<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/","path":"arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/","title":"《ARM Cortex-M3与Cortex-M4权威指南 第3版》第4章 架构"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《ARM Cortex-M3与Cortex-M4权威指南 第3版》第4章 架构 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">4.1 程序员模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81%E5%92%8C%E6%A8%A1%E5%BC%8F"><span class="nav-text">4.1.1 工作状态和模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">4.1.2 寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">4.1.3 特殊寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">4.1.3.1 程序状态寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8primaskfaultmask%E5%92%8Cbasepri"><span class="nav-text">4.1.3.2 寄存器PRIMASK、FAULTMASK和BASEPRI</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8control"><span class="nav-text">4.1.3.3 寄存器CONTROL</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">4.1.4 浮点寄存器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apsr%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="nav-text">4.2 APSR的行为</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97"><span class="nav-text">4.2.1 整数状态标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97q"><span class="nav-text">4.2.2 状态标志Q</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%BF%97ge"><span class="nav-text">4.2.3 标志GE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="nav-text">4.3 存储器系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">4.3.1 内存映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E5%86%85%E5%AD%98"><span class="nav-text">4.3.2 栈内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD"><span class="nav-text">4.4 异常和中断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nvic"><span class="nav-text">4.4.1 NVIC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E8%A1%A8"><span class="nav-text">4.4.2 向量表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86"><span class="nav-text">4.4.3 故障处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-text">4.4.4 系统控制块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95"><span class="nav-text">4.5 调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E4%BD%8D%E5%92%8C%E5%A4%8D%E4%BD%8D%E5%BA%8F%E5%88%97"><span class="nav-text">4.6 复位和复位序列</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《ARM Cortex-M3与Cortex-M4权威指南 第3版》第4章 架构 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《ARM Cortex-M3与Cortex-M4权威指南 第3版》第4章 架构</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-25 00:00:00" itemprop="dateCreated datePublished" datetime="2025-10-25T00:00:00+08:00">2025-10-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-10-27 00:00:00" itemprop="dateModified" datetime="2025-10-27T00:00:00+08:00">2025-10-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/arm/" itemprop="url" rel="index"><span itemprop="name">ARM</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>18k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　Cortex-M3和Cortex-M4处理器都是基于ARMv7-M架构。最初的ARMv7-M架构是在开发Cortex-M3处理器时设计的。当Cortex-M4处理器发布时，该架构扩展为ARMv7E-M (添加了一些指令和特性)。</p><p>　　与其它几乎所有处理器类似，Cortex-M3和Cortex-M4处理器的核心中包含大量用于执行数据处理和控制的寄存器，其中的大多数寄存器都被归类于1个称为<strong>寄存器组</strong>的单元。数据处理指令会指定所需的操作、源寄存器和目的寄存器 (若有必要)。对于ARM架构，若存储器中的数据需要被处理，则需要先将其加载到寄存器组来进行数据处理，然后写回到存储器 (若有必要)，这通常称为<span style="background-color:#ff0">加载-存储</span>架构。通过让寄存器组包含足够多的寄存器，这种设计易于使用，并且允许C编译器生成高效的程序代码 (例如，当执行数据处理时，很多数据变量可以短期内存储在寄存器中，而无需每次使用时都更新到系统存储器并再次读取)。</p><h3 id="程序员模型">4.1 程序员模型</h3><h4 id="工作状态和模式">4.1.1 工作状态和模式</h4><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/operation_states_and_modes.svg" title="operation_states_and_modes"><p>　　Cortex-M3和Cortex-M4处理器有2种工作状态和2种工作模式。此外，Cortex-M3和Cortex-M4处理器还有2种访问级别：特权访问级别和非特权访问级别。特权访问级别可以访问处理器的所有资源，而非特权访问级别只能访问部分资源，并且只能执行部分操作。在有些文档中，非特权访问级别也称为用户状态 (继承自ARM7TDMI的术语)。</p><span id="more"></span><p>　　Cortex-M3和Cortex-M4处理器的2种工作状态分别是<span style="background-color:#ff0">Thumb状态</span>和<span style="background-color:#ff0">调试状态</span>。</p><p>　　● 若处理器正在运行程序代码 (Thumb指令)，则它处于Thumb状态。</p><p>　　● 若处理器因调试器而停止，则它会进入调试状态并停止执行指令。</p><p>　　Cortex-M3和Cortex-M4处理器的2种工作模式分别是<span style="background-color:#ff0">处理函数模式</span>和<span style="background-color:#ff0">线程模式</span>。</p><p>　　● 当处理器执行常规应用程序代码时，它会进入线程模式。在这种情况下，处理器可以处于特权访问级别或非特权访问级别 (由寄存器CONTROL控制)。</p><p>　　● 当处理器执行中断服务例程等异常处理器函数时，它会进入处理函数模式。在这种情况下，处理器总是处于特权访问级别。</p><p>　　软件可以将处理器从特权线程模式切换到非特权线程模式，但无法切回到特权线程模式。若有必要，处理器必须通过异常机制来完成从非特权线程模式到特权线程模式的切换。</p><p>　　特权访问级别和非特权访问级别的分离允许系统设计者通过提供包含关键区域内存访问机制以及级别安全模型机制来开发健壮的嵌入式系统。例如，系统可以包含1个以特权访问级别运行的嵌入式OS内核和任意个以非特权访问级别运行的应用程序任务。通过这种方式，可以使用MPU来设置内存访问权限，以防止应用程序任务损坏OS内核和其他任务使用的内存和外设。当某个应用程序任务崩溃时，剩余应用程序任务和OS内核可以继续运行。</p><p>　　除了内存访问权限和几个特殊指令的访问权限不同之外，特权访问级别的程序员模型和非特权访问级别的程序员模型几乎完全相同 (几乎所有NVIC寄存器的访问都需要特权访问级别)。</p><p>　　线程模式和处理函数模式有类似的程序员模型。但是，线程模式可以切换到使用单独的影子栈指针。这允许应用程序任务的栈内存与OS内核使用的栈分开，进而提升系统的可靠性。</p><p>　　Cortex-M处理器默认以特权线程模式和Thumb状态启动。对于简单应用程序，无需使用非特权线程模式和影子SP。Cortex-M0处理器没有非特权线程模式，而Cortex-M0+处理器将非特权线程模式作为可选项。</p><p>　　调试状态仅用于调试操作，可以通过调试器的断点请求或处理器的调试组件生成的调试事件进入该状态。该状态允许调试器访问或修改处理器寄存器的值。调试器可以访问系统存储器 (包括各种外设)。</p><h4 id="寄存器">4.1.2 寄存器</h4><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/register_bank.svg" title="register_bank"><p>　　Cortex-M3和Cortex-M4处理器的寄存器组包含16个寄存器。其中的13个寄存器作为32位通用目的寄存器，剩余寄存器用于特殊目的。</p><p>　　R0~R12是通用目的寄存器。前8个寄存器也称为<strong>低位寄存器</strong>，后5个寄存器也称为<strong>高位寄存器</strong>。由于指令集的可用空间有限，很多16位指令只能访问低位寄存器。高位寄存器通常与32位指令一起使用，MOV指令等少部分16位指令也能访问高位寄存器。R0~R12的初始值都是未定义的。</p><p>　　R13是<strong>栈指针</strong> (SP)。PUSH和POP操作会使用该寄存器来访问栈内存。从物理角度，存在2个栈指针：<span style="background-color:#ff0">主栈指针</span> (MSP或SP_main) 和<span style="background-color:#ff0">进程栈指针</span> (PSP或SP_process)。MSP是默认栈指针，在复位后或处理器位于处理函数模式时会使用该栈指针。PSP仅用于线程模式。栈指针的选择由寄存器CONTROL决定。对于常规程序，只有1个栈指针是可见的。</p><p>　　MSP和PSP都是32位，但它们的低2位总是为0，对这2个位的写入会被忽略。对于Cortex-M处理器，PUSH和POP始终为32位，并且栈操作中传输的地址必须按照32位对齐。</p><p>　　当应用程序不需要嵌入式OS时，通常不需要使用PSP。很多简单应用程序完全可以仅使用MSP。若涉及嵌入式OS (OS内核使用的栈和应用程序任务使用的栈是分开的)，则通常会使用PSP。PSP的初始值是未定义的，MSP的初始值取自复位序列中内存的第1个字的地址。</p><p>　　R14是<strong>链接寄存器</strong> (LR)，调用函数或子例程时会使用该寄存器来存储返回地址。当函数或子例程调用完成时，控制权会返回给调用函数，并通过将LR的值加载到程序计数器中来恢复调用函数。当调用函数或子例程时，LR的值会自动更新。在调用函数或子例程之前，需要先将LR的值存储在栈中。否则，调用函数时LR的值会丢失。</p><p>　　当处理异常时，LR会自动更新为特殊值EXC_RETURN (异常返回)，该值随后用于在异常处理函数的末尾触发异常返回。</p><p>　　Cortex-M处理器的返回地址值总是为偶数 (最低有效位是0，因为指令必须对齐到32位地址)，但LR的最低有效位是可读和可写的。某些分支/调用操作需要将LR的最低有效位设置为1来表示Thumb状态。</p><p>　　R15是<strong>程序计数器</strong> (PC)，该寄存器是可读和可写的。读PC会返回当前指令的地址加4 (因为流水线设计的特性以及与ARM7TDMI处理器的兼容)。写PC (例如，通过数据传输/处理指令) 会导致分支操作。</p><p>　　指令必须与 (半) 字地址对齐，所以PC的最低有效位是0。但是，当使用某些分支/内存读取指令来更新PC时，需要将PC的新值的最低有效位设置为1来表示Thumb状态。否则，会触发故障异常，因为这表示试图切换到不受支持的ARM指令 (例如，ARM7TDMI中的32位ARM指令)。对于高级编程语言 (包括C和C++)，分支目标的最低有效位的设置由编译器自动处理。</p><p>　　在大多数情况下，分支和调用由专门的指令处理。使用数据处理指令来更新PC则较为少见。但是，PC值对于存储在程序内存中的字面数据很有用。</p><p>　　对于大多数汇编工具，可以通过多个名称来访问寄存器组中的同一寄存器。对于ARM汇编工具等工具，可以使用大写、小写或大小写混合：</p><table><thead><tr><th>寄存器</th><th>可能的寄存器名称</th></tr></thead><tbody><tr><td>R0~R12</td><td>R0~R12或r1~r12</td></tr><tr><td>R13</td><td>R13、r13、SP或sp</td></tr><tr><td>R14</td><td>R14、r14、LR或lr</td></tr><tr><td>R15</td><td>R15、r15、PC或pc</td></tr></tbody></table><p>　　此外，特殊寄存器访问指令 (MRS和MSR) 会使用寄存器名MSP和PSP。</p><h4 id="特殊寄存器">4.1.3 特殊寄存器</h4><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/special_registers.svg" title="special_registers"><p>　　除了寄存器组中的寄存器之外，还有大量特殊寄存器。这些寄存器包含处理器状态，并且定义了工作状态和中断/异常屏蔽。</p><p>　　特殊寄存器没有映射到内存，可以使用MSR和MRS等特殊寄存器访问指令访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRS &lt;reg&gt;, &lt;special_reg&gt; ; 将特殊寄存器的值读取到寄存器</span><br><span class="line">MSR &lt;special_reg&gt;, &lt;reg&gt; ; 将寄存器的值写入到特殊寄存器</span><br></pre></td></tr></table></figure><h5 id="程序状态寄存器">4.1.3.1 程序状态寄存器</h5><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/apsr,epsr,ipsr_and_xpsr.svg" title="apsr,epsr,ipsr_and_xpsr"><table><colgroup><col style="width:10%"><col style="width:89%"></colgroup><thead><tr><th>位</th><th>描述</th></tr></thead><tbody><tr><td>N</td><td>负标志</td></tr><tr><td>Z</td><td>零标志</td></tr><tr><td>C</td><td>进位 (或非借位) 标志</td></tr><tr><td>V</td><td>溢出标志</td></tr><tr><td>Q</td><td>粘性饱和标志 (在ARMv6-M中不可用)</td></tr><tr><td>GE[3:0]</td><td>每个字节通路的大于或等于标志 (仅限于ARMv7E-M；在ARMv6-M和Cortox-M3中不可用)</td></tr><tr><td>ICI/IT</td><td>中断继续指令 (ICI) 位，条件执行的IF-THEN指令状态位 (在ARMv6-M中不可用)</td></tr><tr><td>T</td><td>Thumb状态，总是为1，试图清除该位会导致故障异常</td></tr><tr><td>异常号</td><td>表示处理器正在处理的异常</td></tr></tbody></table><p>　　<strong>程序状态寄存器</strong>由<strong>应用程序PSR</strong> (APSR)、<strong>执行PSR</strong> (EPSR) 和<strong>中断PSR</strong> (IPSR) 组成。这3个寄存器可以通过1个组合寄存器访问，在一些文档中称为xPSR。对于ARM汇编器，访问xPSR使用的符号是PSR：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRS r0, PSR</span><br><span class="line">MSR PSR, r0</span><br></pre></td></tr></table></figure><p>　　此外，也可以访问独立的PSR：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MRS r0, APSR</span><br><span class="line">MRS r0, IPSR</span><br><span class="line">MSR APSR, r0</span><br></pre></td></tr></table></figure><p>　　此外，软件代码无法直接使用MRS或MSR来访问EPSR。IPSR是只读的，可以从xPSR中读取。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/comparing_psr_of_various_arm_architectures.svg" title="comparing_psr_of_various_arm_architectures"><p>　　APSR和EPSR的部分位字段在ARMv6-M架构 (例如，Cortex-M0处理器) 中不可用，并且与ARM7TDMI等经典处理器有很大的不同。如果将其与ARM7中的当前程序状态寄存器 (CPSR) 比较，会发现ARM7中的某些位字段不再使用。模式 (M) 字段不再使用是因为Cortex-M3不具备ARM7中定义的工作模式。Thumb位 (T) 字段移动到了位24。中断状态 (I和F) 位被新的中断屏蔽寄存器 (PRIMASK) 所取代，并与PSR分离。</p><h5 id="寄存器primaskfaultmask和basepri">4.1.3.2 寄存器PRIMASK、FAULTMASK和BASEPRI</h5><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/primask,faultmask_and_basepri_registers.svg" title="primask,faultmask_and_basepri_registers"><p>　　寄存器PRIMASK、FAULTMASK和BASEPRI都用于异常/中断屏蔽。每个异常 (包括中断) 有1个优先级，其数值越小，优先级越高。这些特殊寄存器用于根据优先级屏蔽异常，只能在特权访问级别下被访问这些寄存器 (在非特权访问级别下，写这些寄存器会被忽略，读这些寄存器会返回0)。在默认情况下，这些寄存器都是0，表示屏蔽 (禁用异常/中断) 未被启用。</p><p>　　寄存器PRIMASK是1位的中断屏蔽寄存器。当该寄存器被设置后，会屏蔽除NMI和硬故障 (HardFault) 异常之外的所有异常。实际上，它是将当前异常优先级设置为0，这是可编程异常/中断的最高优先级。</p><p>　　寄存器PRIMASK最常见的用途是为实时进程禁用所有中断。当实时进程完成后，该寄存器需要被清除 (以启用中断)。</p><p>　　寄存器FAULTMASK与PRIMASK相似，但会屏蔽硬故障异常。实际上，它会将当前异常优先级设置为-1。故障处理代码可以通过该寄存器来抑制故障处理期间进一步的故障 (仅限于几种类型) 的触发 (例如，该寄存器可用于绕过MPU或总线故障)，这可能使故障处理代码更容易执行补救措施。此外，FAULTMASK在异常返回后会自动被清除。</p><p>　　为了提供更灵活的中断屏蔽，ARMv7-M架构还提供了寄存器BASEPRI。该寄存器会根据优先级屏蔽异常/中断，并且其长度取决于设计中实现的优先级数 (由微控制器供应商提供)。大多数Cortex-M3和Cortex-M4微控制器有8或16个可编程中断优先级，对应的BASEPRI长度为3或4位。当该寄存器被设置为0时，它将被禁用。当该寄存器被设置为非0值时，它会屏蔽不高于指定优先级的异常 (包括中断)。</p><p>　　ARMv6-M架构 (例如，Cortex-M0) 没有寄存器FAULTMASK和BASEPRI。</p><p>　　CMSIS-Core提供了大量用于访问寄存器PRIMASK、FAULTMASK和BASEPRI的C函数 (只能在特权访问级别下访问这些寄存器)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = __get_BASEPRI();   <span class="comment">/* 读寄存器BASEPRI */</span></span><br><span class="line">x = __get_PRIMARK();   <span class="comment">/* 读寄存器PRIMASK */</span></span><br><span class="line">x = __get_FAULTMASK(); <span class="comment">/* 读寄存器FAULTMASK */</span></span><br><span class="line">__set_BASEPRI(x);      <span class="comment">/* 设置寄存器BASEPRI的值 */</span></span><br><span class="line">__set_PRIMASK(x);      <span class="comment">/* 设置寄存器PRIMASK的值 */</span></span><br><span class="line">__set_FAULTMASK(x);    <span class="comment">/* 设置寄存器FAULTMASK的值 */</span></span><br><span class="line">__disable_irq();       <span class="comment">/* 设置寄存器PRIMASK，禁用IRQ */</span></span><br><span class="line">__enable_irq();        <span class="comment">/* 清除寄存器PRIMASK，启用IRQ */</span></span><br></pre></td></tr></table></figure><p>　　也可以通过汇编代码来访问这些异常屏蔽寄存器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MRS r0, BASEPRI</span><br><span class="line">MRS r0, PRIMASK</span><br><span class="line">MRS r0, FAULTMASK</span><br><span class="line">MSR BASEPRI, r0</span><br><span class="line">MSR PRIMASK, r0</span><br><span class="line">MSR FAULTMASK, r0</span><br></pre></td></tr></table></figure><p>　　此外，改变处理器状态指令 (CPS) 也能用于设置或清除寄存器PRIMASK和FAULTMASK的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CPSIE i ; 启用中断 (清除寄存器PRIMASK)</span><br><span class="line">CPSID i ; 禁用中断 (设置寄存器PRIMASK)</span><br><span class="line">CPSIE f ; 启用中断 (清除寄存器FAULTMASK)</span><br><span class="line">CPSID f ; 禁用中断 (设置寄存器FAULTMASK)</span><br></pre></td></tr></table></figure><h5 id="寄存器control">4.1.3.3 寄存器CONTROL</h5><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/control_register_in_cortex-m3,cortex-m4_and_cortex-m4_with_fpu.svg" title="control_register_in_cortex-m3,cortex-m4_and_cortex-m4_with_fpu"><table><colgroup><col style="width:15%"><col style="width:84%"></colgroup><thead><tr><th>位</th><th>功能</th></tr></thead><tbody><tr><td>nPRIV (位0)</td><td>定义线程模式下的访问级别：若该位为0 (默认)，则线程模式下为特权访问级别；若该位为1，则线程模式下为非特权访问级别。</td></tr><tr><td>SPSEL (位1)</td><td>定义栈指针的选择：若该位为0 (默认)，则线程模式使用MSP；若该位为1，则线程模式使用PSP。在处理函数模式下，该位总是为0，并且对该位的写入会被忽略。</td></tr><tr><td>FPCA (位2)</td><td>浮点上下文激活 (仅限于带有FPU的Cortex-M4)。异常处理机制使用该位来确定发生异常时是否需要保存FPU中的寄存器。若该位为0 (默认)，则表示当前上下文未使用FPU，所以无需保存浮点寄存器；若该位为1，则表示FPU在当前上下文使用了浮点指令，所以需要保存浮点寄存器。当执行浮点指令时，该位会自动被设置。当进入异常时，硬件会清除该位。浮点寄存器的保存方法有多种。</td></tr></tbody></table><p>　　寄存器CONTROL定义了栈指针的选择 (MSP/PSP) 和线程模式下的访问级别 (特权/非特权)。</p><p>　　对于带有FPU的Cortex-M4处理器，寄存器CONTROL中的1位会用于表示当前上下文 (当前执行的代码) 是否使用了FPU。</p><p>　　对于ARMv6-M，nPRIV和非特权访问级别的支持取决于具体实现。第1代Cortex-M0和Cortex-M1产品没有这些功能，并且Cortex-M0+将其作为可选功能。</p><p>　　寄存器CONTROL只能在特权访问级别下被修改，并且可以在特权和非特权访问级别下被读取。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/stack_pointer_selection.svg" title="stack_pointer_selection"><p>　　在复位后，寄存器CONTROL为0。这表示线程模式使用MSP作为栈指针，并且处于特权访问级别。特权线程模式下的程序可以通过写入寄存器CONTROL来切换栈指针或切换到非特权访问级别。但是，一旦nPRIV (位0) 被设置，运行在线程模式下的程序将无法再访问寄存器CONTROL。</p><p>　　非特权访问级别下的程序不能将自己切换到特权访问级别，这对提供基本的安全使用模型至关重要 (例如，嵌入式系统可能包含运行在非特权访问级别下的不受信任的应用程序，并且必须限制这些应用程序的访问权限，以防止安全漏洞和不可靠的应用程序破坏整个系统)。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/switching_between_privileged_thread_mode_and_unprivileged_thread_mode.svg" title="switching_between_privileged_thread_mode_and_unprivileged_thread_mode"><p>　　当需要从非特权线程模式切换到特权线程模式时，必须使用使用异常机制。在异常处理期间，异常处理函数会清除位nPRIV。当回到线程模式时，处理器将处于特权访问级别。</p><p>　　当使用嵌入式OS时，可以在每次切换上下文时重新编程CONTRO寄存器，以允许某些应用程序任务以特权访问级别运行，而其他应用程序任务以非特权访问级别运行。</p><table><colgroup><col style="width:7%"><col style="width:7%"><col style="width:85%"></colgroup><thead><tr><th>nPRIV</th><th>SPSEL</th><th>使用场景</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>简单应用程序——整个应用程序运行在特权访问级别。主程序和中断处理函数共用1个栈 (仅使用MSP)。</td></tr><tr><td>0</td><td>1</td><td>带有嵌入式OS的应用程序，并且当前执行的任务运行在特权线程模式。当前任务使用PSP，而OS内核和异常处理函数使用MSP。</td></tr><tr><td>1</td><td>1</td><td>带有嵌入式OS的应用程序，并且当前执行的任务运行在非特权线程模式。当前任务使用PSP，而OS内核和异常处理函数使用MSP。</td></tr><tr><td>1</td><td>0</td><td>线程模式任务运行在非特权访问级别，并且使用MSP，这可以在处理函数模式下观察到。但是，该设置不太可能用于用户任务，因为对于大多数嵌入式OS，应用程序任务的栈与OS内核和异常处理函数使用的栈是分开的。</td></tr></tbody></table><p>　　nPRIV和SPSEL的设置是正交的。虽然有4种不同的nPRIV和SPSEL组合，但实际应用程序通常仅使用前3种。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/simple_applications_do_not_require_unprivileged_thread_mode.svg" title="simple_applications_do_not_require_unprivileged_thread_mode"><p>　　对于大多数没有嵌入式OS的简单应用程序，无需修改寄存器CONTROL的值。整个应用程序运行在特权访问级别，并且仅使用MSP。</p><p>　　为了在C中访问寄存器CONTROL，符合CMSIS的设备驱动程序库会提供以下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = __get_CONTROL(); <span class="comment">/* 读取寄存器CONTROL的值 */</span></span><br><span class="line">__set_CONTROL(x);    <span class="comment">/* 将寄存器CONTROL的值设置为x */</span></span><br></pre></td></tr></table></figure><p>　　当修改寄存器CONTROL的值时，需要注意以下2点：</p><p>　　● 对于带有FPU的Cortex-M4处理器或带有FPU的ARMv7-M处理器变体，位FPCA会由于浮点指令的出现而自动被设置。若程序包含浮点运算，并且位FPCA被意外清除后发生了中断，则FPU的寄存器中的数据不会被异常进入序列保存，并且可能会被中断处理函数覆写。在这种情况下，程序在从中断返回后可能不会正确地恢复执行。</p><p>　　● 从架构角度，修改寄存器CONTROL后应该使用指令同步屏障 (ISB) 指令或符合CMSIS的驱动程序中的函数<code>__ISB()</code>来确保修改后的效果适用于后续代码。由于Cortex-M3、Cortex-M4、Cortex-M0和Cortex-M0+的流水线很简单，所以省略该操作不会造成任何问题。</p><p>　　为了在汇编中访问寄存器CONTROL，需要使用MRS和MSR指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRS r0, CONTROL ; 将CONTROL读取到r0</span><br><span class="line">MSR CONTROL, r0 ; 将r0写入到CONTROL</span><br></pre></td></tr></table></figure><p>　　此外，可以通过检查寄存器IPSR和CONTROL来判断当前的执行级别是否具有特权：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 是否处于特权访问级别</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return int 1表示有特权，0表示无特权</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">in_privileged</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__get_IPSR() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((__get_CONTROL() &amp; <span class="number">0x1</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="浮点寄存器">4.1.4 浮点寄存器</h4><p>　　Cortex-M4处理器包含可选的FPU。除了为浮点数据处理提供额外的寄存器之外，FPU还提供了<strong>浮点状态和控制寄存器</strong> (FPSCR)。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/registers_in_the_fpu.svg" title="registers_in_the_fpu"><p>　　32位寄存器S0~S31 (S表示单精度) 可以通过浮点指令访问，也可以通过符号D0~D15 (D表示双字/双精度) 成对访问。尽管Cortex-M4中的FPU不支持双精度计算，但仍然使用浮点指令来传输双精度数据。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/fpscr.svg" title="fpscr"><table><colgroup><col style="width:7%"><col style="width:92%"></colgroup><thead><tr><th>位</th><th>描述</th></tr></thead><tbody><tr><td>N</td><td>负标志 (由浮点比较运算更新)</td></tr><tr><td>Z</td><td>零标志 (由浮点比较运算更新)</td></tr><tr><td>C</td><td>进位/借位标志 (由浮点比较运算更新)</td></tr><tr><td>V</td><td>溢出标志 (由浮点比较运算更新)</td></tr><tr><td>AHP</td><td>备用半精度控制位：0表示IEEE半精度格式 (默认)，1表示备用半精度格式</td></tr><tr><td>DN</td><td>默认非数字 (NaN) 模式控制位：0表示NaN操作数会传播到浮点运算的输出 (默认)，1表示任何涉及NaN的运算都将返回默认的NaN</td></tr><tr><td>FZ</td><td>清零模式控制位：0表示禁用清零模式 (默认)，1表示启用清零模式</td></tr><tr><td>RMode</td><td>舍入默认控制字段 (几乎所有浮点指令都使用特定的舍入模式)：00表示向最近值舍入 (RN) 模式 (默认)，01表示向正无穷舍入 (RP) 模式，10表示向负无穷舍入 (RM) 模式，11表示向零舍入 (RZ) 模式</td></tr><tr><td>IDC</td><td>输入非规则累积异常位 (发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td></tr><tr><td>IXC</td><td>不精确累积异常位 (发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td></tr><tr><td>UFC</td><td>下溢出累积异常位 (发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td></tr><tr><td>OFC</td><td>上溢出累积异常位 (发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td></tr><tr><td>DZC</td><td>除以0累积异常位 (发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td></tr><tr><td>IOC</td><td>无效运算累积异常位 (发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td></tr></tbody></table><p>　　FPSCR包含各种位是为了定义一些浮点运算行为以及提供关于浮点运算结果的状态信息。在默认情况下，行为配置符合IEEE 754单精度运算。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/cpacr.svg" title="cpacr"><p>　　除了浮点寄存器组和FPSCR之外，FPU还向系统添加了几个额外的内存映射寄存器。例如，协处理器访问控制寄存器 (CPACR) 用于启用或禁用FPU。FPU默认禁用 (为了降低功耗)，在使用浮点指令之前必须先编程CPACR来启用FPU。</p><p>　　对于带有符合CMSIS的设备驱动程序的C编程环境，可以通过以下代码启用FPU：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCB-&gt;CPACR |= <span class="number">0xF</span> &lt;&lt; <span class="number">20</span>; <span class="comment">/* 启用对FPU的完全访问 */</span></span><br></pre></td></tr></table></figure><p>　　对于汇编，可以通过以下指令来启用FPU：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LDR R0,=0xE000ED88  ; 将R0设置为CPACR的地址</span><br><span class="line">LDR R1,=0x00F00000  ; R1 = 0xF &lt;&lt; 20</span><br><span class="line">LDR R2 [R0] ; 读取CPACR的值</span><br><span class="line">ORRS R2, R2, R1 ; 设置位</span><br><span class="line">STR R2,[R0] ; 将修改后的值写回到CPACR</span><br></pre></td></tr></table></figure><h3 id="apsr的行为">4.2 APSR的行为</h3><p>　　APSR包含3组状态标志：整数运算的状态标志 (N、Z、C和V)、饱和算术的状态标志 (Q) 以及SIMD操作的状态标志 (GE)。</p><h4 id="整数状态标志">4.2.1 整数状态标志</h4><table><colgroup><col style="width:11%"><col style="width:88%"></colgroup><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>N (位31)</td><td>设置指令结果的位31 (1表示负值，0表示正值或0)</td></tr><tr><td>Z (位30)</td><td>当指令的结果为0或比较指令的操作数相同时，会将该标志设置为1</td></tr><tr><td>C (位29)</td><td>结果的进位标志 (对于无符号加法运算，溢出时会将该标志设置为1；对于无符号减法运算，该标志与借位输出状态相反。此外，移位和循环运算也会更新该标志)</td></tr><tr><td>V (位28)</td><td>结果的溢出标志 (对于有符号加减运算，有符号溢出时会将该标志设置为1)</td></tr></tbody></table><p>　　Cortex-M处理器有4个整数状态标志，它们与很多其他处理器架构的ALU状态标志类似。这些标志受通用数据处理指令的影响，并且对控制条件分支和条件执行很重要。此外，标志C也能用于加减运算。</p><table><colgroup><col style="width:35%"><col style="width:64%"></colgroup><thead><tr><th>运算</th><th>结果和标志</th></tr></thead><tbody><tr><td><code>0x70000000 + 0x70000000</code></td><td>结果为<code>0xE0000000</code>，N = 1，Z = 0，C = 0，V = 1</td></tr><tr><td><code>0x90000000 + 0x90000000</code></td><td>结果为<code>0x30000000</code>，N = 0，Z = 0，C = 1，V = 1</td></tr><tr><td><code>0x80000000 + 0x80000000</code></td><td>结果为<code>0x00000000</code>，N = 0，Z = 1，C = 1，V = 1</td></tr><tr><td><code>0x00001234 - 0x00001000</code></td><td>结果为<code>0x00000234</code>，N = 0，Z = 0，C = 1，V = 0</td></tr><tr><td><code>0x00000004 - 0x00000005</code></td><td>结果为<code>0xFFFFFFFF</code>，N = 1，Z = 0，C = 0，V = 0</td></tr><tr><td><code>0xFFFFFFFF - 0xFFFFFFFC</code></td><td>结果为<code>0x00000003</code>，N = 0，Z = 0，C = 1，V = 0</td></tr><tr><td><code>0x80000005 - 0x80000004</code></td><td>结果为<code>0x00000001</code>，N = 0，Z = 0，C = 1，V = 0</td></tr><tr><td><code>0x70000000 - 0xF0000000</code></td><td>结果为<code>0x80000000</code>，N = 1，Z = 0，C = 0，V = 1</td></tr><tr><td><code>0xA0000000 - 0xA0000000</code></td><td>结果为<code>0x00000000</code>，N = 0，Z = 1，C = 1，V = 0</td></tr></tbody></table><p>　　对于ARMv7-M和ARMv7E-M架构，大多数16位指令会影响这4个整数状态标志。对于大多数32位指令，指令编码中会有1位用于定义是否应该更新APSR，并且其中的某些指令不会更新标志V或C (例如，乘法指令只会更新标志N和Z)。</p><p>　　除了条件分支和条件指令代码之外，APSR的进位标志可用于将加减运算扩展到32位 (例如，当加法运算的操作数都是64位整数时，可以将低32位加法运算的进位标志作为高32位加法运算的额外输入)。</p><p>　　所有ARM处理器 (包括Cortex-M0处理器) 都提供了这4个整数状态标志。</p><h4 id="状态标志q">4.2.2 状态标志Q</h4><p>　　标志Q表示在饱和算术运算或饱和调整运算期间是否发生饱和。ARMv7-M (例如，Cortex-M3和Cortex-M4处理器) 提供了该标志，但ARMv6-M (例如，Cortex-M0处理器) 未提供该标志。当该标志被设置后，该标志会保持设置状态，直到通过软件写入APSR来清除该标志。饱和算术/调整运算不会清除该标志。因此，可以通过该标志来判断饱和算术/调整运算序列结束时是否发生饱和 (无需在逐一检查饱和状态)。</p><p>　　饱和算术对数字信号处理很有用。在某些情况下，用于存储计算结果的寄存器的长度可能不够，从而导致向上或向下溢出。若使用了常规算术指令，则结果的最高有效位将会丢失，并且导致输出严重失真。饱和算术不是简单地截断最高有效位，而是强制将结果设置为最大值 (向上溢出) 或最小值 (向下溢出) 来降低信号失真的影响。</p><p>　　触发饱和的实际最大值和最小值取决于使用的指令。在大多数情况下，饱和算术指令都是以 "Q" 开头 (例如，对于指令QADD16，若发生饱和，则设置标志Q；否则，不修改标志Q)。</p><p>　　Cortex-M3处理器提供了部分饱和调整指令，Cortex-M4处理器了全套饱和算术指令 (包括Cortex-M3处理器提供的饱和调整指令)。</p><h4 id="标志ge">4.2.3 标志GE</h4><table><colgroup><col style="width:36%"><col style="width:63%"></colgroup><thead><tr><th>SIMD操作</th><th>结果</th></tr></thead><tbody><tr><td>SADD16、SSUB16、USUB16、SASX和SSAX</td><td>若低半字结果大于等于0，则GE的低2位为11；否则，GE的低2位为00。<br>若高半字结果大于等于0，则GE的高2位为11；否则，GE的高2位为00。</td></tr><tr><td>UADD16</td><td>若低半字结果大于等于<code>0x10000</code>，则GE的低2位为11；否则，GE的低2位为00。<br>若高半字结果大于等于<code>0x10000</code>，则GE的高2位为11；否则，GE的高2位为00。</td></tr><tr><td>SADD8、SSUB8和USUB8</td><td>若字节0结果大于等于0，则GE的最低位为1；否则，GE的最低位为0。<br>若字节1结果大于等于0，则GE的次低位为1；否则，GE的次低位为0。<br>若字节2结果大于等于0，则GE的次高位为1；否则，GE的次高位为0。<br>若字节3结果大于等于0，则GE的最高位为1；否则，GE的最高位为0。</td></tr><tr><td>UADD8</td><td>若字节0结果大于等于<code>0x100</code>，则GE的最低位为1；否则，GE的最低位为0。<br>若字节1结果大于等于<code>0x100</code>，则GE的次低位为1；否则，GE的次低位为0。<br>若字节2结果大于等于<code>0x100</code>，则GE的次高位为1；否则，GE的次高位为0。<br>若字节3结果大于等于<code>0x100</code>，则GE的最高位为1；否则，GE的最高位为0。</td></tr><tr><td>UASX</td><td>若低半字结果大于等于0，则GE的低2位为11；否则，GE的低2位为00。<br>若高半字结果大于等于<code>0x10000</code>，则GE的高2位为11；否则，GE的低2位为00。</td></tr><tr><td>USAX</td><td>若低半字结果大于等于<code>0x10000</code>，则GE的低2位为11；否则，GE的低2位为00。<br>若高半字结果大于等于0，则GE的高2位为11；否则，GE的低2位为00。</td></tr></tbody></table><p>　　GE (大于等于) 是Cortex-M4处理器的APSR中的4位标志。该标志由SIMD指令更新，在大多数情况下，GE的每个位分别代表SIMD的每个字节的正溢出或负溢出。对于带有16位数据的SIMD指令，位0和1由结果或低半字结果控制，位2和3由高半字结果控制。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/sel_operation.svg" title="sel_operation"><p>　　标志GE由SEL指令使用，该指令会根据GE的每个位来复用2个源寄存器的字节值。当结合多条SIMD指令和单条SEL指令时，可以在SIMD指令排列中创建简单的条件数据选择来获取更好的性能。</p><h3 id="存储器系统">4.3 存储器系统</h3><p>　　Cortex-M3和Cortex-M4处理器拥有以下存储器系统特性：</p><p>　　● 4GB线性地址空间——通过32位寻址，ARM处理器可以访问高达4GB的内存空间。虽然很多嵌入式系统需要超过1MB的内存，但32位寻址能力可以保证未来的升级和扩展可能性。Cortex-M3和Cortex-M4处理器提供了使用AHB LITE的32位总线。该总线允许通过合适的存储器接口控制器来连接8/16/32位的存储器设备。</p><p>　　● 架构定义的内存映射——4GB的内存被划分为多个区域，用于各种预定义的存储器和外设用途。这允许处理器设计能够进行性能优化 (例如，Cortex-M3和Cortex-M4处理器有多个总线接口，允许在访问CODE区域的程序代码期间对SRAM或外设区域进行数据操作)。</p><p>　　● 支持大端和小端内存系统——Cortex-M3和Cortex-M4处理器能够适用于大端或小端内存系统。实际上，微控制器产品通常被设计为仅使用其中的1种字节顺序配置。</p><p>　　● 可选的位带访问——若使用了位带 (由微控制器/SoC供应商决定)，内存映射中的2个1MB区域可以通过2个位带区域进行位寻址。这允许对SRAM或外设地址空间中的单个位进行原子访问。</p><p>　　● 写缓冲区——当对可缓冲内存区域的写入传输需要多个周期时，该传输可以通过Cortex-M3和Cortex-M4处理器内核的写缓冲区进行缓冲，以便处理器进行执行下一条指令 (若有需要)。这允许更高的程序执行速度。</p><p>　　● 可选的MPU——MPU是定义了各种内存区域的访问权限的可编程单元。Cortex-M3和Cortex-M4处理器的MPU支持8个可编程区域，并且可以与嵌入式OS一起使用来增加系统的健壮性。</p><p>　　● 支持未对齐传输——所有支持ARMv7-M架构的处理器都支持未对齐的数据传输。</p><p>　　Cortex-M处理器的总线接口是通用总线接口，并且能够通过存储控制器连接到不同类型和大小的存储器。微控制器的存储器系统包含多种类型的存储器：用于程序代码的闪存、用于数据的静态RAM (SRAM) 以及仅用于某些场景的电可擦除只读存储器 (EEPROM)。在大多数情况下，这些存储器位于片上，并且实际的存储器接口细节对软件开发者是透明的。因此，软件开发者只需要知道程序存储器和SRAM的地址和大小。</p><h4 id="内存映射">4.3.1 内存映射</h4><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/memory_map.svg" title="memory_map"><p>　　Cortex-M处理器的4GB地址空间被划分为大量内存区域。这种分区基于使用场景，以便不同的区域分别用于程序代码访问 (例如，CODE区域)、数据访问 (例如，SRAM区域)、外设 (例如，外设区域) 以及处理器的内部控制和调试组件 (例如，私有外设总线)。</p><p>　　该架构还具有高度灵活性，允许将内存区域用于其他用途 (例如，程序可以在CODE区域或SRAM区域执行，微控制器也可以将SRAM区域集成到CODE区域)。</p><p>　　在实际中，很多微控制器设备只会使用程序闪存、SRAM和外设区域的一小部分，并且不会使用某些区域。存储器大小和外设地址位置因微控制器而异。</p><p>　　所有Cortex-M处理器的内存映射都是一致的 (例如，NVIC的寄存器、处理器配置寄存器以及调试组件寄存器总是位于PPB地址空间)。这使得在Cortex-M设备之间移植软件更容易，并提供了软件的可重用性。Cortex-M3和Cortex-M4设备的调试工作方式的一致也为工具供应商带来了便利。</p><h4 id="栈内存">4.3.2 栈内存</h4><p>　　与几乎其他所有处理器架构一样，Cortex-M处理器需要栈内存来运行，并且使用栈指针。栈是允许将一部分内存用作后进先出的数据存储缓冲区的内存使用机制。ARM处理器使用主系统内存进行栈内存操作，使用PUSH指令将数据存储在栈中，使用POP指令从栈中检索数据。当前使用的栈指针会根据PUSH和POP操作自动调整。</p><p>　　栈可用于<span style="background-color:#ff0">临时存储函数使用寄存器进行数据处理时的原始数据</span> (这些数据会在函数返回时恢复，所以调用函数不会丢失数据)、<span style="background-color:#ff0">传递函数和子例程的信息</span>、<span style="background-color:#ff0">存储局部变量</span>以及<span style="background-color:#ff0">在发生异常时保存处理器状态和寄存器值</span>。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/stack_push_and_pop.svg" title="stack_push_and_pop"><p>　　当处理器启动时，栈指针被设置为为栈内存保留的内存空间的末尾。</p><p>　　● 对于PUSH操作，处理器会先减少SP，然后将值存储在SP指向的内存位置。在此期间，SP指向的最后1个数据会被压入栈中。</p><p>　　● 对于POP操作，SP指向的内存位置的值会被读取，然后SP的值会自动增加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUSH (R4) ; 将R4压入栈并调整SP</span><br><span class="line">PUSH (R5) ; 将R5压入栈并调整SP</span><br><span class="line">PUSH (R6) ; 将R6压入栈并调整SP</span><br><span class="line">; 执行任务</span><br><span class="line">POP (R4) ; 将R4弹出栈并调整SP</span><br><span class="line">POP (R5) ; 将R5弹出栈并调整SP</span><br><span class="line">POP (R6) ; 将R6弹出栈并调整SP</span><br><span class="line">BX LR ; 返回</span><br></pre></td></tr></table></figure><p>　　PUSH和POP指令最常见的用途是调用函数/子例程时保持寄存器组的内容。当函数调用开始时，某些寄存器的内容可以通过PUSH指令保存在栈中，然后函数返回时通过POP指令恢复寄存器的值。对于每个PUSH操作，必须有1个对应的POP操作，并且POP的地址应与PUSH操作的地址匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUSH (R4-R6) ; 将R4、R5和R6压入栈</span><br><span class="line">; 执行任务</span><br><span class="line">POP (R4-R6) ; 将R4、R5和R6弹出栈</span><br><span class="line">BX LR ; 返回</span><br></pre></td></tr></table></figure><p>　　每个PUSH和POP指令可以传输多个数据到栈内存。因为寄存器组中的寄存器都是32位，栈PUSH和POP会至少传输1字 (4字节) 的数据，并且地址总是会对齐到4字节边界。SP的低2位总是为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH (R4-R6, LR) ; 保持寄存器 (包括链接寄存器)</span><br><span class="line">; 执行任务</span><br><span class="line">POP (R4-R6, PC) ; 恢复寄存器并返回</span><br></pre></td></tr></table></figure><p>　　返回和POP操作可以结合起来，即先将LR压入栈，然后在函数/子例程结束时将其弹出到PC。</p><p>　　将寄存器状态保存在栈的操作称为<span style="background-color:#ff0">入栈</span>，将栈中的状态恢复到寄存器的操作称为<span style="background-color:#ff0">出栈</span>。对于使用嵌入式OS的嵌入式系统，应用程序栈和内核栈通常使用不同的内存区域，入栈和出栈阶段使用的是PSP。除了可以防止应用程序任务中的栈损坏或错误破坏操作系统的栈之外，栈分离的设计还简化了操作系统设计，从而允许更快的上下文切换。</p><p>　　尽管在任何时间只有1个SP是可见的 (通过SP或R13访问)，但可以直接访问MSP或PSP，而不会对SP/R13产生混淆。对于特权级别，可以使用以下CMSIS函数访问MSP和PSP：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = __get_MSP(); <span class="comment">/* 读MSP */</span></span><br><span class="line">__set_MSP(x);    <span class="comment">/* 将MSP设置为x */</span></span><br><span class="line">x = __get_PSP(); <span class="comment">/* 读PSP */</span></span><br><span class="line">__set_PSP(x);    <span class="comment">/* 将PSP设置为x */</span></span><br></pre></td></tr></table></figure><p>　　通常，不应该在C函数中修改当前SP的值，因为部分栈内存可能用于存储局部变量或其他数据。为了在汇编中访问MSP和PSP，可以使用以下MSR和MRS指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MRS R0, MSP ; 将MSP读到R0</span><br><span class="line">MSR MSP, R0 ; 将R0写到MSP</span><br><span class="line">MRS R0, PSP ; 将PSP读到R0</span><br><span class="line">MSR PSP, R0 ; 将R0写到PSP</span><br></pre></td></tr></table></figure><p>　　大多数应用程序无需显示地访问MSP和PSP。访问MSP和PSP通常是嵌入式OS所需要的 (例如，通过MRS指令读取PSP的值，OS可以读取应用程序任务中API压入栈的数据)。此外，在上下文切换期间，OS的上下文切换代码会更新PSP。</p><p>　　当上电后，MSP由处理器硬件读取向量表来自动初始化。PSP不会自动初始化，必须在使用前由软件初始化。</p><h3 id="异常和中断">4.4 异常和中断</h3><p>　　异常是能够改变程序流的事件。当发生异常时，处理器会挂起当前执行流，并执行<span style="background-color:#ff0">异常处理函数</span>的一部分。当异常处理函数的执行完成后，处理器会恢复程序的执行。对于ARM架构，中断属于异常。中断通常由外设或外部输入生成，并且在某些情况下，软件也可以触发中断。中断的异常处理函数称为<strong>中断服务例程</strong> (ISR)。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/various_exception_sources.svg" title="various_exception_sources"><p>　　Cortex-M处理器包含大量异常源。NVIC负责处理异常。NVIC能够处理多个<strong>中断请求</strong> (IRQ) 和1个<strong>不可屏蔽中断</strong> (NMI)。IRQ通常由片上外设或通过I/O端口的外部中断输入生成。NMI可供看门狗定时器或掉电检测器 (当电源电压降低至某个水平以下时向处理器发送警告的电压监控单元) 使用。处理器内部的SysTick定时器可以周期性地生成定时器IRQ，可供嵌入式OS用于计时，或在不需要OS的应用程序中用于简单的计时控制。</p><p>　　处理器本身也是异常事件源。这些异常事件可能是指示系统错误情况的故障事件，也可能是由软件生成以支持嵌入式OS运行的异常。下表列出了各种异常类型：</p><table><colgroup><col style="width:6%"><col style="width:11%"><col style="width:12%"><col style="width:9%"><col style="width:61%"></colgroup><thead><tr><th>异常号</th><th>CMISI中断号</th><th>异常类型</th><th>优先级</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td></td><td>复位</td><td>-3 (最高)</td><td></td></tr><tr><td>2</td><td>-14</td><td>NMI</td><td>-2</td><td>不可屏蔽中断</td></tr><tr><td>3</td><td>-13</td><td>硬故障</td><td>-1</td><td>各类故障 (当对应的故障处理函数由于被禁用或被异常屏蔽而无法激活时)</td></tr><tr><td>4</td><td>-12</td><td>内存管理故障</td><td>可设置</td><td>由于MPU违规或无效访问</td></tr><tr><td>5</td><td>-11</td><td>总线故障</td><td>可设置</td><td>从总线系统收到错误响应 (由于指令预取中止或数据访问错误)</td></tr><tr><td>6</td><td>-10</td><td>使用故障</td><td>可设置</td><td>通常是因为无效指令或无效状态转换尝试</td></tr><tr><td>7~10</td><td></td><td></td><td></td><td>保留</td></tr><tr><td>11</td><td>-5</td><td>SVC</td><td>可设置</td><td>通过SVC指令进行管理程序调用</td></tr><tr><td>12</td><td>-4</td><td>调试监视器</td><td>可设置</td><td>用于基于软件的调试</td></tr><tr><td>13</td><td></td><td></td><td></td><td>保留</td></tr><tr><td>14</td><td>-2</td><td>PendSV</td><td>可设置</td><td>系统服务的挂起请求</td></tr><tr><td>15</td><td>-1</td><td>SYSTICK</td><td>可设置</td><td>系统节拍定时器</td></tr><tr><td>16~255</td><td>0~239</td><td>IRQ</td><td>可设置</td><td>IRQ输入#0~239</td></tr></tbody></table><p>　　每种异常源有1个异常号。异常号1~15属于系统异常，异常号16及以上用于中断。Cortex-M3和Cortex-M4处理器的NVIC设计支持最多240个异常输入。但是，实际设计中实现的中断输入数量通常是16~100，因为这样做可以减小芯片体积和降低功耗。</p><p>　　异常号出现在各种寄存器中 (包括IPSR)，并且用于确定异常向量地址。异常向量存储在向量表中，处理器会通过读向量表来获取异常进入序列中的异常处理函数的起始地址。此外，异常号不同于CMSIS设备驱动程序库中的中断号。对于CMSIS设备驱动程序库，中断号从0开始，而系统异常号为负值。</p><p>　　与ARM7TDMI等经典ARM处理器相反，Cortex-M处理器没有快速中断 (FIQ)。但是，Cortex-M3和Cortex-M4处理器的中断延迟很低 (12个时钟周期)，所以不会产生任何问题。</p><p>　　复位是特殊类型的异常。当处理器退出复位时，它会进入线程模式执行复位处理函数 (而非像其他异常那样进入处理函数模式)。此外，IPSR中的异常号读取为0。</p><h4 id="nvic">4.4.1 NVIC</h4><p>　　NVIC是可编程的，其寄存器位于内存映射的系统控制空间中。NIVC控制异常和中断配置、优先级以及中断屏蔽。NVIC的功能包括<span style="background-color:#ff0">灵活的异常和中断管理</span>、<span style="background-color:#ff0">嵌套异常/中断支持</span>、<span style="background-color:#ff0">向量异常/中断条目</span>以及<span style="background-color:#ff0">中断屏蔽</span>。</p><p>　　每个异常 (除了NMI) 都可以被启用或禁用，并且可以通过软件设置或清除其挂起状态。NVIC可以处理各种类型的中断源：</p><p>　　● 脉冲中断请求——中断请求至少持续1个时钟周期。当NIVIC在其中断输入收到脉冲时，挂起状态会被设置并保持，直到中断得到服务。</p><p>　　● 电平触发中断请求——中断源保持高电平，直到中断得到服务。</p><p>　　NVIC信号输入电平为高电平时有效。但是，微控制器的外部中断输入可以设计得不同，并通过片上逻辑转换为有效的高电平信号。</p><p>　　所有异常都有优先级。中断等异常有可编程的优先级，而NMI等异常有固定的优先级。NVIC会在发生异常时将异常的优先级和当前优先级进行对比。若异常的优先级更高，则当前运行的任务会被挂起。某些寄存器会被存储在栈内存中，并且处理器会开始执行对应的异常处理函数。该过程称为<span style="background-color:#ff0">抢占</span>。当高优先级的异常处理函数完成时，它将以异常返回操作终止，处理器会自动从栈中恢复寄存器并继续之前的任务。该机制允许在不产生软件开销的情况下异常服务嵌套。</p><p>　　当发生异常时，处理器需要定位对应的异常处理函数的起始地址。对于ARM7TDMI等经典ARM处理器，软件处理这一步。Cortex-M处理器会根据内存中的向量表定位异常处理函数的起始地址。因此，从异常开始到异常处理函数执行的延迟得以减少。</p><p>　　NVIC提供了多种异常屏蔽掩码。寄存器PRIMASK可用于禁用所有异常 (包括硬故障和NMI)，这种屏蔽对不应被中断的操作很有用 (例如，实时多媒体解码器)。寄存器BASEPRI可用于禁用指定优先级以下的异常/中断。</p><p>　　CMSIS提供了1组用于访问各种中断功能的函数。NVIC的灵活性和功能使得Cotex-M处理器非常易于使用，并通过减少中断处理中的软件开销来提供更好的系统响应，从而减小代码体积。</p><h4 id="向量表">4.4.2 向量表</h4><table><colgroup><col style="width:13%"><col style="width:18%"><col style="width:22%"><col style="width:45%"></colgroup><thead><tr><th>异常类型</th><th>CMSIS中断号</th><th>地址偏移</th><th>向量</th></tr></thead><tbody><tr><td>18~255</td><td>2~239</td><td><code>0x48</code>~<code>0x3FF</code></td><td>IRQ #2~239 (最低有效位为1)</td></tr><tr><td>17</td><td>1</td><td><code>0x44</code></td><td>IRQ #1 (最低有效位为1)</td></tr><tr><td>16</td><td>0</td><td><code>0x40</code></td><td>IRQ #0 (最低有效位为1)</td></tr><tr><td>15</td><td>-1</td><td><code>0x3C</code></td><td>SysTick (最低有效位为1)</td></tr><tr><td>14</td><td>-2</td><td><code>0x38</code></td><td>PendSV (最低有效位为1)</td></tr><tr><td></td><td></td><td><code>0x34</code></td><td>保留</td></tr><tr><td>12</td><td>-4</td><td><code>0x30</code></td><td>调试监视器 (最低有效位为1)</td></tr><tr><td>11</td><td>-5</td><td><code>0x2C</code></td><td>SVC (最低有效位为1)</td></tr><tr><td></td><td></td><td><code>0x28</code></td><td>保留</td></tr><tr><td></td><td></td><td><code>0x24</code></td><td>保留</td></tr><tr><td></td><td></td><td><code>0x20</code></td><td>保留</td></tr><tr><td></td><td></td><td><code>0x1C</code></td><td>保留</td></tr><tr><td>6</td><td>-10</td><td><code>0x18</code></td><td>使用故障 (最低有效位为1)</td></tr><tr><td>4</td><td>-11</td><td><code>0x14</code></td><td>总线故障 (最低有效位为1)</td></tr><tr><td>4</td><td>-12</td><td><code>0x10</code></td><td>内存管理故障 (最低有效位为1)</td></tr><tr><td>3</td><td>-13</td><td><code>0x0C</code></td><td>硬故障 (最低有效位为1)</td></tr><tr><td>2</td><td>-14</td><td><code>0x08</code></td><td>NMI (最低有效位为1)</td></tr><tr><td>1</td><td></td><td><code>0x04</code></td><td>复位 (最低有效位为1)</td></tr><tr><td></td><td></td><td><code>0x00</code></td><td>MPS的初始值</td></tr></tbody></table><p>　　当发生异常事件并执行对应的异常处理函数时，为了获取异常处理函数的起始地址，需要使用向量表机制。向量表是系统内存中的字数据数组，每个字数据表示1种异常类型的起始地址。向量表是可重定位的，并且重定位由NVIC中的<strong>向量表偏移寄存器</strong> (VTOR) 控制。VTOR是可编程的。当复位后，VTOR会被重置为0，所以向量表也会被定位到地址<code>0x0</code>。</p><p>　　若复位为异常类型1，则复位向量的地址为<code>0x00000004</code> (每个字是4字节)，并且NMI向量 (类型2) 会位于地址<code>0x00000008</code>。地址<code>0x00000000</code>用于存储MSP的起始值。</p><p>　　每个异常向量的最低有效位表示执行该异常时是否处于Thumb状态。因为Cortex-M处理器仅支持Thumb指令，所以所有异常向量的最低有效位必须为1。</p><h4 id="故障处理">4.4.3 故障处理</h4><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/fault_exceptions_usages.svg" title="fault_exceptions_usages"><p>　　Cortex-M3和Cortex-M4处理器的几种异常是故障处理异常。当处理器检测到未定义的指令等异常或总线系统向内存访问返回错误时，会触发故障异常。故障异常机制可以快速检测错误，并可能允许软件执行补救措施。</p><h4 id="系统控制块">4.4.4 系统控制块</h4><p>　　处理器的一部分合并到了NIVC，该部分是<strong>系统控制块</strong> (SCB)。SCB包含用于以下目的的寄存器：</p><p>　　● 控制寄存器配置 (例如，低功耗模式)</p><p>　　● 提供故障状态信息 (故障状态寄存器)</p><p>　　● 向量表重定位 (VTOR)</p><p>　　SCB是映射到内存的。与NVIC寄存器类似，SCB寄存器通过<span style="background-color:#ff0">系统控制空间</span> (SCS) 访问。</p><h3 id="调试">4.5 调试</h3><p>　　Cortex-M处理器提供了调试接口和跟踪接口，两者都是使用调试适配器。</p><p>　　调试接口允许调试适配器连接到Cortex-M微处理器，以控制调试功能和访问内存空间。Cortex-M处理器支持传统的JTAG协议和较新的<span style="background-color:#ff0">串口线调试</span> (SWD) 协议。前者使用4或5个引脚 (nTRST、TCK、TDI、TMS和TDO)，后者使用2个引脚 (串行线时钟和串行线数据)。SWD协议由ARM开发，仅使用2个引脚即就能在不损失调试性能的情况下提供与JTAG相同的调试功能。很多调试适配器都支持这2种协议。这2种协议可以使用同一连接器，JTAG的TCK与串行线时钟共用同一引脚，而JTAG的TMS与串行线数据共用同一引脚。</p><p>　　跟踪接口用于在运行时收集信息。Cortex-M处理器支持2种跟踪接口：<span style="background-color:#ff0">串行线查看器</span> (SWV) 和<span style="background-color:#ff0">跟踪端口</span>。</p><p>　　● SWV仅使用1个引脚，成本低，跟踪数据带宽也较低，但足以处理选择性数据跟踪、事件跟踪和基本性能分析的捕获。SWV的输出信号称为<span style="background-color:#ff0">串行线输出</span> (SWO)，可以与JTAG的TDO共享同一引脚。</p><p>　　● 跟踪端口需要1个时钟引脚 (TRACECLK) 和多个数据引脚 (TRACEDATA)。数据引脚的数量是可配置的，在大多数情况下，Cortex-M3和Cortex-M4处理器支持最多4个数据引脚。跟踪端口的数据带宽比SWV的更高。</p><p>　　此外，Cortex-M3和Cortex-M4处理器的内部还有ITM等其他调试组件。</p><h3 id="复位和复位序列">4.6 复位和复位序列</h3><p>　　对于典型Cortex-M处理器，存在3种复位：</p><p>　　● 上电复位：重置整个微处理器，包括处理器、调试支持组件和外设。</p><p>　　● 系统复位：仅重置处理器和外设。</p><p>　　● 处理器复位：仅重置处理器。</p><p>　　在系统调试或处理器复位操作期间，Cortex-M3和Cortex-M4处理器的调试组件不会重置，所以调试主机和微控制器之间的连接会被保留。调试主机可以通过SCB寄存器执行系统复位或处理器复位。</p><p>　　上电复位和系统复位所需的时间取决于微控制器设计。在某些情况下，复位会持续几毫秒，因为复位控制器需要等待时钟源 (例如，晶体振荡器) 稳定。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/reset_sequence.svg" title="reset_sequence"><p>　　在复位之后以及处理器开始执行程序之前，Cortex-M处理器会从内存读取前2个字。向量表位于内存空间的开头，并且前2个字是MSP的初始值和复位向量 (即复位处理函数的起始地址)。当读取前2个字后，处理器会使用这些值设置MSP和PC。</p><p>　　设置MSP是必要的。NMI或硬故障等异常会在复位不久后发生，处理这些异常需要使用栈内存，所以MSP需要在处理异常之前将某些处理器状态压入栈中。</p><p>　　对于大部分C开发环境，C起始代码也会在进入主函数 (<code>main()</code>) 之前更新MSP。这2个初始化步骤允许具有外部存储器的微控制器设备将外部存储器作为栈 (例如，它可以在位于小型内部SRAM中的栈中启动，并在重置处理函数中初始化外部存储控制器，然后执行C启动代码，该代码随后会将外部存储器作为栈)。</p><p>　　栈指针初始化行为不同于ARM7TDMI等经典ARM处理器。对于这些处理器，复位后会从地址<code>0x0</code>开始执行指令，栈指针必须由软件初始化。此外，这些处理器的向量表存储着指令代码 (而非地址值)。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/initial_stack_pointer_value_and_initial_program_counter_value_example.svg" title="initial_stack_pointer_value_and_initial_program_counter_value_example"><p>　　如图所示，栈内存的地址范围从<code>0x20007C00</code>到<code>0x20007FFF</code> (1KB)，栈的初始值是<code>0x20008000</code>。向量表中的向量地址的最低有效位应该被设置为1 (表示Thumb代码)。因此，复位向量的地址为<code>0x00000101</code> (引导代码的起始地址)。当读取复位向量后，Cortex-M处理器会从复位向量地址开始执行代码。</p><p>　　各种软件开发工具可能会使用不同的方法来指定起始栈指针和复位向量。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_36/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第36章 进程资源"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第36章 进程资源</a></div><div class="post-nav-item"></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>