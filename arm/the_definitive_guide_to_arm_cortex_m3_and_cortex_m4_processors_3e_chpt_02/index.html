<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/","path":"arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/","title":"《ARM Cortex-M3与Cortex-M4权威指南 第3版》第2章 嵌入式软件开发简介"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《ARM Cortex-M3与Cortex-M4权威指南 第3版》第2章 嵌入式软件开发简介 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-text">2.1 软件开发流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.2 编译程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%81%E7%A8%8B"><span class="nav-text">2.3 软件流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.4 C编程中的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E5%92%8C%E5%A4%96%E8%AE%BE%E8%AE%BF%E9%97%AE"><span class="nav-text">2.5 I&#x2F;O和外设访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.6 微控制器接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cortex%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BD%AF%E4%BB%B6%E6%8E%A5%E5%8F%A3%E6%A0%87%E5%87%86"><span class="nav-text">2.7 Cortex微控制器软件接口标准</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cmsis-core%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96%E8%8C%83%E5%9B%B4"><span class="nav-text">2.7.1 CMSIS-Core的标准化范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cmsis-core%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="nav-text">2.7.2 CMSIS-Core的组织结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cmsis-core%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-text">2.7.3 CMSIS-Core的用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cmsis%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-text">2.7.4 CMSIS的版本</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《ARM Cortex-M3与Cortex-M4权威指南 第3版》第2章 嵌入式软件开发简介 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《ARM Cortex-M3与Cortex-M4权威指南 第3版》第2章 嵌入式软件开发简介</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-04-20 00:00:00" itemprop="dateCreated datePublished" datetime="2025-04-20T00:00:00+08:00">2025-04-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-04-21 00:00:00" itemprop="dateModified" datetime="2025-04-21T00:00:00+08:00">2025-04-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/arm/" itemprop="url" rel="index"><span itemprop="name">ARM</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>12k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　有超过10家不同的供应商销售用于Cortex-M微控制器的C编译器套件，其范围从开源免费的工具到廉价的工具，再到高端商业包。当前可用的选择包括以下供应商的产品：</p><p>　　● Keil Microcontroller Development Kit (MDK-ARM)</p><p>　　● ARM DS-5 (Development Studio 5)</p><p>　　● IAR Systems (Embedded Workbench for ARM Cortex-M)</p><p>　　● Red Suite from Code Red Technologies (已于2013年被NXP收购)</p><p>　　● Mentor Graphics Sourcery CodeBench (前身为CodeSourcery Sourcery g++)</p><p>　　● mbed.org</p><p>　　● Altium Tasking VX-toolset for ARM Cortex-M</p><p>　　● Rowley Associates (CrossWorks)</p><p>　　● Coocox</p><p>　　● Texas Instruments Code Composer Studio (CCS)</p><p>　　● Raisonance RIDE</p><p>　　● Atollic TrueStudio</p><p>　　● GNU Compiler Collection (gcc)</p><p>　　● ImageCraft ICCV8</p><p>　　● Cosmic Software C Cross Compiler for Cortex-M</p><p>　　● mikroElektronika mikroC</p><p>　　● Arduino</p><p>　　有些开发板还包括开发套件的基础版或评估版。此外，还存在其他语言的开发套件：</p><p>　　● Oracle Java ME Embedded</p><p>　　● IS2T MicroEJ Java virtual machine</p><p>　　● mikroElektronika mikroBasic, mikroPascal</p><span id="more"></span><p>　　为了将程序代码下载到微控制器，并进行停止和单步执行等调试操作，需要使用调试适配器，以将PC的USB连接转换为微控制器使用的调试通信协议。大部分C编译器供应商都有自己的调试适配器 (例如，Keil对应ULINK系列产品，IAR对应I-Jet产品)。大多数开发套件也支持第三方调试适配器。此外，不同的供应商可能对这些调试适配器使用不同的术语 (例如，调试探测器、USB-JTAG适配器、JTAG/SW仿真器、JTAG在线仿真器)。</p><p>　　有些开发套件会含板载的USB调试适配器 (例如，Texas Instruments、ST Microelectronics、NXP和Energy Micro等公司的部分廉价评估板)，并且主流商业开发套件也支持其中的很多板载USB适配器。对于很多评估板或开发板，板载USB调试适配器也可用于连接到其他开发板。此外，这些调试适配器也有开源版本 (例如，ARM的CMSIS-DAP和Coocox的CoLink)。</p><p>　　微控制器也有<strong>设备驱动程序</strong>，但其含义与PC的设备驱动程序大不相同。为了帮助微控制器软件开发者，微控制器供应商通常会提供包含外设寄存器定义、外设配置函数和外设访问函数的头文件和C文件，这些文件就是微控制器的设备驱动程序。</p><h3 id="软件开发流程">2.1 软件开发流程</h3><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/a_simplified_software_development_flow.svg"><p>　　软件开发流程取决于使用的编译器套件。这里以带有IDE的编译器为例，软件开发流程通常包含以下步骤：</p><p>　　1) 创建项目，项目将指定源文件的位置、编译目标、内存配置和编译选项等设置，很多IDE都有用于此步骤的项目创建引导。</p><p>　　2) 添加项目所需的源文件。此外，可能还需要在项目选项中指定所有引用的头文件的路径名。此步骤可以使用设备驱动程序库来减少编写新文件的工作量 (包括启动代码、头文件和部分外设控制函数)。</p><p>　　3) 设置项目选项。在大多数情况下，创建的项目文件允许设置编译器优化、内存映射和输出文件类型等项目选项。基于使用的开发板和调试适配器，可能还需要设置调试和下载程序的选项。</p><p>　　4) 编译和链接。在大多数情况下，项目会包含大量需要单独编译的文件。在编译后，每个源文件都有对应的目标文件。为了生成最终的可执行镜像，还需要进行链接。在链接后，IDE也可以生成其他文件格式的程序映像，以便将映像下载到设备上。</p><p>　　5) 闪存编程。几乎所有Cortex-M微处理器使用闪存来存储程序。在程序映像创建后，需要将其下载到微控制器的闪存。为此，需要使用调试适配器。实际的闪存编程过程相当复杂，但该过程通常由IDE完成。此外，程序也可以下载到SRAM，并在SRAM中执行。</p><p>　　6) 执行程序和调试。在程序下载到微控制器后，可以运行程序，并检查是否正常运行 (使用IDE中的调试环境来停止处理器并检查系统状态)。若程序不正常运行，则可以使用单步执行等调试功能来获取程序执行细节。这些操作都需要调试适配器来连接IDE与微控制器。当找到程序漏洞后，需要编辑程序代码和重新编译，然后将程序下载到微控制器，以再次测试。</p><p>　　若使用的是没有IDE的开源工具链，则需要使用脚本或makefile来控制编译和链接过程。此外，可能还需要第三方工具来将程序下载到微控制器，这取决于使用的微控制器产品。</p><p>　　在执行程序的过程中，可以通过UART接口或LCD模块等I/O机制来输出信息，以检查执行状态和结果。</p><h3 id="编译程序">2.2 编译程序</h3><p>　　编译嵌入式程序的流程取决于使用的开发工具。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/common_software_compilation_flow.svg"><p>　　首先，假设使用的是微控制器软件开发中最常用的编程语言——C语言，项目中可能包含一些汇编语言文件 (例如，微控制器供应商提供的启动代码)。在大多数情况下，编译流程与上图所示的流程类似。</p><table><colgroup><col style="width:14%"><col style="width:85%"></colgroup><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>C编译器</td><td>将C程序文件编译为目标文件</td></tr><tr><td>汇编器</td><td>将汇编代码文件汇编为目标文件</td></tr><tr><td>链接器</td><td>将多个目标文件合并在一起并定义内存配置</td></tr><tr><td>闪存编程器</td><td>将编译后的程序映像下载到微控制器的闪存</td></tr><tr><td>调试器</td><td>控制微控制器的操作和访问内部运行信息，以便检查系统状态和程序操作</td></tr><tr><td>模拟器</td><td>在没有实际硬件的情况下模拟程序运行</td></tr><tr><td>其他工具</td><td>文件转换程序 (将编译后的文件转换为其他格式) 等工具</td></tr></tbody></table><p>　　不同的开发工具使用不同的方法来指定微控制器中的程序和数据内存的布局。对于ARM工具链，可以使用<span style="background-color:#ff0">分散加载文件</span> (Keil MDK-ARM的μVision会自动生成分散加载文件)。对于有些ARM工具链，也可以使用命令行选项来指定ROM和RAM的位置。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/common_software_compilation_flow_for_gnu_toolchain.svg"><p>　　对于基于GNU的工具链，内存配置由链接器脚本指定，链接器脚本通常包含在商业gcc工具链的安装过程中。但是，有些gcc用户会创建自己的链接器脚本。GNU gcc工具链通常会编译整个程序，而非将编译过程和链接过程分开。</p><p>　　若有需要，gcc在编译时会自动调用链接器和汇编器，以保证所需参数和库会正确地转递给链接器。将链接过程作为单独的步骤很可能出错，所以大多数gcc工具供应商都不建议这样做。</p><h3 id="软件流程">2.3 软件流程</h3><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/polling_method_for_application_with_multiple_devices_that_need_processing.svg"><p>　　对于简单的应用程序，处理器可以一直等待，直到待处理的数据出现，然后处理该数据并继续等待。在大多数情况下，微控制器会服务多个接口，所以需要处理多个请求。<span style="background-color:#ff0">轮询</span>方法可以轻松地支持处理多个请求，这种设计有时也称为超级循环。</p><p>　　轮询方法很适合简单的应用程序，但它有多个缺点。例如，当程序变得复杂时，轮询的循环设计将可能会变得非常困得。此外，这种方法难以定义优先级，并且效率不高。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/simple_interrupt-driven_application.svg"><p>　　当外设不需要服务时，轮询方法会浪费系统资源。为此，几乎所有微控制器都支持睡眠模式 (以降低功耗)。在睡眠模式下，外设在需要服务时会唤醒处理器。此外，来自不同外设的中断可以指定不同的中断优先级。这种设计通常称为<span style="background-color:#ff0">中断驱动</span>。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/application_with_both_polling_method_and_interrupt-driven_arrangement.svg"><p>　　在某些情况下，来自外设服务的数据处理可以分为2个部分：第1部分需要快速完成，第2部分可以稍后完成。此时，可以同时使用轮询与中断驱动设计来构建程序。当外设需要服务时，会触发中断请求。一旦中断服务的第1部分完成，程序会更新软件变量来让服务的第2部分由基于轮询的代码完成。通过这种设计，可以减少高优先级的中断处理函数的运行时间，所以低优先级的中断服务可以更快地得到服务。</p><p>　　当应用程序足够复杂时，同时使用轮询与中断驱动设计可能都无法处理请求。例如，并发执行多个耗时较长的任务，这可以通过将处理器时间划分为多个时间片，并将时间片分配给任务来完成。从技术角度，这可以通过手动对任务分类和创建简单的调度程序来实现，但在实际项目中这样做往往不切实际，因为这样不仅耗时，而且会使程序难以维护和调试。</p><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/using_an_rtos_to_handle_multiple_tasks.svg"><p>　　对于这些应用程序，RTOS可用于处理任务调度。RTOS通过将处理器时间划分为时间片，并将时间片分配给任务，以支持并发执行多个处理。RTOS的内部记录需要使用定时器，并且在时间片结束时生成定时器中断，然后定时器中断触发任务调度程序，决定是否切换任务。若是，则当前执行的处理会被挂起，处理器执行其他处理。</p><p>　　除了任务调度之外，RTOS还具有信号量和信息传递等功能。为Cortex-M处理器开发的RTOS有很多，并且其中的很多RTOS都是免费的。</p><h3 id="c编程中的数据类型">2.4 C编程中的数据类型</h3><p>　　C支持大量标准数据类型。但是，硬件如何表示数据取决于处理器架构和C编译器。在不同的处理器架构中，特定数据结构的长度可能不同。ARM架构的常用数据类型如下 (包括所有Cortex-M处理器)：</p><table><colgroup><col style="width:35%"><col style="width:6%"><col style="width:57%"></colgroup><thead><tr><th>C和C99数据类型 (<code>stdint.h</code>)</th><th>位数</th><th>范围</th></tr></thead><tbody><tr><td><code>char</code>/<code>int8_t</code>/<code>uint8_t</code></td><td>8</td><td>-128到127 (有符号) 或0到255 (无符号)</td></tr><tr><td><code>short int16_t</code>/<code>uint16_t</code></td><td>16</td><td>-32768到32767 (有符号) 或0到65535 (无符号)</td></tr><tr><td><code>int</code>/<code>int32_t</code>/<code>uint32_t</code></td><td>32</td><td>-2147483648到2147483647 (有符号) 或0到4294967295 (无符号)</td></tr><tr><td><code>long</code></td><td>32</td><td>-2147483648到2147483647 (有符号) 或0到4294967295 (无符号)</td></tr><tr><td><code>long long</code>/<code>int64_t</code>/<code>uint64_t</code></td><td>64</td><td>-2<sup>63</sup>到2<sup>63</sup>-1 (有符号) 或0到2<sup>64</sup>-1 (无符号)</td></tr><tr><td><code>float</code></td><td>32</td><td>-3.4028234×10<sup>38</sup>到3.4028234×10<sup>38</sup></td></tr><tr><td><code>double</code></td><td>64</td><td>-1.7976931348623157×10<sup>308</sup>到1.7976931348623157×10<sup>308</sup></td></tr><tr><td><code>long double</code></td><td>64</td><td>-1.7976931348623157×10<sup>308</sup>到1.7976931348623157×10<sup>308</sup></td></tr><tr><td>指针</td><td>32</td><td><code>0x0</code>到<code>0xFFFFFFFF</code></td></tr><tr><td>枚举</td><td>8/16/32</td><td>尽可能小的数据类型 (除非被编译器选项覆盖)</td></tr><tr><td><code>_Bool</code> (仅限于C) /<code>bool</code> (仅限于C++)</td><td>8</td><td><code>true</code>或<code>false</code></td></tr><tr><td><code>wchar_t</code></td><td>16</td><td>0到65536</td></tr></tbody></table><p>　　因为特定数据类型之间的不同，所以将8位或16位微处理器中的应用程序移植到Cortex-M微控制器时可能需要进行修改。</p><p>　　在ARM编程时，可能会使用术语<strong>字节</strong> (8位)、<strong>半字</strong> (16位)、<strong>字</strong> (32位) 和<strong>双字</strong> (64位)。</p><h3 id="io和外设访问">2.5 I/O和外设访问</h3><p>　　几乎所有微控制器都有各种I/O以及定时器和实时时钟等外设。对于Cortex-M3和Cortex-M4，会有GPIO、SPI、UART和IAC等常见外设，可能还有USB、CAN和以太网等高级接口外设以及ADC和DAC等模拟接口 (这里的大部分接口外设都是特定于供应商的)。</p><p>　　对于这些微控制器，外设是映射到内存的，所以外设寄存器可以从系统内存映射访问 (通过指针)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Configuration Register Low */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_CRL (*((volatile unsigned long *)(0x40010800)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Configuration Register High */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_CRH (*((volatile unsigned long *)(0x40010804)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Input Data Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_IDR (*((volatile unsigned long *)(0x40010808)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Output Data Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_ODR (*((volatile unsigned long *)(0x4001080C)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Bit Set/Reset Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_BSRR (*((volatile unsigned long *)(0x40010810)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Bit Reset Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_BRR (*((volatile unsigned long *)(0x40010814)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Configuration Lock Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_LCKR (*((volatile unsigned long *)(0x40010818)))</span></span><br></pre></td></tr></table></figure><p>　　通常，外设需要在使用前初始化，初始化可能包含以下步骤：</p><p>　　● 对时钟控制电路进行编程，以启用到外设的时钟信号连接，并在需要时启用到对应I/O引脚的时钟信号连接。很多现代微控制器允许对时钟信号进行调整 (例如，启用/关闭到每个独立外设的时钟连接，以降低功耗)。到外设的时钟通常都是关闭的，所以在对外设进行编程前需要启用时钟。在某些情况下，可能还需要启用到外设总线系统的时钟。</p><p>　　● 在部分情况下，可能需要配置I/O引脚的工作模式。大多数微控制器都有用于多个目的的复用I/O引脚。为了使用外设，可能需要配置I/O引脚，以匹配用途 (例如，I/O方向和函数)。此外，可能还需要设置额外的配置寄存器，以定义预期的电器特性 (例如，电压、上拉或下拉以及开漏)。</p><p>　　● 配置外设。大多数外设包含大量可编程的寄存器，使用外设前需要先配置这些寄存器。微控制器供应商通常会提供相关的设备驱动程序库。</p><p>　　● 中断配置。若外设需要与中断操作一起使用，则需要对中断控制器 (NVIC) 进行编程，以启用中断和配置中断优先级。</p><p>　　以上初始化步骤都是通过对外设模块中的外设寄存器进行编程来完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIOA_reset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 将所有引脚设置为模拟输入模式 */</span></span><br><span class="line">    GPIOA_CRL = <span class="number">0</span>;</span><br><span class="line">    GPIOA_CRH = <span class="number">0</span>;</span><br><span class="line">    GPIOA_ODR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以直接使用之前的定义来初始化外设寄存器，这种方法适用于外设寄存器较少的情况。对于外设寄存器较多的情况，这种方法可能会导致问题：</p><p>　　● 对于每个寄存器地址定义，程序都需要对应的常量，进而增加代码量。</p><p>　　● 若外设有多个实例 (例如，STM32微控制器有5个GPIO外设)，则每个实例都需要重复相同的定义。</p><p>　　● 编写可以在同一外设的多个实例之间共享的函数并不容易。例如，在使用示例中的定义时，可能需要为每个GPIO端口都创建相同的GPIO重置函数，进而增加代码量。</p><p>　　为了解决这些问题，通常会将外设寄存器定义为结构体。例如，在微控制器供应商提供的设备驱动程序库中可以找到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> CRL;</span><br><span class="line">    __IO <span class="type">uint32_t</span> CRH;</span><br><span class="line">    __IO <span class="type">uint32_t</span> IDR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> ODR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> BSRR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> BRR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> LCKR;</span><br><span class="line">&#125; GPIO_TypeDef;</span><br></pre></td></tr></table></figure><p>　　然后，所有外设的基地址都定义为指向该结构体的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE ((uint32_t)0x40000000)</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2PERIPH_BASE (PERIPH_BASE + 0x10000)</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_BASE (APB2PERIPH_BASE + 0x0800)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE (APB2PERIPH_BASE + 0x0C00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_BASE (APB2PERIPH_BASE + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_BASE (APB2PERIPH_BASE + 0x1400)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_BASE (APB2PERIPH_BASE + 0x1800)</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA ((GPIO_TypeDef *)GPIOA_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB ((GPIO_TypeDef *)GPIOB_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC ((GPIO_TypeDef *)GPIOC_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD ((GPIO_TypeDef *)GPIOD_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE ((GPIO_TypeDef *)GPIOE_BASE)</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure><p>　　这里的<code>__IO</code>是CMSIS标准头文件定义的关键字 (类似关键字<code>volatile</code>)，表示软件可以读写。此外，还有类似的关键字<code>__I</code>和<code>__O</code>，前者表示只读，后者表示只写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __I volatile</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __I volatile const</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __O volatile</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IO volatile</span></span><br></pre></td></tr></table></figure><p>　　<code>uint32_t</code> (无符号32位整数) 是从C99开始支持的数据类型，它会确保数据的长度是32位 (无论处理器架构)。为了使用该数据类型，项目需要引用头文件<code>stdint.h</code> (若使用的是符合CMSIS的设备头文件，则设备头文件会完成该任务)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="comment">/* C99标准数据类型：</span></span><br><span class="line"><span class="comment">uint8_t - 无符号8位整数</span></span><br><span class="line"><span class="comment">int8_t - 有符号8位整数</span></span><br><span class="line"><span class="comment">uint16_t - 无符号16位整数</span></span><br><span class="line"><span class="comment">int16_t - 有符号16整数</span></span><br><span class="line"><span class="comment">uint32_t - 无符号32位整数</span></span><br><span class="line"><span class="comment">int32_t - 有符号32整数</span></span><br><span class="line"><span class="comment">uint64_t - 无符号64位整数</span></span><br><span class="line"><span class="comment">int64_t - 有符号64整数</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>　　当外设以这种方式声明后，就可以轻松地编写适用于外设的多个实例的函数。例如，重置GPIO端口的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_reset</span><span class="params">(GPIO_TypeDef *GPIOx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 将所有引脚设置为模拟输入模式 */</span></span><br><span class="line">    GPIOx-&gt;CRL = <span class="number">0</span>;</span><br><span class="line">    GPIOx-&gt;CRH = <span class="number">0</span>;</span><br><span class="line">    GPIOx-&gt;ODR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　调用该函数时，只需要将外设基地址作为参数转递：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIO_reset(GPIOA);</span><br><span class="line">GPIO_reset(GPIOB);</span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure><p>　　几乎所有Cortex-M微控制器设备驱动程序库都使用这种声明外设寄存器的方法。</p><h3 id="微控制器接口">2.6 微控制器接口</h3><p>　　不同于PC应用程序，大多数嵌入式应用程序都没有丰富的GUI。虽然应用程序本身可能不需要用户接口，但基于文本的简单通信方法有时可能很有用 (例如，在程序执行期间打印通过ADC获取的数据)。很多方法可用于显示此类信息：</p><p>　　● 使用连接到微控制器I/O引脚的字符LCD显示模块。</p><p>　　● 使用简单的UART来与运行在PC上的终端程序通信。</p><p>　　● 在微控制器上将USB接口设置为虚拟COM端口，以便与运行在PC上的终端程序通信。</p><p>　　● 使用指令跟踪宏单元 (ITM) 来与调试器软件通信。</p><p>　　在某些情况下，字符LCD可能是嵌入式产品的一部分，所以使用该硬件来显示信息很方便。但是，屏幕的尺寸会限制每次显示的信息量。</p><p>　　UART易于使用，并且允许传递更多的信息给开发者。Cortex-M3/M4没有将UART作为标准模块，但大多数微控制器供应商都在其微控制器设计中加入了UART外设。但是，大多数PC都没有UART接口 (COM端口)，所以可能需要额外的USB转UART适配器来实现通信。此外，还需要TTL转RS232适配器来转换信号电压。</p><p>　　对于某些开发板 (例如，Texas Instruments Stellaris LaunchPad)，板载调试器包含UART转USB的功能。</p><p>　　若使用的微控制器包含USB接口，则可以使用该接口来与PC通信。例如，通过使用虚拟COM端口来与运行在PC上的终端程序进行基于文本的通信。这需要对软件进行额外的配置，但允许微控制器硬件直接与PC连接，省去了RS232适配器。</p><p>　　若使用了Keil ULINK2和Segger J-LINK等商业调试适配器，则可以使用ITM来将传输信息到调试主机 (运行在PC上的调试器)，并在开发软件中显示。这不需要额外的硬件，并且软件开销也不大。</p><p>　　将<code>printf()</code> (C语言函数) 中的文本信息重定向到指定硬件 (例如，UART和字符LCD) 的技术称为<span style="background-color:#ff0">重定向</span>。重定向在处理用户输入和系统函数时很有用。用于重定向的C代码是特定于工具链的。</p><h3 id="cortex微控制器软件接口标准">2.7 Cortex微控制器软件接口标准</h3><p>　　ARM制定的<span style="background-color:#ff0">Cortex微控制器软件接口标准</span> (CMSIS) 允许微控制器和软件供应商使用一致的软件基础设施为Cortex-M微控制器开发软件。CMSIS旨在提升软件的可重用性和兼容性、保证软件的开源性以及让软件易于学习和独立于工具链。因此，很多Cortex-M微控制器开发的软件都是符合该标准的。</p><p>　　CMSIS是1个持续发展的项目。它最初用于保证Cortex-M微控制器的设备驱动程序库之间的一致性，该部分现已成为CMSIS-Core。从那时起，其他CMSIS项目已经开始：</p><p>　　● CMSIS-Core (Cortex-M处理器支持) 是1组API，供应用程序和中间件开发者访问Cortex-M处理器的功能。CMSIS目前支持的处理器包括Cortex-M0、Cortex-M0+、Cortex-M3、Cortex-M4以及SC000和SC300等SecurCore产品 (Cortex-M1同Cortex-M0)。</p><p>　　● CMSIS-DSP库于2010年发布，支持FFT和滤波器等常用DSP操作。CMSIS-DSP旨在允许软件开发者轻松地在Cortex-M微控制器上开发DSP应用程序。</p><p>　　● CMSIS-SVD (CMSIS系统视图描述) 是基于XML的文件格式，用于描述微控制器产品的外设。调试工具供应商可以使用微控制器供应商准备的CMSIS-SVD文件来快速构建外设查看器。</p><p>　　● CMSIS-RTOS是运行在微控制器的嵌入式OS的API规范，允许为多个嵌入式OS平台开发中间件和应用程序代码，同时也能提高可重用性和兼容性。</p><p>　　● CMSIS-DAP是调试接口设配器的参考设计 (支持USB到JTAG/串口协议的转换)，允许开发适用于多个开发工具链的低成本调试适配器。</p><h4 id="cmsis-core的标准化范围">2.7.1 CMSIS-Core的标准化范围</h4><p>　　从软件开发角度，CMSIS-Core标准化了多个领域：</p><p>　　● CMSIS-Core标准化了处理器外设的定义，包括包括NVIC寄存器、处理器中的系统节拍定时器 (SysTick)、可选的MPU、系统控制模块中的各种可编程寄存器以及与有些与调试功能相关的软件可编程寄存器。</p><p>　　● CMSIS-Core标准化了处理器功能访问函数，包括通过NVIC进行中断控制的各种函数和访问处理器中的特殊寄存器的函数。尽管在必要时可以直接访问寄存器，但使用访问函数 (或API) 的通用编程可以提高程序的可移植性。</p><p>　　● CMSIS-Core标准化了用于访问特殊指令的函数。Cortex-M处理器支持很多用于特殊目的的寄存器 (例如，等待中断、WFI和进入睡眠模式)，这些指令无法使用通用的IEC/ISO C语言生成。因此，CMSIS实现了1组函数，以便在C程序代码中访问这些指令。若没有这些函数，则用户只能使用特定于工具链的解决方案，这会降低程序的可重用性，并且可能需要对工具链有比较深入的了解。CMSIS提供了1个用于这些函数的标准API，以便应用程序开发者可以轻松使用。</p><p>　　● CMSIS-Core标准化了系统异常处理函数的命名。</p><p>　　● CMSIS-Core标准化了系统初始化函数。大多数功能丰富的微控制器产品在应用程序启动之前需要对时钟电路和电源控制寄存器进行配置。对于符合CMSIS的设备驱动程序库，这些配置步骤实现在函数<code>SystemInit()</code>中。</p><p>　　● CMSIS-Core标准化了表示时钟频率信息的软件变量。这一点可能不明显，但应用程序代码可能经常需要访问系统的时钟频率 (例如，设置UART的波特率分频器或初始化嵌入式OS的SysTick)。CMSIS-Core定义了软件变量<code>SystemCoreClock</code> (CMSIS 1.3及以上版本) 或<code>SystemFrequency</code> (更早的CMSIS版本) 来表示时钟频率。</p><p>　　此外，CMSIS-Core还提供了用于设备驱动程序库的通用平台。所有设备驱动程序库的用法都相似，以便于初学者快速上手这些设备和软件开发者为多个Cortex-M产品开发软件。</p><h4 id="cmsis-core的组织结构">2.7.2 CMSIS-Core的组织结构</h4><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/cmsis-core_structure.svg"><p>　　微控制器供应商的设备驱动程序库集成了CMSIS文件。设备驱动程序库中的某些文件由ARM准备，并且这些文件是各种微控制器供应商的通用文件。其他文件是特定于供应商/设备的。通常，CMSIS定义为多个层次：核心外设访问层、设备外设访问层、外设访问函数和可选的中间件访问层。</p><p>　　● 核心外设访问层是特定于处理器的 (由ARM提供)，包括名称定义、地址定义和用于访问核心寄存器和核心外设的辅助函数。</p><p>　　● 设备外设访问层是特定于设备的，包括名称定义、外设寄存器的地址定义和系统实现 (例如，中断分配和异常向量定义)。</p><p>　　● 外设访问函数是用于访问外设的驱动程序代码。这些函数是特定于供应商的，并且是可选的。</p><p>　　● 中间件访问层用于访问外设设备，其思想是开发1组API来连接UART、SPI和以太网等常见外设。若该层存在，则中间件的开发者可以基于该层开发应用程序，以便在设备之间移植软件。</p><p>　　在有些情况下，设备驱动程序库可能包含微控制器供应商实现的特定于供应商的附加NVIC函数。</p><h4 id="cmsis-core的用法">2.7.3 CMSIS-Core的用法</h4><img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/using_cmsis-core_in_a_project.svg"><p>　　微控制器供应商提供的符合CMSIS的设备驱动程序库会包含CMSIS文件。当不使用这些库时，通常需要通过以下步骤来使用CMSIS-Core：</p><p>　　● 将源文件添加到项目，包括特定于设备和工具链的启动代码 (C或汇编)、特定于设备的设备初始化代码 (例如，<code>system_device.c</code>) 和可选的特定于供应商的外设访问函数代码。对于CMSIS 2.00及以下版本的CMSIS-Core库，若需要使用某些核心寄存器访问函数，则可能还需要添加特定于处理器的C文件 (例如，<code>core_cm3.c</code>)，CMSIS 2.10及以上版本的CMSIS-Core库不需要如此。</p><p>　　● 将头文件添加到项目的搜索路径，包括外设寄存器定义和中断分配定义对应的特定于设备的头文件 (例如，<code>device.h</code>)、设备初始化代码对应的特定于设备的头文件 (例如，<code>system_device.h</code>)、各种特定于处理器的头文件 (例如，<code>core_cm3.h</code>和<code>core_cm4.h</code>) 和可选的外设访问函数对应的特定于供应商的头文件。此外，开发组件可能会包含一些预装的通用CMSIS支持文件。</p><p>　　在程序中引用将特定于设备的头文件后，这些头文件还会自动引用其他头文件，所以需要为这些头文件设置项目搜索路径，以保证程序可以正确编译。</p><p>　　在部分情况下，IDE在创建项目时会自动设置启动代码。否则，需要手动从设备驱动程序库中将启动代码复制到项目。处理器的启动序列需要启动代码，并且启动代码中还包含中断所需的异常向量表定义。</p><h4 id="cmsis的版本">2.7.4 CMSIS的版本</h4><p>　　CMSIS项目一直在发展。在过去的几年里，已经发布了多个版本，带来了更广泛的处理器支持和优化。除了优化代码之外，还有很多其他变化：</p><table><colgroup><col style="width:11%"><col style="width:12%"><col style="width:75%"></colgroup><thead><tr><th>CMSIS版本</th><th>发布时间</th><th>主要变化</th></tr></thead><tbody><tr><td>1.0</td><td>2008年11月</td><td>第1次发布，仅支持Cortex-M3。</td></tr><tr><td>1.10</td><td>2009年2月</td><td>添加对Cortex-M0的支持。</td></tr><tr><td>1.20</td><td>2009年5月</td><td>添加对TASKING编译器的支持。添加用于管理NVIC优先级设置的更多函数。</td></tr><tr><td>1.30</td><td>2009年10月</td><td>系统初始化函数<code>SystemInit()</code>修改为由启动代码调用 (而非在主函数的开头调用)。变量<code>SystemFrequency</code>重命名为<code>SystemCoreClock</code>，以更好地体现其含义。添加函数<code>void SystemCoreClockUpdate(void)</code>。添加对调试通信的数据接收的支持 (以前的版中通过ITM来输出调试通信中的数据)。添加处理器的外设寄存器的位定义。修改目录结构。</td></tr><tr><td>2.0</td><td>2010年11月</td><td>添加对Cortex-M4的支持。添加用于Cortex-M3和Cortex-M4的CMSIS DSP库 (CMSIS-DSP)。添加头文件<code>core_cm4_simd.h</code>、<code>core_cmFunc.h</code>和<code>core_cmInst.h</code>，并将大量核心访问函数移入到这些头文件 (内联)。添加CMSIS系统视图描述。</td></tr><tr><td>2.10</td><td>2010年1月</td><td>添加用于Cortex-M0的CMSIS-DSP库。添加对DSP库的大端支持。简化目录结构。特定于处理器的C文件将 (例如，<code>core_cm3.h</code>和<code>core_cm4.h</code>) 不再需要并被删除。重写CMSIS-DSP库示例。更新文档。</td></tr><tr><td>3.0</td><td>2010年10月</td><td>添加对ARM嵌入式处理器的GNU工具的支持。添加函数<code>_ROR()</code>。添加TPIU和DWT的寄存器映射。添加对SC000和SC300的支持。修复函数<code>ITM_SendChar()</code>。修复用于gcc编译器段的函数<code>__STREXB()</code>和<code>__STREXH()</code>。重组文档。</td></tr><tr><td>3.01</td><td>2012年3月</td><td>添加对Cortex-M0+的支持。集成CMSIS-DSP库版本1.1.0。</td></tr></tbody></table></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_21/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第21章 信号：信号处理函数"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第21章 信号：信号处理函数</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_22/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第22章 信号：高级特性">《Linux/UNIX系统编程手册》第22章 信号：高级特性 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>