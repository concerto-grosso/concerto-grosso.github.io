<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/","path":"misc/computer_systems_a_programmer's_perspective_3e_chpt_02/","title":"《深入理解计算机系统 第3版》第2章 信息的表示与处理"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《深入理解计算机系统 第3版》第2章 信息的表示与处理 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8"><span class="nav-text">2.1 信息存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6"><span class="nav-text">2.1.1 数据长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E5%92%8C%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F"><span class="nav-text">2.1.2 寻址和字节顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="nav-text">2.1.3 布尔代数简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E7%9B%B8%E5%85%B3%E6%94%AF%E6%8C%81"><span class="nav-text">2.1.4 C相关支持</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="nav-text">2.2 整数表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.2.1 整数数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%BC%96%E7%A0%81"><span class="nav-text">2.2.2 整数编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">2.2.3 有符号数和无符号数的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%95%B4%E6%95%B0%E7%9A%84%E4%BD%8D%E8%A1%A8%E7%A4%BA"><span class="nav-text">2.2.4 扩展整数的位表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%AA%E6%96%AD%E6%95%B0%E5%80%BC"><span class="nav-text">2.2.5 截断数值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="nav-text">2.3 整数运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E8%BF%90%E7%AE%97"><span class="nav-text">2.3.1 无符号运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81%E8%BF%90%E7%AE%97"><span class="nav-text">2.3.2 补码运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%A4%E4%BB%A52%E7%9A%84%E5%B9%82"><span class="nav-text">2.3.3 除以2的幂</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%99%A4%E4%BB%A52%E7%9A%84%E5%B9%82"><span class="nav-text">2.3.3.1 无符号数除以2的幂</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A5%E7%A0%81%E9%99%A4%E4%BB%A52%E7%9A%84%E5%B9%82"><span class="nav-text">2.3.3.2 补码除以2的幂</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-text">2.4 浮点数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B0%8F%E6%95%B0"><span class="nav-text">2.4.1 二进制小数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ieee%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA"><span class="nav-text">2.4.2 IEEE浮点表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97"><span class="nav-text">2.4.3 浮点运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E7%9B%B8%E5%85%B3%E6%94%AF%E6%8C%81-1"><span class="nav-text">2.4.4 C相关支持</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《深入理解计算机系统 第3版》第2章 信息的表示与处理 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《深入理解计算机系统 第3版》第2章 信息的表示与处理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-10-05 00:00:00" itemprop="dateCreated datePublished" datetime="2022-10-05T00:00:00+08:00">2022-10-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-03-31 00:00:00" itemprop="dateModified" datetime="2023-03-31T00:00:00+08:00">2023-03-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/misc/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>22k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　使用了一千多年的十进制源于印度，12世纪被阿拉伯数学家改进并在13世纪被意大利数学家Leonardo Pisano (即Fibonacci) 带到西方。对于有10个手指头的人类，十进制很自然。但是，现代计算机存储和处理的信息都是用二进制 (称为<strong>位</strong>) 表示，因为二进制更容易被表示、存储和传输。</p><p>　　单个位并不是很有用，当把位组合在一起并附加上<strong>解释</strong>来给不同的位模式赋予意义时，可以表示任何有限集合中的元素。</p><p>　　<strong>无符号</strong>编码基于传统的二进制表示法，表示非负数。<strong>补码</strong>编码是表示有符号整数 (有正负) 的最常见的方式。<strong>浮点</strong>编码是以2为基数的科学计数法版本，用于表示实数。</p><p>　　计算机的表示法使用有限数量的位来编码，所以当结果太大时以至于不能表示时，某些运算可能<strong>溢出</strong>，进而导致奇怪的结果。例如，对于<code>int</code>是32位的计算机，C计算<code>200 * 300 * 400 * 500</code>会得到−884901888。</p><p>　　计算机的整数运算满足数学中整数运算的许多属性 (例如，乘法的结合律和交换律)。计算机的浮点运算具有完全不同的数学属性。正数之间的乘积始终为正，尽管溢出时会产生特殊值<span class="math inline">\(+\infty\)</span>。由于表示的精度有限，浮点运算是不可结合的。例如，对于大多数计算机，C计算<code>(3.14 + 1e20) - 1e20</code>会得到0.0。整数与浮点算术的不同数学属性源于它们处理表示的有限性的方式不同：整数是精确的，但只能表示范围相对较小的值；浮点数是近似的，但能表示范围相对较大的值。</p><p>　　在20世纪80年代之前，计算机制造商都会设计自己的浮点数表示规则以及相关运算细节，它们都更注重实现的速度和简便 (而非精确)。在1985年，这些随着IEEE 754的出现而发生了变化，IEEE 754是精心设计的标准，用于表示浮点数及其执行的操作。这些工作始于1976年，最初由Intel赞助，与8087 (为8086 CPU提供浮点支持的芯片) 的设计同时进行。Intel聘请了加州大学伯克利分校的教授William Kahan作为顾问，帮助其为未来的CPU设计浮点标准。Intel允许Kahan与委员会合作，在IEEE的主持下制定行业标准。委员会最终采用的标准很接近Kahan为Intel制定的标准。</p><p>　　ASCII字符集适合对英文文档进行编码，但不支持特殊字符 (希腊语、俄语和中文等)。多年来，出现了很多对不同语言进行编码的方法。Unicode联盟制定了最全面和最广泛的文本编码标准，7.0版本的Unicode标准的拥有超过100000个字符，支持多种语言，包括古埃及语和古巴比伦语。此外，Unicode技术委员会否决了为克林贡语制定语言标准的提议。</p><p>　　Unicode的基本编码 (通用字符集) 中的字符都是32位，这似乎要求文本中的所有字符都占用4字节。但是，当常见字符仅占用1或2字节，不太常见的字符占用更多字节时，可以使用其他编码。例如，UTF-8将所有字符都编码为字节序列，并且ASCII字符使用与ASCII中相同的单字节编码 (ASCII字符序列在UTF-8中和在ASCII中具有相同的含义)。Java使用Unicode表示字符串，C也有支持Unicode的库。</p><p>　　由于二进制是计算机编码、存储和操作信息的核心，所以围绕0和1的研究已演化出了丰富的数学知识体系，这源于1850年左右的George Boole (1815-1864) 的努力，所以称为<strong>布尔代数</strong>。Boole观察到，将逻辑值TRUE和FALSE编码为二进制值0和1，可以制定1种包含逻辑推理基本原理的代数。</p><p>　　ISO C99在头文件<code>stdint.h</code>中新增了固定长度的整数类型，其声明形如<code>intN_t</code>和<code>uintN_t</code>，其中<code>N</code>表示<span class="math inline">\(N\)</span>位的有符号和无符号整数，<code>N</code>的具体值与实现有关，但大多数编译器允许的值为8、16、32和64。这些整数类型有1组对应的宏：<code>INTN_MIN</code>、<code>INTN_MAX</code>和<code>UINTN_MAX</code>。</p><span id="more"></span><h3 id="信息存储">2.1 信息存储</h3><p>　　大多数计算机将<span style="background-color:#ff0">字节</span>作为最小的可寻址内存单元。应用程序将内存视为很大的字节数组，称为<strong>虚拟内存</strong>。内存的每个字节都由唯一的数字标识，称为<strong>地址</strong>，所有可能的地址集称为<strong>虚拟地址空间</strong>。</p><p>　　相比二进制和十进制，<span style="background-color:#ff0">十六进制</span>更适合描述位模式，因为它更精简且无需转换。</p><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th></tr></thead><tbody><tr><td>0000</td><td>0</td><td>0</td></tr><tr><td>0001</td><td>1</td><td>1</td></tr><tr><td>0010</td><td>2</td><td>2</td></tr><tr><td>0011</td><td>3</td><td>3</td></tr><tr><td>0100</td><td>4</td><td>4</td></tr><tr><td>0101</td><td>5</td><td>5</td></tr><tr><td>0110</td><td>6</td><td>6</td></tr><tr><td>0111</td><td>7</td><td>7</td></tr><tr><td>1000</td><td>8</td><td>8</td></tr><tr><td>1001</td><td>9</td><td>9</td></tr><tr><td>1010</td><td>10</td><td>A</td></tr><tr><td>1011</td><td>11</td><td>B</td></tr><tr><td>1100</td><td>12</td><td>C</td></tr><tr><td>1101</td><td>13</td><td>D</td></tr><tr><td>1110</td><td>14</td><td>E</td></tr><tr><td>1111</td><td>15</td><td>F</td></tr></tbody></table><p>　　在C中，十六进制以<code>0x</code>或<code>0X</code>开头，字符<code>A</code>~<code>F</code>大小写不限。</p><h4 id="数据长度">2.1.1 数据长度</h4><p>　　每个计算机都有<strong>字长</strong>，表示指针的标称大小。虚拟地址以这样的字来编码，所以字长决定虚拟地址空间的范围。对于字长为<span class="math inline">\(w\)</span>位的计算机，虚拟地址的范围是<span class="math inline">\(0\sim2^w-1\)</span>。32位虚拟地址空间为4GB，64位虚拟地址空间为16EB。</p><p>　　32位程序和64位程序的区别是编译过程。大多数64位计算机可以兼容32位程序。</p><p>　　计算机和编译器支持多种通过不同方法编码的数据格式 (例如，不同长度的整数和浮点数)。C中的某些数据类型的字节数取决于程序的编译方式。整数数据分为<span style="background-color:#ff0">有符号值</span> (有正负) 或<span style="background-color:#ff0">无符号值</span> (非负)，关键字分别是<code>signed</code>和<code>unsigned</code>。大多数计算机都支持单精度和双精度浮点数，长度分别是4字节和8字节。</p><table><thead><tr><th>C有符号数</th><th>C无符号数</th><th>字节数 (32位)</th><th>字节数 (64位)</th></tr></thead><tbody><tr><td><code>char</code></td><td><code>unsigned char</code></td><td>1</td><td>1</td></tr><tr><td><code>short</code></td><td><code>unsigned short</code></td><td>2</td><td>2</td></tr><tr><td><code>int</code></td><td><code>unsigned</code></td><td>4</td><td>4</td></tr><tr><td><code>long</code></td><td><code>unsigned long</code></td><td>4</td><td>8</td></tr><tr><td><code>int32_t</code></td><td><code>uint32_t</code></td><td>4</td><td>4</td></tr><tr><td><code>int64_t</code></td><td><code>uint64_t</code></td><td>8</td><td>8</td></tr><tr><td><code>T *</code></td><td></td><td>4</td><td>8</td></tr><tr><td><code>float</code></td><td></td><td>4</td><td>4</td></tr><tr><td><code>double</code></td><td></td><td>8</td><td>8</td></tr></tbody></table><p>　　大部分数据类型都会编码为有符号值，除非使用关键字<code>unsigned</code>声明或固定大小的无符号数据类型。但是，<code>char</code>是例外，大多数计算机和编译器都将<code>char</code>编码为有符号值，但C标准不保证这一点。当使用<code>char</code>存储1字节的有符号值时，应使用关键字<code>signed</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> l1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> l2;</span><br><span class="line"><span class="type">long</span> <span class="type">unsigned</span> l3;</span><br><span class="line"><span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> l4;</span><br></pre></td></tr></table></figure><p>　　C允许以多种方式来对关键字进行排序以及省略可选关键字，这里<code>l1</code>、<code>l2</code>、<code>l3</code>和<code>l4</code>意义相同。</p><p>　　对不同数据类型的确切大小不敏感是程序的可移植性的方面之一。C标准对不同数据类型的范围设置了下限但没有设置上限。当从32位程序迁移到64位程序时，很多隐藏的字长依赖项都会作为错误出现 (例如，32位程序中<code>int</code>类型的对象可用于存储指针，但这并不适用于64位程序)。</p><h4 id="寻址和字节顺序">2.1.2 寻址和字节顺序</h4><p>　　对于包含多个字节的程序对象，必须确定对象的地址以及字节在内存中的顺序。在几乎所有计算机中，多字节对象都存储为连续的字节序列，对象的地址是对应字节的地址中的最小地址。若<code>int</code>类型 (32位) 的变量<code>x</code>的地址为<code>0x100</code>，即地址表达式<code>&amp;x</code>的值是<code>0x100</code>，则<code>x</code>的4个字节存储在内存位置<code>0x100</code>、<code>0x101</code>、<code>0x102</code>和<code>0x103</code>。</p><img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/big_endian_and_little_endian.svg"><p>　　以<span class="math inline">\(w\)</span>位的整数为例，其位表示为<span class="math inline">\([x_{w-1},x_{w-2},\cdots,x_1,x_0]\)</span>，其中<span class="math inline">\(x_{w-1}\)</span>是最高有效位，<span class="math inline">\(x_0\)</span>是最低有效位。若<span class="math inline">\(w\)</span>是8的整数倍，则这些位可以分组为字节，其中最高有效字节包含位<span class="math inline">\([x_{w-1},x_{w-2},\cdots ,x_{w-8}]\)</span>，最低有效字节包含位<span class="math inline">\([x_7,x_6,\cdots ,x_0]\)</span>，其他字节包含中间的位。有些计算机按从低有效字节到高有效字节的顺序存储对象，而其他计算机从高有效字节到低有效字节的顺序存储对象。前者称为<strong>小端</strong>，后者称为<strong>大端</strong>。大多数与Intel兼容的计算机仅支持小端模式，IBM和Oracle的大多数计算机仅支持大端模式。部分CPU支持<strong>双端</strong> (即支持这2种模式)。实际中，一旦选择了操作系统，字节顺序就会固定 (例如，许多手机使用的ARM CPU是双端，但Android和IOS仅支持小端模式)。</p><p>　　对于大多数应用程序程序员，计算机使用的字节顺序是完全不可见的。无论为哪种类型的计算机所编译的程序，都会得到相同的结果，但有时字节顺序会成为问题。</p><p>　　● 当二进制数据通过网络在不同计算机之间传输时，若发送端和接收端的字节顺序不同，则会导致发送端发送和数据与接收端收到的数据不一致。为了避免该问题，TCP/IP定义了<strong>网络字节顺序</strong>——通过网络传输的数据必须是大端。</p><p>　　● 当阅读表示整数数据的字节序列时，字节顺序很重要。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4004d3:	01 05 43 0b 20 00	add	%eax,0x200b43(%rip)</span><br></pre></td></tr></table></figure><p>　　这是Intel x86-64 CPU的机器级代码的文本表示，由反汇编器生成，<strong>反汇编器</strong>是获取可执行文件对应的指令序列的工具。十六进制字节序列<code>01 05 43 0b 20 00</code>是某条指令的字节级表示形式，该指令会将单字长的数据加到某个值上，该值的存储地址计算为<code>0x200b43</code>加上当前PC的值 (待执行的下一指令的地址) 。若将序列的最后4个字节<code>43 0b 20 00</code>视为小端，则得到<code>00 20 0b 43</code>，去掉开头的填充0，得到值<code>0x200b43</code>。</p><p>　　● 在编写绕过数据类型系统的程序时字节排序很重要。在C中，可以通过使用<strong>强制类型转换</strong>和<strong>联合</strong>来允许数据类型引用声明时数据类型不同于该数据类型的对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印对象的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param start 对象指针</span></span><br><span class="line"><span class="comment"> * @param len 对象长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]); <span class="comment">/* 至少用2个数字的十六进制格式输出 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印int的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_int</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印float的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_float</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印指针的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_pointer</span><span class="params">(<span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 测试函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param val</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_show_bytes</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ival = val;</span><br><span class="line">    <span class="type">float</span> fval = (<span class="type">float</span>)ival;</span><br><span class="line">    <span class="type">int</span> *pval = &amp;ival;</span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_float(fval);</span><br><span class="line">    show_pointer(pval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　若将函数<code>test_show_bytes()</code>的参数<code>val</code>指定为12345 (对应的十六进制是<code>0x00003039</code>)，则Windows 64 (小端) 的输出是<code>39 30 00 00</code>、<code>00 e4 40 46</code>和<code>4c fb 9f e4 9f 00 00 00</code>。<code>int</code>和<code>float</code>类型的12345的字节模式看似不同，将其转换为二进制后会发现有13个匹配的位序列。对于Linux (小端)，以相同的方式调用该函数得到的结果中，12345的指针值很可能不同于这里的结果，因为指针值根据不同的计算机或操作系统配置的存储分配规则分配。</p><p>　　C中的字符串以字符<code>\0</code> (值为0) 结尾的字符数组编码。以ASCII为例，若将函数<code>show_bytes()</code>的参数<code>start</code>和<code>len</code>分别指定为<code>"12345"</code>和6，则可以得到结果<code>31 32 33 34 35 00</code>，因为十进制数字<span class="math inline">\(n\)</span>的ASCII码值是<code>0x0n</code>，字符<code>\0</code>的ASCII码值为<code>0x00</code>。这在任何使用ASCII编码的系统上都可以获得相同的结果 (与字节顺序和字长无关)，所以文本数据比二进制数据更独立于平台。</p><h4 id="布尔代数简介">2.1.3 布尔代数简介</h4><img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/operations_of_boolean_algebra.svg"><p>　　最简单的布尔代数定义在双元集合<span class="math inline">\(\{0,1\}\)</span>上。布尔运算~表示逻辑运算非，表示为<span class="math inline">\(\lnot\)</span>。布尔运算&amp;表示逻辑运算与，表示为<span class="math inline">\(\land\)</span>。布尔运算|表示逻辑运算或，表示为<span class="math inline">\(\lor\)</span>。布尔运算^表示逻辑运算异或，表示为<span class="math inline">\(\oplus\)</span>。</p><p>　　布尔运算也适用于<strong>位向量</strong> (长度为<span class="math inline">\(w\)</span>，由0和1组成的序列)。若<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>分别表示位向量<span class="math inline">\([a_{w-1},a_{w-2},\cdots ,a_0]\)</span>和<span class="math inline">\([b_{w-1},b_{w-2},\cdots ,b_0]\)</span>，则<span class="math inline">\(a\)</span> &amp; <span class="math inline">\(b\)</span>可以定义为长度为<span class="math inline">\(w\)</span>的位向量，其中第<span class="math inline">\(i\)</span>个元素等于<span class="math inline">\(a_i\)</span> &amp; <span class="math inline">\(b_i\)</span>，类似的方法可以扩展到|、~和^上。</p><p>　　对于长度为<span class="math inline">\(2^w\)</span>的位向量，布尔代数和整数算术有很多相似之处。类似乘法对加法的分配律，&amp;和|相互都有分配律，即<span class="math inline">\(a\)</span> &amp; <span class="math inline">\((b\)</span> | <span class="math inline">\(c)=(a\)</span> &amp; <span class="math inline">\(b)\)</span> | <span class="math inline">\((a\)</span> &amp; <span class="math inline">\(c)\)</span>和<span class="math inline">\(a\)</span> | <span class="math inline">\((b\)</span> &amp; <span class="math inline">\(c)=(a\)</span> | <span class="math inline">\(b)\)</span> &amp; <span class="math inline">\((a\)</span> | <span class="math inline">\(c)\)</span>。</p><p>　　对位向量进行布尔运算会得到<strong>布尔环</strong>。布尔环由<strong>幂等元</strong>组成 (所有元素都满足<span class="math inline">\(x^2=x\)</span>)，布尔环与整数算术有很多相似之处 (例如，整数算术的属性之一是是每个值<span class="math inline">\(n\)</span>都有1个<strong>加法逆元</strong><span class="math inline">\(-n\)</span>，使得<span class="math inline">\(n+-n=0\)</span>)。</p><p>　　位向量可用于表示有限集合，即用位向量<span class="math inline">\([a_{w-1},a_{w-2},\cdots ,a_0]\)</span>对任何子集<span class="math inline">\(A\subseteq\{0,1,\cdots ,w-1\}\)</span>编码，当<span class="math inline">\(i\in A\)</span>时，<span class="math inline">\(a_i=1\)</span>。若<span class="math inline">\(a_{w-1}\)</span>在最左侧，<span class="math inline">\(a_0\)</span>在最右侧，则位向量<span class="math inline">\(a=[01101001]\)</span>表示集合<span class="math inline">\(A=\{0,3,5,6\}\)</span>，而<span class="math inline">\(b=[01010101]\)</span>表示集合<span class="math inline">\(B=\{0,2,4,6\}\)</span>。使用这种方式编码集合时，布尔运算|、&amp;和~分别表示交集、并集和补集。若<span class="math inline">\(a\)</span> &amp; <span class="math inline">\(b\)</span>会得到位向量<span class="math inline">\([0100001]\)</span>，则<span class="math inline">\(A\cap B=\{0,6\}\)</span>。</p><h4 id="c相关支持">2.1.4 C相关支持</h4><p>　　C支持布尔运算，其符号也是<code>~</code>、<code>&amp;</code>、<code>|</code>和<code>^</code>，适用于所有整数数据类型。</p><p>　　位级运算可用于实现<strong>掩码</strong>运算，掩码属于位模式，表示字中特定位的位模式 (例如，掩码<code>0xFF</code>表示字中的低位字节)。<code>n &amp; 0xFF</code>会得到低位字节是<code>n</code>的低位字节，其他字节全为0的结果。<code>~0</code>会得到所有位全为1的掩码。</p><p>　　C也提供了逻辑运算符<code>||</code>、<code>&amp;&amp;</code>和<code>!</code>，分别对应逻辑或、与和非运算。</p><p>　　C还支持<strong>移位</strong>运算，用于向左和向右移动位模式。对于位模式为<span class="math inline">\([x_{w-1},x_{w-2},\cdots ,x_0]\)</span>的操作数<code>x</code>，<code>x &lt;&lt; k</code>的位模式是<span class="math inline">\([x_{w-k-1},x_{w-k-w},\cdots ,x_0,0,\cdots ,0]\)</span>，即<code>x</code>向左移动<span class="math inline">\(k\)</span>位，丢弃最高<span class="math inline">\(k\)</span>位并在右端补<span class="math inline">\(k\)</span>个0。显然，偏移量应该介于0和<span class="math inline">\(w-1\)</span>之间。移位操作从左到右执行，所以<code>x &lt;&lt; j &lt;&lt; k</code>等同于<code>(x &lt;&lt; j) &lt;&lt; k</code>。</p><p>　　计算机通常支持<strong>逻辑右移</strong>和<strong>算术右移</strong>。对于<code>x &gt;&gt; k</code>，逻辑右移类似于右移，会直接在左端补<span class="math inline">\(k\)</span>个0。算术右移会在左端补<span class="math inline">\(k\)</span>个最高有效位的值，即<span class="math inline">\([x_{w-1},\cdots ,x_{w-1},x_{w-1},x_{w-2},\cdots x_k]\)</span>，主要用于有符号数。</p><table><thead><tr><th>操作</th><th>值1</th><th>值2</th></tr></thead><tbody><tr><td><code>x</code></td><td>[01100011]</td><td>[10010101]</td></tr><tr><td><code>x &lt;&lt; 4</code></td><td>[0011<strong>0000</strong>]</td><td>[0101<strong>0000</strong>]</td></tr><tr><td><code>x &gt;&gt; 4</code> (逻辑右移)</td><td>[<strong>0000</strong>0011]</td><td>[<strong>0000</strong>1001]</td></tr><tr><td><code>x &gt;&gt; 4</code> (算术右移)</td><td>[<strong>0000</strong>0011]</td><td>[<strong>1111</strong>1001]</td></tr></tbody></table><p>　　C标准没有定义有符号数所使用的右移类型。实际中，几乎所有编译器和计算机会对有符号数使用算术右移，对无符号数使用逻辑右移。对于<span class="math inline">\(w\)</span>位的数据类型，移动<span class="math inline">\(k\)</span> (<span class="math inline">\(k\geqslant w\)</span>)位，实际位移量为<span class="math inline">\(k\bmod w\)</span>。</p><h3 id="整数表示">2.2 整数表示</h3><p>　　数学术语<strong>双射</strong>指函数<span class="math inline">\(f\)</span>有2种映射方式，可以将数字<span class="math inline">\(x\)</span>映射为数值<span class="math inline">\(y\)</span>，即<span class="math inline">\(y=f(x)\)</span>，也可以反向操作，因为对于每个<span class="math inline">\(y\)</span>都有唯一的<span class="math inline">\(x\)</span>满足<span class="math inline">\(f(x)=y\)</span>，这通过<strong>反函数</strong><span class="math inline">\(f^{-1}\)</span>来表示，即<span class="math inline">\(x=f^{-1}(y)\)</span>。</p><p>　　下表列出了用于定义和描述计算机如何编码和操作整数数据的数学术语：</p><table><thead><tr><th>符号</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><span class="math inline">\(B2T_w\)</span></td><td>函数</td><td>二进制转补码</td></tr><tr><td><span class="math inline">\(B2U_w\)</span></td><td>函数</td><td>二进制转无符号数</td></tr><tr><td><span class="math inline">\(U2B_w\)</span></td><td>函数</td><td>无符号数转二进制</td></tr><tr><td><span class="math inline">\(U2T_w\)</span></td><td>函数</td><td>无符号数转补码</td></tr><tr><td><span class="math inline">\(T2B_w\)</span></td><td>函数</td><td>补码转二进制</td></tr><tr><td><span class="math inline">\(T2U_w\)</span></td><td>函数</td><td>补码转无符号数</td></tr><tr><td><span class="math inline">\(TMin_w\)</span></td><td>常数</td><td>补码的最小值</td></tr><tr><td><span class="math inline">\(TMax_w\)</span></td><td>常数</td><td>补码的最大值</td></tr><tr><td><span class="math inline">\(UMax_w\)</span></td><td>常数</td><td>无符号数的最大值</td></tr><tr><td><span class="math inline">\(+^t_w\)</span></td><td>操作符</td><td>补码加法</td></tr><tr><td><span class="math inline">\(+^u_w\)</span></td><td>操作符</td><td>无符号数加法</td></tr><tr><td><span class="math inline">\(*^t_w\)</span></td><td>操作符</td><td>补码乘法</td></tr><tr><td><span class="math inline">\(*^u_w\)</span></td><td>操作符</td><td>无符号数乘法</td></tr><tr><td><span class="math inline">\(-^t_w\)</span></td><td>操作符</td><td>补码取反</td></tr><tr><td><span class="math inline">\(-^u_w\)</span></td><td>操作符</td><td>无符号数取反</td></tr></tbody></table><h4 id="整数数据类型">2.2.1 整数数据类型</h4><p>　　C支持多种整数数据类型 (用<code>char</code>、<code>short</code>和<code>long</code>等关键字声明)：</p><table><thead><tr><th style="text-align:left">C整数数据类型</th><th style="text-align:left">32位程序的取值范围</th><th style="text-align:left">64位程序的取值范围</th></tr></thead><tbody><tr><td style="text-align:left"><code>char</code></td><td style="text-align:left"><span class="math inline">\(-2^7\sim2^7-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^7\sim2^7-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned char</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^8-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^8-1\)</span></td></tr><tr><td style="text-align:left"><code>short</code></td><td style="text-align:left"><span class="math inline">\(-2^{15}\sim2^{15}-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^{15}\sim2^{15}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned short</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{16}-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^{16}-1\)</span></td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><span class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td></tr><tr><td style="text-align:left"><code>long</code></td><td style="text-align:left"><span class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned long</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^{64}-1\)</span></td></tr><tr><td style="text-align:left"><code>int32_t</code></td><td style="text-align:left"><span class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td></tr><tr><td style="text-align:left"><code>uint32_t</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td></tr><tr><td style="text-align:left"><code>int64_t</code></td><td style="text-align:left"><span class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td><td style="text-align:left"><span class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td></tr><tr><td style="text-align:left"><code>uint64_t</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{64}-1\)</span></td><td style="text-align:left"><span class="math inline">\(0\sim2^{64}-1\)</span></td></tr></tbody></table><p>　　C标准定义了所有整数数据类型的最小取值范围 (对于有符号数，正数和负数的取值范围是对称)：</p><table><thead><tr><th style="text-align:left">C整数数据类型</th><th style="text-align:left">C标准定义的最小取值范围</th></tr></thead><tbody><tr><td style="text-align:left"><code>char</code></td><td style="text-align:left"><span class="math inline">\(-2^7+1\sim2^7-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned char</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^8-1\)</span></td></tr><tr><td style="text-align:left"><code>short</code></td><td style="text-align:left"><span class="math inline">\(-2^{15}+1\sim2^{15}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned short</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{16}-1\)</span></td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left"><span class="math inline">\(-2^{15}+1\sim2^{15}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{16}-1\)</span></td></tr><tr><td style="text-align:left"><code>long</code></td><td style="text-align:left"><span class="math inline">\(-2^{31}+1\sim2^{31}-1\)</span></td></tr><tr><td style="text-align:left"><code>unsigned long</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{32}-1\)</span></td></tr><tr><td style="text-align:left"><code>int32_t</code></td><td style="text-align:left"><span class="math inline">\(-2^{31}+1\sim2^{31}-1\)</span></td></tr><tr><td style="text-align:left"><code>uint32_t</code></td><td style="text-align:left"><span class="math inline">\(0\sim 2^{32}-1\)</span></td></tr><tr><td style="text-align:left"><code>int64_t</code></td><td style="text-align:left"><span class="math inline">\(-2^{63}+1\sim2^{63}-1\)</span></td></tr><tr><td style="text-align:left"><code>uint64_t</code></td><td style="text-align:left"><span class="math inline">\(0\sim2^{64}-1\)</span></td></tr></tbody></table><p>　　在C中，当处理包含有符号数和无符号数组合的表达式时，会先将有符号数隐式转换为无符号数 (例如，对于比较式<code>-1 &lt; 0U</code>，若两者都是32位，则<code>-1</code>会转换为<code>4294967295U</code>，所以该比较式会返回0)。此外，在将位模式较短的有符号数转换为位模式较长的无符号数时，需要先进行符号扩展，再进行有符号数到无符号数的转换。</p><h4 id="整数编码">2.2.2 整数编码</h4><p>　　对于<span class="math inline">\(w\)</span>位的整数<span class="math inline">\(x\)</span>，其位向量表示为<span class="math inline">\(\vec{x}\)</span>。</p><p>　　将<span class="math inline">\(\vec{x}\)</span>视为二进制表示的数就可以得到<span class="math inline">\(\vec{x}\)</span>的无符号表示。在此编码中，每个位<span class="math inline">\(x_i\)</span>的值都为0或1，值为1表示<span class="math inline">\(2^i\)</span>是数字值的一部分。 <span class="math display">\[ B2U_w(\vec{x})=\sum_{i=0}^{w-1}x_i2^i \]</span> 　　对于无符号数，<span class="math inline">\(\vec{x}\)</span>的最小值是位向量<span class="math inline">\([00\cdots 0]\)</span>，最大值是位向量<span class="math inline">\([11\cdots 1]\)</span> (其整数值<span class="math inline">\(UMax_w=2^w-1\)</span>)，所以函数<span class="math inline">\(B2U_w\)</span>能定义为映射<span class="math inline">\(B2U_w:\{0,1\}^w\rightarrow\{0,\cdots ,UMax_w\}\)</span>。<span class="math inline">\(B2U_w\)</span>是双射，它能将每个长度为<span class="math inline">\(w\)</span>的位向量映射到<span class="math inline">\(0\sim2^w-1\)</span>之间的唯一整数，也能将<span class="math inline">\(0\sim2^w-1\)</span>之间的每个整数映射到唯一的长度为<span class="math inline">\(w\)</span>的位模式 (即<span class="math inline">\(U2B_w\)</span>)。</p><p>　　在补码中，最高有效位解释为<strong>负权</strong>，也称为<strong>符号位</strong>，其权重为<span class="math inline">\(-2^{w-1}\)</span>。 <span class="math display">\[ B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i \]</span> 　　对于补码，<span class="math inline">\(\vec{x}\)</span>的最小值是位向量<span class="math inline">\([10\cdots 0]\)</span> (其整数值<span class="math inline">\(TMin_w=-2^{w-1}\)</span>)，最大值是位向量<span class="math inline">\([01\cdots 1]\)</span> (其整数值<span class="math inline">\(TMax=2^{w-1}-1\)</span>)，所以函数<span class="math inline">\(B2T_w\)</span>能定义为映射<span class="math inline">\(B2T_w:\{0,1\}^w\rightarrow\{TMin_w,\cdots ,TMax_w\}\)</span>。<span class="math inline">\(B2T_w\)</span>同样也是双射。</p><p>　　C标准并未要求有符号数以补码形式表示，但几乎所有计算机都这样做。头文件<code>limits.h</code>定义了1组常量来限定运行编译器的计算机的不同整数数据类型的取值范围。例如，常量<code>INT_MIN</code>和<code>INT_MAX</code>定义了<code>int</code>的取值范围，常量<code>UINT_MAX</code>定义了<code>unsigned</code>的取值范围。</p><p>　　有符号数也能表示为<strong>反码</strong>，其最高有效位的权重是<span class="math inline">\(-2^{w-1}+1\)</span>。 <span class="math display">\[ B2O_w(\vec{x})=-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_i2^i \]</span> 　　有符号数还能表示为<strong>原码</strong>，其最高有效位是符号位，用于确定其他位是负权或正权。 <span class="math display">\[ B2S_w(\vec{x})=(-1)^{x_{w-1}} \cdot(\sum_{i=0}^{w-2}x_i2^i) \]</span> 　　原码和反码都有1个奇怪的特性——数字0有2种不同的编码，两者都将<span class="math inline">\([00\cdots 0]\)</span>解释为+0，前者将<span class="math inline">\([10\cdots 0]\)</span>解释为-0，后者将<span class="math inline">\([11\cdots 1]\)</span>解释为-0。</p><p>　　补码的命名 (two's complement) 源于情况：对于非负<span class="math inline">\(x\)</span>，<span class="math inline">\(2^w-x\)</span>可用于计算<span class="math inline">\(-x\)</span>的<span class="math inline">\(w\)</span>位表示 (单个2)。反码的命名 (ones' complement) 源于属性：<span class="math inline">\([111\cdots 1]-x\)</span>可用于计算<span class="math inline">\(-x\)</span>的反码表示 (多个1)。</p><h4 id="有符号数和无符号数的转换">2.2.3 有符号数和无符号数的转换</h4><p>　　C允许在表示数字的不同数据类型之间转换 (例如，从有符号数转换到无符号数)，这种转换通常基于位 (而非数字)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> v = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> uv = (<span class="type">unsigned</span> <span class="type">short</span>)v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v = %d, uv = %u\n&quot;</span>, v, uv); <span class="comment">/* v = -12345, uv = 53191 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> ui = (<span class="type">unsigned</span>)i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d, ui = %u\n&quot;</span>, i, ui); <span class="comment">/* i = -1, ui = 4294967295 */</span></span><br></pre></td></tr></table></figure><p>　　-12345的16位补码与53191的16位无符号表示相同，-1的32位补码也与4294967295的32位无符号表示相同。这是大多数C中大多数相同字长的有符号数和无符号数之间的转换规则，即数值可能改变，但位模式不会变。对于整数<span class="math inline">\(x\)</span>，当<span class="math inline">\(x\)</span>满足<span class="math inline">\(0\leqslant x\leqslant UMax_w\)</span>时，函数<span class="math inline">\(U2B_w(x)\)</span>会得到<span class="math inline">\(x\)</span>的唯一<span class="math inline">\(w\)</span>位无符号表示形式。同样，当<span class="math inline">\(x\)</span>满足<span class="math inline">\(TMin_w\leqslant x\leqslant TMax_w\)</span>时，函数<span class="math inline">\(T2B_w(x)\)</span>会得到<span class="math inline">\(x\)</span>的唯一<span class="math inline">\(w\)</span>位补码表示形式。 <span class="math display">\[ \begin{aligned} T2U_w(x)&amp;= B2U_w(T2B_w(x))\\[3px] U2T_w(x)&amp;= B2T_w(U2B_w(x)) \end{aligned} \]</span> 　　<code>0xCFC7</code>的16位位模式既是-12345的补码表示，也是53191的无符号表示，而两者的绝对值之和是<span class="math inline">\(2^{16}\)</span>。该属性也适用于给定位模式表示的两个数值 (补码和无符号数) 之间的关系，无符号表示中<span class="math inline">\(UMax\)</span>和-1的补码具有相同的位模式，所以<span class="math inline">\(1+UMax_w=2^w\)</span>。</p><p>　　对于位模式<span class="math inline">\(\vec{x}\)</span>，当计算<span class="math inline">\(B2U(\vec{x})-B2T(\vec{x})\)</span>时，0到<span class="math inline">\(w-2\)</span>位的加权和将相互抵消，最后得到<span class="math inline">\(x_{w-1}2^w\)</span>。 <span class="math display">\[ B2U_w(T2B_w(x))=T2U_w(x)=x+x_{w-1}2^w \]</span> 　　在<span class="math inline">\(x\)</span>的补码表示中，位<span class="math inline">\(x_{w-1}\)</span>决定了<span class="math inline">\(x\)</span>的正负。 <span class="math display">\[ T2U_w(x)= \begin{cases} x+2^w&amp;&amp;{TMin_x\leqslant x&lt;0}\\ x&amp;&amp;{0\leqslant x\leqslant TMax_w} \end{cases} \]</span> 　　假设<span class="math inline">\(\vec{u}=U2B_w(u)\)</span>，即<span class="math inline">\(U2T_w(u)\)</span>的补码表示。 <span class="math display">\[ U2T_w(u)=-u_{w-1}2^w+u \]</span> 　　对于<span class="math inline">\(u\)</span>的无符号表示，位<span class="math inline">\(u_{w-1}\)</span>决定<span class="math inline">\(u\)</span>是否大于<span class="math inline">\(TMax_w=2^{w-1}-1\)</span>。 <span class="math display">\[ U2T_w(u)= \begin{cases} u&amp;&amp;{0\leqslant u\leqslant TMax_w}\\ u-2^w&amp;&amp;{TMax_w&lt;u\leqslant UMax_w} \end{cases} \]</span> 　　当整数<span class="math inline">\(x\)</span>满足<span class="math inline">\(0\leqslant x\leqslant TMax_w\)</span>时，<span class="math inline">\(T2U_w(x)=U2T_w(x)=x\)</span>，在此范围之外的转换需要加上或减去<span class="math inline">\(2^w\)</span>。</p><h4 id="扩展整数的位表示">2.2.4 扩展整数的位表示</h4><p>　　<strong>零扩展</strong> (在位模式的开头填充0) 可用于将无符号数转换为位模式更长的无符号数。</p><p>　　假设<span class="math inline">\(w\)</span>位位向量<span class="math inline">\(\vec{u}=[u_{w-1},u_{w-2},\cdots ,u_0]\)</span>，<span class="math inline">\(w&#39;\)</span>位位向量<span class="math inline">\(\vec{u}&#39;=[0,\cdots ,0,u_{w-1},u_{w-2},\cdots ,u_0]\)</span>，当<span class="math inline">\(w&#39;&gt;w\)</span>时，<span class="math inline">\(B2U_w(\vec{u})=B2T_{w&#39;}(\vec{u}&#39;)\)</span>。</p><p>　　<strong>符号扩展</strong> (在位模式的开头填充最高有效位) 可用于将有符号数转换为位模式更长的有符号数。</p><p>　　假设<span class="math inline">\(w\)</span>位位向量<span class="math inline">\(\vec{x}=[x_{w-1},x_{w-2},\cdots ,x_0]\)</span>，<span class="math inline">\(w&#39;\)</span>位位向量<span class="math inline">\(\vec{x}&#39;=[x_{w-1},\cdots ,x_{w-1},x_{w-1},x_{w-2},\cdots ,x_0]\)</span>，当<span class="math inline">\(w&#39;&gt;w\)</span>时，<span class="math inline">\(B2U_w(\vec{u})=B2U_{w&#39;}(\vec{u}&#39;)\)</span>。若<span class="math inline">\(w&#39;=w+k\)</span>，则需证明： <span class="math display">\[ B2T_{w+k}([x_{w-1},...,x_{w-1},x_{w-1},x_{w-2},...,x_0])=B2T_w([x_{w-1},x_{w-2},...,x_0]) \]</span> 　　根据数学归纳法，若能证明符号扩展1位时数值不变，则符号扩展到任意位时数值也不变。 <span class="math display">\[ \begin{aligned} B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},...,x_0])&amp;=-x_{w-1}2^w+\sum^{w-1}_{i=0}x_i2^i\\[3px] &amp;=-x_{w-1}2^w+x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i\\[3px] &amp;=-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i\\[3px] &amp;=B2T_w([x_{w-1},x_{w-2},...,x_0]) \end{aligned} \]</span></p><h4 id="截断数值">2.2.5 截断数值</h4><p>　　当将<span class="math inline">\(w\)</span>位位向量截断为<span class="math inline">\(k\)</span>位时，会丢弃高<span class="math inline">\(w-k\)</span>位，这可能会改变其值 (这种情况也属于溢出)。</p><p>　　假设<span class="math inline">\(w\)</span>位位向量<span class="math inline">\(\vec{x}=[x_{w-1},w_{w-2},\cdots ,x_0]\)</span>，截断为<span class="math inline">\(k\)</span>位后的结果<span class="math inline">\(\vec{x}&#39;=[x_{k-1},w_{k-2},\cdots ,x_0]\)</span>，并且<span class="math inline">\(x=B2U_w(\vec{x})\)</span>，<span class="math inline">\(x&#39;=B2U_w(\vec{x}&#39;)\)</span>，则<span class="math inline">\(x&#39;=x\bmod 2^k\)</span>。 <span class="math display">\[ \begin{aligned} B2U([x_{w-1},x_{w-2},...,x_0])\bmod 2^k&amp;=[\sum_{i=0}^{w-1}x_i2^i]\bmod 2^k\\[3px] &amp;=[\sum_{i=0}^{k-1}x_i2^i]\bmod 2^k\\[3px] &amp;=\sum^{k-1}_{i=0}x_i2^i\\[3px] &amp;=B2U_k([x_{k-1},x_{k-2},...,x_0]) \end{aligned} \]</span> 　　对于无符号数，所有截断的位都具有形如<span class="math inline">\(2^i\)</span> (<span class="math inline">\(i\geqslant k\)</span>)的权重，这些权重都在模运算时会得到0。</p><p>　　假设<span class="math inline">\(w\)</span>位位向量<span class="math inline">\(\vec{x}=[x_{w-1},w_{w-2},\cdots ,x_0]\)</span>，截断为<span class="math inline">\(k\)</span>位后的结果<span class="math inline">\(\vec{x}&#39;=[x_{k-1},w_{k-2},\cdots ,x_0]\)</span>，并且<span class="math inline">\(x=B2T_w(\vec{x})\)</span>，<span class="math inline">\(x&#39;=B2T_w(\vec{x}&#39;)\)</span>，则<span class="math inline">\(x&#39;=U2T_k(x\bmod 2^k)\)</span>。</p><h3 id="整数运算">2.3 整数运算</h3><h4 id="无符号运算">2.3.1 无符号运算</h4><p>　　对于位模式为<span class="math inline">\(w\)</span>位的无符号数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>，两者的运算<span class="math inline">\(+^u_w\)</span>就是把和<span class="math inline">\(x+y\)</span>的位模式截断为<span class="math inline">\(w\)</span>位后的结果转换为无符号数。当<span class="math inline">\(x+y\geqslant 2^w\)</span>时，会发生溢出，溢出后的结果小于<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>。当执行C程序时，溢出不会导致错误。 <span class="math display">\[ x+^u_wy= \begin{cases} x+y&amp;&amp;{0\leqslant x+y&lt;2^w}\\ x+y-2^w&amp;&amp;{2^w\leqslant x+y&lt;2^{w+1}} \end{cases} \]</span> 　　模加法会形成<strong>阿贝尔群</strong>。阿贝尔群以挪威数学家Niels Henrik Abel (1802~1829) 命名，它是可交换和可结合的。阿贝尔群有1个单元0，并且每个元素都有1个加法逆元。对于位模式为<span class="math inline">\(w\)</span>位的无符号数<span class="math inline">\(x\)</span>，必有1个值<span class="math inline">\(-^u_wx\)</span>满足<span class="math inline">\(-^u_wx+^u_wx=0\)</span>。 <span class="math display">\[ -^u_wx= \begin{cases} x&amp;&amp;{x=0}\\ 2^w-x&amp;&amp;{0&lt;x\leqslant 2^w-1} \end{cases} \]</span></p><p>　　<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的运算<span class="math inline">\(*^u_w\)</span>是将乘积<span class="math inline">\(x\cdot y\)</span>的位模式 (<span class="math inline">\(2w\)</span>位) 截断为<span class="math inline">\(w\)</span>位后的结果转换为无符号数。 <span class="math display">\[ x*^u_wy=(x\cdot y)\bmod 2^w \]</span></p><h4 id="补码运算">2.3.2 补码运算</h4><p>　　对于位模式为<span class="math inline">\(w\)</span>位的补码<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>，两者的运算<span class="math inline">\(+^t_w\)</span>就是把和<span class="math inline">\(x+y\)</span>的位模式截断为<span class="math inline">\(w\)</span>位后的结果转换为补码。</p><p>　　<span class="math inline">\(+^t_w\)</span>与<span class="math inline">\(+^u_w\)</span>有相同的位级表示，所以<span class="math inline">\(+^t_w\)</span>等同于先将操作数转换为无符号数进行<span class="math inline">\(+^u_w\)</span>，再转换为补码。 <span class="math display">\[ \begin{aligned} x+^t_wy&amp;=U2T_w(T2U_w(x)+^u_wT2U(y))\\[3px] &amp;=U2T_w[(x_{w-1}2^w+x+y_{w-1}2^w+y)\bmod2^w]\\[3px] &amp;=U2T_w[(x+y)\bmod 2^w] \end{aligned} \]</span> 　　假设<span class="math inline">\(z=x+y\)</span>，<span class="math inline">\(z&#39;= z\bmod2^w\)</span>，<span class="math inline">\(z&#39;&#39;= U2T(z&#39;)=x+^t_wy\)</span>。</p><p>　　● 当<span class="math inline">\(-2^w\leqslant z&lt;-2^{w-1}\)</span>时，<span class="math inline">\(z&#39;=z+2^w\)</span>，所以<span class="math inline">\(0\leqslant z&#39;&lt;-2^{w-1}\)</span>，<span class="math inline">\(z&#39;&#39;=z&#39;\)</span>，此时，两个负数相加得到正数，称为<strong>负溢出</strong>。</p><p>　　● 当<span class="math inline">\(-2^{w-1}\leqslant z&lt;0\)</span>时，<span class="math inline">\(z&#39;=z+2^w\)</span>，所以<span class="math inline">\(2^{2-1}\leqslant z&#39;&lt;2^w\)</span>，<span class="math inline">\(z&#39;&#39;=z\)</span>。</p><p>　　● 当<span class="math inline">\(0\leqslant z&lt;2^{w-1}\)</span>时，<span class="math inline">\(z&#39;=z\)</span>，所以<span class="math inline">\(0\leqslant z&#39;&lt;2^{w-1}\)</span>，<span class="math inline">\(z&#39;&#39;=z\)</span>。</p><p>　　● 当<span class="math inline">\(2^{w-1}\leqslant z&lt;2^w\)</span>时，<span class="math inline">\(z&#39;=z\)</span>，所以<span class="math inline">\(2^{w-1}\leqslant z&#39;&lt;2^w\)</span>，<span class="math inline">\(z&#39;&#39;=z-2^w\)</span>，此时，两个正数相加得到负数，称为<strong>正溢出</strong>。 <span class="math display">\[ x+^t_wy= \begin{cases} x+y+2^w&amp;&amp;{-2^w\leqslant x+y&lt;-2^{w-1}}\\ x+y&amp;&amp;{-2^{w-1}\leqslant x+y&lt;2^{w-1}}\\ x+y-2^w&amp;&amp;{2^{w-1}\leqslant x+y&lt;2^w} \end{cases} \]</span> 　　<span class="math inline">\(TMin_w+TMin_w=-2^w\)</span>会导致负溢出，所以<span class="math inline">\(TMin_w+^t_wTMin_w=0\)</span>。若<span class="math inline">\(x&gt;Tmin_w\)</span>，并且<span class="math inline">\(-x\)</span>可以表示为<span class="math inline">\(w\)</span>位的补码，则<span class="math inline">\(-x+x=0\)</span>。 <span class="math display">\[ -^t_wx= \begin{cases} TMin_w&amp;&amp;{x=-2^{w-1}}\\ -x&amp;&amp;{-2^{w-1}&lt;x\leqslant 2^{w-1}-1} \end{cases} \]</span> 　　获取<span class="math inline">\(-^t_wx\)</span>的有2种方法。第1种方法是将<span class="math inline">\(x\)</span>的位模式中的所有位取反并将结果加1。第2种方法是先找到<span class="math inline">\(x\)</span>的位模式中的最右边的1，然后将其左侧的所有位取反。</p><p>　　对于<span class="math inline">\(w\)</span>位位向量<span class="math inline">\(\vec{x}\)</span>和<span class="math inline">\(\vec{y}\)</span>，<span class="math inline">\(x=B2T_w(\vec{x})\)</span>，<span class="math inline">\(y=B2T_w(\vec{y})\)</span>，<span class="math inline">\(x&#39;=B2U_w(\vec{x})\)</span>，<span class="math inline">\(y&#39;=B2U_w(\vec{y})\)</span>。 <span class="math display">\[ \begin{aligned} (x&#39;\cdot y&#39;)\bmod 2^w&amp;=[(x+x_{w-1}2^w)\cdot(y+y_{w-1}2^w)]\bmod 2^w\\[3px] &amp;=[x\cdot y+(x_{w-1}y+y_{w-1}x)2^w+x_{w-1}y_{w-1}2^{2w}]\bmod 2^w\\[3px] &amp;=(x\cdot y)\bmod 2^w \end{aligned} \]</span> 　　因此，无符号数和补码乘法运算的位级表示相同。</p><p>　　<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>的运算<span class="math inline">\(*^t_w\)</span>也是将乘积<span class="math inline">\(x\cdot y\)</span>的位模式 (<span class="math inline">\(2w\)</span>位) 截断为<span class="math inline">\(w\)</span>位后的结果转换为补码。 <span class="math display">\[ x*^t_wy=U2T_w((x\cdot y)\bmod 2^w) \]</span></p><h4 id="除以2的幂">2.3.3 除以2的幂</h4><p>　　除以2的幂可以用右移操作实现，逻辑右移和算术右移分别对应无符号值和补码值。因此，大多数计算机都支持这2种右移，但这种方法并不适用于所有整数。</p><p>　　对于实数<span class="math inline">\(a\)</span>，<span class="math inline">\(\lfloor a \rfloor\)</span>表示唯一整数<span class="math inline">\(a&#39;\)</span>，使得<span class="math inline">\(a&#39;\leqslant a\leqslant a&#39;+1\)</span>。<span class="math inline">\(\lceil a \rceil\)</span>表示唯一整数<span class="math inline">\(a&#39;&#39;\)</span>，使得<span class="math inline">\(a&#39;&#39;-1 \leqslant a\leqslant a&#39;&#39;\)</span>。</p><p>　　整数除法通常向零舍入 (结果为正时向下舍入，结果为负时向上舍入)。因此，当<span class="math inline">\(x\geqslant 0\)</span>和<span class="math inline">\(y&gt;0\)</span>时，会得到<span class="math inline">\(\lfloor \frac{x}{y} \rfloor\)</span>；当<span class="math inline">\(x&lt;0\)</span>和<span class="math inline">\(y&gt;0\)</span>时，会得到<span class="math inline">\(\lceil \frac{x}{y} \rceil\)</span>。</p><h5 id="无符号数除以2的幂">2.3.3.1 无符号数除以2的幂</h5><p>　　若C变量<code>x</code>和<code>k</code>的值分别为无符号值<span class="math inline">\(x\)</span>和<span class="math inline">\(k\)</span>，<span class="math inline">\(x\)</span>的位模式是<span class="math inline">\([x_{w-1},x_{w-2},...,x_0]\)</span>，并且<span class="math inline">\(0\leqslant k&lt;w\)</span>，则<code>x &gt;&gt; k</code>会执行逻辑右移并向下舍入。</p><p>　　若<span class="math inline">\(x&#39;\)</span>表示<span class="math inline">\(x\)</span>的高<span class="math inline">\(w-k\)</span>位的位模式<span class="math inline">\([x_{w-1},x_{w-2},...,x_k]\)</span>，<span class="math inline">\(x&#39;&#39;\)</span>表示<span class="math inline">\(x\)</span>的低<span class="math inline">\(k\)</span>位的位模式<span class="math inline">\([x_{k-1},...,x_0]\)</span>，则<span class="math inline">\(x=2^kx&#39;+x&#39;&#39;\)</span> (<span class="math inline">\(0\leqslant x&#39;&#39;&lt;2^k\)</span>)。因此，<span class="math inline">\(\lfloor \frac{x}{2^k} \rfloor=x&#39;\)</span>。</p><p>　　下表是对12340的16位表示进行逻辑右移后的结果 (粗体表示从左边移入的0)：</p><table><thead><tr><th><code>k</code></th><th><code>&gt;&gt; k</code> (二进制)</th><th>十进制</th><th><code>12340 / (2 ^ k)</code></th></tr></thead><tbody><tr><td>0</td><td>0011000000110100</td><td>12340</td><td>12340.0</td></tr><tr><td>1</td><td><strong>0</strong>001100000011010</td><td>6170</td><td>6170.0</td></tr><tr><td>4</td><td><strong>0000</strong>001100000011</td><td>771</td><td>771.25</td></tr><tr><td>8</td><td><strong>00000000</strong>00110000</td><td>48</td><td>48.203125</td></tr></tbody></table><h5 id="补码除以2的幂">2.3.3.2 补码除以2的幂</h5><p>　　若C变量<code>x</code>和<code>k</code>的值分别是补码值<span class="math inline">\(x\)</span>和无符号值<span class="math inline">\(k\)</span>，<span class="math inline">\(x\)</span>的位模式是<span class="math inline">\([x_{w-1},x_{w-2},...,x_0]\)</span>，并且<span class="math inline">\(0\leqslant k&lt;w\)</span>，则<code>x &gt;&gt; k</code>会执行算术右移并向下舍入。</p><p>　　当<span class="math inline">\(x\geqslant 0\)</span>时，<span class="math inline">\(x\)</span>的最高位是0，算术右移与逻辑右移相同。当<span class="math inline">\(x&lt;0\)</span>时，算术右移<span class="math inline">\(k\)</span>位后，高<span class="math inline">\(k\)</span>位都会变为1，刚好是<span class="math inline">\(\lfloor \frac{x}{2^k} \rfloor\)</span>的补码表示。</p><p>　　下表是对-12340的16位表示进行逻辑右移后的结果 (对于不需要舍入的情况，结果是<span class="math inline">\(\frac{x}{2^k}\)</span>。对于需要舍入的情况，算术右移会导致向下舍入)：</p><table><thead><tr><th><code>k</code></th><th><code>&gt;&gt; k</code> (二进制)</th><th>十进制</th><th><code>-12340 / (2 ^ k)</code></th></tr></thead><tbody><tr><td>0</td><td>1100111111001100</td><td>-12340</td><td>-12340.0</td></tr><tr><td>1</td><td><strong>1</strong>110011111100110</td><td>-6170</td><td>-6170.0</td></tr><tr><td>4</td><td><strong>1111</strong>110011111100</td><td>-772</td><td>-771.25</td></tr><tr><td>8</td><td><strong>11111111</strong>11001111</td><td>-49</td><td>−48.203125</td></tr></tbody></table><p>　　为了保证整数除法向零舍入，算术右移前需要加上<span style="background-color:#ff0">偏置值</span><span class="math inline">\(2^k-1\)</span> (即<code>(x + (1 &lt;&lt; k) - 1) &gt;&gt; k</code>)：</p><table><colgroup><col style="width:5%"><col style="width:7%"><col style="width:30%"><col style="width:25%"><col style="width:7%"><col style="width:23%"></colgroup><thead><tr><th><code>k</code></th><th>偏置值</th><th>-12340 + 偏置值 (二进制)</th><th><code>&gt;&gt; k</code> (二进制)</th><th>十进制</th><th><code>-12340 / (2 ^ k)</code></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1100111111001100</td><td>1100111111001100</td><td>-12340</td><td>-12340.0</td></tr><tr><td>1</td><td>1</td><td>110011111100110<strong>1</strong></td><td><strong>1</strong>110011111100110</td><td>-6170</td><td>-6170.0</td></tr><tr><td>4</td><td>15</td><td>110011111101<strong>1011</strong></td><td><strong>1111</strong>110011111101</td><td>-771</td><td>-771.25</td></tr><tr><td>8</td><td>255</td><td>11010000<strong>11001011</strong></td><td><strong>11111111</strong>11010000</td><td>-48</td><td>−48.203125</td></tr></tbody></table><p>　　第3列展示了-12340与偏置值相加的结果，粗体表示低<span class="math inline">\(k\)</span>位，其左侧的位可能会增加，也可能不会增加。对于不需要舍入的情况，偏置值只会影响那些会移动的位。对于需要舍入的情况，偏置值会导致较高的位增加 (即结果将向零舍入)。</p><p>　　若<span class="math inline">\(x=qy+r\)</span>，并且<span class="math inline">\(0\leqslant x&lt;y\)</span>，则<span class="math inline">\(\frac{x+y-1}{y}=q+\frac{r+y-1}{y}\)</span>，所以<span class="math inline">\(\lfloor\frac{x+y-1}{y}\rfloor=q+\lfloor\frac{r+y-1}{y}\rfloor\)</span>。当<span class="math inline">\(r=0\)</span>时，<span class="math inline">\(\lfloor\frac{r+y-1}{y}\rfloor\)</span>会得到0；当<span class="math inline">\(r&gt;0\)</span>时，<span class="math inline">\(\lfloor\frac{r+y-1}{y}\rfloor\)</span>会得到1。因此，对于整数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span> (<span class="math inline">\(y&gt;0\)</span>)，<span class="math inline">\(\lceil\frac{x}{y}\rceil=\lfloor \frac{x+y-1}{y} \rfloor\)</span>，偏置技术充分利用了这一点。当<span class="math inline">\(y=2^k\)</span>时，<code>(x + (1 &lt;&lt; k) - 1) &gt;&gt; k</code>会将<span class="math inline">\(x+2^k-1\)</span>右移<span class="math inline">\(k\)</span>位，得到<span class="math inline">\(\lceil\frac{x}{2^k}\rceil\)</span>。</p><h3 id="浮点数">2.4 浮点数</h3><p>　　浮点数表示用于对形如<span class="math inline">\(V=x\times 2^y\)</span>的有理数进行编码。对于涉及非常大的数 (<span class="math inline">\(|V|&gt;&gt;0\)</span>)、非常接近于0的数 (<span class="math inline">\(0&lt;|V|&lt;&lt;1\)</span>) 以及更普遍的作为实数运算的近似值的计算，它很实用。</p><h4 id="二进制小数">2.4.1 二进制小数</h4><p>　　小数的十进制表示为<span class="math inline">\(d_md_{m-1}\cdots d_1d_0.d_{-1}d_{-2}\cdots d_{-n+1}d_{-n}\)</span>。小数点左侧的数的权是10的正幂 (对应整数值)，右侧的数的权是10的负幂 (对应小数值)。 <span class="math display">\[ d=\sum^m_{i=-n}10^i\times d_i \]</span> 　　小数的二进制表示为<span class="math inline">\(b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots b_{-n+1}b_{-n}\)</span>。小数点左侧的数的权是2的正幂，右侧的数的权是2的负幂。小数点左移<span class="math inline">\(n\)</span>位相当于除以<span class="math inline">\(2^n\)</span>，右移<span class="math inline">\(n\)</span>位相当于乘以<span class="math inline">\(2^n\)</span>。 <span class="math display">\[ b=\sum^m_{i=-n}2^i\times b_i \]</span> 　　有些小数不能确切地用二进制表示，只能近似地表示，但增加二进制表示的长度可以提高精度。</p><h4 id="ieee浮点表示">2.4.2 IEEE浮点表示</h4><p>　　IEEE浮点标准用<span class="math inline">\(V=(-1)^s\times M\times 2^E\)</span>表示数字。</p><p>　　● <span class="math inline">\(s\)</span>表示<strong>符号位</strong>，<span class="math inline">\(s=1\)</span>时表示负数，<span class="math inline">\(s=0\)</span>时表示正数。数值0的符号位解释作为特殊情况处理。</p><p>　　● <span class="math inline">\(M\)</span>表示<strong>尾数</strong>，它是二进制小数，其范围是<span class="math inline">\(1\sim 2-\epsilon\)</span>或<span class="math inline">\(0\sim 1-\epsilon\)</span>。</p><p>　　● <span class="math inline">\(E\)</span>表示<strong>阶码</strong>，用于对浮点数加权。</p><img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/standard_floating_point_format.svg"><p>　　在C中，单精度浮点数是32位，包括1位符号位、8位阶码和23位尾数。双精度浮点数是64位，包括1位符号位、11位阶码和52位尾数。</p><img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/categories_of_single_precision_floating_point_values.svg"><p>　　对于单精度浮点数，阶码值决定其类别。这里假设阶码和尾数的位模式长度分别表示为<span class="math inline">\(k\)</span>和<span class="math inline">\(n\)</span>。</p><p>　　● 最常见的情况是<strong>规格化</strong>数，其阶码的位模式不全为0或1。在这种情况下，阶码被解释为<strong>偏置</strong>形式表示的有符号整数，即阶码值<span class="math inline">\(E=e-Bias\)</span>，其中<span class="math inline">\(e\)</span>是无符号数，其位模式是<span class="math inline">\(e_{k-1}\cdots e_1e_0\)</span>，<span class="math inline">\(Bias\)</span>是偏置值<span class="math inline">\(2^{k-1}-1\)</span>。因此，单精度浮点数的指数的取值范围是<span class="math inline">\(-126\sim +127\)</span>，双精度浮点数的指数范围是<span class="math inline">\(-1022\sim +1023\)</span>。尾数被解释为小数<span class="math inline">\(f\)</span> (<span class="math inline">\(0\leqslant f&lt;1\)</span>)，其二进制表示为<span class="math inline">\(0.f_{n-1}\cdots f_1f_0\)</span>。尾数定义为<span class="math inline">\(M=1+f\)</span>，这种方式也称为<strong>隐含前导1</strong>表示，因为<span class="math inline">\(M\)</span>的二进制表示为<span class="math inline">\(1.f_{n-1}\cdots f_1f_0\)</span>，这种表示方法可以获得额外精度。由于可以调整阶码<span class="math inline">\(E\)</span>来保证尾数<span class="math inline">\(M\)</span>在范围<span class="math inline">\([1,2)\)</span>内，所以无需显式地表示前导位。</p><p>　　● 当阶码位模式全为0时，表示<strong>非规格化</strong>数。在这种情况下，阶码值<span class="math inline">\(E=1-Bias\)</span>，尾数值<span class="math inline">\(M=f\)</span>。非规格数有2个用途。第1个用途是表示数值0，因为规格化数的尾数<span class="math inline">\(M\geqslant1\)</span>，不能表示0。实际上，<span class="math inline">\(+0.0\)</span>的位模式全为0。<span class="math inline">\(-0.0\)</span>与之类似，但位模式的符号位为1 (对于IEEE浮点格式，<span class="math inline">\(+0.0\)</span>和<span class="math inline">\(-0.0\)</span>在某些方面不同)。第2个用途是表示很接近0的数。这些数有1个称为<strong>渐进下溢</strong>的属性，即均匀分布在<span class="math inline">\(0.0\)</span>附近。</p><p>　　● 当阶码位模式全为1时，表示特殊值。当尾数位模式全为0时，表示无穷大，符号位是0表示<span class="math inline">\(+\infty\)</span>，符号位为1表示<span class="math inline">\(-\infty\)</span>。当很大的数相乘或除以0时，无穷大表示<span style="background-color:#ff0">溢出</span>。当尾数位模式不全为0时，表示<strong>非数字</strong> (NaN)，运算结果无穷大或不为实数时会返回NaN。某些应用程序会使用NaN来表示未初始化的数据。</p><table><colgroup><col style="width:21%"><col style="width:19%"><col style="width:17%"><col style="width:41%"></colgroup><thead><tr><th></th><th>阶码</th><th>尾数</th><th>数值</th></tr></thead><tbody><tr><td>最小的正非规格化数</td><td><span class="math inline">\(M=f=2^{-n}\)</span></td><td><span class="math inline">\(E=-2^{k-1}+2\)</span></td><td><span class="math inline">\(V=2^{-n-2^{k-1}+2}\)</span></td></tr><tr><td>最大的正非规格化数</td><td><span class="math inline">\(M=f=1-2^{-n}\)</span></td><td><span class="math inline">\(E=-2^{k-1}+2\)</span></td><td><span class="math inline">\(V=(1-2^{-n})\cdot 2^{-2^{k-1}+2}\)</span></td></tr><tr><td>最小的正规格化数</td><td><span class="math inline">\(M=1+f=1\)</span></td><td><span class="math inline">\(E=-2^{k-1}+2\)</span></td><td><span class="math inline">\(V=2^{-2^{k-1}+2}\)</span></td></tr><tr><td>最大的正规格化数</td><td><span class="math inline">\(M=1+f=2-2^{-n}\)</span></td><td><span class="math inline">\(E=2^{k-1}-1\)</span></td><td><span class="math inline">\(V=(1-2^{-n-1})\cdot 2^{2^{k-1}}\)</span></td></tr></tbody></table><p>　　以基于IEEE浮点格式的6位浮点数表示为例，包括3位阶码和2位尾数，所以偏置值<span class="math inline">\(Bias=2^{3-1}-1=3\)</span>。对于规格化数，阶码值的取值范围是<span class="math inline">\(-2\sim3\)</span>，尾数值的取值范围是<span class="math inline">\(1\sim \frac{7}{4}\)</span>，最大值是<span class="math inline">\(\pm14\)</span>，最小值是<span class="math inline">\(\pm\frac{1}{4}\)</span>。对于非规格化数，阶码值是<span class="math inline">\(-2\)</span>，尾数值的取值范围是<span class="math inline">\(0\sim \frac{3}{4}\)</span>，最大值是<span class="math inline">\(\pm \frac{3}{16}\)</span>，最小值是<span class="math inline">\(\pm 0\)</span>。非规格数聚集在0附近，它们并不是均匀分布，而是越靠近原点越密集。对比规格数的最小值和非规格数的最大值，可以发现两者之间的<span style="background-color:#ff0">平滑过渡</span>，因为非规格化数的阶码值<span class="math inline">\(E\)</span>定义为<span class="math inline">\(1-Bias\)</span>，这弥补了非规格化数的尾数没有隐含前导1。</p><img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/simple_example_of_converting_a_signed_number_to_a_floating_point_number.svg"><p>　　将整数转换为浮点形式对理解浮点表示很有用。以数值12345为例，其二进制表示为<span class="math inline">\([11000000111001]\)</span>，对应的规格化表示为<span class="math inline">\(1.1000000111001_2\cdot 2^{13}\)</span>。为了用IEEE单精度浮点表示，需要将二进制小数点左移13位，丢弃开头的1并在结尾添加10个0，然后计算尾数<span class="math inline">\(e=E+Bias=13+127=140\)</span>并转换为二进制，最后加上符号位。</p><h4 id="浮点运算">2.4.3 浮点运算</h4><p>　　浮点运算只能近似于实数运算，因为表示的范围和精度有限。因此，对于值<span class="math inline">\(x\)</span>，需要系统的方法来查找浮点格式能表示的最接近的值<span class="math inline">\(x&#39;\)</span>，这是<strong>舍入</strong>的任务。</p><p>　　IEEE浮点格式定义了4种舍入模式。默认舍入模式是向最近值舍入，也称为向偶数舍入，即向上或向下舍入来<span style="background-color:#ff0">尽量</span>保证结果的最低有效位为偶数。当存在2个可能的舍入值时，选择最低有效位为偶数的舍入值。其他3种方式会在实际值上产生<span style="background-color:#ff0">确界</span>，分别是向上舍入、向零舍入和向下舍入。以保留整数为例，下表展示了这4种舍入模式的结果：</p><table><thead><tr><th>舍入模式</th><th>-1.50</th><th>1.40</th><th>1.50</th><th>1.60</th><th>2.5</th></tr></thead><tbody><tr><td>向偶数舍入</td><td>-2</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>向零舍入</td><td>-1</td><td>1</td><td>1</td><td>1</td><td>2</td></tr><tr><td>向上舍入</td><td>-1</td><td>2</td><td>2</td><td>2</td><td>3</td></tr><tr><td>向下舍入</td><td>-2</td><td>1</td><td>1</td><td>1</td><td>2</td></tr></tbody></table><p>　　向偶数舍入也能应用于二进制小数 (0是偶数)。位模式形如<span class="math inline">\(XX\cdots X.YY\cdots Y100\cdots\)</span>的数 (最右侧的<span class="math inline">\(Y\)</span>是待舍入的位置) 才可能有2个舍入值。以保留2位小数为例，<span class="math inline">\(10.00011_2\)</span>会舍入为<span class="math inline">\(10.00_2\)</span>，<span class="math inline">\(10.00110_2\)</span>会舍入为<span class="math inline">\(10.01_2\)</span>，<span class="math inline">\(10.11100_2\)</span>会舍入为<span class="math inline">\(11.00_2\)</span>，<span class="math inline">\(10.10100_2\)</span>会舍入为<span class="math inline">\(10.10\)</span>。</p><p>　　计算数据的平均值时舍入的使用会引入统计偏差。无论向上舍入、向零舍入还是向下舍入，都会增大统计偏差，而向偶数舍入可以减小甚至消除统计偏差，因为大约一半的数据向上舍入，大约一半数据向下舍入。</p><p>　　IEEE规定了用于确定算术运算结果的规则：若将浮点数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>视为实数，则算术运算<span class="math inline">\(\odot\)</span>的结果应该是实际值的舍入结果<span class="math inline">\(Round(x\odot y)\)</span>。</p><p>　　与整数加法类似，实数加法也会形成阿贝尔群，但需要考虑舍入。假设<span class="math inline">\(x+^fy\)</span>表示<span class="math inline">\(Round(x+y)\)</span>，虽然<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>都是实数，但由于溢出可能得到无穷大。该运算是可交换的，<span class="math inline">\(x+^fy=y+^fx\)</span>。但是，该运算是不可结合的 (对于单精度浮点数，<code>(3.14 + 1e10) - 1e10</code>会得到0.0，而<code>3.14 + (1e10 - 1e10)</code>会得到3.14)。大多数在浮点加法时有逆元，<span class="math inline">\(x+^f-x=0\)</span>，无穷大和NaN是例外，因为<span class="math inline">\(+\infty-\infty=NaN\)</span>，<span class="math inline">\(NaN+^fx=NaN\)</span>。</p><p>　　浮点加法满足单调性，即若<span class="math inline">\(a\geqslant b\)</span>，则<span class="math inline">\(x+^fa\geqslant x+^fb\)</span> (<span class="math inline">\(x\neq NaN\)</span>)。</p><p>　　由于浮点加法不具有可结合性，<code>x = a + b + c</code>可能会被编译器替换为<code>t = b + c</code>和<code>x = a + t</code>。在大多数情况下，这种差异无关紧要。编译器无法得知如何取舍效率和保留原始程序的确切行为，所以编译器通常很保守，避免任何可能对功能产生影响的优化。</p><p>　　浮点乘法有常规乘数的很多属性。假设<span class="math inline">\(x\cdot^fy\)</span>表示<span class="math inline">\(Round(x\cdot y)\)</span>，该运算会在乘法下闭合 (可能产生无穷大或NaN)。该运算是可交换的，并且有1.0作为乘法恒等式。由于溢出或舍入会导致精度丢失，所以该运算是不可结合和不可分配的。该运算满足单调性，对于不为NaN的<span class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span>和<span class="math inline">\(c\)</span> (<span class="math inline">\(a\geqslant b\)</span>)，若<span class="math inline">\(c\geqslant 0\)</span>，则<span class="math inline">\(a\cdot^fc \geqslant b \cdot^f c\)</span>；若<span class="math inline">\(c\leqslant0\)</span>，则<span class="math inline">\(a\cdot^f c\leqslant b\cdot^f c\)</span>。</p><h4 id="c相关支持-1">2.4.4 C相关支持</h4><p>　　C提供了数据类型<code>float</code>和<code>double</code>来支持浮点数，其舍入模式是向偶数舍入。C标准不要求计算机使用IEEE浮点格式，所以没有标准方法来更改舍入模式和获取特殊值。但是，对于大多数系统，可以通过头文件引用和过程库的结合来提供这些支持，具体实现因系统而异。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>　　这段代码会让gcc定义常数<code>INFINTY</code>和<code>NAN</code>。</p><p>　　当<code>int</code>转换为<code>float</code>时，可能会舍入。当<code>int</code>或<code>float</code>转换为<code>double</code>时，不会有精度损失。当<code>double</code>转换为<code>float</code>时，可能会溢出为<span class="math inline">\(\pm\infty\)</span>或者舍入。当<code>float</code>或<code>double</code>转换为<code>int</code>时，可能会向零舍入或溢出，C标准没有为这种情况指定结果。</p><p>　　Intel兼容微处理器会用位模式<span class="math inline">\([10\cdots00]\)</span>表示<strong>整数不定值</strong>。当浮点数转换为整数时，若没有合理的整数近似值，则会产生该值。因此，<code>(int)+1e10</code>会得到-21483648 (从正值变为负值)。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/" rel="prev" title="《深入理解计算机系统 第3版》第1章 计算机系统概览"><i class="fa fa-angle-left"></i> 《深入理解计算机系统 第3版》第1章 计算机系统概览</a></div><div class="post-nav-item"><a href="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/" rel="next" title="《深入理解计算机系统 第3版》第3章 程序的机器级表示">《深入理解计算机系统 第3版》第3章 程序的机器级表示 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>