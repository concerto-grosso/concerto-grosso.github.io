<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》附录</title>
    <url>/network/computer_networking_a_top_down_approach_7e_appx/</url>
    <content><![CDATA[<h3 id="a.1-常见应用及其协议">A.1 常见应用及其协议</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">应用</th>
<th style="text-align: center;">应用层协议</th>
<th style="text-align: center;">传输层协议和端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">电子邮件</td>
<td style="text-align: center;">SMTP</td>
<td style="text-align: center;">TCP:25/465/587/2525</td>
</tr>
<tr>
<td style="text-align: center;">远程终端访问</td>
<td style="text-align: center;">Telnet</td>
<td style="text-align: center;">TCP:23</td>
</tr>
<tr>
<td style="text-align: center;">Web</td>
<td style="text-align: center;">HTTP</td>
<td style="text-align: center;">TCP:80</td>
</tr>
<tr>
<td style="text-align: center;">文件传输</td>
<td style="text-align: center;">FTP</td>
<td style="text-align: center;">TCP:20/21</td>
</tr>
<tr>
<td style="text-align: center;">远程文件服务器</td>
<td style="text-align: center;">NFS</td>
<td style="text-align: center;">UDP:2049</td>
</tr>
<tr>
<td style="text-align: center;">流式多媒体</td>
<td style="text-align: center;">通常专用</td>
<td style="text-align: center;">TCP/UDP</td>
</tr>
<tr>
<td style="text-align: center;">互联网电话</td>
<td style="text-align: center;">通常专用</td>
<td style="text-align: center;">TCP/UDP</td>
</tr>
<tr>
<td style="text-align: center;">网络管理</td>
<td style="text-align: center;">SNMP</td>
<td style="text-align: center;">UDP:161/162</td>
</tr>
<tr>
<td style="text-align: center;">域名系统</td>
<td style="text-align: center;">DNS</td>
<td style="text-align: center;">UDP:53</td>
</tr>
<tr>
<td style="text-align: center;">SSH隧道</td>
<td style="text-align: center;">SSH</td>
<td style="text-align: center;">TCP:22</td>
</tr>
<tr>
<td style="text-align: center;">DHCP</td>
<td style="text-align: center;">BOOTP</td>
<td style="text-align: center;">UDP:67 (服务器) /68 (客户端)</td>
</tr>
<tr>
<td style="text-align: center;">BGP</td>
<td style="text-align: center;">BGP</td>
<td style="text-align: center;">TCP:179</td>
</tr>
<tr>
<td style="text-align: center;">OpenFlow</td>
<td style="text-align: center;">OpenFlow</td>
<td style="text-align: center;">TCP:6653</td>
</tr>
<tr>
<td style="text-align: center;">网络管理</td>
<td style="text-align: center;">SNMP</td>
<td style="text-align: center;">UDP:161/162/163或
(D)TLS:10161/10162</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h3 id="a.2-专业术语">A.2 专业术语</h3>
<blockquote>
<p><strong>access point (AP)</strong> 访问接入点</p>
<p><strong>active scanning</strong> 主动扫描</p>
<p><strong>ad hoc network</strong> 自组织网络</p>
<p><strong>advanced audio coding (AAC)</strong> 高级音频编码</p>
<p><strong>acknowledgment (ACK)</strong> 确认</p>
<p><strong>active optical network terminator (AON)</strong>
主动光纤网络</p>
<p><strong>active queue management (AQM)</strong> 主动队列算法</p>
<p><strong>additive increase,multiplicative decrease (AIMD)</strong>
加性增、乘性减</p>
<p><strong>address aggregation</strong> 地址聚合</p>
<p><strong>address lease time</strong> 地址租用期</p>
<p><strong>address resolution protocol (ARP)</strong> 地址解析协议</p>
<p><strong>advanced encryption standard (AES)</strong> 高级加密标准</p>
<p><strong>agent discovery</strong> 代理发现</p>
<p><strong>agent solicitation</strong> 代理请求</p>
<p><strong>aggregator</strong> 聚合器</p>
<p><strong>alternating bit protocol</strong> 比特交替协议</p>
<p><strong>anchor </strong> 锚</p>
<p><strong>anycast</strong> 任播</p>
<p><strong>application programming interface (API)</strong>
应用程序编程接口</p>
<p><strong>assured forwarding (AF)</strong> 确保转发</p>
<p><strong>asymmetric encryption</strong> 非对称加密</p>
<p><strong>asynchronous transfer mode (ATM)</strong> 异步传输模式</p>
<p><strong>atomic aggregate</strong> 原子聚合</p>
<p><strong>authentication key</strong> 认证密钥</p>
<p><strong>authentication header (AH)</strong> 认证首部</p>
<p><strong>authentication protocol (AP)</strong> 认证协议</p>
<p><strong>automatic repeat request (ARQ)</strong> 自动重传请求</p>
<p><strong>autonomous system (AS)</strong> 自治系统</p>
<p><strong>available bite rate (ABR)</strong> 可用比特率</p>
<p><strong>average throughput</strong> 平均吞吐量</p>
<p><strong>bandwidth</strong> 带宽</p>
<p><strong>bandwidth provisioning</strong> 带宽供给</p>
<p><strong>bandwidth sensitive application</strong> 带宽敏感的应用</p>
<p><strong>base station</strong> 基站</p>
<p><strong>base station controller (BSC)</strong> 基站控制器</p>
<p><strong>base station system (BSS)</strong> 基站系统</p>
<p><strong>base transceiver station (BTS)</strong> 基站收发台</p>
<p><strong>basic service set (BSS)</strong> 基本服务集</p>
<p><strong>beacon frame</strong> 信标帧</p>
<p><strong>Berkeley Internet Name Domain (BIND/NAMED)</strong>
DNS服务器软件</p>
<p><strong>best effort delivery service</strong> 尽力而为交付服务</p>
<p><strong>best effort service</strong> 尽力而为服务</p>
<p><strong>BGP attribute</strong> BGP属性</p>
<p><strong>BGP speaker</strong> BGP发言者</p>
<p><strong>blade</strong> 刀片</p>
<p><strong>block cipher</strong> 块加密</p>
<p><strong>bidirectional data transfer</strong> 双向/全双工数据传输</p>
<p><strong>binary exponential back off</strong> 二进制指数退避</p>
<p><strong>bit error ratio (BER)</strong> 比特差错率</p>
<p><strong>bootstrap protocol (BOOTP)</strong> 引导程序协议</p>
<p><strong>border gateway protocol (BGP)</strong> 边界网关协议</p>
<p><strong>border router</strong> 边界路由器</p>
<p><strong>botnet</strong> 僵尸网络</p>
<p><strong>bottleneck link</strong> 瓶颈链路</p>
<p><strong>bring home</strong> 客邀</p>
<p><strong>broadcast</strong> 广播</p>
<p><strong>cable internet access</strong> 电缆互联网接入</p>
<p><strong>cable modern</strong> 电缆调制解调器</p>
<p><strong>cable modern termination system (CMTS)</strong>
电缆调制解调器终端系统</p>
<p><strong>call admission control (CAC)</strong> 呼叫准入控制</p>
<p><strong>call setup</strong> 呼叫建立</p>
<p><strong>canonical hostname</strong> 规范主机名</p>
<p><strong>care-of address (COA)</strong> 转交地址</p>
<p><strong>carrier sense multiple access (CSMA)</strong>
载波侦听多路访问</p>
<p><strong>carrier sense multiple access with collision avoidance
(CSMA/CA)</strong> 带有碰撞避免的载波侦听多路访问</p>
<p><strong>carrier sense multiple access with collision detection
(CSMA/CD)</strong> 带有碰撞检测的载波侦听多路访问</p>
<p><strong>Caesar cipher</strong> 凯撒密码</p>
<p><strong>cellular</strong> 蜂窝</p>
<p><strong>centralized routing algorithm</strong> 集中式路由选择算法</p>
<p><strong>certificate</strong> 证书</p>
<p><strong>certification authority (CA)</strong> 认证中心</p>
<p><strong>channel partitioning protocol</strong> 信道划分协议</p>
<p><strong>channel propagation delay</strong> 信道传播时延</p>
<p><strong>chipping rate</strong> 码片速率</p>
<p><strong>choke packet</strong> 抑制分组</p>
<p><strong>chosen-plaintext attack</strong> 选择明文攻击</p>
<p><strong>cipher block chaining (CBC)</strong> 密码块链接</p>
<p><strong>ciphertext</strong> 密文</p>
<p><strong>ciphertext-only attack</strong> 唯密文攻击</p>
<p><strong>circuit</strong> 电路</p>
<p><strong>circuit switching</strong> 电路交换</p>
<p><strong>class of service (COS)</strong> 服务分类</p>
<p><strong>classful addressing</strong> 分类编制</p>
<p><strong>classless interdomain routing (CIDR)</strong>
无类别域间路由选择</p>
<p><strong>clear to send (CTS)</strong> 允许发送</p>
<p><strong>client</strong> 客户端</p>
<p><strong>cluster selection strategy</strong> 集群选择策略</p>
<p><strong>code division multiple access (CDMA)</strong> 码分多址</p>
<p><strong>communication link</strong> 通信链路</p>
<p><strong>congestion avoidance</strong> 拥塞避免</p>
<p><strong>congestion control</strong> 拥塞控制</p>
<p><strong>congestion window reduced (CWR)</strong> 拥塞窗口减少</p>
<p><strong>congestion window (cwnd)</strong> 拥塞窗口</p>
<p><strong>collision detection</strong> 碰撞检测</p>
<p><strong>compact disk (CD)</strong> 光盘</p>
<p><strong>connection oriented</strong> 面向连接的</p>
<p><strong>content distribution network (CDN)</strong> 内容分发网络</p>
<p><strong>content provider network</strong> 内容提供商网络</p>
<p><strong>contention period (CP)</strong> 竞争周期</p>
<p><strong>contention window (CW)</strong> 竞争窗口</p>
<p><strong>contention-free period (CFP)</strong> 无竞争周期</p>
<p><strong>control plane</strong> 控制平面</p>
<p><strong>convergence</strong> 收敛</p>
<p><strong>correspondent</strong> 通信者</p>
<p><strong>correspondent agent</strong> 通信者代理</p>
<p><strong>count to infinity</strong> 无穷计数</p>
<p><strong>countdown timer</strong> 倒数计时器</p>
<p><strong>cryptographic hash function</strong> 密码散列函数</p>
<p><strong>cumulative acknowledgement</strong> 累积确认</p>
<p><strong>customer</strong> 客户</p>
<p><strong>cyclic redundancy check (CRC)</strong> 循环冗余校验</p>
<p><strong>data center</strong> 数据中心</p>
<p><strong>data center network</strong> 数据中心网络</p>
<p><strong>data center TCP (DCTCP)</strong> 数据中心TCP</p>
<p><strong>data encryption standard (DES)</strong> 数据加密标准</p>
<p><strong>data over cable service interface specification
(DOCSIS)</strong> 有线电缆数据服务接口规范</p>
<p><strong>data plane</strong> 数据平面</p>
<p><strong>datagram</strong> 数据报</p>
<p><strong>datagram congestion control protocol (DCCP)</strong>
数据报拥塞控制协议</p>
<p><strong>decentralized routing algorithm</strong>
分布式路由选择算法</p>
<p><strong>deep packet inspection (DPI)</strong> 深度分组检测</p>
<p><strong>default gateway</strong> 默认网关</p>
<p><strong>delay,throughput,reliability (DTR)</strong>
延迟、吞吐量、可靠性</p>
<p><strong>denial of service (DOS)</strong> 拒绝服务</p>
<p><strong>demilitarized zone (DMZ)</strong> 隔离区</p>
<p><strong>demultiplexing</strong> 多路分解</p>
<p><strong>destination options</strong> 目的选项</p>
<p><strong>destination port number field</strong> 目的端口号字段</p>
<p><strong>DHCP decline message</strong> DHCP拒绝报文</p>
<p><strong>DHCP discover message</strong> DHCP发现报文</p>
<p><strong>DHCP Inform message</strong> DHCP信息报文</p>
<p><strong>DHCP offer message</strong> DHCP提供报文</p>
<p><strong>DHCP release message</strong> DHCP释放报文</p>
<p><strong>DHCP request message</strong> DHCP请求报文</p>
<p><strong>differentiated service (diffserv, DS)</strong> 区分服务</p>
<p><strong>digital subscriber line (DSL)</strong> 数字用户线</p>
<p><strong>digital signature</strong> 数字签名</p>
<p><strong>direct sequence wideband CDMA (DS-WCDMA)</strong>
直接序列宽带码分多址</p>
<p><strong>distance vector (DV)</strong> 距离向量</p>
<p><strong>distinguished name (DN)</strong> 专用名称</p>
<p><strong>distributed application</strong> 分布式应用程序</p>
<p><strong>distributed coordination function (DCF)</strong>
分布式协调功能</p>
<p><strong>distributed interframe space (DIFS)</strong>
分布式帧间间隔</p>
<p><strong>distribution time</strong> 分发时间</p>
<p><strong>DNS caching</strong> DNS缓存</p>
<p><strong>don't fragment (DF)</strong> 禁止分片</p>
<p><strong>domain name system (DNS)</strong> 域名系统</p>
<p><strong>dotted-decimal notation</strong> 点分十进制表示法</p>
<p><strong>drop tail</strong> 弃尾</p>
<p><strong>duplicate data packet</strong> 冗余数据分组</p>
<p><strong>dynamic adaptive streaming over HTTP (DASH)</strong>
HTTP动态自适应流</p>
<p><strong>dynamic host configuration protocol (DHCP)</strong>
动态主机配置协议</p>
<p><strong>dynamic routing algorithm</strong> 动态路由选择算法</p>
<p><strong>ECN Echo (ECE)</strong> 显式拥塞提醒回应</p>
<p><strong>edge router</strong> 边缘路由器</p>
<p><strong>encapsulating security payload (ESP)</strong>
封装安全有效载荷</p>
<p><strong>encapsulation</strong> 封装</p>
<p><strong>encrypted master secret (EMS)</strong> 加密主密钥</p>
<p><strong>end system</strong> 端系统</p>
<p><strong>end-end principle</strong> 端到端原则</p>
<p><strong>end-point authentication</strong> 端点认证</p>
<p><strong>end-to-end connection</strong> 端到端连接</p>
<p><strong>enhanced distributed channel access (EDCA)</strong>
增强分布式信道接入</p>
<p><strong>enhanced packet core (EPC)</strong> 增强分组核</p>
<p><strong>enter deep</strong> 深入</p>
<p><strong>elastic application</strong> 弹性应用</p>
<p><strong>event based programming</strong> 基于事件的编程</p>
<p><strong>error detection and correction (EDC)</strong>
差错检测和纠错</p>
<p><strong>expedited forwarding (EF)</strong> 加速转发</p>
<p><strong>explicit congestion notification (ECN)</strong>
显式拥塞通知</p>
<p><strong>extend simple mail transfer protocol (ESMTP)</strong>
扩展简单邮件传输协议</p>
<p><strong>extended interframe space (EIFS)</strong> 扩展帧间间隔</p>
<p><strong>extensible authentication protocol (EAP)</strong>
可扩展认证协议</p>
<p><strong>external BGP (EBGP)</strong> 外部BGP</p>
<p><strong>exponential weighted moving average (EWMA)</strong>
指数加权移动平均</p>
<p><strong>fast recovery</strong> 快速恢复</p>
<p><strong>fast retransmit</strong> 快速重传</p>
<p><strong>flooding</strong> 泛洪</p>
<p><strong>flow control service</strong> 流量控制协议</p>
<p><strong>flow table</strong> 流表</p>
<p><strong>fiber to the home (FTTH)</strong> 光纤到户</p>
<p><strong>file transfer protocol (FTP)</strong> 文件传输协议</p>
<p><strong>filtering</strong> 过滤</p>
<p><strong>finite state machine (FSM)</strong> 有限状态机</p>
<p><strong>firewall</strong> 防火墙</p>
<p><strong>first come first service (FCFS)</strong> 先来先服务</p>
<p><strong>first input first output (FIFO)</strong> 先进先出</p>
<p><strong>foreign address</strong> 外部地址</p>
<p><strong>foreign agent</strong> 外部代理</p>
<p><strong>foreign network</strong> 外部网络</p>
<p><strong>forward error correction (FEC)</strong> 前向纠错</p>
<p><strong>forwarding</strong> 转发</p>
<p><strong>forwarding equivalence class (FEC)</strong> 转发等价类</p>
<p><strong>forwarding table</strong> 转发表</p>
<p><strong>fragment</strong> 片</p>
<p><strong>frame</strong> 帧</p>
<p><strong>frame check sequence (FCS)</strong> 帧校验序列</p>
<p><strong>frequency division multiple access (FDMA)</strong>
频分多址</p>
<p><strong>frequency-division multiplexing (FDM)</strong> 频分复用</p>
<p><strong>frequency-hopping spread spectrum (FHSS)</strong>
跳频扩频</p>
<p><strong>full duplex service</strong> 全双工服务</p>
<p><strong>gateway router</strong> 网关路由器</p>
<p><strong>gateway GRPS support node (GGSN)</strong>
网关GRPS支持节点</p>
<p><strong>gateway mobile services switching center (GMSC)</strong>
网关移动交换中心</p>
<p><strong>general packet radio service (GRPS)</strong>
通用分组无线服务</p>
<p><strong>geographically closest</strong> 地理上最近</p>
<p><strong>geostationary satellite</strong> 同步卫星</p>
<p><strong>gigabit ethernet</strong> 吉比特/千兆以太网</p>
<p><strong>global system for mobile communications (GSM)</strong>
全球移动通信系统</p>
<p><strong>go-back-n (GBN)</strong> 回退N步</p>
<p><strong>guided media</strong> 导引型媒体</p>
<p><strong>hand off</strong> 切换</p>
<p><strong>hash-based message authentication code (HMAC)</strong>
散列报文认证码</p>
<p><strong>head of the line (HOL)</strong> 线路前部</p>
<p><strong>header line</strong> 首部行</p>
<p><strong>high-level data link control (HDLC)</strong>
高级数据链路控制</p>
<p><strong>high speed packet access (HSPA)</strong> 高速分组接入</p>
<p><strong>home agent</strong> 移动代理</p>
<p><strong>home location register (HLR)</strong> 归属位置寄存器</p>
<p><strong>home network</strong> 归属网络</p>
<p><strong>home subscriber server (HSS)</strong> 归属用户服务器</p>
<p><strong>hop by hop options</strong> 逐跳选项</p>
<p><strong>host</strong> 主机</p>
<p><strong>host aliasing</strong> 主机别名</p>
<p><strong>hostname</strong> 主机名</p>
<p><strong>hot potato routing</strong> 热土豆路由选择</p>
<p><strong>hub</strong> 集线器</p>
<p><strong>hybrid coordination function (HCF)</strong> 混合协调功能</p>
<p><strong>hybrid fiber coax (HFC)</strong> 混合光纤同轴</p>
<p><strong>hyper text transfer protocol (HTTP)</strong>
超文本传输协议</p>
<p><strong>infrastructure mode</strong> 基础设施模式</p>
<p><strong>ingress port</strong> 输入端口</p>
<p><strong>initial sequence number (ISN)</strong> 初始序号</p>
<p><strong>initialization vector (IV)</strong> 初始向量</p>
<p><strong>input port</strong> 输入端口</p>
<p><strong>instantaneous throughput</strong> 瞬时吞吐量</p>
<p><strong>interframe spacing (IFS)</strong> 帧间间隔</p>
<p><strong>interleave</strong> 交错</p>
<p><strong>intermediate system to intermediate system (IS-IS)</strong>
中间系统到中间系统</p>
<p><strong>internal BGP (IBGP)</strong> 内部BGP</p>
<p><strong>internal router</strong> 内部路由器</p>
<p><strong>international telecommunication union (ITU)</strong>
国际电信联盟</p>
<p><strong>internet control message protocol (ICMP)</strong>
互联网控制报文协议</p>
<p><strong>internet corporation for assigned names and numbers
(ICANN)</strong> 互联网名称与数字地址分配机构</p>
<p><strong>internet exchange point (IXP)</strong> 互联网交换点</p>
<p><strong>internet engineering task force (IETF)</strong>
互联网工程任务组</p>
<p><strong>internet group management protocol (IGMP)</strong>
互联网组管理协议</p>
<p><strong>internet key exchange (IKE)</strong> 互联网密钥交换</p>
<p><strong>internet mail access protocol (IMAP)</strong>
互联网邮件访问协议</p>
<p><strong>internet protocol (IP) </strong>网际协议</p>
<p><strong>internet protocol security (IPsec)</strong>
互联网安全协议</p>
<p><strong>internet service provider (ISP)</strong> 互联网服务提供商</p>
<p><strong>internet standard</strong> 互联网标准</p>
<p><strong>inter-autonomous system routing protocol</strong>
自治系统间路由选择协议</p>
<p><strong>intra-autonomous system routing protocol</strong>
自治系统内部路由选择协议</p>
<p><strong>intrusion detection system (IDS)</strong> 入侵检测系统</p>
<p><strong>intrusion prevention system (IPS)</strong> 入侵防御系统</p>
<p><strong>IP spoofing</strong> IP哄骗</p>
<p><strong>jitter</strong> 抖动</p>
<p><strong>key distribution center (KDC)</strong> 密钥分发中心</p>
<p><strong>key-signing party</strong> 密钥签署方</p>
<p><strong>label switching path (LSP)</strong> 标签交换路径</p>
<p><strong>label switching router (LSR)</strong> 标签交换路由器</p>
<p><strong>layer</strong> 分层</p>
<p><strong>least cost path</strong> 最低成本路径</p>
<p><strong>lightweight directory access protocol (LDAP)</strong>
轻型目录访问协议</p>
<p><strong>link layer switch</strong> 链路层交换机</p>
<p><strong>link state (LS)</strong> 链路状态</p>
<p><strong>link state advertisement (LSA)</strong> 链路状态通告</p>
<p><strong>link-scheduling discipline</strong> 链路调度规则</p>
<p><strong>known-plaintext attack</strong> 已知明文攻击</p>
<p><strong>load distribution</strong> 负载分配</p>
<p><strong>load insensitive algorithm</strong> 负载迟钝算法</p>
<p><strong>load sensitive algorithm</strong> 负载敏感算法</p>
<p><strong>local area network (LAN)</strong> 局域网</p>
<p><strong>local preference (LOCAL_PREF)</strong> 本地优先级</p>
<p><strong>logic communication</strong> 逻辑通信</p>
<p><strong>long term evolution (LTE)</strong> 长期演进</p>
<p><strong>longest prefix matching rule</strong> 最长前缀匹配规则</p>
<p><strong>loss tolerant application</strong> 容忍丢失的应用</p>
<p><strong>low earth orbiting (LEO)</strong> 近地轨道</p>
<p><strong>mail server aliasing</strong> 邮件服务别名</p>
<p><strong>managed device</strong> 被管设备</p>
<p><strong>managed object</strong> 被管对象</p>
<p><strong>management information base (MIB)</strong> 管理信息库</p>
<p><strong>managing server</strong> 管理服务器</p>
<p><strong>manifest file</strong> 告示文件</p>
<p><strong>malware</strong> 恶意软件</p>
<p><strong>master secret (MS)</strong> 主密钥</p>
<p><strong>maximum segment size (MSS)</strong> 最大报文段长度</p>
<p><strong>maximum transmission unit (MTU)</strong> 最大传输单元</p>
<p><strong>message</strong> 报文</p>
<p><strong>message authentication code (MAC)</strong> 报文认证码</p>
<p><strong>message integrity</strong> 报文完整性</p>
<p><strong>meter</strong> 计量</p>
<p><strong>modular data center (MDC)</strong> 模块化数据中心</p>
<p><strong>mobile ac hoc network (MANET)</strong> 移动自组织网络</p>
<p><strong>mobile station roaming number (MSRN)</strong>
移动站点漫游号</p>
<p><strong>mobility management entity (MME)</strong> 移动性管理实体</p>
<p><strong>mobile switching center (MSC)</strong> 移动交换中心</p>
<p><strong>monoalphabetic cipher</strong> 单表替换密码</p>
<p><strong>more fragment (MF)</strong> 还有分片</p>
<p><strong>multicast OSPF (MOSPF)</strong> 多播OSPF</p>
<p><strong>multipath propagation</strong> 多径传播</p>
<p><strong>multiple access</strong> 多路访问</p>
<p><strong>multiple input multiple output (MIMO)</strong>
多输入多输出</p>
<p><strong>multiprotocol label switching (MPLS)</strong>
多协议标签交换</p>
<p><strong>multi-exit discriminator (MED/MULTI_EXIT_DISC)</strong>
多出口鉴别器</p>
<p><strong>multi-home</strong> 多宿</p>
<p><strong>multi-homed access ISP</strong> 多宿接入ISP</p>
<p><strong>must be zero (MBZ)</strong> 必须为零</p>
<p><strong>NAT translation table</strong> NAT转换表</p>
<p><strong>media access control (MAC)</strong> 媒体访问控制</p>
<p><strong>mesh</strong> 网状</p>
<p><strong>negative acknowledgment (NAK)</strong> 否定确认</p>
<p><strong>net file system (NFS)</strong> 网络文件系统</p>
<p><strong>network address translation (NAT)</strong> 网络地址转换</p>
<p><strong>network allocation vector (NAV)</strong> 网络分配向量</p>
<p><strong>network architecture</strong> 网络体系结构</p>
<p><strong>network control server (NCS)</strong> 网络控制服务器</p>
<p><strong>network dimensioning</strong> 网络定制</p>
<p><strong>network functions virtualization (NFV)</strong>
网络功能虚拟化</p>
<p><strong>network information base (NIB)</strong> 网络信息数据库</p>
<p><strong>network interface card (NIC)</strong> 网络接口卡</p>
<p><strong>network management agent</strong> 网络管理代理</p>
<p><strong>network management protocol</strong> 网络管理协议</p>
<p><strong>network operations center (NOC)</strong> 网络运营中心</p>
<p><strong>network service model</strong> 网络服务模型</p>
<p><strong>nodal processing delay</strong> 节点处理时延</p>
<p><strong>nonce</strong> 不重数</p>
<p><strong>nonce sum (NS)</strong> 随机数和</p>
<p><strong>non-persistent connection</strong> 非持续连接</p>
<p><strong>non-preemptive priority queueing</strong>
非抢占式优先级排队</p>
<p><strong>offered load</strong> 供给载荷</p>
<p><strong>open network operating system (ONOS)</strong>
开放网络操作系统</p>
<p><strong>open shortest path first (OSPF)</strong>
开放式最短路径优先</p>
<p><strong>open system interconnection reference model (OSI
model)</strong> 开放式系统互联网通信参考模型</p>
<p><strong>OpenFlow agent (OFA)</strong> OpenFlow代理</p>
<p><strong>OpenFlow controller (OFC)</strong> OpenFlow控制器</p>
<p><strong>optical Carrier (OC)</strong> 光载波</p>
<p><strong>optical line terminator (OLT)</strong> 光纤线路端连接器</p>
<p><strong>optical network terminator (ONT)</strong> 光纤网络终端</p>
<p><strong>optional non-transitive</strong> 可选非传递</p>
<p><strong>optional transitive</strong> 可选传递</p>
<p><strong>orthogonal frequency division multiplexing (OFDM)</strong>
正交频分复用</p>
<p><strong>output buffer</strong> 输出缓存</p>
<p><strong>output port</strong> 输出端口</p>
<p><strong>output queue</strong> 输出队列</p>
<p><strong>packet</strong> 分组</p>
<p><strong>packet data network gateway (P-GW)</strong>
分组数据网络网关</p>
<p><strong>packet loss</strong> 分组丢包</p>
<p><strong>packet sniffer</strong> 分组嗅探器</p>
<p><strong>packet switch</strong> 分组交换机</p>
<p><strong>packet switching</strong> 分组交换</p>
<p><strong>paging</strong> 寻呼</p>
<p><strong>pairwise master key (PMK)</strong> 成对主密钥</p>
<p><strong>parity bit</strong> 奇偶校验位</p>
<p><strong>passive optical network (PON)</strong> 被动光纤网络</p>
<p><strong>passive scanning</strong> 被动扫描</p>
<p><strong>path</strong> 路径</p>
<p><strong>path loss</strong> 路径损耗</p>
<p><strong>payload field</strong> 有效载荷字段</p>
<p><strong>peer</strong> 对等</p>
<p><strong>peer to peer (P2P)</strong> 点对点</p>
<p><strong>penultimate hop popping (PHP)</strong> 倒数第二跳弹出</p>
<p><strong>per-hop behavior (PHB)</strong> 每跳行为</p>
<p><strong>prefetch</strong> 预取</p>
<p><strong>permanent address</strong> 永久地址</p>
<p><strong>persistent connection</strong> 持续连接</p>
<p><strong>personal area network (PAN)</strong> 个人局域网</p>
<p><strong>per-router control</strong> 每路由器控制</p>
<p><strong>plug and play protocol</strong> 即插即用协议</p>
<p><strong>piconet</strong> 微微网</p>
<p><strong>piggyback</strong> 捎带</p>
<p><strong>pipelining</strong> 流水线</p>
<p><strong>playback attack</strong> 重放攻击</p>
<p><strong>point coordination function (PCF)</strong> 点协调功能</p>
<p><strong>point coordinator</strong> 点协调器</p>
<p><strong>point of presence (POP)</strong> 存在点</p>
<p><strong>point to point</strong> 点对点</p>
<p><strong>point to point protocol (PPP)</strong> 点对点协议</p>
<p><strong>poisoned reverse</strong> 毒性逆转</p>
<p><strong>polling protocol</strong> 轮询协议</p>
<p><strong>polyalphabetic encryption</strong> 多表替换密码</p>
<p><strong>post office protocol-version 3 (POP3)</strong> 第三版邮局</p>
<p><strong>precedence</strong> 优先级</p>
<p><strong>prefix</strong> 前缀</p>
<p><strong>pre-master secret (PMS)</strong> 前主密钥</p>
<p><strong>priority queueing</strong> 优先级排队</p>
<p><strong>propagation delay</strong> 传播时延</p>
<p><strong>protocol</strong> 协议</p>
<p><strong>protocol data unit (PDU)</strong> 协议数据单元</p>
<p><strong>provider</strong> 提供商</p>
<p><strong>physical medium</strong> 物理媒体</p>
<p><strong>quantization</strong> 量化</p>
<p><strong>public land mobile network (PLMD)</strong>
公共陆地移动网络</p>
<p><strong>public key</strong> 公钥</p>
<p><strong>public key certification</strong> 公钥认证</p>
<p><strong>public key infrastructure (PKI)</strong> 公钥基础设施</p>
<p><strong>public switched telephone network (PSTN)</strong>
公共交换电话网络</p>
<p><strong>pull protocol</strong> 拉协议</p>
<p><strong>pulse code modulation (PCM)</strong> 脉冲编码调制</p>
<p><strong>push protocol</strong> 推协议</p>
<p><strong>quality of service (QOS)</strong> 服务质量</p>
<p><strong>queuing delay</strong> 排队时延</p>
<p><strong>quick UDP internet connection (QUIC)</strong>
快速UDP互联网连接</p>
<p><strong>radio access network (RAN)</strong> 无线接入网络</p>
<p><strong>radio network controller (RNC)</strong> 无线网络控制器</p>
<p><strong>random access protocol</strong> 随机接入协议</p>
<p><strong>random early detection (RED)</strong> 随机早期检测</p>
<p><strong>rarest first</strong> 最稀缺优先</p>
<p><strong>real time measurement</strong> 实时测量</p>
<p><strong>real-time streaming protocol (RTSP)</strong>
实时流传输协议</p>
<p><strong>real-time transport protocol (RTP)</strong> 实时传输协议</p>
<p><strong>reliable data transfer (RDT)</strong> 可靠数据传输</p>
<p><strong>repeater</strong> 中继器</p>
<p><strong>representational state transfer (REST)</strong>
表征状态传递</p>
<p><strong>request for comment (RFC)</strong> 请求评论</p>
<p><strong>request line</strong> 请求行</p>
<p><strong>request to send (RTS)</strong> 允许发送</p>
<p><strong>resource record (RR)</strong> 资源记录</p>
<p><strong>resource reservation protocol (RSVP)</strong>
资源预留协议</p>
<p><strong>retransmission time out (RTO)</strong> 重传超时时间</p>
<p><strong>reverse address resolution protocol (RARP)</strong>
反向地址解析协议</p>
<p><strong>round robin (RR) queueing</strong> 循环排队</p>
<p><strong>round trip time (RTT)</strong> 往返时间</p>
<p><strong>route</strong> 路径</p>
<p><strong>route aggregation</strong> 路由聚合</p>
<p><strong>route summarization</strong> 路由摘要</p>
<p><strong>router</strong> 路由器</p>
<p><strong>routing</strong> 路由选择</p>
<p><strong>routing loop</strong> 路由选择环路</p>
<p><strong>routing table</strong> 路由选择表</p>
<p><strong>routing processor</strong> 路由选择处理器</p>
<p><strong>security hash algorithm (SHA)</strong> 安全散列算法</p>
<p><strong>secure shell (SSH)</strong> 安全外壳</p>
<p><strong>secure socket layer (SSL)</strong> 安全套接字层</p>
<p><strong>security association (SA)</strong> 安全联盟</p>
<p><strong>security association database (SAD)</strong>
安全联盟数据库</p>
<p><strong>security parameter index (SPI)</strong> 安全参数索引</p>
<p><strong>security policy database (SPD)</strong> 安全策略数据库</p>
<p><strong>segment</strong> 报文段</p>
<p><strong>selective acknowledgement (SACK)</strong> 选择性确认</p>
<p><strong>selective repeat (SR)</strong> 选择重传</p>
<p><strong>self clocking</strong> 自计时的</p>
<p><strong>sequence number</strong> 序号</p>
<p><strong>service abstraction layer (SAL)</strong> 服务抽象层</p>
<p><strong>service set identifier (SSID)</strong> 服务集标识符</p>
<p><strong>serving GRPS support node (SGSN)</strong>
服务GRPS支持节点</p>
<p><strong>serving gateway (S-GW)</strong> 服务网关</p>
<p><strong>session initialization protocol (SIP)</strong>
会话发起协议</p>
<p><strong>session key</strong> 会话密钥</p>
<p><strong>shared medium</strong> 共享媒体</p>
<p><strong>short interframe spacing (SIFS)</strong> 短帧间间隔</p>
<p><strong>shortest path</strong> 最短路径</p>
<p><strong>signal-to-noise ratio (SNR)</strong> 信噪比</p>
<p><strong>silent period</strong> 静默期</p>
<p><strong>simple mail transfer protocol (SMTP)</strong>
简单邮件传输协议</p>
<p><strong>simple network management protocol (SNMP)</strong>
简单网络管理协议</p>
<p><strong>sliding-window protocol</strong> 滑动窗口协议</p>
<p><strong>slow start</strong> 慢启动</p>
<p><strong>slow start threshold (ssthresh)</strong> 慢启动阈值</p>
<p><strong>socket</strong> 套接字</p>
<p><strong>slot</strong> 时隙</p>
<p><strong>software defined network (SDN)</strong> 软件定义网络</p>
<p><strong>source port number field</strong> 源端口号字段</p>
<p><strong>source quench</strong> 源抑制</p>
<p><strong>spanning tree protocol (STP)</strong> 生成树协议</p>
<p><strong>splitter</strong> 分配器</p>
<p><strong>stateless protocol</strong> 无状态协议</p>
<p><strong>static routing algorithm</strong> 静态路由选择算法</p>
<p><strong>stop and wait</strong> 停等</p>
<p><strong>store and forward transmission</strong> 存储转发传输</p>
<p><strong>stream cipher</strong> 流加密</p>
<p><strong>stream control transmission protocol (SCTP)</strong>
流控制传输协议</p>
<p><strong>structure of management information (SMI)</strong>
管理信息结构</p>
<p><strong>stub network</strong> 存根网络</p>
<p><strong>subnet mask</strong> 子网掩码</p>
<p><strong>switching fabric</strong> 交换结构</p>
<p><strong>switch poisoning</strong> 交换机毒化</p>
<p><strong>symmetrical encryption</strong> 对称加密</p>
<p><strong>synchronization source identifier (SSRC)</strong>
同步源标识符</p>
<p><strong>tag protocol identifier (TPID)</strong> 标签协议标识符</p>
<p><strong>taking-turns protocol</strong> 轮流协议</p>
<p><strong>TCP friendly rate control (TFRC)</strong> TCP友好速率控制</p>
<p><strong>TCP splitting</strong> TCP分岔</p>
<p><strong>temporal key (TK)</strong> 临时密钥</p>
<p><strong>ternary content addressable memory (TCAM)</strong>
三态内容寻址存储器</p>
<p><strong>three way handshake</strong> 三次握手</p>
<p><strong>time division multiple access (TDMA)</strong> 时分多址</p>
<p><strong>time division multiplexing (TDM)</strong> 时分复用</p>
<p><strong>time frame</strong> 时间帧</p>
<p><strong>time to live (TTL)</strong> 生存时间</p>
<p><strong>tit for tat</strong> 一报还一报</p>
<p><strong>token passing protocol</strong> 令牌传递协议</p>
<p><strong>top down approach</strong> 自顶向下方方法</p>
<p><strong>top level domain (TLD)</strong> 顶级域</p>
<p><strong>top of rack (TOR)</strong> 机架式</p>
<p><strong>torrent</strong> 洪流</p>
<p><strong>total nodal delay</strong> 节点总时延</p>
<p><strong>tagged</strong> 有标记的</p>
<p><strong>tracker</strong> 追踪器</p>
<p><strong>traffic engineering (TE)</strong> 流量工程</p>
<p><strong>traffic intensity</strong> 流量强度</p>
<p><strong>traffic volume</strong> 通信容量</p>
<p><strong>transmission control protocol (TCP)</strong> 传输控制协议</p>
<p><strong>transmission delay</strong> 传输时延</p>
<p><strong>transmission rate</strong> 传输速率</p>
<p><strong>transport layer security (TLS)</strong> 安全传输层</p>
<p><strong>trap message</strong> 陷阱报文</p>
<p><strong>triangle routing</strong> 三角路由选择</p>
<p><strong>truncation attack</strong> 截断攻击</p>
<p><strong>tunnel</strong> 隧道</p>
<p><strong>tunneling</strong> 建立隧道</p>
<p><strong>two dimensional parity</strong> 二维奇偶检验</p>
<p><strong>type of service (TOP)</strong> 服务类型</p>
<p><strong>unchoked</strong> 疏通</p>
<p><strong>unguided media</strong> 非导引型媒体</p>
<p><strong>unidirectional data transfer</strong> 单向/半双工数据传输</p>
<p><strong>universal mobile telecommunications service (UMTS)</strong>
通用移动通信系统</p>
<p><strong>universal terrestrial radio access network (UTRAN)</strong>
通用陆地无线接入网络</p>
<p><strong>unreliable service</strong> 不可靠服务</p>
<p><strong>unshielded twisted pair (UTP)</strong> 无屏蔽双绞线</p>
<p><strong>untagged</strong> 无标记的</p>
<p><strong>user agent</strong> 用户代理</p>
<p><strong>user datagram protocol (UDP)</strong> 用户数据报协议</p>
<p><strong>user equipment (UE)</strong> 用户设备</p>
<p><strong>utilization</strong> 利用率</p>
<p><strong>vehicular ad hoc network (VANET)</strong> 车载自组织网络</p>
<p><strong>VLAN trunking</strong> 虚拟局域网中继/干道</p>
<p><strong>virtual local area network (VLAN)</strong> 虚拟局域网</p>
<p><strong>virtual private network (VPN)</strong> 虚拟专用网络</p>
<p><strong>visited network</strong> 被访网络</p>
<p><strong>voice over IP (VOIP)</strong> IP语音</p>
<p><strong>weighted fair queueing (WFQ)</strong> 加权公平排队</p>
<p><strong>well-known discretionary</strong> 公认任意</p>
<p><strong>well-known mandatory</strong> 公认必遵</p>
<p><strong>well-known port number</strong> 周知端口号</p>
<p><strong>WiFi jungle</strong> WiFi丛林</p>
<p><strong>wired equivalent privacy (WEP)</strong> 有线等效保密</p>
<p><strong>wireless communication link</strong> 无线通信链路</p>
<p><strong>wireless local area network (WLAN)</strong> 无线局域网</p>
<p><strong>wireless personal area network (WPAN)</strong>
无线个人局域网</p>
<p><strong>wireless distribution system (WDS)</strong>
无线分布式系统</p>
<p><strong>visitor location register (VLR)</strong> 访问者位置寄存器</p>
<p><strong>work-conserving queuing</strong> 保持工作排队</p>
<p><strong>world interoperability for microwave access (WiMAX)</strong>
全球微波接入互操作性</p>
<p><strong>zero configuration protocol</strong> 零配置协议</p>
</blockquote>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第1章 计算机网络和互联网</title>
    <url>/network/computer_networking_a_top_down_approach_7e_chpt_01/</url>
    <content><![CDATA[<h3 id="互联网">1.1 互联网</h3>
<p>　　与互联网连接的设备称为<strong>主机</strong>(因为容纳/运行应用程序)或<strong>端系统</strong>(因为位于互联网的边缘)。</p>
<p>　　主机分为<strong>客户端</strong>和<strong>服务器</strong>。</p>
<p>　　端系统彼此交换<strong>报文</strong>。端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起。</p>
<p>　　通信链路的<strong>传输速率</strong>的单位是<span
class="math inline">\(bit/s\)</span>。一台端系统向另一台端系统发送报文时，发送端将报文分段并为每段加上首部字节，由此形成的信息包称为<strong>分组</strong>。</p>
<p>　　交换机主要包括<strong>路由器</strong>和<strong>链路层交换机</strong>。链路层交换机通常用于接入网中，而路由器通常用于网络核心中。从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<strong>路径</strong>。</p>
<p>　　端系统通过<strong>互联网服务提供商</strong>接入互联网。</p>
<p>　　端系统、分组交换机和其他互联网部件都要运行一系列<strong>协议</strong>，这些协议控制互联网中信息的接收和发送。<strong>IP</strong>协议定义了在路由器和端系统之间发送和接收的分组格式。互联网的主要协议统称为<strong>TCP/IP</strong>。</p>
<p>　　<strong>协议</strong>定义了两个或多个通信实体之间交换的报文的格式和顺序，以及发送/接收一条报文或其他事件所采取的动作。</p>
<p>　　<strong>互联网标准</strong>由<strong>互联网工程任务组</strong>研发，其标准文档称为<strong>请求评论</strong>。</p>
<p>　　应用程序涉及多个相互交换数据的端系统称为<strong>分布式应用程序</strong>。</p>
<p>　　与互联网相连的端系统提供了一个<strong>套接字接口</strong>，该接口规定了运行在端系统上的程序请求互联网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。</p>
<p>　　ICANN负责分配IP地址，分配AS号，管理DNS根服务器，分配域名以及解决域名纷争。</p>
<span id="more"></span>
<h3 id="网络边缘">1.2 网络边缘</h3>
<p>　　<strong>接入网</strong>指将端系统物理连接到其边缘路由器的网络。<strong>边缘路由器</strong>是端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<p>　　家庭接入：DSL、电缆、FTTH、拨号和卫星</p>
<p>　　企业/家庭接入：以太网和WiFi</p>
<p>　　广域无线接入：3G/4G/5G和LTE</p>
<p>　　<strong>物理媒体</strong>包括<strong>导引型媒体</strong>(电波沿着固态媒体传播)和<strong>非导引型媒体</strong>(电波在空气或外层空间传播)。</p>
<h3 id="网络核心">1.3 网络核心</h3>
<p>　　通过网络链路和交换机移动数据有两种基本方法：<strong>分组交换</strong>和<strong>电路交换</strong>。</p>
<p>　　在电路交换的网络中，端系统间通信会话期间，<span
style="background-color: yellow">预留</span>了端系统间沿路径通信所需要的资源(缓存和链路传输速率)，而在分组交换的网络中<span
style="background-color: yellow">不会预留</span>这些资源。</p>
<h4 id="分组交换">1.3.1 分组交换</h4>
<p>　　多数分组交换机在链路的输入的使用<strong>存储转发传输</strong>机制。存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_01/store-and-forward_packet_switching.svg" class="">
<p>　　若有<span class="math inline">\(N\)</span>条速率均为<span
class="math inline">\(R\)</span>的链路组成的路径，其中有<span
class="math inline">\(N-1\)</span>台路由器且所有分组的长度都为<span
class="math inline">\(L\)</span>，则端到端时延为<span
class="math inline">\(d_{端到端}=N\frac{L}{R}\)</span>。</p>
<p>　　对于每条相连的链路，分组交换机有一个用来存储路由器准备发往该链路的分组的<strong>输出缓存/队列</strong>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_01/packet_switching.svg" class="">
<p>　　分组需要承受输出缓存的<strong>排队时延</strong>。</p>
<p>　　由于缓存空间是有限的，一个到达的分组可能发现该缓存已被其他待传输的分组完全占满，此时刚到达的分组或已经排队的分组其中之一将被丢弃，称为<strong>分组丢失/丢包</strong>。</p>
<p>　　每个端系统都有IP地址，分组的首部中包含了目的地的IP地址。</p>
<p>　　每台路由器具有一个将目的IP地址(一部分)映射成输出链路的<strong>转发表</strong>。</p>
<h4 id="电路交换">1.3.2 电路交换</h4>
<p>　　链路中的电路是通过<strong>频分复用</strong>或<strong>时分复用</strong>来实现的。</p>
<p>　　对于频分复用，链路的频谱由跨越链路创建的所有连接共享。在连接期间链路为每条连接专用一个频段，该频段的宽度称为<strong>带宽</strong>。</p>
<p>　　对于时分复用，时间被划分为固定期间的帧，称为<strong>时间帧</strong>，并且每个时间帧又被划分为固定数量的<strong>时隙</strong>。当网络跨越一条链路创建一条连接时，网络会为这个连接分配一个时隙，通常时隙的长度能够传输单个帧。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_01/fdm_and_tdm.svg" class="">
<h4 id="网络的网络">1.3.3 网络的网络</h4>
<p>　　因为接入ISP向全球传输ISP付费，故接入ISP可视为<strong>客户</strong>，而全球传输ISP可视为<strong>提供商</strong>。</p>
<p>　　在任何给定的区域，可能有一个<strong>区域ISP</strong>，每个区域ISP则与<strong>第一层ISP连接</strong>。</p>
<p>　　任何ISP(除了第一层ISP)可以选择<strong>多宿</strong>。</p>
<p>　　位于相同等级结构层次的邻近一对ISP能够<strong>对等</strong>。</p>
<p>　　<strong>互联网交换点</strong>是一个汇合点，多个ISP能够在这里一起对等。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_01/interconnection_of_isps.svg" class="">
<h3 id="分组交换网">1.4 分组交换网</h3>
<p>　　当分组从一个节点/主机/路由器沿着路径到后继节点/主机/路由器，该节点在沿途的每个节点承受了几种不同类型的时延，其中最重要的是<strong>节点处理时延</strong>、<strong>排队时延</strong>、<strong>传输时延</strong>和<strong>传播时延</strong>，这些时延的总和是<strong>节点总时延</strong>。若用<span
class="math inline">\(d_{proc}\)</span>、<span
class="math inline">\(d_{queue}\)</span>、<span
class="math inline">\(d_{trans}\)</span>、<span
class="math inline">\(d_{prop}\)</span>、<span
class="math inline">\(d_{nodal}\)</span>分别表示处理时延、排队时延、传输时延、传播时延和节点总时延，则<span
class="math inline">\(d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}\)</span>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_01/total_nodal_delay_of_router.svg" class="">
<p>　　检查分组首部和决定将该分组导向何处所需要的时间是<strong>处理时延</strong>的一部分。</p>
<p>　　在队列中，当分组在链路上等待传输时，需要经受<strong>排队时延</strong>。</p>
<p>　　<strong>传输时延</strong>是路由器推出分组所需的时间，可表示为<span
class="math inline">\(\frac{L}{R}\)</span>，<span
class="math inline">\(L\)</span>表示分组的长度，<span
class="math inline">\(R(b/s)\)</span>表示链路的传输速率，即从队列中推出<span
class="math inline">\(1b\)</span>的速率。</p>
<p>　　<span
class="math inline">\(\frac{L\alpha}{R}\)</span>是<strong>流量强度</strong>，其中<span
class="math inline">\(\alpha(pkt/s)\)</span>表示分组到达队列的平均速率。流量强度主要用于衡量排队时延，设计系统时流量强度不能大于1。</p>
<p>　　<span
class="math inline">\(1b\)</span>从一个路由器到另一个路由器所需的时间是<strong>传播时延</strong>。</p>
<p>　　源主机和目的主机之间有<span
class="math inline">\(N-1\)</span>台路由器，网络通畅(排队时延可以忽略)，节点时延累加起来，得到端到端时延：
<span class="math display">\[
\begin{align}
d_{end-end}&amp;=N(d_{proc}+d_{trans}+d_{prop})\\[3px]
&amp;=N(d_{proc}+\frac{L}{R}+d_{prop})
\end{align}
\]</span></p>
<p>　　<strong>吞吐量</strong>是进程交互比特的速率。</p>
<h3 id="协议层次及其服务模型">1.5 协议层次及其服务模型</h3>
<p>　　某层的<strong>服务模型</strong>是该层向上一层提供的服务。</p>
<p>　　各层的所有协议被称为<strong>协议栈</strong>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_01/internet_protocol_stack_and_osi_reference_model.svg" class="">
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 45%" />
<col style="width: 40%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>功能</th>
<th>主要协议</th>
<th>分组名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>存留网络应用程序及其应用层协议</td>
<td>HTTP、SMTP、FTP、DNS、DHCP、SNMP和NFS等</td>
<td>报文</td>
</tr>
<tr>
<td>传输层</td>
<td>应用程序之间传输应用层报文</td>
<td>TCP、UDP、DCCP、DCTCP、TRFC、SCTP和QUIC等</td>
<td>报文段</td>
</tr>
<tr>
<td>网络层</td>
<td>也称为IP层，将数据报从一台主机移动到另一台主机</td>
<td>IP等</td>
<td>数据报</td>
</tr>
<tr>
<td>链路层</td>
<td>沿着路径将数据报传递给下一个节点</td>
<td>以太网、WiFi和DOCSIS等</td>
<td>帧</td>
</tr>
<tr>
<td>物理层</td>
<td>将帧中的一个个比特从一个节点移动到下一个节点</td>
<td></td>
<td>比特</td>
</tr>
</tbody>
</table>
<p>　　<strong>网络体系结构</strong>是通信系统的整体设计，其广泛采用OSI模型。</p>
<p>　　相比互联网协议栈，OSI模型多出表示层和会话层。</p>
<p>　　表示层的作用是使通信的应用程序能够解释交换数据的含义。这些服务包括数据压缩、数据加密和数据描述。</p>
<p>　　会话层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_01/encapsulation.svg" class="">
<p>　　在每一层，分组包括首部字段和<strong>有效载荷字段</strong>(通常是上一层的分组)。</p>
<h3 id="网络安全">1.6 网络安全</h3>
<p>　　<strong>病毒</strong>是一种需要某种形式的用户交互来感染用户设备的恶意软件。</p>
<p>　　<strong>蠕虫</strong>是一种无须任何明显用户交互就能进入设备的恶意软件。</p>
<p>　　<strong>Dos攻击</strong>包括<span
style="background-color: yellow">弱点攻击</span>(发送特殊的报文来控制或宕机)、<span
style="background-color: yellow">带宽洪泛</span>(发送大量分组)和<span
style="background-color: yellow">连接洪泛</span>(创建大量TCP连接)。</p>
<p>　　用来观察执行协议实体之间交换的报文的基本工具被称为<strong>分组嗅探器</strong>。</p>
<p>　　<strong>IP哄骗</strong>指将具有虚假源地址的分组注入互联网。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第4章 网络层</title>
    <url>/network/computer_networking_a_top_down_approach_7e_chpt_04/</url>
    <content><![CDATA[<p>　　网络层提供的服务是<strong>尽力而为服务</strong>。</p>
<p>　　<strong>转发</strong>是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。转发所需时间通常为几纳秒，故通过硬件实现。</p>
<p>　　<strong>路由选择</strong>是指确定数据报从源到目的地的端到端路径的网络范围处理过程。路由选择所需时间通常为几秒，故通过软件来实现。</p>
<p>　　网络层可以分为<strong>数据平面</strong>和<strong>控制平面</strong>。</p>
<p>　　● 数据平面即<span
style="background-color: yellow">路由器的功能</span>，用于从路由器的输入链路向输出链路转发分组，包括传统的<span
style="background-color: yellow">IP地址转发</span>和<span
style="background-color: yellow">通用转发</span>。两者都采用匹配加动作的模式，匹配是匹配分组，动作是匹配之后的动作，区别在于IP地址转发是根据IP地址匹配，而通用转发是根据协议栈对多个首部字段进行匹配。</p>
<p>　　● 控制平面即<span
style="background-color: yellow">网络范围的逻辑</span>，用于协调路由器间的转发动作，使得分组最终沿着源主机和目的主机之间的路径进行端到端传输。可以通过传统的<strong>每路由器控制</strong>(每台都有转发和路由选择功能，每台路由器还有一个路由选择组件，该组件与其他路由器中的路由组件通信以计算转发表的值)和<strong>SDN控制</strong>(逻辑集中控制器计算并分发转发表给每台路由器)来构建控制平面。</p>
<p>　　<strong>网络服务模型</strong>定义了分组在发送端与接收端之间的端到端传输特性。</p>
<p>　　主机与物理链路之间的边界称为<strong>接口</strong>。路由器与其任意一条链路之间的边界也称为接口，例如，输入端口或输出端口。在技术层面上，一个IP地址与一个接口相关，而不是与包括该接口的主机/路由器相关。在公网中，除NAT接口之外的每台主机/路由器的每个接口都必须有个公网IP地址。</p>
<p>　　IP地址一般划分为网络地址和主机地址。主机地址不能全为0/1，主机地址全为0的地址是网络地址，主机地址全为1的地址是广播地址。</p>
<p>　　<strong>子网掩码</strong>用来区分IP地址的网络地址和主机地址，故必须与IP地址结合使用。</p>
<p>　　<strong>IP广播</strong>分为<strong>受限广播</strong>和<strong>直接广播</strong>。受限广播中发送数据报时不会进行路由选择，而是被广播到所属<span
style="background-color: yellow">物理网络</span>上的所有主机，<strong>受限广播IP地址</strong>全为1。直接广播中发送数据报时进行路由选择并广播到所属网络的所有主机，<strong>直接广播IP地址</strong>的主机地址全为1。IP广播地址除了受限广播地址和直接广播地址，还有<strong>指向子网的广播IP地址</strong>(主机地址全为1)以及<strong>指向所有子网的广播IP地址</strong>(子网地址和主机地址去全为1)。</p>
<p>　　第一跳路由器的IP地址称为<strong>默认网关</strong>。</p>
<span id="more"></span>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/nat.svg" class="">
<p>　　<strong>网络地址转换</strong>是将数据报中的IP地址转换成另一个IP地址，主要用于实现内网访问公网的功能。</p>
<p>　　在互联网中每个<strong>自治系统</strong>由一组受相同管理控制的路由器组成，通常在一个ISP中的路由器以及互联它们的链路构成一个自治系统。自治系统由全局唯一的AS号(ASN)所标识。在同一自治系统中的路由器运行相同的路由选择算法并有彼此的信息。</p>
<p>　　在一个自治系统内运行的路由选择协议称为<strong>自治系统内部路由选择协议</strong>。自治系统间的路由选择协议称为<strong>自治系统间路由选择协议</strong>。两者的差别主要体现在策略、规模以及性能这三个方面。</p>
<p>　　●
从策略的角度，AS内部都在同一管理控制下，策略在AS内部路由选择中起着微不足道的作用；AS间路由选择承载了路径属性并提供路由信息的受控分布，以便能做出基于策略的路由选择决策。</p>
<p>　　●
从规模的角度，规模不是AS内部路由选择的关注重点，但它是AS间路由选择协议的关键问题。</p>
<p>　　●
从性能的角度，AS内部路由选择协议注重路由的性能；AS间路由选择是面向策略的，因此所选路由的性能是次要问题。</p>
<p>　　互联网中所有AS运行相同的AS间路由选择协议，即<strong>边界网关协议</strong>，边界网关协议还常用于实现<strong>IP任播</strong>。</p>
<p>　　<strong>存根网络</strong>又称为桩网络或末端网络，指仅有一条(默认)路径连接到其他网络。</p>
<p>　　<strong>网络功能虚拟化</strong>指将用服务器、交换机和存储设备来代替复杂的中间盒。</p>
<h3 id="路由器">4.1 路由器</h3>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/router_architecture.svg" class="">
<p>　　线路终端的功能是结束传入物理链路的物理层功能。</p>
<p>　　数据链路处理的功能是与位于传入链路远端的数据链路层交互的数据链路层功能。</p>
<p>　　当一条链路是双向时，输入端口和输出端口通常成对出现在同一线路卡上。</p>
<h4 id="ip地址转发">4.1.1 IP地址转发</h4>
<p>　　每台路由器都有<strong>转发表</strong>。路由选择处理器通过路由选择协议与其他路由器中的路由选择处理器交互来计算/更新转发表。在SDN路由器中，路由选择处理器用来接收远程控制器计算的转发表项并更新转发表。</p>
<p>　　路由选择处理器经过独立总线将转发表复制到线路卡。通过转发表的副本，每个输入端口就可以本地完成转发，避免了集中式处理的瓶颈。</p>
<p>　　路由器根据分组目的地址的<strong>前缀</strong>与转发表中的表项进行匹配。当有多个匹配项时，路由器使用<strong>最长前缀匹配规则</strong>。</p>
<p>　　可以使用<strong>三态内容寻址存储器</strong>来保证查询转发表所需时间维持在一个常数内。</p>
<p>　　找到分组的输出端口后，分组就可以进入交换结构了，但如果该输出端口已被占用，分组可能在进入交换结构前暂时阻塞。</p>
<h4 id="交换结构">4.1.2 交换结构</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/three_switching_techniques.svg" class="">
<p>　　● <span
style="background-color: yellow">经内存交换</span>：最简单、最早的路由器是传统的计算机，输入端口与输出端口之间的交换是在CPU(路由选择处理器)的直接控制下完成的。输入/输出端口的功能就像传统操作系统中的I/O设备一样。当分组到达到达一个输入端口时，该端口先通过中断方式向路由选择控制器发送信号，该分组从输入端口复制到内存，路由选择处理器从分组首部中获取IP，查询转发表获取输出端口并将分组复制到输出端口的缓存中。若内存每秒能读/写<span
class="math inline">\(B\)</span>个分组，则总转发吞吐量必定小于<span
class="math inline">\(\frac{B}{2}\)</span>，因为共享系统总线每次仅能执行一个内存读/写。</p>
<p>　　● <span
style="background-color: yellow">经总线交换</span>：输入端口经一根共享总线将分组直接传输到输出端口，不需要路由选择控制器的干预。输入端口预先为分组指定一个交换机内部标签(仅用来跨越总线)并指示输出端口。每个输出端口都能收到该分组，但只有指定的输出端口才能保存该分组，指定的输出端口保存分组后去掉标签。每次仅有一个分组能跨域总线，故分组有时需要等待，导致路由器的带宽受限于总线速率。</p>
<p>　　● <span
style="background-color: yellow">经互联网络交换</span>：纵横式交换机是由<span
class="math inline">\(2N\)</span>条总线构成的互联网络，包括<span
class="math inline">\(N\)</span>个输入端口和<span
class="math inline">\(N\)</span>个输出端口。每条垂直的总线与每条水平的总线交叉，交叉点通过交换结构控制器实现随时开启/闭合。纵横式交换机是<strong>非阻塞</strong>的，只有两个或以上的分组同时转发到同一个输出端口，分组不会阻塞，否则会出现分组等待。</p>
<p>　　部分现代路由器也通过内存进行交换，不过转发表的查找和将分组存储进适当的内存存储位置是由输入线路卡来处理。</p>
<p>　　更复杂的互联网络使用多级交换元素来使多个分组同时转发到同一输出端口时无需等待。例如，在三级非阻塞交换策略中，输入/输出端口连接到<span
class="math inline">\(N\)</span>个交换结构，输入端口将分组分成<span
class="math inline">\(K\)</span>个较小的块并通过<span
class="math inline">\(N\)</span>个交换结构发送这<span
class="math inline">\(K\)</span>个块到指定输出端口，输出端口再将这<span
class="math inline">\(K\)</span>个块组装成原本的分组。</p>
<h4 id="排队">4.1.3 排队</h4>
<p>　　假设纵横式交换机有<span
class="math inline">\(N\)</span>个输入端口和<span
class="math inline">\(N\)</span>个输出端口且输入线路与输入线路速率相同，都为<span
class="math inline">\(R_{line}(packet/s)\)</span>。此外，所有分组具有相同的固定长度，以同步的方式到达输入端口且采用FCFS方式，即所有链路发送/接收分组的时间相等。用<span
class="math inline">\(R_{switch}\)</span>表示分组从输入端口传输到输出端口的速率并假设<span
class="math inline">\(R_{switch}=N\times R_{line}\)</span>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/hol_blocking.svg" class="">
<p>　　一个输入队列中排队的分组阻塞后，队列中该分组之后的分组也会阻塞，这种情况称为<strong>线路前部阻塞</strong>。由于HOL阻塞，当输入链路分组的到达速率达到其容量的<span
class="math inline">\(58\%\)</span>时，在某些假设前提下，输入端口的队列长度将无限制地增大。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/output_port_queueing.svg" class="">
<p>　　当没有足够缓存时，要么丢弃到达的分组(即弃尾策略)，要么删除排队中的分组。在某些情况下，在缓存填满之前便丢弃分组或在其首部加上标记，这可以向发送端反馈拥塞信号，这种策略称为<strong>主动队列管理</strong>策略。RED算法是最广泛研究与实现的AQM算法之一。</p>
<p>　　<span class="math inline">\(B\)</span>表示缓存容量，<span
class="math inline">\(C\)</span>表示链路容量，通常<span
class="math inline">\(B=RTT\times
C\)</span>，大量(N条)TCP流量经过同一链路时<span
class="math inline">\(B=\frac{RTT\times C}{\sqrt{N}}\)</span>。</p>
<h4 id="链路分组调度">4.1.4 链路分组调度</h4>
<p>　　<strong>链路分组调度</strong>指排队分组在链路上传输的方式。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/fifo_or_fcfs_queueing_model.svg" class="">
<p>　　FIFO/FCFS调度规则按照分组到达输出链路队列的顺序来传输分组。当链路正忙于传输其他分组时，到达链路输出队列的分组需要排队等待传输。若缓存不足则需要丢弃分组。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/priority_queueing_model.svg" class="">
<p>　　在<strong>优先级排队</strong>规则下，到达输出链路的分组被分类放入输出队列的优先级类队列，每个类通常都有对应的队列。当传输分组时，从优先级最高且非空的队列中选择分组进行传输。<span
style="background-color: yellow">同一优先级</span>队列的分组采用FIFO方式。在非抢占式优先级排队规则下，一旦分组开始传输就不能打断。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/weighted_fair_queueing_model.svg" class="">
<p>　　在<strong>循环排队</strong>规则下，分组会被分类，但是类之间不存在严格的优先级，循环调度器在这些类之间轮流提供服务。在<strong>保持工作排队</strong>规则下，有分组待传输时不会允许链路空闲，当指定类里不存在分组时，会立即检查循环序列中的下一个类。<strong>加权公平排队</strong>就是循环排队的一种通用实现方式，它也是保持工作队列。</p>
<p>　　WFQ与循环排队的不同之处在于每个类在任何时间间隔内可能收到<span
style="background-color: yellow">不同数量</span>的服务。对于WFQ，若有<span
class="math inline">\(n\)</span>个类存在分组待传输，类<span
class="math inline">\(i\)</span>的权值为<span
class="math inline">\(w_i\)</span>，即使所有类都有分组排队，类<span
class="math inline">\(i\)</span>总能保证至少<span
class="math inline">\(\frac{w_i}{\sum_{j=1}^{n}{w_j}}\times
R\)</span>的吞吐量。</p>
<h3 id="网际协议">4.2 网际协议</h3>
<h4 id="ipv4数据报">4.2.1 IPv4数据报</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/ipv4_datagram_format.svg" class="">
<p>　　IPv4数据报包括4位<strong>版本(号)</strong>、4位<strong>首部长度</strong>、8位<strong>服务类型</strong>(3位优先级、4位服务类型子字段和1位必须为零)、16位<strong>数据报长度</strong>、16位<strong>标识</strong>、3个<strong>标志位</strong>、13位<strong>片偏移</strong>、8位<strong>生存时间</strong>、8位<strong>上层协议</strong>、16位<strong>首部检验和</strong>、32位<strong>源IP地址</strong>、32位<strong>目的IP地址</strong>、最多<span
class="math inline">\(40B\)</span>的<strong>可选项</strong>和有效载荷。</p>
<p>　　版本规定了IP协议版本。由于不同版本的IP协议数据报格式不同，需要版本字段来确定。</p>
<p>　　首部长度<span style="background-color: yellow">以<span
class="math inline">\(4B\)</span>为单位</span>表示首部长度。</p>
<p>　　服务类型用来区分不同类型的数据报。前3位是优先级字段，第4位到第6位是DTR字段，第4位到第7位是服务类型子字段，最后一位必须为零。服务类型子字段最多只能有1位为1。</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>routine</td>
<td>默认</td>
</tr>
<tr>
<td>001</td>
<td>priority</td>
<td>数据业务</td>
</tr>
<tr>
<td>010</td>
<td>immediate</td>
<td>数据业务</td>
</tr>
<tr>
<td>011</td>
<td>flash</td>
<td>语音控制数据</td>
</tr>
<tr>
<td>100</td>
<td>flash override</td>
<td>视频会议或视频流</td>
</tr>
<tr>
<td>101</td>
<td>critic</td>
<td>语音数据</td>
</tr>
<tr>
<td>110</td>
<td>internetwork control</td>
<td>网络控制数据</td>
</tr>
<tr>
<td>111</td>
<td>network control</td>
<td>网络控制数据</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>服务类型子字段</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>normal service</td>
</tr>
<tr>
<td>1000</td>
<td>minimize delay</td>
</tr>
<tr>
<td>0100</td>
<td>maximize throughout</td>
</tr>
<tr>
<td>0010</td>
<td>maximize reliability</td>
</tr>
<tr>
<td>0001</td>
<td>minimize monetary cost</td>
</tr>
</tbody>
</table>
<p>　　生存时间表示数据报能经过的最大路由器数量，每当路由器处理数据报时该字段值减1，当该字段值为0时丢弃该数据报。</p>
<p>　　由于源到目的地路径的上的每段链路使用的链路层协议可能不同，不同协议的最大传输单元可能不同，所以可能需要将数据报分成多个较小的数据报并封装成合适的链路层帧，这些较小的数据报称为<strong>片</strong>。片到达目的地后需要重组成原始数据报再交给传输层。重组过程在端系统完成，因为组装会增加协议复杂性和降低路由器的性能。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/ipv4_datagram_fragmentation.svg" class="">
<p>　　标识、标志位以及片偏移用于分片和重组。标识是数据报的唯一值，分片时会复制到各个片中。3个标志位中第1位是保留位，第2位是禁止分片标志位，第3位是还有分片标志。DF为1时表示不能分片，MF为1时表示不是最后一个片。片偏移<span
style="background-color: yellow">以<span
class="math inline">\(8B\)</span>为单位</span>表示片在原始数据报中的相对位置。</p>
<p>　　上层协议表示传输层所用协议的协议号。1表示ICMP，2表示IGMP，6表示TCP，17表示UDP，89表示OSPF。</p>
<p>　　首部校验和<span
style="background-color: yellow">仅用来校验数据报中的首部</span>，计算方式类似于UDP的校验和。由于每次经过路由器时首部中的某些字段会改变，所以需要重新计算。</p>
<h4 id="ipv4编址">4.2.2 IPv4编址</h4>
<p>　　每个IPv4地址长度是32位，因此共有<span
class="math inline">\(2^{32}\)</span>个可能的IP地址。IP地址通常使用<strong>点分十进制表示法</strong>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/ipv4_classful_addressing.svg" class="">
<p>　　IPv4<strong>分类编制</strong>包括A、B、C三类普通地址以及D、E两类特殊地址。A类地址一般用于大型网络，B类地址一般用于中型网络，C型地址一般用于小型网络，D类地址是多播地址，E类地址是保留地址。</p>
<p>　　互联网的地址分配策略称为<strong>无类别域间路由选择</strong>。CIDR不在使用分类编址，IP地址表示为<code>a.b.c.d/x</code>。<code>x</code>表示网络地址所占的位数，该部分称为该地址的<strong>前缀</strong>，剩余的几位则表示主机地址。其地址掩码依然是子网掩码。使用单个网络前缀通告多个网络称为<strong>地址聚合</strong>或<strong>路由聚合</strong>或<strong>路由摘要</strong>。</p>
<h4 id="dhcp">4.2.3 DHCP</h4>
<p>　　<strong>动态主机配置协议</strong>允许主机自动获得IP地址、子网掩码、默认网关以及本地DNS服务器地址，故也称为<strong>即插即用协议</strong>或<strong>零配置协议</strong>。DHCP是C/S体系结构，客户端即新到达的主机，若子网没有DHCP服务器则会由一个通常是路由器的DHCP中继代理，中继代理能够获取DHCP服务器。</p>
<p>　　DHCP分配IP地址包括<strong>人工配置</strong>、<strong>自动配置</strong>和<strong>动态配置</strong>。人工配置即管理员手动分配。自动配置即服务器为首次连接网络的客户端分配一个永久IP地址，客户端一直使用该IP地址。动态配置即按服务器为首次连接网络的客户端分配一个期限IP地址，到期后停止使用或续约。</p>
<p>　　DHCP租约表包括<strong>静态租约表</strong>和<strong>动态租约表</strong>，分别对应静态租约存储文件和周期存储文件。静态租约表中的IP地址不能重复使用。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/dhcp_message_format.svg" class="">
<p>　　DHCP属于<strong>引导程序协议</strong>，DHCP报文格式符合BOOTP报文格式。</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 16%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr>
<th>字段</th>
<th>长度(单位是B)</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>op</td>
<td>1</td>
<td>报文类型，1表请求报文，2表示响应报文</td>
</tr>
<tr>
<td>htype</td>
<td>1</td>
<td>客户端硬件地址类型，1表示以太网地址</td>
</tr>
<tr>
<td>hlen</td>
<td>1</td>
<td>客户端硬件地址长度</td>
</tr>
<tr>
<td>hops</td>
<td>1</td>
<td>跳数，客户端置0</td>
</tr>
<tr>
<td>xid</td>
<td>4</td>
<td>报文的唯一值</td>
</tr>
<tr>
<td>secs</td>
<td>2</td>
<td>客户端获取到IP地址或续约成功到现在所消耗的时间，若未获得IP地址则为0</td>
</tr>
<tr>
<td>flags</td>
<td>2</td>
<td>DHCP仅用到了第一位，0表示单播的方式，1表示广播的方式，其余位保留</td>
</tr>
<tr>
<td>ciaddr</td>
<td>4</td>
<td>客户端IP地址</td>
</tr>
<tr>
<td>yiaddr</td>
<td>4</td>
<td>服务器分配给客户端的IP地址</td>
</tr>
<tr>
<td>siaddr</td>
<td>4</td>
<td>服务器IP地址</td>
</tr>
<tr>
<td>giaddr</td>
<td>4</td>
<td>网关IP地址</td>
</tr>
<tr>
<td>chaddr</td>
<td>16</td>
<td>客户端硬件地址</td>
</tr>
<tr>
<td>sname</td>
<td>64</td>
<td>服务器主机名，全为0则表示没有</td>
</tr>
<tr>
<td>file</td>
<td>128</td>
<td>引导文件名，全为0则表示没有</td>
</tr>
<tr>
<td>vender</td>
<td>可变</td>
<td>采用CLV模式，对于DHCP，必须以固定值01100011 10000010 01010011
01100011开头，表示Magic cookie，即之后是vender</td>
</tr>
</tbody>
</table>
<p>　　DHCP有8种报文，根据<code>Optiont(53)</code>可以区分，即<strong>DHCP发现报文</strong>、<strong>DHCP提供报文</strong>、<strong>DHCP请求报文</strong>、<strong>DHCP
ACK报文</strong>、<strong>DHCP
NAK报文</strong>、<strong>DHCP拒绝报文</strong>、<strong>DHCP释放报文</strong>和<strong>DHCP信息报文</strong>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/dhcp_client_server_interaction.svg" class="">
<p>　　1)
DHCP服务器发现。新到达的DHCP客户端首先需要寻找DHCP服务器。DHCP客户端以广播的方式发送DHCP发现报文，报文段封装成数据报时源IP地址是<code>0.0.0.0</code>，目的IP地址使用广播地址。</p>
<p>　　2)
DHCP服务器提供。所有收到DHCP发现报文的DHCP服务器发送包括发现报文的事务ID、推荐IP地址、子网掩码以及IP<strong>地址租用期</strong>的DHCP提供报文来响应，报文段封装成数据报时目的IP地址使用广播地址，因为子网中可能存在多个新到达的DHCP客户端。若为静态租用则匹配硬件地址，若为动态租约则检测DHCP发现报文中是否包含有效<code>yiaddr</code>，有则进一步检测是否可用，否则从IP地址池中分配一个最小可用的IP地址。</p>
<p>　　3)
DHCP请求。DHCP客户端可能会收到多个DHCP提供报文，DHCP客户端选择一个并发送包含配置参数的DHCP请求报文来响应。报文段封装成数据报时源IP地址是<code>0.0.0.0</code>，目的IP地址使用广播地址。</p>
<p>　　4) DHCP
ACK/NAK。DHCP服务器根据客户端的状态进行响应，若客户端处于<code>selecting</code>则验证<code>yiaddr</code>和<code>siaddr</code>是否匹配，若客户端处于<code>init_reboot</code>则验证<code>yiaddr</code>是否匹配，若客户端处于<code>renewing/rebinding</code>则验证<code>ciaddr</code>是否匹配，若都不匹配以单播的方式发送DHCP
NAK报文，否则发送DHCP ACK报文。</p>
<p>　　● 当客户端的IP地址租期到<span
class="math inline">\(\frac{1}{2}\)</span>，客户端会以单播的方式向原服务器发送DHCP请求报文，若收到DHCP
ACK报文则续租成功并更新租期，最多可重发3次，分别在4s、8s和16s后。</p>
<p>　　● 当客户端的IP地址租期到<span
class="math inline">\(\frac{7}{8}\)</span>，客户端会以广播的方式向所有服务器发送DHCP请求报文，若收到DHCP
ACK报文则更新租约，最多可重发3次，分别在4s、8s和16s后。</p>
<p>　　租约到期则重新开始【发现-提供-请求-确认】这4个步骤。</p>
<p>　　若客户端收到DHCP
ACK报文后，向网络发送3个此IP地址的ARP解析请求以执行冲突检测。若出现冲突，客户端向服务器发送DHCP拒绝报文来重新获取IP地址，服务器会将租约表中关于客户端硬件地址置空并保持该IP地址一段时间。若客户端<span
style="background-color: yellow">不再需要当前IP地址或租约到期</span>，向服务器发送DHCP释放报文。若客户端需要获取租约的详细信息，可以向服务器发送DHCP信息报文，服务器会以DHCP
ACK报文响应。</p>
<h4 id="ipv6">4.2.4 IPv6</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/ipv6_datagram_format.svg" class="">
<p>　　IPv6数据报包括8位<strong>版本(号)</strong>、8位<strong>流量类别</strong>、16位<strong>流标签</strong>、16位<strong>有效载荷长度</strong>、8位<strong>下个首部</strong>、8位<strong>跳限制</strong>、<span
class="math inline">\(16B\)</span><strong>源IP地址</strong>、<span
class="math inline">\(16B\)</span><strong>目的IP地址</strong>、非必需且长度不定的扩展首部以及有效载荷。</p>
<p>　　流量类别等同于IPv4数据报中的服务类型。</p>
<p>　　类标签用于区分实时流量，不同的流标签+源IP地址可以确定唯一的数据流。</p>
<p>　　有效载荷长度包括<span
style="background-color: yellow">扩展首部的长度+有效载荷的长度</span>，若超过<span
class="math inline">\(65535B\)</span>则使用扩展首部中的超大有效载荷来表示。</p>
<p>　　下个首部类似于IPv4数据报中的上层协议，若存在下一个扩展首部则表示下一个扩展首部的编号，否则表示传输层协议的编号。</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 16%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr>
<th>扩展首部类型</th>
<th>对应的下个首部值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>逐跳选项扩展首部</td>
<td>0</td>
<td>用于为在传输链路上每跳转发指定参数，传输链路的每台中间节点都要读取并处理该字段。主要应用包括超大有效载荷、设备提示以及资源预留</td>
</tr>
<tr>
<td>路由选择扩展首部</td>
<td>43</td>
<td>用于强制让数据报经过特定的设备</td>
</tr>
<tr>
<td>分片扩展首部</td>
<td>44</td>
<td>用于分片</td>
</tr>
<tr>
<td>封装安全有效载荷扩展首部</td>
<td>50</td>
<td>由IPsec使用，提供认证、数据完整性校验以及重放保护，类似于认证</td>
</tr>
<tr>
<td>认证扩展首部</td>
<td>51</td>
<td>由IPsec使用，提供认证、数据完整性校验、首部部分字段保护以及重放保护</td>
</tr>
<tr>
<td>目的选项扩展首部</td>
<td>60</td>
<td>携带只有目的主机才会处理的信息</td>
</tr>
</tbody>
</table>
<p>　　跳限制等同于IPv4数据报中的生存时间。</p>
<p>　　IPv6数据报必须按照指定顺序：首部、逐跳选项首部扩展首部、目的选项扩展首部、路由选择扩展首部、分片扩展首部、认证扩展首部、封装安全有效载荷扩展首部、目的选项扩展首部以及有效载荷。</p>
<p>　　IPv6<span
style="background-color: yellow">只允许源主机和目的主机</span>进行分片与重组。若路由器收到的数据报因太大无法转发到链路上，则路由器丢弃该数据报并向发送端发送一个ICMP差错报文，然后发送端以较小长度的数据报重发。</p>
<p>　　由于传输层和链路层的协议都有差错检测，故IPv6并没有校验和。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/tunneling.svg" class="">
<p>　　IPv4迁移到IPv6的方法是<strong>建立隧道</strong>。其基本思想是：假设两个IPv6主机需要使用IPv6数据报进行交互，但它们的传输路径经过IPv4路由器，将路径上的IPv4路由器集合为一个<strong>隧道</strong>，借助隧道，将IPv6数据报作为IPv4数据报的有效载荷。</p>
<h3 id="路由选择算法">4.3 路由选择算法</h3>
<p>　　无向图<span class="math inline">\(G=(N,E)\)</span>是一个<span
class="math inline">\(N\)</span>个节点和<span
class="math inline">\(E\)</span>条边的集合，其中每条边是取<span
class="math inline">\(N\)</span>的一对节点。节点可以表示路由器，连接节点的边可以表示路由器之间的物理路径。对于<span
class="math inline">\(E\)</span>中的任意一条边<span
class="math inline">\((x,y)\)</span>，<span
class="math inline">\(c(x,y)\)</span>表示节点<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>的成本。若节点对<span
class="math inline">\((x,y)\)</span>不属于<span
class="math inline">\(E\)</span>，则<span
class="math inline">\(c(x,y)=\infty\)</span>，否则两个节点互称<strong>邻居</strong>。<span
class="math inline">\(u\)</span>表示源节点。</p>
<p>　　对于任何两个节点<span class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>，通常有很多条路径，这些路径中的一条或多条是<strong>最低成本路径</strong>。当所有边的成本相同时，最低成本路径就是<strong>最短路径</strong>。</p>
<p>　　节点<span class="math inline">\(x\)</span>到节点<span
class="math inline">\(y\)</span>的最低成本可以用Bellman-Ford算法表示，即<span
class="math inline">\(d_{x}(y)=min_{v}\{c(x,v)+d_{v}(y)\}\)</span>，其中<span
class="math inline">\(v\)</span>表示<span
class="math inline">\(x\)</span>的所有邻居。</p>
<p>　　路由选择算法根据集中式/分布式可以分为<strong>集中式路由选择算法</strong>和<strong>分布式路由选择算法</strong>，根据静态/动态可以分为<strong>静态路由选择算法</strong>和<strong>动态路由选择算法</strong>，根据负载的敏感可以分为<strong>负载敏感算法</strong>和<strong>负载迟钝算法</strong>。</p>
<p>　　●
集中式路由选择算法以网络拓扑以及所有链路的成本为输入。具有全局状态信息的算法称为<strong>链路状态算法</strong>。</p>
<p>　　●
分布式路由选择算法中，每个节点开始时仅有与其直连链路的成本信息，然后通过迭代计算过程以及与相邻节点交换信息，逐渐计算出到达某个或某组目的节点的最低成本路径。每个节点维护到其他节点的成本(距离)估计的向量称为<strong>距离向量算法</strong>，主要通过与相邻路由器间交换交互式报文。</p>
<p>　　●
静态路由选择算法中路由选择随时间的变化非常缓慢，通常是人工进行调整。</p>
<p>　　●
动态路由选择算法随着网络流量负载或拓扑变化而改变路由选择路径。一个动态路由选择算法可以周期性地或直接响应拓扑或链路成本变化。</p>
<p>　　●
负载敏感算法中，链路成本会动态地变化来反映底层链路的当前拥塞水平。若当前拥塞的链路与高成本相关联则该算法会趋向绕开该拥塞链路来选择路由。</p>
<p>　　●
负载迟钝算法中，链路成本不会明确地反映其当前会最近的拥塞水平。</p>
<p>　　<strong>收敛</strong>指网络中所有路由器的路由选择表中的信息完全一致。</p>
<h4 id="ls算法">4.3.1 LS算法</h4>
<p>　　链路状态算法通过让每个节点向网络中所有其他节点广播链路状态分组来获得网络拓扑以及所有链路成本，其中每个链路状态分组包含它所连接的链路的标识和成本，这通常由<strong>链路状态广播算法</strong>来完成。</p>
<p>　　Dijkstra算法从某节点到网络中所有其他节点的最低成本路径，该算法是迭代算法，迭代<span
class="math inline">\(k\)</span>次后可以获得<span
class="math inline">\(k\)</span>个目的节点的最低成本路径。<span
class="math inline">\(D(v)\)</span>表示到本次迭代为止，从源节点<span
class="math inline">\(u\)</span>到节点<span
class="math inline">\(v\)</span>的最低成本路径的成本。<span
class="math inline">\(p(v)\)</span>表示源节点<span
class="math inline">\(u\)</span>到节点<span
class="math inline">\(v\)</span>的当前最低成本路径中<span
class="math inline">\(v\)</span>的前一节点。<span
class="math inline">\(N&#39;\)</span>表示节点子集，若源节点<span
class="math inline">\(u\)</span>到节点<span
class="math inline">\(v\)</span>的最低成本路径已知，则<span
class="math inline">\(N&#39;\)</span>包含<span
class="math inline">\(v\)</span>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 初始化阶段：N&#x27;仅包含u，若v是u的邻居则D(v) = c(u,v)，p(v) = u，否则D(v) = ∞ */</span><br><span class="line">Initialization:</span><br><span class="line">　N&#x27; = &#123;u&#125;</span><br><span class="line">　for all nodes v</span><br><span class="line">&amp;#12288;&amp;#12288;if v is a neighbor of u</span><br><span class="line">&amp;#12288;&amp;#12288;　D(v) = c(u, v)</span><br><span class="line">&amp;#12288;&amp;#12288;else D(v) = ∞</span><br><span class="line">/* 循环阶段：查找不在N&#x27;中且到u的最短成本路径最小的节点w，将w加入N&#x27;。若节点v不在N&#x27;中且是w的邻居则更新D(v)和p(v)。当N&#x27;包含所有节点时结束循环 */</span><br><span class="line">Loop</span><br><span class="line">　find w not in N&#x27; such that D(w) is a minimum</span><br><span class="line">　add w to N&#x27;</span><br><span class="line">　update D(v) for each neighbor v of w and not in N&#x27;:</span><br><span class="line">&amp;#12288;&amp;#12288;D(v) = min(D(v), D(w) + c(w, v))</span><br><span class="line">until N&#x27; = N</span><br></pre></td></tr></table></figure>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/link_state_algorithm_in_operation.svg" class="">
<p>　　LS算法结束后，获得了除源节点以外的每个节点的最低成本路径以及前一节点。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/osciallations_with_congestion_sensitive_routing.svg" class="">
<p>　　当出现振荡时，最简单的解决方法是强制链路成本与承载的流量无关，但是这违背了路由选择的初衷之一——避开拥塞严重的链路。另一种解决方法是确保并非所有的路由器都同时运行LS算法。路由器最初在同一周期的不同时间执行算法，但最终算法会在路由器上同步并一直保持。避免这种自同步的方法之一就是让每台路由器发送链路通告的时间随机化。</p>
<h4 id="dv算法">4.3.2 DV算法</h4>
<p>　　根据Bellman-Ford算法可以实现邻居间的通信，基本思想是对应每个节点<span
class="math inline">\(x\)</span>以<span
class="math inline">\(D_x(y)\)</span>开始，对于<span
class="math inline">\(N\)</span>中的所有节点<span
class="math inline">\(y\)</span>，估计从<span
class="math inline">\(x\)</span>到<span
class="math inline">\(y\)</span>的最低成本路径的成本。<span
class="math inline">\(D_x=[D_x(y):y\in N]\)</span>表示节点<span
class="math inline">\(x\)</span>的距离向量，该向量是从<span
class="math inline">\(x\)</span>到<span
class="math inline">\(N\)</span>中所有目的地节点<span
class="math inline">\(y\)</span>的成本估计向量。</p>
<p>　　使用DV算法，每个节点<span
class="math inline">\(x\)</span>需要维护自身的距离向量<span
class="math inline">\(D_x=[D_x(y):y\in N]\)</span>，每个邻居<span
class="math inline">\(v\)</span>的成本<span
class="math inline">\(c(x,v)\)</span>以及每个邻居<span
class="math inline">\(v\)</span>的距离向量<span
class="math inline">\(D_v=[D_v(y):y\in
N]\)</span>。每个节点不时地向每个邻居发送它的距离向量副本，邻居收到新的距离向量时，保存该距离向量并使用Bellman-Ford算法更新自身的距离向量。当节点的距离向量因收到邻居的距离向量或链路成本变化而改变时，该节点需要向所有邻居发送改变后的距离向量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initialization:</span><br><span class="line">　for all destinations y in N:</span><br><span class="line">&amp;#12288;&amp;#12288;Dₓ(y) = c(x, y)</span><br><span class="line">　for each neighbor v</span><br><span class="line">&amp;#12288;&amp;#12288;Dᵥ(y) = ? for all destinations y in N</span><br><span class="line">　for each neighbor v</span><br><span class="line">&amp;#12288;&amp;#12288;send distance vector Dₓ = [Dₓ(y):y in N] to v</span><br><span class="line">Loop</span><br><span class="line">　wait until link cost changes or receive a distance vector</span><br><span class="line">　for each y in N:</span><br><span class="line">&amp;#12288;&amp;#12288;Dₓ(y) = minᵥ&#123;c(x, y) + Dᵥ(y)&#125;</span><br><span class="line">　if Dₓ(y) changed for any destination y</span><br><span class="line">&amp;#12288;&amp;#12288;send distance vector Dₓ = [Dₓ(y):y in N] to all neighbors</span><br><span class="line">forever</span><br></pre></td></tr></table></figure>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/distance_vector_algorithm_in_operation.svg" class="">
<p>　　假设<span class="math inline">\(t_0\)</span>时刻<span
class="math inline">\(x\)</span>与<span
class="math inline">\(y\)</span>间的链路成本从2变为10，则<span
class="math inline">\(D_y(x)=min\{10+0,1+3\}=4\)</span>，若<span
class="math inline">\(y\)</span>需要发送分组到<span
class="math inline">\(x\)</span>，则需要通过<span
class="math inline">\(z\)</span>，<span
class="math inline">\(t_1\)</span>时刻分组到达<span
class="math inline">\(z\)</span>，但是<span
class="math inline">\(z\)</span>节点的路由选择表中是通过<span
class="math inline">\(y\)</span>到达<span
class="math inline">\(x\)</span>，然后就出现了<strong>路由选择环路</strong>，即从<span
class="math inline">\(y\)</span>发往<span
class="math inline">\(x\)</span>的分组在<span
class="math inline">\(y\)</span>和<span
class="math inline">\(z\)</span>间来回传输。在<span
class="math inline">\(t_1\)</span>后的某个时刻，<span
class="math inline">\(z\)</span>收到了<span
class="math inline">\(y\)</span>的新距离向量，即<span
class="math inline">\(D_y(x)=4\)</span>，重新计算到<span
class="math inline">\(x\)</span>的最低成本<span
class="math inline">\(D_z(x)=min\{7+0,1+4\}=5\)</span>，<span
class="math inline">\(t_2\)</span>时刻<span
class="math inline">\(y\)</span>收到<span
class="math inline">\(z\)</span>的新距离向量，即<span
class="math inline">\(D_z(x)=5\)</span>，重新计算到x的最低成本<span
class="math inline">\(D_y(x)=min\{10+0,1+5\}=6\)</span>，这个过程会一直持续到<span
class="math inline">\(D_z(y)=11\)</span>，然后<span
class="math inline">\(z\)</span>确定到<span
class="math inline">\(x\)</span>的最低成本路径就是直接到<span
class="math inline">\(x\)</span>而不是通过<span
class="math inline">\(y\)</span>。当<span
class="math inline">\(c(x,y)\)</span>从4变为10000时，这种情况可以称为<strong>无穷计数</strong>问题。</p>
<p>　　通过<strong>毒性逆转</strong>可以解决这种<span
style="background-color: yellow">仅涉及2个节点</span>的简单路由选择环路，若<span
class="math inline">\(z\)</span>需通过<span
class="math inline">\(y\)</span>到达<span
class="math inline">\(x\)</span>，则发送<span
class="math inline">\(D_z(x)=\infty\)</span>的新距离向量给<span
class="math inline">\(y\)</span>来毒化<span
class="math inline">\(z\)</span>到<span
class="math inline">\(y\)</span>的逆向路径。<span
class="math inline">\(y\)</span>会发送<span
class="math inline">\(D_y(x)=10\)</span>的新距离向量给<span
class="math inline">\(z\)</span>，因为<span
class="math inline">\(y\)</span>不再通过<span
class="math inline">\(z\)</span>到<span
class="math inline">\(x\)</span>，之后<span
class="math inline">\(z\)</span>发送<span
class="math inline">\(D_z(x)=7\)</span>的新距离向量给<span
class="math inline">\(y\)</span>，<span
class="math inline">\(y\)</span>更新到<span
class="math inline">\(x\)</span>的最低成本路径的成本<span
class="math inline">\(D_y(x)=8\)</span>，此时<span
class="math inline">\(z\)</span>位于<span
class="math inline">\(y\)</span>到<span
class="math inline">\(x\)</span>的最低成本路径上，<span
class="math inline">\(y\)</span>发送<span
class="math inline">\(D_y(x)\)</span>的新距离向量来毒化<span
class="math inline">\(y\)</span>到<span
class="math inline">\(z\)</span>的逆向路径。</p>
<h4 id="ls算法与dv算法的比较">4.3.3 LS算法与DV算法的比较</h4>
<p>　　在LS算法的具体实现中，每个节点需要将该节点到所有邻居的直接相连链路的成本广播到其他所有节点。而在DV算法的具体实现中，每个节点仅需将已知的该节点到其他节点的估计最低成本发送给所有邻居。</p>
<p>　　● 从报文复杂性的角度，LS算法需要发送<span
class="math inline">\(O(|N||E|)\)</span>个报文，当某条链路的成本改变时需要重新向其他节点发送报文；DV算法需要迭代的过程中仅邻居间交换报文，当某个节点到另一节点的最低成本路径的成本改变时才发送改变后的路径成本。</p>
<p>　　● 从收敛速率的角度，LS算法的收敛所需时间为<span
class="math inline">\(O(|N|^2)\)</span>；DV算法的收敛速率较慢，收敛的过程中可能会出现路由选择环路以及无穷计数。</p>
<p>　　●
从健壮性的角度，LS算法使用了广播的形式，每个节点仅计算自身的路由选择表，即每个节点在一定程度上是分离的，若某个节点损坏或丢弃了某个收到的分组也只会影响自身的路由选择表，保证了一定的健壮性；DV算法中每次迭代中每个节点的计算的最低成本路径的成本会发送给邻居，在下次迭代中会进一步扩散，经过一段时间，一个错误的最低成本路径的成本会扩散到整个网络。</p>
<h3 id="ospf">4.4 OSPF</h3>
<p>　　OSPF是一种链路状态协议，它使用链路状态信息泛洪和Dijkstra最低成本路径算法。<strong>链路状态通告</strong>包含在OSPF报文中，OSPF报文由<span
style="background-color: yellow">直接由IP承载</span>。每台路由器都构建了整个AS的完整拓扑图，然后每台路由器在本地运行Dijkstra最低成本路径算法，以确定以自身为根节点到所有子网的最短路径树。OSPF不强制设置路径权值，而是提供一种协议，为给定链路权值集合确定最低成本路径的路由选择。</p>
<p>　　OSPF协议中，当一条链路的状态发生变化时，路由器会广播链路状态信息，即使未发生变化，路由器也周期性地广播链路状态信息。OSPF协议需要检测链路是否正常运行(通过邻居间发送HELLO报文)，允许路由器获得邻居网络范围内链路状态的数据库。</p>
<p>　　OSPF的优点包括安全、多条相同成本的路径、对单播与多播路由选择的综合支持以及支持单个AS中的层次结构。</p>
<p>　　●
OSPF协议提供了报文认证来保证安全性。OSPF报文默认不启用认证，可以配置简单认证和MD5认证。简单验证基于配置在所有路由器中的共享密码，但密码会以明文的形式出现在OSPF报文中。MD5认证基于配置在所有路由器上的共享密钥，发送路由器在OSPF报文中加入报文内容加密钥的MD5散列值。MD5认证与序号一起使用来防止重放攻击。</p>
<p>　　●
当存在多条成本相等的路径时，无须仅选择单一的路径来承载所有的流量。</p>
<p>　　● MOSPF是OSPF的简单扩展，用来提供多播的支持。</p>
<p>　　●
一个OSPF自治系统可以分层并配置为区域，其中只能存在一个主干区域，每个区域都运行自身的LS算法。在每个区域内，一台或多台区域边界路由器负责为发往区域外的分组提供路由选择。主干区域包含所有的区域边界路由器，可能包含一些非边界路由器。分组在区域间的路由选择需要先区域内路由到一个区域边界路由器，再通过主干区域路由到目的区域的区域边界路由器，最后路由到目的地。</p>
<h3 id="bgp">4.5 BGP</h3>
<p>　　在BGP中，分组并不是路由到一个特定的目的IP地址，而是路由到类似于CIDR的前缀，该前缀表示一个子网或一个子网的集合。因此，路由器的转发表将具有<span
class="math inline">\((x,I)\)</span>形式的表项，<span
class="math inline">\(x\)</span>表示诸如138.116.68/22的前缀，<span
class="math inline">\(I\)</span>表示该路由器的某个接口的接口号。</p>
<p>　　BGP允许每个子网向互联网的其他部分通告它的存在，同时确保所有AS收到该通告。</p>
<p>　　一台路由器可能知道多条到指定前缀的不同路由，为了确定最好的路由，而最好的路由基于策略以及可达性信息来确定，该路由器将在本地运行BGP路由选择(类似于DV算法，通过邻居获得前缀的可达性信息)。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/ebgp_and_ibgp_connections.svg" class="">
<p>　　在BGP中，每条直接连接以及所有通过该连接发送的报文称为<strong>BGP连接</strong>。若BGP连接跨越AS则称为<strong>外部BGP</strong>连接，若在同一AS则称为<strong>内部BGP</strong>连接。内部BGP连接<span
style="background-color: yellow">并不总是</span>对应物理链路。建立BGP连接的两个路由器互称<strong>BGP对等体</strong>，其中发送BGP报文的路由器称为<strong>BGP发言者</strong>。</p>
<p>　　对于每个AS，其中的路由器是要么是<strong>网关路由器</strong>，要么是<strong>内部路由器</strong>。网关路由器位于AS边缘，内部路由器仅连接AS内部的主机和路由器。</p>
<p>　　假设需要通告前缀<span
class="math inline">\(x\)</span>的可达性信息，以跳数较多的路径为例，首先网关路由器3a向网关路由器2c发送EBGP报文“AS3
<span
class="math inline">\(x\)</span>”，然后网关路由器2c向AS2内的所有其他路由器发送IBGP报文“AS3
<span
class="math inline">\(x\)</span>”，最后网关路由器2a向网关路由器1c发送EBGP报文"AS2
AS3 <span class="math inline">\(x\)</span>"。</p>
<p>　　路由器通过BGP连接通告前缀时，前缀中包括一些<strong>BGP属性</strong>，前缀及其属性称为<strong>路由</strong>。BGP属性分为<strong>公认必遵</strong>、<strong>公认任意</strong>、<strong>可选传递</strong>和<strong>可选非传递</strong>。</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 53%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr>
<th>BGP属性类别</th>
<th>BGP属性类别详情</th>
<th>包含的BGP属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>公认必遵</td>
<td>所有BGP路由器必须支持，必须包含于更新报文中</td>
<td>ORIGIN、AS_PATH、NEXT_HOP</td>
</tr>
<tr>
<td>公认任意</td>
<td>所有BGP路由器必须支持</td>
<td>LOCAL_PREF、ATOMIC_AGGREGATE</td>
</tr>
<tr>
<td>可选传递</td>
<td>可以不支持，即使不支持也应该能接收包含该属性的路由并传递给邻居</td>
<td>COMMUNITY、AGGREGATOR</td>
</tr>
<tr>
<td>可选非传递</td>
<td>可以不支持，若不支持则可以忽略包含该属性的更新报文</td>
<td>MULTI_EXIT_DISC、ORIGINATOR_ID、CLUSTER_ID</td>
</tr>
</tbody>
</table>
<p>　　<strong>ORIGIN</strong>标识路由信息的来源。</p>
<p>　　<strong>AS_PATH</strong>包含了通告已通过的AS列表，可用来检测和防止通告环路，若路由器在AS_PATH中发现包含了自身所属的AS则拒绝该通告。</p>
<p>　　<strong>NEXT_HOP</strong>是<span
style="background-color: yellow">AS_PATH起始路由器接口的IP地址</span>。对于从AS1通过AS2到<span
class="math inline">\(x\)</span>的路由"AS2 AS3 <span
class="math inline">\(x\)</span>"，NEXT_HOP是路由器2a的左边接口的IP地址。对于AS1直接路由到AS3的路由"AS3
<span
class="math inline">\(x\)</span>"，NEXT_HOP是路由器3d的最左边接口的IP地址。</p>
<p>　　<strong>LOCAL_PREF</strong>表示路由的优先级，仅用在IBGP对等体间，由<span
style="background-color: yellow">本地AS的路由选择策略</span>决定。</p>
<p>　　<strong>ATOMIC_AGGREGATE</strong>表示路由已聚合。</p>
<p>　　<strong>COMMUNITY</strong>表示共享相同属性的目的地集合，用于将路由信息编组，通过组的标识决定路由策略的传递。</p>
<p>　　<strong>AGGREGATOR</strong>是ATOMIC_AGGREGATE的补充，包含发起路由聚合的ASN和形成聚合路由的BGP发言者的IP地址。</p>
<p>　　<strong>MULTI_EXIT_DISC</strong>用于区分同一相邻AS的多个接口。</p>
<p>　　<strong>ORIGINATOR_ID</strong>用于标识路由反射器。</p>
<p>　　<strong>CLUSTER_ID</strong>用于标识路由反射器组。</p>
<h4 id="bgp路由选择">4.5.1 BGP路由选择</h4>
<p>　　<strong>热土豆路由选择</strong>可以从所有可能的路由中选择到对应NEXT_HOP路由器成本最小的路由，忽略剩余端到端成本。</p>
<p>　　使用热土豆路由选择在转发表中增加AS外部目的前缀的步骤如下：</p>
<p>　　1) 从AS间路由选择协议知道可通过多个网关到达子网<span
class="math inline">\(x\)</span>。</p>
<p>　　2)
通过AS内部路由选择协议获取的路由选择信息来计算到每个网关的最低成本路径的成本。</p>
<p>　　3) 热土豆路由选择，即选择成本最低的网关。</p>
<p>　　4) 从转发表确定通往最低成本网关的接口<span
class="math inline">\(I\)</span>并在转发表中加入表项<span
class="math inline">\((x,I)\)</span>。</p>
<p>　　BGP实际使用的路由选择算法结合了热土豆路由选择的特点但更复杂。对应给定的目的前缀，算法的输入是到路由器已知悉且接受的到该前缀的所有路由的集合。若集合中多个路由则按下列消除原则直至最后一条路由：</p>
<p>　　1)
路由被分配LOCAL_PREF作为BGP属性之一。路由的LOCAL_PREF可能已由路由器设置，也可能已从同一AS中的另一台路由器获悉。选择具有最高LOCAL_PREF的路由。</p>
<p>　　2)
选择具有最短AS_PATH的路由。若该规则是路由选择的唯一规则，则BGP将使用DV算法决定路径，其中距离测量使用AS跳的跳数而非路由器跳的跳数。</p>
<p>　　3) 使用热土豆路由选择，选择到NEXT_HOP路由器成本最小的路由。</p>
<p>　　4) 使用BGP标识符来选择路由。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/simple_policy_scenario.svg" class="">
<p>　　假设A、B、C是主干提供商网络且它们直接向彼此发送流量，并向它们的客户网络提供全部的BGP信息，则W、Y是接入ISP，X是<strong>多宿接入ISP</strong>。可以通过控制BGP路由的通告的方式保证W、X和Y的存根网络行为，例如，X可能知道到Y的一条路径(XCY)，但X<span
style="background-color: yellow">不会</span>将此路径通告给B，因此B也不会经由X来转发到C或Y的分组。</p>
<p>　　所有进入接入ISP网络的流量必定是以该网络为目的地，所有离开接入ISP网络的流量必定源自该网络。</p>
<p>　　各个对等协议通常都是ISP双方协商且通常对外保密。</p>
<p>　　商业规则是任何流经ISP提供商网络的流量的源或目的地(或两者)必须位于该ISP的客户网络中，否则这些流量将免费通过该ISP的网络。</p>
<h4 id="ip任播">4.5.2 IP任播</h4>
<p>　　当BGP被用于实现IP任播时，常用于DNS中。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/ip_anycast_forwards_requests_to_the_closest_cdn_server.svg" class="">
<p>　　在IP任播配置时，CDN公司为多台CDN服务器指派了<span
style="background-color: yellow">相同的IP地址</span>，然后这些服务器中的每一台都使用BGP来通告该IP地址。当某台BGP路由器收到该IP地址的多个路由通告时，它将这些通告视为到同一物理位置的不同路径，配置路由选择表时，路由器将在本地使用BGP路由选择算法来确定最合适的路由。实际中CDN通常不使用IP任播，因为BGP路由选择的变化可能导致同一的TCP连接的的分组到达Web服务器的不同实例。</p>
<p>　　在DNS系统中，IP任播常用于将DNS请求指向最近的根DNS服务器。</p>
<h3 id="sdn">4.6 SDN</h3>
<p>　　SDN体系结构包括<strong>基于流的转发</strong>、<strong>数据平面和控制平面分离</strong>、<strong>网络控制</strong>以及<strong>可编程网络</strong>这4个关键特征。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/sdn_architecture.svg" class="">
<p>　　控制平面由SDN控制器(或网络操作系统)以及若干网络控制应用程序(运行在网络控制服务器上)组成。控制器维护准确的网络状态信息并为网络控制应用程序提供这些信息，还为这些应用程序提供方法来监控、编程以及控制底层网络设备。</p>
<p>　　SDN控制器的功能可分为<strong>通信层</strong>、<strong>网络范围状态管理层</strong>和<strong>网络控制应用层的接口</strong>。</p>
<p>　　●
若SDN控制器需要控制远程设备，则需要一个协议(OpenFlow)来为SDN控制器和该设备传输信息。此外，该设备必须能够将本地观察到达的事件传输给SDN控制器。SDN控制器和受控网络设备之间的通信跨越了SDN控制器的南向接口。</p>
<p>　　●
SDN控制平面做出的最终控制决策将要求SDN控制器具有网络主机、链路、交换机和其他SDN控制的设备的最新状态信息。交换机的流表包含计数器，其值可以为网络控制应用程序所用。因为控制平面的最终目标是确定各种受控设备的流表，SDN控制器可能也维护这些表的副本。</p>
<p>　　●
SDN控制器通过它的北向接口与网络控制应用程序交互。该接口允许网络控制应用程序在状态管理层中读取/写入网络状态和流表。应用程序可以注册以状态更新事件时收到通知，这样它们可以采取行动以响应来自受控于SDN的设备发送的网络事件通知。</p>
<h4 id="openflow">4.6.1 OpenFlow</h4>
<p>　　<span
style="background-color: yellow">OpenFlow</span>是一个得到高度认可和成功的标准，它开创了匹配加动作转发抽象、控制器的概念以及更广泛的SDN革命。实际应用包括简单转发、负载均衡以及防火墙。</p>
<p>　　匹配加动作转发表在OpenFlow中称为<strong>流表</strong>。表项包括首部字段值的集合、计数器集合以及匹配项对应的动作集合。当匹配成功时更新计数器，计数器可能包括匹配成功分组的数量以及上次更新时间。匹配失败的分组将被丢弃或发送到远程控制器进行更多处理。在实践中，一个流表可能由多个流表实现。动作包括转发给指定的一个或多个输出端口、丢弃、复制以及重写部分首部字段。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/packet_matching_fields_of_openflow_1.0_flow_table.svg" class="">
<p>　　支持OpenFlow的设备可以充当路由器转发分组以及充当交换机转发帧。以太网类型对应用来分解复用帧的有效载荷的传输层协议。</p>
<p>　　输入端口指路由器接收分组的输入端口。</p>
<p>　　流表项可以使用通配符<code>*</code>。每个流表项具有优先级。</p>
<p>　　动作中重要的动作包括转发、丢弃和修改字段。</p>
<p>　　●
分组可以转发到指定的物理输出端口，可以广播到所有端口，也可以通过所选的端口集合进行多播。该分组可能被封装并发送到远程控制器，远程控制器可能会对分组进行某些动作，例如，安装新的流表项并可能返回分组来更新流表项来根据更新的流表项转发。</p>
<p>　　● 没有对应动作时分组将被丢弃。</p>
<p>　　●
分组被转发到指定的输出端口之前，源MAC地址、目的MAC地址、以太网类型、局域网ID、局域网优先级、源IP地址、目的IP地址、服务类型、源端口、目的端口这些字段的值可以重写。</p>
<p>　　从SDN控制器流向受控路由器的重要报文包括<span
style="background-color: yellow">配置</span>报文、<span
style="background-color: yellow">修改状态</span>报文、<span
style="background-color: yellow">读取状态</span>报文、<span
style="background-color: yellow">发送分组</span>报文。配置报文允许SDN控制器查询并设置路由器的配置参数。修改状态报文用于增加/删除/修改路由器流表中的表项并设置路由器的端口属性。读取状态报文用于从路由器的流表和端口收集统计数据以及计数器值。发送分组报文用于从受控路由器的指定端口发送特定报文，报文的有效载荷包含分组。</p>
<p>　　从受控路由器流向SDN控制器的重要报文包括<span
style="background-color: yellow">流删除</span>报文、<span
style="background-color: yellow">端口状态</span>报文、<span
style="background-color: yellow">分组进入</span>报文。流删除报文用于通知SDN控制器已删除一个流表项。端口状态报文用于向SDN控制器通知端口状态的变化。分组进入报文用于分组匹配成功的分组发给SDN控制器。</p>
<h4 id="数据平面与控制平面的交互">4.6.2 数据平面与控制平面的交互</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/sdn_scenario_link_state_change.svg" class="">
<p>　　Dijkstra算法是实现在每台路由器中泛洪链路状态更新，这里Dijkstra算法作为路由器外部的一个单独的程序而且路由器将链路更新发送到SDN控制器而非彼此。</p>
<p>　　假设OpenFlow作为通信层协议，控制平面只执行路由选择。此外，s1与s2之间的链路出现了故障。</p>
<p>　　1) s1使用OpenFlow的端口状态报文通知SDN控制器链路状态改变。</p>
<p>　　2)
SDN控制器收到报文后通知链路状态管理器，链路状态管理器更新链路状态数据库。</p>
<p>　　3)
因为用于实现Dijkstra算法的网络控制应用程序之前已经注册，网络控制应用程序收到了链路状态更改的通知。</p>
<p>　　4)
链路状态应用程序与链路状态管理器交互以获取最新的链路状态信息，也可能会与链路状态管理层的其他组件交互，然后计算新的最低成本路径。</p>
<p>　　5) 链路状态应用程序与流表管理器交互来更新流量。</p>
<p>　　6) 流表管理器使用OpenFlow更新受影响路由器的流表项。</p>
<h4 id="sdn的发展">4.6.3 SDN的发展</h4>
<p>　　Google的B4网络使用定制的交换机，每台交换机实现了OpenFlow的扩展版并带有本地OpenFlow代理。每个OFA与网络控制服务器中的OpenFlow控制器连接，使用单独的带外网络，该网络不同于数据中心间传输数据中心流量的网络。OpenFlow控制器因此提供网络控制服务器和其受控交换机之间的通信。在B4中，OpenFlow控制器还执行状态管理功能，将节点与链路信息保存在网络信息数据库中。OpenFlow控制器的实现基于ONIX
SDN控制器。B4网络实现了BGP和IS-IS(类似于OSPF)。</p>
<p>　　在SDN发展早期，采用单一的SDN协议(OpenFlow)和单一的SDN控制器。后来，OpenDaylight(ODL)控制器和ONOS控制器得到业界广泛支持。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/opendaylight_simplified_architecture.svg" class="">
<p>　　<strong>网络服务应用程序</strong>用于决定受控路由器完成数据平面转发和其他服务(如防火墙和负载均衡)。ODL控制器的核心是<strong>基本网络服务功能</strong>。控制器有REST接口和服务抽象层这2个接口，外部应用程序通过HTTP上的REST接口与控制器通信，内部应用程序通过SAL相互通信。应用程序实现在控制器外部还是控制器内部由应用程序设计者决定。</p>
<p>　　SAL允许控制器组件和应用程序互相调用并订阅彼此生成的事件，它还为通信层中特定的协议(如OpenFlow、SNMP和OVSDB)提供统一的抽象接口。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/onos_simplified_architecture.svg" class="">
<p>　　ONOS作为服务部署在一组互联的服务器上，每台服务器都运行相同的ONOS软件副本。</p>
<p>　　ONOS的一个独特功能是它的意图框架，它允许网络控制应用程序请求高级服务而无须了解该服务的具体信息。状态信息通过北向接口以同步(查询)或异步(监听器回调)提供给应用程序。</p>
<p>　　ONOS的分布式核心维护网络链路、主机以及设备的状态等。ONOS核心提供复制和实例间协调机制，为上层的应用程序和下层的受控设备提供逻辑上的集中式核心服务抽象。</p>
<p>　　ONOS的南向接口屏蔽底层主机、链路、交换机和协议的差异，允许分布式核心和这些无关。</p>
<h3 id="icmp">4.7 ICMP</h3>
<p>　　ICMP虽然是网络层协议，但ICMP报文作为IP数据包的有效载荷，类似于TCP和UDP。ICMP最典型的用途是差错报告。基于ICMP的常用程序是ping和traceroute。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/icmp_message_format.svg" class="">
<table>
<thead>
<tr>
<th>ICMP type</th>
<th>ICMP code</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>echo(ping) reply</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>destination network unreachable</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>destination host unreachable</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>destination protocol unreachable</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>destination port unreachable</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>destination network unknown</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>destination host unknown</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>source quench(congestion control)</td>
</tr>
<tr>
<td>8</td>
<td>0</td>
<td>echo(ping) request</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>router advertisement</td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>router discovery</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>TTL exceeded</td>
</tr>
<tr>
<td>12</td>
<td>0</td>
<td>IP header bad</td>
</tr>
</tbody>
</table>
<p>　　源抑制报文最初的目的是用于拥塞控制，即发送或对方减小发送速率。</p>
<p>　　在traceroute中，为了确定源主机和目的主机之间的路由器的主机板和IP地址，源主机向目的主机发送了一系列的IP数据报，这些数据报都带有一个不可达的UDP端口的UDP报文段，其中第<span
class="math inline">\(n\)</span>个数据报的TTL为<span
class="math inline">\(n\)</span>。因此，当第<span
class="math inline">\(n\)</span>个数据报到达第<span
class="math inline">\(n\)</span>个路由器时TTL刚好过期，路由器丢弃数据报并向源主机发送ICMP报文(type=11,code=0)，该报文包括路由器的主机名以及IP地址。当数据报到达目的主机时，由于UDP端口不可达，目的主机会向源主机发送ICMP报文(type=3,code=3)，源主机收到该报文后停止发送数据报。</p>
<h3 id="网络管理">4.8 网络管理</h3>
<p>　　<strong>网络管理</strong>包括对硬件、软件和人为元素的部署、集成和协调，以便对网络资源进行监视、测试、轮询、配置、分析、评估和控制，这样能以合理的成本满足诸如实时运行性能、服务质量等需求。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/components_of_network_management.svg" class="">
<p>　　网络管理的重要组件包括管理服务器、被管设备、MIB数据、远程代理以及SNMP。</p>
<p>　　管理服务器是一个应用程序，通常有人的参与，并在网络运营中心的集中式管理站上运行。管理服务器用于网络管理，负责网络管理信息的收集、处理、分析以及显示。</p>
<p>　　被管设备是被管网络中的网络设备(包括软件)。一个被管设备内可能有几个<strong>被管对象</strong>。这些被管对象包括被管设备中的实际硬件(例如，网络接口卡是主机或路由器的一个组件)以及用于这些硬件和软件组件的配置参数(例如，AS内部路由选择协议)。</p>
<p>　　被管设备中的每个被管对象的相关信息收集在<strong>管理信息库</strong>中，这些信息可供管理服务器使用。一个管理信息库的对象称为SMI，可以是计数器、收到的UDP报文的数量、描述性信息或状态信息等。</p>
<p>　　每个被管设备上都有<strong>网络管理代理</strong>，它是一个与管理服务器通信的进程，在管理服务器的命令和控制下在被管设备执行本地操作。</p>
<p>　　<strong>网络管理协议</strong>在管理服务器与被管设备间运行，运行管理服务器查询被管设备的状态并通过代理间接地在被管设备上采取行动。代理通过网络管理协议通知管理服务器异常事件。</p>
<p>　　<strong>简单网络管理协议</strong>用于管理服务器和被管设备上的网络管理代理之间传输网络管理控制和信息报文。SNMP常用模式是请求响应模式，管理服务器向代理发送请求，代理收到请求后执行某些操作并响应请求。请求通常用于查询或修改被管设备相关的MIB对象值。另一种情况是代理向管理服务器发送未被请求的报文，该报文称为<strong>陷阱报文</strong>。陷阱报文是异步产生的，即不是为了响应报文，而是为了响应管理服务器要求通知的事件，用于通知管理服务器异常情况导致MIB对象值改变。</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 34%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr>
<th>PDU类型</th>
<th>发送端-接收端</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetRequest</td>
<td>管理服务器到代理</td>
<td>获取一个或多个MIB对象值</td>
</tr>
<tr>
<td>GetNextRequest</td>
<td>管理服务器到代理</td>
<td>获取下一个MIB对象值</td>
</tr>
<tr>
<td>GetBulkRequest</td>
<td>管理服务器到代理</td>
<td>获取大数据块的值</td>
</tr>
<tr>
<td>InformRequest</td>
<td>管理服务器到管理服务器</td>
<td>通知<span
style="background-color: yellow">远程</span>管理服务器远程访问的MIB值</td>
</tr>
<tr>
<td>SetRequest</td>
<td>管理服务器到代理</td>
<td>设置一个或多个MIB对象值</td>
</tr>
<tr>
<td>Response</td>
<td>代理到管理服务器/管理服务器到管理服务器</td>
<td>响应GetRequest、GetNextRequest、GetBulkRequest、InformRequest和SetRequest</td>
</tr>
<tr>
<td>Trap</td>
<td>代理到管理服务器</td>
<td>通知管理服务器异常事件</td>
</tr>
</tbody>
</table>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_04/snmp_pdu_format.svg" class="">
<p>　　SNMP通常基于UDP，但UDP并不可靠，类似于rdt，管理服务器用Request
Id来标识报文。SNMP并没有强制重传，若需要重传，管理服务器设置重传频率和周期。</p>
<p>　　GetRequest、GetNextRequest、GetBulkRequest
PDU请求的值在PDU的变量绑定部分。GetRequest、GetNextRequest、GetBulkRequest
PDU的数据请求颗粒度不同，
GetRequest可以请求任意一组MIB值，多个GetNextRequest可用于对MIB对象的列表或表格进行排序，GetBulkRequest用于返回大块数据，相比多个GetRequest或GetNextRequest减小了成本。代理会使用包含对象标识符以及相关值的PDU来响应。</p>
<p>　　代理用带有"noError"错误状态的PDU来响应SetRequest。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第6章 无线网络和移动网络</title>
    <url>/network/computer_networking_a_top_down_approach_7e_chpt_06/</url>
    <content><![CDATA[<p>　　无线网络包括<strong>无线主机</strong>、<strong>无线链路</strong>、<strong>基站</strong>和<strong>网络基础设施</strong>。主机通过无线通信链路连接到基站或无线主机，这里的连接指的是主机位于基站的无线通信范围内且主机通过基站来中继到更大的网络。</p>
<p>　　连接到基站的主机通常以<strong>基础设施模式</strong>运行，因为所有传统网络服务都是由主机通过连接到基站的网络提供。在<strong>自组织网络</strong>中，无线主机没有可连接的此类基础设施，主机本身必须提供这些传统网络服务。</p>
<p>　　当移动主机超出当前基站的范围并进入去其他基站的范围时，它会更改连接点，这个过程称为<strong>切换</strong>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/part_of_wireless_network_standards.svg" class="">
<p>　　无线网络可以按基站与主机通信时经过单跳还是多跳以及网络中是否存在基础设施进行分类。</p>
<p>　　●
<strong>单跳且基于基础设施</strong>的无线网络中有1个连接到更大的有线网络的基站，该基站与无线主机之间的所有通信都仅经过单跳。</p>
<p>　　●
<strong>单跳且无基础设施</strong>的无线网络中的节点可以协调其他节点的传输。</p>
<p>　　●
<strong>多跳且基于基础设施</strong>的无线网络中有1个有线连接到更大的网络的基站，为了通过基站通信，其中部分节点需要通过其他节点中继它们的通信。</p>
<p>　　●
<strong>多跳且无基础设施</strong>的无线网络中没有基站，节点可能需要其他节点中继。若节点是移动的则称为<strong>移动自组织网络</strong>。若移动节点是车载的则称为<strong>车载自组织网络</strong>。</p>
<p>　　<strong>蜂窝</strong>(技术)是蜂窝网覆盖的区域被划分为称为<strong>小区</strong>或<strong>蜂窝</strong>的多个地理覆盖区域。每个蜂窝包含1个<strong>基站收发台</strong>，BTS负责向其蜂窝中的移动设备发送/接收信号。</p>
<p>　　对于TCP，比特差错或切换导致的报文段丢失不应该减小拥塞窗口，可以通过<span
style="background-color: yellow">本地恢复</span>、<span
style="background-color: yellow">让TCP双方知晓无线链路</span>、<span
style="background-color: yellow">拆分连接</span>来处理这个问题。本地恢复中的目标是在比特差错发生的时间和位置将其恢复，主要通过ARQ或FEC等实现。让TCP双方知晓无线链路的目标是区分有线网络的拥塞和其它两者并仅对拥塞进行拥塞控制。拆分连接常用于蜂窝网络，将连接分成无线部分和有线部分，无线部分使用标准TCP或带有差错恢复的UDP。</p>
<span id="more"></span>
<h3 id="无线链路和网络特征">6.1 无线链路和网络特征</h3>
<p>　　相比有线链路，无线链路存在<strong>信号强度的衰减</strong>、<strong>其他源的干扰</strong>以及<strong>多径传播</strong>。</p>
<p>　　●
电磁波穿过物体时信号强度会衰减。随着传播距离的增加，电磁波信号强度也会降低，称为<strong>路径损耗</strong>。</p>
<p>　　●
同一频段的电磁波将互相干扰，此外，环境中的其他电磁波也会导致干扰。</p>
<p>　　●
当部分电磁波在物体或地面上反射时，在发送端和接收端之间经过了不同长度的路径，称为<strong>多径传播</strong>，这样会导致接收端收到的信号模糊。</p>
<p>　　无线链路相比有线链路更容易出现比特差错，因此无线链路不仅采用了CRC编码，还使用了链路层ARQ协议来重传受损的帧。</p>
<p>　　接收端收到的电磁信号是发送端传输的初始信号的退化形式(信号衰减和多径传播等)和环境中的噪声(干扰信号)的结合。<strong>信噪比</strong>是收到的信号和噪声强度的相对值，即以10为底信号振幅与噪声振幅之比的对数的20倍。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/ber_and_transmission_rate_and_snr.svg" class="">
<p>　　对于给定的调制技术，SNR越高，BER越低，发送端可以通过增加传输速率来增加SNR，进而降低BER。增加传输速率会消耗更大的能量而且可能干扰其他发送端的传输，传输功率达到某个阈值时收益将微乎其微。</p>
<p>　　对于给定的SNR，传输速率越高，BER越高。</p>
<p>　　物理层调制技术的动态选择可用于适配信道条件的调制技术。</p>
<h3 id="ieee-802无线协议">6.2 IEEE 802无线协议</h3>
<p>　　在IEEE
802.11(WiFi)协议族中有几个WLAN技术的802.11标准。它们都使用了CSMA/CA协议，链路层帧结构相同，可以通过降低传输速率来增加传输距离，而且向后兼容。</p>
<table>
<thead>
<tr>
<th>标准</th>
<th>频率范围(Hz)</th>
<th>最高传输速率(<span class="math inline">\(Mb/s\)</span>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>802.11b</td>
<td>2.4G</td>
<td>11</td>
</tr>
<tr>
<td>802.11a</td>
<td>5G</td>
<td>54</td>
</tr>
<tr>
<td>802.11g</td>
<td>2.4G</td>
<td>54</td>
</tr>
<tr>
<td>802.11n</td>
<td>2.5~5G</td>
<td>450</td>
</tr>
<tr>
<td>802.11ac</td>
<td>5G</td>
<td>1300</td>
</tr>
</tbody>
</table>
<p>　　802.11设备工作在<span
style="background-color: yellow">2.4G~2.485G(称为2.4GHz)</span>和<span
style="background-color: yellow">5.1~5.8GHz(5GHz)</span>这两个不同的频段。2.4GHz是无须许可的频段，802.11设备可能与2.4GHz电话或微波炉竞争。在5GHz频段，802.11WLAN在给定功率时传输距离更短且更容易受到多径传播的影响。802.11n和802.11ac使用多输入多输出(MIMO)天线，即发送端和接收端都有两个或多个天线用来发送/接收不同的信号。802.11ac基站可以同时向多个基站发送信号，并使用智能天线自适应成型波束向目的地传输，这样减少了干扰并增加了给定速率下的传输距离。</p>
<p>　　除了802.11，其他两个802无线协议是使用802.15.1的蓝牙以及使用802.15.4的ZigBee。802.15.1是低功率、小范围、小速率的电缆代替技术，因此802.15.1也称为<strong>无线个人局域网</strong>。802.15.4服务于低功率、低数据率和低工作周期的应用，例如，物联网设备。</p>
<h4 id="体系结构">6.2.1 802.11体系结构</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/802.11_wlan_architecture.svg" class="">
<p>　　802.11体系结构的基本构建块是<strong>基本服务集</strong>。BSS包含若干个无线主机和1个称为<strong>接入点</strong>的中央基站。在常规的家庭网络中，1个AP和1个路由器(通常集成为1个单元)将BSS连接到互联网。</p>
<p>　　类似于以太网设备，每个802.11无线主机都有MAC地址，该地址存储在设备适配器(802.11网络接口卡)的固件中。每个AP的无线接口也有1个MAC地址。</p>
<p>　　部署AP的WLAN称为<strong>基础设施WLAN</strong>，基础设施指AP以及互联AP和路由器的有线以太网。802.11设备能将组成1个自组织网络，该网络无中央控制且与外部没有连接。</p>
<p>　　在802.11WLAN体系结构中，每个无线主机都需要与AP相连才能发送/接收网络层数据报。</p>
<p>　　在安装AP时会为AP分配1或2个字的<strong>服务集标识符</strong>和1个信道号。802.11在2.4Ghz~2.485Ghz的频段内运行，在这个85MHz的频段内，802.11定义了11个部分重叠的信道，2个信道只有被4个或更多信道隔开时才不会有重叠，因此信道1、6和11的唯一的3个不重叠信道集合，同一个网络里可以安装3个802.11b的AP并为这些AP分配信道1、6和11，然后将每个AP都连接到同一交换机上。2个不同ISP在同一区域都设置了AP且使用了相同的信道，若2个AP同时接收则会导致其中之一丢弃地址错误的帧，若2个AP同时发送则会导致碰撞。</p>
<p>　　<strong>WiFi丛林</strong>指无线主机能从至少2个AP接收到足够强的信号的任何物理位置。无线主机需要与AP<strong>关联</strong>才能加入AP所属子网并访问互联网，关联表示无线主机与AP建立一条虚拟链路。</p>
<p>　　802.11标准中AP会定期发送<strong>信标帧</strong>，每个信标帧包含AP的SSID和MAC地址。无线主机会扫描11个信道来获悉信标帧以及发送的AP。802.11标准并没有指定AP关联的算法，该算法由无线主机中的802.11固件和软件设计者决定。通常，设备会选择接收到的信标帧信号强度最高的AP，显然信号强度并不是决定设备接收性能的唯一AP特性。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/active_and_passive_scanning.svg" class="">
<p>　　无线主机通过向无线主机范围内所有的AP广播探测请求帧来<strong>主动扫描</strong>，也能通过扫描信道和侦听信标帧来<strong>被动扫描</strong>。无线主机选择AP后，向AP发送关联请求帧，AP响应关联响应帧。一旦与AP关联，无线主机将加入AP所属子网。</p>
<p>　　为了创建与特定AP的关联，无线主机可能需要向AP认证自身。802.11WLAN为认证和访问提供了多种选择，例如，基于主机的MAC地址和使用账户和密码，这两种方式中，AP通常与认证服务器通信，使用诸如RADIUS或DIAMETER之类的协议在无线主机与认证服务器之间中继信息。分离认证服务器和AP使得认证服务器可以为多个AP服务，将认证和访问的决策集中在单个服务器中，并降低AP成本和复杂度。</p>
<h4 id="mac协议">6.2.2 802.11MAC协议</h4>
<p>　　802.11的载波侦听分为物理侦听和虚拟侦听，主要使用虚拟侦听。802.11使用<strong>网络分配向量</strong>来实现虚拟侦听，NAV是一个微秒计时器，用来指示预计使用信道的时间，当NAV不为0时则表示信道忙碌。由于各种原因，帧可能无法完整地达到目的地，因此使用了类似于rdt2.0中ACK的<strong>链路层确认</strong>。</p>
<p>　　802.11MAC协议中帧间都有<strong>帧间间隔</strong>。一般情况下，发送帧前需要等待<strong>分布式帧间间隔</strong>，发送ACK帧前需要等待<strong>短帧帧间间隔</strong>，重传帧时需要等待<strong>扩展帧间间隔</strong>。SIFS是固定值，DIFS=SIFS+2slot
time。t(ACK)表示最低速率传输ACK所需时间，则EIFS=time(ACK)+SIFS+DIFS。</p>
<p>　　802.11MAC协议包括<strong>分布式协调功能</strong>、<strong>点协调功能</strong>和<strong>混合协调功能</strong>三种工作模式，其中DCF是PCF和HCF的基础，PCF是可选项，HCF提供QOS的支持。DCF采用竞争的方式接入信道，PCF采用统一分配的方式接入信道，HCF在DCF的基础上加入了QOS的支持。</p>
<p>　　●
DCF是站点共享信道的接入方式，接入方式是CSMA/CA，还加入了可选的短<strong>请求发送</strong>控制帧和短<strong>允许发送</strong>控制帧来避免长数据帧的碰撞。</p>
<p>　　●
PCF中需要1个站点作为<strong>点协调器</strong>，点协调器周期性地发送信标帧来广播WLAN的网络标识和管理参数，其他站点根据管理参数来设置NAV。由于信标帧通过DCF发送，点协调器必须参与信道竞争。PCF只能在<strong>非竞争期</strong>工作，其机制类似于轮流协议中的轮询协议，点协调器轮询其他节点，轮询的节点才能传输帧，帧的长度受到限制。</p>
<p>　　●
HCF类似于PCF，但可以在<strong>竞争期</strong>工作且支持QOS。</p>
<p>　　802.11并未实现碰撞检测，因为碰撞检测需要同时传输和侦听，由于接收信号的强度通常远小于发送信号的强度，实现碰撞检测成本较高。即使网络适配器可以同时传输和侦听(并在检测到碰撞时时中止传输)，由于隐藏终端和信号衰减的问题，网络适配器依然无法检测到所有碰撞。</p>
<p>　　当源站点有帧待发送时需要先侦听信道，当信道空闲后需要等待DIFS，若在此期间未侦听到信号就发送帧，否则源站点像CSMA/CD一样使用二进制指数退避算法计算退避时间并启动<strong>退避计时器</strong>，不同的是基本退避时间为1个时隙，退避时间的随机区间为[0,CW<span
class="math inline">\(\times\)</span>slot
time)，CW是<strong>竞争窗口</strong>，最小值是<span
class="math inline">\(2^4-1\)</span>，最大值是<span
class="math inline">\(2^{10}-1\)</span>。侦听到的信道空闲时间至少为1时隙时，计时器才会减1(时隙)。若在退避时间内侦听到信号则暂停计时器，然后会重新等待到信道空闲并在下一个DIFS后再次启动计时器(计时器时间是剩下的时间)，计时器为0时发送帧。若至少2个站点选择了相同的退避时间则可能导致碰撞，碰撞后CW会变为原来的2倍加1。当AP收到通过CRC的帧时，它会等待SIFS后响应1个ACK帧。若源站点等待ACK帧超时则会等待EIFS后重传，在给定次数的重传后依然未收到ACK帧则丢弃帧。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/hidden_terminal.svg" class="">
<p>　　无线主机H1和H2都在AP的范围内且都与AP关联，但由于信号衰减，两个无线主机对AP不隐藏，但是对彼此隐藏。若H1正在传输帧时，H2也要传输帧，这会导致碰撞，因此H1和H2的整个传输期间，信道都被浪费。</p>
<p>　　为了避免隐藏终端导致的问题，802.11协议允许无线主机使用RTS帧和CTS帧来预约信道的访问。类似于TCP建立连接，当源站点有数据帧要发送时，可以先向AP发送一个RTS帧来指示传输数据帧和ACK帧所需的总时间，能够侦听到源站点信号的站点会进入NAV静默状态。当AP收到RTS帧后通过广播CTS帧来响应，这样既给了源站点明确的发送权限，也指示了其他站点在预约时间内不要发送，其他所有节点也进入NAV静默状态。若等待CTS帧超时则像发送普通数据帧一样使用二进制指数退避算法来计算退避时间并等待然后重传。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/collision_avoidance_using_rts_and_cts_frames.svg" class="">
<p>　　尽管RTS和CTS帧有助于减少碰撞，但也引入了延迟并消耗信道资源，因此，RTS和CTS帧仅用于长数据帧的传输信道预约。实际上可以为每个无线站点设置RTS阈值，当帧的长度超过阈值时才使用RTS/CTS帧，默认阈值一般是<span
class="math inline">\(2347B\)</span>，即不使用。除了解决隐藏终端，RTS和CTS帧体现了<span
style="background-color: yellow">用短帧的碰撞来避免长帧的碰撞</span>。</p>
<h4 id="帧">6.2.3 802.11帧</h4>
<p>　　802.11帧分为<strong>数据帧</strong>、<strong>控制帧</strong>和<strong>管理帧</strong>。数据帧用于传输数据，控制帧通常与数据中配合使用。负责区域的清空、信道的获取、载波侦听的维护和响应数据。管理帧用于加入或退出WLAN以及处理基站之间的转移。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/802.11_frame_format.svg" class="">
<p>　　802.11帧包括<span
class="math inline">\(2B\)</span><strong>帧控制</strong>、<span
class="math inline">\(2B\)</span><strong>持续期或ID</strong>、<span
class="math inline">\(6B\)</span><strong>地址1</strong>、<span
class="math inline">\(6B\)</span><strong>地址2</strong>、<span
class="math inline">\(6B\)</span><strong>地址3</strong>、<span
class="math inline">\(2B\)</span><strong>序号控制</strong>、<span
class="math inline">\(6B\)</span><strong>地址4</strong>、最多<span
class="math inline">\(2312B\)</span>的有效载荷以及<span
class="math inline">\(4B\)</span>CRC。</p>
<p>　　帧控制包括帧的类型信息和一些控制位。</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 16%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr>
<th>帧控制字段</th>
<th>长度(单位是<span class="math inline">\(b\)</span>)</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>protocol version</td>
<td>2</td>
<td>802.11协议版本，目前只有一个版本，该字段值为0</td>
</tr>
<tr>
<td>type</td>
<td>2</td>
<td>值为00时表示管理帧，值为01时表示控制帧，值为10时表示数据帧，值为11保留</td>
</tr>
<tr>
<td>subtype</td>
<td>4</td>
<td>具体的802.11帧类型信息</td>
</tr>
<tr>
<td>to DS</td>
<td>1</td>
<td>值为1时表示帧发送到无线工作站(例如，AP)</td>
</tr>
<tr>
<td>from DS</td>
<td>1</td>
<td>值为1时表示帧由无线工作站(例如，AP)发送</td>
</tr>
<tr>
<td>more flag</td>
<td>1</td>
<td>类似于IPv4数据报中的分片标志位</td>
</tr>
<tr>
<td>retry</td>
<td>1</td>
<td>值为1时表示重传帧</td>
</tr>
<tr>
<td>power management</td>
<td>1</td>
<td>值为1时发送完本帧后进入省电模式</td>
</tr>
<tr>
<td>more data</td>
<td>1</td>
<td>仅用于管理帧，控制帧的该字段值为0</td>
</tr>
<tr>
<td>protected frame</td>
<td>1</td>
<td>值为1时表示有效载荷已加密</td>
</tr>
<tr>
<td>order</td>
<td>1</td>
<td>值为1时表示帧按序传输</td>
</tr>
</tbody>
</table>
<p>　　持续期用于记录NAV的值。当最后一位为0时用于设置NAV，例如，RTS和CTS帧中会设置这个值来指示其他站点在指定时间内不要发送帧。</p>
<p>　　地址1表示接收端(接收端不一定是目的地)的MAC地址。</p>
<p>　　地址2表示发送端(发送端不一定是源)的MAC地址。</p>
<p>　　地址3用于基站和传输系统的过滤，具体用法取决于网络类型。例如，1台路由器需要向某个BSS中的某台无线主机发送帧，但是路由器并不知道它需要通过AP到达无线主机，路由器发送目的MAC地址为无线主机的<span
style="background-color: yellow">以太帧</span>到AP。AP收到以太网帧后将其<span
style="background-color: yellow">转换为802.11帧</span>，该802.11帧的地址1是无线主机的MAC地址，地址2是自身地址，地址3是路由器发送数据报接口的MAC地址。</p>
<p>　　序号控制类似于rdt2.0中的序号。</p>
<p>　　地址4仅在无线分布式系统中使用。</p>
<h4 id="蓝牙和zigbee">6.2.4 蓝牙和ZigBee</h4>
<p>　　802.15.1的链路层和物理层基于早期的PAN蓝牙规范。802.15.1以TDM方式在2.4GHz频段上运行，时隙是625<span
class="math inline">\(\mu
s\)</span>。在每个时隙中，发送端在79个信道中的一个上进行传输，信道以已知但伪随机的方式跳频，称为<strong>跳频扩频</strong>。802.15.1可提供最高<span
class="math inline">\(4Mb/s\)</span>的传输速率。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/bluetooth_piconet.svg" class="">
<p>　　802.15.1网络是自组织网络，802.15.1设备首先组织成最多八个活动设备的<strong>微微网</strong>，这些设备之一被指定为主设备，其他设备充当从设备。主设备管理微微网，因为它的时钟决定微微网的时间，它可以在每个奇数时隙中传输，而从设备只能在主设备前一时隙与它通信后才能传输。除了从设备，微微网还可以容纳最多255个停放设备，停放设备只能在主设备将其状态变更为活动后才能通信。</p>
<p>　　ZigBee定义了<span class="math inline">\(20Kb/s\)</span>、<span
class="math inline">\(40Kb/s\)</span>、<span
class="math inline">\(100Kb/s\)</span>和<span
class="math inline">\(250Kb/s\)</span>的信道速率，具体取决于信道的频率。在ZigBee网络中，多个相对简化功能的设备在单个全功能设备的控制下运行，并且多个全功能设备还能够配置为一个网状网络，全功能设备在它们之间路由帧。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/802.15.4_super_frame_format.svg" class="">
<p>　　单个全功能设备使用信标帧以时隙方式控制多个简化功能的设备。ZigBee网络将时间划分为若干个超帧，每个超帧以信标帧开始。信标帧将超帧划分为活跃期(此期间内设备可以传输)和非活跃期(此期间内设备可以休眠来节能)。活跃期由16个时隙组成，其中部分由使用CSMA/CA随机接入方式的设备使用，其余部分由控制器分配特定的设备来给这些设备提供有保障的信道接入。</p>
<h3 id="蜂窝互联网接入">6.3 蜂窝互联网接入</h3>
<p>　　最早的几代蜂窝主要服务于语音流量。第1代(1G)是专为纯语音通信设计的模拟<strong>频分多址</strong>系统。最初的2G系统也是为语音而设计的，后来扩展了对数据(互联网)的支持(2.5G)。3G系统支持语音和数据，但更强调数据能力和更高速的无线接入链路。4G系统基于LTE，其特点是全IP核心网络并以<span
class="math inline">\(Mb/s\)</span>速率提供语音和数据服务。</p>
<p>　　2G蜂窝系统的GSM标准使用组合的FDM/TDM(无线)作为空中接口。对于组合FDM/TDM系统，若将信道划分为<span
class="math inline">\(F\)</span>个子信道且时间划分为<span
class="math inline">\(T\)</span>个时隙，则该信道能够支持<span
class="math inline">\(F\cdot
T\)</span>个并发呼叫。GSM系统由200kHz的频段组成，每个频段支持8个TDM呼叫。GSM以<span
class="math inline">\(13Kb/s\)</span>和<span
class="math inline">\(12.2Kb/s\)</span>编码语音。</p>
<p>　　单个GSM网络的<strong>基站控制器</strong>通常会为数十个BTS提供服务。BSC的作用是为移动设备分配BTS无线电信道，执行<strong>寻呼</strong>(查找移动设备所在的蜂窝)。基站控制器及其受控的BTS共同构成一个GSM<strong>基站系统</strong>。</p>
<p>　　<strong>移动交换中心</strong>在用户授权和计费、呼叫建立和断开以及切换中发挥着决定性作用。单个MSC通常最多包含5个BSC，因此每个MSC大约有20万用户。蜂窝提供商的网络有多个MSC，其中称为网关MSC的特殊的MSC将提供商的蜂窝网络连接到更大的公共电话网络。</p>
<p>　　<strong>通用分组无线服务</strong>是2G网络中的一种早期蜂窝数据服务，基于GSM的无线分组交换技术，提供端到端且广域的无线IP连接。</p>
<h4 id="g蜂窝网">6.3.1 3G蜂窝网</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/3g_network_architecture.svg" class="">
<p>　　相比2G，3G
UMTS不再使用GSM的FDMA/TDMA方案，而是在TDMA时隙内使用<strong>直接序列宽带码分多址</strong>，类似于DOCSIS。与WCDMA规范相关的数据服务称为<strong>高速分组接入</strong>。</p>
<p>　　3G核心蜂窝数据网络将无线接入网络连接到互联网。鉴于现有蜂窝语音网络存在大量现有基础设施，因此3G保持现有核心GSM蜂窝语音网络不变，同时添加额外的蜂窝数据功能到现有的蜂窝语音网络。</p>
<p>　　3G核心网络中有<strong>服务GRRS支持节点</strong>和<strong>网关GRPS支持节点</strong>这两种节点。SGSN负责向与其连接的无线接入网中的移动节点发送/接收数据报。SGSN与同一区域的蜂窝语音网络的MSC交互，提供用户授权和切换，维护活跃移动节点的蜂窝信息，并在无线接入网络中的移动节点和GGSN间转发数据报。GGSN充当网关，将多个SGSN连接到互联网。因此，GGSN是源自移动节点的数据报进入互联网之前经过的最后一个3G基础设施。对外界而言，GGSN无异于其他网关路由器。GGSN网络内3G节点的移动性对外隐藏。</p>
<p>　　3G<strong>无线接入网络</strong>是移动节点接触的无线首跳网络。<strong>无线网络控制器</strong>(又称为Node
B)通常控制多个蜂窝的BTS。每个蜂窝的移动节点和BTS之间通过无线链路连接。RNC通过MSC连接到连接到电路交换蜂窝语音网络，并通过SGSN连接到互联网。3G蜂窝语音服务和数据服务虽然使用不同的核心网络，但它们共享第一跳和最后一跳无线接入网络。</p>
<h4 id="g蜂窝网-1">6.3.2 4G蜂窝网</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/4g_network_architecture.svg" class="">
<p>　　相比3G，4G使用了<strong>全IP核心网络</strong>(语音和流量全都承载在IP数据报中)和增强的无线接入网络，而且4G对数据平面和控制平面进行了分离。</p>
<p>　　<strong>eNodeB</strong>是2G的基站和3G的RNC的逻辑后代。在控制平面中，eNodeB代表UE来处理注册和移动信令流量。在数据平面中，eNodeB负责在UE和P-GW之间转发数据报。UE数据报在eNodeB中封装并通过4G网络的全IP增强分组核以隧道形式传输到P-GW。eNodeB与P-GW之间的隧道类似于IPv6中IPv4迁移到IPv6的隧道，这些隧道可能具有相关的QOS保证。</p>
<p>　　<strong>分组数据网络网关</strong>为UE分配IP地址并保证QOS的执行。作为隧道端点，它负责封装和解封装发给UE和来自UE的数据报。</p>
<p>　　<strong>服务网关</strong>是数据平面移动锚点，即所有UE流量都将通过。S-GW还负责收费/计费以及合法的流量拦截。</p>
<p>　　<strong>归属用户服务器</strong>容纳包括漫游接入能力、QOS配置文件和认证信道的UE信息，它从UE归属蜂窝提供商获得这些信息。</p>
<p>　　<strong>移动性管理实体</strong>代表驻留在其控制的蜂窝中的UE执行连接和移动性管理，它从HHS接收UE订阅信息。</p>
<p>　　LTE在下行信道使用组合FDM/TDM，称为<strong>正交频分复用</strong>。在LTE中，每个活跃移动节点在若干个信道频率中被分配若干个0.5<span
class="math inline">\(ms\)</span>时隙。分配的时隙越多，移动节点能够获取的传输速率越高。移动节点之间的时隙(重)分配可以每1<span
class="math inline">\(ms\)</span>执行1次。</p>
<p>　　LTE标准没有规定分配移动节点特定的时隙。允许那些移动节点在特定频率上的给定时隙中进行传输由LET设备供应商或网络运营商提供的调度算法决定。使用机会调度，将物理层协议与发送端和接收端之间的信道条件相互匹配，并根据信道条件选择分组将发送到达接收端，使RNC能够充分利用无线链路。此外，用户的优先级和约定的服务级别可用于调度下行分组传输。高级LTE通过向移动节点分配聚合信道提供数百<span
class="math inline">\(Mb/s\)</span>的下行带宽。</p>
<p>　　另一种4G无线技术是使用802.16的WiMAX。</p>
<h3 id="移动管理">6.4 移动管理</h3>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/initial_elements_of_a_mobile_network_architecture.svg" class="">
<p>　　在网络环境中，1个移动节点的永久归属地称为<strong>归属网络</strong>。归属网络内代表移动节点执行移动管理的实体称为<strong>归属代理</strong>。移动节点当前所在的网络称为<strong>外部网络</strong>或<strong>被访网络</strong>，外部网络中帮助移动节点实现移动管理的实体称为<strong>外部代理</strong>。会话开始时移动节点所在外部网络的外部代理称为<strong>锚外部代理</strong>。将与移动节点通信的实体称为<strong>通信者</strong>。</p>
<p>　　当移动节点驻留在外部网络中时，所有发往该节点永久地址的流量需要路由到外部网络。为了实现这一点，一种方法是外部网络向所有其他网络通告移动节点驻留在其网络中，这通常可以通过交换域内和域间路由选择信息实现，而且只需要对现有路由选择基础设施进行少量改动即可。外部网络只需向它的邻居通告有1条特定的路由可以到达该移动节点的永久地址。类似于DV算法，作为更新路由选择信息和转发表的1个流程，这些邻居在整个网络传播此路由信息。当移动节点离开该外部网络并加入另一个外部网络是，新外部网络将通告1条通向该移动节点的新路由，而旧外部网络将撤销与该移动节点相关的路由选择信息。而实际中采用了另一种方法，将移动功能从网络核心转移到网络边缘，主要通过移动节点的归属网络来实现。</p>
<p>　　外部代理放置于外部网络的边缘路由器上，外部代理的作用之一是为移动节点创建1个所谓的<strong>转交地址</strong>，COA的网络部分与外部网络CIDR的网络部分相同。因此1个移动节点可与永久地址以及COA关联。外部代理的另一个作用是通知归属代理移动节点驻留在其网络中且具有给定的COA。移动节点可以(通过DHCP等协议)获取外部网络的COA并通知给归属代理。</p>
<h4 id="移动节点的间接路由选择">6.4.1 移动节点的间接路由选择</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/indirect_routing_to_a_mobile_node.svg" class="">
<p>　　在<strong>间接路由选择</strong>中，通信者是将数据报寻址到移动节点的永久地址并将数据报发送到网络中，但并不知道移动节点是驻留在归属网络还是外部网络。这些数据报首先路由到移动节点的归属网络。归属代理收到数据报后将其转发给外部代理，然后外部代理在转发给移动节点。若移动节点需要发送数据报给通信者，可以直接发送给通信者。</p>
<p>　　为了确保通信者发送的数据报的完好无损以及对移动节点隐藏数据报经过了归属代理的转发，可以建立类似于IPv4迁移到IPv6的隧道，即归属代理将通信者的数据报再次封装。归属代理将移动节点的COA作为封装后的数据报的目的IP地址来将数据报路由到外部网络。外部代理收到封装的数据报后拆封再将原始数据报转发给移动节点。</p>
<p>　　间接路由选择需要<span
style="background-color: yellow">移动节点到外部代理的协议</span>、<span
style="background-color: yellow">外部代理到归属代理的注册协议</span>、<span
style="background-color: yellow">归属代理数据报封装协议</span>以及<span
style="background-color: yellow">外部代理拆封协议</span>这些网络层新功能。当移动节点连接到外部网络时需要向外部代理注册，离开时也需要注销。此外，外部代理将向归属代理注册移动节点的COA，当移动节点离开网络不需要显式注销COA，因为移动节点再次连接新网络时，新COA的注册会完成注销。</p>
<p>　　间接路由选择存在<strong>三角路由选择</strong>问题，即发往移动节点的数据报需要先发送到归属代理再发送到外部网络。最坏的情况是移动节点与通信者在同一外部网络，但数据报还是需要先发往归属代理再回到该外部网络。</p>
<h4 id="移动节点的直接路由选择">6.4.2 移动节点的直接路由选择</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/direct_routing_to_a_mobile_node.svg" class="">
<p>　　<strong>直接路由选择</strong>解决了三角路由选择问题，但是在通信者所在的网络中加入了<strong>通信者代理</strong>，通信者代理需要先获取移动节点COA，这可以通过向归属代理查询来完成。通信者代理通过隧道将数据报发送移动节点的COA，外部代理收到数据报后再拆封并转发给移动节点。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/mobile_transfer_between_networks_with_direct_routing.svg" class="">
<p>　　直接路由选择需要<span
style="background-color: yellow">移动节点定位协议</span>来查询归属代理并获得移动节点的COA。通信者代理仅在会话开始时查询归属并代理获得移动节点的COA，这样会导致会话过程中数据无法在移动节点切换外部网络后路由选择到新外部网络。一种解决方法是创建1个协议来告知通信者切换网络后的COA，GSM实践中采用了另一种方法，当移动节点移动到另一个外部网络后，移动节点向新的外部代理注册，新的外部代理再向锚外部代理提供移动节点新COA。当锚外部代理收到发往已离开该外部网络的移动节点的数据报后，它使用新COA再次封装数据报并转发给移动节点。若移动节点再次移动到另一个外部网络，则新外部代理将联系锚外部代理提供新COA。</p>
<h3 id="移动ip">6.5 移动IP</h3>
<p>　　移动IP标准由<strong>代理发现</strong>、<strong>向归属代理注册</strong>、<strong>数据报的间接路由选择</strong>组成。</p>
<p>　　加入新网络(外部网络或归属网络)的移动节点，它都必须知道相应的外部代理或归属代理的身份。实际上，正是具有新IP地址的的外部代理才允许移动节点的网络层知道自身已进入新的外部网络，称为<strong>代理发现</strong>。代理发现可以通过<strong>代理通告</strong>或<strong>代理请求</strong>实现。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/icmp_router_discovery_message_with_mobility_agent_advertisement_extension.svg" class="">
<p>　　借助代理通告，外部代理或归属代理使用扩展ICMP路由器发现报文来通告其服务。外部代理或归属代理周期性地在所有连接的链路上广播ICMP报文(type=9)。</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 18%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr>
<th>字段名称</th>
<th>字段长度(单位是<span class="math inline">\(b\)</span>)</th>
<th>字段描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Router IP address</td>
<td>32</td>
<td>发送该报文的代理的IP地址</td>
</tr>
<tr>
<td>type</td>
<td>8</td>
<td>值固定为16</td>
</tr>
<tr>
<td>length</td>
<td>8</td>
<td>值为6+4N，N表示COA的个数</td>
</tr>
<tr>
<td>sequence number</td>
<td>16</td>
<td>代理启动后的第1个通告序列号必须是0，之后每次加1，但0xFFFF之后必须是256，这样可以区分序列号减小是由于重启还是达到序列号最大值</td>
</tr>
<tr>
<td>registration lifetime</td>
<td>16</td>
<td>注册的最大生命周期(以秒为单位)，0xFFFF表示无穷大</td>
</tr>
<tr>
<td>registration required(R)</td>
<td>1</td>
<td>此网络中的移动节点必须向外部代理注册。若移动节点无法(使用DHCP)在外部网络中获取COA且无法承担自身外部代理的功能，则无需向外地代理注册</td>
</tr>
<tr>
<td>busy(B)</td>
<td>1</td>
<td>代理不再接受新移动节点的注册</td>
</tr>
<tr>
<td>home agent(H)</td>
<td>1</td>
<td>代理为它所在网络的归属代理</td>
</tr>
<tr>
<td>foreign agent(F)</td>
<td>1</td>
<td>代理为它所在网络的外部代理</td>
</tr>
<tr>
<td>minimal encapsulation(M)</td>
<td>1</td>
<td>隧道支持最小封装</td>
</tr>
<tr>
<td>GRE encapsulation(G)</td>
<td>1</td>
<td>隧道支持GRE</td>
</tr>
<tr>
<td>reserved(r)</td>
<td>1</td>
<td>值固定为0</td>
</tr>
<tr>
<td>reverse tunneling(T)</td>
<td>1</td>
<td>支持反向隧道</td>
</tr>
<tr>
<td>U</td>
<td>1</td>
<td>支持UDP</td>
</tr>
<tr>
<td>X</td>
<td>1</td>
<td>支持撤销注册</td>
</tr>
<tr>
<td>I</td>
<td>1</td>
<td>支持区域注册</td>
</tr>
<tr>
<td>COA address</td>
<td>32N</td>
<td>外部代理提供COA列表，移动节点选择1个作为其COA</td>
</tr>
</tbody>
</table>
<p>　　移动节点可以通过代理请求直接广播ICMP报文(type=10)，收到该报文的代理将<span
style="background-color: yellow">单播</span>1个代理通告。</p>
<p>　　一旦移动节点收到COA，则必须向归属代理注册该地址，这可以通过外部代理(外部代理向归属代理注册该地址)或直接自行注册，这里考虑前者。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/agent_advertisement_and_mobile_ip_registration.svg" class="">
<p>　　1)
当收到代理通告后，移动节点向外部代理发送移动代理注册报文。注册报文由UDP数据报承载并发送到434端口，包括选择的COA、归属代理的IP地址、移动节点的永久IP地址、请求注册的生命周期以及1个64位的注册标识。</p>
<p>　　2)
外部代理收到注册报文后记录移动节点的永久IP地址，将注册请求报文再封装并以隧道的形式发送给归属代理，报文同样由UDP数据报承载并发送到434端口。</p>
<p>　　3)
归属代理收到注册请求并检测其真实性和正确性。归属代理将移动节点永久IP地址和COA绑定，然后将注册响应再封装并以隧道的形式发送给外部代理，报文中包括归属代理的IP地址、移动节点的永久IP地址、实际注册生命周期以及请求的注册标识。</p>
<p>　　4) 外部代理收到再封装的注册响应后拆封并转发给移动节点。</p>
<h3 id="蜂窝网络中的移动性">6.6 蜂窝网络中的移动性</h3>
<p>　　在GSM中移动设备的归属网络称为该移动设备的<strong>归属公共陆地移动网络</strong>，这里简称为<strong>归属网络</strong>，而移动设备当前所在的PLMN简称为<strong>被访网络</strong>。</p>
<p>　　归属网络维护1个称为<strong>归属位置寄存器</strong>的数据库，其中包含该网络中每个移动设备的永久手机号码和概要信息以及用户当前位置的信息，因此当移动设备漫游到另一个提供商的蜂窝网络中，HLR中包含足够的信息来获取移动设备被呼叫时应该路由选择到的被访网络的的IP地址。当移动设备被呼叫时，通信者会联系归属网络中1个称为<strong>网关移动交换中心</strong>的交换机，这里简称为<strong>归属MSC</strong>。</p>
<p>　　被访网络维护1个称为<strong>访问者位置寄存器</strong>的数据库，其中包含该网络中每个移动设备的表项，VLR表项因此随着移动设备加入或退出网络而新增或删除。VLR通常与MSC位于同一位置，MSC协调到达或离开被访网络的呼叫建立。</p>
<p>　　在实际中，提供商的蜂窝网络作为其用户的归属网络以及其他提供商的蜂窝网络的用户的被访网络。</p>
<h4 id="移动设备呼叫的路由选择">6.6.1 移动设备呼叫的路由选择</h4>
<p>　　当移动设备切换或进入新VLR覆盖的被访网络时，必须和VLR交换信令报文来向被访网络注册。被访网络的VLR再向移动设备的HLR发送位置更新请求报文来告知HLR可用于联系移动设备的<strong>移动站点漫游号</strong>(简称为<strong>漫游号</strong>)或VLR地址，VLR从HLR获取移动设备的信息并确定被访网络应向移动设备提供对应的服务(如果有)。MSRN的功能类似于COA，对通信者和移动设备都隐藏。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/place_a_call_to_a_mobile_user_with_indirect_routing.svg" class="">
<p>　　与移动IP一样，GSM采用了间接路由选择，先将通信者的呼叫路由选择到移动节点的归属网络，再到被访网络。</p>
<p>　　1)
通信者拨打移动设备的电话号码。呼叫通过<strong>公共交换电话网络</strong>到达移动设备的归属MSC。</p>
<p>　　2)
归属MSC收到呼叫后查询HLR来确定移动设备的位置。在最简单的情况下，HLR返回MSRN。若HLR中没有MSRN则返回VLR在被访网络中的地址。</p>
<p>　　3)
归属MSC获得MSRN后，通过PSTN到达被访网络的MSC建立第2段呼叫来完成呼叫。</p>
<h4 id="gsm中的切换">6.6.2 GSM中的切换</h4>
<p>　　呼叫过程中的切换不仅导致移动设备关联新基站，而且导致呼叫从网络中的交换点重新路由选择到新基站。</p>
<p>　　在与基站关联时，移动设备会定期测量关联基站的信标信号强度与其他基站的信标信号强度，结果以每秒1或2次的频率报告给关联基站，关联基站根据测量结果、附近蜂窝的移动设备负载以及其他因素来切换。GSM标准中没有规定执行切换的具体算法。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_06/handoff_between_base_stations_with_a_common_msc.svg" class="">
<p>　　1) 旧BS通知被访MSC移动设备将执行切换和切换后的BS(组)。</p>
<p>　　2)
被访MSC发起到新BS的路径建立，分配承载重新路由选择的呼叫所需的资源以及用信令告知新BS切换即将发生。</p>
<p>　　3) 新BS分配并激活1个无线信道供移动设备使用。</p>
<p>　　4)
新BS向被访MSC和旧BS发送信令通知已建立被访MSC到新BS路径并且应该通知移动设备即将发生的切换。新BS提供移动设备与新BS关联所需的所有信息。</p>
<p>　　5)
移动设备被告知它应该执行切换。之前移动设备并不知道网络以及为切换做好所有底层工作。</p>
<p>　　6) 移动设备和新BS交换若干个报文来完全激活新BS中的信道。</p>
<p>　　7)
移动设备向新BS发送1个切换完成报文，然后该报文被转发到被访MSC。被访MSC通过新BS将正在进行的呼叫重新路由到移动设备。</p>
<p>　　8) 到旧BS的路径分配的资源随后释放。</p>
<p>　　GSM中定义了类似于锚外部代理的<strong>锚MSC</strong>，锚MSC是呼叫开始时移动设备的被访MSC，它在整个呼叫持续过程中保持不变。无论移动设备在呼叫的过程中转移多少次，呼叫都是从归属MSC路由选择到锚MSC再到移动设备当前的被访MSC，因此，通信者和移动设备间最多有3个MSC。除了保持锚MSC到当前被访MSC的单MSC跳，另一种方法是直接将移动设备被访MSC链接起来(出现在IS-41蜂窝网络中)，每当移动设备移动到新MSC后，让旧MSC将呼叫转发给新MSC。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第2章 应用层</title>
    <url>/network/computer_networking_a_top_down_approach_7e_chpt_02/</url>
    <content><![CDATA[<p>　　<strong>套接字</strong>是应用程序进程和传输层协议之间的接口。一个进程可以有多个套接字。</p>
<p>　　应用程序开发者可以通过套接字控制应用层的一切，但是对传输层的控制仅限于选择协议和设定几个传输层参数。应用程序体系结构通常使用客户端/服务器体系结构和对等体系结构。</p>
<p>　　当进程向另一台主机的进程发送分组时需要定义目的主机的地址和目的主机中接收进程的标识符。</p>
<p>　　传输层为应用层提供的服务可分为四类：<span
style="background-color: yellow">可靠数据传输</span>、<span
style="background-color: yellow">吞吐量</span>、<span
style="background-color: yellow">定时</span>和<span
style="background-color: yellow">安全性</span>。</p>
<p>　　<strong>带宽敏感的应用</strong>具有吞吐量要求，而<strong>弹性应用</strong>能够根据可用的带宽尽可能多或少地使用。</p>
<p>　　<strong>应用层协议</strong>定义了运行在不同端系统上的应用程序进程如何相互传递报文：</p>
<p>　　● 交互的报文类型。</p>
<p>　　● 各种报文类型的语法。</p>
<p>　　● 字段的语义。</p>
<p>　　● 确定一个进程何时以及如何发送报文，对报文的响应规则。</p>
<p>　　Web的应用层协议是<strong>HTTP</strong>。</p>
<p>　　一张未压缩/数字编码的图像有像素阵列组成，每个像素由一些比特编码来表示亮度或颜色。</p>
<p>　　视频是一系列图像以每秒24或30张图像来展现。视频能被压缩，故可以比特率来权衡视频质量。</p>
<p>　　在<strong>HTTP动态自适应流</strong>中，视频编码为比特率不同的多个版本，每个版本都有一个不同的URL，每个版本的URL和比特率都存在HTTP服务器中的<strong>告示文件</strong>中。DASH运行客户端自由地切换版本。</p>
<span id="more"></span>
<h3 id="http">2.1 HTTP</h3>
<p>　　HTTP服务器不保存关于客户端的任何信息，故HTTP是一个<strong>无状态协议</strong>。为了识别客户端，HTTP使用了cookie。</p>
<p>　　<strong>持续连接</strong>指一个TCP可以传输多个HTTP请求和响应。<strong>非持续连接</strong>指一个TCP只能传输一个HTTP请求/响应对。HTTP默认使用持续连接，但也能配置为非持续连接。</p>
<p>　　<strong>Web缓存器</strong>，也称为<strong>代理服务器</strong>，能够代表Web服务器来满足HTTP请求的网络实体。</p>
<p>　　HTTP的<strong>条件GET</strong>机制可以解决Web缓存器缓存的数据陈旧的问题。</p>
<p>　　HTTP主要是一个<strong>拉协议</strong>，TCP连接是由接收端发起。</p>
<h4 id="http请求报文">2.1.1 HTTP请求报文</h4>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/somedir/page.html</span> <span class="meta">HTTP/2</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.test.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure>
<p>　　HTTP请求报文的第一行是<strong>请求行</strong>。请求行包括方法字段、URL字段和HTTP版本字段。</p>
<p>　　HTTP请求报文第一行之后的行是<strong>首部行</strong>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_02/http_request_message_format.svg" class="">
<h4 id="http响应报文">2.1.2 HTTP响应报文</h4>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/2</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">content-type</span><span class="punctuation">: </span>text/javascript; charset=utf-8</span><br><span class="line"><span class="attribute">content-encoding</span><span class="punctuation">: </span>br</span><br><span class="line"><span class="attribute">last-modified</span><span class="punctuation">: </span>Wed, 03 Nov 2021 01:12:45 GMT</span><br><span class="line"><span class="attribute">server</span><span class="punctuation">: </span>Windows-Azure-Blob/1.0 Microsoft-HTTPAPI/2.0</span><br></pre></td></tr></table></figure>
<p>　　HTTP响应报文的第一行是<strong>状态行</strong>。状态行包括协议版本字段、状态码字段和相应状态字段。</p>
<p>　　HTTP响应报文第一行之后的行是<strong>首部行</strong>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_02/http_response_message_format.svg" class="">
<h4 id="条件get">2.1.3 条件GET</h4>
<p>　　如果请求报文是GET方法且请求报文的首部行包括<code>If-modified-since</code>，该请求报文就是<strong>条件GET</strong>请求报文。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_02/conditional_get.svg" class="">
<p>　　第三步中<code>If-modified-since</code>的值等于第二步中<code>last-modified</code>的值，这表示Web服务器仅当指定日期之后该对象修改后才发送该对象，若该对象在指定日期后没被修改，则第四步中Web服务器向Web缓存器发送的响应报文中状态码为304且没有对象，表示Web缓存器可以转发缓存的该对象的副本。</p>
<h3 id="电子邮件">2.2 电子邮件</h3>
<p>　　互联网电子邮件系统由<strong>用户代理</strong>、<strong>邮件服务器</strong>和<strong>简单邮件传输协议</strong>组成。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_02/email_protocols_and_their_communicating_entities.svg" class="">
<p>　　1) 发件方调用用户代理撰写内容并发送邮件。</p>
<p>　　2)
发件方的用户代理把报文发给发件方的邮件服务器，在这里报文被放在报文队列里。</p>
<p>　　3)
发件方邮件服务器上的SMTP客户端创建一个到收件方邮件服务器上的SMTP服务器的TCP连接。</p>
<p>　　4) 经过初始SMTP握手后，SMTP客户端通过TCP连接发送报文。</p>
<p>　　5)
收件方邮件服务器的SMTP服务器接收到报文并将报文投入到收件方的邮箱。</p>
<p>　　6) 收件方调用用户代理查看邮件。</p>
<h4 id="smtp">2.2.1 SMTP</h4>
<p>　　SMTP是互联网电子邮件中主要的应用层协议。它限制了邮件的报文(不只是首部)只能采用7位ASCII表示，若报文包含非7位ASCII字符或二进制数据，需要进行7位ASCII编码。</p>
<p>　　SMTP是<strong>推协议</strong>，TCP连接是发送端发起的。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">S: 220 client</span><br><span class="line">C: EHLO server</span><br><span class="line">S: 250 from | 250 PIPELINING | 250 SIZE 12345</span><br><span class="line">C: AUTH XOAUTH2 oauth</span><br><span class="line">S: 235 2.7.0 Accepted</span><br><span class="line">C: MAIL FROM: &lt;client@email.com&gt; </span><br><span class="line">S: 250 OK</span><br><span class="line">C: RCPT TO: &lt;server@email.com&gt;</span><br><span class="line">S: 250 OK</span><br><span class="line">C: DATA</span><br><span class="line">S: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">C: DATA fragment,content</span><br><span class="line">S: 250 OK: queued as.</span><br><span class="line">C: QUIT</span><br><span class="line">S: 221 Bye</span><br></pre></td></tr></table></figure>
<p>　　SMTP协议中客户端发送了5条命令：<code>HELO</code>/<code>EHLO</code>(HELLO缩写，ESMTP版本)、<code>MAIL FROM</code>、<code>RCPT TO</code>、<code>DATA</code>以及<code>QUIT</code>。</p>
<p>　　ESMTP相比SMTP，在发送邮件时<span
style="background-color: yellow">需要验证用户账户</span>。</p>
<h4 id="电子邮件-1">2.2.2 电子邮件</h4>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">From: from@email.com</span><br><span class="line">To: to@email.com</span><br><span class="line">Subject: subject</span><br></pre></td></tr></table></figure>
<p>　　邮件报文的首部行包括环境信息，必须包含一个<code>From</code>和一个<code>To</code>，可能包含<code>Subject</code>以及其他可选首部行。</p>
<p>　　在用户代理建立一个到邮件服务器110端口上的TCP连接后，POP3按照3个阶段进行工作：授权、事务处理以及更新。</p>
<p>　　●
授权阶段需要用户代理以明文形式发送用户名和密码来认证，主要命令有<code>user &lt;username&gt;</code>和<code>pass &lt;password&gt;</code>。</p>
<p>　　●
事务处理阶段中用户代理可以取回报文，也可以添加/取消报文删除标记，主要命令有<code>list</code>、<code>retr</code>和<code>dele</code>。</p>
<p>　　●
更新阶段在用户代理发出<code>quit</code>命令并结束会话后，邮件服务器会删除那些被标记的报文。</p>
<p>　　POP3会话期间，邮件服务器会保留一些状态信息，但是在会话中不会携带这些信息。</p>
<p>　　IMAP使用了TCP连接的143端口。相比POP3，IMAP把报文和文件夹联系起来并且提供了创建/修改/删除文件夹和获取报文某些部分的命令。</p>
<h3 id="dns">2.3 DNS</h3>
<p>　　主机可以用<strong>主机名</strong>和<strong>IP地址</strong>来进行识别。</p>
<p>　　一台名为a.com的主机，可能还有别名b.com和c.com，此时a.com是<strong>规范主机名</strong>。</p>
<p>　　<strong>域名系统</strong>是一个由分层的<strong>DNS服务器</strong>实现的分布式数据库，一个让主机查询分布式数据库的应用层协议。主要用于将主机名解析为IP地址，也提供<strong>主机别名</strong>、<strong>邮件服务器别名</strong>和<strong>负载分配</strong>服务。</p>
<h4 id="dns工作原理">2.3.1 DNS工作原理</h4>
<p>　　DNS服务器主要分为<strong>根DNS服务器</strong>、<strong>顶级域DNS服务器</strong>、<strong>权威DNS服务器</strong>和<strong>本地DNS服务器</strong>。</p>
<p>　　● 根DNS服务器提供顶级域DNS服务器的IP地址。</p>
<p>　　●
每个顶级域<sup>【如com、org、net、edu和gov等】</sup>和国家的顶级域<sup>【如uk、fr、ca和cn等】</sup>都有顶级域DNS服务器(集群)。顶级域DNS服务器提供权威DNS服务器的IP地址。</p>
<p>　　●
互联网上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名称映射为IP地址。</p>
<p>　　● 每个ISP都有一个本地DNS服务器/默认名称服务器。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_02/interaction_of_the_various_dns_servsers.svg" class="">
<p>　　一般情况下，从请求主机到本地DNS服务器的查询是<strong>递归查询</strong>，其余的查询是<strong>迭代查询</strong>。</p>
<p>　　为了降低时延并减少报文数量，<strong>DNS缓存</strong>广泛使用，因此在大部分DNS查询中根DNS服务器都被绕过。</p>
<h4 id="dns报文">2.3.2 DNS报文</h4>
<p>　　<strong>资源记录</strong>提供了主机名到IP地址的映射，格式为<code>(Name, Value, Type, TTL)</code>。</p>
<p>　　●
<code>Type = A</code>时，<code>Name</code>是主机名，<code>Value</code>是主机名对应的IP地址。</p>
<p>　　●
<code>Type = NS</code>时，<code>Name</code>是域名，<code>Value</code>是能够获取该域名中主机IP地址的权威DNS服务器的主机名。</p>
<p>　　●
<code>Type = CNAME</code>时，<code>Value</code>是别名为<code>Name</code>的主机的规范主机名。</p>
<p>　　●
<code>Type = MX</code>时，<code>Value</code>是别名为<code>Name</code>的邮件服务器的规范主机名。</p>
<p>　　对于某个主机名，若DNS服务器是它的权威DNS服务器，则该DNS服务器会有一条包含该主机名的A型记录。若DNS服务器不是它的权威服务器，则该DNS服务器会有一条该主机名所属域名的NS型记录和一条包含该NS型记录中<code>Value</code>的A型记录，还可能会有一条包含该主机名的A型记录。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_02/dns_message_format.svg" class="">
<p>　　DNS报文分为查询和应答报文，报文格式相同。</p>
<p>　　●
在首部区域，第一个字段占16位，用于标识该查询，该字段会被复制到应答报文中来匹配请求。第二个字段有若干1位的标志位。0/1标识查询/应答报文。若请求的是权威DNS服务器则应答报文会设置权威标志位。若客户端在DNS服务器没有资源记录时希望它执行递归查询则会设置希望递归标志位。若DNS服务器支持递归查询则会在应答报文设置递归可用标志位。剩下四个字段表示后四个区域数据的数量。</p>
<p>　　●
问题区域包名称字段和类型字段，名称字段是待查询的主机名称，类型字段对应资源记录中的类型字段。</p>
<p>　　● 应答区域可以包含多条资源记录。</p>
<p>　　● 权威区域包含其他权威DNS服务器的资源记录。</p>
<p>　　● 附加信息区域包含其他有用的资源记录。</p>
<h3 id="p2p文件分发">2.4 P2P文件分发</h3>
<p>　　<strong>分发时间</strong>是所有<span
class="math inline">\(n\)</span>个对等方得到<span
class="math inline">\(f(b)\)</span>文件的副本所需时间。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_02/file_distribution.svg" class="">
<p>　　<span
class="math inline">\(D_{cs}\)</span>表示C/S体系结构的分发时间，其中服务器需要上传<span
class="math inline">\(n\)</span>个大小为<span
class="math inline">\(f(b)\)</span>文件的副本，<span
class="math inline">\(D_c\)</span>表示客户端下载所需时间，<span
class="math inline">\(d_{min}\)</span>表示客户端最低下载速度，<span
class="math inline">\(D_S\)</span>表示服务器上传所需时间，<span
class="math inline">\(u_s\)</span>表示服务器的上传速度，则 <span
class="math display">\[
\begin{align}
D_{cs}&amp;\geqslant max\{D_c,D_s\}\\[3px]
&amp;\geqslant max\{\frac{f}{d_{min}},\frac{nf}{u_s}\}
\end{align}
\]</span> 　　<span
class="math inline">\(D_{P2P}\)</span>表示P2P体系结构的分发时间，分发开始时只有服务器有文件，分发一次后可由对等方来分发，则
<span class="math display">\[
\begin{align}
D_{P2P}&amp;\geqslant max\{D_c,D_s,\frac{nf}{u_{total}}\}\\[3px]
&amp;\geqslant
max\{\frac{f}{d_{min}},\frac{f}{u_s},\frac{nf}{u_s+\sum_{i=1}^{n}u_i}\}
\end{align}
\]</span></p>
<p>　　参与文件分发的所有对等方集合称为<strong>洪流</strong>。洪流中的对等方彼此下载固定大小的文件块，通常是<span
class="math inline">\(256KB\)</span>。每个洪流具有一个基础设施节点，称为<strong>追踪器</strong>。当有对等方加入洪流时需要向追踪器注册并周期性地通知是否在洪流中。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_02/file_distribution_with_bittorrent.svg" class="">
<p>　　与对等方建立TCP连接的其他对等方称为该对等方的<strong>邻居/邻近对等方</strong>。</p>
<p>　　<strong>最稀缺优先</strong>即优先请求本身没有且邻居中副本最少的块，这样可以大致地均衡每个块在洪流中的副本量。</p>
<p>　　对等方优先响应那些当前能够以<span
style="background-color: yellow">最高速率</span>提供副本的邻居。对等方会每十秒进行速率测量并确定速率前四的邻居，这四个邻居会被<strong>疏通</strong>。此外，每三十秒会随机再选择一个邻居进行交换，如果彼此都能满足，则继续交换。除了这五个邻居，其他邻居将被阻塞，即无法从该对等方获取块。这种机制被称为<strong>一报还一报</strong>。</p>
<h3 id="cdn">2.5 CDN</h3>
<p>　　<strong>内容分发网络</strong>分布在多个地理位置的服务器上，并且将用户请求重定向到一个时延更低的CDN。</p>
<p>　　CDN分为<strong>专用CDN</strong>和<strong>第三方CDN</strong>，专用CDN由内容提供商自身拥有，第三方CDN分发多个内容提供商的内容。</p>
<p>　　CDN通常采用<strong>深入</strong>和<strong>客邀</strong>这两种安置原则。</p>
<p>　　●
深入原则由Akamai首创，该原则通过在遍及全球的接入ISP中部署服务器集群来深入到ISP的接入网中。其目标是靠近端系统，通过减少端系统和CDN集群之间的链路和路由器来减少时延和提供吞吐量，但也带来了较高的维护管理成本。</p>
<p>　　●
客邀原则被Limelight和很多其他CDN公司采用，该原则通过在少量的关键位置(通常是互联网交换点)建立大量集群来客邀ISP。相比深入，客邀的维护管理成本更低，但时延较高且吞吐量较低。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_02/dns_redirects_a_request_to_a_cdn_server.svg" class="">
<p>　　大多数CDN利用DNS来截获和重定向请求。</p>
<p>　　1) 客户端访问某Web网页。</p>
<p>　　2) 客户端访问该Web下的某个资源时，发送了对应的DNS请求。</p>
<p>　　3)
本地DNS服务器将DNS请求中继到该Web的权威DNS服务器，权威DNS服务器返回了CDN域下的主机名。</p>
<p>　　4)
本地DNS服务器通过CDN域下的主机名向CDN权威DNS服务器发送DNS请求，CDN权威DNS服务器返回了CDN服务器的IP地址。</p>
<p>　　5) 本地DNS服务器将IP地址返回给客户端。</p>
<p>　　6) 客户端通过IP地址与CDN服务器建立TCP连接并发送HTTP请求。</p>
<p>　　CDN部署的核心都是<strong>集群选择策略</strong>，即动态地将请求重定向到CDN中的某个服务器集群/数据中心。</p>
<p>　　较简单的选择策略是将请求重定向到(距离DNS服务器)<span
style="background-color: yellow">地理上最近</span>的集群。另一种选择策略是对DNS服务器和集群之间进行周期性的时延以及丢包<span
style="background-color: yellow">实时测量</span>来选择。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第3章 传输层</title>
    <url>/network/computer_networking_a_top_down_approach_7e_chpt_03/</url>
    <content><![CDATA[<p>　　网络层提供了主机之间的逻辑通信，传输层提供不同主机的进程之间的逻辑通信。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/transport_layer_multiplexing_and_demultiplexing.svg" class="">
<p>　　传输层的<strong>多路复用</strong>与<strong>多路分解</strong>指将主机间交付延伸到进程间交付。</p>
<p>　　●
多路复用指在不同套接字中收集数据块，为每个数据块附加首部信息并封装从而生成报文段，再将报文段传递到网络层。</p>
<p>　　● 多路分解指将传输层报文段解封并提取数据交付到正确的套接字。</p>
<p>　　多路复用需要<strong>源端口号字段</strong>(套接字的唯一标识符)和<strong>目的端口号字段</strong>(报文段中标识目标套接字的字段)。</p>
<p>　　端口号的长度是16位。0~1023之间的端口称为<strong>周知端口号</strong>。</p>
<p>　　<strong>序号</strong>用于为从发送端发往接收端的分组按序编号。</p>
<p>　　<strong>校验和</strong>用于分组的差错检测。</p>
<span id="more"></span>
<h3 id="udp">3.1 UDP</h3>
<p>　　UDP在发送报文段前传输层实体间没有握手，故UDP是<span
style="background-color: yellow">无连接</span>的。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/udp_segment_format.svg" class="">
<p>　　UDP首部包括16位<strong>源端口</strong>、16位<strong>目的端口</strong>、16位<strong>长度</strong>和16位<strong>校验和</strong>。</p>
<p>　　● 长度字段即报文段中的字节数(首部+有效载荷)。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/checksum_of_udp.svg" class="">
<p>　　发送端在计算校验和时需要先加上伪首部并将校验和字段置0，将伪首部、首部和有效载荷转换成16位二进制(不足部分填充0)并求和，求和时需要回卷(如果进位到第17位则将结果加1)，将和取反得到校验和，最后发送端设置校验和并去掉伪首部。接收端计算校验和方式类似于发送端(不需要将校验和置0)，最后结果全为1则说明数据无误，否则警告。伪首部包括源IP地址、目的IP地址、填充0的保留字段、传输层协议号以及报文长度。</p>
<p>　　由于无法确保链路的可靠和内存中的差错检测，UDP在端到端基础上的传输层进行差错检测，这种设计被称为<strong>端到端原则</strong>，即同一功能的实现成本在底层相比上层可能更高。</p>
<h3 id="可靠数据传输">3.2 可靠数据传输</h3>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/reliable_data_transfer.svg" class="">
<h4 id="rdt1.0">3.2.1 rdt1.0</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/fsm_of_rdt1.0.svg" class="">
<p>　　rdt1.0协议指经完全可靠信道的可靠数据传输，故接收端不需要提供任何反馈信息给发送端。此外，该协议的数据单元与分组无异，所有分组都是发送端到接收端。</p>
<p>　　FSM的初始状态用虚线表示。发送端和接收端的FSM都只有一个状态，故变迁必定是从一个状态返回到本身。</p>
<p>　　发送端只通过<code>rdt_send(data)</code>从上层接收数据，经由<code>make_pkt(data)</code>产生一个包含该数据的分组，并将分组发送到信道中。接收端通过<code>rdt_rcv(packet)</code>从底层信道接收一个分组，经由<code>extract(packet,data)</code>取出数据，并通过<code>deliver_data(data)</code>将数据传输给上层。</p>
<h4 id="rdt2.0">3.2.2 rdt2.0</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/fsm_of_rdt2.0.svg" class="">
<p>　　rdt2.0相比rdt1.0，加入了差错检测和<strong>肯定/否定确认</strong>。肯定/否定确认用于让发送端知道分组被正确接收或接收有误需要重传，因此rdt2.0称为<strong>自动重传请求</strong>协议。自动重传请求协议还需要<span
style="background-color: yellow">差错检测</span>、<span
style="background-color: yellow">接收端反馈</span>(用1位来表示，0是NAK，1是ACK)和<span
style="background-color: yellow">重传</span>来处理比特差错的情况。</p>
<p>　　当发送端等待ACK/NCK时不能从上层获取数据或发送分组，故rdt2.0称为<strong>停等</strong>协议。</p>
<p>　　发送端有两个状态。在左边的状态中，发送端正在等待上层调用。当出现<code>rdt_send(data)</code>时，发送端将通过<code>make_pkt(data,checksum)</code>产生一个包含数据和校验和的分组，经由<code>udt_send(sndpkt)</code>发送该分组。在右边的状态中，发送端正在等待接收端回传的ACK/NAK。若收到ACK分组，即<code>rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)</code>，发送端会回到等待上层调用的状态。若收到NAK分组，即<code>rdt_rcv(rcvpkt) &amp;&amp; isNAK(rcvpkt)</code>，发送端会重传分组并等待接收回传的ACK/NAK。</p>
<p>　　接收端只有一个状态。当分组到达时，接收端回传ACK/NAK，即<code>rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt)</code>或<code>rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt)</code>。</p>
<p>　　但是rdt2.0忽视了ACK/NAK分组受损的情况，解决这一问题的简单方法就是添加一个新字段来表示发送数据分组的序号。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/fsm_of_rdt2.1.svg" class="">
<p>　　rdt2.1是rdt2.0的修订版，rdt2.1的发送端和接收端FSM的状态数都是以前的两倍，因为需要反映出目前分组的序号。rdt2.1使用了接收端到发送端的ACK/NAK。当收到乱序的分组时，接收端回传ACK。当收到受损的分组时，接收端回传NAK。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/fsm_of_rdt2.2.svg" class="">
<p>　　rdt2.2相比rdt2.1，rdt2.2无NAK，而是对上一次正确接收的分组回传ACK。发送端收<strong>冗余ACK</strong>后，就知道了接收端没有正确接收到冗余ACK对应的分组后的分组。因此，ACK报文需要一个序号字段。</p>
<h4 id="rdt3.0">3.2.3 rdt3.0</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/fsm_of_rdt3.0_sender.svg" class="">
<p>　　rdt3.0是用于具有比特差错的丢包信道的协议。通过在发送端中加入<strong>倒数计时器</strong>来解决超时/丢包问题，接收端与rdt2.2相同。</p>
<p>　　因为分组序号在0和1之间交替，rdt3.0也被称为<strong>比特交替协议</strong>。</p>
<h4 id="流水线可靠数据传输协议">3.2.4 流水线可靠数据传输协议</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/stop-and-wait_and_pipelined_sending.svg" class="">
<p>　　停等协议存在一定的性能问题，简单的解决方式就是不使用停等，允许发送方发送多个分组而无须等待。因为许多从发送端到接收端的分组可以被看出是填充到一条流水线，故这种技术被称为<strong>流水线</strong>。</p>
<p>　　流水线需要可靠数据传输协议增加序号的范围和发送/接收端缓存分组，而这些取决于差错恢复。流水线的差错恢复包括<strong>回退N步</strong>和<strong>选择重传</strong>。</p>
<h4 id="回退n步">3.2.5 回退N步</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/sender_view_of_sequence_numbers_in_gbn.svg" class="">
<p>　　随着协议的运行，该窗口的序号空间向前滑动，<span
class="math inline">\(N\)</span>称为窗口长度，故GBN也称为滑动窗口协议。</p>
<p>　　<span
class="math inline">\(base\)</span>表示最早待确认的分组的序号，<span
class="math inline">\(nextseqnum\)</span>表示最早的待发送的分组的序号。<span
class="math inline">\([0,base-1]\)</span>表示已被确认的分组，<span
class="math inline">\([base,nextseqnum-1]\)</span>表示待确认的分组，<span
class="math inline">\([nextseqnum,base+N-1]\)</span>表示待发送的分组，<span
class="math inline">\([base+N,+\infty)\)</span>表示不可用的分组，直到当前流水线中待确认的分组确认。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/extended_fsm_of_gbn.svg" class="">
<p>　　发送端必须响应<span
style="background-color: yellow">上层的调用</span>、<span
style="background-color: yellow">接收ACK</span>和<span
style="background-color: yellow">处理超时</span>。</p>
<p>　　当上层调用<code>rdt_send</code>时，发送端先检测发送窗口是否已满。若窗口未满则产生一个分组发送并更新对应的变量，否则反馈上层。不存在待确认分组的情况下首次发送分组时会设置一个计时器。当收到ACK但仍存在待确认的分组时，计时器将重置。当不存在待确认的分组时停止计时器。</p>
<p>　　接收端用<span
class="math inline">\(expectedseqnum\)</span>来表示按序待接收的分组的序号。</p>
<p>　　接收端对序号为<span
class="math inline">\(n\)</span>的分组使用<strong>累积确认</strong>的方式，表明已正确收到序号小于等于<span
class="math inline">\(n\)</span>的所有分组。</p>
<p>　　当接收端收到序号为<span
class="math inline">\(n\)</span>的分组且上次交付给上层的分组的序号是<span
class="math inline">\(n-1\)</span>时会对分组<span
class="math inline">\(n\)</span>回传ACK，否则丢弃该分组并对最近交付给上层的分组回传ACK。</p>
<p>　　接收端会丢失所有乱序分组，因为这些分组还会重传。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/gbn_operation.svg" class="">
<h4 id="选择重传">3.2.6 选择重传</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/sender_and_receiver_views_of_sequence_numbers_in_sr.svg" class="">
<p>　　发送端会收到窗口内某些分组的ACK，重传那些在接收端丢失/受损的分组。</p>
<p>　　接收端将确认一个正确接收的分组而不管是否按序，乱序的分组将被缓存，当所有的乱序分组都被接收后再一起交付给上层。</p>
<p>　　当上层调用<code>rdt_send</code>时，发送端检测可用于分组的序号是否在窗口内。若在窗口内则产生一个分组发送，否则反馈上层。每个分组都有一个计时器。当收到ACK时，若ACK对应的分组序号在窗口内则将该分组标记为已确认，若ACK对应的分组序号等于<span
class="math inline">\(send\_base\)</span>则将窗口移动至待确认的最小序号处。窗口移动后且窗口内存在待发送的分组，这些分组将被发送。</p>
<p>　　对接收端，<span style="background-color: yellow">序号在<span
class="math inline">\([rcv\_base-N,rcv\_base+N-1]\)</span>内的分组将被正确接收</span>。若接收分组的序号在窗口内将回传ACK，分组首次接收时缓存该分组。若接收分组的序号等于<span
class="math inline">\(rcv\_base\)</span>，则该分组以及缓存中序号始于该分组的序号且连续的所有分组将交付给上层。若接收分组的序号在<span
class="math inline">\([rcv\_base-N,rcv\_base-1]\)</span>，则<span
style="background-color: yellow">必须</span>回传一个ACK，无论该分组是否已被确认。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/sr_operation.svg" class="">
<p>　　SR问题在于发送端/接收端之间缺乏同步，唯一能确定的是只有信道中收到的分组/ACK。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/problem_of_sr.svg" class="">
<p>　　SR的窗口长度必须小于等于序号去重后的数量的一半。</p>
<p>　　若信道是单段物理连接时，信道中的分组不会重新排序。若信道是网络时，信道中的分组可能会重新排序，体现在即使发送端和接收端的当前窗口都不包含序号<code>x</code>，但信道中可能出现序号为<code>x</code>的分组/ACK的副本。信道中的分组重新排序可视为缓存这些分组并在未来的<span
style="background-color: yellow">任何时间</span>自发地发出这些分组。由于序号可以重复，这种序号重复的分组应该避免出现，实际中通常是确保在发送端确定之前发送的序号<code>x</code>的分组不会出现在网络前，都不会使用序号<code>x</code>，这通过设置分组的<strong>生存时间</strong>(一般不超过3分钟)来实现。</p>
<h3 id="拥塞控制原理">3.3 拥塞控制原理</h3>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/two_senders_and_a_router_with_infinite_buffers.svg" class="">
<p>　　<span
class="math inline">\(\lambda_{in}(B/s)\)</span>表示应用层通过套接字发送初始报文到传输层的速率，<span
class="math inline">\(\lambda_{out}(B/s)\)</span>表示应用层接收报文的速率。</p>
<p>　　分组通过一台路由器在容量为<span
class="math inline">\(R\)</span>的共享式输出链路上传输，忽略添加底层首部信息的开销、差错恢复、流量控制和拥塞控制，显然<span
class="math inline">\(\lambda_{out} \leqslant \frac{R}{2}\)</span>
。时延的增长率随着<span
class="math inline">\(\lambda_{in}\)</span>增长，<span
class="math inline">\(\lambda_{in}\)</span>达到<span
class="math inline">\(\frac{R}{2}\)</span>时时延无穷大。这里体现了<span
style="background-color: yellow">拥塞的代价之一：当分组的到达速率接近链路容量时，分组承受巨大的排队时延</span>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/two_senders_with_retransmissions_and_a_router_with_finite_buffers.svg" class="">
<p>　　<span
class="math inline">\(\lambda^{&#39;}_{in}(B/s)\)</span>表示传输层发送初始报文段和重传报文段到网络层的速率，称为<strong>供给载荷</strong>。</p>
<p>　　假设发送端能确定路由器的可用缓存并根据情况发送分组，故不会丢包，<span
class="math inline">\(\lambda_{in}=\lambda^{&#39;}_{in}\)</span>，连接的吞吐量为<span
class="math inline">\(\lambda^{&#39;}_{in}\)</span>。在这种情况下，主机平均发送速率不能超过<span
class="math inline">\(\frac{R}{2}\)</span>。</p>
<p>　　假设发送端仅确定分组丢失后下才重传，当<span
class="math inline">\(\lambda_{in}^{&#39;}=\frac{R}{2}\)</span>时从平均角度有<span
class="math inline">\(\lambda_{in}=\lambda_{out}=\frac{R}{3}\)</span>。这里体现了<span
style="background-color: yellow">拥塞的代价之一：发送端必须重传因缓存溢出而丢失的分组</span>。</p>
<p>　　假设发送端重传因排队时延超时但未丢失的分组，初始分组和重传的分组可能都会到达接收端，接收端只需要一个这样的分组。当<span
class="math inline">\(\lambda_{in}^{&#39;}=\frac{R}{2}\)</span>时从平均角度(每个分组转发两次)有<span
class="math inline">\(\lambda_{in}=\lambda_{out}=\frac{R}{4}\)</span>。这里体现了<span
style="background-color: yellow">拥塞的代价之一：发送方因较大的时延进行了不必要的重传而占用路由器额外的链路带宽</span>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/four_senders_with_retransmissions,routers_with_finite_buffers.svg" class="">
<p>　　当<span
class="math inline">\(\lambda_{in}\)</span>较小时，路由器缓存比较充足，吞吐量大致等于供给载荷，<span
class="math inline">\(\lambda_{out}\)</span>随着<span
class="math inline">\(\lambda_{in}\)</span>增大而增大。当<span
class="math inline">\(\lambda_{in}\)</span>较大时，对于R2，主机B发送的分组的到达速率高于主机A发送的分组的到达速率，这会导致主机A发送的分组因缓存溢出而丢失。</p>
<p>　　若考虑网络资源的浪费，当分组在第二跳及之后的路由器丢失时，之前路由器的转发工作毫无意义。这里体现<span
style="background-color: yellow">拥塞的代价之一：分组丢失时转发过该分组的上游路由器因转发而使用的传输容量被浪费</span>。</p>
<p>　　根据网络层是否为传输层提供了显式支持可将拥塞控制分为<span
style="background-color: yellow">端到端拥塞控制</span>和<span
style="background-color: yellow">网络辅助拥塞控制</span>。</p>
<p>　　在端到端拥塞控制中，网络层<span
style="background-color: yellow">没有</span>为传输层提供显示支持。即使网络中存在拥塞，端系统也必须通过对丢包和时延等网络行为的观察来确定是否拥塞。</p>
<p>　　在网络辅助的拥塞控制中，路由器向发送端提供关于的拥塞状态的显示反馈信息。拥塞信息反馈到发送端通常有两种方式，一种是路由器直接发送关于拥塞状态的分组给发送端，此时该分组称为<strong>抑制分组</strong>。另一种方式更通用，TCP、DCCP和DCTCP都有使用。路由器更新<span
style="background-color: yellow">由发送端到接收端的数据报头部中的ECN字段</span>(包含2位)来表示出现拥塞。若接收端收到分组的标志位表示出现拥塞则会通知发送端，故这种方式至少需要一个完整的往返周期。</p>
<h3 id="tcp">3.4 TCP</h3>
<p>　　在进程发送数据之前，进程间必须握手，即相互发送一些预备报文段来设置确保数据传输的参数，故TCP是<strong>面向连接的</strong>。</p>
<p>　　TCP连接只能有一个客户端和一个服务器，故TCP是<strong>点对点</strong>的。</p>
<p>　　进程间建立TCP连接后，双方都可以发送/接收报文段，故TCP是<strong>全双工服务</strong>。</p>
<p>　　TCP根据ACK到达的速率来调节拥塞窗口，故TCP是<strong>自计时</strong>的。</p>
<p>　　客户端先发送一个特殊的报文段，服务器用另一个特殊报文段来响应，最后，客户端用第三个特殊报文段作为响应，这种建立连接的过程被称为<strong>三次握手</strong>。前2个报文段不承载有效载荷，第三个报文段可以承载有效载荷。</p>
<p>　　TCP双方都有接收缓存、发送缓存和几个变量。当TCP连接收到正确且按序的数据后，会将数据放入接收缓存，对应的应用会从该缓存中读取数据(但并非立即读取)，若不能及时读取而收到的数据过多且过快，接收缓存可能溢出。</p>
<p>　　TCP会使用<strong>重传计时器</strong>、<strong>坚持计时器</strong>、<strong>保活计时器</strong>和<strong>时间等待计时器</strong>这四种计时器。重传计时器用于报文段重传。坚持计时器用于防止双方的死锁。保活计时器用于在长连接中断开无响应的连接。时间等待计时器用于四次握手断开连接前的等待。</p>
<p>　　<strong>最大传输单元</strong>指从源到目的地所有链路上发送的最大链路层帧的有效载荷(即IP数据报)。<strong>最大报文段长度</strong>是报文段中有效载荷的最大长度。最大传输单元一般是<span
class="math inline">\(1500B\)</span>，TCP/IP首部的长度一般是<span
class="math inline">\(40B\)</span>，故TCP报文段最大长度一般是<span
class="math inline">\(1460B\)</span>。</p>
<p>　　当收到按序报文段时，若序号在按序报文段之前的报文段都已经确认，则等待下一个按序报文段最多500ms，超时则发送ACK。若还存在另一个按序报文段待确认，则立即发送单个累积ACK来确认这两个报文段。</p>
<p>　　当收到序号在按序报文段之后的报文段时则立即发送冗余ACK。</p>
<p>　　当<span
style="background-color: yellow">超时或收到3个冗余ACK</span>时时，表示出现了丢包。一旦收到3个冗余ACK，TCP就执行<strong>快速重传</strong>。</p>
<h4 id="tcp报文段">3.4.1 TCP报文段</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/tcp_segment_format.svg" class="">
<p>　　TCP报文段包括16位<strong>源端口</strong>、16位<strong>目的端口</strong>、32位<strong>序号</strong>、32位<strong>确认序号</strong>、4位<strong>首部长度</strong>、3位保留字段、9个标志位、16位<strong>窗口长度</strong>、16位<strong>校验和</strong>、16位<strong>紧急指针</strong>以及最多<span
class="math inline">\(40B\)</span>的的选项字段。</p>
<p>　　TCP将数据看成一个无结构且有序的字节流，通过字节流确定序号，序号是<span
style="background-color: yellow">报文段首字节的编号</span>。初始序号一般随机。</p>
<p>　　确认号是<span
style="background-color: yellow">下一次按序应接收报文段首字节的编号</span>。TCP只确认报文段有效载荷中到第一个丢失字节为止的字节，故TCP提供<strong>累积确认</strong>。当有效载荷为空时吗，确认号被<strong>捎带</strong>在报文段中。</p>
<p>　　9个标志位中第2、3位标志位用于显式拥塞控制，若发送端至接收端链路中的某个路由器出现拥塞，当数据报达到该路由器后，路由器将数据报头部中的ECN字段置1，接收端收到数据报后将ACK报文段头部中的<code>ECE</code>置1来通知发送端链路出现拥塞，发送端像快速重传一样对<code>ECE</code>为1的ACK回应ACK，发送端在下一个报文段中将<code>CWR</code>置1来通知接收端拥塞窗口已缩减。</p>
<p>　　●
<strong>NS/N</strong>通常用于防止标记数据包被意外或恶意地隐藏。</p>
<p>　　● <strong>CWR/C</strong>为1时通知对方拥塞窗口已缩减。</p>
<p>　　● <strong>ECE/E</strong>为1时通知对方链路出现拥塞。</p>
<p>　　●
<strong>Urgent/URG/U</strong>为1时表示高优先级报文段，紧急指针生效。</p>
<p>　　●
<strong>ACK/A</strong>为1时表示确认序号生效，报文段成功接收。</p>
<p>　　●
<strong>Push/PSH/P</strong>为1时表示应该立即将该报文段交给应用层而不用等待缓存区填满。</p>
<p>　　● <strong>Reset/RST/R</strong>为1时表示重置连接。</p>
<p>　　●
<strong>Synchronization/SYN/S</strong>为1时表示三次握手中建立连接。</p>
<p>　　● <strong>Finish/FIN/F</strong>为1时表示四次挥手中断开连接。</p>
<p>　　选项字段包括8位Kind、可变的Length以及可变的Info。</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 35%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr>
<th>Kind字段值</th>
<th>Length字段值</th>
<th>Info字段长度</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td></td>
<td>选项表结束(EOP)</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td></td>
<td>空操作(NOP)</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td><span class="math inline">\(2B\)</span></td>
<td>最大报文段长度(MSS)</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td><span class="math inline">\(1B\)</span></td>
<td>窗口扩大系数(WSOPT)</td>
<td>窗口长度扩展</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td></td>
<td>选择性确认(SACK-Premitted)</td>
<td>表示支持SACK</td>
</tr>
<tr>
<td>5</td>
<td>可变</td>
<td></td>
<td>选择性确认(SACK)</td>
<td>收到的乱序数据</td>
</tr>
<tr>
<td>8</td>
<td>10</td>
<td></td>
<td>TSPOT</td>
<td>时间戳</td>
</tr>
<tr>
<td>19</td>
<td>18</td>
<td></td>
<td>TCP-MD5</td>
<td>MD5认证</td>
</tr>
<tr>
<td>28</td>
<td>4</td>
<td></td>
<td>User Timeout(UTO)</td>
<td>超时时间</td>
</tr>
<tr>
<td>29</td>
<td>可变</td>
<td></td>
<td>TCP-AO</td>
<td>认证算法</td>
</tr>
<tr>
<td>253/254</td>
<td>可变</td>
<td></td>
<td>Experimental</td>
<td>保留</td>
</tr>
</tbody>
</table>
<p>　　窗口长度用于流量控制服务。</p>
<p>　　校验和的计算类似于UDP的校验和。</p>
<h4 id="连接管理">3.4.2 连接管理</h4>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/three-way_handshake.svg" class="">
<p>　　1)
客户端向服务器发送<strong>SYN</strong>(报文段)，即报文段的有效载荷为空，<code>SYN</code>为1，客户端进入<code>SYN_SENT</code>。</p>
<p>　　2)
服务器收到SYN后为该连接分配TCP缓存和变量，再向客户端发送<strong>SYNACK</strong>(报文段)，即ACK报文段的<code>SYN</code>为1，最后服务器进入<code>SYN_RCVD</code>。</p>
<p>　　3)
客户端收到SYNACK后该连接分配TCP缓存和变量，再向服务器发送ACK，此时连接已建立，<code>SYN</code>置为0，最后客户端进入<code>ESTABLISHED</code>。服务器收到ACK后进入<code>ESTABLISHED</code>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/four-way_handshake.svg" class="">
<p>　　1)
客户端向服务器发送<strong>FIN</strong>(报文段)，即报文段的有效载荷为空，<code>FIN</code>为1，客户端进入<code>FIN_WAIT_1</code>。</p>
<p>　　2)
服务器收到FIN后发送ACK并进入<code>CLOSE_WAIT</code>。客户端收到ACK后进入<code>FIN_WAIT_2</code>。</p>
<p>　　3) 服务器向客户端发送FIN并进入<code>LAST_ACK</code>。</p>
<p>　　4)
客户端收到FIN后发送ACK并进入<code>TIME_wAIT</code>，同时设置时间等待计时器，计时结束后释放资源(包括端口号)并进入<code>CLOSED</code>。服务器收到ACK后释放资源并进入<code>CLOSED</code>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/tcp_state.svg" class="">
<p>　　在TCP连接的生命周期中，运行在每台主机的TCP协议会在各种<strong>TCP状态</strong>间变迁。</p>
<h4 id="超时">3.4.3 超时</h4>
<p>　　<span
class="math inline">\(SampleRTT\)</span>表示报文段从发送(交付给IP)到收到该报文段的确认所需时间。TCP不会为重传的报文段测量<span
class="math inline">\(SampleRTT\)</span>，仅仅为只需要传输一次的报文段测量。</p>
<p>　　<span class="math inline">\(EstimatedRTT\)</span>表示<span
class="math inline">\(SampleRTT\)</span>的平均值，其中<span
class="math inline">\(\alpha\)</span>一般取<span
class="math inline">\(\frac{1}{8}\)</span>。 <span
class="math display">\[
EstimatedRTT=(1-\alpha)\times EstimatedRTT+ \alpha \times SampleRTT
\]</span> 　　<span class="math inline">\(DevRTT\)</span>表示<span
class="math inline">\(SampleRTT\)</span>偏离<span
class="math inline">\(EstimatedRTT\)</span>的程度，其中<span
class="math inline">\(\beta\)</span>一般取<span
class="math inline">\(\frac{1}{4}\)</span>。 <span
class="math display">\[
DevRTT=(1-\beta)\times DevRTT+\beta \times |SampleRTT-EstimatedRTT|
\]</span> 　　<span class="math inline">\(EstimatedRTT\)</span>和<span
class="math inline">\(DevRTT\)</span>的计算方式是<strong>指数加权移动平均</strong>。</p>
<p>　　<span
class="math inline">\(TimeoutInterval\)</span>表示超时时间。 <span
class="math display">\[
TimeoutInterval=EstimatedRTT+4\times DevRTT
\]</span></p>
<h4 id="流量控制">3.4.4 流量控制</h4>
<p>　　TCP用<strong>流量控制服务</strong>来使发送端的发送速率和接收端的读取速率相匹配，主要通过让<span
style="background-color: yellow">发送端</span>维护<strong>接收窗口</strong>(表示接收端可用缓存空间)的变量来实现。</p>
<p>　　<span
class="math inline">\(RevBuffer\)</span>表示接收端的接收缓存的大小。<span
class="math inline">\(LastByteRead\)</span>表示接收端在接收缓存中读取的数据流的最后一个字节的编号。<span
class="math inline">\(LastByteRcvd\)</span>表示接收端缓存至接收缓存的数据流的最后一个字节的编号。<span
class="math inline">\(rwnd\)</span>表示接收窗口。 <span
class="math display">\[
rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]
\]</span> 　　接收端将报文段中窗口长度字段设置为<span
class="math inline">\(rwnd\)</span>来告知发送端可用缓存空间。</p>
<p>　　<span
class="math inline">\(LastByteSent-LastByteAcked\)</span>表示发送端待确认的数据量。
<span class="math display">\[
LastByteSent-LastByteAcked\leqslant rwnd
\]</span> <img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/tcp_flow_control.svg" class=""></p>
<p>　　当发送端收到窗口长度为0的ACK时，会设置坚持计时器并发送一个有效载荷为<span
class="math inline">\(1B\)</span>的探测报文段，若计时器超时或收到窗口长度为0的ACK时会再次发送同样的报文段并重置计时器，否则继续发送有效载荷为有效数据的报文段。</p>
<h4 id="tcp拥塞控制">3.4.5 TCP拥塞控制</h4>
<p>　　网络层不向端系统提供显式的网络拥塞反馈，故TCP只能使用端到端拥塞控制。</p>
<p>　　TCP发送端比接收端多1个变量，即<strong>拥塞窗口</strong>，用来限制发送速率。发送端未被确认的数据不能超过接收窗口与拥塞窗口的最小值。
<span class="math display">\[
LastByteSent-LastByteAcked \leqslant min\{cwnd,rwnd\}
\]</span>
　　假设接收窗口足够大、忽略丢包与时延以及发送端总有数据需要发送，<span
style="background-color: yellow">发送速率大致等于<span
class="math inline">\(\frac{cwnd}{RTT}(B/s)\)</span></span>。</p>
<p>　　当某路径出现拥塞时，该路径上部分路由器的缓存会溢出并导致某个数据包丢失，此时发送端可以确定该路径出现了拥塞。</p>
<p>　　<span
style="background-color: yellow">带宽探测：丢包表示出现了拥塞，应该降低发送速率。当未确认报文段的ACK到达时应该提高发送速率。</span></p>
<h5 id="tcp拥塞控制算法">3.4.5.1 TCP拥塞控制算法</h5>
<p>　　TCP拥塞控制算法包括<strong>慢启动</strong>、<strong>拥塞避免</strong>和<strong>快速恢复</strong>。</p>
<p>　　TCP拥塞控制被称为<strong>加性增、乘性减</strong>拥塞控制方式。加性增指在拥塞避免阶段<span
class="math inline">\(cwnd\)</span>的线性增加，乘性减指进入快速恢复阶段时<span
class="math inline">\(cwnd\)</span>的减半，若结果不是整数则向下取整。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/fsm_of_tcp_congestion_control.svg" class="">
<p>　　在慢启动阶段，<span
class="math inline">\(cwnd\)</span>的初始值是<span
class="math inline">\(MSS\)</span>，<span
class="math inline">\(ssthresh\)</span>的初始值是<span
class="math inline">\(64KB\)</span>。每当报文段首次确认<span
class="math inline">\(cwnd\)</span>就增加<span
class="math inline">\(MSS\)</span>，即指数级增长。若出现超时导致的丢包，发送端令<span
class="math inline">\(ssthresh=\frac{cwnd}{2}\)</span>，<span
class="math inline">\(cwnd=MSS\)</span>并重新开始慢启动。当<span
class="math inline">\(cwnd \geqslant
ssthresh\)</span>时发送端结束慢启动并进入拥塞避免阶段。当收到3个冗余ACK时，发送端结束慢启动并令<span
class="math inline">\(ssthresh=\frac{cwnd}{2}\)</span>，<span
class="math inline">\(cwnd=\frac{ssthresh}{2}+3MSS\)</span>，然后执行快速重传，最后进入快速恢复阶段。</p>
<p>　　在不考虑处理时间的情况下，客户端发送请求到远程数据中心并收到响应大致需要<span
class="math inline">\(4RTT\)</span>，其中建立TCP需要<span
class="math inline">\(RTT\)</span>，慢启动阶段需要<span
class="math inline">\(3RTT\)</span>。显然，当<span
class="math inline">\(RTT\)</span>较大时，时延也较大。可以使用<strong>TCP分岔</strong>解决这一问题，即通过CDN将请求转发至邻近客户端且与远程数据中心有很大窗口的连接的前端服务器，在这种情况下响应所需时间大致是<span
class="math inline">\(4RTT_{FE}+RTT_{BE}+处理时间\)</span>，其中<span
class="math inline">\(RTT_{FE}\)</span>表示客户端与前端服务器的往返时间，<span
class="math inline">\(RTT_{BE}\)</span>表示前端服务器与远程数据中心的往返时间。当前端服务器与客户端足够近，就可以忽略<span
class="math inline">\(RTT_{FE}\)</span>，此时响应所需时间大致等于<span
class="math inline">\(RTT\)</span>。</p>
<p>　　在拥塞避免阶段，每个<span
class="math inline">\(RTT\)</span>内<span
class="math inline">\(cwnd\)</span>仅增加<span
class="math inline">\(MSS\)</span>。通用实现方法是若<span
class="math inline">\(RTT\)</span>内发送了<span
class="math inline">\(n\)</span>个报文段，在此期间每个报文段首次确认时<span
class="math inline">\(cwnd\)</span>增加<span
class="math inline">\(\frac{cwnd}{n}\)</span>。超时和3个冗余ACK的情况同慢启动。</p>
<p>　　在快速恢复阶段，每收到一个冗余ACK，<span
class="math inline">\(cwnd\)</span>增加<span
class="math inline">\(MSS\)</span>。当收到了新报文段的首次ACK，发送端会结束快速恢复阶段并进入拥塞避免阶段。当出现超时导致的丢包时发送端会结束快速恢复并令<span
class="math inline">\(ssthresh=\frac{cwnd}{2}\)</span>，<span
class="math inline">\(cwnd=MSS\)</span>，然后进入慢启动阶段。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_03/evolution_of_tcp_congestion_window.svg" class="">
<p>　　TCP的较新版本<strong>TCP
Reno</strong>的快速恢复阶段符合上述情况。但TCP的早期版本<strong>TCP
Tahoe</strong>在快速恢复阶段只要出现丢包都会结束快速恢复并令<span
class="math inline">\(ssthresh=\frac{cwnd}{2}\)</span>，<span
class="math inline">\(cwnd=MSS\)</span>，然后进入慢启动阶段。</p>
<p>　　TCP
Vegas试图在维持较好吞吐量同时避免拥塞，通过测量RTT来衡量拥塞程度，根据拥塞程度线性地降低发送速率。TCP
Vegas提供了慢启动、拥塞避免、快速恢复、快速重传和SACK。</p>
<h5 id="平均吞吐量">3.4.5.2 平均吞吐量</h5>
<p>　　当计算一个吞吐量较大的连接的平均吞吐量时，因为慢启动阶段和快速恢复阶段通常很短，都可以忽略，故可以认为该连接处于拥塞避免阶段。在一个RTT内，窗口长度是<span
class="math inline">\(w(B)\)</span>，吞吐量大约是<span
class="math inline">\(\frac{w}{RTT}\)</span>。在出现丢包之前，每个RTT内<span
class="math inline">\(w=w+MSS\)</span>。用<span
class="math inline">\(W\)</span>表示出现丢包时<span
class="math inline">\(w\)</span>的值。</p>
<p>　　若在一段时间内吞吐量从<span
class="math inline">\(\frac{W}{2RTT}\)</span>线性增长到<span
class="math inline">\(\frac{W}{RTT}\)</span>，丢包仅出现了一次且发生在最后。
<span class="math display">\[
\begin{align}
Segment_{total}&amp;=\frac{W}{2RTT}\times RTT+\frac{W+2}{2RTT}\times
RTT+\cdots +\frac{W}{RTT}\times RTT\\[3px]
&amp;=(\frac{W}{4}+\frac{W}{2}) \times (\frac{W}{4}+\frac{1}{2})\\[3px]
&amp;=\frac{3W^2}{8}+\frac{3W}{4}
\end{align}
\]</span> 　　丢包率<span
class="math inline">\(L=\frac{Segment_{loss}}{Segment_{total}}\)</span>。
<span class="math display">\[
\begin{align}
L&amp;=\frac{1}{Segment_{total}}\\[3px]
&amp;=\frac{1}{\frac{3W^2}{8}+\frac{3W}{4}}\\[3px]
&amp;=\frac{8}{3W^2+6W}
\end{align}
\]</span> 　　由于<span
class="math inline">\({3W^2}&gt;&gt;{6W}\)</span>，<span
class="math inline">\(6W\)</span>可以忽略，故<span
class="math inline">\(W \approx
\sqrt{\frac{8}{3L}}\)</span>。由于增长是线性，平均吞吐量是<span
class="math inline">\(\frac{3W}{4RTT}(MSS)\)</span>。 <span
class="math display">\[
\begin{align}
平均吞吐量&amp;=\frac{\sqrt{6}MSS}{2RTT\sqrt{L}}\\[3px]
&amp;\approx \frac{1.22\times MSS}{RTT\sqrt{L}}
\end{align}
\]</span></p>
<h5 id="公平性">3.4.5.3 公平性</h5>
<p>　　<strong>瓶颈链路</strong>指沿着某连接路径上的每条连接都不拥塞且相比该链路的传输容量都具有足够的传输容量。</p>
<p>　　假设<span
class="math inline">\(K\)</span>条TCP连接每条的端到端路径不同，但是都经过一段传输速率为<span
class="math inline">\(R(b/s)\)</span>的瓶颈链路。若每条连接都在传输一个大文件且无UDP流量通过该链路，而且每条连接的平均传输速率接近<span
class="math inline">\(\frac{R}{K}\)</span>，则认为该拥塞控制机制是<strong>公平</strong>的。在这种理想情况下，当所有连接的RTT相同时才能平等共享带宽，实际中这些条件不能都满足，具有较小RTT的连接可以更快地扩大拥塞窗口。</p>
<p>　　UDP并没有内置的拥塞控制机制，UDP是不公平的，UDP可能抑制TCP。</p>
<p>　　当一个应用使用多条并行TCP连接时，对单条TCP连接可能是公平的，但对应用并不公平。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第7章 网络安全</title>
    <url>/network/computer_networking_a_top_down_approach_7e_chpt_07/</url>
    <content><![CDATA[<p>　　<strong>安全通信</strong>应该具有<span
style="background-color: yellow">保密</span>、<span
style="background-color: yellow">报文完整</span>、<span
style="background-color: yellow">端点认证</span>、<span
style="background-color: yellow">运行安全</span>的特点。</p>
<p>　　互联网协议栈中不止网络层提供安全性功能。首先，网络层可以通过加密数据报中的有效载荷以及认证所有源IP地址来提供全面覆盖的安全性，但并不能提供用户级安全，因此也需要其他层的安全性功能来实现。其次，在协议栈的较上层部署新的的互联网服务(包括安全性服务)通常更容易。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/provide_anonymity_and_privacy_with_a_proxy.svg" class="">
<p>　　为了在访问Web获得隐私和匿名，可以组合使用可信代理服务器和SSL。首先主机与可信代理服务器建立SSL连接，通过SSL连接发送到所需站点的HTTP请求。代理收到SSL加密的HTTP请求后，它会解密该请求并将明文HTTP转发到网站，然后服务器响应代理，代理再通过SSL将响应转发给主机。该Web站点仅能看到代理的IP地址，主机的本地ISP无法记录主机的访问，但代理可以获取主机的IP地址以及主机和网站之间所有明文流量。因此，这种方式的安全取决于代理的可信度。</p>
<p>　　TOR匿名和隐私服务采用一系列非串通代理服务器来路由流量。TOR允许独立个体为其代理池贡献代理。当某用户使用TOR连接到服务器时，TOR从代理池随机选择三个代理形成代理链并通过代理链路由在用户和服务器之间所有流量。若三个代理不串通则无法得知用户与Web站点间的通信。尽管最后一个代理和服务器之间传输明文，但最后一个代理并不知道用户的IP地址。</p>
<span id="more"></span>
<h3 id="密码学">7.1 密码学</h3>
<p>　　使用<strong>加密算法</strong>对<strong>明文</strong>进行加密后生成<strong>密文</strong>。</p>
<p>　　在<strong>对称加密</strong>中双方使用相同的密钥。在<strong>非对称加密</strong>中使用<strong>公钥</strong>和<strong>密钥</strong>，任何人都可以获得公钥。</p>
<p>　　若只能得到截取的密文，也不了解明文内容，统计分析有助于对加密方案的<strong>唯密文攻击</strong>。若能得到部分明文与密文的匹配关系，通过这种方式的攻击称为<strong>已知明文攻击</strong>。在<strong>选择明文攻击</strong>中，能选择明文信息并获取对应的密文，但并不代表能获取加密的过程。</p>
<h4 id="对称加密">7.1.1 对称加密</h4>
<p>　　<strong>凯撒密码</strong>加密字母时，将每个字母在字母表中该字母后第<span
class="math inline">\(k\)</span>个字母与之替换。 <span
class="math display">\[
x=(x+k) \bmod 26
\]</span>
　　凯撒密码的改进版是<strong>单表替换密码</strong>，但它不是根据常规模式进行替换，任何字母可以替换其他字母，只需每个字母有唯一的替换字母即可。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/a_monoalphabetic_cipher.svg" class="">
<p>　　单表替换密码的字母配对看似很多，但通过对明文语言进行统计分析后可以发现e和t出现的频率最高且特定的两个和三个字母经常一起出现，实际上破解更容易一些。</p>
<p>　　单表替换密码的的改进版是<strong>多表替换密码</strong>。多表替换密码的基本思想是使用多个单表替换密码，一个单表替换密码用于加密明文中特定位置的字母。因此，明文中不同位置出现的字母可能以不同的方式加密。</p>
<p>　　现代对称加密大致分为<strong>流加密</strong>和<strong>块加密</strong>。块加密用于PGP、SSL和IPsec等，流加密用于WEP等。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/simple_example_of_block_cipher.svg" class="">
<p>　　在块加密中，明文以<span
class="math inline">\(k\)</span>位块进行处理。为了对块进行加密，使用一对一映射将明文的<span
class="math inline">\(k\)</span>位映射到密文的<span
class="math inline">\(k\)</span>位块，因此每种输入都有不同的输出。块密码通常使用函数模拟随机排列表。以64位块为例并假设置乱函数为公共已知，将64位块分成8个小块，每个小块由8位组成，每个小块由一个8位到8位的映射表进行映射，该表具有的大小可管理的映射长度，然后这8个输出块重新组装成64位块并置乱，最后将结果作为输入再循环<span
class="math inline">\(n\)</span>次该过程。循环的目的是使每个输入位都影响最后输出位的大部分乃至全部。这种块密码算法的密钥是8张映射表。</p>
<p>　　诸如DES、3DES和AES的块密码都使用位串作为密钥，密钥决定了映射表的映射和算法内部的排列。DES使用了具有56位密钥的64位块，AES使用了128位块且能够使用128、192和256位的密钥进行操作。</p>
<p>　　报文明文中可能存在多个相同的明文块，使用块密码产生的密文也相同，因此可能猜出明文并根据相同的密文块和协议结构相关的知识解密整个报文。为了解决这个问题，可以在密文中混合一些随机性使得相同的明文生成不同的密文。</p>
<p>　　密钥为<span
class="math inline">\(S\)</span>的块密码加密算法表示为<span
class="math inline">\(K_S\)</span>，第<span
class="math inline">\(i\)</span>个明文块和密文块分布表示为<span
class="math inline">\(m(i)\)</span>和<span
class="math inline">\(c(i)\)</span>。发送端根据第<span
class="math inline">\(i\)</span>块生成随机的<span
class="math inline">\(k\)</span>位数<span
class="math inline">\(r(i)\)</span>且计算<span
class="math inline">\(c(i)=K_s(m(i)\oplus
r(i))\)</span>。接收端能接收到<span
class="math inline">\(c(i)\)</span>和<span
class="math inline">\(r(i)\)</span>，根据<span
class="math inline">\(m(i)=K_s(c(i)\oplus
r(i))\)</span>可以进行解密。但这样需要传输额外的随机数，为了解决这一问题，块密码使用了<strong>密码块链接</strong>，基本思想是仅第一个报文发送一个随机值，然后让发送端和接收端使用计算出的密文代替后继的随机数。</p>
<p>　　1) 在加密报文前，发送端生成一个随机的<span
class="math inline">\(k\)</span>位串，称为<strong>初始向量</strong>，用<span
class="math inline">\(c(0)\)</span>表示。发送端以<span
style="background-color: yellow">明文</span>发送IV给接收端。</p>
<p>　　2) 对第一个块，发送端计算<span class="math inline">\(m(1)\oplus
c(0)\)</span>，然后通过块密码得到对应的密文<span
class="math inline">\(c(1)=K_S(m(1)\oplus c(0))\)</span>并发送。</p>
<p>　　3) 对于第<span
class="math inline">\(i\)</span>个块，发送端根据<span
class="math inline">\(c(i)=K_S(m(i)\oplus c(i-1))\)</span>生成第<span
class="math inline">\(i\)</span>个密文块。</p>
<h4 id="非对称加密">7.1.2 非对称加密</h4>
<p>　　公钥和私钥分别表示为<span
class="math inline">\(K^+_B\)</span>和<span
class="math inline">\(K^-_B\)</span>。报文<span
class="math inline">\(m\)</span>通过公钥和众所周知的加密算法加密后得到密文<span
class="math inline">\(K^+_B(m)\)</span>，密文通过私钥和众所周知的解密算法进行解密<span
class="math inline">\(K^-_B(K^+_B(m))=m\)</span>。私钥加密后也可以用公钥解密<span
class="math inline">\(K^+_B(K^-_B(m))=m\)</span>。</p>
<p>　　RSA算法广泛使用了模<span class="math inline">\(n\)</span>运算。
<span class="math display">\[
\begin{align}
[(a \bmod n)\cdot (b \bmod n)]&amp;=(a\cdot b)\bmod n\\[3px]
(a \bmod n)^d \bmod n&amp;=a^d\bmod n
\end{align}
\]</span> 　　为了生成RSA的公钥和密钥，首先选择两个大素数<span
class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>，<span
class="math inline">\(p\)</span>和<span
class="math inline">\(q\)</span>越大，破解RSA越困难，加密和解密的时间也越长。然后计算公共模数<span
class="math inline">\(n=pq\)</span>和欧拉函数<span
class="math inline">\(\varphi(n)=(p-1)(q-1)\)</span>。选择一个小于<span
class="math inline">\(n\)</span>且与<span
class="math inline">\(\varphi(n)\)</span>没有(非1的)公因数的公钥指数<span
class="math inline">\(e\)</span>，再选择<span
class="math inline">\(d\)</span>使<span class="math inline">\(ed\bmod
\varphi(n)=1\)</span>成立。公钥<span
class="math inline">\(K^+_B\)</span>是一对数<span
class="math inline">\((n,e)\)</span>，私钥<span
class="math inline">\(K^-_B\)</span>是一对数<span
class="math inline">\((n,d)\)</span>。实际中，RSA的<span
class="math inline">\(n\)</span>一般是1024位和2048位，<span
class="math inline">\(e\)</span>常使用3、17和65537。</p>
<p>　　对于明文<span class="math inline">\(m(m&lt;n)\)</span>的密文<span
class="math inline">\(c=m^e \bmod n\)</span>，解密时先对该值进行<span
class="math inline">\(d\)</span>次幂运算，再做模<span
class="math inline">\(n\)</span>运算。 <span class="math display">\[
\begin{align}
(m^e \bmod n)^d \bmod n&amp;=m^{ed}\bmod n\\[3px]
&amp;=m^{(ed \bmod \varphi(n))} \bmod n\\[3px]
&amp;=m^1 \bmod n\\[3px]
&amp;=m
\end{align}
\]</span> 　　使用私钥加密同样可以用公钥解密<span
class="math inline">\((m^d \bmod n)^e \bmod n=m^{ed}\bmod
n=m\)</span>。</p>
<p>　　RSA的指数运算比较耗时，DES则快很多，因此在实际应用中RSA常与对称加密结合使用。首先选择加密数据的共享对称密钥，称为<strong>会话密钥</strong><span
class="math inline">\(K_S\)</span>。然后使用RSA密钥对会话密钥进行加密<span
class="math inline">\(c=(K_S)^e \bmod
n\)</span>。最后对方收到后使用私钥进行解密可以获得会话密钥。</p>
<h4 id="密钥分发和管理">7.1.3 密钥分发和管理</h4>
<p>　　Diffie-Hellman(DH)密钥协商算法能够让通信双方在<span
style="background-color: yellow">非安全</span>的信道中安全地交换密钥，用于加密后续的通信信息。DH算法选择一个大素数<span
class="math inline">\(p\)</span>和小于<span
class="math inline">\(p\)</span>的数<span
class="math inline">\(g\)</span>，这两个数以明文的形式从一方发送到另一方，A、B双方完成共享<span
class="math inline">\(g\)</span>和<span
class="math inline">\(p\)</span>后各自选择密钥<span
class="math inline">\(S_A\)</span>和<span
class="math inline">\(S_B\)</span>。A、B各自计算公钥<span
class="math inline">\(T_A=g^{S_A}\bmod p\)</span>和<span
class="math inline">\(T_B=g^{S_B}\bmod
p\)</span>并通过公网交换公钥。A计算共享密钥<span
class="math inline">\(S=S_A^{^{S_B}}\bmod
p\)</span>，同样B计算共享密钥<span
class="math inline">\(S&#39;=S_B^{^{S_A}}\bmod p\)</span>。 <span
class="math display">\[
\begin{align}
S&amp;=S_A^{^{S_B}}\bmod p=(g^{S_A})^{S_B}\bmod p=g^{S_A\cdot S_B}\bmod
p=S&#39;
\end{align}
\]</span> 　　若<span
class="math inline">\(g=p-1\)</span>，根据费马小定理可以推出<span
class="math inline">\(g^{p-1}\equiv 1( \bmod
p)\)</span>，这对密钥协商构成威胁，因此<span
class="math inline">\(g\)</span>只能在<span
class="math inline">\([1,p-2]\)</span>中选择。</p>
<p>　　DH算法并不能防御欺骗攻击，攻击者在在双方交换密钥时截获并替换成自身的密钥，双方的密钥协商就变成了每方单独都和攻击者的协商。</p>
<p>　　<strong>密钥分发中心</strong>存储每个用户信息以及仅用户和KDC共享的对称密钥，该密钥称为<strong>长效密钥</strong>，因此通信双方都是KDC用户时KDC可以作为通信双方的第三方。</p>
<p>　　<span class="math inline">\(K_S\)</span>表示A和B的会话密钥，<span
class="math inline">\(K_{A-KDC}\)</span>和<span
class="math inline">\(K_{B-KDC}\)</span>表示A和B与KDC的长效密钥。A用<span
class="math inline">\(K_{A-KDC}\)</span>加密A和B的标识得到<span
class="math inline">\(K_{A-KDC}(A,B)\)</span>并发送给KDC。KDC收到后解密得知A将与B通信并生成<span
class="math inline">\(K_S\)</span>，用<span
class="math inline">\(K_{B-KDC}\)</span>加密A的标识和<span
class="math inline">\(K_S\)</span>得到<span
class="math inline">\(K_{B-KDC}(A,K_S)\)</span>，用<span
class="math inline">\(K_{A-KDC}\)</span>加密<span
class="math inline">\(K_S\)</span>和<span
class="math inline">\(K_{B-KDC}(A,K_S)\)</span>得到<span
class="math inline">\(K_{A-KDC}(K_S,K_{B-KDC}(A,K_S))\)</span>并发送给A。A收到后解密得到<span
class="math inline">\(K_S\)</span>并把<span
class="math inline">\(K_{B-KDC}(A,K_S)\)</span>发送给B，B收到后解密得到<span
class="math inline">\(K_S\)</span>。</p>
<h3 id="报文完整性和数字签名">7.2 报文完整性和数字签名</h3>
<p>　　散列函数输入<span
class="math inline">\(m\)</span>，可以得到一个固定长度的字符串<span
class="math inline">\(H(m)\)</span>。<strong>密码散列函数</strong>的特点是不同的输入不能得到相同的输出。</p>
<p>　　在MD5散列算法中，首先添加一个64位数来表示明文长度，再填充长度(添加1并在后面添加足够的0)，直到输入满足一定的条件，初始化累加器并进行循环，在循环中对报文的16字块进行4轮处理。另一个常用散列算法是SHA。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/mac.svg" class="">
<p>　　为了执行<strong>报文完整性</strong>，除了使用密码散列函数，还需要一个称为<strong>认证密钥</strong>的共享密钥<span
class="math inline">\(s\)</span>。发送端用报文<span
class="math inline">\(m\)</span>和<span
class="math inline">\(s\)</span>级联生成<span
class="math inline">\(m+s\)</span>并计算散列值<span
class="math inline">\(H(m+s)\)</span>，散列值<span
class="math inline">\(H(m+s)\)</span>称为<strong>报文认证码</strong>。然后将MAC附加到<span
class="math inline">\(m\)</span>生成扩展报文<span
class="math inline">\((m,H(m+s))\)</span>并发送。接收端收到扩展报文<span
class="math inline">\((m,h)\)</span>，由于接收端也有<span
class="math inline">\(s\)</span>，若<span
class="math inline">\(H(m+s)=h\)</span>则表示一切正常。</p>
<p>　　常用的MAC有HMAC，它能够与MD5或SHA一起使用。HMAC实际上通过散列函数计算数据和认证密钥两次。在LS算法中，可以通过物理操作或直接使用路由器自带的公钥实现认证密钥分发给AS内的每个路由器。</p>
<p>　　可以使用<span
style="background-color: yellow">非对称加密</span>和<span
style="background-color: yellow">散列函数</span>来进行<strong>数字签名</strong>。发送端的公钥和密钥表示为<span
class="math inline">\(K^+_S\)</span>和<span
class="math inline">\(K^-_S\)</span>，接收端的公钥和密钥表示为<span
class="math inline">\(K^+_R\)</span>和<span
class="math inline">\(K^-_R\)</span>。发送端先用散列函数计算明文获得散列值，用<span
class="math inline">\(K^-_S\)</span>加密散列值得到数字签名并和<span
class="math inline">\(K^+_R\)</span>加密后的密文一起发送。接收端收到后用<span
class="math inline">\(K^+_S\)</span>解密数字签名后的结果并和<span
class="math inline">\(K^-_R\)</span>解密密文后的结果的散列值进行比较，若相等则表示一切正常。</p>
<p>　　<strong>公钥认证</strong>是证明公钥属于特定的实体。将公钥认证通常由<strong>认证中心</strong>完成，其功能是证实一个实体的真实身份，一旦证实了身份后，CA会生成一个其身份和实体的公钥绑定的<strong>证书</strong>，该证书包含公钥和公钥所有者的全局唯一标识信息(人名或IP地址等)，CA会对这个证书进行数字签名。</p>
<p>　　ITU和IETF都研发了用于CA的系列标准。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>version</td>
<td>X.509规范的版本号</td>
</tr>
<tr>
<td>serial number</td>
<td>CA颁发的证书的唯一标识符</td>
</tr>
<tr>
<td>signature</td>
<td>规定CA用于签署证书的算法</td>
</tr>
<tr>
<td>issuer name</td>
<td>颁发此证书的CA的身份(采用DN格式)</td>
</tr>
<tr>
<td>validity period</td>
<td>证书有效期的时间范围</td>
</tr>
<tr>
<td>subject name</td>
<td>其公钥与该证书相关连的实体身份(采用DN格式)</td>
</tr>
<tr>
<td>subject public key</td>
<td>公钥以及使用的公钥算法及其参数的指示</td>
</tr>
</tbody>
</table>
<h3 id="端点认证">7.3 端点认证</h3>
<p>　　<strong>端点认证</strong>是一个实体通过计算机网络向另一个实体证明其身份的过程。</p>
<p>　　<strong>认证协议</strong>将在两个通信实体运行其他协议之前运行。AP首先建立相互认可的各方的标识，当认证完成后才继续之后的事情。</p>
<p>　　ap1.0就是直接告知对方其身份，但该身份可以假冒。</p>
<p>　　ap2.0使用了类似于IP地址的众所周知的网络地址，但IP哄骗可以在数据报的源地址中填入任何地址且并非所有网关路由器都配置了仅转发源IP地址为路由器所属网络的IP地址的数据报的功能。</p>
<p>　　ap3.0加入了密码，密码由认证实体和被认证实体共享，但密码可能被窃取，例如，当Telnet其他主机并登录时，登录密码会以明文的形式发送端Telnet服务器，而连接到Telnet客户端或服务器LAN的攻击者可以嗅探LAN上传输的所有数据包来获取登录密码。</p>
<p>　　ap3.1加入了加密密码，但这样并不能防御<strong>重放攻击</strong>，攻击者只需窃听通信并记录加密密码，再将重放加密密码。</p>
<p>　　ap4.0加入了类似于TCP建立连接的方式和<strong>不重数</strong>，不重数是不重复使用的随机数。被认证实体向认证实体发送认证信息，认证实体返回一个不重数<span
class="math inline">\(R\)</span>，被认证实体使用共享对称密钥<span
class="math inline">\(K\)</span>来加密<span
class="math inline">\(R\)</span>并把<span
class="math inline">\(K(R)\)</span>发回给认证实体。认证实体解密后得到的结果与<span
class="math inline">\(R\)</span>相等则表示认证成功。<span
class="math inline">\(R\)</span>也可以用被认证实体的私钥来加密，认证实体收到后使用被认证实体的公钥解密。</p>
<h3 id="安全电子邮件">7.4 安全电子邮件</h3>
<p>　　安全电子邮件应该具有<span
style="background-color: yellow">保密</span>、<span
style="background-color: yellow">报文完整</span>、<span
style="background-color: yellow">发送端认证</span>的特点。</p>
<p>　　保密性可以通过会话密钥实现，报文完整性和发送端认证都可以通过数字签名实现。若需要同时实现保密性、报文完整性和发送端认证则需要将会话密钥和数字签名结合使用，安全分发公钥可以使用CA来验证公钥。</p>
<p>　　<span class="math inline">\(K_S\)</span>表示会话密钥，<span
class="math inline">\(K^+_S\)</span>和<span
class="math inline">\(K^-_S\)</span>表示发送端的公钥和私钥， <span
class="math inline">\(K^+_R\)</span>和<span
class="math inline">\(K^-_R\)</span>表示接收端的公钥和私钥。发送端通过散列函数计算原始报文的散列值，使用<span
class="math inline">\(K^-_S\)</span>对散列值加密得到数字签名并和原始报文级联形成预备包。然后使用<span
class="math inline">\(K_S\)</span>加密预备包并使用<span
class="math inline">\(K^+_R\)</span>加密<span
class="math inline">\(K_S\)</span>，最后将加密的预备包和加密的<span
class="math inline">\(K_S\)</span>级联形成包并发送。接收端收到报文后使用<span
class="math inline">\(K^-_R\)</span>解密得到<span
class="math inline">\(K_S\)</span>并进一步解密得到数字签名和原始报文，再使用<span
class="math inline">\(R^+_S\)</span>解密的结果和原始报文的散列值进行比较。</p>
<p>　　PGP(Pretty Good
Privacy)是安全电子邮件的一个范例。PGP使用MD5或SHA来计算散列值，使用CAST、3DES或IDEA进行对称加密，使用RSA进行非对称加密。</p>
<p>　　用户安装PGP时会为用户生成一个公钥，该公钥可以发布在用户的网站或放置在公钥服务器上。用户每次访问私钥时都必须输入密码。PGP为用户提供了报文的数字签名、加密或两者都执行的选项。PGP也提供公钥认证机制，但公钥由可信网站认证，用户可以查询某公钥是否属于某用户。此外，PGP允许用户为其所信任的用户认证更多密钥提供担保。PGP用户间可以通过持有密钥签署方来签署彼此的密钥。</p>
<h3 id="ssl">7.5 SSL</h3>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/ssl.svg" class="">
<p>　　<strong>安全套接字层</strong>使用保密性、数据完整性和端点认证来强化TCP。SSL
3.1称为<strong>安全传输层</strong>。SSL常用于为通过HTTP的事务提供安全性，实际上，SSL为TCP提供安全性，故任何通过TCP的应用程序都可以使用SSL。SSL提供了一个简单的具有套接字的接口，该接口类似于TCP的接口。</p>
<p>　　SSL具有<span style="background-color: yellow">握手</span>、<span
style="background-color: yellow">密钥派生</span>和<span
style="background-color: yellow">数据传输</span>三个阶段。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/simplified_ssl_handshake.svg" class="">
<p>　　在握手阶段，客户端与服务器创建TCP连接并对服务器认证，然后客户端发送给服务器一个主密钥，客户端和服务器都将使用该密钥生成
SSL会话所需的所有对称密钥。一旦建立TCP连接，客户端就向服务器发送一个hello报文，服务器用其证书响应，证书中包括服务器的公钥<span
class="math inline">\(K^+_S\)</span>。客户端生成一个仅用于SSL会话的<strong>主密钥</strong>，用<span
class="math inline">\(K^+_S\)</span>加密MS得到加密主密钥并发送给服务器。服务器收到后对EMS使用服务器的私钥<span
class="math inline">\(K^-_S\)</span>进行解密获得MS。</p>
<p>　　在密钥派生阶段，发送端和服务器各自使用MS派生用于加密和报文完整的密钥，<span
class="math inline">\(E_C\)</span>和<span
class="math inline">\(E_S\)</span>表示客户端和服务器各自用于加密数据的会话密钥。<span
class="math inline">\(M_C\)</span>和<span
class="math inline">\(M_S\)</span>表示客户端和服务器各自用于验证数据完整的认证密钥。</p>
<p>　　在数据传输阶段，TCP是一种字节流协议，为了传输流的同时验证数据完整性，SSL将数据流分成多个<strong>记录</strong>，每个记录附加一个认证密钥来验证完整性。为了防御重排序或重放报文段，SSL使用了序号，序号从0开始并随着发送的每条SSL记录递增，SSL记录中并不包含序号，而是在计算MAC时加入序号，即数据加认证密钥加当前序号的散列值。对方跟踪序号并在验证数据完整性的计算中加入序号。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/ssl_record_format.svg" class="">
<p>　　SSL记录由类型、版本、长度、数据和MAC组成。前三个字段不加密。类型表示报文类型(握手报文或数据报文)，也用于关闭SSL。虽然SSL的关闭连接直接使用了TCP关闭连接，这为<strong>截断攻击</strong>创造了条件，即攻击者使用TCP
FIN来关闭连接，但SSL记录中指示了记录类型加上MAC可以防止截断攻击。</p>
<p>　　SSL并未规定加密算法的选择，它允许在SSL会话开始时就加密算法取得一致。</p>
<p>　　1)
客户端发送它支持的加密算法列表和客户端不重数。不重数是为了防御连接重放攻击，即攻击者重放从建立连接到关闭连接的所有报文。</p>
<p>　　2)
服务器选择一种对称加密算法、一种非对称加密算法和一种MAC算法并将它的选择、证书以及服务器不重数返回给客户端。</p>
<p>　　3)
客户端验证证书，提取服务器的公钥，生成一个<strong>前主密钥</strong>，用服务器的公钥加密PMS并发送给服务器。</p>
<p>　　4)
客户端和服务器使用相同的密钥派生函数并各自根据PMS和不重数计算MS，然后对MS进行切片以生成两个密钥和认证密钥。此外，对称加密中的CBC的IV也从MS获得。</p>
<p>　　5) 客户端和服务器分别发送各自握手报文的MAC。</p>
<h3 id="ipsec和vpn">7.6 IPsec和VPN</h3>
<p>　　<strong>互联网安全协议</strong>为网络层提供安全性，保护任意两个网络层实体间的IP数据报，可以用来建立VPN。IPsec提供了保密性、源认证、数据完整性和重放攻击防护。</p>
<p>　　与互联网完全分离的物理网络称为<strong>专用网络</strong>。</p>
<p>　　VPN的流量通过互联网而不是专用网络发送，流量在进入互联网前会加密。</p>
<p>　　IPsec协议族中的主要协议有<strong>认证首部</strong>协议和<strong>封装安全有效载荷</strong>协议。AH协议提供源认证和数据完整性但<span
style="background-color: yellow">不</span>提供保密性。ESP协议提供源认证、数据完整性和保密性。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/sa.svg" class="">
<p>　　在源使用和目的实体发送IPsec数据报之前先建立称为<strong>安全联盟</strong>的网络层逻辑连接。一个SA是单工逻辑连接，如果两个实体需要互相发送IPsec数据报则需要创建两个SA。并非所有网关路由器或主机发送到互联网的流量都受到IPsec保护。</p>
<p>　　IPsec实体将其所有SA的状态信息存储在其<strong>安全联盟数据库</strong>中，该数据库是实体操作系统内核中的一个数据结构，需要维护的SA的状态信息包括称为<strong>安全参数索引</strong>的32位SA标识符、SA的源接口IP地址、SA的目的接口IP地址、将要使用的加密算法类型、加密密钥、完整性验证的类型以及认证密钥。IPsec实体还维护一个称为<strong>安全策略数据库</strong>的数据结构，SPD指示哪些类型(IP地址和协议类型)的数据报将被作为IPsec处理并指定SA。</p>
<p>　　IPsec数据报有<strong>隧道模式</strong>和<strong>传输模式</strong>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/esp_tunnel_mode_datagram_format.svg" class="">
<p>　　IP数据报转换成ESP隧道模式数据报时，先在IP数据报后面附上ESP尾部并使用SA指定的算法和密钥对这部分(IP数据报和ESP尾部)加密。在这个加密部分的前加上ESP首部并附加MAC形成有效载荷，最后加上新的IP数据报首部形成一个IP数据报。</p>
<p>　　新IP数据报首部源IP地址和目的IP地址是隧道两端路由器的接口，其协议号设置为50，表示使用ESP协议的IPsec数据报。</p>
<p>　　ESP尾部包括填充字段、填充长度和下个首部，下个首部长度表示原IP数据报有效载荷(报文段)的类型。</p>
<p>　　ESP首部包括SPI和序号，SPI表示数据报所属SA，然后接收实体可以使用SPI搜索器SAD以确定对应的认证/加密算法和密钥。序号用于重放攻击防护。</p>
<p>　　IPsec使用<strong>互联网密钥交换</strong>协议来自动创建SA。IKE协议与SSL中握手有些类似，每个IPsec实体都有一个证书，其中包括实体的公钥。两个实体交换证书、协商认证和加密算法并安全地交换密钥材料以在SA中生成会话密钥。与SSL不同的是，IKE通过两次报文交换来完成这些。</p>
<p>　　● 在首次报文交换期间，双方使用DH算法在路由器间生成一个双向的IKE
SA，该IKE
SA在两台路由器间提供认证和加密的信道。双方还创建用于认证和加密的密钥和第二次报文交换期间将用到的MS。</p>
<p>　　●
在第二次报文交换期间，双方通过数字签名表明了身份，但嗅探器无法嗅探到这些身份，因为报文是通过IKE
SA信道发生的。双方还协商用于IPsec SA的加密和认证算法。</p>
<p>　　在IKE协议第二阶段，双方在每个方向建立一个SA。在第二阶段末时，为两个SA在双方建立加密和认证会话密钥。IKE协议有两个阶段的主要原因是计算成本，由于第二阶段不涉及任何非对称加密，IKE可以在两个IPsec实体间能以较低成本生成大量SA。</p>
<h3 id="wlan安全">7.7 WLAN安全</h3>
<p>　　802.11规范中标准化的安全机制称为<strong>有线等效保密</strong>协议，WEP协议旨在提供与有线网络类似的安全级别。</p>
<p>　　WEP协议使用对称共享密钥在无线站点和无线AP之间提供认证和加密。WEP协议并没有指定密钥管理算法，因此无线站点和无线AP通过带外方法以某种方式就密钥达成一致。无线站点请求无线AP进行认证，无线AP以128位的不重数响应，无线站点用共享对称密钥加密这个不重数并发送，无线AP收到后解密并和不重数比较。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/802.11_wep_protocol.svg" class="">
<p>　　若无线站点和无线AP共享40位的对称密钥<span
class="math inline">\(K_S\)</span>且<span
class="math inline">\(K_S\)</span>后附加24位的IV来创建用于加密单个帧的64位密钥。每个帧使用的IV都不同，IV以明文形式包含于每个WEP加密的802.11帧的首部中。对于64位密钥，RC4算法产生一个用于加密单个帧中的有效载荷和CRC值的密钥值的流<span
class="math inline">\(k^{IV}_1\)</span>、<span
class="math inline">\(k^{IV}_2\)</span>、<span
class="math inline">\(k^{IV}_3\)</span>，…，通过把有效载荷的第<span
class="math inline">\(i\)</span>位<span
class="math inline">\(d_i\)</span>和<span
class="math inline">\(k^{IV}_i\)</span>进行异或运算来进行加密产生密文<span
class="math inline">\(c_i=d_i\oplus
k^{IV}_i\)</span>，解密同样也是异或运算<span
class="math inline">\(d_i=c_i\oplus k^{IV}_i\)</span>。</p>
<p>　　对于给定<span class="math inline">\(K_S\)</span>只有<span
class="math inline">\(2^{24}\)</span>个密钥可用，若进行随机选择则在处理12000帧后重复的概率超过99%。攻击者通过IP哄骗的等方式来获取内容已知的加密帧，通过<span
class="math inline">\(d_i\oplus c_i=K^{IV}_i\)</span>可以获取<span
class="math inline">\(K^{IV}_i\)</span>，当攻击者再次嗅探到相同的IV时可以对其进行解密。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/802.11i.svg" class="">
<p>　　相比WEP，802.11i提供了更强大的加密形式、可扩展的认证机制集合和密钥分发机制。802.11i除了无线站点和无线AP，还有认证服务器。认证服务器与无线AP分离允许一个认证服务器为多个无线AP服务，将认证和访问的决策集中在单个服务器内，并降低无线AP的成本和复杂性。</p>
<p>　　1)
在发现阶段，无线AP通告它的存在以及它能够给无线站点提供认证和加密的形式。无线站点请求所需形式的认证和加密。虽然无线站点和无线AP已经在交换报文，但无线站点尚未认证，也没有加密密钥。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/eap.svg" class="">
<p>　　2)
在相互认证和MK生成阶段，AP作为中继在无线站点和认证服务器间转发报文。<strong>可扩展认证协议</strong>定义了无线站点和认证服务器间的报文格式。EAP使用EAPOL封装并通过802.11无线链路发送，EAP报文在无线AP拆封并使用RADIUS协议重新封装以便通过UDP/IP传输给认证服务器。802.11i并未规定认证方法，但常使用EAP
TLS认证方案。EAP
TLS使用了非对称加密(不包括不重数和散列算法)来实现无线站点和认证服务器相互认证并派生共享的MS。</p>
<p>　　3)
在生成<strong>成对主密钥</strong>阶段，MK是仅无线站点和认证服务器所共享的密钥，它们各自使用它来生成第二个密钥，即PMK。认证服务器向无线AP发送PMK。现在无线站点和无线AP共享密钥且相互认证。</p>
<p>　　4)
在生成<strong>临时密钥</strong>阶段，无线站点和无线AP可以生成用于通信的附加密钥。其中的关键是TK，TK用于通过无线链路发送的数据的链路层加密。</p>
<p>　　802.11i提供了多次加密形式，包括基于AES的加密方案和WEP加密的增强版本。</p>
<h3 id="防火墙和入侵检测系统">7.8 防火墙和入侵检测系统</h3>
<h4 id="防火墙">7.8.1 防火墙</h4>
<p>　　<strong>防火墙</strong>是硬件和软件的组合，它将内网与整个互联网隔开，允许部分分组通过并阻止其他分组。防火墙允许网络管理员通过管理进出这些资源的流量来控制互联网和受管网络内的资源之间的访问。防火墙的目标包括<span
style="background-color: yellow">进出受管网络的流量都必须通过防火墙</span>，<span
style="background-color: yellow">仅允许本地安全策略定义的授权流量通过</span>以及<span
style="background-color: yellow">防火墙本身免于渗透</span>。</p>
<p>　　防火墙包括<strong>传统分组过滤器</strong>、<strong>状态过滤器</strong>和<strong>应用程序网关</strong>。</p>
<p>　　一个组织通常有一个网关路由器，将其内网连接到其ISP或互联网。所有进出内网的流量都经过这个路由器，<strong>分组过滤</strong>在这个路由器上进行。</p>
<p>　　传统分组过滤器单独检查每个数据报并根据过滤规则来确定转发或丢弃数据报。过滤决策通常基于IP地址、数据报中协议类型、端口、TCP标志位(SYN和ACK等)、ICMP报文类型、数据报出入网络的规则以及不同路由器接口的不同规则。</p>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr>
<th>策略</th>
<th>防火墙设置</th>
</tr>
</thead>
<tbody>
<tr>
<td>无外部Web访问</td>
<td>丢弃所有到任何IP地址、端口80的分组</td>
</tr>
<tr>
<td>除访问内网的公共Web服务器外无入TCP连接</td>
<td>丢弃所有到除指定IP地址、端口80外的任何IP地址的入TCP SYN分组</td>
</tr>
<tr>
<td>防止Web无线电占用带宽</td>
<td>丢弃除DNS分组外的所有入UDP分组</td>
</tr>
<tr>
<td>防御smurf dos攻击</td>
<td>丢弃所有到指定广播地址的ICMP ping分组</td>
</tr>
<tr>
<td>防止路由跟踪</td>
<td>丢弃所有ICMP TTL过期分组</td>
</tr>
</tbody>
</table>
<p>　　相比传统分组过滤器，状态过滤器实际跟踪的是TCP连接并可以根据TCP状态进行过滤。状态过滤器跟踪连接表中所有正在进行的TCP连接，通过三次握手来知晓新连接的开始，通过FIN分组或一段时间内未检查到连接活跃来知晓连接结束。</p>
<p>　　应用程序网关是应用程序特定的服务器，所有应用程序数据都必须通过它。多个应用程序网关可以在同一台主机上运行，但每个应用程序网关都有独立进程。除了IP/TCP/UDP首部，应用程序网关还根据应用数据做决策。　　应用程序网关并非没有缺点。首先，不同应用程序需要不同的应用程序网关。其次，由于所有的流量都通过应用程序网关进行中继，应用程序网关的负担较大。最后，当用户发送请求时客户端必须知道如何联系应用程序网关并告知其连接到对应的外部服务器。</p>
<p>　　实际中，一个机构的邮件服务器和Web缓存都是应用程序网关。</p>
<h4 id="入侵检测系统">7.8.2 入侵检测系统</h4>
<p>　　为了检测多种攻击类型，需要执行<strong>深度分组检测</strong>，即深入检测分组的有效载荷。应用程序网关经常进行DPI，但仅对特定的应用程序执行。</p>
<p>　　当检测到潜在恶意流量时发送警报的设备称为<strong>入侵检测系统</strong>。过滤可疑流量的设备称为<strong>入侵防御系统</strong>。由于IDS和IPS的重要技术都是检测可疑流量，所以将IDS和IPS统称IDS。</p>
<p>　　IDS可用于检测多种攻击，包括网络映射(例如，使用nmp分析)、端口扫描、TCP栈扫描、DOS带宽泛洪攻击、蠕虫、病毒、操作系统漏洞攻击和应用程序漏洞攻击。</p>
<p>　　IDS大致分为<strong>基于特征的IDS</strong>和<strong>基于异常的IDS</strong>。基于特征的IDS维护了一个范围广泛的攻击特征数据库。每个特征是与一个入侵活动相关的一组规则。特征可能是单个或多个分组相关的特征列表(端口、协议类型或特定位串等)，当分组符合特征时发送警报，但实际中可能由于各种情况无效或误报。基于异常的IDS观测正常流量时会生成一个流量概况文件并查找在统计上异常的分组流，但区分正常流量和在统计上异常的流量仍是一个挑战。</p>
<p>　　一个机构可能在其内网部署一个或多个IDS传感器。由于IDS不仅需要进行DPI，还需要将每个分组与诸多的特征比较，这可能是极大的处理量，因此可能需要多个IDS传感器。将IDS传感器放置在更下游的位置，每个IDS传感器仅能检测到部分流量，这样更易于维护。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_07/ids.svg" class="">
<p>　　当部署多个IDS传感器时，它们通常协同工作，将有关可疑流量的信息发送到中心IDS处理器，中心IDS处理器收集并综合这些信息，当时机合适时发送警报。该机构将内网划分为较高安全区和称为<strong>隔离区</strong>的较低安全区，较高安全区由分组过滤器和应用程序网关保护，DMZ仅由分组过滤器保护，它们都受IDS传感器监控。DMZ包括了该机构需要与互联网通信的服务器，例如，Web服务器、FTP服务器和权威DNS服务器等。实际中，有很多高性能的IDS和IPS供使用，因此有些机构仅需一个位于接入路由器附近的IDS传感器。</p>
<p>　　Snort是一个公共域的开源IDS，它使用通用嗅探接口libpcap(Wireshark和其他分组嗅探器也使用该接口)。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第8章 多媒体网络</title>
    <url>/network/computer_networking_a_top_down_approach_7e_chpt_08/</url>
    <content><![CDATA[<p>　　视频最为显著的特点是<strong>高比特率</strong>，另一个重要特点是可以被压缩，从而在视频质量和比特率之间权衡。视频有两种类型的冗余，都可以用来进行<strong>视频压缩</strong>。<span
style="background-color: yellow">空间冗余</span>是给定图像的内部冗余，主要由空白组成的图像具有高度冗余，可以在不牺牲图像质量下进行冗余。<span
style="background-color: yellow">时间冗余</span>反映了图像间的重复。可以通过压缩来生成<strong>多重版本</strong>的视频，不同版本具有不同的质量等级。</p>
<p>　　模拟音频信号以某个固定速率进行采样，每个采样值近似取值为有限数量的值之一，该过程称为<strong>量化</strong>，这些值的数量称为<strong>量化值</strong>，通常是2的幂。每个量化值由固定数量的位表示。解码后的的信号只是原始信号的近似值，音质可能有所下降(可能丢失高频的声音)。增加采样率和量化值的数量可以让解码后的信号更接近原始信号。</p>
<p>　　<strong>脉冲编码调制</strong>是一种音频编码技术，语音使用的PCM采用速率是每秒8000个样本，每个样本用8位表示，因此速率是<span
class="math inline">\(64Kb/s\)</span>。音频光盘使用的PCM采用速率是每秒44100个样本，每个样本用16位表示，单声道速率为<span
class="math inline">\(705.6Kb/s\)</span>，立体声速率为<span
class="math inline">\(1.411Mb/s\)</span>。</p>
<p>　　压缩也可以用于降低音频流的比特率，人类语音可以压缩到小于<span
class="math inline">\(10Kb/s\)</span>且依旧可以理解。用于接近CD质量的立体声音乐的流行压缩技术是<strong>MP3</strong>(MPEG
1 layer 3)，MP3编码器可以压缩到不同的速率，<span
class="math inline">\(128Kb/s\)</span>的编码速率可以保证很小的声音失真，一种相关标准是<strong>高级音频编码</strong>。</p>
<p>　　多媒体应用大致可以分为<span
style="background-color: yellow">流式存储音频/视频</span>、<span
style="background-color: yellow">会话式IP语音/视频</span>和<span
style="background-color: yellow">流式实况音频/视频</span>。</p>
<p>　　<strong>流式传输</strong>时，客户端在从服务器接收音频/视频一段时间后就可以播放，在播放的同时继续接收剩余部分，避免了在播放前需要接收整个文件。</p>
<p>　　●
流式存储视频依赖的媒体是服务器上预先录制的视频，用户向服务器请求以按需观看视频。流式存储视频的特点是<strong>流媒体</strong>、<strong>交互性</strong>和<strong>不间断播放</strong>。由于视频是预先录制的，用户可以进行快进等操作并获得即时响应。视频播放开始后应按照录制的时序进行，因此必须从服务器及时接收数据。流式存储音频与流式存储视频相同。</p>
<p>　　●
互联网上的实时会话式语音通常称为<strong>网络电话</strong>或<strong>IP语音</strong>。因为从用户的角度，它类似于传统的电话交换服务。会话式语音/视频是<span
style="background-color: yellow">时延敏感</span>但<span
style="background-color: yellow">容忍丢包</span>的。</p>
<p>　　●
流式实况音频/视频类似于传统的电台和电视，只是它通过互联网传输。</p>
<p>　　分发存储和实况视频经常使用CDN。</p>
<p>　　对于VOIP等会话时实时应用，重传一个错过预计播放时间的分组没有意义。</p>
<span id="more"></span>
<h3 id="流式存储视频">8.1 流式存储视频</h3>
<p>　　流式视频系统分为<strong>UDP流</strong>、<strong>HTTP流</strong>和<strong>自适应HTTP流</strong>。这三种形式的视频流的共同特点是广泛使用了客户端应用程序的缓存来减轻变化的的端到端时延以及变化的客户端和服务器间可用带宽的影响。这种<strong>客户端缓存</strong>不仅可以吸收服务器到客户端时延中的波动，而且当其未完全耗尽时，即使服务器到客户端的带宽暂时低于视频消耗速率，客户端也能维持不间断播放。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/client_playout_delay_in_video_streaming.svg" class="">
<p>　　假设视频以固定的比特率编码，因此每个视频块包含在固定时间<span
class="math inline">\(\Delta\)</span>播放的视频帧。服务器在<span
class="math inline">\(t_0\)</span>传输第一个视频块，在<span
class="math inline">\(t_0+\Delta\)</span>传输第二个视频块，依此类推。一旦客户端开始播放，每个块应该在前一个块之后播放<span
class="math inline">\(\Delta\)</span>时间单元来保证原始视频录制时的时序。若在<span
class="math inline">\(t_1\)</span>就开始播放视频则第二块不能在<span
class="math inline">\(t_1+\Delta\)</span>内到达，相反，若<span
class="math inline">\(t_3\)</span>开始播放，此时前6块已到达，所有收到的块都能按序且不间断地播放。</p>
<h4 id="udp流">8.1.1 UDP流</h4>
<p>　　UDP流通常使用的客户端缓存较小。由于UDP没有拥塞控制，服务器能够以客户端的视频消耗速率的传输视频。在视频块传递给UDP前，服务器将视频块封装在传输分组中，该传输分组专为传输音频/视频设计，使用了<strong>实时传输协议</strong>或<strong>会话发起协议</strong>等类似的方案。RTP可用于传输常见格式和专用的音频和视频格式，它也是其他实时交互协议(如<strong>生成树协议</strong>)的补充。SIP是一个开放的轻量级协议。</p>
<p>　　使用UDP时，除了服务器到客户端的视频流外，客户端和服务器还同时维护一个单独的控制链接，客户端通过该连接发送有关会话状态变化的命令(如暂停、重新开始、重定位等)，<strong>实时流传输协议</strong>是一种用于这种控制连接的协议。</p>
<p>　　UDP存在三个重大缺陷，首先，由于服务器和客户端之间的可用带宽不可预测且不断变化，因此恒定速率UDP流不一定能保证不间断播放。其次，需要RTSP服务器这样的媒体控制服务器来为每个正在进行的客户端会话处理客户端到服务器的交互请求并跟踪客户端状态，这增加了大规模部署成本和复杂性。最后，许多防火墙配置为阻止UDP流量。</p>
<h4 id="http流">8.1.2 HTTP流</h4>
<p>　　在HTTP流中，
视频作为具有特定URL的文件存储在HTTP服务器上。当用户要观看视频时，客户端与服务器建立一个TCP连接并对该URL发起HTTP
GET请求。服务器在HTTP响应报文中发送该视频文件，即以TCP拥塞控制和流控制允许的情况下尽快发送。在客户端，数据被收集在客户端应用程序缓存中。当缓存中的字节数达到阈值就开始播放，它周期性地从客户端应用程序缓存中读取视频帧，对帧解压并在用户屏幕上显示。</p>
<p>　　对于流式存储视频，客户端能够以高于消耗速率的速率下载视频，从而<strong>预取</strong>将被消耗的视频帧。当平均TCP吞吐量大约是媒体比特率的两倍时，TCP流达到最小的饥饿和低缓存时延。</p>
<p>　　由于TCP的拥塞控制机制，服务器到客户端的传输速率可能波动很大，而且分组可能由于重传机制而出现较大的时延。使用了客户端缓存和预取后，这些不一定会妨碍不间断播放。</p>
<p>　　HTTP基于TCP，因此更容易穿越防火墙和NAT。HTTP流无需媒体控制服务器，从而减低大规模部署的成本。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/streaming_stored_video_over_http.svg" class="">
<p>　　服务器的视频文件通过套接字后，字节在传输到互联网前存放在TCP发送缓存，当服务器的TCP发送缓存已满时，服务器暂时无法将更多的字节从视频文件发送到套接字。客户端应用程序从TCP接收缓存(通过套接字)读取字节并将字节存放到客户端缓存。同时客户端应用程序周期性地从客户端缓存抓取视频帧并解压播放。若客户端缓存大于该视频文件则从客户端直接按照TCP允许的最快速率从服务器接收视频。</p>
<p>　　当客户端缓存变满时，可能会导致TCP接收缓存边满，进而TCP发送缓存也会变满，服务器不能向套接字中发送字节。因此，播放暂停可能服务器被迫停止传输直到继续播放。在常规的播放中，若客户端缓存变满，进而导致TCP缓存变满，迫使服务器降低发送速率，因此服务器的发送速率不能高于客户端视频消耗速率。因此，当使用HTTP流时，满的客户端缓存间接地限制了服务器到客户端的传输速率。</p>
<p>　　<span
class="math inline">\(B(b)\)</span>表示客户端应用程序的缓存，<span
class="math inline">\(Q(b)\)</span>表示客户端应用程序开始播放前必要的缓存。<span
class="math inline">\(r(b/s)\)</span>表示视频消耗速率。只要客户端应用程序的缓存未满，服务器会以恒定速率<span
class="math inline">\(x(b/s)\)</span>发送数据，则经过<span
class="math inline">\(t_{play}=\frac{Q}{x}\)</span>后首次播放。若<span
class="math inline">\(x&lt;r\)</span>，客户端在开始播放后应用程序缓存会以<span
class="math inline">\(r-x\)</span>的速率消耗，在<span
class="math inline">\(t_{pause}=\frac{Q}{r-x}\)</span>后出现停滞，再经过<span
class="math inline">\(t_{play}\)</span>后开始播放，一直循环这个过程直至结束。若<span
class="math inline">\(x&gt;r\)</span>，客户端在开始播放后应用程序缓存会以<span
class="math inline">\(x-r\)</span>的速率增加，经过<span
class="math inline">\(t_{full}=\frac{B-Q}{x-r}\)</span>后应用程序缓存达到最大值，播放开始后不会停滞。</p>
<p>　　现在进一步假设服务器发送数据的速率<span
class="math inline">\(x\)</span>不是恒定，初始为0，在<span
class="math inline">\(T(s)\)</span>后<span
style="background-color: yellow">线性增长</span>到最大值<span
class="math inline">\(H(b/s)\)</span>，然后变为0并再次线性增长，一直循环这个过程。为了保证不会停滞，需要<span
class="math inline">\(\overline{x}&gt;r\)</span>，因此<span
class="math inline">\(H&gt;2r\)</span>。当<span
class="math inline">\(x\)</span>从0开始线性增长时，其加速度<span
class="math inline">\(\alpha=\frac{H}{T}\)</span>，期间服务器发送数据<span
class="math inline">\(D=\frac{Ht^2}{2T}(b)\)</span>。</p>
<p>　　若需要保证<span class="math inline">\(Q\)</span>最小，则需要<span
class="math inline">\(x\)</span>从0增长到<span
class="math inline">\(r\)</span>期间消耗的数据刚好为<span
class="math inline">\(Q\)</span>，因此<span
class="math inline">\(Q_{min}=\frac{r^2}{2a}=\frac{Tr^2}{2H}\)</span>。</p>
<p>　　HTTP流经常使用HTTP
GET请求报文中的<strong>HTTP字节范围首部</strong>，用来指定客户端当前想要从所需视频中检索的特定字节范围。当需要跳转到视频中未播放的某个时间点时，客户端发送一个新HTTP请求，用字节范围首部指示服务器应该从文件中的对应字节发送，服务器收到后从字节范围首部指示的字节开始发送。当视频跳转到未播放的某个时间点或提前终止时，服务器传输的一些预取但未播放的视频将跳过，导致相关的带宽和服务器资源浪费，无线链路浪费的带宽和服务器资源可能更多。因此，很多流系统进使用了适当的客户端缓存或者使用HTTP请求中的字节范围首部来限制预取的视频。</p>
<h3 id="ip语音">8.2 IP语音</h3>
<p>　　VOIP一般默认使用UDP，当用户位于阻止UDP的NAT或防火墙后时才使用TCP。UDP存在丢包的问题，TCP没有丢包的问题，但TCP的重传会增加端到端时延，而且丢包后由于拥塞控制，发送端的传输速率可能降低到低于接收端的消耗速率，从而可能导致缓存饥饿。</p>
<p>　　实际中，VOIP可以容忍1%到20%的丢包，这取决于语音的编码、传输方式以及接收端隐藏丢包的方式。使用FEC将冗余信息和原始信息一起发送，能够从冗余信息中恢复一些丢失的初始数据。丢包率超过10%~20%则无法采取任何措施来恢复可接受的音频质量。</p>
<p>　　对于VOIP，小于150ms的时延收听者察觉不到，150ms~400ms的时延可以接受，但不够理想，超过400ms就影响语音交谈的质量。因此，VOIP应用程序的接收端通常忽略时延超过阈值的所有分组。</p>
<p>　　分组在路由器中经历的变化的排队时延是端到端时延的组成部分之一，因此发送端生成分组到接收端接收到分组的时间可能随着分组的变化而波动，称为<strong>时延抖动</strong>。</p>
<p>　　时延抖动可以通过<strong>序号</strong>、<strong>时间戳</strong>和<strong>播放时延</strong>来消除。发送端为每个音频块标记其生成时间。类似于流式存储视频的播放时延，接收端的音频块的播放时延必须足够大，以便大多数分组在其预计播放时间之前接收，播放时延可以固定或自适应。</p>
<h4 id="在接收端消除时延抖动">8.2.1 在接收端消除时延抖动</h4>
<p>　　使用固定延迟策略时，接收端尝试在块生成后<span
class="math inline">\(q(ms)\)</span>播放，若块在<span
class="math inline">\(t(ms)\)</span>时被标记时间戳，则接收端在<span
class="math inline">\(t+q\)</span>播放该块，若该块在<span
class="math inline">\(t+q\)</span>后到达则会被丢弃并视为丢包。若网络时延经常出现较大的变化则<span
class="math inline">\(q\)</span>较大更好，若网络时延较小且变化也较小则<span
class="math inline">\(q&lt;150ms\)</span>更好。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/packet_loss_for_different_fixed_playout_delays.svg" class="">
<p>　　对于第一个固定播放时延<span
class="math inline">\(p-r\)</span>，第4个分组在预计时间未到达则认为丢包。对于第二个固定播放时延<span
class="math inline">\(p&#39;-r\)</span>，所有分组都在预计时间内到达。</p>
<p>　　为了尽可能小的播放时延，可以估计网络时延及其变化并在每次语音的突发期开始时相应地调整播放时延，这会导致发送端的静默期的压缩或拉长。对于第<span
class="math inline">\(i\)</span>个分组，<span
class="math inline">\(t_i\)</span>表示生成时间，<span
class="math inline">\(r_i\)</span>表示接收时间，<span
class="math inline">\(p_i\)</span>表示播放时间，<span
class="math inline">\(r_i-t_i\)</span>表示网络时延，<span
class="math inline">\(d_i\)</span>表示收到该分组时的平均网络时延的估计值。<span
class="math inline">\(u\)</span>表示大于0而小于1的常数。 <span
class="math display">\[
d_i=(1-u)d_{i-1}+u(r_i-t_i)
\]</span> 　　<span
class="math inline">\(v_i\)</span>表示估计网络时延与估计的平均网络时延的平均偏差的估计值。
<span class="math display">\[
v_i=(1-u)v_{i-1}+u|r_i-t_i-d_i|
\]</span> 　　若分组<span
class="math inline">\(i\)</span>是语音突发期首个分组，则<span
class="math inline">\(p_i=t_i+d_i+Kv_i\)</span>，<span
class="math inline">\(K\)</span>是一个正的常数，<span
class="math inline">\(Kv_i\)</span>用于将播放时间设置到足够大，保证语音突发期的分组丢包率较低。突发期内之后的每个分组的播放时间被计算为该突发期内首个分组的播放时间的偏移量。语音突发期的首个分组生成到播放的时间跨度<span
class="math inline">\(q_i=p_i-t_i\)</span>，若分组<span
class="math inline">\(j\)</span>属于该突发期，它的播放时刻<span
class="math inline">\(p_j=t_j+q_i\)</span>。</p>
<h4 id="丢包恢复">8.2.2 丢包恢复</h4>
<p>　　VOIP通常使用<span
style="background-color: yellow">FEC</span>和<span
style="background-color: yellow">交织</span>这两种类型的<strong>丢包恢复方案</strong>。</p>
<p>　　FEC的基本思想是在初始的分组流增加冗余信息。以略微增加传输速率为代价，这些冗余信息可以用于重建一些丢失分组的近似或准确版本。</p>
<p>　　一种FEC机制是在每<span
class="math inline">\(n\)</span>个块后发送一个冗余编码块，冗余块通过异或<span
class="math inline">\(n\)</span>个初始块获得，由于接收端在播放前必须收到整个组的分组，因此增加了播放时延。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/piggybacking_lower-quality_redundant_information.svg" class="">
<p>　　第二种FEC机制是发送一个低质量的音频流作为冗余信息，发送端生成一个标称音频流和与一个相应的低分辨率、低比特率的音频流(标称流可以是<span
class="math inline">\(64Kb/s\)</span>的PCM编码，而低质量的流可以是<span
class="math inline">\(13Kb/s\)</span>的GSM编码。接收端在播放前只需接收两个分组，因此增加的时延较小。若低质量冗余音频的编码比标称音频小很多则增加的额外传输速率并不大。若需要处理连续丢失，发送端可以每个块附加更多低质量块，但同时也会增加传输带宽和播放时延。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/send_interleaved_audio.svg" class="">
<p>　　在交织中，发送端在传输前对音频数据单元重新排序，从而使传输流中原本相邻的单元分开。交织可以减轻丢包的影响从而提高音频流的质量。交织不增加流的带宽，且开销也较低，但增加了时延。</p>
<p>　　丢包恢复试图为丢失的分组产生一个相似的代替。音频信号表现除大量的短期自相似性，因此差错掩盖方案适用于丢失率较小(低于15%)和分组较小(小于音素)的场景，但损失长度接近音素的长度时，就会失效，因为听者可能听错。</p>
<h4 id="案例学习skype">8.2.3 案例学习：Skype</h4>
<p>　　对应音频和视频，Skype客户端使用多种不同的编码方式。Skype默认使用UDP发送音频和视频分组，但控制分组通过TCP发送，UDP被拦截时才使用TCP发送音频和视频分组。Skype客户端通过改变视频质量和FEC开销来使其发送的音频流和视频流适应当前网络环境。</p>
<p>　　Skype中除了主机间VOIP使用了P2P，用户定位和NAT穿透也使用了P2P。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/skype_peers.svg" class="">
<p>　　Skype中对等方组织成一个分层的覆盖网络，对等方分为超级对等方和普通对等方。Skype维护一个将用户映射到当前IP地址(和端口)的索引，该索引分布在超级对等方上。当A需要呼叫B时，客户端会搜索该分布式索引以决定B当前的IP地址。</p>
<p>　　NAT用于阻止外网的主机连接到内网主机，若A和B都有NAT，可以通过超级对等方和<strong>Skype中继</strong>来让A和B建立连接。A向非NAT的超级对等方建立连接，B也向非NAT的超级对等方建立连接。A通知A的超级对等方，A的超级对等方通知B的超级对等方，B的超级对等方再通知B。两个超级对等方选择第三个非NAT的超级对等方作为中继对等方，然后A、B都向中继对等方建立连接。</p>
<p>　　若<span
class="math inline">\(N(N&gt;2)\)</span>个参与者进行音频会议，每个参与者将音频流的副本发送给其他<span
class="math inline">\(N-1\)</span>个参与者，因此需将<span
class="math inline">\(N(N-1)\)</span>个音频流副本发送到网络中。为了减少带宽消耗，每个参与者向发起者发送其音频流，发起者将这些音频流结合为一个流(基本是将所有的音频流信号加在一起)并发送给其他<span
class="math inline">\(N-1\)</span>个参与者，因此需要将<span
class="math inline">\(2(N-1)\)</span>个音频流的副本发送到网络。</p>
<p>　　若<span
class="math inline">\(N(N&gt;2)\)</span>个参与者进行视频会议，视频并不能像音频一样结合为一个流且大多数接入链路的上行链路带宽明显低于下行链路带宽(上行链路可能无法支持P2P方式的<span
class="math inline">\(N-1\)</span>个视频流)，因此每个参与者的视频流被路由选择到一个服务器集群，该集群将该视频流中继给其他<span
class="math inline">\(N-1\)</span>个参与者。</p>
<h3 id="实时会话应用协议">8.3 实时会话应用协议</h3>
<h4 id="rtp">8.3.1 RTP</h4>
<p>　　若应用程序集成了RTP，而不是使用有限载荷类型、序号和时间戳这种专用方案，该应用程序更容易与其他应用程序交互。</p>
<p>　　RTP不提供任何机制来确保及时交互数据或提供其他QOS保证，也不保证分组交互或防止分组失序。RTP允许每个源(例如，一个麦克风或摄像头等)分配其独立的RTP分组流。很多编码技术将音频和视频捆绑在一个流中，因此也只产生一个RTP流。</p>
<p>　　RTP分组不仅限于单播应用，也可以经过一对多和多对多的多播树发送。对于多对多的多播会话，所有的发送端和源通常使用相同的多播组来发送RTP流。一起使用的RTP多播流(例如，视频会议中多个发送端发出的音频和视频流)同属于一个<strong>RTP会话</strong>。</p>
<p>　　对于语音，若语音源使用<span
class="math inline">\(64Kb/s\)</span>的PCM编码，每个编码数据的时间长度是20ms，即每个音频块有<span
class="math inline">\(160B\)</span>，发送端在每个音频块前添加一个RTP首部，RTP首部通常为<span
class="math inline">\(12B\)</span>，音频块和RTP首部一起形成<strong>RTP分组</strong>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/rtp_header_fields.svg" class="">
<p>　　RTP首部包括7位<strong>有限载荷类型</strong>、16位<strong>序号</strong>、32位<strong>时间戳</strong>、32<strong>位同步源标识符</strong>以及其他字段。</p>
<p>　　●
有限载荷类型字段表示音频/视频的编码类型。发送端可以在会话过程中改变编码。</p>
<table>
<thead>
<tr>
<th>有限载荷类型</th>
<th>媒体编码格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>PCM μ-law</td>
<td>采样率是8KHz，速率是<span class="math inline">\(64Kb/s\)</span></td>
</tr>
<tr>
<td>1</td>
<td>1016</td>
<td>采样率是8KHz，速率是<span
class="math inline">\(4.8Kb/s\)</span></td>
</tr>
<tr>
<td>3</td>
<td>GSM</td>
<td>采样率是8KHz，速率是<span class="math inline">\(13Kb/s\)</span></td>
</tr>
<tr>
<td>7</td>
<td>LPC</td>
<td>采样率是8KHz，速率是<span
class="math inline">\(2.4Kb/s\)</span></td>
</tr>
<tr>
<td>9</td>
<td>G.722</td>
<td>采样率是16KHz，速率是<span
class="math inline">\(48\sim64Kb/s\)</span></td>
</tr>
<tr>
<td>14</td>
<td>MPEG音频</td>
<td>采样率是90KHz</td>
</tr>
<tr>
<td>15</td>
<td>G.728</td>
<td>采样率是8KHz，速率是<span class="math inline">\(16Kb/s\)</span></td>
</tr>
<tr>
<td>26</td>
<td>MJPEG</td>
<td></td>
</tr>
<tr>
<td>31</td>
<td>H.261</td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>MPEG1视频</td>
<td></td>
</tr>
<tr>
<td>33</td>
<td>MPEG2视频</td>
<td></td>
</tr>
</tbody>
</table>
<p>　　●
发送端每发送一个RTP分组，序号加1，接收端根据序号来检测丢包和恢复分组。</p>
<p>　　● 时间戳表示RTP分组中第一位的采样时刻。</p>
<p>　　●
SSRC用于标识流的源。在RTP会话中通常每个流的SSRC不同。当新的流生成时分配随机数，若两个流分配的SSRC相同则重新分配SSRC。</p>
<h4 id="sip">8.3.2 SIP</h4>
<p>　　SIP是常用于发起和结束呼叫的信令协议，可以用于视频会议和基于文本的会话。实际中，SIP可以作为即时通信应用程序的基本组件。</p>
<p>　　SIP提供了通过IP网络在呼叫者和被呼叫者间建立呼叫的机制，允许呼叫者通知被呼叫者将要开始呼叫，允许参与者就媒体编码达成一致，也允许参与者接收呼叫。</p>
<p>　　SIP为呼叫者提供被呼叫者的当前IP地址。用户可能没有固定IP地址，因为它们可能动态分配IP地址或使用多个IP设备。</p>
<p>　　SIP提供了呼叫管理机制，例如，呼叫期间添加新媒体流、呼叫期间更改编码、呼叫期间邀请新新参与者、呼叫转移和呼叫保持等。</p>
<p>　　SIP是一个带外协议，发送和接收SIP报文使用了不同于发送和接收媒体数据的套接字。SIP报文是ASCII，与HTTP报文类似。SIP要求所有的报文都有确认，因此能够在UDP或TCP上运行。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/call_establishment_when_ip_address_is_known.svg" class="">
<p>　　当A知道B的IP地址时，A通过UDP向B的5060端口发送一个INVITE报文(类似于HTTP请求报文)，此时一个SIP会话开始。INVITE报文包括B的标识符、A当前IP地址、A希望接收的音频格式以及接收端口。B收到INVITE报文后向A的5060端口发送SIP响应报文(类似于HTTP响应报文)，SIP响应报文包括<code>200 OK</code>、B当前IP地址、B希望接收的音频格式以及接收端口。A收到SIP响应报文后响应SIP
ACK报文，然后双方就可以开始发送音频。</p>
<p>　　若B在收到A的INVITE报文后发现不支持A希望接收的音频编码，则会响应<code>606 NOT Acceptable</code>并在报文中列出支持的编码。A从中选择一个编码并再发送一个INVITE报文。B也能直接发送表示拒绝的代码来拒绝呼叫。</p>
<p>　　B的SIP地址是<code>B@193.64.210.89</code>，实际上SIP地址可能类似于email地址或电话号码或姓名等。SIP可以包含于Web页面中，当访问者点击SIP地址，访问者设备中SIP应用将启动并向该SIP地址发送INVITE报文。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">INVITE sip:B@domain.com SIP/2.0</span><br><span class="line"><span class="attribute">Via</span><span class="punctuation">: </span>SIP/2.0/UDP 167.180.112.24</span><br><span class="line"><span class="attribute">From</span><span class="punctuation">: </span>sip:A@hereway.com</span><br><span class="line"><span class="attribute">To</span><span class="punctuation">: </span>sip:B@domain.com</span><br><span class="line"><span class="attribute">Call-ID</span><span class="punctuation">: </span>a2e3a@pigeon.hereway.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/sdp</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>885</span><br><span class="line"> </span><br><span class="line">c=IN IP4 167.180.112.24</span><br><span class="line">m=audio 38060 RTP/AVP 0</span><br></pre></td></tr></table></figure>
<p>　　<code>INVITE</code>行包含SIP版本。每当SIP报文通过SIP设备(包括产生该报文的设备)时，它附加一个<code>Via</code>首部来指示该设备的IP地址。SIP报文包含一个<code>From</code>首部行和一个<code>To</code>首部行。<code>Call-ID</code>是呼叫的唯一标识符。<code>Content-Type</code>表示SIP报文中内容的格式。在一个换车和换行后就是报文的内容部分。</p>
<p>　　每个SIP用户都有一个相关联的<strong>SIP注册器</strong>。SIP注册器的功能类似于权威DNS，将SIP地址转换为IP地址。SIP注册器和<strong>SIP代理</strong>通常运行在同一台设备上。每当启动SIP应用程序时都会向SIP注册器发送SIP注册报文来告知它的当前IP地址。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">REGISTER sip:domain.com SIP/2.0</span><br><span class="line"><span class="attribute">Via</span><span class="punctuation">: </span>SIP/2.0/UDP 193.64.210.89</span><br><span class="line"><span class="attribute">From</span><span class="punctuation">: </span>sip:B@domain.com</span><br><span class="line"><span class="attribute">To</span><span class="punctuation">: </span>sip:B@domain.com</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>3600</span><br></pre></td></tr></table></figure>
<p>　　<code>Expires</code>表示注册有效期，过期后需要重新向SIP注册器注册。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/sip_session_initiation.svg" class="">
<p>　　若当前IP地址为217.23.56.89的A需要对当前IP地址为197.87.54.21的B发起VOIP会话，A向hereway的SIP代理发送INVITE报文，该代理在注册器上对domain进行DNS查询并将报文转发给domain的SIP注册器。由于B并没有在domain的SIP注册器上注册，该注册器返回一个重定向到temp的应答。hereway的SIP代理向temp的SIP注册器发送INVITE报文，temp的SIP注册器将INVITE报文转发给B，B收到返回SIP响应，temp的SIP注册器将SIP响应转发给hereway的SIP代理并进一步转发给A。至此A、B可以开始传输音频(还有个SIP
ACK)。</p>
<h3 id="多媒体网络">8.4 多媒体网络</h3>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 20%" />
<col style="width: 16%" />
<col style="width: 35%" />
<col style="width: 5%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>方法</th>
<th>粒度</th>
<th>保证</th>
<th>机制</th>
<th>复杂度</th>
<th>当前部署状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>尽力而为服务</td>
<td>公平处理所有流量</td>
<td>无/软</td>
<td>应用级支持，CDN，覆盖网络，网络级资源供给</td>
<td>最小</td>
<td>无处不在</td>
</tr>
<tr>
<td>区分服务</td>
<td>不同类型的流量处理不同</td>
<td>无/软</td>
<td>分组标识，监管，调度</td>
<td>中等</td>
<td>部分</td>
</tr>
<tr>
<td>每个连接QOS保证</td>
<td>每个源到目的地流处理不同</td>
<td>一旦流被准入，软/硬</td>
<td>分组标识，监管，调度，呼叫准入和信令</td>
<td>高</td>
<td>很少</td>
</tr>
</tbody>
</table>
<p>　　<strong>带宽供应</strong>指在给定拓扑中能达到给定性能水平的网络链路容量。<strong>网络定制</strong>指设计一个能达到给定水平端到端性能的网络拓扑。</p>
<p>　　为了预测端到端的应用程序级性能，需要考虑<span
style="background-color: yellow">端到端间的流量需求模型</span>、<span
style="background-color: yellow">明确定义的性能要求</span>和<span
style="background-color: yellow">用于预测给定负载模型的端到端性能模型并求出满足所有用户需求的最低成本带宽</span>。</p>
<h4 id="提供多种类型的服务">8.4.1 提供多种类型的服务</h4>
<p>　　在聚合流量(多种流量类型而不是单个连接)中提供了DS。相同类型的流量受到相同的服务，而与它们的所属的端到端连接无关。通过少量的聚合流量而不是大量的单个连接，提供优于尽力而为服务的新型网络机制更简单。</p>
<p>　　<strong>分组标记</strong>使得路由器区分属于不同类型流量的分组。在流量类型间提供一定程度的<strong>流量隔离</strong>防止某类流量受到另一类异常流量的负面影响，同时尽可能地保证资源利用率最大化。</p>
<p>　　一种实现流量隔离的方法是<strong>流量监管</strong>，若需要流量类型或流满足某些准则，可以设置监控机制以确保准则的确被遵守。若被监管的应用程序行为异常，则采取某种行动(丢包或延时)以确保其进入网络的流量符合准则。分组分类、分组标记和流量监管都一起在网络边缘或端系统或边界路由器中实现。另一种实现流量隔离的方法是链路级的分组调度机制为每种流量类型明确地分配固定的链路带宽。</p>
<p>　　流量监管有<span
style="background-color: yellow">平均速率</span>、<span
style="background-color: yellow">峰值速率</span>和<span
style="background-color: yellow">突发大小</span>这3个监管准则。平均速率用于限制较长时间内可以发送网络中的流量，峰值速率用于限制较短时间内可以发送的最大分组数量，突发大小用于限制瞬时发送到网络中分组数量。</p>
<p>　　漏桶机制是可用于描述流量监管准则的一种抽象，一个漏桶可以容纳<span
class="math inline">\(b\)</span>个令牌。可能潜在地添加到桶中的新令牌总是以<span
class="math inline">\(r\)</span>个每秒的速率生成。当生成一个新令牌时，若桶中的令牌数量少于<span
class="math inline">\(b\)</span>则将新令牌添加到桶中，否则，忽略该令牌。</p>
<p>　　漏桶机制可以用来监管分组。若分组被进入到网络之前，它必须先从桶中取出一个令牌。若桶为空，则分组必须等待令牌(或丢弃分组)。桶最多可以容纳<span
class="math inline">\(b\)</span>个令牌，因此最大突发大小是<span
class="math inline">\(b\)</span>个分组。由于令牌生成速率是<span
class="math inline">\(r\)</span>，因此长度为<span
class="math inline">\(t\)</span>的时间间隔内，可以进入网络的最大分组数为<span
class="math inline">\(rt+b\)</span>。此外，令牌的生成速率<span
class="math inline">\(r\)</span>用于限制长期内分组进入网络的平均速率。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/leaky_bucket_policer.svg" class="">
<p>　　可以通过串联漏桶来监管流量的峰值速率，第一个漏桶以<span
class="math inline">\(r\)</span>个令牌每秒的速率生成令牌，其容量为<span
class="math inline">\(b\)</span>个令牌，第二个桶以<span
class="math inline">\(p\)</span>个令牌每秒的速率生成令牌，其容量为1个令牌。显然<span
class="math inline">\(r&lt;p\)</span>，因为<span
class="math inline">\(r&gt;p\)</span>会导致队列溢出并丢失分组。若峰值速率最长持续时间为<span
class="math inline">\(t\)</span>，则<span
class="math inline">\(rt+b=pt\)</span>，因此<span
class="math inline">\(t=\frac{b}{p-r}\)</span>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/n_multiplexed_leaky_bucket_flows_with_wfq_scheduling.svg" class="">
<p>　　使用了WFQ调度的路由器的输出链路复用了<span
class="math inline">\(n\)</span>条流。流<span
class="math inline">\(i\)</span>被容量为<span
class="math inline">\(b_i\)</span>和令牌生成速率为<span
class="math inline">\(r_i\)</span>的漏桶监管，至少有<span
class="math inline">\(\frac{w_iR}{\sum_{j=1}^{n}{w_j}}\)</span>的共享链路带宽。若流1的令牌桶最初是满的，然后<span
class="math inline">\(b_1\)</span>个分组突发到达流1的漏桶监管器，因此流1的漏桶中不再有令牌，<span
class="math inline">\(b_1\)</span>个分组进入流1的WFQ等待区域。因为这<span
class="math inline">\(b_1\)</span>分组以至少<span
class="math inline">\(\frac{w_iR}{\sum_{j=1}^{n}{w_j}}\)</span>分组每秒的速率得到服务，其中最后一个分组有最大时延<span
class="math inline">\(d_{max}=\frac{b_1\sum^{n}_{j=1}{w_j}}{w_1R}\)</span>。</p>
<p>　　若在时间<span
class="math inline">\(t\)</span>内到达的分组需要排队，此期间内分组流1发送到网络的分组数量和在WFQ队列中排队的分组数量分别表示为<span
class="math inline">\(S\)</span>和<span
class="math inline">\(Q\)</span>。显然，<span
class="math inline">\(S\geqslant\frac{w_iRt}{\sum_{j=1}^{n}{w_j}}\)</span>，<span
class="math inline">\(Q=r_1t+b_1-S\)</span>。 <span
class="math display">\[
\begin{align}
Q&amp;\leqslant r_1t+b_1-\frac{w_iRt}{\sum_{j=1}^{n}{w_j}}\\[3px]
Q&amp;\leqslant (r_1-\frac{w_iR}{\sum_{j=1}^{n}{w_j}})t+b_1
\end{align}
\]</span> 　　若<span
class="math inline">\(r_1&lt;\frac{w_iR}{\sum_{j=1}^{n}{w_j}}\)</span>，则<span
class="math inline">\(Q\leqslant
b_1\)</span>，即分组流1在WFQ队列中排队的最大分组数是<span
class="math inline">\(b_1\)</span>，这些分组得到服务的速率最小值是<span
class="math inline">\(\frac{w_iR}{\sum_{j=1}^{n}{w_j}}\)</span>，分组流1中任何在WFQ队列中排队的分组承受的最大时延都是<span
class="math inline">\(d_{max}\)</span>。</p>
<h4 id="ds架构">8.4.2 DS架构</h4>
<p>　　DS架构由<span
style="background-color: yellow">边缘功能(分组分类和流量调节)</span>和<span
style="background-color: yellow">核心功能(转发)</span>的集合组成。在网络的传入边缘到达的分组将被标记，即将数据报首部中的DS字段设置为某个值。DS架构的一个关键原则是路由器的<strong>每跳行为</strong>仅基于分组(DS)标记，即分组所属的流量类型。因此，DS架构无需为各个"源到目的地对"保持路由器状态，这是DS具有可扩展性的一个关键考虑因素。</p>
<p>　　PHB导致不同服务类型的流量行为不同，PHB虽然定义了类型间的行为差异，但并未规定特定的机制来实现这些行为。行为的差异必须可以观察，因此可以计量。只需满足外部可观察的行为准则，任何实现机制和任何缓存/带宽分配策略都可以使用。已定义了<strong>加速转发</strong>和<strong>确保转发</strong>这两种PHB。EF
PHB规定了一类流量离开路由器的速率必须达到某个已配置的速率，AF
PHB将流量分为4类，每个类都确保提供某种最小的带宽和缓存。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_08/simple_ds_network_example.svg" class="">
<p>　　到达边缘路由器的分组首先被分类，分类器根据一个或多个分组首部字段选择分组并引导到对应的标记器。某些情况下，端用户可能同意限制分组发送速率来符合某个声明的<strong>流量配置文件</strong>(该流量配置文件可能包含对峰值速率和突发大小的限制)。只要用户符合流量配置文件，分组就会收到优先级标记并被转发到目的地，否则，超出限制的分组可能被整形(为了保持最大速率而延时)或丢弃。<strong>计量功能</strong>用于将传入的分组流与协商的流量配置文件进行比较并确定是分组否符合规范，而不符合规范时的操作由网络管理员决定。</p>
<p>　　若不总是有足够的资源提供但需保证呼叫(端到端流)的QOS，则需要进行<strong>呼叫准入控制</strong>，即呼叫声明其QOS所需资源，若网络能保证所需资源则准入，否则进行拦截。保证呼叫的QOS所需资源的唯一方法是显式地为该呼叫分配这些资源，称为<strong>资源预留</strong>。资源预留需要源到目的地路径上的每个路由器都预留足够的资源，这是<strong>呼叫建立</strong>的工作，主要通过<strong>资源预留协议</strong>等信令协议完成。一旦资源被保留，呼叫持续期间都可以按需访问这些资源，而忽略其他呼叫的QOS所需资源。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法 第7版》第5章 链路层</title>
    <url>/network/computer_networking_a_top_down_approach_7e_chpt_05/</url>
    <content><![CDATA[<p>　　运行链路层协议的设备称为<strong>节点</strong>。连接相邻节点的通信信道称为<strong>链路</strong>。</p>
<p>　　链路层提供的服务包括<strong>封装成帧</strong>、<strong>链路接入</strong>、<strong>可靠交付</strong>、<strong>差错检测和纠错</strong>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/relationship_of_network_adapter_to_other_host_components.svg" class="">
<p>　　通常链路层是通过<strong>网络适配器</strong>实现的，网络适配器也称为<strong>网络接口卡</strong>。网络适配器的核心是链路层控制器，通常是一个实现了很多链路层服务的专用芯片。因此，链路层控制器的大部分功能(封装成帧、链路接入和差错检测)是通过硬件实现的。链路层的软件部分实现更高级别的链路层功能(组装链路层寻址信息和激活控制器硬件)。</p>
<p>　　交换机的工作是主机与路由器之间传输数据报，即交换机不必明确地将帧寻址到其他交换机，因此它没有与其相连的主机或路由器的链路层地址。</p>
<p>　　主机和路由器的<span
style="background-color: yellow">网络适配器(即网络接口)</span>拥有链路层地址。链路层地址又称<strong>LAN地址</strong>、<strong>物理地址</strong>或<strong>MAC地址</strong>。MAC地址长度为<span
class="math inline">\(6B\)</span>，共有<span
class="math inline">\(2^{48}\)</span>个可能的地址，常用16进制数表示，即<span
class="math inline">\(1B\)</span>对应一对16进制数。没有两块适配器拥有相同的MAC地址，因为一个公司想要生产网络适配器时需要向IEEE购买<span
class="math inline">\(2^{24}\)</span>个地址组成的地址空间，这些地址的前24位相同。</p>
<p>　　当网络适配器发送帧时会将目的网络适配器的MAC地址插入帧中。交换机可能将帧广播到所有接口，因此网络适配器可能收到不是发送给它的帧。当网络适配器收到帧时会将目的MAC地址与自身MAC地址进行匹配，若匹配则提取数据报并沿协议栈向上传递，否则丢弃该帧。</p>
<p>　　若网络适配器需要将帧广播到其他网络适配器，发送端网络适配器需要将帧的MAC地址设置为特殊的广播地址，即48位全是1。</p>
<span id="more"></span>
<p>　　<strong>集线器</strong>是物理层设备，作用于比特，当比特从一个接口到达时，集线器只需要重新生成该比特来提供其能量强度，并将该比特传输到其他所有接口。</p>
<p>　　<strong>中继器</strong>是物理层设备，用来放大信号，比特从输入接口达到后会重新生成该比特并传输到输出接口。</p>
<table>
<thead>
<tr>
<th></th>
<th>路由器</th>
<th>集线器</th>
<th>交换机</th>
</tr>
</thead>
<tbody>
<tr>
<td>流量隔离</td>
<td>✓</td>
<td>⨉</td>
<td>✓</td>
</tr>
<tr>
<td>即插即用</td>
<td>⨉</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>优化路由</td>
<td>✓</td>
<td>⨉</td>
<td>⨉</td>
</tr>
</tbody>
</table>
<h3 id="差错检测和纠错">5.1 差错检测和纠错</h3>
<p>　　<strong>前向纠错</strong>指接收端检测并纠错。</p>
<p>　　传输层通常由主机中的软件实现并作为主机操作系统的一部分，传输层的差错检验同样是通过软件实现的，故传输层使用了更简单快速的差错检测(例如，校验和)。而链路层的差错检测通常在网络适配器中的专用硬件实现，可以快速执行更复杂的CRC操作。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/single_bit_even_parity.svg" class="">
<p>　　最简单的差错检测技术是用单个<strong>奇偶校验位</strong>。假设待发送的信息<span
class="math inline">\(D\)</span>有<span
class="math inline">\(d\)</span>位，若使用偶校验，发送端只需要再加上1位，使得这<span
class="math inline">\(d+1\)</span>位有偶数个1，若使用奇校验则<span
class="math inline">\(d+1\)</span>位中有奇数个1。显然这种方案只能检测出奇数比特的差错。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/two_dimensional_even_parity.svg" class="">
<p>　　<strong>二维奇偶检验</strong>可以检测出单比特的错误并纠错，只能检测错两比特的错误。</p>
<p>　　另一种差错检测技术是校验和，比较简单的校验和方法就是将<span
class="math inline">\(d\)</span>位数据看作<span
class="math inline">\(k\)</span>位整数的序列化，再将这<span
class="math inline">\(k\)</span>位整数相加并将得到的和用作差错检测位。<strong>互联网校验和</strong>就基于这种方法，即将待发送数据字节视作16位的整数并求和，求和时需要回卷，求和后再取反码，这个反码设置为分组首部的校验和字段。接收端收到分组后用同样的方式(包括校验和)求和取反码，若结果全为1则表示没有出现差错。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/crc.svg" class="">
<p>　　现在常用的差错检测技术是<strong>循环冗余校验编码</strong>，循环冗余校验编码也称为多项式编码，因为该编码将待发送的位串视作多项式，其系数是位串中的0和1，对位串的操作被视为多项式算术。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/simple_crc_calculation.svg" class="">
<p>　　所有的CRC都采用模2运算，模2运算<span
style="background-color: yellow">不考虑进位和借位</span>，模2加法和模2减法等价于操作数的异或运算<span
class="math inline">\(\oplus\)</span>，模2乘法和模2除法运算规则与二进制中的乘法和除法相同。</p>
<p>　　依然假设待发送的数据<span class="math inline">\(D\)</span>有<span
class="math inline">\(d\)</span>位，发送端接收端必须先就<span
class="math inline">\(r+1\)</span>位模式(二进制形式)达成一致，称为<strong>生成多项式</strong>，用<span
class="math inline">\(G\)</span>表示，<span
class="math inline">\(G\)</span>的最高有效位必须是1并且使用模2运算时<span
class="math inline">\(d+r\)</span>位模式(二进制形式)能整除<span
class="math inline">\(G\)</span>，若有余数则说明出现了差错。</p>
<p>　　根据二进制乘法中乘<span
class="math inline">\(2^k\)</span>相当于左移<span
class="math inline">\(k\)</span>位的特性，<span
class="math inline">\(d+r\)</span>位模式可以表示为<span
class="math inline">\(D\times 2^r\oplus R\)</span>。 <span
class="math display">\[
\begin{align}
D\times 2^r \oplus R&amp;=nG\\[3px]
D\times 2^r\oplus R\oplus R&amp;=nG\oplus R\\[3px]
D\times 2^r&amp;=nG \oplus R
\end{align}
\]</span> 　　显然，<span class="math inline">\(R= (D\times 2^r) \bmod
G\)</span>。</p>
<p>　　CRC能检测出奇数比特的差错，而且CRC能检测出小于<span
class="math inline">\(r+1\)</span>位的差错，在适当的假设下还可以以<span
class="math inline">\(1-\frac{r}{2}\)</span>的概率检测出大于<span
class="math inline">\(r+1\)</span>位的差错。</p>
<h3 id="多路访问链路和协议">5.2 多路访问链路和协议</h3>
<p>　　<strong>点对点链路</strong>由链路一端的单个发送端和链路另一端的单个接收端组成，相关协议包括PPP和HDLC。</p>
<p>　　<strong>广播</strong>指当任何节点通过广播信道传输帧时其他所有节点都会收到该帧的副本。<strong>广播链路</strong>可以有多个发送端和接收端都连接到同一共享广播信道。</p>
<p>　　因为所有的节点都能传输帧，所有可能多个节点会同时传输帧，此时，传输的帧在所有接收端<strong>碰撞</strong>，涉及此次碰撞的所有帧都会丢失。</p>
<p>　　<strong>多路访问</strong>指多个节点共享同一信道，其中任意节点发送的帧可以被多个节点接收。多路访问协议分为<strong>信道划分协议</strong>、<strong>随机接入协议</strong>和<strong>轮流协议</strong>。</p>
<p>　　在理想情况下，速率为<span
class="math inline">\(R(b/s)\)</span>的广播信息的，多路信道应该具有以下理想特性：</p>
<p>　　1) 当仅有一个节点发送数据时，该节点吞吐量为<span
class="math inline">\(R(b/s)\)</span>。</p>
<p>　　2) 当<span
class="math inline">\(M\)</span>个节点发送数据时，每个节点的吞吐量为<span
class="math inline">\(\frac{R}{M}(b/s)\)</span>。</p>
<p>　　3) 协议是去中心化的，即不会因为主节点故障而导致整个系统崩溃。</p>
<p>　　4) 协议是简单的，故实现成本也不高。</p>
<h4 id="信道划分协议">5.2.1 信道划分协议</h4>
<p>　　FDM和TDM可以用于信道划分。</p>
<p>　　FDM消除了碰撞且很公平，每个节点都获得了专用带宽<span
class="math inline">\(\frac{R}{N}(b/s)\)</span>，缺点是带宽的限制。</p>
<p>　　TDM也消除了碰撞且也很公平，每个节点在每个时间帧内都获得了专用传输速率<span
class="math inline">\(\frac{R}{N}(b/s)\)</span>，缺点是节点的平均速率被限制在<span
class="math inline">\(\frac{R}{N}(b/s)\)</span>以及节点必须等待传输序列的轮次。</p>
<p>　　另一种信道划分协议是<strong>码分多址</strong>，码分多址为每个节点分配了不同的编码，每个节点使用其唯一编码来将待发送的数据编码。若精心选择编码，码分多址既可以保证不同节点同时传输，又可以保证它们对应的接收端仍能正确地接收数据。</p>
<p>　　在CDMA协议中，发送端的每个比特都通过乘一个信号(编码)进行编码，该信号的变化速率(称为<strong>码片速率</strong>)比初始数据比特序列的变化速率快很多。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/simple_example_of_cmda.svg" class="">
<p>　　假设初始数据比特达到CDMA编码器的速率定义了时间单位，即每个待发送的初始数据比特需要1比特的时隙。为了数学上的便利，这里用<span
class="math inline">\(-1\)</span>代替<span
class="math inline">\(0\)</span>。<span
class="math inline">\(d_i\)</span>表示第<span
class="math inline">\(i\)</span>个比特时隙中的数据比特值。每个比特时隙进一步细分为<span
class="math inline">\(M\)</span>个微时隙(这里<span
class="math inline">\(M=8\)</span>，实际中<span
class="math inline">\(M\)</span>的值大得多)。发送端使用CDMA编码由<span
class="math inline">\(M\)</span>个值的一个序列<span
class="math inline">\(c_m\)</span>组成。</p>
<p>　　对于<span class="math inline">\(d_i\)</span>比特传输时的第<span
class="math inline">\(m\)</span>个微时隙，CDMA编码器的输出<span
class="math inline">\(Z_{i,m}=d_i\cdot
c_m\)</span>。在没有其他发送端的干扰时，接收端将收到比特<span
class="math inline">\(Z_{i,m}\)</span>并恢复成初始的数据比特<span
class="math inline">\(d_i=\frac{\sum_{m=1}^MZ_{i,m}\cdot
c_m}{M}\)</span>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/simple_example_of_two-sender_cmda.svg" class="">
<p>　　实际中干扰在所难免，CDMA在原始数据比特与干扰比特传输信号是相加的假设下工作。相比无干扰情况，接收端收到比特的值是所有发送端传输的比特总和<span
class="math inline">\(Z_{i,m}^*=\sum_{s=1}^NZ_{i,m}^s\)</span>。</p>
<h4 id="随机接入协议">5.2.2 随机接入协议</h4>
<p>　　随机接入协议中，节点总是以信道的最高速率<span
class="math inline">\(R(b/s)\)</span>进行传输，当发送碰撞时，涉及碰撞的每个节点都会重传直到无碰撞为止，但并非碰撞后立即重传，而是<span
style="background-color: yellow">等待随机时延</span>后重传。涉及碰撞的节点都独立地选择随机时延。</p>
<h5 id="时隙aloha">5.2.2.1 时隙ALOHA</h5>
<p>　　在时隙ALOHA协议中，先做如下假设：</p>
<p>　　● 所有帧的长度固定为<span
class="math inline">\(L\)</span>位。</p>
<p>　　● 时间划分为<span
class="math inline">\(\frac{L}{R}(s)\)</span>的时隙，即一个时隙等于传输一帧所需时间。</p>
<p>　　● 节点仅在时隙的开始传输帧。</p>
<p>　　● 节点是同步的，每个节点都指定时隙的开始时间。</p>
<p>　　●
若两个或多个帧在同一时隙内碰撞则所有节点在时隙结束前会检测到该碰撞。</p>
<p>　　当节点有帧待发送时，它等到下个时隙的开始并在该时隙内传输整个帧。若出现碰撞，该节点在时隙结束前会检测到该碰撞，在之后的每个时隙内以概率<span
class="math inline">\(p\)</span>(二项分布)重传该帧直到不出现碰撞。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/simple_example_of_slotted_aloha.svg" class="">
<p>　　只有一个节点传输的时隙称为<strong>成功时隙</strong>。时隙ALOHA协议的<strong>效率</strong>指大量活动节点的情况下成功时隙的比例。</p>
<p>　　假设<span
class="math inline">\(N\)</span>个节点，则某个时隙是成功时隙的概率就是其他<span
class="math inline">\(N-1\)</span>个节点不进行传输的概率。某个节点传输的概率是<span
class="math inline">\(p\)</span>，其他节点不传输的概率是<span
class="math inline">\((1-p)^{N-1}\)</span>，因此该节点成功传输的概率是<span
class="math inline">\(p(1-p)^{N-1}\)</span>。因为有<span
class="math inline">\(N\)</span>个节点，其中任一节点成功传输的概率是<span
class="math inline">\(Np(1-p)^{N-1}\)</span>。 <span
class="math display">\[
\begin{align}
f(p)&amp;=Np(1-p)^{N-1}\\[3px]
f&#39;(p)&amp;=(Np)&#39;(1-p)^{N-1}-Np((1-p)^{N-1})&#39;\\[3px]
&amp;=N(1-p)^{N-1}-Np(N-1)(1-p)^{N-2}\\[3px]
&amp;=N(1-p)^{N-2}(1-p-p(N-1))\\[3px]
&amp;=N(1-p)^{N-2}(1-pN)
\end{align}
\]</span> 　　令<span
class="math inline">\(f&#39;(p)=0\)</span>时，则<span
class="math inline">\(p=\frac{1}{N}\)</span>或<span
class="math inline">\(p=1\)</span>。</p>
<p>　　当<span class="math inline">\(p=\frac{1}{N}\)</span>时，<span
class="math inline">\(f(\frac{1}{N})=(1-\frac{1}{N})^{N-1}&gt;0\)</span>，<span
class="math inline">\(p=\frac{1}{N}\)</span>是<span
class="math inline">\(f(p)\)</span>的极大值点。</p>
<p>　　当<span class="math inline">\(p=1\)</span>时，<span
class="math inline">\(f(1)=0\)</span>，<span
class="math inline">\(p=1\)</span>是<span
class="math inline">\(f(p)\)</span>的极小值点。 <span
class="math display">\[
\begin{align}
\lim \limits_{N\rightarrow \infty} f(\frac{1}{N})&amp;=\lim
\limits_{N\rightarrow \infty} (1-\frac{1}{N})^{N-1}\\[3px]
&amp;=\lim \limits_{N\rightarrow \infty}
\frac{(1-\frac{1}{N})^N}{1-\frac{1}{N}}\\[3px]
&amp;=\frac{\lim \limits_{N\rightarrow \infty}(1-\frac{1}{N})^N}{\lim
\limits_{N\rightarrow \infty}(1-\frac{1}{N})}\\[3px]
&amp;=\frac{1}{e}
\end{align}
\]</span></p>
<p>　　时隙ALOHA效率是<span class="math inline">\(\frac{1}{e}\approx
0.37\)</span>。</p>
<h5 id="aloha">5.2.2.2 ALOHA</h5>
<p>　　ALOHA是无时隙的。在ALOHA中，当一个帧首次到达(数据报从发送端的网络层向下传递)，节点立即将整个帧传输到广播信道中。若出现碰撞，该节点(传输完出现碰撞的帧后)下一个帧传输时间以概率<span
class="math inline">\(p\)</span>重传。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/interfering_transmission_in_aloha.svg" class="">
<p>　　为了确定ALOHA的最高效率，关注的重点是单独的节点。类似于时隙ALOHA，时间单元为帧的传输时间。对于指定时间，节点<span
class="math inline">\(i\)</span>传输帧的概率是<span
class="math inline">\(p\)</span>。该节点在<span
class="math inline">\(t_0\)</span>开始传输，若该帧能够成功传输，在<span
class="math inline">\([t_0-1,t_0]\)</span>内不能有其他节点传输，因为这样会导致传输干扰。其他所有节点在<span
class="math inline">\([t_0-1,t_0]\)</span>内不传输的概率是<span
class="math inline">\((1-p)^{N-1}\)</span>。当节点<span
class="math inline">\(i\)</span>传输时不能有其他节点传输，这样概率也是<span
class="math inline">\((1-p)^{N-1}\)</span>。因此，节点<span
class="math inline">\(i\)</span>成功传输的概率是<span
class="math inline">\((1-p)^{2N-2}\)</span>。当有<span
class="math inline">\(N\)</span>个节点，其中任一节点成功传输的概率是<span
class="math inline">\(Np(1-p)^{2N-2}\)</span>。 <span
class="math display">\[
\begin{align}
f(p)&amp;=Np(1-p)^{2N-2}\\[3px]
f&#39;(p)&amp;=(Np)&#39;(1-p)^{2N-2}-Np((1-p)^{2N-2})&#39;\\[3px]
&amp;=N(1-p)^{2N-2}-Np(2N-2)(1-p)^{2N-3}\\[3px]
&amp;=N(1-p)^{2N-3}(1-p-p(2N-2))\\[3px]
&amp;=N(1-p)^{2N-3}(1-p(2N-1))
\end{align}
\]</span> 　　令<span
class="math inline">\(f&#39;(p)=0\)</span>时，则<span
class="math inline">\(p=\frac{1}{2N-1}\)</span>或<span
class="math inline">\(p=1\)</span>。</p>
<p>　　当<span class="math inline">\(p=\frac{1}{2N-1}\)</span>时，<span
class="math inline">\(f(\frac{1}{2N-1})= \frac{N}{2N-1} \times
(1-\frac{1}{2N-1})^{2N-2}&gt;0\)</span>，<span
class="math inline">\(p=\frac{1}{2N-1}\)</span>是<span
class="math inline">\(f(p)\)</span>的极大值点。</p>
<p>　　当<span class="math inline">\(p=1\)</span>时，<span
class="math inline">\(f(1)=0\)</span>，<span
class="math inline">\(p=0\)</span>是<span
class="math inline">\(f(p)\)</span>的极小值点。 <span
class="math display">\[
\begin{align}
\lim \limits_{N\rightarrow \infty} f(\frac{1}{2N-1})&amp;=\lim
\limits_{N\rightarrow \infty} [\frac{N}{2N-1} \times
(1-\frac{1}{2N-1})^{2N-2}]\\[3px]
&amp;=\lim \limits_{N\rightarrow \infty} \frac{N}{2N-1}\times \lim
\limits_{N\rightarrow \infty} (1-\frac{1}{2N-1})^{2N-2}\\[3px]
&amp;=\frac{1}{2}\times \frac{\lim \limits_{N\rightarrow
\infty}(1-\frac{1}{2N-1})^{2N-1}}{\lim \limits_{N\rightarrow
\infty}(1-\frac{1}{2N-1})}\\[3px]
&amp;=\frac{1}{2e}
\end{align}
\]</span></p>
<p>　　ALOHA效率是<span
class="math inline">\(\frac{1}{2e}\)</span>，仅为时隙ALOHA的一半。</p>
<h5 id="csma">5.2.2.3 CSMA</h5>
<p>　　<strong>载波侦听</strong>指节点在传输前先侦听信道。若有其他节点在通过该信道传输则该节点会等待，直到短时间内未检测到传输再开始传输。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/two_csma_nodes_collide.svg" class="">
<p>　　假设一条广播总线有A、B、C、D这4个节点。在<span
class="math inline">\(t_0\)</span>时刻，节点B侦听到信道是空闲的，因此节点B开始传输，帧向着总线的两端传输。在<span
class="math inline">\(t_1\)</span>时刻，节点D有帧待发送，此时节点B的帧还未到达节点D，因此D侦听到信道是空闲的，因此节点D也开始传输帧。过了一段时间后B的传输与D的传输碰撞。</p>
<p>　　广播信道的端到端<strong>信道传播时延</strong>在性能方面起到关键作用。信道传播时延越长，载波侦听节点不能侦听到另一节点已开始传输的几率越大。</p>
<h5 id="csmacd">5.2.2.4 CSMA/CD</h5>
<p>　　<strong>碰撞检测</strong>指节点在传输时侦听信道。若检测到其他节点在传输，该节点会停止并等待随机时延，再进入“侦听-空闲时传输”的循环。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/csma_with_collision_detection.svg" class="">
<p>　　从连接到广播信道的节点的网络适配器角度来说明CSMA/CD的内容：</p>
<p>　　1)
网络适配器从网络层获取数据报，将数据报封装成帧并将帧放入网络适配器的缓存中。</p>
<p>　　2)
如果网络适配器侦听到信道是空闲的(无信号能量从信道进入网络适配器)则开始传输帧，否则网络适配器将等待，直至信道空闲。</p>
<p>　　3) 传输帧时网络适配器会监视该信道中其他网络适配器的信号能量。</p>
<p>　　4)
若传输整个帧的过程中未检测到其他网络适配器的能量信号则网络适配器完成了传输，否则网络适配器将中止传输。</p>
<p>　　5) 中止之后，网络适配器将等待随机时延并回到第2步。</p>
<p>　　<strong>二进制指数退避算法</strong>可以让碰撞后节点等待的随机时延随着碰撞次数增长而增长。<span
class="math inline">\(512b\)</span>数据在端到端的往返时间表示为<span
class="math inline">\(2\tau\)</span>，也称为<strong>冲突窗口</strong>或<strong>竞争期</strong>，一般设置为基本退避时间。若一个帧的碰撞次数达到16次时会<span
style="background-color: yellow">丢弃该帧并向上层反馈错误</span>。定义一个与冲突次数相关的参数<span
class="math inline">\(k\)</span>，<span
class="math inline">\(k=min\{碰撞次数,10\}\)</span>。从<span
class="math inline">\([0,1,2,\cdots ,2^k-1]\)</span>中选取随机数<span
class="math inline">\(r\)</span>，则等待的随机时延是<span
class="math inline">\(r\)</span>倍的基本退避时间，即<span
class="math inline">\(r\times 2\tau\)</span>。</p>
<p>　　CSMA/CD的效率指大量活动节点时，帧在信道上无碰撞地传输的时间所占的比例。
<span class="math display">\[
effciency\approx \frac{1}{1+5\frac{d_{prop}}{d_{trans}}}
\]</span> 　　<span
class="math inline">\(d_{prop}\)</span>表示信号能量在任意两个网络适配器之间传输所需的最长时间。<span
class="math inline">\(d_{trans}\)</span>表示传输最大长度的帧所需时间。</p>
<p>　　假设<span
class="math inline">\(S\)</span>表示类似于时隙ALOHA的时隙，<span
class="math inline">\(S\)</span>比传输一帧的时间小很多且<span
class="math inline">\(S&gt;d_{prop}\)</span>，这样在时隙结束前每个节点都能检测到其他节点的信号能量。所有帧的长度固定，用<span
class="math inline">\(L\)</span>表示，<span
class="math inline">\(L=kRS\)</span>，<span
class="math inline">\(R\)</span>表示信道的速率，即成功传输帧需要连续<span
class="math inline">\(k\)</span>个传输成功的时隙。由于时隙结束前每个节点都能检测到其他节点的信号能量，首个传输成功的时隙后的<span
class="math inline">\(k-1\)</span>个时隙无时隙竞争。此外，有<span
class="math inline">\(N\)</span>个节点且每个节点有无限帧待发送。每个节点在时隙内传输的概率是<span
class="math inline">\(p\)</span>。每<span
class="math inline">\(x\)</span>个传输失败的时隙后有传输成功的时隙。时隙内成功传输的概率是<span
class="math inline">\(\beta\)</span>，<span
class="math inline">\(\beta=Np(1-p)^{N-1}\)</span>。<span
class="math inline">\(Y\)</span>表示时隙序号。 <span
class="math display">\[
P(Y=x+1)=\beta (1-\beta)^{x}
\]</span> 　　根据几何分布期望，<span
class="math inline">\(E(x+1)=\frac{1}{\beta}\)</span>，则<span
class="math inline">\(E(x)=\frac{1-\beta}{\beta}=\frac{1-Np(1-p)^{N-1}}{Np(1-p)^{N-1}}\)</span>。
<span class="math display">\[
\begin{align}
effciency&amp;=\frac{k}{k+x}\\[3px]
&amp;=\frac{k}{k+\frac{1-Np(1-p)^{N-1}}{Np(1-p)^{N-1}}}
\end{align}
\]</span> 　　显然<span
class="math inline">\(\beta\)</span>越大，效率越高，在时隙ALOHA中推导了<span
class="math inline">\(p=\frac{1}{N}\)</span>时<span
class="math inline">\(\beta\)</span>取最大值<span
class="math inline">\(\frac{1}{e}\)</span>，<span
class="math inline">\(effciency_{max}=\frac{k}{k+e-1}\)</span>。</p>
<h4 id="轮流协议">5.2.3 轮流协议</h4>
<p>　　轮流协议中，只有一个节点活跃时，该节点的吞吐量为<span
class="math inline">\(R(b/s)\)</span>，当有<span
class="math inline">\(M\)</span>个活跃节点时，每个活跃节点的吞吐量接近<span
class="math inline">\(\frac{R}{M}(b/s)\)</span>。</p>
<p>　　<strong>轮询协议</strong>需要一个主节点，主节点以循环的方式<strong>轮询</strong>其他节点。主节点通过侦听信道来确定节点是否完成了传输帧。例如，主节点向节点1发送报文来告诉它能够传输的帧的最大数量。节点1传输了一些帧后，主节点再向节点2发送报文来告诉它能够传输的帧的最大数量。主节点通过这种方式来轮询每个节点。</p>
<p>　　轮询协议相比随机访问协议消除了碰撞和空时隙。但轮询协议需要引入了轮询延迟，更严重的的是问题是当主节点发生故障时整个信道将无法运行。</p>
<p>　　<strong>令牌传递协议</strong>相比轮询协议没有主节点，而是一个称为的<strong>令牌</strong>的小型专用帧以某种固定顺序在节点之间交换。当节点收到令牌且有帧待传输时，才持有令牌并发送最大数量的帧，否则将按序向下一个节点转发令牌。</p>
<h4 id="docsis">5.2.4 DOCSIS</h4>
<p>　　有线接入网通常将数千个住宅有线调制解调器连接到<strong>电缆调制解调器终端系统</strong>。<strong>有线电缆数据服务接口规范</strong>规定了有线网络架构及其协议。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/upstream_and_downstream_channels.svg" class="">
<p>　　DOCSIS使用FDM将下行(CMTS到调制解调器)和上行(调制解调器到CMTS)网段划分为多个频率信道。</p>
<p>　　每个下行信道的带宽是6Mhz，每个信道的最大吞吐量大约为<span
class="math inline">\(40Mb/s\)</span>。每个上行信道的最大带宽是6.4Mhz，最大上行吞吐量约为<span
class="math inline">\(30Mb/s\)</span>。每个上行和下行通道都是一个广播信道。</p>
<p>　　每个上行信道被划分为时间间隔(类似于TDM)，每个时间间隔包含一个微时隙序列，电缆调制解调器可以通过这些微时间序列向CMTS传输。CMTS显式地授予各个电缆调制解调器在指定微时隙序列传输的权限(通过CMTS在下行信道发送的称为MAP报文的控制报文来实现)。</p>
<p>　　CMTS在下行信道上传输的帧被所有接收该信道的电缆调制解调器接收。由于只有一个CMTS传输到下行信道，故不存在多路访问的问题。多个电缆调制解调器共享相同的上行信道到CMTS，因此可能出现碰撞。</p>
<p>　　电缆调制解调器在微时隙请求帧专用的微时隙间隔内向CMTS发送微时隙请求帧来让CMTS知晓自身有数据待发送。这些微时隙请求帧以随机接入方式传输，故可能出现碰撞。电缆调制解调器既不能侦听上行信道是否空闲，也不能检测碰撞。相反，若电缆调制解调器没有在下一个下行信道的控制报文中收到微时隙请求帧的响应，则推断微时隙请求帧出现了碰撞并使用二进制指数退避算法来重传。</p>
<p>　　当上行信道的流量很少时，电缆调制解调器可以在微时隙请求帧专用的信道中传输帧。</p>
<h3 id="交换局域网">5.3 交换局域网</h3>
<h4 id="arp">5.3.1 ARP</h4>
<p>　　<strong>地址解析协议</strong>用于将网络层地址解析为链路层地址，而<strong>反向地址解析协议</strong>用于将链路层地址解析为网络层地址。ARP仅解析同一子网下的主机和路由器接口的IP地址。</p>
<p>　　每个主机或路由器的内存中都有一个<strong>ARP表</strong>，其中包含IP地址到MAC地址映射。ARP表字段包括IP地址、MAC地址和TTL，TTL表示每个映射的删除时间，一般设置为20min。ARP表是自动构建的，若主机与子网断开连接，子网中的其他ARP表会删除该主机的表项。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/arp_packet_format.svg" class="">
<p>　　ARP分组包括16位<strong>硬件地址类型</strong>、16位<strong>协议地址类型</strong>、8位<strong>硬件地址长度</strong>、8位<strong>协议长度</strong>、16位<strong>操作类型</strong>、48位<strong>发送端MAC地址</strong>、32位<strong>发送端IP地址</strong>、48位<strong>目的MAC地址</strong>、32位<strong>目的IP地址</strong>。</p>
<p>　　● 硬件地址类型为1时表示以太网。</p>
<p>　　● 协议类型为0x0080时表示IP。</p>
<p>　　● 硬件地址长度和协议地址长度的单位是<span
class="math inline">\(B\)</span>。</p>
<p>　　●
操作类型为1时表示ARP请求分组，操作类型为2时表示ARP响应分组，操作类型为3时表示RARP请求分组，操作类型为4时表示RARP响应分组。</p>
<p>　　ARP请求分组用于获取目的IP地址对应的MAC地址，因此目的MAC地址为空(全为0)。</p>
<p>　　若主机需要发送一个IP寻址的数据报，需要获取目的IP地址对应的目的MAC地址，但其ARP表中没有目的IP地址的表项，则需要ARP协议来解析这个IP地址。</p>
<p>　　1)
主机构造ARP分组，网络适配器将分组封装成帧时将广播地址作为帧的目的MAC地址。</p>
<p>　　2) 主机将待发送的数据报放入缓存。</p>
<p>　　3)
同一子网下的其他网络适配器接收帧后将帧内的ARP分组传递给ARP模块。ARP模块会将分组中的目的IP地址与自身IP地址进行匹配，若匹配则向请求主机发送一个带有所需映射的ARP响应分组。主机根据ARP响应分组更新ARP表。若主机无法收到ARP响应分组，则会丢弃数据报。</p>
<p>　　4) 主机从缓存中取出数据报并查询ARP表获取MAC地址。</p>
<p>　　5) 主机将数据报封装成帧并发送。</p>
<p>　　某些ARP模块在等待ARP响应报文时<span
style="background-color: yellow">丢弃数据报</span>而不是放入缓存。</p>
<p>　　若子网1的主机A需要向子网2的主机B发送数据报，数据报首先发送到子网1中的第一跳路由，封装成帧时目的MAC地址应该是第一跳路由的IP地址对应的MAC地址。路由器收到帧后提取数据报，再次封装成帧并根据转发表进行转发。</p>
<h4 id="交换机">5.3.2 交换机</h4>
<p>　　交换机是全双工的，它可以在任何接口同时发送和接收。</p>
<p>　　交换机消除了碰撞，支持不同物理介质混搭且易于管理。</p>
<p>　　<strong>过滤</strong>是决定帧应该被转发到某个接口还是将其丢弃的交换机功能。<strong>转发</strong>是决定帧应该到哪个接口并移动到这个接口的交换机功能。交换机的过滤和转发功能是通过<strong>交换机表</strong>完成的。交换机表的表字段包括MAC地址、通向该MAC地址的接口和表项加入的时间。交换机表不一定包含局域网下所有主机和路由器的表项。</p>
<p>　　若一个帧从交换机的接口<span
class="math inline">\(x\)</span>到达，交换机用帧的目的MAC地址索引交换机表。若交换机表中没有帧的目的MAC地址的相关表项，交换机将帧的副本移动到接口<span
class="math inline">\(x\)</span>之外的所有接口的输出缓存，即广播该帧。若交换机表中有帧的目的MAC地址关联接口<span
class="math inline">\(x\)</span>的表项，表示帧已经在包含目的MAC地址的局域网广播，交换机会丢弃该帧来执行过滤。若交换机表中有帧的目的MAC地址的相关表项且关联的接口不是<span
class="math inline">\(x\)</span>，交换机会将帧的副本移动到该接口的输出缓存来执行转发。</p>
<p>　　交换机表是<strong>自学习</strong>的。交换机表初始为空。对于每个从接口上到达的帧，交换机表会存储帧的源MAC地址、帧到达的接口和当前时间。交换机通过这种方式记录发送端所在的局域网。若一段时间(老化期)后没有收到源MAC地址为该地址的帧，交换机将删除表中的地址。</p>
<p>　　<strong>交换机毒化</strong>指向交换机发送大量不同伪造源MAC地址的帧来填满交换机表。</p>
<h4 id="以太网">5.3.3 以太网</h4>
<p>　　在基于集线器的星形拓扑以太网中，主机或路由器通过双绞铜线直接连接到集线器。因此，这种局域网是一种广播局域网。若集线器仅在一个接口收到帧，它会向所有其他接口发送副本。若集线器同时从两个接口接收帧就会发送碰撞，生成帧的节点需要重传帧。随着以太网的发展，集线器被交换机代替。集线器是半双工设备，交换机是全双工设备。</p>
<p>　　最初的以太网的吞吐量是<span
class="math inline">\(10Mb/s\)</span>，使用了CMSA/CD协议，称为标准以太网。后来以太网有了不同规格，通过不同字符组合区分，例如，10BASE-T、100BASE-2等。缩略词的第一部分为数字，表示吞吐量。第二部分通常是BASE或BROAD。BASE指基带以太网，表示物理介质仅承载以太网流量。BOARD指宽带以太网。第三部分表示物理介质，2表示细同轴电缆，5表示粗同轴电缆，F表示光纤，T表示双绞线。</p>
<p>　　<span
class="math inline">\(100Mb/s\)</span>以太网除了吞吐量的提高，还定义了更高速的物理层。双绞线的距离限制为100m，光纤距离限制为几千米。</p>
<p>　　吉比特/千兆以太网是<span
class="math inline">\(10Mb/s\)</span>和<span
class="math inline">\(100Mb/s\)</span>的扩展，除了兼容前者和吞吐量的单位提高到了<span
class="math inline">\(Gb/s\)</span>，还提供了全双工和半双工两种方式。半双工基于集线器，使用了一对电缆线，需要CMSA/CD。全双工基于交换机，使用了两对电缆线，不需要链路层协议。</p>
<p>　　以太网提供无连接且不可靠服务。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/ethernet_frame_format.svg" class="">
<p>　　以太网帧包括<span
class="math inline">\(8B\)</span><strong>前同步码</strong>、<span
class="math inline">\(6B\)</span><strong>目的MAC地址</strong>、<span
class="math inline">\(6B\)</span><strong>源MAC地址</strong>、<span
class="math inline">\(2B\)</span><strong>类型</strong>、<span
class="math inline">\(46\sim1500B\)</span>的<strong>有效载荷</strong>和<span
class="math inline">\(4B\)</span>的<strong>帧校验序列</strong>。</p>
<p>　　● 前同步码的前<span
class="math inline">\(7B\)</span>都是10101010，用于保证接收MAC帧时接收端的网络适配器的时钟频率与发送端的网络适配器同步。前同步码最后<span
class="math inline">\(1B\)</span>是10101011，最后连续的11表示之后是帧的信息。</p>
<p>　　●
类型表示上层(网络层)协议类型。值为0x0800时表示IPv4，值为0x0806表示ARP，值为0x86DD表示IPv6。</p>
<p>　　● 有效载荷不足<span
class="math inline">\(46B\)</span>时会将数据报填充到<span
class="math inline">\(46B\)</span>，网络层根据数据报首部中的长度字段来去掉填充的字节。</p>
<p>　　● 帧校验序列用于差错检测，一般是CRC编码。</p>
<h4 id="虚拟局域网">5.3.4 虚拟局域网</h4>
<p>　　支持<strong>虚拟局域网</strong>的交换机可以在单个物理局域网基础设施上定义多个虚拟局域网。</p>
<p>　　在基于端口的VLAN中，交换机的接口被分组。每个组构成一个VLAN，每个VLAN中的端口组成一个广播域，即来自端口的广播流量只能达到组中的其他端口。</p>
<p>　　将交换机端口连接到外部路由器，并将路由器接口中连接交换机的接口配置为属于交换机所属VLAN。通过这种方式可以实现基于端口的VLAN互联，从逻辑上就是通过路由器转发。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/802.1q_ethernet_frame_format.svg" class="">
<p>　　另一种更加可扩展性的实现基于端口的VLAN互联的方式是<strong>虚拟局域网干道</strong>，每个交换机的部分接口配置为干道接口，干道端口用于连接其他交换机，干道接口属于所有VLAN，干道接口之间的链路称为干道链路，发送到任何VLAN的帧都会通过干道链路转发到另一台交换机。为了区分VLAN，IEEE定义了一种扩展以太网帧格式802.1Q。相比以太网帧在首部加入了<span
class="math inline">\(4B\)</span><strong>VLAN标签</strong>用于标识VLAN。</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 5%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr>
<th>字段名</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>标签控制信息</td>
<td><span class="math inline">\(2B\)</span></td>
<td>表示帧类型，一般取固定值0x8100，若自定义则各个设备需统一</td>
</tr>
<tr>
<td>优先级</td>
<td>3位</td>
<td>网络拥塞时，优先发送优先级高的帧</td>
</tr>
<tr>
<td>标准格式指示位</td>
<td>1位</td>
<td>取值0时表示以标准格式封装，取值1时表示非标准格式封装</td>
</tr>
<tr>
<td>VLAN标识符</td>
<td>12位</td>
<td>全为0和全为1为协议保留值</td>
</tr>
</tbody>
</table>
<p>　　在基于接口的VLAN中，以太网帧分为<strong>有标记帧</strong>和<strong>无标记帧</strong>，有标记帧有VLAN标签，无标记帧没有。若交换机不支持有标记帧则会丢弃。干道链路上传输的帧都是有标记帧，接入链路上传输的帧都是无标记帧。交换机内部处理的帧都是有标记帧，若收到无标记帧，交换机会为无标记帧添加VLAN标签并重新计算FCS。交换机向接入链路发送帧时会将有标记帧的VLAN标签去除。</p>
<p>　　由于802.1Q以太网帧中的VLAN标识符只能表示<span
class="math inline">\(2^{12}-2=4096\)</span>个VLAN，为了扩展VLAN数量，可以将802.1Q以太网帧作为另一个802.1Q以太网帧的有效载荷，称为QinQ(802.1Q
in 802.1Q)，这样VLAN数量增加到了<span class="math inline">\(4096\times
4096\)</span>。</p>
<p>　　VLAN除了基于接口，还可以基于其他方式，例如，MAC地址和网络层协议等。在基于MAC地址中的VLAN中会为VLAN指定MAC地址集。VLAN也可以跨IP路由器扩展，允许LAN岛连接在一起形成全球性的VLAN。</p>
<h3 id="mpls">5.4 MPLS</h3>
<p>　　为了提高路由器的转发速率，MPLS采用了虚电路网络的一个关键概念——固定长度标签，其目标是在可能的情况下，标记数据报并允许路由器基于固定长度标签转发数据报(通常与IP协同)来提供转发速率。</p>
<p>　　MPLS是一种分类转发技术，它将具有相同转发处理方式的分组归类，称为<strong>转发等价类</strong>。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/mpls_label.svg" class="">
<p>　　<strong>MPLS标签栈</strong>表示MPLS首部的排序集合。靠近链路层帧的MPLS首部称为栈顶标签或外层标签，靠近网络层数据报的MPLS首部称为栈底标签或内层标签。MPLS标签栈按后进先出方式组成首部，从栈顶开始处理首部。</p>
<p>　　MPLS首部位于链路层帧首部和网络层数据报首部之间。MPLS首部包括20位<strong>标签</strong>、3位<strong>实验</strong>、1位<strong>栈底标识</strong>和8位<strong>生存时间</strong>。</p>
<p>　　● 标签用于标识分组所属FEC。</p>
<p>　　● 实验常用于<strong>服务分类</strong>。</p>
<p>　　● 栈底标识值为1时表示为最底层标签。</p>
<p>　　● 生存时间与IPv4数据报中的生存时间相同。</p>
<p>　　支持MPLS的路由器称为<strong>标签交换路由器</strong>，MPLS分组仅能标签交换路由器之间传输。LSR通过在其转发表中查找MPLS标签来转发MPLS分组，然后将数据报移动到对应的输出接口。<strong>标签交换路径</strong>指同一FEC报文在MPLS域内转发的路径。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/basic_operations_of_mpls_label.svg" class="">
<p>　　MPLS标签的基本操作包括<strong>标签压入</strong>、<strong>标签交换</strong>和<strong>标签弹出</strong>。</p>
<p>　　●
标签压入指当LSP入口节点添加新MPLS标签或LSP中间节点按需添加一层新的标签。</p>
<p>　　● 标签交换指LSP中间节点根据标签转发表替换MPLS分组的栈顶标签。</p>
<p>　　●
标签弹出指当LSP出口节点去除标签或在LSP倒数第二跳节点去除栈顶标签。</p>
<p>　　在MPLS域内的最后一跳时，MPLS标签已失去作用，可以利用<strong>倒数第二跳弹出</strong>在MPLS域内倒数第二跳节点将标签弹出以减少最后一跳的处理负担。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/mpls_enhanced_forwarding.svg" class="">
<p>　　R1-R4是LSR，R5和R6是标准IP路由器。R1已向R2、R3通告可以路由到A，MPLS标签为6的帧将被转发到A。R3已向R4通告可以到达A和D，MPLS标签为10的帧将被转发到A，MPLS标签为12的帧将被转发到D。R2已向R4通告可以到达A，MPLS标签为10的帧将被转发到A。与交换LAN或ATM网络一样，R1-R4路由器的转发与IP数据报无关。</p>
<p>　　MPLS是一种简单的<strong>流量工程</strong>，其中ISP可以覆盖常规的IP路由并强制一些流量沿着一条链路传输到指定目的地，而其他流量则沿着另一条链路流向同一目的地。</p>
<p>　　MPLS可用于执行MPLS转发路径的快速恢复，例如，用过预先计算的故障转移链路重新路由流量来响应链路故障。</p>
<p>　　MPLS可用于来实现<strong>虚拟专用网络</strong>，ISP使用支持MPLS的网络将客户的各种网络连接在一起。MPLS还可用于将VPN客户端使用的资源和地址与跨ISP网络的其他用户的资源和地址隔离。</p>
<h3 id="数据中心网络">5.5 数据中心网络</h3>
<p>　　每个数据中心都有<strong>数据中心网络</strong>，将其主机互联并将数据中心与互联网互联。数据中心网络的关键需求是计算和服务放置的灵活。</p>
<p>　　数据中心的主机称为<strong>刀片</strong>。刀片负责提供内容、存储数据并共同执行大型分布式计算。主机堆叠在机架上，每个机架顶部都有一台<strong>机架式</strong>交换机。TOR交换机将机架上的互联。机架上的主机都有一个与TOR交换机连接的网络接口卡，每个TOR交换机都有可以连接到其他TOR交换机的额外接口。每台主机都分配了数据中心的内网IP。</p>
<p>　　数据中心网络支持两种流量：外部客户端和内部主机之间的流量以及内部主机之间的流量。为了处理外部客户端和内部主机之间的流量，数据中心网络包括一个或多个<strong>边界路由器</strong>用于将数据中心网络连接到互联网。所以数据中心网络需要将所有主机互联并将机架与边界路由器连接。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/data_center_network_with_hierarchical_topology.svg" class="">
<p>　　大型数据中心通常使用<strong>等级拓扑</strong>形式，其中有多个负载均衡器，每个负载均衡器专门用于一组特定的应用程序，这种负载均衡器也称为第4层交换机，因为它根据分组的端口号和目的IP地址进行决策。收到请求后，负载均衡器会将其转发到对应的主机，主机处理请求后将响应发送给负载均衡器，负载均衡器再将响应发送给客户端。负载均衡器不仅可以提供负载均衡，还可以提供类似NAT的功能，将公网IP地址转换为内网IP地址并将响应按向相反的转发方式处理。</p>
<p>　　在等级拓扑的数据中心网络中，边界路由器与接入路由器相连，接入路由器下有3层交换机。每台接入路由器下的主机构成一个子网，为了本地化ARP广播流量，这些子网进一步划分为VLAN子网。所有链路通常使用以太网作为链路层和物理层并使用铜缆和光纤。此外，数据中心还包括冗余网络设备和链路(例如，TOR交换机连接两台第2层交换机，其中接入路由器、第1层交换机和第2层交换机都可以冗余)。虽然这种结构解决了扩展性的问题，但是存在吞吐量的问题。</p>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/data_network_with_fully_connected_topology.svg" class="">
<p>　　用<strong>全连接拓扑</strong>来代替交换机和路由器的等级结构可以改善吞吐量，这种结构中每台第1层交换机都连接到所有第2层交换机，因此需要考虑交换机之间选择算法，较简单的算法是随机，另一种在每个主机中部署多个网络接口卡，将主机连接到多个低成本商用交换机并允许主机在交换机之间智能路由流量。</p>
<p>　　另一种方式是采用基于集装箱的<strong>模块化数据中心</strong>。在MDC中，工厂在一个集装箱内建造一个迷你数据中心，并将集装箱运送到数据中心位置。当许多组件发生故障并且性能下降到阈值时，整个容器会被换掉。对于MDC，有两种网络类型：每个容器内的容器内部网络和连接每个容器的核心网络。容器内部可以使用全连接拓扑，但核心网络存在吞吐量问题。</p>
<h3 id="web页面请求的流程">5.6 Web页面请求的流程</h3>
<img src="/network/computer_networking_a_top_down_approach_7e_chpt_05/process_of_a_web_page_request.svg" class="">
<p>　　用户的主机用以太网电缆连接到局域网的以太网交换机，以太网交换机连接着路由器，路由器连接着ISP(comcast)且ISP为局域网提供DNS服务。就像大多数情况，DHCP服务器在路由器内运行。假设主机刚连接，并<span
style="background-color: yellow">未</span>获得IP地址，获得IP地址后用户会访问google主页。</p>
<p>　　1) 主机生成<span
style="background-color: yellow">DHCP请求报文</span>并封装成源端口是68和目的端口是67的<span
style="background-color: yellow">UDP报文段</span>，进一步封装成源IP地址是<code>0.0.0.0</code>和目的IP地址是<code>255.255.255.255</code>的<span
style="background-color: yellow">IP数据报</span>，最后封装成源MAC地址是<code>FF:FF:FF:FF:FF:FF</code>和目的MAC地址是主机的MAC地址的<span
style="background-color: yellow">以太网帧</span>。</p>
<p>　　2) 主机将广播以太网帧发送到以太网交换机，以太网交换机是<span
style="background-color: yellow">自学习</span>的，它更新了交换机表，然后在所有的输出接口广播该帧。</p>
<p>　　3) 路由器收到帧后解封提取IP数据报，IP数据报<span
style="background-color: yellow">被分解</span>为UDP报文段并解封获取DHCP请求报文。路由器在<span
style="background-color: yellow">CIDR</span>块<code>68.85.2.0/24</code>中给主机分配了<code>68.85.2.101</code>并生成<span
style="background-color: yellow">DHCP
ACK报文</span>，报文除了包含该IP地址还包含DNS服务器的IP地址<code>68.87.71.226</code>、默认网关<code>68.85.2.1</code>以及子网掩码<code>68.85.2.0/24</code>。DHCP
ACK报文封装成UDP报文段再封装成以太网帧，以太网帧的源MAC地址是路由器接口的MAC地址，目的MAC地址是主机的MAC地址。路由器将以太网帧发送给以太网交换机。</p>
<p>　　4)
以太网交换机收到帧后，根据交换机表将帧转发给连接到主机的接口。</p>
<p>　　5) 主机收到帧后经过层层解封后提取DHCP
ACK报文，主机中的DHCP客户端根据报文记录IP地址和DNS服务器IP地址并在<span
style="background-color: yellow">IP转发表</span>中更新默认网关的表项。此时，主机以完成网络组件的初始化，可以开始访问Web页面。</p>
<p>　　6)
主机对google页面生成DNS查询报文，再封装成目的端口是53和目的IP地址是DNS服务器IP地址的数据报，最后封装成以太网帧。该帧将送给网关路由器，但主机并未获取网关路由器MAC地址，需要使用<span
style="background-color: yellow">ARP</span>，主机对默认网关生成<span
style="background-color: yellow">ARP查询报文</span>，层层封装成源MAC地址是<code>FF:FF:FF:FF:FF:FF</code>的以太网帧并发送给以太网交换机，以太网交换机转发给所有输出接口。</p>
<p>　　7) 网关路由器收到以太网帧后，层层解封提取ARP查询报文，生成<span
style="background-color: yellow">ARP响应报文</span>并层层封装成目的MAC地址为主机MAC地址的以太网帧，最后将该帧发送给以太网交换机，以太网交换机转发给主机。</p>
<p>　　8)
主机收到帧后，层层解封提取ARP响应报文并获得网关路由器的MAC地址，将之前待发送的帧的目的MAC地址设置为网关路由器的MAC地址并发送给以太网交换机，以太网交换机再转发给网关路由器。</p>
<p>　　9)
网关路由器收到帧后解封提取包含DNS查询报文的IP数据报。网关路由器根据数据报的目的IP地址和转发表再次封装成帧并转发给comcast网络的边界路由器。</p>
<p>　　10)
comcast网络的边界路由器收到帧后，解封提取IP数据报根据comcast的路由选择算法以及<span
style="background-color: yellow">IBGP</span>再次封装成帧并转发给DNS服务器。</p>
<p>　　11) DNS服务器收到帧后，层层解封提取DNS查询报文，根据<span
style="background-color: yellow">DNS源记录</span>生成<span
style="background-color: yellow">DNS应答报文</span>，封装成UDP报文段，再封装成IP数据报，最后封装成以太网帧反向转发给主机。</p>
<p>　　12) 主机收到帧后，层层解封并获得google主页的IP地址，创建<span
style="background-color: yellow">TCP套接字</span>用于将<span
style="background-color: yellow">HTTP
GET报文</span>发送给google主页。主机创建TCP套接字时必须先进行<span
style="background-color: yellow">三次握手</span>，主机生成一个80端口的<span
style="background-color: yellow">TCP
SYN报文段</span>并封装成目的MAC地址是网关路由器MAC地址的帧，最后将帧发送给以太网交换机。</p>
<p>　　13) 局域网、comcast网络和google网络的路由器根据<span
style="background-color: yellow">BGP</span>转发包含TCP
SYN报文段的数据报。</p>
<p>　　14) google网络的HTTP服务器收到帧后，生成<span
style="background-color: yellow">TCP
SYNACK报文段</span>并层层封装成目的MAC地址为google网络的第一跳路由器MAC地址的帧，最后转发给google网络的第一跳路由器。</p>
<p>　　14) 包含TCP
SYNACK报文段的数据报经过google网络、comcast网络和局域网到达主机。主机收到帧后，TCP进入连接状态。主机生成HTTP
GET报文并写入套接字，然后封装成TCP报文段，就像12~14步中发送给google网络中HTTP服务器。</p>
<p>　　15) google网络中HTTP服务器从TCP套接字中读取HTTP
GET报文，生成<span
style="background-color: yellow">HTTP响应报文</span>并发送到TCP套接字中。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第2章 信息的表示与处理</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_02/</url>
    <content><![CDATA[<p>　　使用了一千多年的十进制源于印度，12世纪被阿拉伯数学家改进并在13世纪被意大利数学家Leonardo
Pisano (即Fibonacci)
带到西方。对于有10个手指头的人类，十进制很自然。但是，现代计算机存储和处理的信息都是用二进制
(称为<strong>位</strong>) 表示，因为二进制更容易被表示、存储和传输。</p>
<p>　　单个位并不是很有用，当把位组合在一起并附加上<strong>解释</strong>来给不同的位模式赋予意义时，可以表示任何有限集合中的元素。</p>
<p>　　<strong>无符号</strong>编码基于传统的二进制表示法，表示非负数。<strong>补码</strong>编码是表示有符号整数
(有正负)
的最常见的方式。<strong>浮点</strong>编码是以2为基数的科学计数法版本，用于表示实数。</p>
<p>　　计算机的表示法使用有限数量的位来编码，所以当结果太大时以至于不能表示时，某些运算可能<strong>溢出</strong>，进而导致奇怪的结果。例如，对于<code>int</code>是32位的计算机，C计算<code>200 * 300 * 400 * 500</code>会得到−884901888。</p>
<p>　　计算机的整数运算满足数学中整数运算的许多属性
(例如，乘法的结合律和交换律)。计算机的浮点运算具有完全不同的数学属性。正数之间的乘积始终为正，尽管溢出时会产生特殊值<span
class="math inline">\(+\infty\)</span>。由于表示的精度有限，浮点运算是不可结合的。例如，对于大多数计算机，C计算<code>(3.14 + 1e20) - 1e20</code>会得到0.0。整数与浮点算术的不同数学属性源于它们处理表示的有限性的方式不同：整数是精确的，但只能表示范围相对较小的值；浮点数是近似的，但能表示范围相对较大的值。</p>
<p>　　在20世纪80年代之前，计算机制造商都会设计自己的浮点数表示规则以及相关运算细节，它们都更注重实现的速度和简便
(而非精确)。在1985年，这些随着IEEE 754的出现而发生了变化，IEEE
754是精心设计的标准，用于表示浮点数及其执行的操作。这些工作始于1976年，最初由Intel赞助，与8087
(为8086 CPU提供浮点支持的芯片)
的设计同时进行。Intel聘请了加州大学伯克利分校的教授William
Kahan作为顾问，帮助其为未来的CPU设计浮点标准。Intel允许Kahan与委员会合作，在IEEE的主持下制定行业标准。委员会最终采用的标准很接近Kahan为Intel制定的标准。</p>
<p>　　ASCII字符集适合对英文文档进行编码，但不支持特殊字符
(希腊语、俄语和中文等)。多年来，出现了很多对不同语言进行编码的方法。Unicode联盟制定了最全面和最广泛的文本编码标准，7.0版本的Unicode标准的拥有超过100000个字符，支持多种语言，包括古埃及语和古巴比伦语。此外，Unicode技术委员会否决了为克林贡语制定语言标准的提议。</p>
<p>　　Unicode的基本编码 (通用字符集)
中的字符都是32位，这似乎要求文本中的所有字符都占用4字节。但是，当常见字符仅占用1或2字节，不太常见的字符占用更多字节时，可以使用其他编码。例如，UTF-8将所有字符都编码为字节序列，并且ASCII字符使用与ASCII中相同的单字节编码
(ASCII字符序列在UTF-8中和在ASCII中具有相同的含义)。Java使用Unicode表示字符串，C也有支持Unicode的库。</p>
<p>　　由于二进制是计算机编码、存储和操作信息的核心，所以围绕0和1的研究已演化出了丰富的数学知识体系，这源于1850年左右的George
Boole (1815-1864)
的努力，所以称为<strong>布尔代数</strong>。Boole观察到，将逻辑值TRUE和FALSE编码为二进制值0和1，可以制定1种包含逻辑推理基本原理的代数。</p>
<p>　　ISO
C99在头文件<code>stdint.h</code>中新增了固定长度的整数类型，其声明形如<code>intN_t</code>和<code>uintN_t</code>，其中<code>N</code>表示<span
class="math inline">\(N\)</span>位的有符号和无符号整数，<code>N</code>的具体值与实现有关，但大多数编译器允许的值为8、16、32和64。这些整数类型有1组对应的宏：<code>INTN_MIN</code>、<code>INTN_MAX</code>和<code>UINTN_MAX</code>。</p>
<span id="more"></span>
<h3 id="信息存储">2.1 信息存储</h3>
<p>　　大多数计算机将<span
style="background-color: yellow">字节</span>作为最小的可寻址内存单元。应用程序将内存视为很大的字节数组，称为<strong>虚拟内存</strong>。内存的每个字节都由唯一的数字标识，称为<strong>地址</strong>，所有可能的地址集称为<strong>虚拟地址空间</strong>。</p>
<p>　　相比二进制和十进制，<span
style="background-color: yellow">十六进制</span>更适合描述位模式，因为它更精简且无需转换。</p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0001</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0010</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>0011</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>0100</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>0101</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>0110</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>0111</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>1000</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>1001</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>1010</td>
<td>10</td>
<td>A</td>
</tr>
<tr>
<td>1011</td>
<td>11</td>
<td>B</td>
</tr>
<tr>
<td>1100</td>
<td>12</td>
<td>C</td>
</tr>
<tr>
<td>1101</td>
<td>13</td>
<td>D</td>
</tr>
<tr>
<td>1110</td>
<td>14</td>
<td>E</td>
</tr>
<tr>
<td>1111</td>
<td>15</td>
<td>F</td>
</tr>
</tbody>
</table>
<p>　　在C中，十六进制以<code>0x</code>或<code>0X</code>开头，字符<code>A</code>~<code>F</code>大小写不限。</p>
<h4 id="数据长度">2.1.1 数据长度</h4>
<p>　　每个计算机都有<strong>字长</strong>，表示指针的标称大小。虚拟地址以这样的字来编码，所以字长决定虚拟地址空间的范围。对于字长为<span
class="math inline">\(w\)</span>位的计算机，虚拟地址的范围是<span
class="math inline">\(0\sim2^w-1\)</span>。32位虚拟地址空间为4GB，64位虚拟地址空间为16EB。</p>
<p>　　32位程序和64位程序的区别是编译过程。大多数64位计算机可以兼容32位程序。</p>
<p>　　计算机和编译器支持多种通过不同方法编码的数据格式
(例如，不同长度的整数和浮点数)。C中的某些数据类型的字节数取决于程序的编译方式。整数数据分为<span
style="background-color: yellow">有符号值</span> (有正负) 或<span
style="background-color: yellow">无符号值</span>
(非负)，关键字分别是<code>signed</code>和<code>unsigned</code>。大多数计算机都支持单精度和双精度浮点数，长度分别是4字节和8字节。</p>
<table>
<thead>
<tr>
<th>C有符号数</th>
<th>C无符号数</th>
<th>字节数 (32位)</th>
<th>字节数 (64位)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char</code></td>
<td><code>unsigned char</code></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>unsigned short</code></td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>unsigned</code></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>unsigned long</code></td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td><code>int32_t</code></td>
<td><code>uint32_t</code></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>int64_t</code></td>
<td><code>uint64_t</code></td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td><code>T *</code></td>
<td></td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td><code>float</code></td>
<td></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>double</code></td>
<td></td>
<td>8</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>　　大部分数据类型都会编码为有符号值，除非使用关键字<code>unsigned</code>声明或固定大小的无符号数据类型。但是，<code>char</code>是例外，大多数计算机和编译器都将<code>char</code>编码为有符号值，但C标准不保证这一点。当使用<code>char</code>存储1字节的有符号值时，应使用关键字<code>signed</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> l1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> l2;</span><br><span class="line"><span class="type">long</span> <span class="type">unsigned</span> l3;</span><br><span class="line"><span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> l4;</span><br></pre></td></tr></table></figure>
<p>　　C允许以多种方式来对关键字进行排序以及省略可选关键字，这里<code>l1</code>、<code>l2</code>、<code>l3</code>和<code>l4</code>意义相同。</p>
<p>　　对不同数据类型的确切大小不敏感是程序的可移植性的方面之一。C标准对不同数据类型的范围设置了下限但没有设置上限。当从32位程序迁移到64位程序时，很多隐藏的字长依赖项都会作为错误出现
(例如，32位程序中<code>int</code>类型的对象可用于存储指针，但这并不适用于64位程序)。</p>
<h4 id="寻址和字节顺序">2.1.2 寻址和字节顺序</h4>
<p>　　对于包含多个字节的程序对象，必须确定对象的地址以及字节在内存中的顺序。在几乎所有计算机中，多字节对象都存储为连续的字节序列，对象的地址是对应字节的地址中的最小地址。若<code>int</code>类型
(32位)
的变量<code>x</code>的地址为<code>0x100</code>，即地址表达式<code>&amp;x</code>的值是<code>0x100</code>，则<code>x</code>的4个字节存储在内存位置<code>0x100</code>、<code>0x101</code>、<code>0x102</code>和<code>0x103</code>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/big_endian_and_little_endian.svg" class="">
<p>　　以<span
class="math inline">\(w\)</span>位的整数为例，其位表示为<span
class="math inline">\([x_{w-1},x_{w-2},\cdots,x_1,x_0]\)</span>，其中<span
class="math inline">\(x_{w-1}\)</span>是最高有效位，<span
class="math inline">\(x_0\)</span>是最低有效位。若<span
class="math inline">\(w\)</span>是8的整数倍，则这些位可以分组为字节，其中最高有效字节包含位<span
class="math inline">\([x_{w-1},x_{w-2},\cdots
,x_{w-8}]\)</span>，最低有效字节包含位<span
class="math inline">\([x_7,x_6,\cdots
,x_0]\)</span>，其他字节包含中间的位。有些计算机按从低有效字节到高有效字节的顺序存储对象，而其他计算机从高有效字节到低有效字节的顺序存储对象。前者称为<strong>小端</strong>，后者称为<strong>大端</strong>。大多数与Intel兼容的计算机仅支持小端模式，IBM和Oracle的大多数计算机仅支持大端模式。部分CPU支持<strong>双端</strong>
(即支持这2种模式)。实际中，一旦选择了操作系统，字节顺序就会固定
(例如，许多手机使用的ARM CPU是双端，但Android和IOS仅支持小端模式)。</p>
<p>　　对于大多数应用程序程序员，计算机使用的字节顺序是完全不可见的。无论为哪种类型的计算机所编译的程序，都会得到相同的结果，但有时字节顺序会成为问题。</p>
<p>　　●
当二进制数据通过网络在不同计算机之间传输时，若发送端和接收端的字节顺序不同，则会导致发送端发送和数据与接收端收到的数据不一致。为了避免该问题，TCP/IP定义了<strong>网络字节顺序</strong>——通过网络传输的数据必须是大端。</p>
<p>　　● 当阅读表示整数数据的字节序列时，字节顺序很重要。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4004d3:	01 05 43 0b 20 00	add	%eax,0x200b43(%rip)</span><br></pre></td></tr></table></figure>
<p>　　这是Intel x86-64
CPU的机器级代码的文本表示，由反汇编器生成，<strong>反汇编器</strong>是获取可执行文件对应的指令序列的工具。十六进制字节序列<code>01 05 43 0b 20 00</code>是某条指令的字节级表示形式，该指令会将单字长的数据加到某个值上，该值的存储地址计算为<code>0x200b43</code>加上当前PC的值
(待执行的下一指令的地址)
。若将序列的最后4个字节<code>43 0b 20 00</code>视为小端，则得到<code>00 20 0b 43</code>，去掉开头的填充0，得到值<code>0x200b43</code>。</p>
<p>　　●
在编写绕过数据类型系统的程序时字节排序很重要。在C中，可以通过使用<strong>强制类型转换</strong>和<strong>联合</strong>来允许数据类型引用声明时数据类型不同于该数据类型的对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印对象的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param start 对象指针</span></span><br><span class="line"><span class="comment"> * @param len 对象长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]); <span class="comment">/* 至少用2个数字的十六进制格式输出 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印int的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_int</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印float的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_float</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印指针的字节表示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_pointer</span><span class="params">(<span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 测试函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param val</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_show_bytes</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ival = val;</span><br><span class="line">    <span class="type">float</span> fval = (<span class="type">float</span>)ival;</span><br><span class="line">    <span class="type">int</span> *pval = &amp;ival;</span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_float(fval);</span><br><span class="line">    show_pointer(pval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　若将函数<code>test_show_bytes()</code>的参数<code>val</code>指定为12345
(对应的十六进制是<code>0x00003039</code>)，则Windows 64 (小端)
的输出是<code>39 30 00 00</code>、<code>00 e4 40 46</code>和<code>4c fb 9f e4 9f 00 00 00</code>。<code>int</code>和<code>float</code>类型的12345的字节模式看似不同，将其转换为二进制后会发现有13个匹配的位序列。对于Linux
(小端)，以相同的方式调用该函数得到的结果中，12345的指针值很可能不同于这里的结果，因为指针值根据不同的计算机或操作系统配置的存储分配规则分配。</p>
<p>　　C中的字符串以字符<code>\0</code> (值为0)
结尾的字符数组编码。以ASCII为例，若将函数<code>show_bytes()</code>的参数<code>start</code>和<code>len</code>分别指定为<code>"12345"</code>和6，则可以得到结果<code>31 32 33 34 35 00</code>，因为十进制数字<span
class="math inline">\(n\)</span>的ASCII码值是<code>0x0n</code>，字符<code>\0</code>的ASCII码值为<code>0x00</code>。这在任何使用ASCII编码的系统上都可以获得相同的结果
(与字节顺序和字长无关)，所以文本数据比二进制数据更独立于平台。</p>
<h4 id="布尔代数简介">2.1.3 布尔代数简介</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/operations_of_boolean_algebra.svg" class="">
<p>　　最简单的布尔代数定义在双元集合<span
class="math inline">\(\{0,1\}\)</span>上。布尔运算~表示逻辑运算非，表示为<span
class="math inline">\(\lnot\)</span>。布尔运算&amp;表示逻辑运算与，表示为<span
class="math inline">\(\land\)</span>。布尔运算|表示逻辑运算或，表示为<span
class="math inline">\(\lor\)</span>。布尔运算^表示逻辑运算异或，表示为<span
class="math inline">\(\oplus\)</span>。</p>
<p>　　布尔运算也适用于<strong>位向量</strong> (长度为<span
class="math inline">\(w\)</span>，由0和1组成的序列)。若<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>分别表示位向量<span
class="math inline">\([a_{w-1},a_{w-2},\cdots ,a_0]\)</span>和<span
class="math inline">\([b_{w-1},b_{w-2},\cdots ,b_0]\)</span>，则<span
class="math inline">\(a\)</span> &amp; <span
class="math inline">\(b\)</span>可以定义为长度为<span
class="math inline">\(w\)</span>的位向量，其中第<span
class="math inline">\(i\)</span>个元素等于<span
class="math inline">\(a_i\)</span> &amp; <span
class="math inline">\(b_i\)</span>，类似的方法可以扩展到|、~和^上。</p>
<p>　　对于长度为<span
class="math inline">\(2^w\)</span>的位向量，布尔代数和整数算术有很多相似之处。类似乘法对加法的分配律，&amp;和|相互都有分配律，即<span
class="math inline">\(a\)</span> &amp; <span
class="math inline">\((b\)</span> | <span
class="math inline">\(c)=(a\)</span> &amp; <span
class="math inline">\(b)\)</span> | <span
class="math inline">\((a\)</span> &amp; <span
class="math inline">\(c)\)</span>和<span
class="math inline">\(a\)</span> | <span
class="math inline">\((b\)</span> &amp; <span
class="math inline">\(c)=(a\)</span> | <span
class="math inline">\(b)\)</span> &amp; <span
class="math inline">\((a\)</span> | <span
class="math inline">\(c)\)</span>。</p>
<p>　　对位向量进行布尔运算会得到<strong>布尔环</strong>。布尔环由<strong>幂等元</strong>组成
(所有元素都满足<span
class="math inline">\(x^2=x\)</span>)，布尔环与整数算术有很多相似之处
(例如，整数算术的属性之一是是每个值<span
class="math inline">\(n\)</span>都有1个<strong>加法逆元</strong><span
class="math inline">\(-n\)</span>，使得<span
class="math inline">\(n+-n=0\)</span>)。</p>
<p>　　位向量可用于表示有限集合，即用位向量<span
class="math inline">\([a_{w-1},a_{w-2},\cdots
,a_0]\)</span>对任何子集<span
class="math inline">\(A\subseteq\{0,1,\cdots
,w-1\}\)</span>编码，当<span class="math inline">\(i\in
A\)</span>时，<span class="math inline">\(a_i=1\)</span>。若<span
class="math inline">\(a_{w-1}\)</span>在最左侧，<span
class="math inline">\(a_0\)</span>在最右侧，则位向量<span
class="math inline">\(a=[01101001]\)</span>表示集合<span
class="math inline">\(A=\{0,3,5,6\}\)</span>，而<span
class="math inline">\(b=[01010101]\)</span>表示集合<span
class="math inline">\(B=\{0,2,4,6\}\)</span>。使用这种方式编码集合时，布尔运算|、&amp;和~分别表示交集、并集和补集。若<span
class="math inline">\(a\)</span> &amp; <span
class="math inline">\(b\)</span>会得到位向量<span
class="math inline">\([0100001]\)</span>，则<span
class="math inline">\(A\cap B=\{0,6\}\)</span>。</p>
<h4 id="c相关支持">2.1.4 C相关支持</h4>
<p>　　C支持布尔运算，其符号也是<code>~</code>、<code>&amp;</code>、<code>|</code>和<code>^</code>，适用于所有整数数据类型。</p>
<p>　　位级运算可用于实现<strong>掩码</strong>运算，掩码属于位模式，表示字中特定位的位模式
(例如，掩码<code>0xFF</code>表示字中的低位字节)。<code>n &amp; 0xFF</code>会得到低位字节是<code>n</code>的低位字节，其他字节全为0的结果。<code>~0</code>会得到所有位全为1的掩码。</p>
<p>　　C也提供了逻辑运算符<code>||</code>、<code>&amp;&amp;</code>和<code>!</code>，分别对应逻辑或、与和非运算。</p>
<p>　　C还支持<strong>移位</strong>运算，用于向左和向右移动位模式。对于位模式为<span
class="math inline">\([x_{w-1},x_{w-2},\cdots
,x_0]\)</span>的操作数<code>x</code>，<code>x &lt;&lt; k</code>的位模式是<span
class="math inline">\([x_{w-k-1},x_{w-k-w},\cdots ,x_0,0,\cdots
,0]\)</span>，即<code>x</code>向左移动<span
class="math inline">\(k\)</span>位，丢弃最高<span
class="math inline">\(k\)</span>位并在右端补<span
class="math inline">\(k\)</span>个0。显然，偏移量应该介于0和<span
class="math inline">\(w-1\)</span>之间。移位操作从左到右执行，所以<code>x &lt;&lt; j &lt;&lt; k</code>等同于<code>(x &lt;&lt; j) &lt;&lt; k</code>。</p>
<p>　　计算机通常支持<strong>逻辑右移</strong>和<strong>算术右移</strong>。对于<code>x &gt;&gt; k</code>，逻辑右移类似于右移，会直接在左端补<span
class="math inline">\(k\)</span>个0。算术右移会在左端补<span
class="math inline">\(k\)</span>个最高有效位的值，即<span
class="math inline">\([x_{w-1},\cdots ,x_{w-1},x_{w-1},x_{w-2},\cdots
x_k]\)</span>，主要用于有符号数。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>值1</th>
<th>值2</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td>[01100011]</td>
<td>[10010101]</td>
</tr>
<tr>
<td><code>x &lt;&lt; 4</code></td>
<td>[0011<strong>0000</strong>]</td>
<td>[0101<strong>0000</strong>]</td>
</tr>
<tr>
<td><code>x &gt;&gt; 4</code> (逻辑右移)</td>
<td>[<strong>0000</strong>0011]</td>
<td>[<strong>0000</strong>1001]</td>
</tr>
<tr>
<td><code>x &gt;&gt; 4</code> (算术右移)</td>
<td>[<strong>0000</strong>0011]</td>
<td>[<strong>1111</strong>1001]</td>
</tr>
</tbody>
</table>
<p>　　C标准没有定义有符号数所使用的右移类型。实际中，几乎所有编译器和计算机会对有符号数使用算术右移，对无符号数使用逻辑右移。对于<span
class="math inline">\(w\)</span>位的数据类型，移动<span
class="math inline">\(k\)</span> (<span class="math inline">\(k\geqslant
w\)</span>)位，实际位移量为<span class="math inline">\(k\bmod
w\)</span>。</p>
<h3 id="整数表示">2.2 整数表示</h3>
<p>　　数学术语<strong>双射</strong>指函数<span
class="math inline">\(f\)</span>有2种映射方式，可以将数字<span
class="math inline">\(x\)</span>映射为数值<span
class="math inline">\(y\)</span>，即<span
class="math inline">\(y=f(x)\)</span>，也可以反向操作，因为对于每个<span
class="math inline">\(y\)</span>都有唯一的<span
class="math inline">\(x\)</span>满足<span
class="math inline">\(f(x)=y\)</span>，这通过<strong>反函数</strong><span
class="math inline">\(f^{-1}\)</span>来表示，即<span
class="math inline">\(x=f^{-1}(y)\)</span>。</p>
<p>　　下表列出了用于定义和描述计算机如何编码和操作整数数据的数学术语：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(B2T_w\)</span></td>
<td>函数</td>
<td>二进制转补码</td>
</tr>
<tr>
<td><span class="math inline">\(B2U_w\)</span></td>
<td>函数</td>
<td>二进制转无符号数</td>
</tr>
<tr>
<td><span class="math inline">\(U2B_w\)</span></td>
<td>函数</td>
<td>无符号数转二进制</td>
</tr>
<tr>
<td><span class="math inline">\(U2T_w\)</span></td>
<td>函数</td>
<td>无符号数转补码</td>
</tr>
<tr>
<td><span class="math inline">\(T2B_w\)</span></td>
<td>函数</td>
<td>补码转二进制</td>
</tr>
<tr>
<td><span class="math inline">\(T2U_w\)</span></td>
<td>函数</td>
<td>补码转无符号数</td>
</tr>
<tr>
<td><span class="math inline">\(TMin_w\)</span></td>
<td>常数</td>
<td>补码的最小值</td>
</tr>
<tr>
<td><span class="math inline">\(TMax_w\)</span></td>
<td>常数</td>
<td>补码的最大值</td>
</tr>
<tr>
<td><span class="math inline">\(UMax_w\)</span></td>
<td>常数</td>
<td>无符号数的最大值</td>
</tr>
<tr>
<td><span class="math inline">\(+^t_w\)</span></td>
<td>操作符</td>
<td>补码加法</td>
</tr>
<tr>
<td><span class="math inline">\(+^u_w\)</span></td>
<td>操作符</td>
<td>无符号数加法</td>
</tr>
<tr>
<td><span class="math inline">\(*^t_w\)</span></td>
<td>操作符</td>
<td>补码乘法</td>
</tr>
<tr>
<td><span class="math inline">\(*^u_w\)</span></td>
<td>操作符</td>
<td>无符号数乘法</td>
</tr>
<tr>
<td><span class="math inline">\(-^t_w\)</span></td>
<td>操作符</td>
<td>补码取反</td>
</tr>
<tr>
<td><span class="math inline">\(-^u_w\)</span></td>
<td>操作符</td>
<td>无符号数取反</td>
</tr>
</tbody>
</table>
<h4 id="整数数据类型">2.2.1 整数数据类型</h4>
<p>　　C支持多种整数数据类型
(用<code>char</code>、<code>short</code>和<code>long</code>等关键字声明)：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">C整数数据类型</th>
<th style="text-align: left;">32位程序的取值范围</th>
<th style="text-align: left;">64位程序的取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>char</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^7\sim2^7-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^7\sim2^7-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned char</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^8-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^8-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>short</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{15}\sim2^{15}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{15}\sim2^{15}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned short</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{16}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{16}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned long</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{64}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int32_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}\sim2^{31}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int64_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{63}\sim2^{63}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>uint64_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{64}-1\)</span></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{64}-1\)</span></td>
</tr>
</tbody>
</table>
<p>　　C标准定义了所有整数数据类型的最小取值范围
(对于有符号数，正数和负数的取值范围是对称)：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">C整数数据类型</th>
<th style="text-align: left;">C标准定义的最小取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>char</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^7+1\sim2^7-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned char</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^8-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>short</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{15}+1\sim2^{15}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned short</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{16}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{15}+1\sim2^{15}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{16}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>long</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}+1\sim2^{31}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>unsigned long</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{32}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int32_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{31}+1\sim2^{31}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>uint32_t</code></td>
<td style="text-align: left;"><span class="math inline">\(0\sim
2^{32}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>int64_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(-2^{63}+1\sim2^{63}-1\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><code>uint64_t</code></td>
<td style="text-align: left;"><span
class="math inline">\(0\sim2^{64}-1\)</span></td>
</tr>
</tbody>
</table>
<p>　　在C中，当处理包含有符号数和无符号数组合的表达式时，会先将有符号数隐式转换为无符号数
(例如，对于比较式<code>-1 &lt; 0U</code>，若两者都是32位，则<code>-1</code>会转换为<code>4294967295U</code>，所以该比较式会返回0)。此外，在将位模式较短的有符号数转换为位模式较长的无符号数时，需要先进行符号扩展，再进行有符号数到无符号数的转换。</p>
<h4 id="整数编码">2.2.2 整数编码</h4>
<p>　　对于<span class="math inline">\(w\)</span>位的整数<span
class="math inline">\(x\)</span>，其位向量表示为<span
class="math inline">\(\vec{x}\)</span>。</p>
<p>　　将<span
class="math inline">\(\vec{x}\)</span>视为二进制表示的数就可以得到<span
class="math inline">\(\vec{x}\)</span>的无符号表示。在此编码中，每个位<span
class="math inline">\(x_i\)</span>的值都为0或1，值为1表示<span
class="math inline">\(2^i\)</span>是数字值的一部分。 <span
class="math display">\[
B2U_w(\vec{x})=\sum_{i=0}^{w-1}x_i2^i
\]</span> 　　对于无符号数，<span
class="math inline">\(\vec{x}\)</span>的最小值是位向量<span
class="math inline">\([00\cdots 0]\)</span>，最大值是位向量<span
class="math inline">\([11\cdots 1]\)</span> (其整数值<span
class="math inline">\(UMax_w=2^w-1\)</span>)，所以函数<span
class="math inline">\(B2U_w\)</span>能定义为映射<span
class="math inline">\(B2U_w:\{0,1\}^w\rightarrow\{0,\cdots
,UMax_w\}\)</span>。<span
class="math inline">\(B2U_w\)</span>是双射，它能将每个长度为<span
class="math inline">\(w\)</span>的位向量映射到<span
class="math inline">\(0\sim2^w-1\)</span>之间的唯一整数，也能将<span
class="math inline">\(0\sim2^w-1\)</span>之间的每个整数映射到唯一的长度为<span
class="math inline">\(w\)</span>的位模式 (即<span
class="math inline">\(U2B_w\)</span>)。</p>
<p>　　在补码中，最高有效位解释为<strong>负权</strong>，也称为<strong>符号位</strong>，其权重为<span
class="math inline">\(-2^{w-1}\)</span>。 <span class="math display">\[
B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i
\]</span> 　　对于补码，<span
class="math inline">\(\vec{x}\)</span>的最小值是位向量<span
class="math inline">\([10\cdots 0]\)</span> (其整数值<span
class="math inline">\(TMin_w=-2^{w-1}\)</span>)，最大值是位向量<span
class="math inline">\([01\cdots 1]\)</span> (其整数值<span
class="math inline">\(TMax=2^{w-1}-1\)</span>)，所以函数<span
class="math inline">\(B2T_w\)</span>能定义为映射<span
class="math inline">\(B2T_w:\{0,1\}^w\rightarrow\{TMin_w,\cdots
,TMax_w\}\)</span>。<span
class="math inline">\(B2T_w\)</span>同样也是双射。</p>
<p>　　C标准并未要求有符号数以补码形式表示，但几乎所有计算机都这样做。头文件<code>limits.h</code>定义了1组常量来限定运行编译器的计算机的不同整数数据类型的取值范围。例如，常量<code>INT_MIN</code>和<code>INT_MAX</code>定义了<code>int</code>的取值范围，常量<code>UINT_MAX</code>定义了<code>unsigned</code>的取值范围。</p>
<p>　　有符号数也能表示为<strong>反码</strong>，其最高有效位的权重是<span
class="math inline">\(-2^{w-1}+1\)</span>。 <span
class="math display">\[
B2O_w(\vec{x})=-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_i2^i
\]</span>
　　有符号数还能表示为<strong>原码</strong>，其最高有效位是符号位，用于确定其他位是负权或正权。
<span class="math display">\[
B2S_w(\vec{x})=(-1)^{x_{w-1}} \cdot(\sum_{i=0}^{w-2}x_i2^i)
\]</span>
　　原码和反码都有1个奇怪的特性——数字0有2种不同的编码，两者都将<span
class="math inline">\([00\cdots 0]\)</span>解释为+0，前者将<span
class="math inline">\([10\cdots 0]\)</span>解释为-0，后者将<span
class="math inline">\([11\cdots 1]\)</span>解释为-0。</p>
<p>　　补码的命名 (two's complement) 源于情况：对于非负<span
class="math inline">\(x\)</span>，<span
class="math inline">\(2^w-x\)</span>可用于计算<span
class="math inline">\(-x\)</span>的<span
class="math inline">\(w\)</span>位表示 (单个2)。反码的命名 (ones'
complement) 源于属性：<span class="math inline">\([111\cdots
1]-x\)</span>可用于计算<span class="math inline">\(-x\)</span>的反码表示
(多个1)。</p>
<h4 id="有符号数和无符号数的转换">2.2.3 有符号数和无符号数的转换</h4>
<p>　　C允许在表示数字的不同数据类型之间转换
(例如，从有符号数转换到无符号数)，这种转换通常基于位 (而非数字)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> v = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> uv = (<span class="type">unsigned</span> <span class="type">short</span>)v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v = %d, uv = %u\n&quot;</span>, v, uv); <span class="comment">/* v = -12345, uv = 53191 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> ui = (<span class="type">unsigned</span>)i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d, ui = %u\n&quot;</span>, i, ui); <span class="comment">/* i = -1, ui = 4294967295 */</span></span><br></pre></td></tr></table></figure>
<p>　　-12345的16位补码与53191的16位无符号表示相同，-1的32位补码也与4294967295的32位无符号表示相同。这是大多数C中大多数相同字长的有符号数和无符号数之间的转换规则，即数值可能改变，但位模式不会变。对于整数<span
class="math inline">\(x\)</span>，当<span
class="math inline">\(x\)</span>满足<span
class="math inline">\(0\leqslant x\leqslant UMax_w\)</span>时，函数<span
class="math inline">\(U2B_w(x)\)</span>会得到<span
class="math inline">\(x\)</span>的唯一<span
class="math inline">\(w\)</span>位无符号表示形式。同样，当<span
class="math inline">\(x\)</span>满足<span
class="math inline">\(TMin_w\leqslant x\leqslant
TMax_w\)</span>时，函数<span
class="math inline">\(T2B_w(x)\)</span>会得到<span
class="math inline">\(x\)</span>的唯一<span
class="math inline">\(w\)</span>位补码表示形式。 <span
class="math display">\[
\begin{aligned}
T2U_w(x)&amp;= B2U_w(T2B_w(x))\\[3px]
U2T_w(x)&amp;= B2T_w(U2B_w(x))
\end{aligned}
\]</span>
　　<code>0xCFC7</code>的16位位模式既是-12345的补码表示，也是53191的无符号表示，而两者的绝对值之和是<span
class="math inline">\(2^{16}\)</span>。该属性也适用于给定位模式表示的两个数值
(补码和无符号数) 之间的关系，无符号表示中<span
class="math inline">\(UMax\)</span>和-1的补码具有相同的位模式，所以<span
class="math inline">\(1+UMax_w=2^w\)</span>。</p>
<p>　　对于位模式<span
class="math inline">\(\vec{x}\)</span>，当计算<span
class="math inline">\(B2U(\vec{x})-B2T(\vec{x})\)</span>时，0到<span
class="math inline">\(w-2\)</span>位的加权和将相互抵消，最后得到<span
class="math inline">\(x_{w-1}2^w\)</span>。 <span
class="math display">\[
B2U_w(T2B_w(x))=T2U_w(x)=x+x_{w-1}2^w
\]</span> 　　在<span
class="math inline">\(x\)</span>的补码表示中，位<span
class="math inline">\(x_{w-1}\)</span>决定了<span
class="math inline">\(x\)</span>的正负。 <span class="math display">\[
T2U_w(x)=
\begin{cases}
x+2^w&amp;&amp;{TMin_x\leqslant x&lt;0}\\
x&amp;&amp;{0\leqslant x\leqslant TMax_w}
\end{cases}
\]</span> 　　假设<span
class="math inline">\(\vec{u}=U2B_w(u)\)</span>，即<span
class="math inline">\(U2T_w(u)\)</span>的补码表示。 <span
class="math display">\[
U2T_w(u)=-u_{w-1}2^w+u
\]</span> 　　对于<span
class="math inline">\(u\)</span>的无符号表示，位<span
class="math inline">\(u_{w-1}\)</span>决定<span
class="math inline">\(u\)</span>是否大于<span
class="math inline">\(TMax_w=2^{w-1}-1\)</span>。 <span
class="math display">\[
U2T_w(u)=
\begin{cases}
u&amp;&amp;{0\leqslant u\leqslant TMax_w}\\
u-2^w&amp;&amp;{TMax_w&lt;u\leqslant UMax_w}
\end{cases}
\]</span> 　　当整数<span class="math inline">\(x\)</span>满足<span
class="math inline">\(0\leqslant x\leqslant TMax_w\)</span>时，<span
class="math inline">\(T2U_w(x)=U2T_w(x)=x\)</span>，在此范围之外的转换需要加上或减去<span
class="math inline">\(2^w\)</span>。</p>
<h4 id="扩展整数的位表示">2.2.4 扩展整数的位表示</h4>
<p>　　<strong>零扩展</strong> (在位模式的开头填充0)
可用于将无符号数转换为位模式更长的无符号数。</p>
<p>　　假设<span class="math inline">\(w\)</span>位位向量<span
class="math inline">\(\vec{u}=[u_{w-1},u_{w-2},\cdots
,u_0]\)</span>，<span class="math inline">\(w&#39;\)</span>位位向量<span
class="math inline">\(\vec{u}&#39;=[0,\cdots ,0,u_{w-1},u_{w-2},\cdots
,u_0]\)</span>，当<span
class="math inline">\(w&#39;&gt;w\)</span>时，<span
class="math inline">\(B2U_w(\vec{u})=B2T_{w&#39;}(\vec{u}&#39;)\)</span>。</p>
<p>　　<strong>符号扩展</strong> (在位模式的开头填充最高有效位)
可用于将有符号数转换为位模式更长的有符号数。</p>
<p>　　假设<span class="math inline">\(w\)</span>位位向量<span
class="math inline">\(\vec{x}=[x_{w-1},x_{w-2},\cdots
,x_0]\)</span>，<span class="math inline">\(w&#39;\)</span>位位向量<span
class="math inline">\(\vec{x}&#39;=[x_{w-1},\cdots
,x_{w-1},x_{w-1},x_{w-2},\cdots ,x_0]\)</span>，当<span
class="math inline">\(w&#39;&gt;w\)</span>时，<span
class="math inline">\(B2U_w(\vec{u})=B2U_{w&#39;}(\vec{u}&#39;)\)</span>。若<span
class="math inline">\(w&#39;=w+k\)</span>，则需证明： <span
class="math display">\[
B2T_{w+k}([x_{w-1},...,x_{w-1},x_{w-1},x_{w-2},...,x_0])=B2T_w([x_{w-1},x_{w-2},...,x_0])
\]</span>
　　根据数学归纳法，若能证明符号扩展1位时数值不变，则符号扩展到任意位时数值也不变。
<span class="math display">\[
\begin{aligned}
B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},...,x_0])&amp;=-x_{w-1}2^w+\sum^{w-1}_{i=0}x_i2^i\\[3px]
&amp;=-x_{w-1}2^w+x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i\\[3px]
&amp;=-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}x_i2^i\\[3px]
&amp;=B2T_w([x_{w-1},x_{w-2},...,x_0])
\end{aligned}
\]</span></p>
<h4 id="截断数值">2.2.5 截断数值</h4>
<p>　　当将<span class="math inline">\(w\)</span>位位向量截断为<span
class="math inline">\(k\)</span>位时，会丢弃高<span
class="math inline">\(w-k\)</span>位，这可能会改变其值
(这种情况也属于溢出)。</p>
<p>　　假设<span class="math inline">\(w\)</span>位位向量<span
class="math inline">\(\vec{x}=[x_{w-1},w_{w-2},\cdots
,x_0]\)</span>，截断为<span
class="math inline">\(k\)</span>位后的结果<span
class="math inline">\(\vec{x}&#39;=[x_{k-1},w_{k-2},\cdots
,x_0]\)</span>，并且<span
class="math inline">\(x=B2U_w(\vec{x})\)</span>，<span
class="math inline">\(x&#39;=B2U_w(\vec{x}&#39;)\)</span>，则<span
class="math inline">\(x&#39;=x\bmod 2^k\)</span>。 <span
class="math display">\[
\begin{aligned}
B2U([x_{w-1},x_{w-2},...,x_0])\bmod
2^k&amp;=[\sum_{i=0}^{w-1}x_i2^i]\bmod 2^k\\[3px]
&amp;=[\sum_{i=0}^{k-1}x_i2^i]\bmod 2^k\\[3px]
&amp;=\sum^{k-1}_{i=0}x_i2^i\\[3px]
&amp;=B2U_k([x_{k-1},x_{k-2},...,x_0])
\end{aligned}
\]</span> 　　对于无符号数，所有截断的位都具有形如<span
class="math inline">\(2^i\)</span> (<span
class="math inline">\(i\geqslant
k\)</span>)的权重，这些权重都在模运算时会得到0。</p>
<p>　　假设<span class="math inline">\(w\)</span>位位向量<span
class="math inline">\(\vec{x}=[x_{w-1},w_{w-2},\cdots
,x_0]\)</span>，截断为<span
class="math inline">\(k\)</span>位后的结果<span
class="math inline">\(\vec{x}&#39;=[x_{k-1},w_{k-2},\cdots
,x_0]\)</span>，并且<span
class="math inline">\(x=B2T_w(\vec{x})\)</span>，<span
class="math inline">\(x&#39;=B2T_w(\vec{x}&#39;)\)</span>，则<span
class="math inline">\(x&#39;=U2T_k(x\bmod 2^k)\)</span>。</p>
<h3 id="整数运算">2.3 整数运算</h3>
<h4 id="无符号运算">2.3.1 无符号运算</h4>
<p>　　对于位模式为<span
class="math inline">\(w\)</span>位的无符号数<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>，两者的运算<span
class="math inline">\(+^u_w\)</span>就是把和<span
class="math inline">\(x+y\)</span>的位模式截断为<span
class="math inline">\(w\)</span>位后的结果转换为无符号数。当<span
class="math inline">\(x+y\geqslant
2^w\)</span>时，会发生溢出，溢出后的结果小于<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>。当执行C程序时，溢出不会导致错误。
<span class="math display">\[
x+^u_wy=
\begin{cases}
x+y&amp;&amp;{0\leqslant x+y&lt;2^w}\\
x+y-2^w&amp;&amp;{2^w\leqslant x+y&lt;2^{w+1}}
\end{cases}
\]</span>
　　模加法会形成<strong>阿贝尔群</strong>。阿贝尔群以挪威数学家Niels
Henrik Abel (1802~1829)
命名，它是可交换和可结合的。阿贝尔群有1个单元0，并且每个元素都有1个加法逆元。对于位模式为<span
class="math inline">\(w\)</span>位的无符号数<span
class="math inline">\(x\)</span>，必有1个值<span
class="math inline">\(-^u_wx\)</span>满足<span
class="math inline">\(-^u_wx+^u_wx=0\)</span>。 <span
class="math display">\[
-^u_wx=
\begin{cases}
x&amp;&amp;{x=0}\\
2^w-x&amp;&amp;{0&lt;x\leqslant 2^w-1}
\end{cases}
\]</span></p>
<p>　　<span class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>的运算<span
class="math inline">\(*^u_w\)</span>是将乘积<span
class="math inline">\(x\cdot y\)</span>的位模式 (<span
class="math inline">\(2w\)</span>位) 截断为<span
class="math inline">\(w\)</span>位后的结果转换为无符号数。 <span
class="math display">\[
x*^u_wy=(x\cdot y)\bmod 2^w
\]</span></p>
<h4 id="补码运算">2.3.2 补码运算</h4>
<p>　　对于位模式为<span class="math inline">\(w\)</span>位的补码<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>，两者的运算<span
class="math inline">\(+^t_w\)</span>就是把和<span
class="math inline">\(x+y\)</span>的位模式截断为<span
class="math inline">\(w\)</span>位后的结果转换为补码。</p>
<p>　　<span class="math inline">\(+^t_w\)</span>与<span
class="math inline">\(+^u_w\)</span>有相同的位级表示，所以<span
class="math inline">\(+^t_w\)</span>等同于先将操作数转换为无符号数进行<span
class="math inline">\(+^u_w\)</span>，再转换为补码。 <span
class="math display">\[
\begin{aligned}
x+^t_wy&amp;=U2T_w(T2U_w(x)+^u_wT2U(y))\\[3px]
&amp;=U2T_w[(x_{w-1}2^w+x+y_{w-1}2^w+y)\bmod2^w]\\[3px]
&amp;=U2T_w[(x+y)\bmod 2^w]
\end{aligned}
\]</span> 　　假设<span class="math inline">\(z=x+y\)</span>，<span
class="math inline">\(z&#39;= z\bmod2^w\)</span>，<span
class="math inline">\(z&#39;&#39;= U2T(z&#39;)=x+^t_wy\)</span>。</p>
<p>　　● 当<span class="math inline">\(-2^w\leqslant
z&lt;-2^{w-1}\)</span>时，<span
class="math inline">\(z&#39;=z+2^w\)</span>，所以<span
class="math inline">\(0\leqslant z&#39;&lt;-2^{w-1}\)</span>，<span
class="math inline">\(z&#39;&#39;=z&#39;\)</span>，此时，两个负数相加得到正数，称为<strong>负溢出</strong>。</p>
<p>　　● 当<span class="math inline">\(-2^{w-1}\leqslant
z&lt;0\)</span>时，<span
class="math inline">\(z&#39;=z+2^w\)</span>，所以<span
class="math inline">\(2^{2-1}\leqslant z&#39;&lt;2^w\)</span>，<span
class="math inline">\(z&#39;&#39;=z\)</span>。</p>
<p>　　● 当<span class="math inline">\(0\leqslant
z&lt;2^{w-1}\)</span>时，<span
class="math inline">\(z&#39;=z\)</span>，所以<span
class="math inline">\(0\leqslant z&#39;&lt;2^{w-1}\)</span>，<span
class="math inline">\(z&#39;&#39;=z\)</span>。</p>
<p>　　● 当<span class="math inline">\(2^{w-1}\leqslant
z&lt;2^w\)</span>时，<span
class="math inline">\(z&#39;=z\)</span>，所以<span
class="math inline">\(2^{w-1}\leqslant z&#39;&lt;2^w\)</span>，<span
class="math inline">\(z&#39;&#39;=z-2^w\)</span>，此时，两个正数相加得到负数，称为<strong>正溢出</strong>。
<span class="math display">\[
x+^t_wy=
\begin{cases}
x+y+2^w&amp;&amp;{-2^w\leqslant x+y&lt;-2^{w-1}}\\
x+y&amp;&amp;{-2^{w-1}\leqslant x+y&lt;2^{w-1}}\\
x+y-2^w&amp;&amp;{2^{w-1}\leqslant x+y&lt;2^w}
\end{cases}
\]</span> 　　<span
class="math inline">\(TMin_w+TMin_w=-2^w\)</span>会导致负溢出，所以<span
class="math inline">\(TMin_w+^t_wTMin_w=0\)</span>。若<span
class="math inline">\(x&gt;Tmin_w\)</span>，并且<span
class="math inline">\(-x\)</span>可以表示为<span
class="math inline">\(w\)</span>位的补码，则<span
class="math inline">\(-x+x=0\)</span>。 <span class="math display">\[
-^t_wx=
\begin{cases}
TMin_w&amp;&amp;{x=-2^{w-1}}\\
-x&amp;&amp;{-2^{w-1}&lt;x\leqslant 2^{w-1}-1}
\end{cases}
\]</span> 　　获取<span
class="math inline">\(-^t_wx\)</span>的有2种方法。第1种方法是将<span
class="math inline">\(x\)</span>的位模式中的所有位取反并将结果加1。第2种方法是先找到<span
class="math inline">\(x\)</span>的位模式中的最右边的1，然后将其左侧的所有位取反。</p>
<p>　　对于<span class="math inline">\(w\)</span>位位向量<span
class="math inline">\(\vec{x}\)</span>和<span
class="math inline">\(\vec{y}\)</span>，<span
class="math inline">\(x=B2T_w(\vec{x})\)</span>，<span
class="math inline">\(y=B2T_w(\vec{y})\)</span>，<span
class="math inline">\(x&#39;=B2U_w(\vec{x})\)</span>，<span
class="math inline">\(y&#39;=B2U_w(\vec{y})\)</span>。 <span
class="math display">\[
\begin{aligned}
(x&#39;\cdot y&#39;)\bmod
2^w&amp;=[(x+x_{w-1}2^w)\cdot(y+y_{w-1}2^w)]\bmod 2^w\\[3px]
&amp;=[x\cdot y+(x_{w-1}y+y_{w-1}x)2^w+x_{w-1}y_{w-1}2^{2w}]\bmod
2^w\\[3px]
&amp;=(x\cdot y)\bmod 2^w
\end{aligned}
\]</span> 　　因此，无符号数和补码乘法运算的位级表示相同。</p>
<p>　　<span class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>的运算<span
class="math inline">\(*^t_w\)</span>也是将乘积<span
class="math inline">\(x\cdot y\)</span>的位模式 (<span
class="math inline">\(2w\)</span>位) 截断为<span
class="math inline">\(w\)</span>位后的结果转换为补码。 <span
class="math display">\[
x*^t_wy=U2T_w((x\cdot y)\bmod 2^w)
\]</span></p>
<h4 id="除以2的幂">2.3.3 除以2的幂</h4>
<p>　　除以2的幂可以用右移操作实现，逻辑右移和算术右移分别对应无符号值和补码值。因此，大多数计算机都支持这2种右移，但这种方法并不适用于所有整数。</p>
<p>　　对于实数<span class="math inline">\(a\)</span>，<span
class="math inline">\(\lfloor a \rfloor\)</span>表示唯一整数<span
class="math inline">\(a&#39;\)</span>，使得<span
class="math inline">\(a&#39;\leqslant a\leqslant
a&#39;+1\)</span>。<span class="math inline">\(\lceil a
\rceil\)</span>表示唯一整数<span
class="math inline">\(a&#39;&#39;\)</span>，使得<span
class="math inline">\(a&#39;&#39;-1 \leqslant a\leqslant
a&#39;&#39;\)</span>。</p>
<p>　　整数除法通常向零舍入
(结果为正时向下舍入，结果为负时向上舍入)。因此，当<span
class="math inline">\(x\geqslant 0\)</span>和<span
class="math inline">\(y&gt;0\)</span>时，会得到<span
class="math inline">\(\lfloor \frac{x}{y} \rfloor\)</span>；当<span
class="math inline">\(x&lt;0\)</span>和<span
class="math inline">\(y&gt;0\)</span>时，会得到<span
class="math inline">\(\lceil \frac{x}{y} \rceil\)</span>。</p>
<h5 id="无符号数除以2的幂">2.3.3.1 无符号数除以2的幂</h5>
<p>　　若C变量<code>x</code>和<code>k</code>的值分别为无符号值<span
class="math inline">\(x\)</span>和<span
class="math inline">\(k\)</span>，<span
class="math inline">\(x\)</span>的位模式是<span
class="math inline">\([x_{w-1},x_{w-2},...,x_0]\)</span>，并且<span
class="math inline">\(0\leqslant
k&lt;w\)</span>，则<code>x &gt;&gt; k</code>会执行逻辑右移并向下舍入。</p>
<p>　　若<span class="math inline">\(x&#39;\)</span>表示<span
class="math inline">\(x\)</span>的高<span
class="math inline">\(w-k\)</span>位的位模式<span
class="math inline">\([x_{w-1},x_{w-2},...,x_k]\)</span>，<span
class="math inline">\(x&#39;&#39;\)</span>表示<span
class="math inline">\(x\)</span>的低<span
class="math inline">\(k\)</span>位的位模式<span
class="math inline">\([x_{k-1},...,x_0]\)</span>，则<span
class="math inline">\(x=2^kx&#39;+x&#39;&#39;\)</span> (<span
class="math inline">\(0\leqslant
x&#39;&#39;&lt;2^k\)</span>)。因此，<span class="math inline">\(\lfloor
\frac{x}{2^k} \rfloor=x&#39;\)</span>。</p>
<p>　　下表是对12340的16位表示进行逻辑右移后的结果
(粗体表示从左边移入的0)：</p>
<table>
<thead>
<tr>
<th><code>k</code></th>
<th><code>&gt;&gt; k</code> (二进制)</th>
<th>十进制</th>
<th><code>12340 / (2 ^ k)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0011000000110100</td>
<td>12340</td>
<td>12340.0</td>
</tr>
<tr>
<td>1</td>
<td><strong>0</strong>001100000011010</td>
<td>6170</td>
<td>6170.0</td>
</tr>
<tr>
<td>4</td>
<td><strong>0000</strong>001100000011</td>
<td>771</td>
<td>771.25</td>
</tr>
<tr>
<td>8</td>
<td><strong>00000000</strong>00110000</td>
<td>48</td>
<td>48.203125</td>
</tr>
</tbody>
</table>
<h5 id="补码除以2的幂">2.3.3.2 补码除以2的幂</h5>
<p>　　若C变量<code>x</code>和<code>k</code>的值分别是补码值<span
class="math inline">\(x\)</span>和无符号值<span
class="math inline">\(k\)</span>，<span
class="math inline">\(x\)</span>的位模式是<span
class="math inline">\([x_{w-1},x_{w-2},...,x_0]\)</span>，并且<span
class="math inline">\(0\leqslant
k&lt;w\)</span>，则<code>x &gt;&gt; k</code>会执行算术右移并向下舍入。</p>
<p>　　当<span class="math inline">\(x\geqslant 0\)</span>时，<span
class="math inline">\(x\)</span>的最高位是0，算术右移与逻辑右移相同。当<span
class="math inline">\(x&lt;0\)</span>时，算术右移<span
class="math inline">\(k\)</span>位后，高<span
class="math inline">\(k\)</span>位都会变为1，刚好是<span
class="math inline">\(\lfloor \frac{x}{2^k}
\rfloor\)</span>的补码表示。</p>
<p>　　下表是对-12340的16位表示进行逻辑右移后的结果
(对于不需要舍入的情况，结果是<span
class="math inline">\(\frac{x}{2^k}\)</span>。对于需要舍入的情况，算术右移会导致向下舍入)：</p>
<table>
<thead>
<tr>
<th><code>k</code></th>
<th><code>&gt;&gt; k</code> (二进制)</th>
<th>十进制</th>
<th><code>-12340 / (2 ^ k)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1100111111001100</td>
<td>-12340</td>
<td>-12340.0</td>
</tr>
<tr>
<td>1</td>
<td><strong>1</strong>110011111100110</td>
<td>-6170</td>
<td>-6170.0</td>
</tr>
<tr>
<td>4</td>
<td><strong>1111</strong>110011111100</td>
<td>-772</td>
<td>-771.25</td>
</tr>
<tr>
<td>8</td>
<td><strong>11111111</strong>11001111</td>
<td>-49</td>
<td>−48.203125</td>
</tr>
</tbody>
</table>
<p>　　为了保证整数除法向零舍入，算术右移前需要加上<span
style="background-color: yellow">偏置值</span><span
class="math inline">\(2^k-1\)</span>
(即<code>(x + (1 &lt;&lt; k) - 1) &gt;&gt; k</code>)：</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 7%" />
<col style="width: 30%" />
<col style="width: 25%" />
<col style="width: 7%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr>
<th><code>k</code></th>
<th>偏置值</th>
<th>-12340 + 偏置值 (二进制)</th>
<th><code>&gt;&gt; k</code> (二进制)</th>
<th>十进制</th>
<th><code>-12340 / (2 ^ k)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1100111111001100</td>
<td>1100111111001100</td>
<td>-12340</td>
<td>-12340.0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>110011111100110<strong>1</strong></td>
<td><strong>1</strong>110011111100110</td>
<td>-6170</td>
<td>-6170.0</td>
</tr>
<tr>
<td>4</td>
<td>15</td>
<td>110011111101<strong>1011</strong></td>
<td><strong>1111</strong>110011111101</td>
<td>-771</td>
<td>-771.25</td>
</tr>
<tr>
<td>8</td>
<td>255</td>
<td>11010000<strong>11001011</strong></td>
<td><strong>11111111</strong>11010000</td>
<td>-48</td>
<td>−48.203125</td>
</tr>
</tbody>
</table>
<p>　　第3列展示了-12340与偏置值相加的结果，粗体表示低<span
class="math inline">\(k\)</span>位，其左侧的位可能会增加，也可能不会增加。对于不需要舍入的情况，偏置值只会影响那些会移动的位。对于需要舍入的情况，偏置值会导致较高的位增加
(即结果将向零舍入)。</p>
<p>　　若<span class="math inline">\(x=qy+r\)</span>，并且<span
class="math inline">\(0\leqslant x&lt;y\)</span>，则<span
class="math inline">\(\frac{x+y-1}{y}=q+\frac{r+y-1}{y}\)</span>，所以<span
class="math inline">\(\lfloor\frac{x+y-1}{y}\rfloor=q+\lfloor\frac{r+y-1}{y}\rfloor\)</span>。当<span
class="math inline">\(r=0\)</span>时，<span
class="math inline">\(\lfloor\frac{r+y-1}{y}\rfloor\)</span>会得到0；当<span
class="math inline">\(r&gt;0\)</span>时，<span
class="math inline">\(\lfloor\frac{r+y-1}{y}\rfloor\)</span>会得到1。因此，对于整数<span
class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>
(<span class="math inline">\(y&gt;0\)</span>)，<span
class="math inline">\(\lceil\frac{x}{y}\rceil=\lfloor \frac{x+y-1}{y}
\rfloor\)</span>，偏置技术充分利用了这一点。当<span
class="math inline">\(y=2^k\)</span>时，<code>(x + (1 &lt;&lt; k) - 1) &gt;&gt; k</code>会将<span
class="math inline">\(x+2^k-1\)</span>右移<span
class="math inline">\(k\)</span>位，得到<span
class="math inline">\(\lceil\frac{x}{2^k}\rceil\)</span>。</p>
<h3 id="浮点数">2.4 浮点数</h3>
<p>　　浮点数表示用于对形如<span class="math inline">\(V=x\times
2^y\)</span>的有理数进行编码。对于涉及非常大的数 (<span
class="math inline">\(|V|&gt;&gt;0\)</span>)、非常接近于0的数 (<span
class="math inline">\(0&lt;|V|&lt;&lt;1\)</span>)
以及更普遍的作为实数运算的近似值的计算，它很实用。</p>
<h4 id="二进制小数">2.4.1 二进制小数</h4>
<p>　　小数的十进制表示为<span class="math inline">\(d_md_{m-1}\cdots
d_1d_0.d_{-1}d_{-2}\cdots
d_{-n+1}d_{-n}\)</span>。小数点左侧的数的权是10的正幂
(对应整数值)，右侧的数的权是10的负幂 (对应小数值)。 <span
class="math display">\[
d=\sum^m_{i=-n}10^i\times d_i
\]</span> 　　小数的二进制表示为<span
class="math inline">\(b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots
b_{-n+1}b_{-n}\)</span>。小数点左侧的数的权是2的正幂，右侧的数的权是2的负幂。小数点左移<span
class="math inline">\(n\)</span>位相当于除以<span
class="math inline">\(2^n\)</span>，右移<span
class="math inline">\(n\)</span>位相当于乘以<span
class="math inline">\(2^n\)</span>。 <span class="math display">\[
b=\sum^m_{i=-n}2^i\times b_i
\]</span>
　　有些小数不能确切地用二进制表示，只能近似地表示，但增加二进制表示的长度可以提高精度。</p>
<h4 id="ieee浮点表示">2.4.2 IEEE浮点表示</h4>
<p>　　IEEE浮点标准用<span class="math inline">\(V=(-1)^s\times M\times
2^E\)</span>表示数字。</p>
<p>　　● <span
class="math inline">\(s\)</span>表示<strong>符号位</strong>，<span
class="math inline">\(s=1\)</span>时表示负数，<span
class="math inline">\(s=0\)</span>时表示正数。数值0的符号位解释作为特殊情况处理。</p>
<p>　　● <span
class="math inline">\(M\)</span>表示<strong>尾数</strong>，它是二进制小数，其范围是<span
class="math inline">\(1\sim 2-\epsilon\)</span>或<span
class="math inline">\(0\sim 1-\epsilon\)</span>。</p>
<p>　　● <span
class="math inline">\(E\)</span>表示<strong>阶码</strong>，用于对浮点数加权。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/standard_floating_point_format.svg" class="">
<p>　　在C中，单精度浮点数是32位，包括1位符号位、8位阶码和23位尾数。双精度浮点数是64位，包括1位符号位、11位阶码和52位尾数。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/categories_of_single_precision_floating_point_values.svg" class="">
<p>　　对于单精度浮点数，阶码值决定其类别。这里假设阶码和尾数的位模式长度分别表示为<span
class="math inline">\(k\)</span>和<span
class="math inline">\(n\)</span>。</p>
<p>　　●
最常见的情况是<strong>规格化</strong>数，其阶码的位模式不全为0或1。在这种情况下，阶码被解释为<strong>偏置</strong>形式表示的有符号整数，即阶码值<span
class="math inline">\(E=e-Bias\)</span>，其中<span
class="math inline">\(e\)</span>是无符号数，其位模式是<span
class="math inline">\(e_{k-1}\cdots e_1e_0\)</span>，<span
class="math inline">\(Bias\)</span>是偏置值<span
class="math inline">\(2^{k-1}-1\)</span>。因此，单精度浮点数的指数的取值范围是<span
class="math inline">\(-126\sim
+127\)</span>，双精度浮点数的指数范围是<span
class="math inline">\(-1022\sim +1023\)</span>。尾数被解释为小数<span
class="math inline">\(f\)</span> (<span class="math inline">\(0\leqslant
f&lt;1\)</span>)，其二进制表示为<span
class="math inline">\(0.f_{n-1}\cdots f_1f_0\)</span>。尾数定义为<span
class="math inline">\(M=1+f\)</span>，这种方式也称为<strong>隐含前导1</strong>表示，因为<span
class="math inline">\(M\)</span>的二进制表示为<span
class="math inline">\(1.f_{n-1}\cdots
f_1f_0\)</span>，这种表示方法可以获得额外精度。由于可以调整阶码<span
class="math inline">\(E\)</span>来保证尾数<span
class="math inline">\(M\)</span>在范围<span
class="math inline">\([1,2)\)</span>内，所以无需显式地表示前导位。</p>
<p>　　●
当阶码位模式全为0时，表示<strong>非规格化</strong>数。在这种情况下，阶码值<span
class="math inline">\(E=1-Bias\)</span>，尾数值<span
class="math inline">\(M=f\)</span>。非规格数有2个用途。第1个用途是表示数值0，因为规格化数的尾数<span
class="math inline">\(M\geqslant1\)</span>，不能表示0。实际上，<span
class="math inline">\(+0.0\)</span>的位模式全为0。<span
class="math inline">\(-0.0\)</span>与之类似，但位模式的符号位为1
(对于IEEE浮点格式，<span class="math inline">\(+0.0\)</span>和<span
class="math inline">\(-0.0\)</span>在某些方面不同)。第2个用途是表示很接近0的数。这些数有1个称为<strong>渐进下溢</strong>的属性，即均匀分布在<span
class="math inline">\(0.0\)</span>附近。</p>
<p>　　●
当阶码位模式全为1时，表示特殊值。当尾数位模式全为0时，表示无穷大，符号位是0表示<span
class="math inline">\(+\infty\)</span>，符号位为1表示<span
class="math inline">\(-\infty\)</span>。当很大的数相乘或除以0时，无穷大表示<span
style="background-color: yellow">溢出</span>。当尾数位模式不全为0时，表示<strong>非数字</strong>
(NaN)，运算结果无穷大或不为实数时会返回NaN。某些应用程序会使用NaN来表示未初始化的数据。</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 19%" />
<col style="width: 17%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>阶码</th>
<th>尾数</th>
<th>数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小的正非规格化数</td>
<td><span class="math inline">\(M=f=2^{-n}\)</span></td>
<td><span class="math inline">\(E=-2^{k-1}+2\)</span></td>
<td><span class="math inline">\(V=2^{-n-2^{k-1}+2}\)</span></td>
</tr>
<tr>
<td>最大的正非规格化数</td>
<td><span class="math inline">\(M=f=1-2^{-n}\)</span></td>
<td><span class="math inline">\(E=-2^{k-1}+2\)</span></td>
<td><span class="math inline">\(V=(1-2^{-n})\cdot
2^{-2^{k-1}+2}\)</span></td>
</tr>
<tr>
<td>最小的正规格化数</td>
<td><span class="math inline">\(M=1+f=1\)</span></td>
<td><span class="math inline">\(E=-2^{k-1}+2\)</span></td>
<td><span class="math inline">\(V=2^{-2^{k-1}+2}\)</span></td>
</tr>
<tr>
<td>最大的正规格化数</td>
<td><span class="math inline">\(M=1+f=2-2^{-n}\)</span></td>
<td><span class="math inline">\(E=2^{k-1}-1\)</span></td>
<td><span class="math inline">\(V=(1-2^{-n-1})\cdot
2^{2^{k-1}}\)</span></td>
</tr>
</tbody>
</table>
<p>　　以基于IEEE浮点格式的6位浮点数表示为例，包括3位阶码和2位尾数，所以偏置值<span
class="math inline">\(Bias=2^{3-1}-1=3\)</span>。对于规格化数，阶码值的取值范围是<span
class="math inline">\(-2\sim3\)</span>，尾数值的取值范围是<span
class="math inline">\(1\sim \frac{7}{4}\)</span>，最大值是<span
class="math inline">\(\pm14\)</span>，最小值是<span
class="math inline">\(\pm\frac{1}{4}\)</span>。对于非规格化数，阶码值是<span
class="math inline">\(-2\)</span>，尾数值的取值范围是<span
class="math inline">\(0\sim \frac{3}{4}\)</span>，最大值是<span
class="math inline">\(\pm \frac{3}{16}\)</span>，最小值是<span
class="math inline">\(\pm
0\)</span>。非规格数聚集在0附近，它们并不是均匀分布，而是越靠近原点越密集。对比规格数的最小值和非规格数的最大值，可以发现两者之间的<span
style="background-color: yellow">平滑过渡</span>，因为非规格化数的阶码值<span
class="math inline">\(E\)</span>定义为<span
class="math inline">\(1-Bias\)</span>，这弥补了非规格化数的尾数没有隐含前导1。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_02/simple_example_of_converting_a_signed_number_to_a_floating_point_number.svg" class="">
<p>　　将整数转换为浮点形式对理解浮点表示很有用。以数值12345为例，其二进制表示为<span
class="math inline">\([11000000111001]\)</span>，对应的规格化表示为<span
class="math inline">\(1.1000000111001_2\cdot
2^{13}\)</span>。为了用IEEE单精度浮点表示，需要将二进制小数点左移13位，丢弃开头的1并在结尾添加10个0，然后计算尾数<span
class="math inline">\(e=E+Bias=13+127=140\)</span>并转换为二进制，最后加上符号位。</p>
<h4 id="浮点运算">2.4.3 浮点运算</h4>
<p>　　浮点运算只能近似于实数运算，因为表示的范围和精度有限。因此，对于值<span
class="math inline">\(x\)</span>，需要系统的方法来查找浮点格式能表示的最接近的值<span
class="math inline">\(x&#39;\)</span>，这是<strong>舍入</strong>的任务。</p>
<p>　　IEEE浮点格式定义了4种舍入模式。默认舍入模式是向最近值舍入，也称为向偶数舍入，即向上或向下舍入来<span
style="background-color: yellow">尽量</span>保证结果的最低有效位为偶数。当存在2个可能的舍入值时，选择最低有效位为偶数的舍入值。其他3种方式会在实际值上产生<span
style="background-color: yellow">确界</span>，分别是向上舍入、向零舍入和向下舍入。以保留整数为例，下表展示了这4种舍入模式的结果：</p>
<table>
<thead>
<tr>
<th>舍入模式</th>
<th>-1.50</th>
<th>1.40</th>
<th>1.50</th>
<th>1.60</th>
<th>2.5</th>
</tr>
</thead>
<tbody>
<tr>
<td>向偶数舍入</td>
<td>-2</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>向零舍入</td>
<td>-1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>向上舍入</td>
<td>-1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>向下舍入</td>
<td>-2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>　　向偶数舍入也能应用于二进制小数 (0是偶数)。位模式形如<span
class="math inline">\(XX\cdots X.YY\cdots Y100\cdots\)</span>的数
(最右侧的<span class="math inline">\(Y\)</span>是待舍入的位置)
才可能有2个舍入值。以保留2位小数为例，<span
class="math inline">\(10.00011_2\)</span>会舍入为<span
class="math inline">\(10.00_2\)</span>，<span
class="math inline">\(10.00110_2\)</span>会舍入为<span
class="math inline">\(10.01_2\)</span>，<span
class="math inline">\(10.11100_2\)</span>会舍入为<span
class="math inline">\(11.00_2\)</span>，<span
class="math inline">\(10.10100_2\)</span>会舍入为<span
class="math inline">\(10.10\)</span>。</p>
<p>　　计算数据的平均值时舍入的使用会引入统计偏差。无论向上舍入、向零舍入还是向下舍入，都会增大统计偏差，而向偶数舍入可以减小甚至消除统计偏差，因为大约一半的数据向上舍入，大约一半数据向下舍入。</p>
<p>　　IEEE规定了用于确定算术运算结果的规则：若将浮点数<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>视为实数，则算术运算<span
class="math inline">\(\odot\)</span>的结果应该是实际值的舍入结果<span
class="math inline">\(Round(x\odot y)\)</span>。</p>
<p>　　与整数加法类似，实数加法也会形成阿贝尔群，但需要考虑舍入。假设<span
class="math inline">\(x+^fy\)</span>表示<span
class="math inline">\(Round(x+y)\)</span>，虽然<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>都是实数，但由于溢出可能得到无穷大。该运算是可交换的，<span
class="math inline">\(x+^fy=y+^fx\)</span>。但是，该运算是不可结合的
(对于单精度浮点数，<code>(3.14 + 1e10) - 1e10</code>会得到0.0，而<code>3.14 + (1e10 - 1e10)</code>会得到3.14)。大多数在浮点加法时有逆元，<span
class="math inline">\(x+^f-x=0\)</span>，无穷大和NaN是例外，因为<span
class="math inline">\(+\infty-\infty=NaN\)</span>，<span
class="math inline">\(NaN+^fx=NaN\)</span>。</p>
<p>　　浮点加法满足单调性，即若<span class="math inline">\(a\geqslant
b\)</span>，则<span class="math inline">\(x+^fa\geqslant x+^fb\)</span>
(<span class="math inline">\(x\neq NaN\)</span>)。</p>
<p>　　由于浮点加法不具有可结合性，<code>x = a + b + c</code>可能会被编译器替换为<code>t = b + c</code>和<code>x = a + t</code>。在大多数情况下，这种差异无关紧要。编译器无法得知如何取舍效率和保留原始程序的确切行为，所以编译器通常很保守，避免任何可能对功能产生影响的优化。</p>
<p>　　浮点乘法有常规乘数的很多属性。假设<span
class="math inline">\(x\cdot^fy\)</span>表示<span
class="math inline">\(Round(x\cdot y)\)</span>，该运算会在乘法下闭合
(可能产生无穷大或NaN)。该运算是可交换的，并且有1.0作为乘法恒等式。由于溢出或舍入会导致精度丢失，所以该运算是不可结合和不可分配的。该运算满足单调性，对于不为NaN的<span
class="math inline">\(a\)</span>、<span
class="math inline">\(b\)</span>和<span class="math inline">\(c\)</span>
(<span class="math inline">\(a\geqslant b\)</span>)，若<span
class="math inline">\(c\geqslant 0\)</span>，则<span
class="math inline">\(a\cdot^fc \geqslant b \cdot^f c\)</span>；若<span
class="math inline">\(c\leqslant0\)</span>，则<span
class="math inline">\(a\cdot^f c\leqslant b\cdot^f c\)</span>。</p>
<h4 id="c相关支持-1">2.4.4 C相关支持</h4>
<p>　　C提供了数据类型<code>float</code>和<code>double</code>来支持浮点数，其舍入模式是向偶数舍入。C标准不要求计算机使用IEEE浮点格式，所以没有标准方法来更改舍入模式和获取特殊值。但是，对于大多数系统，可以通过头文件引用和过程库的结合来提供这些支持，具体实现因系统而异。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>　　这段代码会让gcc定义常数<code>INFINTY</code>和<code>NAN</code>。</p>
<p>　　当<code>int</code>转换为<code>float</code>时，可能会舍入。当<code>int</code>或<code>float</code>转换为<code>double</code>时，不会有精度损失。当<code>double</code>转换为<code>float</code>时，可能会溢出为<span
class="math inline">\(\pm\infty\)</span>或者舍入。当<code>float</code>或<code>double</code>转换为<code>int</code>时，可能会向零舍入或溢出，C标准没有为这种情况指定结果。</p>
<p>　　Intel兼容微处理器会用位模式<span
class="math inline">\([10\cdots00]\)</span>表示<strong>整数不定值</strong>。当浮点数转换为整数时，若没有合理的整数近似值，则会产生该值。因此，<code>(int)+1e10</code>会得到-21483648
(从正值变为负值)。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》附录</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_appx/</url>
    <content><![CDATA[<p>　　官方资料下载地址：<a
href="https://csapp.cs.cmu.edu/">点击这里</a>。</p>
<h3 id="a.1-错误处理">A.1 错误处理</h3>
<p>　　在之前遇到的系统级函数中，使用的错误返回风格有3种：UNIX风格、POSIX风格和GAI风格。</p>
<h4 id="a.1.1-unix风格">A.1.1 UNIX风格</h4>
<p>　　UNIX早期开发的<code>fork()</code>和<code>wait()</code>等函数
(以及一些较旧的POSIX函数)
是UNIX风格，当这些函数出错时，会在返回的同时设置<code>errno</code>。例如，对于函数<code>wait()</code>，若出错，则会返回-1并设置<code>errno</code>；若成功，则返回回收的子进程的PID。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = wait(<span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;wait error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是UNIX风格的错误处理代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief UNIX风格错误输出函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg 错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数wait()的 (错误处理) 包装函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param status 状态</span></span><br><span class="line"><span class="comment"> * @return pid_t PID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Wait</span><span class="params">(<span class="type">int</span> *status)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = wait(status)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Wait error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数kill()的 (错误处理) 包装函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param pid PID</span></span><br><span class="line"><span class="comment"> * @param signum 信号编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="keyword">if</span> ((rc = kill(pid, signum)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Kill error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是UNIX风格的错误输出函数和错误处理包装函数。</p>
<span id="more"></span>
<h4 id="a.1.2-posix风格">A.1.2 POSIX风格</h4>
<p>　　很多较新的POSIX函数是POSIX风格，其返回值仅表示成功 (0) 或出错
(非0)，有用的结果通过引用传递的参数返回。例如，函数<code>pthread_create()</code>的返回值仅表示成功或出错，新创建的线程TID通过第1个参数返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((retcode = pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(retcode));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是POSIX风格的错误处理代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief POSIX风格错误输出函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param code 错误码</span></span><br><span class="line"><span class="comment"> * @param msg 错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">posix_error</span><span class="params">(<span class="type">int</span> code, <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(code));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数pthread_detach()的 (错误处理) 包装函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param tid TID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="keyword">if</span> ((rc = pthread_detach(tid)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        posix_error(rc, <span class="string">&quot;Pthread_detach error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是POSIX风格的错误输出函数和错误处理包装函数。</p>
<h4 id="a.1.3-gai风格">A.1.3 GAI风格</h4>
<p>　　GAI是函数<code>getaddrinfo()</code>的简称，这种风格的返回值仅表示成功
(0) 或出错 (非0)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((retcode = getaddrinfo(host, service, &amp;hints, &amp;result)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo error: %s\n&quot;</span>, gai_strerror(retcode));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是GAI风格的错误处理代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief GAI风格错误输出函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param code 错误码</span></span><br><span class="line"><span class="comment"> * @param msg 错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gai_error</span><span class="params">(<span class="type">int</span> code, <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, gai_strerror(code));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数getaddrinfo()的 (错误处理) 包装函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param host 主机名</span></span><br><span class="line"><span class="comment"> * @param service 服务名</span></span><br><span class="line"><span class="comment"> * @param hints 可选项</span></span><br><span class="line"><span class="comment"> * @param res 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **res)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(host, service, hints, res)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gai_error(rc, <span class="string">&quot;Getaddrinfo error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是GAI风格的错误输出函数和错误处理包装函数。</p>
<h3 id="a.2-相关术语">A.2 相关术语</h3>
<blockquote>
<p><strong>abelian group</strong> 阿贝尔群</p>
<p><strong>action in distance</strong> 在远处起作用</p>
<p><strong>actuator arm</strong> 传动臂</p>
<p><strong>additive inverse</strong> 加法逆元</p>
<p><strong>address-space layout randomization (ASLR)</strong>
地址空间布局随机化</p>
<p><strong>address translation</strong> 地址转换</p>
<p><strong>Advanced Research Projects Agency (ARPA)</strong>
高级研究计划署</p>
<p><strong>advanced vecter extension</strong> 高级向量扩展</p>
<p><strong>aggregate payload</strong> 聚合有效载荷</p>
<p><strong>alignment</strong> 对齐</p>
<p><strong>always taken (AT)</strong> 总是选择</p>
<p><strong>American National Standards Institute (ANSI)</strong>
美国国家标准协会</p>
<p><strong>Andrew File System (AFS)</strong> 安德鲁文件系统</p>
<p><strong>archive</strong> 存档</p>
<p><strong>arithmetic logic unit (ALU)</strong> 算术逻辑单元</p>
<p><strong>assembler directive</strong> 汇编指示</p>
<p><strong>asymptotic inefficiency</strong> 渐进低效</p>
<p><strong>async-signal-safe</strong> 异步信号安全</p>
<p><strong>background</strong> 后台</p>
<p><strong>backward taken, forward non-taken (BTFNT)</strong>
反向选择、正向不选择</p>
<p><strong>basic input/output system (BIOS)</strong>
基本输入输出系统</p>
<p><strong>best fit</strong> 最佳适配</p>
<p><strong>block storage start (BSS)</strong> 块存储开始</p>
<p><strong>bias</strong> 偏置</p>
<p><strong>bijection</strong> 双射</p>
<p><strong>big endian</strong> 大端</p>
<p><strong>binary</strong> 二进制</p>
<p><strong>bit</strong> 位</p>
<p><strong>bi-endian</strong> 双端</p>
<p><strong>block device</strong> 块设备</p>
<p><strong>Boolean algebra</strong> 布尔代数</p>
<p><strong>boundary tag</strong> 边界标记</p>
<p><strong>branch prediction logic</strong> 分支预测逻辑</p>
<p><strong>bridge</strong> 网桥</p>
<p><strong>buddy system</strong> 伙伴系统</p>
<p><strong>bus</strong> 总线</p>
<p><strong>bypassing</strong> 旁路</p>
<p><strong>byte</strong> 字节</p>
<p><strong>cache memory</strong> 高速缓存</p>
<p><strong>callee-saved</strong> 被调用者保存</p>
<p><strong>caller-saved</strong> 调用者保存</p>
<p><strong>calling environment</strong> 调用环境</p>
<p><strong>carriage return (CR)</strong> 回车</p>
<p><strong>case expression</strong> 情况表达式</p>
<p><strong>cache friendly</strong> 缓存友好</p>
<p><strong>cache hit</strong> 缓存命中</p>
<p><strong>cache line</strong> 缓存行</p>
<p><strong>cache miss</strong> 缓存未命中</p>
<p><strong>cache set</strong> 缓存组</p>
<p><strong>capacity miss</strong> 容量未命中</p>
<p><strong>central processing unit (CPU)</strong> 中央处理器</p>
<p><strong>character device</strong> 字符设备</p>
<p><strong>circuit retiming</strong> 电路重定时</p>
<p><strong>client</strong> 客户端</p>
<p><strong>code motion</strong> 代码移动</p>
<p><strong>code profiler</strong> 代码剖析程序</p>
<p><strong>column access strobe (CAS)</strong> 列地址选通脉冲</p>
<p><strong>combinational circuit</strong> 组合电路</p>
<p><strong>common gateway interface (CGI)</strong> 通用网关接口</p>
<p><strong>complex instruction set computer (CISC)</strong>
复杂指令集计算机</p>
<p><strong>compulsory miss</strong> 强制未命中</p>
<p><strong>concurrency</strong> 并发</p>
<p><strong>concurrent server</strong> 并发服务器</p>
<p><strong>condition code (CC)</strong> 条件码</p>
<p><strong>conflict miss</strong> 冲突未命中</p>
<p><strong>conservative garbage collector</strong> 保守式垃圾回收器</p>
<p><strong>constant word</strong> 常数字</p>
<p><strong>context</strong> 上下文</p>
<p><strong>control dependency</strong> 控制依赖</p>
<p><strong>control hazard</strong> 控制隐患</p>
<p><strong>control transfer</strong> 控制转移</p>
<p><strong>coprocessor</strong> 协处理器</p>
<p><strong>copy-on-write</strong> 写时复制</p>
<p><strong>core dump</strong> 核心转储</p>
<p><strong>core memory</strong> 磁芯存储器</p>
<p><strong>critical section</strong> 临界区</p>
<p><strong>current working directory</strong> 当前工作目录</p>
<p><strong>cycles per element (CPE)</strong> 每元素周期数</p>
<p><strong>cycles per instruction (CPI)</strong> 每指令周期数</p>
<p><strong>cylinder</strong> 柱面</p>
<p><strong>data cache (d-cache)</strong> 数据缓存</p>
<p><strong>data dependency</strong> 数据依赖</p>
<p><strong>data forwarding</strong> 数据转发</p>
<p><strong>data hazard</strong> 数据隐患</p>
<p><strong>data section</strong> 数据节</p>
<p><strong>datagram</strong> 数据报</p>
<p><strong>deadlock</strong> 死锁</p>
<p><strong>deferred coalescing</strong> 延迟合并</p>
<p><strong>demand paging</strong> 按需页面调度</p>
<p><strong>demand-zero page</strong> 请求二进制0的页</p>
<p><strong>demangling</strong> 还原</p>
<p><strong>denormalize</strong> 非规格化</p>
<p><strong>descriptor</strong> 描述符</p>
<p><strong>descriptor set</strong> 描述符集</p>
<p><strong>direct-mapped cache</strong> 直接映射缓存</p>
<p><strong>direct memory access (DMA)</strong> 直接存储器存取</p>
<p><strong>directory</strong> 目录</p>
<p><strong>dirty bit</strong> 修改位</p>
<p><strong>disassembler</strong> 反汇编器</p>
<p><strong>domain name</strong> 域名</p>
<p><strong>domain name system (DNS)</strong> 域名系统</p>
<p><strong>dotted-decimal notation</strong> 点分十进制表示法</p>
<p><strong>double date-rate synchronous DRAM (DDR SDRAM)</strong>
双数据率同步DRAM</p>
<p><strong>double word</strong> 双字</p>
<p><strong>dual inline memory module (DIMM)</strong>
双列直插存储模块</p>
<p><strong>dynamic linking</strong> 动态链接</p>
<p><strong>dynamic link library (DLL)</strong> 动态链接库</p>
<p><strong>dynamic memory allocator</strong> 动态内存分配器</p>
<p><strong>dynamic random access memory (DRAM)</strong>
动态随机存取存储器</p>
<p><strong>effective address</strong> 有效地址</p>
<p><strong>electrically erasable PROM</strong> 电可擦写可编程ROM</p>
<p><strong>encapsulation</strong> 封装</p>
<p><strong>end of file (EOF)</strong> 文件结束</p>
<p><strong>end of line (EOL)</strong> 行尾符</p>
<p><strong>entry point</strong> 入口点</p>
<p><strong>ephemeral port</strong> 临时端口</p>
<p><strong>epilogue block</strong> 结尾块</p>
<p><strong>erasable programmable ROM (EPROM)</strong>
可擦写可编程ROM</p>
<p><strong>error-reporting function</strong> 错误报告函数</p>
<p><strong>Ethernet</strong> 以太网</p>
<p><strong>excepting instrcution</strong> 异常指令</p>
<p><strong>exception handler</strong> 异常处理函数</p>
<p><strong>exception table base register</strong> 异常表基址寄存器</p>
<p><strong>exceptional control flow (ECF)</strong> 异常控制流</p>
<p><strong>executable and linkable format (ELF)</strong>
可执行与可链接格式</p>
<p><strong>executable object file</strong> 可执行目标文件</p>
<p><strong>execution unit (EU)</strong> 执行单元</p>
<p><strong>explicit free list</strong> 显式空闲链表</p>
<p><strong>exploit code</strong> 攻击代码</p>
<p><strong>exponent</strong> 阶码</p>
<p><strong>extended data out DRAM (EDO DRAM)</strong>
扩展数据输出DRAM</p>
<p><strong>first fit</strong> 首次适配</p>
<p><strong>flash memory</strong> 闪存</p>
<p><strong>flash translation layer (FTL)</strong> 闪存转换层</p>
<p><strong>flat addressing</strong> 平坦寻址</p>
<p><strong>floating point</strong> 浮点</p>
<p><strong>floating point unit (FPU)</strong> 浮点处理单元</p>
<p><strong>footer</strong> 脚部</p>
<p><strong>foreground</strong> 前台</p>
<p><strong>garbage collection</strong> 垃圾回收</p>
<p><strong>garbage collector</strong> 垃圾回收器</p>
<p><strong>general-purpose register</strong> 通用目的寄存器</p>
<p><strong>giga-instructions per second (GIPS)</strong>
每秒千兆条指令</p>
<p><strong>gigahertz (GHz)</strong> 千兆赫兹</p>
<p><strong>global offset table (GOT)</strong> 全局偏移表</p>
<p><strong>gradual underflow</strong> 渐进下溢</p>
<p><strong>granularity</strong> 粒度</p>
<p><strong>graphics card</strong> 显卡</p>
<p><strong>guaranteed bound</strong> 确界</p>
<p><strong>hardware control language (HCL)</strong> 硬件控制语言</p>
<p><strong>hardware description language (HDL)</strong> 硬件描述语言</p>
<p><strong>heap</strong> 堆</p>
<p><strong>hexadecimal</strong> 十六进制</p>
<p><strong>host bus adapter</strong> 主机总线适配器</p>
<p><strong>hub</strong> 集线器</p>
<p><strong>hypertext transfer protocol (HTTP)</strong>
超文本传输协议</p>
<p><strong>hypertext markup language (HTML)</strong> 超文本标记语言</p>
<p><strong>hyperthreading (HT)</strong> 超线程</p>
<p><strong>false fragmentation</strong> 假碎片</p>
<p><strong>fast page mode DRAM (FPM DRM)</strong> 快页模式DRAM</p>
<p><strong>faulting instruction</strong> 故障指令</p>
<p><strong>firmware</strong> 固件</p>
<p><strong>floating exception</strong> 浮点异常</p>
<p><strong>formal verification</strong> 形式化验证</p>
<p><strong>fragmentation</strong> 碎片</p>
<p><strong>frame</strong> 帧</p>
<p><strong>front side bus (FSB)</strong> 前端总线</p>
<p><strong>fully associate cache</strong> 全相联缓存</p>
<p><strong>I/O redirection</strong> I/O重定向</p>
<p><strong>idempotent</strong> 幂等元</p>
<p><strong>immediate coalescing</strong> 立即合并</p>
<p><strong>implied leading 1</strong> 隐含前导1</p>
<p><strong>implicit free list</strong> 隐式空闲链表</p>
<p><strong>inline substitution</strong> 内联替换</p>
<p><strong>input/output (I/O)</strong> 输入/输出</p>
<p><strong>integer indefinite</strong> 整数不定值</p>
<p><strong>interrupt handler</strong> 中断处理函数</p>
<p><strong>instruction cache (i-cache)</strong> 指令缓存</p>
<p><strong>instruction code (icode)</strong> 指令代码</p>
<p><strong>instruction control unit (ICU)</strong> 指令控制单元</p>
<p><strong>instructions executed per cycle (IPC)</strong>
每周期执行指令数</p>
<p><strong>instruction function (ifun)</strong> 指令函数</p>
<p><strong>instruction squashing</strong> 指令排除</p>
<p><strong>instruction set architecture (ISA)</strong> 指令集架构</p>
<p><strong>Institute of Electrical and Electronics Engineers
(IEEE)</strong> 电气与电子工程师协会</p>
<p><strong>International Organization for Standardization (ISO)</strong>
国际标准化组织</p>
<p><strong>International Telephone and Telegraph Corporation (AT&amp;T,
ITT)</strong> 美国国际电话电报公司</p>
<p><strong>internet protocol (IP)</strong> 网际协议</p>
<p><strong>interpretation</strong> 解释</p>
<p><strong>interprocess communication (IPC)</strong> 进程间通信</p>
<p><strong>inverse function</strong> 反函数</p>
<p><strong>issue time</strong> 发出时间</p>
<p><strong>iterative server</strong> 迭代服务器</p>
<p><strong>Java native interface (JNI)</strong> Java本地接口</p>
<p><strong>job</strong> 作业</p>
<p><strong>just-in-time</strong> 即时</p>
<p><strong>kernel</strong> 内核；核心</p>
<p><strong>last-in first-out (LIFO)</strong> 后进先出</p>
<p><strong>latency bound</strong> 延迟界限</p>
<p><strong>lazy binding</strong> 延迟绑定</p>
<p><strong>least frequently used (LFU)</strong> 最不常用使用</p>
<p><strong>least recently used (LRU)</strong> 最近最少使用</p>
<p><strong>library interpositioning</strong> 库打桩</p>
<p><strong>line feed (LF)</strong> 换行</p>
<p><strong>little endian</strong> 小端</p>
<p><strong>load effective address</strong> 加载有效地址</p>
<p><strong>load interlock</strong> 加载互锁</p>
<p><strong>load/use hazard</strong> 加载/使用隐患</p>
<p><strong>load penalty</strong> 加载处罚</p>
<p><strong>local area network (LAN)</strong> 局域网</p>
<p><strong>locality</strong> 局部性</p>
<p><strong>logic gate</strong> 逻辑门</p>
<p><strong>logic synthsis</strong> 逻辑合成</p>
<p><strong>logical control flow</strong> 逻辑控制流</p>
<p><strong>loop unrolling</strong> 循环展开</p>
<p><strong>loopback address</strong> 环回地址</p>
<p><strong>macro</strong> 宏</p>
<p><strong>main memory</strong> 主存；内存</p>
<p><strong>mangling</strong> 倾轧</p>
<p><strong>mark&amp;sweep</strong> 标记-清除</p>
<p><strong>mask</strong> 掩码</p>
<p><strong>memory aliasing</strong> 内存混叠</p>
<p><strong>memory controller</strong> 存储控制器</p>
<p><strong>memory hierarchy</strong> 存储器层次结构</p>
<p><strong>memory-mapped I/O</strong> 内存映射I/O</p>
<p><strong>memory mapping</strong> 内存映射</p>
<p><strong>memory management unit (MMU)</strong> 存储管理单元</p>
<p><strong>memory mountain</strong> 存储器山</p>
<p><strong>metadata</strong> 元数据</p>
<p><strong>mispredicted branch penalty</strong> 预测错误分支处罚</p>
<p><strong>mode bit</strong> 模式位</p>
<p><strong>multicore</strong> 多核</p>
<p><strong>multiple zone recording</strong> 多区记录</p>
<p><strong>multiplexor (MUX)</strong> 多路复用器</p>
<p><strong>multiprocessor</strong> 多处理器</p>
<p><strong>multipurpose internet mail extensions (MIME)</strong>
多用途互联网邮件扩展</p>
<p><strong>multiway branching</strong> 多重分支</p>
<p><strong>mutex</strong> 互斥锁</p>
<p><strong>mutual exclusion</strong> 互斥</p>
<p><strong>named pipe</strong> 命名管道</p>
<p><strong>National Science Foundation (NSF)</strong> 国家科学基金会</p>
<p><strong>negative weight</strong> 负权</p>
<p><strong>network file system</strong> 网络文件系统</p>
<p><strong>never taken (NT)</strong> 从不选择</p>
<p><strong>newline character</strong> 换行符</p>
<p><strong>next fit</strong> 下次适配</p>
<p><strong>no-write-allocate</strong> 非写分配</p>
<p><strong>no operation (nop)</strong> 空操作</p>
<p><strong>noexecute (NE)</strong> 不执行</p>
<p><strong>nonlocal jump</strong> 非本地跳转</p>
<p><strong>nonvolatile memory (NVM)</strong> 非易失性存储器</p>
<p><strong>nop sled</strong> 空操作雪橇</p>
<p><strong>normal size</strong> 标称大小</p>
<p><strong>not a number (NaN)</strong> 非数字</p>
<p><strong>object file format</strong> 目标文件格式</p>
<p><strong>object module</strong> 目标模块</p>
<p><strong>oct word</strong> 八字</p>
<p><strong>off-by-one</strong> 相差1</p>
<p><strong>ones' complement</strong> 反码</p>
<p><strong>operand</strong> 操作数</p>
<p><strong>optimization blocker</strong> 优化阻碍</p>
<p><strong>origin server</strong> 原始服务器</p>
<p><strong>overflow</strong> 溢出</p>
<p><strong>packet</strong> 分组</p>
<p><strong>page fault</strong> 缺页</p>
<p><strong>page frame</strong> 页帧</p>
<p><strong>page in</strong> 页面调入</p>
<p><strong>page out</strong> 页面调出</p>
<p><strong>page table</strong> 页表</p>
<p><strong>page table base register (PTBR)</strong> 页表基址寄存器</p>
<p><strong>page table entry</strong> 页表条目</p>
<p><strong>parallelism</strong> 并行</p>
<p><strong>parity flag (PF)</strong> 奇偶标志</p>
<p><strong>pathname</strong> 路径名</p>
<p><strong>PC-relative</strong> PC相对</p>
<p><strong>peak utilization</strong> 峰值利用率</p>
<p><strong>pending signal</strong> 待处理信号</p>
<p><strong>peripheral component interconnect (PCI)</strong>
外围组件互联</p>
<p><strong>physical address (PA)</strong> 物理地址</p>
<p><strong>physical page (PP)</strong> 物理页</p>
<p><strong>picosecond (ps)</strong> 微微秒；皮秒</p>
<p><strong>placement policy</strong> 放置策略</p>
<p><strong>platter</strong> 盘片</p>
<p><strong>pointer dereferencing</strong> 指针间接引用</p>
<p><strong>position-independint code (PIC)</strong> 位置无关代码</p>
<p><strong>prefetch</strong> 预取</p>
<p><strong>prethread</strong> 预线程</p>
<p><strong>printed circuit board (PCB)</strong> 印制电路板</p>
<p><strong>preempt</strong> 抢占</p>
<p><strong>prefix sum</strong> 前缀和</p>
<p><strong>private address space</strong> 私有地址空间</p>
<p><strong>privileged instruction</strong> 特权指令</p>
<p><strong>procedure linkage table (PLT)</strong> 过程链接表</p>
<p><strong>process graph</strong> 进度图</p>
<p><strong>process group</strong> 进程组</p>
<p><strong>processor package</strong> 处理器封装</p>
<p><strong>program counter (PC)</strong> 程序计数器</p>
<p><strong>programmable ROM (PROM)</strong> 可编程ROM</p>
<p><strong>programmer visible state</strong> 程序员可见状态</p>
<p><strong>prologue block</strong> 序言块</p>
<p><strong>proxy cache</strong> 代理缓存</p>
<p><strong>proxy chain</strong> 代理链</p>
<p><strong>portable executable (PE)</strong> 可移植可执行</p>
<p><strong>quad word</strong> 四字</p>
<p><strong>random access memory (RAM)</strong> 随机 (存取) 存储器</p>
<p><strong>reachability graph</strong> 可达图</p>
<p><strong>read-only memory (ROM)</strong> 只读存储器</p>
<p><strong>read/write head</strong> 读/写磁头</p>
<p><strong>reassociation transformation</strong> 重新结合变换</p>
<p><strong>reentrancy</strong> 可重入性</p>
<p><strong>recursion</strong> 递归</p>
<p><strong>reduced instruction set computer (RISC)</strong>
精简指令集计算机</p>
<p><strong>register specifier byte</strong> 寄存器指示符字节</p>
<p><strong>relocateable object file</strong> 可重定位目标文件</p>
<p><strong>relocation entry</strong> 重定位条目</p>
<p><strong>request for comment (RFC)</strong> 请求评论</p>
<p><strong>reset configuration</strong> 复位配置</p>
<p><strong>resident set</strong> 常驻集合</p>
<p><strong>retirement unit</strong> 退役单元</p>
<p><strong>return penalty</strong> 返回处罚</p>
<p><strong>reverse engineering</strong> 逆向工程</p>
<p><strong>revolution per minute (RPM)</strong> 转每分钟</p>
<p><strong>router</strong> <strong>路由器</strong></p>
<p><strong>row access strobe (RAS)</strong> 行地址选通脉冲</p>
<p><strong>security monoculture</strong> 安全单一化</p>
<p><strong>section header table</strong> 节首部表</p>
<p><strong>sector</strong> 扇区</p>
<p><strong>seek</strong> 寻道</p>
<p><strong>segmentation fault</strong> 段故障</p>
<p><strong>segmented addressing</strong> 段寻址</p>
<p><strong>segregated fit</strong> 分离适配</p>
<p><strong>semaphore</strong> 信号量</p>
<p><strong>separate compliation</strong> 分离编译</p>
<p><strong>sequential circuit</strong> 时序电路</p>
<p><strong>serial advanced technology attachment (SATA)</strong>
串行高级技术附件</p>
<p><strong>server</strong> 服务器</p>
<p><strong>set associative cashe</strong> 组相联缓存</p>
<p><strong>shared library</strong> 共享库</p>
<p><strong>shared object</strong> 共享目标</p>
<p><strong>short count</strong> 计数不足</p>
<p><strong>side effect</strong> 副作用</p>
<p><strong>sign magnitude</strong> 原码</p>
<p><strong>signal</strong> 信号</p>
<p><strong>signal mask</strong> 信号掩码</p>
<p><strong>significand</strong> 尾数</p>
<p><strong>slow system call</strong> 慢速系统调用</p>
<p><strong>small code model</strong> 小型代码模型</p>
<p><strong>small computer system interface (SCSI)</strong>
小型计算机系统接口</p>
<p><strong>simple segregated storage</strong> 简单分离存储</p>
<p><strong>simultaneous multithreading</strong> 同时多线程</p>
<p><strong>single instruction multiple data (SIMD)</strong>
单指令多数据</p>
<p><strong>socket</strong> 套接字</p>
<p><strong>socket pair</strong> 套接字对</p>
<p><strong>solid state disk (SSD)</strong> 固态硬盘</p>
<p><strong>speculative execution</strong> 试探执行</p>
<p><strong>speedup</strong> 加速比</p>
<p><strong>spill</strong> 溢出</p>
<p><strong>stack</strong> 栈</p>
<p><strong>standard library</strong> 标准库</p>
<p><strong>state machine</strong> 状态机</p>
<p><strong>static library</strong> 静态库</p>
<p><strong>static linker</strong> 静态链接器</p>
<p><strong>static random access memory (SRAM)</strong>
静态随机存取存储器</p>
<p><strong>streaming SIMD extension (SSE)</strong> 流式SMID扩展</p>
<p><strong>stride-1 reference pattern</strong> 步长为1的引用模式</p>
<p><strong>strong scaling</strong> 强缩放</p>
<p><strong>superscalar</strong> 超标量</p>
<p><strong>supervisors mode</strong> 超级用户模式</p>
<p><strong>swap area</strong> 交换区域</p>
<p><strong>swap file</strong> 交换文件</p>
<p><strong>swap space</strong> 交换空间</p>
<p><strong>symbol resolution</strong> 符号解析</p>
<p><strong>symbolic link</strong> 字符链接</p>
<p><strong>symbolic method</strong> 符号方法</p>
<p><strong>synchronous DRAM (SDRAM)</strong> 同步DRAM</p>
<p><strong>system call</strong> 系统调用</p>
<p><strong>tag bit</strong> 标识位</p>
<p><strong>The Internet Corporation for Assigned Names and Numbers
(ICANN)</strong> 互联网名称与数据地址分配机构</p>
<p><strong>The Internet Engineering Task Force (IETF)</strong>
互联网工程任务组</p>
<p><strong>thrash</strong> 抖动</p>
<p><strong>thread</strong> 线程</p>
<p><strong>thread ID (TID)</strong> 线程ID</p>
<p><strong>thread routine</strong> 线程例程</p>
<p><strong>throughput bound</strong> 吞吐量界限</p>
<p><strong>time slicing</strong> 时间分片</p>
<p><strong>topological sort</strong> 拓扑排序</p>
<p><strong>track</strong> 磁道</p>
<p><strong>transaction</strong> 事务</p>
<p><strong>transfer time</strong> 传输时间</p>
<p><strong>transition</strong> 过渡</p>
<p><strong>translation lookaside buffer (TLB)</strong>
转换后备缓冲区；页表缓存</p>
<p><strong>transmission control protocol (TCP)</strong> 传输控制协议</p>
<p><strong>truncation</strong> 截断</p>
<p><strong>two's complement</strong> 补码</p>
<p><strong>unified cache</strong> 统一缓存</p>
<p><strong>uniform resource identifier (URI)</strong> 统一资源标识符</p>
<p><strong>uniprocessor</strong> 单处理器</p>
<p><strong>universal resource locator (URL)</strong> 统一资源定位符</p>
<p><strong>universal serial bus (USB)</strong> 通用串行总线</p>
<p><strong>unsigned</strong> 无符号</p>
<p><strong>user datagram protocol (UDP)</strong> 用户数据报协议</p>
<p><strong>valid bit</strong> 有效位</p>
<p><strong>video RAM (VRAM)</strong> 显存</p>
<p><strong>virtual page (VP)</strong> 虚拟页</p>
<p><strong>virtual page offset (VPO)</strong> 虚拟页偏移</p>
<p><strong>wait set</strong> 等待集合</p>
<p><strong>weak scaling</strong> 弱缩放</p>
<p><strong>wear-leveling</strong> 磨损均衡</p>
<p><strong>wide area network (WAN)</strong> 广域网</p>
<p><strong>word size</strong> 字长</p>
<p><strong>working set</strong> 工作集</p>
<p><strong>world wide web</strong> 万维网</p>
<p><strong>wrapper function</strong> 包装函数</p>
<p><strong>write-allocate</strong> 写分配</p>
<p><strong>write-through cache</strong> 透写缓存</p>
<p><strong>write-back cache</strong> 回写缓存</p>
</blockquote>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第1章 计算机系统概览</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_01/</url>
    <content><![CDATA[<p>　　<strong>计算机系统</strong>由硬件和系统软件组成，它们协同工作来运行应用程序。大部分现代计算机系统都使用ASCII标准来表示文本字符。</p>
<p>　　20世纪60年代的操作系统都是庞大且复杂的，例如，IBM的OS/360和Honeywell的Multics系统。贝尔实验室曾是Multics项目的最初参与者，由于该项目的复杂性和缺乏进展于1969年退出。同年，贝尔实验室的研究员Ken
Thompson、Dennis Ritchie、Doug McIlroy和Joe
Ossanna开始用机器语言编写UNIX系统，并在1973年用C重写其内核。在1974年，UNIX对外发布。</p>
<p>　　在20世纪80年代，UNIX供应商通过添加通常不兼容的新功能来区分产品。IEEE为了对抗这种趋势，制定了一系列标准，Richard
Stallman称其为POSIX。后来，1个名为 "标准UNIX规范"
的标准化项目与POSIX联手为UNIX制定了统一标准。</p>
<p>　　C是贝尔实验室的Dennis
Ritchie于1969年~1973年间开发的。ANSI在1989年发布了ANSI
C标准，C的标准化后来由ISO负责。1990年发布了几乎和ANSI
C一样的标准，称为ISO C90。1999年发布了ISO C99。2011年发布了ISO
C11。这些标准定义了C和1组称为C标准库的库函数。</p>
<p>　　GNU (GNU's Not UNIX) 项目是Richard
Stallman于1984年成立的免税慈善机构，其目标是开发1个完整的类UNIX系统，其源代码不受修改和分发方式的限制。GNU项目开发了1个除内核之外的包含UNIX操作系统所有主要部件的环境，内核由Linux项目独立发展而来。</p>
<p>　　1991年8月，芬兰研究生Linus
Torvalds发布了Linux内核，Linux内核最初参考了Andrew S.
Tanenbaum开发的类UNIX的操作系统内核Minix。</p>
<p>　　gcc (GNU Compiler Collection)
是GNU项目开发的工具之一，可以基于不同命令选项，根据不同版本的C规则来编译程序，例如，<code>gcc -std=c11 proc.c</code>。</p>
<table>
<thead>
<tr>
<th>C版本</th>
<th>gcc命令行</th>
</tr>
</thead>
<tbody>
<tr>
<td>GNU 89</td>
<td><code>-std=gnu89</code></td>
</tr>
<tr>
<td>ANSI</td>
<td><code>-ansi</code></td>
</tr>
<tr>
<td>ISO C90</td>
<td><code>-std=c89</code></td>
</tr>
<tr>
<td>ISO C99</td>
<td><code>-std=c99</code></td>
</tr>
<tr>
<td>ISO C11</td>
<td><code>-std=c11</code></td>
</tr>
</tbody>
</table>
<p>　　shell是命令解释器，它会先输出提示符，然后等待命令输入并执行。若命令的第1个单词不是内置命令，则会默认该命令是可执行文件的名称，然后加载并执行。</p>
<p>　　早期的计算机先驱Gene
Amdahl提出了Amdahl定律：当提升计算机系统部分组件性能时，对系统整体性能的影响取决于这部分组件的重要性和提升程度。若系统执行某应用程序的时间是<span
class="math inline">\(T_{old}\)</span>，某个组件的占比是<span
class="math inline">\(\alpha\)</span>。当该组件性能提升为原来的<span
class="math inline">\(k\)</span>倍后，该组件的执行时间从<span
class="math inline">\(\alpha T_{old}\)</span>变为<span
class="math inline">\(\frac{\alpha
T_{old}}{k}\)</span>，系统执行该程序的时间变为<span
class="math inline">\(T_{new}\)</span>，提升比为<span
class="math inline">\(S\)</span>。<span
class="math inline">\(S\)</span>通常用 "数字X"
的形式来表示，例如，2.2X表示速度提升为原来的2.2倍。 <span
class="math display">\[
\begin{align}
S&amp;=\frac{T_{old}}{T_{new}}\\[3px]
&amp;=\frac{T_{old}}{(1-\alpha)T_{old}+\frac{\alpha T_{old}}{k}}\\[3px]
&amp;=\frac{1}{1-\alpha+\frac{a}{k}}
\end{align}
\]</span>
　　因此，若想要提升系统整体性能，就必须提升系统中大部分组件的性能。</p>
<span id="more"></span>
<h3 id="计算机系统的硬件">1.1 计算机系统的硬件</h3>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/hardware_organization_of_a_typical_system.svg" class="">
<p>　　<strong>总线</strong>贯穿整个系统，用于在组件之间传输数据。总线传输数据的单位通常是称为<strong>字</strong>的固定大小的字节块。字的字节数
(简称<strong>字长</strong>)
是基本系统参数之一，因系统而异。例如，很多机器的字长是4字节 (32位)
或8字节 (64位)。</p>
<p>　　I/O设备是系统与外部的连接通道。每个I/O设备都通过<strong>控制器</strong>或<strong>适配器</strong>与I/O总线连接，两者的区别在于封装方式。控制器是I/O设备本身或<strong>主印制电路板</strong>
(简称<strong>主板</strong>)
的芯片组，而适配器是插在主板插槽上的卡，两者的功能都是在I/O总线与I/O设备之间传输信息。</p>
<p>　　网络为计算机之间的通信提供了途径。从计算机角度，网络可以看作I/O设备。</p>
<p>　　<strong>中央处理器</strong> (CPU) 是解释 (或执行)
存储在内存中的指令的引擎。CPU的核心是单字大小的存储设备
(或寄存器)，称为<strong>程序计数器</strong>
(PC)，它总是指向内存中的某个机器语言指令 (包含其地址)。</p>
<p>　　<strong>主存储器</strong>
(简称<strong>主存</strong>或<strong>内存</strong>)
是在CPU执行程序时存储程序及其操作的数据的临时存储设备。从物理角度，内存由1组<strong>动态随机存取存储器</strong>
(DRAM) 组成。从逻辑角度，内存是线性的字节数组，每个字节都有唯一的地址
(从0开始的数组索引)。组成程序的机器指令的字节数可能不同。此外，与C程序变量对应的数据项的大小因数据类型而异。</p>
<p>　　CPU看似按照<strong>指令集架构</strong> (ISA)
定义的指令执行模型进行操作
(指令会按照严格的顺序执行，并且执行1条指令会涉及多个步骤)。CPU从PC指向的内存位置读取指令并解释指令中的位，然后执行指令对应的一些简单操作，最后更新PC以指向下一条指令
(这两条指令在内存中并不一定相邻)。这种围绕着内存、寄存器文件和算术逻辑单元进行简单操作并不多。<strong>寄存器文件</strong>是由若干个单字大小且有名称的寄存器组成的小型存储设备。
<strong>算术逻辑单元</strong> (ALU)
计算数据和地址的值。CPU可能应指令请求执行的简单操作示例如下：</p>
<p>　　● <span
style="background-color: yellow">加载</span>：CPU将1个字节或字从内存复制到寄存器。</p>
<p>　　● <span
style="background-color: yellow">存储</span>：CPU将1个字节或字从寄存器复制到内存。</p>
<p>　　● <span
style="background-color: yellow">操作</span>：CPU将2个寄存器的值复制到ALU并进行算术运算，然后将结果存储到某个寄存器。</p>
<p>　　● <span
style="background-color: yellow">跳转</span>：CPU从指令中提取1个字并将该字复制到PC。</p>
<h3 id="信息就是位上下文">1.2 信息就是位+上下文</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hello.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　程序<code>hello.c</code>的生命周期以<strong>源程序
</strong>(或<strong>源文件</strong>)
的形式开始。源程序是1个位序列，8个位组成1个字节，每个字节代表程序中的某个文本字符。</p>
<p>　　程序<code>hello.c</code>以字节序列的形式存储在文件中，每个文本行都以不可见的<span
style="background-color: yellow">换行符</span><code>\n</code>结尾，每个字节的值都对应1个字符
(包括换行符<code>\n</code>)。仅由ASCII字符组成的文件称为<strong>文本文件</strong>，所有其他文件都称为<strong>二进制文件</strong>。</p>
<p>　　系统中的所有信息
(包括磁盘文件、位于内存的程序和用户数据以及通过网络传输的数据)
都表示为一系列位。区分不同数据对象的唯一方法是它们的<strong>上下文</strong>。因此，同一字节序列在不同上下文中可能表示不同的含义。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/compilation_system.svg" class="">
<p>　　● 在<span
style="background-color: yellow">预处理</span>阶段，预处理器会根据<code>#</code>开头的代码修改原始C程序。例如，<code>hello.c</code>中的<code>#include &lt;stdio.h&gt;</code>会告诉预处理器读取头文件<code>stdio.h</code>并将其直接插入到程序的文本中，这样会得到另一个C程序
(通常是以<code>.i</code>作为文件扩展名)。</p>
<p>　　● 在<span
style="background-color: yellow">编译</span>阶段，编译器会将文本文件<code>hello.i</code>转换成文本文件<code>hello.s</code>，其中包含以下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">	subq	$8, %rsp</span><br><span class="line">	movl	$.LCO, %edi</span><br><span class="line">	call	puts</span><br><span class="line">	movl	$0, $eax</span><br><span class="line">	addq	$8,%rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　● 在<span
style="background-color: yellow">汇编</span>阶段，汇编器会将<code>hello.s</code>转换成机器指令，然后打包为<strong>可重定位目标文件</strong><code>hello.o</code>。该文件是17字节的二进制文件。</p>
<p>　　● 在<span
style="background-color: yellow">链接</span>阶段，链接器会合并<code>hello.o</code>及其调用的函数来得到<strong>可执行目标文件</strong>
(简称<strong>可执行文件</strong>)
<code>hello</code>，该文件可以加载到内存中并执行。因为主函数
(即<code>main()</code>) 调用了函数<code>printf()</code>
(位于单独的预编译目标文件<code>printf.o</code>中)，所以链接器会合并<code>hello.o</code>和<code>printf.o</code>来得到可执行文件<code>hello</code>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/read_the_command_from_the_keyboard.svg" class="">
<p>　　在shell输入<code>./hello</code>后，shell会将可执行文件<code>hello</code>中的每个字符都读取到寄存器并存储到内存。当输入回车键后，shell会执行一系列指令来加载该文件，这些指令会将<code>hello</code>中的代码和数据从磁盘复制到内存。这些数据包括最终会被输出的<code>hello, world\n</code>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/load_the_executable_from_disk_into_main_memory.svg" class="">
<p>　　若使用<strong>直接存储器存取</strong>
(DMA)，则数据可以直接到达内存 (不通过CPU)。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/write_the_output_string_from_memory_to_the_display.svg" class="">
<p>　　当可执行文件<code>hello</code>的代码和数据加载到内存后，CPU会开始执行主函数中的机器指令。这些指令会将字符串<code>hello, world\n</code>的字节从内存中复制到寄存器文件，再从寄存器文件中复制到显示器。</p>
<h3 id="高速缓存">1.3 高速缓存</h3>
<p>　　由于物理因素，容量较大的存储设备通常比容量较小的存储设备更慢，速度较慢的设备通常比速度较快的设备更便宜。典型的寄存器文件的容量是数百字节，而内存的容量可达到数亿字节。但是，寄存器文件的存取速度几乎是内存的存取速度的100倍。随着半导体技术的发展，这种差距会不断增大。加快寄存器文件的存取速度比加快内存的存取速度更容易和更便宜。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/cache_memory.svg" class="">
<p>　　为了减小寄存器文件的存取速度和内存的存取速度之间的差距，系统设计者使用了<strong>高速缓存</strong>
(简称<strong>缓存</strong>)
来存储短期内CPU可能会需要的数据，即CPU中的L1、L2和L3缓存，它们通过<strong>静态随机存取存储器</strong>
(SRAM)
实现。L1缓存的存取速度比L2缓存的快，L2缓存的存取速度比L3缓存的快。L1缓存的容量比L2缓存的小，L2缓存的容量比L3缓存的小。</p>
<p>　　缓存的主要思想是系统可以通过缓存的<span
style="background-color: yellow">局部性</span>
(程序存取局部区域中的数据和代码的趋势)
来获取较大的内存容量和较快的存取速度。通过在缓存中存储可能经常访问的数据，可以通过缓存执行大部分内存操作。</p>
<h3 id="存储器层次结构">1.4 存储器层次结构</h3>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/example_of_a_memory_hierarchy.svg" class="">
<p>　　在<strong>存储器层次结构</strong>中，从顶部到底部，容量越来越大，速度越来越慢，存储1个字节的成本也越来越低。寄存器文件在顶部，即L0或0级。L1~L3缓存在L1~L3，内存在L4，本地2级存储在L5，远程2级存储在L6。</p>
<p>　　存储器层次结构的主要思想是<span
style="background-color: yellow">上一级存储器作为下一级存储器的缓存</span>
(寄存器文件是L1缓存的缓存，L1缓存是L2缓存的缓存，依此类推)。</p>
<h3 id="操作系统">1.5 操作系统</h3>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/layered_view_of_a_computer_system.svg" class="">
<p>　　操作系统的基本功能包括<span
style="background-color: yellow">防止硬件被失控的应用程序滥用</span>和<span
style="background-color: yellow">为应用程序提供简单且统一的机制来控制复杂且通常大相径庭的底层硬件</span>，这些功能通常通过基本抽象概念
(<strong>进程</strong>、<strong>虚拟内存</strong>和<strong>文件</strong>)
来实现。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/abstraction_provided_by_a_computer_system.svg" class="">
<p>　　<span
style="background-color: yellow">文件</span>是对I/O设备的抽象，<span
style="background-color: yellow">虚拟内存</span>是对内存和磁盘I/O设备的抽象，<span
style="background-color: yellow">指令集架构</span>是对CPU的抽象，<span
style="background-color: yellow">进程</span>是对CPU、内存和I/O设备的抽象，<span
style="background-color: yellow">虚拟机</span>是对整个计算机系统的抽象。</p>
<p>　　文件是字节序列。每个I/O设备 (磁盘、键盘、显示器、网络等)
都可以视为文件。系统中的所有输入和输出都是通过读写文件来实现 (调用UNIX
I/O系统调用)。文件为应用程序提供了系统中可能包含的所有I/O设备的统一视图。</p>
<h4 id="进程">1.5.1 进程</h4>
<p>　　进程是操作系统对正在运行的程序的抽象。多个进程可以在同一系统上<strong>并发</strong>运行，并且每个进程<span
style="background-color: yellow">似乎</span>都独占地使用硬件。并发运行是某个进程的指令和其他进程的指令交错，操作系统使用<strong>上下文切换</strong>来执行这种交错。</p>
<p>　　操作系统会追踪进程运行所需的所有状态信息，这些状态称为<strong>上下文</strong>，包括PC的当前值、寄存器文件和内存的内容等信息。单核CPU在同一时间只能执行1个进程的代码。当操作系统决定将控制权从进程A转移到进程B时，就会执行上下文切换，即存储进程A的上下文，恢复进程B的上下文并将控制器传递给进程B。进程B会从上次停止的地方开始。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/process_context_switching.svg" class="">
<p>　　进程切换由操作系统的<strong>内核</strong>执行。内核是系统用于管理所有进程的代码和数据结构的集合。若应用程序需要操作系统执行某些操作
(例如，读写文件)，则会执行特殊的<strong>系统调用</strong>指令来将控制权转移给内核，然后内核执行所请求的操作并返回到应用程序。</p>
<p>　　进程实际上可以由多个称为<strong>线程</strong>的执行单元组成。属于同一进程的所有线程都在进程的上下文中运行，并且共享相同的代码和全局数据。</p>
<h4 id="虚拟内存">1.5.2 虚拟内存</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/process_virtual_address_space.svg" class="">
<p>　　虚拟内存是为每个进程提供的独占内存的假象的抽象概念。每个进程都有相同的内存视图，称为<strong>虚拟地址空间</strong>。对于Linux，地址自底向上递增，顶部存储操作系统中所有进程共享的代码和数据，底部存储用户进程定义的代码和数据。</p>
<p>　　● 最底部是<span
style="background-color: yellow">程序代码和数据</span>。所有进程的代码都从相同的固定地址开始，然后是对应C全局变量的数据位置。代码和数据区域会直接根据可执行文件
(这里是<code>hello</code>) 的内容初始化。</p>
<p>　　● 代码和数据区域之上是<span
style="background-color: yellow">堆</span>。所有程序的堆的初始大小都是固定的，随后可以通过<code>malloc()</code>和<code>free()</code>等C标准库函数来在运行时动态地扩展和收缩堆。</p>
<p>　　● 在堆之上是<span
style="background-color: yellow">共享库</span>，用于存储共享库的代码和数据。</p>
<p>　　● 共享库之上是编译器用来实现函数调用的<span
style="background-color: yellow">栈</span>，栈在程序运行期间可以动态地扩展和收缩，每次调用函数时栈会扩展，每次函数返回时栈会收缩。</p>
<p>　　● 最顶部是为内核保留的<span
style="background-color: yellow">内核虚拟内存</span>。应用程序不能读写该区域或直接调用内核代码中定义的函数。相反，应用程序必须请求内核来执行这些操作。</p>
<h4 id="并发和并行">1.5.3 并发和并行</h4>
<p>　　<strong>并发</strong>表示系统同时具有多个活动，而<strong>并行</strong>表示用并发来使系统运行得更快。</p>
<p>　　对于单核CPU系统，即使CPU在多个任务之间切换，大多数实际的计算都是由单个CPU核心完成。对于多核CPU系统，操作系统内核控制着多个CPU核心。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_01/multicore_cpu_organization.svg" class="">
<p>　　多核CPU是将多个核心被集成到单个集成电路芯片。这里以4核为例，每个核都有自己的L1缓存和L2缓存，L1缓存分为2部分，分别用于存储数据和最近使用的指令。这些核共享更底层的缓存和内存的接口。</p>
<p>　　超线程 (也称为同时多线程)
CPU允许单个核心执行多个控制流。它涉及CPU部分硬件 (例如，PC和寄存器文件)
的多个副本，而其他部分硬件 (例如，ALU)
的单个副本。传统CPU需要大约20000个时钟周期才能在不同线程之间切换，而超线程CPU可以在逐个周期地决定执行哪个线程。超线程CPU也属于多核CPU。</p>
<p>　　使用多核CPU会从2个方面提高系统性能。首先，它降低了执行多个任务时模拟并发的要求。其次，它可以更快地运行以多线程方式工作的应用程序。</p>
<p>　　在较底层的抽象上，现代CPU可以同时执行多条指令，称为<strong>指令级并行</strong>。</p>
<p>　　可以维持执行速度高于每周期1条指令的CPU称为<span
style="background-color: yellow">超标量</span>CPU。</p>
<p>　　<strong>单指令多数据</strong> (SIMD)
指单个指令并行执行多个操作。SIMD指令主要用于加速处理图像、音频和视频数据应用程序。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第3章 程序的机器级表示</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_03/</url>
    <content><![CDATA[<p>　　计算机执行<strong>机器代码</strong>
(即字节序列编码的底层操作)，包括操作数据、管理内存、读写存储设备和网络通信。编译器根据编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列阶段生成机器代码。gcc以<strong>汇编代码</strong>的形式生成输出，汇编代码是机器代码的文本表示，给出了程序的所有指令。然后，gcc调用<strong>汇编器</strong>和<strong>链接器</strong>根据汇编代码生成可执行的机器代码。</p>
<p>　　8086 (1978年，29K个晶体管)
是第1代16位处理器之一。8088是8086的变体，在其基础上添加了1个8位外部总线，作为最初的IBM个人计算机的核心。1980年，Intel推出了8087浮点协处理器
(45K个晶体管)，它与8086或8088一同运行，执行浮点指令。8087建立了x86系列的浮点模型，称为x87。</p>
<p>　　80286 (1982年，134K个集体管) 添加了更多的寻址模式
(现已过时)，它是IBM
PC-AT个人计算机的基础，这种计算机是Windows最初的使用平台。</p>
<p>　　i386 (1985年，275K个晶体管)
将体系架构扩展到32位并添加了平坦寻址模式，这是第1个全面支持UNIX的Intel处理器。</p>
<p>　　i486 (1989年，1.2M个晶体管)
在提高性能的同时将浮点处理单元集成到了处理器芯片，但指令集没有明显的变化。</p>
<p>　　Pentium (1993年，3.1M个晶体管)
提高了性能，仅对指令集进行了小幅扩展。</p>
<p>　　PentiumPro (1995年，5.5M个晶体管) 采用了全新的处理器设计
(内部称为P6微体系架构)，指令集添加了条件移动指令。</p>
<p>　　Pentium/MMX (1997年，4.5M个晶体管)
添加了处理整数向量的指令。每个数据可以是8、16或32位。每个向量是64位。</p>
<p>　　Pentium II (1997年，7M个晶体管) 是P6微体系架构的延续。</p>
<p>　　Pentium III (1999年，8.2M个晶体管)
添加了SSE，此类指令用于处理整数或浮点数向量。每个数据可以是8、16或32位，打包成128位的向量。由于芯片里有L2缓存，该芯片后续的版本最多使用了24M个晶体管。</p>
<p>　　Pentium 4 (2000年，42M个晶体管)
将SSE扩展到了SSE2，添加了新的数据类型 (包括双精度浮点)
以及相关的144条新指令。有了这些扩展，编译器可以使用SSE指令而非x87指令来编译浮点代码。</p>
<p>　　Pentium 4E (2004年，125M个晶体管)
添加了超线程和EM64T。EM64T是Intel对AMD开发的IA32的64位扩展的实现，称为x86-64。</p>
<p>　　Core 2 (2006年，291M个晶体管)
回归类似于P6的微体系架构，也是第1个多核Intel处理器，但不支持超线程。</p>
<p>　　后续版本的处理器都被设计为向后兼容，所以指令集中有许多奇怪的指令。</p>
<span id="more"></span>
<p>　　虽然gcc在把程序中表达的计算转换到机器代码方面表项出色，但有些机器特性是C程序无法访问的。例如，每次x86-64处理器执行算术或逻辑运算时，若结果的低8位有偶数个1，则将1位的奇偶标志PF置1；否则，置0。C计算这个信息至少需要7次移位、掩码和异或运算，而几行汇编代码就可以完成该任务。硬件将奇偶标志的计算作为算术或逻辑运算的一部分来执行，但C程序无法得知PF的值。</p>
<p>　　在C程序中插入汇编代码有2种方法。第1种方法是编写完整的函数，放进单独的汇编代码文件中，并用汇编器和链接器将其和C代码合并。第2种方法是使用gcc的<span
style="background-color: yellow">内联汇编</span>，用关键字<code>asm</code>在C程序中加入简短的汇编代码，这种方法可以减少特定于机器的代码。</p>
<p>　　由于16位体系架构发展成了32位，Intel用<strong>字</strong>表示16位数据类型，所以32位数据类型称为<strong>双字</strong>，64位数据类型称为<strong>四字</strong>，128位数据类型称为<strong>八字</strong>。</p>
<p>　　大多数指令都有<strong>操作数</strong>，表示源数据和结果的存储位置。</p>
<p>　　之后内容使用都是<span
style="background-color: yellow">ATT</span>格式汇编代码
(根据曾经运营过贝尔实验室的公司AT&amp;T命名)，这是gcc、OBJDUMP等工具的默认格式。有些编程工具
(包括Microsoft的工具)
和Intel文档的汇编格式都是Intel格式，这2种格式在许多方面有所不同。</p>
<p>　　● Intel汇编代码省略了ATT汇编代码中表示大小标识的后缀
(例如，ATT汇编代码的<code>pushq</code>和<code>movq</code>指令对应Intel汇编代码的<code>push</code>和<code>mov</code>指令)。</p>
<p>　　● Intel汇编代码省略了ATT汇编代码中寄存器名前的<code>%</code>
(例如，ATT汇编代码中的寄存器<code>%rbx</code>对应Intel汇编代码中的<code>rbx</code>)。</p>
<p>　　● ATT汇编代码和Intel汇编代码描述内存中位置的方式不同
(例如，ATT汇编代码中的<code>(%rbx)</code>对应Intel汇编代码中的<code>QWORD PTR [rbx]</code>)。</p>
<p>　　●
对于有多个操作数的指令，ATT汇编代码和Intel汇编代码操作数的顺序相反。</p>
<h3 id="程序编码">3.1 程序编码</h3>
<p>　　假设某个C程序包含文件<code>p1.c</code>和<code>p2.c</code>，其编译命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Og -o p p1.c p2.c</span></span><br></pre></td></tr></table></figure>
<p>　　<code>gcc</code>表示gcc。命令行选项<code>-Og</code>表示gcc会生成符合原始C代码体系优化等级的机器代码，因为使用较高级别的优化可能会生成经过大量转换的代码，导致生成的机器代码和源代码之间看似毫无关联。从性能角度，<code>-O1</code>或<code>-O2</code>是更好的选择。</p>
<table>
<thead>
<tr>
<th>C声明 (x86-64)</th>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小 (单位是字节)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char</code></td>
<td>字节</td>
<td><code>b</code></td>
<td>1</td>
</tr>
<tr>
<td><code>short</code></td>
<td>字</td>
<td><code>w</code></td>
<td>2</td>
</tr>
<tr>
<td><code>int</code></td>
<td>双字</td>
<td><code>l</code></td>
<td>4</td>
</tr>
<tr>
<td><code>long</code></td>
<td>四字</td>
<td><code>q</code></td>
<td>8</td>
</tr>
<tr>
<td><code>char *</code></td>
<td>四字</td>
<td><code>q</code></td>
<td>8</td>
</tr>
<tr>
<td><code>float</code></td>
<td>单精度</td>
<td><code>s</code></td>
<td>4</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度</td>
<td><code>l</code></td>
<td>8</td>
</tr>
</tbody>
</table>
<p>　　部分gcc生成的汇编代码中会有表示操作数大小的后缀。例如，数据移动指令<code>mov</code>有4个变体：<code>movb</code>、<code>movw</code>、<code>movl</code>和<code>movq</code>，后缀<code>l</code>可以表示4字节的<code>int</code>和8字节的<code>double</code>，但这不会产生歧义，因为浮点数使用一系列完全不同的指令和寄存器。</p>
<p>　　浮点数分为单精度和双精度，对应C中的<code>float</code>和<code>double</code>。x86处理器还支持特殊的80位
(10字节)
浮点格式，对应C中的<code>long double</code>，这种格式不能移植到其他类型的机器，而且也不如单精度和双精度浮点运算高效。</p>
<h4 id="机器级代码">3.1.1 机器级代码</h4>
<p>　　对于机器级编程，有2种抽象模型很重要。第1种抽象是由ISA来定义机器级程序的格式和行为，它定义了处理器状态、指令格式以及每条指令对状态的影响。大多数ISA将程序的行为描述为每条指令按序执行，但处理器的硬件复杂得多，它们同时执行多条指令，但可以保证整体行为与ISA定义的执行顺序一致。第2种抽象是机器级程序使用的内存地址是虚拟地址，提供的内存模型看似1个很大的字节数组。</p>
<p>　　x86-64机器代码和原始C代码差距很大，其中的某些处理器状态对C程序员是隐藏的。</p>
<p>　　● <span style="background-color: yellow">程序计数器</span>
(在x86-64中用<code>%rip</code>表示)
给出待执行的下一条指令的内存地址。</p>
<p>　　● <span
style="background-color: yellow">整数寄存器</span>包含16个命名位置，用于存储64位值
(对应C中的指针或整数数据)。有些寄存器用于记录某些重要的程序状态，其他寄存器用于存储临时数据
(例如，过程中的参数和局部变量以及函数返回值)。</p>
<p>　　● <span
style="background-color: yellow">条件码寄存器</span>保存最近执行的算术或逻辑指令的状态信息，用于实现控制或数据流中的条件变化
(例如，<code>if</code>和<code>while</code>语句)。</p>
<p>　　● 多个<span
style="background-color: yellow">向量寄存器</span>可以存储若干个整数或浮点值。</p>
<p>　　虽然C提供了1种允许不同数据类型在内存中声明和分配的模型，但机器代码只是将内存视为1个按字节寻址的数组。C的聚合类型
(例如，数组和结构)
在机器代码中用1组连续的字节表示。对于标量数据类型，汇编代码不会区分指针和整数数据。</p>
<p>　　程序内存包含程序的可执行机器代码、操作系统所需的信息、用于管理过程调用和返回的运行时栈以及用户分配的内存块
(例如，通过库函数<code>malloc()</code>分配)。程序内存使用虚拟地址寻址，在任意时刻，只有有限的虚拟地址子集是有效的。例如，x86-64的虚拟地址由1个64位的字表示，在目前的实现中，地址的高16位必须设置为0，所以地址的实际范围是2<sup>48</sup>。操作系统负责管理虚拟地址，在必要时会将其转换为处理器内存中的物理地址。</p>
<p>　　1条机器指令仅执行1个非常基本的操作
(例如，将存储在寄存器中的2个数相加，在存储器和寄存器之间移动数据以及条件分支到新的指令地址)，编译器必须生成指令序列来实现程序结构。</p>
<h4 id="示例代码">3.1.2 示例代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mstore.c */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Og -S mstore.c</span></span><br></pre></td></tr></table></figure>
<p>　　执行这条命令后，gcc会根据<code>mstore.c</code>生成汇编代码，但不会进一步执行编译流程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.file	&quot;010-mstore.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	multstore</span><br><span class="line">	.type	multstore, @function</span><br><span class="line">multstore:</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	movq	%rdx, %rbx</span><br><span class="line">	call	mult2</span><br><span class="line">	movq	%rax, (%rbx)</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	popq	%rbx</span><br><span class="line">	ret</span><br><span class="line">	.seh_endproc</span><br><span class="line">	.ident &quot;gcc: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1&quot;</span><br><span class="line">	.section .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<p>　　这是<code>mstore.s</code>的完整内容。<code>.</code>开头的行是<strong>汇编指示</strong>，用于引导汇编器和链接器，通常可以忽略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multstore:</span><br><span class="line">    pushq	%rbx</span><br><span class="line">    movq	%rdx,%rbx</span><br><span class="line">    call	mult2</span><br><span class="line">    movq	%rax,(%rbx)</span><br><span class="line">    popq	%rbx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>　　为了更清楚地说明汇编代码，这里省略了大部分汇编指示。<code>mstore.c</code>中每个缩进的行都是1条机器指令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Og -c mstore.c</span></span><br></pre></td></tr></table></figure>
<p>　　执行这条这条命令后，gcc会编译并汇编该代码，生成目标代码文件<code>mstore.o</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3</span><br></pre></td></tr></table></figure>
<p>　　这是汇编指令对应的目标代码。显然，机器执行的程序只是字节序列
(即一系列指令的编码)。</p>
<p>　　<code>objdump</code>等<strong>反汇编器</strong>可用于查看机器代码文件的内容，它会根据机器代码生成类似汇编格式的代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -d mstore.o</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;multstore&gt;:</span><br><span class="line">0:	53		push	%rbx</span><br><span class="line">1:	48 89 d3	mov	%rdx,%rbx</span><br><span class="line">4:	e8 00 00 00 00	callq	9 &lt;multstore+0x9&gt;</span><br><span class="line">9:	48 89 03	mov	%rax,(%rbx)</span><br><span class="line">c:	5b		pop	%rbx</span><br><span class="line">d:	c3		retq</span><br></pre></td></tr></table></figure>
<p>　　左侧是之前的14个十六进制数，它们分成若干组，每组长度为1到5字节，对应右侧的指令。</p>
<p>　　●
x86-64指令长度从1到5字节不等，常用或操作数较少的指令较短，不常用或操作数较多的指令较长。</p>
<p>　　● 指令格式是从某个给定位置开始将字节唯一地解码成机器指令的方式
(例如，只有<code>pushq %rbx</code>以字节值53开始)。</p>
<p>　　●
反汇编器只是基于机器代码文件中的字节序列来生成汇编代码，并不需要访问程序的源代码或汇编代码。</p>
<p>　　● 反汇编器使用的指令命名规则与gcc生成的汇编代码有细微差别
(例如，反汇编输出中省略了部分指令的后缀<code>q</code>。表示操作数大小的后缀<code>q</code>在大多数情况下都可以省略。指令<code>callq</code>和<code>retq</code>对应<code>call</code>和<code>ret</code>，这里的后缀<code>q</code>只是为了强调这是x86-64指令而非IA32，在x86-64汇编代码中，两者没有区别)。</p>
<p>　　生成实际可执行的代码需要对目标代码文件运行链接器，而目标代码文件中必须包含主函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>, <span class="type">long</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> d;</span><br><span class="line">    multstore(<span class="number">2</span>, <span class="number">3</span>, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 * 3 --&gt; %d\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> s = a * b;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Og -o prog main.c mstore.c</span></span><br></pre></td></tr></table></figure>
<p>　　<code>prog</code>的大小是8655字节，因为它不仅包含编写的代码，还包括用于启动和终止程序以及与操作系统交互的代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -d prog</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400540 &lt;multstore&gt;:</span><br><span class="line">400540:	53		push %rbx</span><br><span class="line">400541:	48 89 d3 	mov %rdx,%rbx</span><br><span class="line">400544:	e8 42 00 00 00	callq 40058b &lt;mult2&gt;</span><br><span class="line">400549:	48 89 03	mov %rax,(%rbx)</span><br><span class="line">40054c:	5b		pop %rbx</span><br><span class="line">40054d:	c3		retq</span><br><span class="line">40054e:	90		nop</span><br><span class="line">40054f:	90		nop</span><br></pre></td></tr></table></figure>
<p>　　这是反汇编器生成的代码的一部分，这段代码与<code>mstore.c</code>反汇编生成的代码几乎相同，但也有区别。第1个区别是左侧列出的地址不同——链接器将这段代码的位置移动到一段不同的地址范围中。第2个区别是链接器填上了指令<code>callq</code>调用函数<code>mult2()</code>需要使用的地址
(第4行)，这体现了链接器的任务之一——为函数调用找到对应的可执行代码的位置。第3个区别是结尾多了2行代码
(第8~9行)，它们对程序没有影响，因为出现返回指令 (第7行)
之后。插入这些指令是为了让函数代码变为16字节，以满足内存系统的对齐要求。</p>
<h3 id="访问信息">3.2 访问信息</h3>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/16_integer_registers.svg" class="">
<p>　　x86-64处理器包含16个64位的<strong>通用目的寄存器</strong>，这些寄存器用于存储整数数据和指针。它们都以<code>%r</code>开头，后面跟着一些根据不同命名规则命名的名称
(由于指令集历史的演化)。最初的8086有8个16位的寄存器：<code>%ax</code>到<code>%sp</code>。每个寄存器都有特殊的用途，其名称反映了这些用途。扩展到IA32架构时，这些寄存器也扩展成32位寄存器：从<code>%eax</code>到<code>%esp</code>。扩展到64位时，原来的8个寄存器也扩展成64位：<code>%rax</code>到<code>%rsp</code>，此外，还添加了8个新寄存器，它们都根据新的命名规则命名：<code>%r8</code>到<code>%r15</code>。</p>
<h4 id="操作数指示符">3.2.1 操作数指示符</h4>
<p>　　操作数中的源数据可以是常数，也可以从寄存器或内存中读取，结果可以存储在寄存器或内存中。因此，操作数大致可以分为3种类型。</p>
<p>　　●
第1种类型是<strong>立即数</strong>，用于表示常数。在ATT汇编代码中，立即数的格式是<code>$</code>加上用C风格表示的整数，例如，<code>$-577</code>或<code>$0x1F</code>。不同指令允许的立即数范围不同。汇编器会自动选择最紧凑的方式进行数组编码。</p>
<p>　　●
第2种类型是<strong>寄存器</strong>，用于表示寄存器的内容，16个寄存器的低8、16、32或64位都可以作为操作数。</p>
<p>　　● 第3种类型是<strong>内存引用</strong>，用于根据计算出来的地址
(通常称为<strong>有效地址</strong>)
访问某个内存位置。由于内存可以视很大的字节数组，所以这里用<span
class="math inline">\(M_b[Addr]\)</span>表示从地址<span
class="math inline">\(Addr\)</span>开始的<span
class="math inline">\(b\)</span>个字节值的引用。为了简便，可以省略<span
class="math inline">\(b\)</span>。</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 23%" />
<col style="width: 42%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>操作数值</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>立即数</td>
<td><span class="math inline">\(\$Imm\)</span></td>
<td><span class="math inline">\(Imm\)</span></td>
<td>立即数寻址</td>
</tr>
<tr>
<td>寄存器</td>
<td><span class="math inline">\(r_a\)</span></td>
<td><span class="math inline">\(R[r_a]\)</span></td>
<td>寄存器寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\(Imm\)</span></td>
<td><span class="math inline">\(M[Imm]\)</span></td>
<td>直接/绝对寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\((r_a)\)</span></td>
<td><span class="math inline">\(M[R[r_a]]\)</span></td>
<td>间接寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\(Imm(r_b)\)</span></td>
<td><span class="math inline">\(M[Imm+R[r_b]]\)</span></td>
<td>(基址+偏移量) 寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\((r_b,r_i)\)</span></td>
<td><span class="math inline">\(M[R[r_b]+R[r_i]]\)</span></td>
<td>变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\(Imm(r_b,r_i)\)</span></td>
<td><span class="math inline">\(M[Imm+R[r_b]+[r_i]]\)</span></td>
<td>变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\((,r_i,s)\)</span></td>
<td><span class="math inline">\(M[R[r_i]\cdot s]\)</span></td>
<td>比例变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\(Imm(,r_i,s)\)</span></td>
<td><span class="math inline">\(M[Imm+R[r_i]\cdot s]\)</span></td>
<td>比例变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\((r_b,r_i,s)\)</span></td>
<td><span class="math inline">\(M[R[r_b]+R[r_i]\cdot s]\)</span></td>
<td>比例变址寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><span class="math inline">\(Imm(r_b,r_i,s)\)</span></td>
<td><span class="math inline">\(M[Imm+R[r_b]+R[r_i]\cdot
s]\)</span></td>
<td>比例变址寻址</td>
</tr>
</tbody>
</table>
<p>　　有不同的<strong>寻址模式</strong>允许不同形式的内存引用。<span
class="math inline">\(Imm(r_b,r_i,s)\)</span>是最常用的形式，<span
class="math inline">\(Imm\)</span>表示立即数偏移，<span
class="math inline">\(r_b\)</span>表示基址寄存器 (64位)，<span
class="math inline">\(r_i\)</span>表示变址寄存器 (64位)，<span
class="math inline">\(s\)</span>表示比例因子
(必须是1、2、4或8)，地址计算公式是<span
class="math inline">\(Imm+R[r_b]+R[r_i]\cdot
s\)</span>。引用数组时会用到这种通用形式，其他形式都是这种通用形式的变体
(省略部分元素)。</p>
<h4 id="数据移动指令">3.2.2 数据移动指令</h4>
<table>
<thead>
<tr>
<th>指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOV  S, D</code></td>
<td><code>D</code> ← <code>S</code></td>
<td>移动</td>
</tr>
<tr>
<td><code>movb</code></td>
<td></td>
<td>移动字节</td>
</tr>
<tr>
<td><code>movw</code></td>
<td></td>
<td>移动字</td>
</tr>
<tr>
<td><code>movl</code></td>
<td></td>
<td>移动双字</td>
</tr>
<tr>
<td><code>movq</code></td>
<td></td>
<td>移动四字</td>
</tr>
<tr>
<td><code>movabsp  I, R</code></td>
<td><code>R</code> ← <code>I</code></td>
<td>移动完整的四字</td>
</tr>
</tbody>
</table>
<p>　　数据移动指令的源操作数可以是立即数、寄存器或内存引用，目的操作数可以是寄存器或内存引用。x86-64要求数据移动指令的操作数不能都是内存引用。将值从某个内存位置复制到其他内存位置需要2条指令——第1条指令将值加载到寄存器，第2条指令将值从寄存器写入到目的位置。</p>
<p>　　指令<code>movq</code>只能以32位值作为源操作数，它会把这个值符号扩展
(复制最高位)
到64位并移动目的位置。指令<code>movabsp</code>以64位值作为源操作数，但只能以寄存器作为目的操作数。</p>
<p>　　数据移动指令需要和整数寄存器的大小相匹配。大多数情况下，数据移动指令只会更新目的操作数指定的位置。唯一的例外是指令<code>movl</code>的目的操作数是寄存器时，它会把该寄存器的高4B置0，因为x86-64的惯例——任何为寄存器生成32位值的指令都会把该寄存器的<span
style="background-color: yellow">高位部分置0</span>。</p>
<table>
<thead>
<tr>
<th>零扩展数据移动指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOVZ  S, R</code></td>
<td><code>R</code> ← <code>S</code> (零扩展)</td>
<td>以零扩展进行移动</td>
</tr>
<tr>
<td><code>movzbw</code></td>
<td></td>
<td>将零扩展后的字节移动到字</td>
</tr>
<tr>
<td><code>movzbl</code></td>
<td></td>
<td>将零扩展后的字节移动到双字</td>
</tr>
<tr>
<td><code>movzwl</code></td>
<td></td>
<td>将零扩展后的字移动到双字</td>
</tr>
<tr>
<td><code>movzbq</code></td>
<td></td>
<td>将零扩展后的字节移动到四字</td>
</tr>
<tr>
<td><code>movzwq</code></td>
<td></td>
<td>将零扩展后的字移动到四字</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 35%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr>
<th>符号扩展数据移动指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MOVS  S, R</code></td>
<td><code>R</code> ← <code>S</code> (符号扩展)</td>
<td>以符号扩展进行移动</td>
</tr>
<tr>
<td><code>movsbw</code></td>
<td></td>
<td>将符号扩展后的字节移动到字</td>
</tr>
<tr>
<td><code>movsbl</code></td>
<td></td>
<td>将符号扩展后的字节移动到双字</td>
</tr>
<tr>
<td><code>movswl</code></td>
<td></td>
<td>将符号扩展后的字移动到双字</td>
</tr>
<tr>
<td><code>movsbq</code></td>
<td></td>
<td>将符号扩展后的字节移动到四字</td>
</tr>
<tr>
<td><code>movswq</code></td>
<td></td>
<td>将符号扩展后的字移动到四字</td>
</tr>
<tr>
<td><code>movslq</code></td>
<td></td>
<td>将符号扩展后的双字移动到四字</td>
</tr>
<tr>
<td><code>cltq</code></td>
<td><code>%rax</code> ← <code>%eax</code> (符号扩展)</td>
<td>将<code>%eax</code>符号扩展到<code>%rax</code></td>
</tr>
</tbody>
</table>
<p>　　<span
style="background-color: yellow">零扩展数据移动指令</span>和<span
style="background-color: yellow">符号扩展数据移动指令</span>用于将较小的源操作数
(寄存器或内存引用) 复制到较大的目的操作数
(寄存器)。这2类指令的最后2个字符分别表示源操作数和目的操作数的大小。零扩展数据移动指令中并没有将4B源操作数移动到8B目的操作数的指令，因为指令<code>movl</code>可以实现这个功能。指令<code>cltq</code>没有操作数，因为源操作数只能是<code>%eax</code>，目的操作数只能是<code>%rax</code>，等同于<code>movslq  %eax, %rax</code>。</p>
<h4 id="压入和弹出栈数据">3.2.3 压入和弹出栈数据</h4>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 67%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pushq  S</code></td>
<td><code>R[%rsp]</code> ← <code>R[%rsp] - 8</code>;
<code>M[R[%rsp]]</code> ← <code>S</code></td>
<td>将四字压入栈</td>
</tr>
<tr>
<td><code>popq  D</code></td>
<td><code>D</code> ← <code>M[R[%rsp]]</code>; <code>R[%rsp]</code> ←
<code>R[%rsp] + 8</code></td>
<td>将四字弹出栈</td>
</tr>
</tbody>
</table>
<p>　　栈是后进先出的数据结构，可以添加或删除元素。通过指令<code>pushq</code>压入
(添加) 元素，通过指令<code>popq</code>弹出 (删除)
元素。栈可用于实现数组，总是从数组的一端 (称为<strong>栈顶</strong>)
插入和删除元素。在x86-64中，程序栈存储在内存中某个区域，栈向下增长，栈顶元素的地址值最小。栈指针<code>%rsp</code><span
style="background-color: yellow">总是</span>保存栈顶元素的地址。</p>
<p>　　将1个四字压入栈时，会先将栈指针减8，然后将值写入新的栈顶地址。因此，<code>pushq  %rbp</code>等同于以下2条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subq  $8, %rsp</span><br><span class="line">movq  %rbp, (%rsp)</span><br></pre></td></tr></table></figure>
<p>　　编码为机器代码后，指令<code>pushq</code>仅需1B，而这2条指令共需8B。</p>
<p>　　弹出1个四字时，会先从栈顶读出数据，然后将栈指针加8。因此，<code>popq  %rax</code>等同于以下2条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq  (%rsp), %rax</span><br><span class="line">addq  $8, %rsp</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/stack_operation.svg" class="">
<p>　　因为栈、程序代码和其他形式的程序数据都存储在同一内存中，所以程序可以用标准的内存寻址方式访问栈内的任意位置。</p>
<h4 id="示例代码-1">3.2.4 示例代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">exchange</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exchange:</span><br><span class="line">	movq	(%rdi), %rax</span><br><span class="line">	movq	%rsi, (%rdi)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　这是是函数<code>exchange()</code>的C和汇编代码，寄存器<code>%rdi</code>和<code>%rsi</code>分别存储参数<code>xp</code>和<code>y</code>。C中的指针实际上是地址。<code>*xp</code>表示读取<code>xp</code>所指位置的值，该操作称为<strong>指针间接引用</strong>。操作符<code>*</code>执行指针间接引用，而操作符<code>&amp;</code>执行取址，例如，<code>&amp;a</code>会创建1个指针，该指针指向保存<code>a</code>的位置。</p>
<p>　　像<code>x</code>这样的局部变量通常保存储在寄存器中，因为寄存器的存取速度比内存的快很多。</p>
<p>　　在函数开始执行时，参数<code>xp</code>和<code>y</code>分别存储在寄存器<code>%rdi</code>和<code>%rsi</code>中。第2行指令从内存中读出<code>x</code>并将它存入寄存器<code>%rax</code>中，对应<code>x = *xp</code>。然后，寄存器<code>%rax</code>作为返回值，即<code>x</code>。第3行指令将<code>y</code>写入到寄存器<code>%rdi</code>中的<code>xp</code>指向的内存位置，对应<code>*xp = y</code>。</p>
<h3 id="算术和逻辑操作">3.3 算术和逻辑操作</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>leaq  S, D</code></td>
<td><code>D</code> ← <code>&amp;S</code></td>
<td>加载有效地址</td>
</tr>
<tr>
<td><code>INC  D</code></td>
<td><code>D</code> ← <code>D + 1</code></td>
<td>加1</td>
</tr>
<tr>
<td><code>DEC  D</code></td>
<td><code>D</code> ← <code>D - 1</code></td>
<td>减1</td>
</tr>
<tr>
<td><code>NEG  D</code></td>
<td><code>D</code> ← <code>- D</code></td>
<td>取负</td>
</tr>
<tr>
<td><code>NOT  D</code></td>
<td><code>D</code> ← <code>~ D</code></td>
<td>取补</td>
</tr>
<tr>
<td><code>ADD  S, D</code></td>
<td><code>D</code> ← <code>D + S</code></td>
<td>加</td>
</tr>
<tr>
<td><code>SUB  S, D</code></td>
<td><code>D</code> ← <code>D - S</code></td>
<td>减</td>
</tr>
<tr>
<td><code>IMUL  S, D</code></td>
<td><code>D</code> ← <code>D * S</code></td>
<td>乘</td>
</tr>
<tr>
<td><code>XOR  S, D</code></td>
<td><code>D</code> ← <code>D ^ S</code></td>
<td>异或</td>
</tr>
<tr>
<td><code>OR  S, D</code></td>
<td><code>D</code> ← <code>D | S</code></td>
<td>或</td>
</tr>
<tr>
<td><code>AND  S, D</code></td>
<td><code>D</code> ← <code>D &amp; S</code></td>
<td>与</td>
</tr>
<tr>
<td><code>SAL  k, D</code></td>
<td><code>D</code> ← <code>D &lt;&lt; k</code></td>
<td>左移</td>
</tr>
<tr>
<td><code>SHL  k, D</code></td>
<td><code>D</code> ← <code>D &lt;&lt; k</code></td>
<td>左移 (等同于<code>SAL</code>)</td>
</tr>
<tr>
<td><code>SAR  k, D</code></td>
<td><code>D</code> ← <code>D &gt;&gt; k</code></td>
<td>算术右移</td>
</tr>
<tr>
<td><code>SHR  k, D</code></td>
<td><code>D</code> ← <code>D &gt;&gt; k</code></td>
<td>逻辑右移</td>
</tr>
</tbody>
</table>
<p>　　x86-64整数和逻辑操作指令可分为<span
style="background-color: yellow">加载有效地址</span>、<span
style="background-color: yellow">一元操作</span>、<span
style="background-color: yellow">二元操作</span>和<span
style="background-color: yellow">移位</span>。</p>
<p>　　加载有效地址指令<code>leaq</code>实际上是<code>movq</code>的变体，其指令形式是从内存读数据到寄存器，但实际上不会引用内存。第1个操作数看似是内存引用，但并非从指定的位置读取数据，而是将有效地址写入到目的操作数，所以用C中的取址操作符<code>&amp;</code>表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">scale</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = x + y * <span class="number">4</span> + <span class="number">12</span> * z;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scale:</span><br><span class="line">	leaq	(%rdi,%rsi,4), %rax</span><br><span class="line">	leaq	(%rdx,%rdx,2), %rdx</span><br><span class="line">	leaq	(%rax,%rdx,4), %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　<code>leaq</code>指令能执行加法和有限形式的乘法，在编译简单的算术表达式时很有用。</p>
<p>　　一元操作指令只有1个操作数，这个操作数既是源操作数又是目的操作数，可以是寄存器或内存引用。</p>
<p>　　二元操作指令有2个操作数，第2个操作数既是源操作数又是目的操作数。第1个操作数可以是任何类型，第2个操作数可以是寄存器或内存引用。当第2个操作数是内存引用时，必须先从内存中读出数据并执行操作，然后把结果回写到内存。</p>
<p>　　移位操作指令的第1个操作数是移位量，第2个操作数是待移位的数。移位量可以是立即数或单字节寄存器<code>%cl</code>中的值
(最大移位量为<span
class="math inline">\(2^8-1\)</span>)。左移指令有<code>SAL</code>和<code>SHL</code>，两者效果相同，都是在右边填上0。右移指令有<code>SAR</code>和<code>SHR</code>，前者是算术右移
(填上符号位)，后者是逻辑右移 (填上0)。x86-64中，对<span
class="math inline">\(w\)</span>位的数据移位时，移位量由寄存器<code>%cl</code>中的低<span
class="math inline">\(m\)</span>位决定，其中<span
class="math inline">\(2^m=w\)</span>，高位会被忽略。例如，当寄存器<code>%cl</code>值为<code>0xFF</code>时，指令<code>salb</code>会左移7位，指令<code>salw</code>会左移15位，指令<code>sall</code>会左移31位，指令<code>salq</code>会左移63位。</p>
<p>　　2个64位有符号数或无符号数的乘积需要128位来表示。x86-64指令集对128位数据类型提供了支持。</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 75%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>imulq  S</code></td>
<td><code>R[%rdx], R[%rax]</code> ← <code>S * R[%rax]</code></td>
<td>有符号乘法</td>
</tr>
<tr>
<td><code>mulq  S</code></td>
<td><code>R[%rdx], R[%rax]</code> ← <code>S * R[%rax]</code></td>
<td>无符号乘法</td>
</tr>
<tr>
<td><code>clto</code></td>
<td><code>R[%rdx], R[%rax]</code> ← <code>R[%rax]</code> (符号扩展)</td>
<td>转换为八字</td>
</tr>
<tr>
<td><code>idivq  S</code></td>
<td><code>R[%rdx]</code> ←
<code>R[%rdx]:R[%rax] % S</code>；<code>R[%rax]</code> ←
<code>R[%rdx]:R[%rax] / S</code></td>
<td>有符号除法</td>
</tr>
<tr>
<td><code>divq  S</code></td>
<td><code>R[%rdx]</code> ←
<code>R[%rdx]:R[%rax] % S</code>；<code>R[%rax]</code> ←
<code>R[%rdx]:R[%rax] / S</code></td>
<td>无符号除法</td>
</tr>
</tbody>
</table>
<p>　　乘法指令除了双操作数指令，还有单操作数指令：<code>mulq</code>和<code>imulq</code>。这2条指令都要求一个参数存储在寄存器<code>%rax</code>中，另一个参数数作为指令的源操作数给出。乘积的高64位存储在寄存器<code>%rdx</code>中，低64位存储在寄存器<code>%rax</code>中。指令<code>imulq</code>的操作数可以是1或2个，汇编器会根据操作数的数量来分辨。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __int128 <span class="type">uint128_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">store_upord</span><span class="params">(<span class="type">uint128_t</span> *dest, <span class="type">uint64_t</span> x, <span class="type">uint64_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    *dest = x * (<span class="type">uint128_t</span>)y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store_upord:</span><br><span class="line">	movq	%rsi, %rax</span><br><span class="line">	mulq	%rdx</span><br><span class="line">	movq	%rax, (%rdi)</span><br><span class="line">	movq	%rdx, 8(%rdi)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　存储乘积需要使用2次指令<code>movq</code>，分别存储低64位和高64位。由于生成这段代码的是小端机器，所以高64位存储在较大的地址。</p>
<p>　　除法指令也是单操作数指令，被除数的高64位存储在寄存器<code>%rdx</code>中，低64位存储在寄存器<code>%rax</code>中，除数作为操作数，商存储在寄存器<code>%rax</code>中，余数存储在寄存器<code>%rdx</code>中。</p>
<p>　　对于大多数64位应用程序，被除数通常也是64位，存储在寄存器<code>%rax</code>中，寄存器<code>%rdx</code>应该全为0
(无符号运算) 或符号位
(有符号运算)。64位有符号被除数符号扩展到128位可以通过指令<code>cqto</code>实现
(对应Intel格式中指令<code>cqo</code>)，该指令不需要操作数，默认读取寄存器<code>%rax</code>的符号位并复制到寄存器<code>%rdx</code>的所有位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remdiv</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *qp, <span class="type">long</span> *rp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> q = x / y;</span><br><span class="line">    <span class="type">long</span> r = x % y;</span><br><span class="line">    *qp = q;</span><br><span class="line">    *rp = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remdiv:</span><br><span class="line">	movq	%rdx, %r8</span><br><span class="line">	movq	%rdi, %rax</span><br><span class="line">	cqto</span><br><span class="line">	idivq	%rsi</span><br><span class="line">	movq	%rax, (%r8)</span><br><span class="line">	movq	%rdx, (%rcx)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，会先把参数<code>qp</code>保存到寄存器<code>%r8</code>，因为除法会使用寄存器<code>%rdx</code>。然后准备被除数并进行符号扩展。除法完成后，将寄存器<code>%rax</code>中的商保存到<code>qp</code>，寄存器<code>%rdx</code>中的余数保存到<code>rp</code>。</p>
<h3 id="控制">3.4 控制</h3>
<p>　　机器代码提供了2种基本的底层机制来实现条件行为，即先判断数据值，再根据判断结果来改变控制流或数据流。</p>
<h4 id="条件码">3.4.1 条件码</h4>
<p>　　除了整数寄存器，处理器还维护着1组单个位的<strong>条件码</strong>寄存器，它们表示最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。</p>
<p>　　●
进位标志CF为1时，表示最近的操作使最高位产生了进位，可用来检测无符号操作的溢出。</p>
<p>　　● 零标志ZF为1时，表示最近的操作得到的结果为0。</p>
<p>　　● 符号标志SF为1时，表示最近的操作得到的结果为负。</p>
<p>　　● 溢出标志OF为1时，表示最近的操作导致补码溢出 (无论正负)。</p>
<p>　　指令<code>leaq</code>不会设置条件码寄存器，因为它用于取址。对于逻辑操作，CF和OF都会置0。对于移位操作，CF会设置为最后1个被移出的位，而OF会置0。指令<code>INC</code>和<code>DEC</code>会设置OF和ZF，但不会改变CF。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>基于</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CMP  S1, S2</code></td>
<td><code>S2 - S1</code></td>
<td>比较</td>
</tr>
<tr>
<td><code>cmpb</code></td>
<td></td>
<td>比较字节</td>
</tr>
<tr>
<td><code>cmpw</code></td>
<td></td>
<td>比较字</td>
</tr>
<tr>
<td><code>cmpl</code></td>
<td></td>
<td>比较双字</td>
</tr>
<tr>
<td><code>cmpq</code></td>
<td></td>
<td>比较四字</td>
</tr>
</tbody>
</table>
<p>　　指令<code>CMP</code>和<code>SUB</code>的行为相同，但<code>CMP</code>只设置条件码而不更新目的寄存器。若2个操作数相等，<code>CMP</code>会将ZF置1。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>基于</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TEST  S1, S2</code></td>
<td><code>S1 &amp; S2</code></td>
<td>判断</td>
</tr>
<tr>
<td><code>testb</code></td>
<td></td>
<td>判断字节</td>
</tr>
<tr>
<td><code>testw</code></td>
<td></td>
<td>判断字</td>
</tr>
<tr>
<td><code>testl</code></td>
<td></td>
<td>判断双字</td>
</tr>
<tr>
<td><code>testq</code></td>
<td></td>
<td>判断四字</td>
</tr>
</tbody>
</table>
<p>　　指令<code>TEST</code>和<code>AND</code>的行为相同，但<code>TEST</code>只设置条件码而不更新目的寄存器。指令<code>TEST</code>可用于判断2个操作数是否相同和实现掩码，例如，<code>testq  %rax, %rax</code>可用于检测寄存器<code>%rax</code>的正负。</p>
<h4 id="条件码的使用">3.4.2 条件码的使用</h4>
<p>　　条件码通常不会直接读取，常见的用法有<span
style="background-color: yellow">根据条件码将字节置0或1</span>、<span
style="background-color: yellow">条件跳转到程序某个部分</span>和<span
style="background-color: yellow">条件移动数据</span>。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>别名</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sete  D</code></td>
<td><code>setz</code></td>
<td><code>D</code> ← <code>ZF</code></td>
<td>相等或为0</td>
</tr>
<tr>
<td><code>setne  D</code></td>
<td><code>setnz</code></td>
<td><code>D</code> ← <code>~ZF</code></td>
<td>不等或非0</td>
</tr>
<tr>
<td><code>sets  D</code></td>
<td></td>
<td><code>D</code> ← <code>SF</code></td>
<td>为负</td>
</tr>
<tr>
<td><code>setns  D</code></td>
<td></td>
<td><code>D</code> ← <code>~SF</code></td>
<td>非负</td>
</tr>
<tr>
<td><code>setg  D</code></td>
<td><code>setnle</code></td>
<td><code>D</code> ← <code>~(SF ^ OF) &amp; ~ZF</code></td>
<td>大于 (有符号)</td>
</tr>
<tr>
<td><code>setge  D</code></td>
<td><code>setnl</code></td>
<td><code>D</code> ← <code>~(SF ^ OF)</code></td>
<td>大于等于 (有符号)</td>
</tr>
<tr>
<td><code>setl  D</code></td>
<td><code>setnge</code></td>
<td><code>D</code> ← <code>SF ^ OF</code></td>
<td>小于 (有符号)</td>
</tr>
<tr>
<td><code>setle  D</code></td>
<td><code>setng</code></td>
<td><code>D</code> ← <code>(SF ^ OF) | ZF</code></td>
<td>小于等于 (有符号)</td>
</tr>
<tr>
<td><code>seta  D</code></td>
<td><code>setnbe</code></td>
<td><code>D</code> ← <code>~CF &amp; ~ZF</code></td>
<td>大于 (无符号)</td>
</tr>
<tr>
<td><code>setae  D</code></td>
<td><code>setnb</code></td>
<td><code>D</code> ← <code>~CF</code></td>
<td>大于等于 (无符号)</td>
</tr>
<tr>
<td><code>setb  D</code></td>
<td><code>setnae</code></td>
<td><code>D</code> ← <code>CF</code></td>
<td>小于 (无符号)</td>
</tr>
<tr>
<td><code>setbe  D</code></td>
<td><code>setna</code></td>
<td><code>D</code> ← <code>CF | ZF</code></td>
<td>小于等于 (无符号)</td>
</tr>
</tbody>
</table>
<p>　　指令<code>SET</code>会根据条件码将字节置0或1，其后缀表示不同的条件。指令<code>SET</code>的操作数是单字节整数寄存器或单字节的内存位置，指令会将操作数置0或1。为了得到32或64位结果，必须将高位置0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">comp</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">comp:</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	setl	%al</span><br><span class="line">	movzbl	%ral, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，指令<code>movzbl</code>会把寄存器<code>%eax</code>的高3B和<code>%rax</code>的高4B置0。</p>
<p>　　假设有符号数<span class="math inline">\(a\)</span>、<span
class="math inline">\(b\)</span>和<span
class="math inline">\(t\)</span>的补码形式为<span
class="math inline">\(\alpha\)</span>、<span
class="math inline">\(\beta\)</span>和<span
class="math inline">\(\tau\)</span>且<span
class="math inline">\(\tau=\alpha-^t_w\beta\)</span>。对于指令<code>sete</code>，当<span
class="math inline">\(\tau=0\)</span>时，ZF为1。对于指令<code>setl</code>，在不溢出的情况下
(OF为0)，若<span
class="math inline">\(\tau&lt;0\)</span>，则SF为1；若<span
class="math inline">\(\tau\geqslant0\)</span>，则SF为0。在溢出的情况下
(OF为1)，若<span class="math inline">\(\tau&lt;0\)</span>
(SF为0)，则<span class="math inline">\(a&gt;b\)</span>；若<span
class="math inline">\(\tau&gt;0\)</span> (SF为1)，则<span
class="math inline">\(a&lt;b\)</span>。</p>
<p>　　假设无符号数<span class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>的二进制形式是<span
class="math inline">\(\alpha\)</span>和<span
class="math inline">\(\beta\)</span>。在计算<span
class="math inline">\(\tau=\alpha-^u_w\beta\)</span>时，若<span
class="math inline">\(\tau&lt;0\)</span>时，指令<code>CMP</code>会将CF置1，所以无符号数的比较会使用CF和ZF的组合。</p>
<h4 id="跳转指令">3.4.3 跳转指令</h4>
<p>　　<strong>跳转</strong>指令可以让指令切换到指定位置。在汇编代码中，跳转目标通常用<strong>标签</strong>指明。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>别名</th>
<th>跳转条件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jmp  Label</code></td>
<td></td>
<td></td>
<td>直接跳转</td>
</tr>
<tr>
<td><code>jmp  *Operand</code></td>
<td></td>
<td></td>
<td>间接跳转</td>
</tr>
<tr>
<td><code>je  Label</code></td>
<td><code>jz</code></td>
<td><code>ZF</code></td>
<td>相等或为0</td>
</tr>
<tr>
<td><code>jne  Label</code></td>
<td><code>jnz</code></td>
<td><code>~ZF</code></td>
<td>不等或非0</td>
</tr>
<tr>
<td><code>js  Label</code></td>
<td></td>
<td><code>SF</code></td>
<td>为负</td>
</tr>
<tr>
<td><code>jns  Label</code></td>
<td></td>
<td><code>~SF</code></td>
<td>非负</td>
</tr>
<tr>
<td><code>jg  Label</code></td>
<td><code>jnle</code></td>
<td><code>~(SF ^ OF) &amp; ~ZF</code></td>
<td>大于 (有符号)</td>
</tr>
<tr>
<td><code>jge  Label</code></td>
<td><code>jnl</code></td>
<td><code>~(SF ^ OF)</code></td>
<td>大于等于 (有符号)</td>
</tr>
<tr>
<td><code>jl  Label</code></td>
<td><code>jnge</code></td>
<td><code>SF ^ OF</code></td>
<td>小于 (有符号)</td>
</tr>
<tr>
<td><code>jle  Label</code></td>
<td><code>jng</code></td>
<td><code>(SF ^ OF) | ZF</code></td>
<td>小于等于 (有符号)</td>
</tr>
<tr>
<td><code>ja  Label</code></td>
<td><code>jnbe</code></td>
<td><code>~CF &amp; ~ZF</code></td>
<td>大于 (无符号)</td>
</tr>
<tr>
<td><code>jae  Label</code></td>
<td><code>jnb</code></td>
<td><code>~CF</code></td>
<td>大于等于 (无符号)</td>
</tr>
<tr>
<td><code>jb  Label</code></td>
<td><code>jnae</code></td>
<td><code>CF</code></td>
<td>小于 (无符号)</td>
</tr>
<tr>
<td><code>jbe  Label</code></td>
<td><code>jna</code></td>
<td><code>CF | ZF</code></td>
<td>小于等于 (无符号)</td>
</tr>
</tbody>
</table>
<p>　　指令<code>jmp</code>是无条件跳转指令，可以<strong>直接</strong>或<strong>间接</strong>跳转，例如，<code>jmp  .L1</code>和<code>jmp  *(%rax)</code>。其他跳转指令都是条件跳转指令，条件跳转只能是直接跳转。</p>
<p>　　跳转指令有2种编码方式。第1种编码方法是使用<strong>PC相对</strong>地址
(更常用)，即目标指令的地址相对跳转指令的下一条指令的偏移，偏移量可以编码为1、2或4B。第2种编码方法是使用绝对地址，用4B直接指定目标。汇编器和链接器会选择适当的跳转目的编码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	movq	%rdi, %rax</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	sarq	%rax</span><br><span class="line">.L2:</span><br><span class="line">	testq	%rax, %rax</span><br><span class="line">	jg	.L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:	48 89 f8		mov	%rdi, %rax</span><br><span class="line">3:	eb 03			jmp	8 &lt;loop+0x8&gt;</span><br><span class="line">5:	48 d1 f8		sar	%rax</span><br><span class="line">8:	48 85 c0		test	%rax, %rax</span><br><span class="line">b:	7f f8 			jg	5 &lt;loop+0x5&gt;</span><br><span class="line">d:	f3 c3 			repz retq</span><br></pre></td></tr></table></figure>
<p>　　这是根据同一C文件生成的汇编代码和反汇编代码。在反汇编代码中，第2行中跳转指令的跳转目标为<code>0x8</code>，第5行中跳转指令的跳转目标是<code>0x5</code>。第1个跳转指令的目标编码
(<span style="background-color: yellow">单字节补码形式</span>)
是<code>0x3</code>，加上<code>0x5</code>得到下一条指令 (第4行)
的地址<code>0x8</code>。同样，第2个跳转指令的目标编码为<code>0xf8</code>，加上<code>0xd</code>得到下一条指令
(第3行)
的地址<code>0x5</code>。当执行PC相对寻址时，PC的值是跳转指令的下一条指令的地址而非跳转指令本身的地址，这可以追溯到早期的实现，当时的处理器会将更新PC作为执行下一条指令的第1步。</p>
<p>　　<code>rep; ret</code>是为了避免指令<code>ret</code>成为条件跳转指令的目标，若没有指令<code>rep</code>
(表示空操作)，当分支不跳转时，指令<code>jg</code> (第7行)
会继续到<code>ret</code>指令。根据AMD的文档，当指令<code>ret</code>通过跳转指令到达时，处理器不能正确预测到指令<code>ret</code>的目的地。除了能使代码在AMD上运行更快外，这种组合不会改变其他行为。<code>repz retq</code>与之相同。</p>
<h4 id="用条件控制实现条件分支">3.4.4 用条件控制实现条件分支</h4>
<p>　　在汇编代码中实现条件分支的最常用的方式是结合有条件和无条件跳转指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> lt_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> ge_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">absdiff_se</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        lt_cnt++;</span><br><span class="line">        result = y - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ge_cnt++;</span><br><span class="line">        result = x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">gotodiff_se</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> x_ge_y;</span><br><span class="line">    &#125;</span><br><span class="line">    lt_cnt++;</span><br><span class="line">    result = y - x;</span><br><span class="line">x_ge_y:</span><br><span class="line">    ge_cnt++;</span><br><span class="line">    result = x - y;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">absdiff_se:</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	jge	.L2</span><br><span class="line">	addq	$1, lt_cnt(%rip)</span><br><span class="line">	movq	%rsi, %rax</span><br><span class="line">	subq	%rdi, %rax</span><br><span class="line">	ret</span><br><span class="line">.L2:</span><br><span class="line">	addq	$1, ge_cnt(%rip)</span><br><span class="line">	movq	%rdi, %rax</span><br><span class="line">	subq	%rsi, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是计算两数之差绝对值的C代码，这里会增加2个计数器：<code>lt_cnt</code>和<code>ge_cnt</code>。第3段代码是gcc生成的汇编代码，第2段代码是汇编代码的C版本
(省略了全局变量的声明)，使用了类似汇编无条件跳转指令的<code>goto</code>，这种风格称为goto代码，这种编程风格并不好，因为它会使代码难以阅读和理解。</p>
<h4 id="用条件移动实现条件分支">3.4.5 用条件移动实现条件分支</h4>
<p>　　在汇编代码中实现条件分支的传统方式是<span
style="background-color: yellow">控制</span>的条件移动，当条件满足时，沿对应的路线执行；当条件不满足时，沿其他路径执行。这种机制简单而通用，但在现代处理器上可能非常低效。代替方案是<span
style="background-color: yellow">数据</span>的条件移动，计算条件语句的多种结果并根据条件选取其中之一，该方案会受到一些限制，但更符合现代处理器的性能特性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">absdiff</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        result = y - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">cmovdiff</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> rval = y - x;</span><br><span class="line">    <span class="type">long</span> eval = x - y;</span><br><span class="line">    <span class="type">long</span> ntest = x &gt;= y;</span><br><span class="line">    <span class="keyword">if</span> (ntest)</span><br><span class="line">    &#123;</span><br><span class="line">        rval = eval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">	movq	%rsi, %rax</span><br><span class="line">	subq	%rdi, %rax</span><br><span class="line">	movq	%rdi, %rdx</span><br><span class="line">	subq	%rsi, %rdx</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	cmovge	%rdx, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是计算两数之差的绝对值，第3段代码是数据的条件移动版本的汇编代码，第2段代码是汇编代码的C版本。第2段代码中<code>if</code>语句
(第6~9行) 对应第3段代码中的指令<code>cmp</code>和<code>cmovge</code>
(第6~7行)。</p>
<p>　　处理器通过<strong>流水线</strong>来获取高性能。在流水线中，1条指令的处理要经过一系列阶段，每个阶段执行该过程的一小部分
(例如，从内存读取指令、确定指令类型、从内存读取数据、执行算术运算、将数据写入内存以及更新PC)。这种方式通过重叠连续指令的步骤来获取高性能，例如，从内存读取指令的同时执行前一条指令的算术运算。要做到这一点，要求能够<span
style="background-color: yellow">事先确定待执行的指令序列</span>，这样才能保证流水线里充满待执行的指令。当遇到条件分支
(即跳转)
时，只有当分支条件求值完成后，才能确定分支。处理器使用<strong>分支预测逻辑</strong>来预测分支，只有当预测可靠时
(90%的成功率)，流水线才会充满指令。当预测失误时，处理器会丢弃跳转指令后所有为指令已做的工作，再开始用从正确位置开始的指令去填充流水线。预测失误的代价较高，这会浪费大于15~30个时钟周期，导致程序性能严重下降。</p>
<p>　　以Intel
Haswell处理器上运行函数<code>absdiff()</code>为例，使用传统方式实现条件分支时，<code>x &lt; y</code>的结果不可预测，此外，2个分支中的计算都只需要1个时钟周期，所以预测是否正确决定该函数的性能。对于包含条件分支的x86-64代码，当分支易于预测时，每次调用函数需要大约8个时钟周期；当分支难以预测时，每次调用函数需要大约17.5个时钟周期。假设预测失误的概率是<span
class="math inline">\(p\)</span>。预测成功时，执行代码所需时间是<span
class="math inline">\(T_{OK}\)</span>。预测失误的代价是<span
class="math inline">\(T_{MP}\)</span>。 <span class="math display">\[
T_{avg}(p)=(1-p)T_{OK}+p(T_{OK}+T_{MP})=T_{OK}+pT_{MP}
\]</span> 　　当<span
class="math inline">\(p=\frac{1}{2}\)</span>，<span
class="math inline">\(T_{OK}=8\)</span>，<span
class="math inline">\(T_{ran}=17.5\)</span>时，<span
class="math inline">\(T_{ran}=T_{avg}(p)=T_{OK}+\frac{T_{MP}}{2}\)</span>，故<span
class="math inline">\(T_{MP}=19\)</span>。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>别名</th>
<th>移动条件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cmov  S, R</code></td>
<td><code>cmovz</code></td>
<td><code>ZF</code></td>
<td>相等或为0</td>
</tr>
<tr>
<td><code>cmovne  S, R</code></td>
<td><code>cmovnz</code></td>
<td><code>~ZF</code></td>
<td>不等或非0</td>
</tr>
<tr>
<td><code>cmovs  S, R</code></td>
<td></td>
<td><code>SF</code></td>
<td>为负</td>
</tr>
<tr>
<td><code>cmovns  S, R</code></td>
<td></td>
<td><code>~SF</code></td>
<td>非负</td>
</tr>
<tr>
<td><code>cmovg  S, R</code></td>
<td><code>cmovnle</code></td>
<td><code>~(SF ^ OF) &amp; ~ZF</code></td>
<td>大于 (有符号)</td>
</tr>
<tr>
<td><code>cmovge  S, R</code></td>
<td><code>cmovnl</code></td>
<td><code>~(SF ^ OF)</code></td>
<td>大于等于 (有符号)</td>
</tr>
<tr>
<td><code>cmovl  S, R</code></td>
<td><code>cmovnge</code></td>
<td><code>SF ^ OF</code></td>
<td>小于 (有符号)</td>
</tr>
<tr>
<td><code>cmovle  S, R</code></td>
<td><code>cmovlng</code></td>
<td><code>(SF ^ OF) | ZF</code></td>
<td>小于等于 (有符号)</td>
</tr>
<tr>
<td><code>cmova  S, R</code></td>
<td><code>cmovnbe</code></td>
<td><code>~CF &amp; ~ZF</code></td>
<td>大于 (无符号)</td>
</tr>
<tr>
<td><code>cmovae  S, R</code></td>
<td><code>cmovnb</code></td>
<td><code>~CF</code></td>
<td>大于等于 (无符号)</td>
</tr>
<tr>
<td><code>cmovb  S, R</code></td>
<td><code>cmovnae</code></td>
<td><code>CF</code></td>
<td>小于 (无符号)</td>
</tr>
<tr>
<td><code>cmovbe  S, R</code></td>
<td><code>cmovna</code></td>
<td><code>CF | ZF</code></td>
<td>小于等于 (无符号)</td>
</tr>
</tbody>
</table>
<p>　　条件移动指令都有2个操作数：源寄存器或内存引用<code>S</code>和目的寄存器<code>R</code>，操作数可以是16、32或64位。条件移动指令没有指定操作数长度的后缀。不同于跳转指令和<code>SET</code>，条件移动指令的结果取决于条件码的值，只有当条件满足时才会进行移动。不同于条件跳转指令，处理器无需预测就可以执行条件移动指令，只需要检查条件码并根据情况进行移动。</p>
<p>　　并非所有的条件分支都可以用数据的条件移动来实现。由于无论结果如何，系统都会对所有分支进行计算。因此，当条件分支中的<span
style="background-color: yellow">任一</span>分支可能产生错误或副作用，就会出现非法的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">cread</span><span class="params">(<span class="type">long</span> *xp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (xp ? *xp : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cread:</span><br><span class="line">	movq	(%rdi), %rax</span><br><span class="line">	testq	%rdi, %rdi</span><br><span class="line">	movl	$0, %edx</span><br><span class="line">	cmov	%rdx, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　当第1段代码中的指针为空时，第2段代码这种实现是非法的，<code>movq</code>指令的间接引用会导致空指针错误。</p>
<p>　　使用数据的条件移动也并非总是能提高效率。若条件判断的计算很复杂，而当相应的条件不满足时，相关的工作就白费了。编译器必须在浪费的计算和分支预测失误之间取舍，但编译器没有具有足够的信息来决定，最后gcc还是选择<span
style="background-color: yellow">控制的条件移动</span>。</p>
<h4 id="循环">3.4.6 循环</h4>
<p>　　C提供了多种循环：<code>do-while</code>、<code>while</code>和<code>for</code>。汇编没有对应的指令，但可以通过条件判断和跳转组合来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_do</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (n &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_do_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">loop:</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fact_do:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">.L2:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jg	.L2</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是阶乘的C代码
(<code>do-while</code>版本)，第3段代码是gcc生成的汇编代码，第2段代码是汇编代码的C版本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_while</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result *= n;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_while_jm_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n - <span class="number">1</span>;</span><br><span class="line">test:</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fact_while_jm_goto:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">.L2:</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jg	.L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_while_gd_goto</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">loop:</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fact_while_gd_goto:</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jle	.L3</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">.L2:</span><br><span class="line">	imulq	%rdi, %rax</span><br><span class="line">	subq	$1, %rdi</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jne	.L2</span><br><span class="line">	rep; ret</span><br><span class="line">.L3:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是阶乘的C代码
(<code>while</code>版本)，但gcc有2种编译方法。第1种编译方法是第3段代码
(对应的C代码是第2段)，称为jump to
middle，先执行一个无条件跳转跳到循环结尾处的条件判断，以此来执行初始化的条件判断。第2种编译方法是第5段代码
(对应的C代码是第4段)，称为guarded-do，先进行条件判断，若不满足则跳过循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fact_for</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fact_for_jm_goto:</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	movl	$2, %edx</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	imulq	%rdx, %rax</span><br><span class="line">	addq	$1, %rdx</span><br><span class="line">.L2:</span><br><span class="line">	cmpq	%rdi, %rdx</span><br><span class="line">	jle	.L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fact_for_gd_goto:</span><br><span class="line">	cmpq	$1, %rdi</span><br><span class="line">	jle	.L3</span><br><span class="line">	movl	$1, %edx</span><br><span class="line">	movl	$2, %eax</span><br><span class="line">.L2:</span><br><span class="line">	imulq	%rax, %rdx</span><br><span class="line">	addq	$1, %rax</span><br><span class="line">	cmpq	%rax, %rdi</span><br><span class="line">	jge	.L3</span><br><span class="line">	rep; ret</span><br><span class="line">.L3:</span><br><span class="line">	movl	$1, %edx</span><br><span class="line">	movl	$2, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　C的<code>for</code>语句 (第1段代码) 也可以用jump to middle
(第2段代码) 和guarded-do (第3段代码) 编译。</p>
<h4 id="多重分支">3.4.7 多重分支</h4>
<p>　　C中的<code>switch</code>语句提供基于1个整数索引值的<strong>多重分支</strong>，在处理有多个可能结果的判断时很有用。为了保证高效，在实现多重分支时会使用<strong>跳转表</strong>。跳转表是1个数组，表项<code>i</code>是代码段的地址，对应的代码段会实现<code>switch</code>索引值等于<code>i</code>时程序应采取的行动。相比1组很长的<code>if-else</code>，跳转表执行<code>switch</code>语句的时间与<code>case</code>的数量无关。gcc会根据<code>case</code>的数量和<code>case</code>值的范围跨度来编译<code>switch</code>语句。当<code>case</code>数量较多
(4个以上) 且值的范围跨度较小时，会使用跳转表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_eg</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val = x;</span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        val *= <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">        val += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">103</span>:</span><br><span class="line">        val += <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">104</span>:`</span><br><span class="line">    <span class="keyword">case</span> <span class="number">106</span>:</span><br><span class="line">        val *= val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_eg_impl</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n, <span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> *jt[<span class="number">7</span>] = &#123;&amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B, &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def, &amp;&amp;loc_D&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> index = n - <span class="number">100</span>;</span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loc_def;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> *jt[index];</span><br><span class="line">loc_A:</span><br><span class="line">    val = x * <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_B:</span><br><span class="line">    x = x + <span class="number">10</span>;</span><br><span class="line">loc_C:</span><br><span class="line">    val = x + <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_D:</span><br><span class="line">    val = x * x;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loc_def:</span><br><span class="line">    val = <span class="number">0</span>;</span><br><span class="line">done:</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch_eg:</span><br><span class="line">	subq	$100, %rsi</span><br><span class="line">	cmpq	$6, %rsi</span><br><span class="line">	ja	.L8</span><br><span class="line">	jmp	*.L4(,%rsi,8)</span><br><span class="line">.L3:</span><br><span class="line">	leaq	(%rdi,%rdi,2), %rax</span><br><span class="line">	leaq	(%rdi,%rax,4), %rdi</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L5:</span><br><span class="line">	addq	$10, %rdi</span><br><span class="line">.L6:</span><br><span class="line">	addq	$11, %rdi</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L7:</span><br><span class="line">	imulq	%rdi, %rdi</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L8:</span><br><span class="line">	movl	$0, %edi</span><br><span class="line">.L2:</span><br><span class="line">	movq	%rdi, (%rdx)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是C<code>switch</code>语句的示例，这个示例中包括<code>case</code>跨过不连续的区域，多个标签都是同一<code>case</code>以及没有<code>break</code>结尾的<code>case</code>。第3段代码是gcc生成的汇编代码，第2段代码是汇编代码的C版本。原始的C代码中有针对值100、102~104和106的<code>case</code>，但<code>switch</code>变量<code>n</code>可以为任意值。gcc会先将<code>n</code>减100来将取值范围转移到0~6，然后创建新变量<code>index</code>，通过比较<code>index</code>和6来进行跳转。</p>
<p>　　在第2段代码中，数组<code>jt</code> (第10行)
就是跳转表，有7个表项，每个表项都是1个代码块的地址。表项由代码指针指明，由前缀<code>&amp;&amp;</code>
(创建指向代码位置的指针)
加标签组成。gcc支持计算<code>goto</code>，这是对C的扩展。类似的操作在第3段代码中的第5行，指令<code>jmp</code>的操作数有前缀<code>*</code>
(表示间接跳转)，并且操作数指向内存位置，其索引由寄存器<code>%rsi</code>给出，该寄存器保存<code>index</code>的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.section .rodata</span><br><span class="line">	.align 8		# 地址按8字节对齐</span><br><span class="line">.L4:</span><br><span class="line">	.quad	.L3		# case 100: loc_A</span><br><span class="line">	.quad	.L8		# case 101: loc_def</span><br><span class="line">	.quad	.L5		# case 102: loc_B</span><br><span class="line">	.quad	.L6		# case 103: loc_C</span><br><span class="line">	.quad	.L7		# case 104: loc_D</span><br><span class="line">	.quad	.L8		# case 105: loc_def</span><br><span class="line">	.quad	.L7		# case 106: loc_D</span><br></pre></td></tr></table></figure>
<p>　　这是跳转表的汇编声明，在<code>.rodata</code> (read-only data)
的目标代码文件段中，其中有7个四字，每个四字的值都是对应的汇编代码标签
(例如，<code>.L3</code>)
的地址。标签<code>.L4</code>是这个区域的起始，该标签对应的地址会作为间接跳转
(汇编代码中的第5行) 的基址。</p>
<h3 id="过程">3.5 过程</h3>
<p>　　过程是软件中的重要抽象之一，它提供了1种封装代码的方式，用1组指定的参数和1个可选的返回值实现了某个功能。在不同编程语言中，过程的形式有多种，例如，函数、方法、子例程和处理函数。要提供过程的机器级支持，必须要处理很多不同的属性。</p>
<p>　　假设过程<code>P()</code>调用过程<code>Q()</code>，<code>Q()</code>执行后返回到<code>P()</code>，该过程至少包括以下机制中的1个：</p>
<p>　　●
<strong>转移控制权</strong>。在进入过程<code>Q()</code>时，PC必须设置为<code>Q()</code>的代码的起始地址，然后在返回时，把PC设置为<code>P()</code>中对<code>Q()</code>的调用的下一条指令的地址。</p>
<p>　　●
<strong>传递数据</strong>。<code>P()</code>必须能向<code>Q()</code>提供若干个参数，<code>Q()</code>必须能向<code>P()</code>返回1个值。</p>
<p>　　●
<strong>分配和释放内存</strong>。在开始时，<code>Q()</code>可能需要为局部变量分配空间，而在返回前，必须释放这些空间。</p>
<p>　　当<code>Q()</code>执行时，<code>P()</code>以及调用链中所有直到<code>P()</code>的过程都会暂挂。当<code>Q()</code>运行时，仅需要为局部变量分配新的存储空间或设置对其他过程的调用。当<code>Q()</code>返回时，它分配的所有局部变量都可以释放。因此，程序可以用栈来管理其过程所需的存储空间，栈和PC存储着转移控制权、传递数据和分配内存所需的信息。当<code>P()</code>调用<code>Q()</code>时，控制权和数据信息会添加到栈顶。当<code>P()</code>返回时，这些信息会释放。</p>
<p>　　寄存器是唯一所有过程都共享的资源。虽然在给定时刻只有1个过程是活跃的，但仍需确保当过程调用其他过程时，被调用者不会覆盖调用者之后会使用的寄存器的值。为此，x86-64了采用了所有过程
(包括程序库) 都必须遵守的使用惯例。</p>
<p>　　按照惯例，寄存器<code>%rbx</code>、<code>%rbp</code>以及<code>%r12</code>~<code>%r15</code>是<strong>被调用者保存</strong>寄存器。当过程<code>P()</code>调用过程<code>Q()</code>时，<code>Q()</code>必须保存这些寄存器的值，维持它们的值在<code>Q()</code>返回<code>P()</code>时与<code>Q()</code>被调用时一致。过程<code>Q()</code>要维持寄存器的值不变，要么不改变寄存器的值，要么将寄存器的旧值压入栈中，改变寄存器的值，然后在返回前弹出旧值。所有其他寄存器
(除栈指针外)
是<strong>调用者保存</strong>寄存器，顾名思义，调用者在调用前需要先保存寄存器的值，所以所有过程都可以修改这类寄存器。</p>
<h4 id="运行时栈">3.5.1 运行时栈</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/general_stack_frame_structure.svg" class="">
<p>　　当x86-64过程需要的存储空间超出寄存器能存储的空间时，就会在栈上分配空间，该部分称为过程的<strong>栈帧</strong>。当前正在执行的过程总是在栈顶。<span
style="background-color: yellow">大多数</span>过程的栈帧都是定长的，在过程的开始就已分配。</p>
<p>　　当过程<code>P()</code>调用过程<code>Q()</code>时，会把返回地址压入栈中，表示从<code>Q()</code>返回时<code>P()</code>继续执行的位置，这个返回地址存储的是与<code>P()</code>相关的状态，所以属于<code>P()</code>的栈帧。<code>Q()</code>的代码会扩展到当前栈的边界，分配它的栈帧所需的空间，这个空间可用于保存寄存器的值、分配局部变量的值和为其调用的过程设置参数。</p>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>操作数大小 (单位是位)</th>
<th>参数1</th>
<th>参数2</th>
<th>参数3</th>
<th>参数4</th>
<th>参数5</th>
<th>参数6</th>
</tr>
</thead>
<tbody>
<tr>
<td>64</td>
<td><code>%rdi</code></td>
<td><code>%rsi</code></td>
<td><code>%rdx</code></td>
<td><code>%rcx</code></td>
<td><code>%r8</code></td>
<td><code>%r9</code></td>
</tr>
<tr>
<td>32</td>
<td><code>%edi</code></td>
<td><code>%esi</code></td>
<td><code>%edx</code></td>
<td><code>%ecx</code></td>
<td><code>%r8d</code></td>
<td><code>%r9d</code></td>
</tr>
<tr>
<td>16</td>
<td><code>%di</code></td>
<td><code>%si</code></td>
<td><code>%dx</code></td>
<td><code>%cx</code></td>
<td><code>%r8w</code></td>
<td><code>%r9w</code></td>
</tr>
<tr>
<td>8</td>
<td><code>%dil</code></td>
<td><code>%sil</code></td>
<td><code>%dl</code></td>
<td><code>%cl</code></td>
<td><code>%r8b</code></td>
<td><code>%r9b</code></td>
</tr>
</tbody>
</table>
<p>　　在x86-64中，可通过寄存器<span
style="background-color: yellow">最多传递6个</span>整数数据
(例如，整数和指针)。寄存器的使用有特定顺序，寄存器的选择取决于待传递的数据的数据类型的大小。若函数的参数超过6个，超出的部分需要用栈来传递，即把参数0~5复制到寄存器，把参数6~n压入栈
(参数6位于栈顶)。通过栈传递参数时，所有的数据的大小都需要向上舍入到<span
style="background-color: yellow">8的整数倍</span>，这部分参数需要在自己的栈帧中分配空间，称为<strong>参数构造区</strong>。</p>
<p>　　有时，局部数据必须存储在内存中：</p>
<p>　　● 寄存器不足以存储所有的本地数据。</p>
<p>　　●
对局部变量使用地址运算符<code>&amp;</code>，所以必须能够为其生成地址。</p>
<p>　　●
某些局部变量是数组或结构，所以必须能够通过数组或结构引用来访问它们。</p>
<p>　　一般情况下，过程通过减小栈指针来在栈上分配空间，该空间作为栈帧的一部分
(即<strong>局部变量</strong>)。</p>
<p>　　为了提高空间和时间使用率，x86-64仅分配自己所需的栈帧部分，例如，当过程的参数少于6个时，所有参数都可以通过寄存器传递。实际上，很多过程甚至不需要栈帧，例如，所有的局部变量都可以保存在寄存器且不调用其他过程的过程。</p>
<h4 id="转移控制权">3.5.2 转移控制权</h4>
<p>　　将控制权从过程<code>P()</code>转移到过程<code>Q()</code>仅需把PC设置为<code>Q()</code>的代码的起始位置。从<code>Q()</code>返回时，处理器需要记录<code>P()</code>继续执行的代码位置。在x86-64中，用指令<code>call  Q</code>调用过程<code>Q()</code>时会记录该信息，该指令会把地址<code>A</code>压入栈中，并把PC设置为<code>Q()</code>的起始地址。压入的地址<code>A</code>称为返回地址，是指令<code>call</code>的下一条指令的地址。指令<code>ret</code>会从栈中弹出地址<code>A</code>并把PC设置为<code>A</code>。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>call  Label</code></td>
<td>过程调用</td>
</tr>
<tr>
<td><code>call  *Operand</code></td>
<td>过程调用</td>
</tr>
<tr>
<td><code>ret</code></td>
<td>从过程调用中返回</td>
</tr>
</tbody>
</table>
<p>　　指令<code>call</code>有1个操作数：被调过程的指令的起始地址。类似跳转，调用可以是直接，也可以是间接
(<code>*</code>加操作数指示符)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># leaf(long y)的反汇编代码</span><br><span class="line">0000000000400540 &lt;leaf&gt;:</span><br><span class="line">400540:	48 8d 47 02	lea	0x2(%rdi), %rax</span><br><span class="line">400544:	c3		retq</span><br><span class="line"></span><br><span class="line"># top(long x)的反汇编代码</span><br><span class="line">0000000000400545 &lt;top&gt;:</span><br><span class="line">400545:	48 83 ef 05	sub	$0x5, %rdi</span><br><span class="line">400549:	e8 f2 ff ff ff 	callq	400540 &lt;leaf&gt;</span><br><span class="line">40054e: 48 01 c0	add	%rax, %rax</span><br><span class="line">400551: c3		retq</span><br><span class="line"></span><br><span class="line"># 主函数调用top的反汇编代码</span><br><span class="line"># ...</span><br><span class="line">40055b: e8 e5 ff ff ff	callq	400545 &lt;top&gt;</span><br><span class="line">400560: 48 89 c2	mov	%rax, %rdx</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 10%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr>
<th>PC</th>
<th>指令</th>
<th><code>%rdi</code></th>
<th><code>%rax</code></th>
<th><code>%rsp</code></th>
<th><code>*%rsp</code></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x40055b</code></td>
<td><code>callq</code></td>
<td>100</td>
<td></td>
<td><code>0x7fffffffe820</code></td>
<td></td>
<td>调用<code>top(100)</code></td>
</tr>
<tr>
<td><code>0x400545</code></td>
<td><code>sub</code></td>
<td>100</td>
<td></td>
<td><code>0x7fffffffe818</code></td>
<td><code>0x400560</code></td>
<td>进入<code>top</code></td>
</tr>
<tr>
<td><code>0x400549</code></td>
<td><code>callq</code></td>
<td>95</td>
<td></td>
<td><code>0x7fffffffe818</code></td>
<td><code>0x400560</code></td>
<td>调用<code>leaf(100)</code></td>
</tr>
<tr>
<td><code>0x400540</code></td>
<td><code>lea</code></td>
<td>95</td>
<td></td>
<td><code>0x7fffffffe810</code></td>
<td><code>0x40054e</code></td>
<td>进入<code>leaf</code></td>
</tr>
<tr>
<td><code>0x400544</code></td>
<td><code>retq</code></td>
<td></td>
<td>97</td>
<td><code>0x7fffffffe810</code></td>
<td><code>0x40054e</code></td>
<td><code>leaf</code>返回97</td>
</tr>
<tr>
<td><code>0x40054e</code></td>
<td><code>add</code></td>
<td></td>
<td>97</td>
<td><code>0x7fffffffe818</code></td>
<td><code>0x400560</code></td>
<td>继续<code>top</code></td>
</tr>
<tr>
<td><code>0x400551</code></td>
<td><code>retq</code></td>
<td></td>
<td>194</td>
<td><code>0x7fffffffe818</code></td>
<td><code>0x400560</code></td>
<td><code>top</code>返回194</td>
</tr>
<tr>
<td><code>0x400560</code></td>
<td><code>mov</code></td>
<td></td>
<td>194</td>
<td><code>0x7fffffffe820</code></td>
<td></td>
<td>继续主函数</td>
</tr>
</tbody>
</table>
<p>　　在这个示例中，主函数先调用<code>top(100)</code>，然后<code>top</code>调用<code>leaf(95)</code>。<code>leaf</code>向<code>top</code>返回97，然后<code>top</code>向主函数返回194。第3行将寄存器<code>%rax</code>设置为97，然后第4行返回，从栈中弹出<code>0x40054e</code>并将PC设置为这个弹出的值，控制权转移回<code>top</code>并将寄存器<code>%rax</code>置为194
(第11行)，最后第11行返回，它从栈中弹出<code>0x400560</code>并将PC设置为这个弹出的值。此时，<code>%rsp</code>也恢复为调用<code>top</code>前的值。</p>
<p>　　把返回地址压入栈的这种简单机制能让函数在之后返回到程序中正确的位置。C
(以及大多数编程语言)
标准的调用-返回机制刚好与栈提供的后进先出的内存管理方法吻合。</p>
<h4 id="传递数据">3.5.3 传递数据</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="type">long</span> a1, <span class="type">long</span> *a1p, <span class="type">int</span> a2, <span class="type">int</span> *a2p, <span class="type">short</span> a3, <span class="type">short</span> *a3p, <span class="type">char</span> a4, <span class="type">char</span> *a4p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    *a4p += a4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc:</span><br><span class="line">	movq	16(%rsp), %rax</span><br><span class="line">	addq	%rdi, (%rsi)</span><br><span class="line">	addl	%edx, (%rcx)</span><br><span class="line">	addw	%r8w, (%r9)</span><br><span class="line">	movl	8(%rsp), %edx</span><br><span class="line">	addb	%dl, (%rax)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/stack_frame_for_function_proc.svg" class="">
<p>　　函数<code>proc()</code>有8个参数，包括不同长度的整数数和指向这些整数数的指针，其中前6个参数通过寄存器传递，后2个参数通过栈传递。作为过程调用的一部分，返回地址被压入栈中，所以后2个参数位于相对栈指针距离为8和16的位置。</p>
<h4 id="栈上的局部存储">3.5.4 栈上的局部存储</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">call_proc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> x1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">short</span> x3 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">    proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4);</span><br><span class="line">    <span class="keyword">return</span> (x1 + x2) * (x3 - x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call_proc:</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	movq	$1, 24(%rsp)</span><br><span class="line">	movl	$2, 20(%rsp)</span><br><span class="line">	movw	$3, 18(%rsp)</span><br><span class="line">	movb	$4, 17(%rsp)</span><br><span class="line">	leaq	17(%rsp), %rax</span><br><span class="line">	movq	%rax, 8(%rsp)</span><br><span class="line">	movl	$4, (%rsp)</span><br><span class="line">	leaq	18(%rsp), %r9</span><br><span class="line">	movl	$3, %r8d</span><br><span class="line">	leaq	20(%rsp), %rcx</span><br><span class="line">	movl	$2, %edx	</span><br><span class="line">	leaq	24(%rsp), %rsi</span><br><span class="line">	movl	$1, %edi</span><br><span class="line">	call	proc</span><br><span class="line">	movslq	20(%rsp), %rdx</span><br><span class="line">	addq	24(%rsp), %rdx</span><br><span class="line">	movswl	18(%rsp), %eax</span><br><span class="line">	movsbl	17(%rsp), %ecx</span><br><span class="line">	subl	%ecx, %eax</span><br><span class="line">	cltq</span><br><span class="line">	imulq	%rdx, %rax</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/stack_frame_for_function_call_proc.svg" class="">
<p>　　函数<code>call_proc()</code>有4个局部变量，还需要向有8个参数的函数<code>proc()</code>传参。函数<code>call_proc()</code>的汇编代码中大部分代码
(第2~15行)
都是为调用函数<code>proc()</code>准备，包括为局部变量和函数参数分配空间以及将函数参数加载到寄存器。在栈帧上分配局部变量<code>x1</code>
(相对栈指针偏移量为24)、<code>x2</code>
(相对栈指针偏移量为20)、<code>x3</code> (相对栈指针偏移量为18)
和<code>x4</code>
(相对栈指针偏移量为17)。用<code>leaq</code>指令生成指向这些变量的指针
(第7、10、12和14行)。参数7 (值为4) 和参数8 (指向<code>x4</code>的指针)
存储在相对栈指针偏移量为0和8的位置。</p>
<p>　　在调用函数<code>proc()</code>时，参数7和参数8的位置会变成相对栈指针偏移量为8和16的位置，因为返回地址已经被压入栈帧中。调用函数<code>proc()</code>完成后，会获取4个局部变量的值
(第17~20行) 并计算最终结果。在函数结束前，把栈指针加32来释放栈帧。</p>
<h4 id="寄存器中的局部存储空间">3.5.5 寄存器中的局部存储空间</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">P</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> u = Q(y);</span><br><span class="line">    <span class="type">long</span> v = Q(x);</span><br><span class="line">    <span class="keyword">return</span> u + v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	subq	$8, %rsp</span><br><span class="line">	movq	%rdi, %rbp</span><br><span class="line">	movq	%rsi, %rdi</span><br><span class="line">	call	Q</span><br><span class="line">	movq	%rax, %rbx</span><br><span class="line">	movq	%rbp, %rdi</span><br><span class="line">	call	Q</span><br><span class="line">	addq	%rbx, %rax</span><br><span class="line">	addq	$8, %rsp</span><br><span class="line">	popq	%rbx</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　函数<code>P()</code>调用了2次函数<code>Q()</code>，第1次调用前，必须保存<code>x</code>的值。同样，第2次调用前，必须保存<code>Q(y)</code>的值。在汇编代码中，寄存器<code>%rbp</code>和<code>%rbx</code>分别保存<code>x</code>和<code>Q(y)</code>
(第2~3行)，然后进行栈帧对齐
(第4行)。第1次调用<code>Q()</code>前，把<code>x</code>存入<code>%rbp</code>
(第5行)，第2次调用<code>Q()</code>前，把上次调用的返回结果存入<code>%rbx</code>
(第8行)。最后，把它们从栈帧中弹出
(第13~14行)，恢复这2个被调用者保存寄存器的值。</p>
<h4 id="递归">3.5.6 递归</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rfact</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rfact:</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	movq	%rdi, %rbx</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	movq	$1, %rdi</span><br><span class="line">	jle	.L1</span><br><span class="line">	leaq	-1(%rdi), %rdi</span><br><span class="line">	call	rfact</span><br><span class="line">	imulq	%rbx, %rax</span><br><span class="line">.L1:</span><br><span class="line">	popq	%rbx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　在函数<code>rfact()</code>的汇编代码中，寄存器<code>%rbx</code>用于保存参数<code>n</code>，先把已有的值压入栈帧
(第2行)，随后在返回前弹出
(第11行)。根据栈的特点和寄存器的保存规则，可以保证当递归调用<code>rfact(n - 1)</code>返回时，调用的结果会保存到寄存器<code>%rax</code>且参数<code>n</code>仍然在寄存器<code>%rbx</code>中。</p>
<p>　　递归调用与调用其他函数一样。栈的机制保证每次调用都有私有的状态信息
(保存的返回位置和被调用者保存寄存器的值)
存储空间。如果需要，它还可以提供局部变量的存储。栈的分配和释放规则很自然地与函数调用-返回的顺序匹配。这种实现函数调用和返回的方法更复杂的场景同样适用，包含相互递归调用
(例如，函数<code>P()</code>调用<code>Q()</code>，<code>Q()</code>再调用<code>P()</code>)。</p>
<h3 id="数组的分配和访问">3.6 数组的分配和访问</h3>
<p>　　C中的数组可用于将标量数据聚集成更大的数据类型。对于数据类型<code>T</code>和整数常数<code>N</code>，其对应数组的声明为<code>T A[N]</code>。在声明时，会先在内存中分配<span
class="math inline">\(L\cdot N\)</span>字节的连续区域，<span
class="math inline">\(L\)</span>是数据类型<code>T</code>的大小。然后，声明标识符<code>A</code>来作为指向数组起始位置的指针，其指针值为<span
class="math inline">\(x_A\)</span>。可以用0到<span
class="math inline">\(N-1\)</span>的整数索引来访问该数组元素。数组元素<code>i</code>的存储地址为<span
class="math inline">\(x_A+L\cdot i\)</span>。</p>
<p>　　C允许指针运算，若<code>p</code>是指向类型是<code>T</code>的数据的指针，<code>p</code>的值为<span
class="math inline">\(x_p\)</span>，则<code>p + i</code>的值为<span
class="math inline">\(x_p+L\cdot
i\)</span>。可以对数组和指针应用数组下标操作，数组引用<code>A[i]</code>等同于<code>*(A + i)</code>。</p>
<p>　　假设整数数组<code>E</code>的起始地址和整数索引<code>i</code>分别存储在寄存器<code>%rdx</code>和<code>%rcx</code>中。以下是一些与<code>E</code>有关的表达式以及对应的汇编代码实现，结果存储在寄存器<code>%eax</code>
(若是数据) 或寄存器<code>%rax</code> (若是指针) 中。</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 10%" />
<col style="width: 21%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr>
<th>表达式</th>
<th>类型</th>
<th>值</th>
<th>汇编代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>E</code></td>
<td><code>int *</code></td>
<td><span class="math inline">\(x_E\)</span></td>
<td><code>movq  %rdx, %rax</code></td>
</tr>
<tr>
<td><code>E[0]</code></td>
<td><code>int</code></td>
<td><span class="math inline">\(M[x_E]\)</span></td>
<td><code>movl  (%rdx), %rax</code></td>
</tr>
<tr>
<td><code>E[i]</code></td>
<td><code>int</code></td>
<td><span class="math inline">\(M[x_E+4i]\)</span></td>
<td><code>movl  (%rdx,%rcx,4), %eax</code></td>
</tr>
<tr>
<td><code>&amp;E[2]</code></td>
<td><code>int *</code></td>
<td><span class="math inline">\(x_E+8\)</span></td>
<td><code>leaq  8(%rdx), %rax</code></td>
</tr>
<tr>
<td><code>E + i - 1</code></td>
<td><code>int *</code></td>
<td><span class="math inline">\(x_E+4i-4\)</span></td>
<td><code>leaq  -4(%rdx,%rcx,4), %rax</code></td>
</tr>
<tr>
<td><code>*(E + i - 3)</code></td>
<td><code>int</code></td>
<td><span class="math inline">\(M[x_E+4i-12]\)</span></td>
<td><code>movl  -12(%rdx,%rcx,4), %eax</code></td>
</tr>
<tr>
<td><code>&amp;E[i] - E</code></td>
<td><code>long</code></td>
<td><span class="math inline">\(i\)</span></td>
<td><code>movq  %rcx, %rax</code></td>
</tr>
</tbody>
</table>
<h4 id="嵌套数组">3.6.1 嵌套数组</h4>
<p>　　当创建嵌套数组时，数组的分配和引用一般原则也成立。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">row3_t</span>[<span class="number">3</span>];</span><br><span class="line"><span class="type">row3_t</span> A[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>　　这是二元数组的声明方式之一，数据类型<code>row3_t</code>定义为包含3个<code>int</code>的数组，数组<code>A</code>包含5个元素，所有元素都是12B，整个数组是60B。</p>
<p>　　访问多维数组时，gcc会生成代码来计算元素的偏移量，并以数组的起始地址为基址和以偏移量
(可能会伸缩)
为索引来执行数据移动指令。对于声明为<code>T D[R][C]</code>的数组，数组元素<code>D[i][j]</code>的地址为<span
class="math inline">\(x_0+L(C\cdot i+j)\)</span>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leaq	(%rsi,%rsi,2), %rax</span><br><span class="line">leaq	(%rdi,%rax,4), %rax</span><br><span class="line">movl	(%rax,%rdx,4), %eax</span><br></pre></td></tr></table></figure>
<p>　　这段代码会计算元素地址<span
class="math inline">\(x_A+12i+4j=x_A+4(3i+j)\)</span>，使用了x86-64地址运算的伸缩和加法特性。其中<code>A[i][j]</code>是<span
class="math inline">\(5\times
3\)</span>的整数数组，第1个元素的指针、<code>i</code>和<code>j</code>分别在寄存器<code>%rdi</code>、<code>%rsi</code>和<code>%rdx</code>中。</p>
<h4 id="定长数组">3.6.2 定长数组</h4>
<p>　　gcc能够优化定长数组上的操作代码，这里以优化等级<code>-O1</code>为例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> fix_matrix[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fix_prod_ele</span><span class="params">(fix_matrix A, fix_matrix B, <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += A[i][j] * B[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fix_prod_ele_opt</span><span class="params">(fix_matrix A, fix_matrix B, <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *Aptr = &amp;A[i][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> *Bptr = &amp;B[<span class="number">0</span>][k];</span><br><span class="line">    <span class="type">int</span> *Bend = &amp;B[N][k];</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result += *Aptr * *Bptr;</span><br><span class="line">        Aptr++;</span><br><span class="line">        Bptr += N;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Bptr != Bend);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fix_prod_ele:</span><br><span class="line">	salq	$6, %rdx</span><br><span class="line">	addq	%rdx, %rdi</span><br><span class="line">	leaq	(%rsi,%rcx,4), %rcx</span><br><span class="line">	leaq	1024(%rcx), %rsi</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">.L2:</span><br><span class="line">	movl	(%rdi), %edx</span><br><span class="line">	imull	(%rcx), %edx</span><br><span class="line">	addl	%edx, %eax</span><br><span class="line">	addq	$4, %rdi</span><br><span class="line">	addq	$64, %rcx</span><br><span class="line">	cmpq	%rsi, %rcx</span><br><span class="line">	jne	.L2</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是计算矩阵<code>A</code>的行<code>i</code>和矩阵<code>B</code>的列<code>k</code>的内积的C版本，第3段代码是gcc生成的汇编代码，第2段代码是汇编代码的C版本。相比第1段代码，第3段代码省略了整数索引<code>j</code>，并把所有的数组引用都换成了指针间接引用，包括指向矩阵<code>A</code>的行<code>i</code>中元素的指针<code>Aptr</code>、指向矩阵<code>B</code>的列<code>k</code>中元素的指针<code>Bptr</code>以及终止循环的指针<code>Bend</code>。</p>
<h4 id="变长数组">3.6.3 变长数组</h4>
<p>　　过去，C仅支持大小在编译时就能确定的多维数组
(对第1维可能有些例外)。若需要实现变长数组，需要使用<code>malloc()</code>或<code>calloc()</code>等函数和行优先索引将多维数组映射到一维数组。ISO
C99加入了允许数组维度是表达式的功能，维度在数组被分配时才计算出来，声明为<code>int A[expr1][expr2]</code>，它可以作为局部变量或函数的参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">var_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">long</span> i, <span class="type">long</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码会访问<span class="math inline">\(n\times
n\)</span>数组的元素<code>A[i][j]</code>，参数<code>n</code>必须在参数<code>A[n][n]</code>之前，这样函数可以在遇到这个数组时计算出其维度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">var_prod_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">int</span> B[n][n], <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += A[i][j] * B[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">var_prod_ele</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> A[n][n], <span class="type">int</span> B[n][n], <span class="type">long</span> i, <span class="type">long</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> *Arow = A[i];</span><br><span class="line">    <span class="type">int</span> *Bptr = &amp;B[<span class="number">0</span>][k];</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        result += Arow[j] * *Bptr;</span><br><span class="line">        Bptr += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.L2:</span><br><span class="line">	movl	(%rsi,%rdx,4), %r8d</span><br><span class="line">	imull	(%rcx), %r8d</span><br><span class="line">	addl	%r8d, %eax</span><br><span class="line">	addq	$1, %rdx</span><br><span class="line">	addq	%r9, %rcx</span><br><span class="line">	cmpq	%rdi, %rax</span><br><span class="line">	jne	.L2</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是计算<span class="math inline">\(n\times
n\)</span>矩阵<code>A</code>的行<code>i</code>和<span
class="math inline">\(n\times
n\)</span>矩阵<code>B</code>的列<code>k</code>的内积的C版本，第3段代码是gcc生成的汇编代码
(仅节选了循环部分)，第2段代码是汇编代码的C版本。第2段代码中，保留了循环变量<code>j</code>来判断循环是否结束以及作为到<code>A</code>的行<code>i</code>的元素组成的数组的索引。第3段代码中，使用了伸缩后的值<code>4n</code>
(存储在寄存器<code>%r9</code>)
来增加<code>Bptr</code>，也使用了值<code>n</code>来判断循环是否结束，C代码中并没有体现出需要这2个值，但是由于指针运算的伸缩才使用了它们。</p>
<p>　　若允许使用优化，gcc能够识别出程序访问多维数组时的步长，然后在生成代码时避免直接应用计算元素地址的等式而导致的乘法。不论生成基于指针的代码还是基于数组的代码，这些优化都能显著提供程序的性能。</p>
<h3 id="异质的数据结构">3.7 异质的数据结构</h3>
<p>　　C提供了2种将不同类型的对象组合起来创建数据类型的机制：<strong>结构体</strong>和<strong>共用体</strong>。结构体允许将多个对象聚合到1个单元，用关键字<code>struct</code>声明。共用体允许用几种不同的类型来引用同一对象，用关键字<code>union</code>声明。</p>
<h4 id="结构体">3.7.1 结构体</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/structure_rec.svg" class="">
<p>　　结构体<code>rec</code>包括2个<code>int</code>、1个由2个<code>int</code>组成的数组和1个<code>int</code>指针。数组<code>a</code>是嵌入到该结构体的。</p>
<p>　　在汇编代码中访问结构体的字段时，需要在结构体的地址上加上合适的偏移量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r-&gt;p = &amp;r-&gt;a[r-&gt;i + r-&gt;j];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl	4(%rdi), %eax</span><br><span class="line">addl	(%rdi), %eax</span><br><span class="line">ctlq</span><br><span class="line">leaq	8(%rdi,%rax,4), %rax</span><br><span class="line">movq	%rax, 16(%rdi)</span><br></pre></td></tr></table></figure>
<p>　　<code>r</code>的类型是<code>struct rec *</code>，存储在寄存器<code>%rdi</code>中。在汇编代码中，第1~2行会将元素<code>r-&gt;i</code>加上元素<code>r-&gt;j</code>，字段<code>i</code>的偏移量是0，其地址是<code>r</code>。字段<code>j</code>的偏移量是4，其地址是<code>r + 4</code>。第4行会计算<code>&amp;r-&gt;a[r-&gt;i + r-&gt;j]</code>。第5行会将结果移动到<code>r-&gt;p</code>。</p>
<p>　　结构体的各个字段的选取完全是在编译时处理的。汇编代码不包含任何关于字段名称或声明的信息。</p>
<h4 id="共用体">3.7.2 共用体</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　对于类型是<code>union U3 *</code>的指针<code>p</code>，<code>p-&gt;c</code>、<code>p-&gt;i[0]</code>和<code>p-&gt;v</code>引用的都是数据结构的起始地址。共用体的大小等于其<span
style="background-color: yellow">最大字段</span>的大小，所以<code>union U3</code>是8B。</p>
<p>　　在有些上下文中，共用体很有用。但是，它也能导致一些错误，因为它绕过了C的类型系统提供的安全措施。应用场景之一是事先知道数据结构中2个不同字段是互斥的，声明为共用体可以减少分配的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    N_LEAF,</span><br><span class="line">    N_INTERNAL</span><br><span class="line">&#125; <span class="type">nodetype_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">nodetype_t</span> type;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">left</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">right</span>;</span></span><br><span class="line">        &#125; internal;</span><br><span class="line">        <span class="type">double</span> data[<span class="number">2</span>];</span><br><span class="line">    &#125; info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　以二叉树为例，每个叶子节点都有2个<code>double</code>数据。每个内部节点都有指向2个子节点的指针，但没有数据。<code>type</code>是4B，<code>info.internal</code>或<code>info.data</code>是16B，加上用于数据对齐的4B，这个结构体共需24B。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">double2bits</span><span class="params">(<span class="type">double</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> u;</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.d = d;</span><br><span class="line">    <span class="keyword">return</span> temp.u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　共用体还可以用于访问不同数据类型的位模式。在这段代码中，会以某种数据类型来存储共用体中的参数，又以其他数据类型来访问，最后<code>u</code>和<code>d</code>会有相同的位模式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">uu2double</span><span class="params">(<span class="type">unsigned</span> word0, <span class="type">unsigned</span> word1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> u[<span class="number">2</span>];</span><br><span class="line">    &#125; temp;</span><br><span class="line">    temp.u[<span class="number">0</span>] = word0;</span><br><span class="line">    temp.u[<span class="number">1</span>] = word1;</span><br><span class="line">    <span class="keyword">return</span> temp.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　当通过共用体将各种不同大小的数据类型结合时，字节顺序会变得很重要。对于这段代码，在小端机器上时，<code>word0</code>是<code>d</code>的低4B，<code>word1</code>是<code>d</code>的高4B，而在大端机器上相反。</p>
<h4 id="数据对齐">3.7.3 数据对齐</h4>
<p>　　很多计算机系统都对基本数据类型的合法地址施加了限制，要求<span
style="background-color: yellow"><span
class="math inline">\(K\)</span>字节的基本对象的地址必须是<span
class="math inline">\(K\)</span>的整数倍</span>。这种对齐限制简化了在处理器和内存系统之间形成接口的硬件设计。虽然无论数据是否对齐，x86-64硬件都能正常工作。</p>
<table>
<thead>
<tr>
<th><span class="math inline">\(K\)</span></th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>char</code></td>
</tr>
<tr>
<td>2</td>
<td><code>short</code></td>
</tr>
<tr>
<td>4</td>
<td><code>int</code>，<code>float</code></td>
</tr>
<tr>
<td>8</td>
<td><code>long</code>，<code>double</code>，<code>char *</code></td>
</tr>
</tbody>
</table>
<p>　　编译器会在汇编代码中加入用于指明数据对齐要求的汇编指示，例如，<code>.align 8</code>表示之后的数据的起始地址都是8的整数倍。</p>
<p>　　对于结构体，编译器可能需要在字段的分配中插入间隙来保证每个元素都满足其对齐要求，而结构本身也有对齐要求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/structure_s1_and_s2.svg" class="">
<p>　　编译器在结构体<code>S1</code>和<code>S2</code>中都插入了3B的间隙来保证每个元素以及结构体的对齐。</p>
<p>　　对于大多数x86-64指令，数据对齐只会提升效率，并不会影响程序的行为。但是，当数据没有对齐时，某些型号的Intel和AMD处理器将无法正确执行部分用于实现多媒体操作的SSE指令，这些指令会对16B数据块进行操作。在SSE单元和内存之间移动数据的指令要求内存地址必须是16的整数倍，不满足此要求会导致异常
(默认是程序终止)。因此，编译器和运行时系统必须确保为了读写SSE寄存器而分配的内存满足16B对齐。较新版本的x86-64处理器加入了AVX多媒体指令，这类指令除了提供SSE指令的超集，还去除了对齐要求。</p>
<h3 id="在机器级程序中结合控制和数据">3.8
在机器级程序中结合控制和数据</h3>
<p>　　指针能以统一的方式对不同数据结构的元素产生引用。每个指针都对应1个类型，该类型表明该指针指向的对象。<code>int *p</code>是指向<code>int</code>的指针，<code>char **cpp</code>指向的对象是指向<code>char</code>的指针。通常，若对象类型是<code>T</code>，其指针是<code>T *</code>。特殊的<code>void *</code>表示通用指针。每个指针都有1个值，该值是某个指定类型的对象的地址。特殊的<code>NULL</code>
(0) 表示该指针没有指向任何位置。</p>
<p>　　将指针强制转换到其他类型时，仅改变其类型，不会改变其值。强制转换的效果之一是改变指针运算的伸缩。例如，若<code>p</code>是<code>char *</code>类型的指针，其值为<span
class="math inline">\(p\)</span>，则<code>(int *)p + 7</code>的结果为<span
class="math inline">\(p+28\)</span>。</p>
<p>　　指针也可以指向函数，函数指针的值是该函数机器代码表示中第1条指令的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> *p)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span> *);</span><br><span class="line">fp = fun;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> result = fp(<span class="number">3</span>, &amp;y);</span><br></pre></td></tr></table></figure>
<p>　　第1段代码是函数<code>fun()</code>的函数原型。第2段代码会先声明指针<code>fp</code>，然后将它赋值为函数<code>fun()</code>。第3段代码会用指针<code>fp</code>来调用函数<code>fun()</code>。</p>
<h4 id="gdb的使用">3.8.1 GDB的使用</h4>
<p>　　GNU的调试器GDB提供了很多有用的特性，支持机器级程序的运行时评估和分析。启动GDB的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb prog</span></span><br></pre></td></tr></table></figure>
<p>　　GDB的常规使用方法是在程序中有需要的地方设置断点，断点可以设置在函数入口后或某个地址处。程序在执行时，遇到断点会停止并将控制权返回给用户。在断点处，可以以各种方式查看各个寄存器和内存位置，也可以单步追踪程序，还可以1次仅执行几条指令或前进到下一断点。</p>
<table>
<colgroup>
<col style="width: 47%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>quit</code></td>
<td>退出GDB</td>
</tr>
<tr>
<td><code>run</code></td>
<td>运行程序 (在此给出命令行选项)</td>
</tr>
<tr>
<td><code>kill</code></td>
<td>停止程序</td>
</tr>
<tr>
<td><code>break multstore</code></td>
<td>在函数<code>multstore()</code>入口处设置断点</td>
</tr>
<tr>
<td><code>break *0400540</code></td>
<td>在地址<code>0x0400540</code>处设置断点</td>
</tr>
<tr>
<td><code>delete 1</code></td>
<td>删除断点1</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>删除所有断点</td>
</tr>
<tr>
<td><code>stepi</code></td>
<td>执行1条指令</td>
</tr>
<tr>
<td><code>stepi 4</code></td>
<td>执行4条指令</td>
</tr>
<tr>
<td><code>nexti</code></td>
<td>类似于<code>stepi</code>，但以函数调用为单位</td>
</tr>
<tr>
<td><code>continue</code></td>
<td>继续执行</td>
</tr>
<tr>
<td><code>finish</code></td>
<td>运行到当前函数返回</td>
</tr>
<tr>
<td><code>disas</code></td>
<td>反汇编当前函数</td>
</tr>
<tr>
<td><code>disas multstore</code></td>
<td>反汇编函数<code>multstore()</code></td>
</tr>
<tr>
<td><code>disas 0x400544</code></td>
<td>反汇编地址位于<code>0x0400540</code>附近的函数</td>
</tr>
<tr>
<td><code>disas 0x400540, 0x40054d</code></td>
<td>反汇编地址在指定范围内的代码</td>
</tr>
<tr>
<td><code>print /x $rip</code></td>
<td>以十六进制输出PC的值</td>
</tr>
<tr>
<td><code>print $rax</code></td>
<td>以十进制输出寄存器<code>%rax</code>的值</td>
</tr>
<tr>
<td><code>print /x $rax</code></td>
<td>以十六进制输出寄存器<code>%rax</code>的值</td>
</tr>
<tr>
<td><code>print /t $rax</code></td>
<td>以二进制输出寄存器<code>%rax</code>的值</td>
</tr>
<tr>
<td><code>print 0x100</code></td>
<td>输出<code>0x100</code>的十进制表示</td>
</tr>
<tr>
<td><code>print /x 555</code></td>
<td>输出555的十六进制表示</td>
</tr>
<tr>
<td><code>print /x ($rsp+8)</code></td>
<td>以十六进制输出栈指针加8的内容</td>
</tr>
<tr>
<td><code>print *(long *) 0x7fffffffe818</code></td>
<td>输出地址是<code>0x7fffffffe818</code>的长整数</td>
</tr>
<tr>
<td><code>print *(long *) ($rsp + 8)</code></td>
<td>输出地址是栈指针加8的长整数</td>
</tr>
<tr>
<td><code>x/2g 0x7fffffffe818</code></td>
<td>检查地址始于<code>0x7fffffffe818</code>的双字</td>
</tr>
<tr>
<td><code>x/20b multstore</code></td>
<td>检查函数<code>multstore()</code>的前20B</td>
</tr>
<tr>
<td><code>info frame</code></td>
<td>当前栈帧的相关信息</td>
</tr>
<tr>
<td><code>info registers</code></td>
<td>所有寄存器的值</td>
</tr>
<tr>
<td><code>help</code></td>
<td>GDB的相关信息</td>
</tr>
</tbody>
</table>
<p>　　除了使用命令行接口来访问GDB，DDD也是选择之一，它是GDB的扩展，提供了图像用户界面。</p>
<h4 id="内存越界引用和缓存溢出">3.8.2 内存越界引用和缓存溢出</h4>
<p>　　C不会对数组引用进行边界检查，而且局部变量和状态信息都存储在栈中，这2种情况结合起来就能导致严重的程序错误。对越界的数组元素的写操作会损坏存储在栈中的状态信息，当程序使用这个已损坏的状态信息来重新加载寄存器或执行指令<code>ret</code>时，会导致严重的错误。</p>
<p>　　<strong>缓存溢出</strong>是常见的状态损坏之一，即在栈中分配字符数组来保存字符串时，字符串的长度超过了为数组分配的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> *dest = s;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        *dest++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　库函数<code>gets()</code>会从标准输入读取1行
(遇到<code>\n</code>或错误时停止)，然后将这个字符串复制到参数<code>s</code>指向的位置并在字符串结尾加上<code>\0</code>。函数<code>echo()</code>会从标准输入读取1行并回显到标准输出。由于<code>buf</code>仅有8B，任何超过7B的字符串都会导致越界。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo:</span><br><span class="line">	subq	$24, %rsp</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	call	gets</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	call	puts</span><br><span class="line">	addq	$24, %rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/stack_organization_for_function_echo.svg" class="">
<p>　　在函数<code>echo()</code>的汇编代码中，会先把栈指针减24
(第2行)。栈指针 (即<code>buf</code>)
会被复制到<code>%rdi</code>作为调用<code>gets()</code>和<code>puts()</code>的参数。<code>buf</code>和返回地址之间的16B是未使用的。用户输入的字符不超过7个时，函数<code>gets()</code>返回的字符串能放入<code>buf</code>分配的空间中。输入的字符不超过23个时，不会有严重的后果，但超过后会损坏存储在返回地址的值，导致指令<code>ret</code>
(第8行) 会跳转意想不到的位置。</p>
<p>　　在函数<code>echo()</code>中，更好的选择使用函数<code>fgets()</code>，它包括1个参数来限制待读入的最大字节数。使用<code>gets()</code>或其他任何能导致溢出的函数通常都是不好的编程习惯，但很多常用的库函数
(包括<code>strcpy()</code>、<code>strcat()</code>和<code>sprintf()</code>)
都不需要指定目标缓存的大小。</p>
<p>　　缓存溢出可用于让程序执行它本来不会执行的函数，这是常见的攻击方式之一。例如，给程序输入某个字符串，该字符串包含一些可执行代码的字节编码
(称为<strong>攻击代码</strong>)
和一些字节，这些字节能让指向攻击代码的指针覆盖返回地址，因此，执行指令<code>ret</code>会跳转到攻击代码。在某种攻击形式中，攻击代码会使用系统调用启动1个shell程序，给攻击者提供1组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的损坏，然后再次执行指令<code>ret</code>，(表面上)
正常返回给调用者。</p>
<h4 id="对抗缓存溢出攻击">3.8.3 对抗缓存溢出攻击</h4>
<p>　　在系统中插入攻击代码时，既要插入代码，也要插入指向这段代码的指针，该指针也是攻击字符串的一部分，生成该指针需要知道这个字符串的栈地址。过去，程序的栈地址很容易预测。对于所有运行相同程序和操作系统版本组合的机器，栈位置是固定的。以传染病类比，许多系统都容易受到同一种病毒的攻击，这种现象称为<strong>安全单一化</strong>。</p>
<p>　　栈随机化的思想是使得栈的位置在程序每次运行时都有变化。实现方式是程序开始时，在栈上分配0~<span
class="math inline">\(n\)</span>字节的随机大小的空间来了让后续栈的地址变化
(程序不会使用它)。<span
class="math inline">\(n\)</span>需要足够大，才能保证栈地址的变化范围足够大，但又需要足够小，不至于浪费太多的空间。</p>
<p>　　在Linux中，栈随机化已经成为标准，它是<strong>地址空间布局随机化</strong>
(ASLR) 技术之一。当使用ASLR后，每次运行时程序的不同部分
(包括程序代码、库代码、栈、全局变量和堆数据)
都会加载到内存不同的区域。然而，可以通过暴力手段来克服随机化，常见方法之一是在实际的攻击代码前插入1段很长的<span
style="background-color: yellow">空操作</span>，执行这种指令除了使PC加1，没有其他效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列到达攻击代码，称为<span
style="background-color: yellow">空操作雪橇</span>。栈随机化和其他一些ASLR技术能够增加攻击难度，但并不能完全防御。</p>
<p>　　第2道防线是<strong>栈损坏检查</strong>。较新版本的gcc加入了<strong>栈保护者</strong>机制，其思想是在所有局部缓存和栈状态之间加入<span
style="background-color: yellow">金丝雀值</span> (也称为<span
style="background-color: yellow">哨兵值</span>)，该值每次运行时随机。在恢复寄存器状态和返回前，程序会检查金丝雀值是否改变，若改变，则程序异常终止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo:</span><br><span class="line">	subq	$24, %rsp</span><br><span class="line">	movq	%fs:40, %rax</span><br><span class="line">	movq	%rax, 8(%rsp)</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	movq	%rax, 8(%rsp)</span><br><span class="line">	call	gets</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	call	puts</span><br><span class="line">	movq	8(%rsp), %rax</span><br><span class="line">	xorq	%fs:40, %rax</span><br><span class="line">	je		.L2</span><br><span class="line">	call	__stack_chk_fail</span><br><span class="line">.L2:</span><br><span class="line">	addq	$24, %rsp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/stack_organization_for_function_echo_with_stack_protector_enabled.svg" class="">
<p>　　栈溢出示例的代码使用了命令行选项<code>-fno-stack-protector</code>，这段代码没有使用该命令行选项。这个版本的函数会在内存中读取1个值
(第3行)，再把它放到存储到相对栈指针偏移量为8的位置。指令操作数<code>%fs:40</code>表示金丝雀值是通过<span
style="background-color: yellow">段寻址</span>从内存中读取的。将金丝雀值存储在特殊的段并标记为只读，这样攻击者就不能覆盖。在恢复寄存器状态和返回前，函数会将存储在栈位置的值和金丝雀值比较
(第11行)。若相等，指令<code>xorq</code>会得到0，函数会正常执行；否则，将会调用错误处理例程。</p>
<p>　　栈保护者能防止缓存溢出攻击损坏存储在程序栈上的状态。它只会带来很小的性能损失，gcc只在函数中有局部<code>char</code>类型缓存时，才会插入这样的代码。</p>
<p>　　第3段防线是消除攻击者向系统中插入可执行代码的能力。方法之一是限制存储可执行代码的内存区域。在常规程序中，只有用于存储编译器生成的代码的内存区域才需要是可执行的，其他部分可以被限制为只读和写。虚拟内存空间在逻辑上划分为<span
style="background-color: yellow">页</span>，每页通常是2048或4096B。硬件支持多种形式的内存保护，指示用户程序和操作系统内核允许的访问形式。很多系统允许控制3种访问形式：读
(从内存读取)、写 (写入到内存) 和执行 (将内存的内容视为机器级代码)。</p>
<p>　　过去，x86-64体系架构将读和执行访问控制位作为1个1位的标志位，所以任何被标记位可读的页也是可执行的。栈必须是既可读又可写，所以栈的数据也是可执行的。有很多已经实现的机制可以让页可读的同时不可执行，但这种机制通常会带来严重的性能损失。后来，AMD为其64位处理器的内存保加入了<span
style="background-color: yellow">不执行</span>位，将读和执行访问模式分开，Intel也跟进了该特性。有了该特性后，实现页可读的同时不可执行就不再有性能损失。</p>
<p>　　有些类型的程序要求动态生成和执行代码的能力，例如，<span
style="background-color: yellow">即时</span>编译技术动态地为解释型语言
(例如，Java) 编写的程序生成代码来提供程序性能。</p>
<h4 id="变长栈帧">3.8.4 变长栈帧</h4>
<p>　　有些函数需要的局部存储是变长的，例如，声明局部变长数组或调用标准库函数<code>alloca()</code>
(该函数类似函数<code>malloc()</code>，但该函数在运行时栈上分配空间，并且分配的空间会在返回时自动释放)。为了管理变长栈帧，x86-64使用寄存器<code>%rbp</code>作为<strong>帧指针</strong>，也称为<strong>基指针</strong>。帧指针是被调用者保存寄存器，所以需要先将其值保存在栈中并让帧指针指向该位置，在之后函数的整个执行过程中帧指针将一直指向该位置。对于固定长度的局部变量
(通常保存在与帧指针相邻且更靠近栈顶的位置)，可以通过其相对帧指针的偏移量来引用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">vframe</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> idx, <span class="type">long</span> *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> *p[n];</span><br><span class="line">    p[<span class="number">0</span>] = &amp;i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *p[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vframe:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	leaq	22(,%rdi,8), %rax</span><br><span class="line">	andq	$-16, %rax</span><br><span class="line">	subq	%rax, %rsp</span><br><span class="line">	leaq	7(%rsp), %rax</span><br><span class="line">	shrq	$3, %rax</span><br><span class="line">	leaq	0(,%rax,8), %r8</span><br><span class="line">	movq	%r8, %rcx</span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line">.L3:</span><br><span class="line">	movq	%rdx, (%rcx,%rax,8)</span><br><span class="line">	addq	$1, %rax</span><br><span class="line">	movq	%rax, -8(%rbp)</span><br><span class="line">.L2:</span><br><span class="line">	movq	-8(%rbp), %rax</span><br><span class="line">	cmpq	%rdi, %rax</span><br><span class="line">	jl	.L3</span><br><span class="line"># ...</span><br><span class="line">	</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/stack_frame_for_function_vframe.svg" class="">
<p>　　第1段代码是包含变长数组的示例的C代码，第2段代码是gcc生成的汇编代码
(节选了部分)。第1段代码中，函数声明了包含<span
class="math inline">\(n\)</span>个指针的局部数组<code>p</code>，<span
class="math inline">\(n\)</span>由第1个参数给出，每次调用都可能不同，编译器无法确定该分配给该函数的栈帧空间。此外，该函数还有1个对局部变量<code>i</code>的地址引用，所以该变量必须存储在栈中。在执行该函数时，必须能够访问局部变量<code>i</code>和数组<code>p</code>中的元素。返回时，该函数必须释放该栈帧，并让栈指针指向返回地址。</p>
<p>　　第2段代码中，会先把帧指针的值压入栈并让帧指针指向栈顶
(第2~3行)。然后，在栈上分配16B，其中前8B存储局部变量<code>i</code>，而后8B未使用。接着，为数组<code>p</code>分配空间
(第5~11行)，<span
class="math inline">\(s_1\)</span>是第4行代码执行后栈指针的值，<span
class="math inline">\(s_2\)</span>是第7行代码执行后栈指针的值，<span
class="math inline">\(p\)</span>是第10~11行中赋值给寄存器<code>%r8</code>和<code>%rcx</code>的值，用于引用数组<code>p</code>。第5行会通过指令<code>leaq</code>计算<span
class="math inline">\(8n+22\)</span>，第6行会通过指令<code>andq</code>将结果向下舍入到最接近的16的整数倍，<span
class="math inline">\(s_2\)</span>等于<span
class="math inline">\(s_1\)</span>减该值。第8~10行会将<span
class="math inline">\(s_2\)</span>向上舍入到最接近的8的整数倍。<span
class="math inline">\(p\)</span>是8的整数倍，<span
class="math inline">\(s_1\)</span>与<span
class="math inline">\(s_2\)</span>的差值是16的整数倍，而可能存在的空间<span
class="math inline">\(e_1\)</span>和<span
class="math inline">\(e_2\)</span>正是为了保证这一点。变量<code>i</code>的地址是<code>-8(%rbp)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movq	%rbp, %rsp</span><br><span class="line">popq	%rbp</span><br></pre></td></tr></table></figure>
<p>　　指令<code>leave</code>用于释放栈帧，等同于这2条指令，即先将栈指针设置为保存帧指针值的位置并将弹出帧指针。</p>
<p>　　在较早的x86-64代码中，每个函数调用都会使用帧指针。后来，只有栈帧长度可变的情况才使用。过去，大多数编译器在生成IA32代码时会使用帧指针，较新版本的gcc放弃了这一惯例。</p>
<h3 id="浮点代码">3.9 浮点代码</h3>
<p>　　由于1997年推出的Pentium/MMX，Intel和AMD都推出了持续数代的用于支持图形和图像处理的媒体指令。这些指令本意是允许多个操作以并行模式执行
(即<strong>单指令多数据</strong>)。在这种模式中，对多个不同数据并行执行同一操作。后来，经过长足的发展，名称也发生了变化，从MMX到SSE再到AVX。每一代中，都有一些不同的版本。这些版本都会管理寄存器组的数据，这些寄存器在MMX中称为MM寄存器，SSE中称为XMM寄存器，AVX中称为YMN寄存器。MM寄存器是64位，XMM寄存器是128位，YMM寄存器是256位。因此，每个YMM寄存器可以存储8个32位值或4个64位值，这些值可以是整数或浮点数。</p>
<p>　　2000年推出的Pentium
4中使用了SSE2，至此，媒体指令开始包括通过XMM和YMM寄存器的低32位或64位中的单个值操作标量浮点数据的指令。这个标量模式提供了1组寄存器和指令，它们更类似于其他处理器支持浮点数的方式。所有能够执行x86-64代码的处理器都支持SSE2或更高的版本，因此，x86-64浮点数是基于SSE或AVX的，包括传递过程参数和返回值的规则。</p>
<p>　　这里的内容基于AVX2，即AVX的第2个版本，在2013年Core i7
Haswell处理器中使用。当给定<code>-mavx2</code>命令行选项时，gcc会生成AVX2代码。基于不同版本的SSE以及第1个版本的AVX的代码从概念上类似，不过指令名和格式有所不同。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_03/media_registers.svg" class="">
<p>　　AVX浮点体系架构允许数据存储在16个YMM寄存器，它们的名称为<code>%ymm0</code>~<code>%ymm15</code>。每个YMM寄存器都是256位。当对标量数据操作时，这些寄存器仅保存浮点数，而且只使用低32
(对于<code>float</code>) 或64位
(对于<code>double</code>)。汇编代码用寄存器的SSE
XMM寄存器名称<code>%xmm0</code>~<code>%xmm15</code>来引用它们，每个XMM寄存器都是对应的YMM寄存器的低128位。</p>
<p>　　寄存器<code>%xmm0</code>~<code>%xmm7</code>用于传递浮点参数，按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。寄存器<code>%xmm0</code>还用于返回浮点值。所有的XMM寄存器都是调用者保存，被调用者可以不用保存就覆盖这些寄存器。</p>
<p>　　当函数参数包含指针、整数和浮点数时，指针和整数通过整数寄存器传递，浮点数通过XMM寄存器传递，寄存器的分配取决于参数的类型和排列顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y, <span class="type">long</span> z)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">double</span> y, <span class="type">int</span> x, <span class="type">long</span> z)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">f3</span><span class="params">(<span class="type">float</span> x, <span class="type">double</span> *y, <span class="type">double</span> *z)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>f1()</code>的参数<code>x</code>、<code>y</code>和<code>z</code>分别存储在寄存器<code>%edi</code>、<code>%xmm0</code>和<code>%rsi</code>，函数<code>f2()</code>和函数<code>f1()</code>的寄存器分配相同。函数<code>f3()</code>的参数<code>x</code>、<code>y</code>和<code>z</code>分别存储在寄存器<code>%xmm0</code>、<code>%rdi</code>和<code>%rsi</code>。</p>
<h4 id="浮点移动和转换操作">3.9.1 浮点移动和转换操作</h4>
<table>
<thead>
<tr>
<th>指令</th>
<th>源</th>
<th>目的</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vmovss</code></td>
<td><span class="math inline">\(M_{32}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>移动单精度数</td>
</tr>
<tr>
<td><code>vmovss</code></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(M_{32}\)</span></td>
<td>移动单精度数</td>
</tr>
<tr>
<td><code>vmovsd</code></td>
<td><span class="math inline">\(M_{64}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>移动双精度数</td>
</tr>
<tr>
<td><code>vmovsd</code></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(M_{64}\)</span></td>
<td>移动双精度数</td>
</tr>
<tr>
<td><code>vmovaps</code></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>移动对齐且已封装的单精度数</td>
</tr>
<tr>
<td><code>vmovapd</code></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>移动对齐且已封装的双精度数</td>
</tr>
</tbody>
</table>
<p>　　引用内存的指令是<span
style="background-color: yellow">标量</span>指令，表示其操作数是单个值而非封装后的值。数据要么保存在内存中
(在表中用<span class="math inline">\(M_{32}\)</span>和<span
class="math inline">\(M_{64}\)</span>表示)，要么保存在XMM寄存器中
(在表中用<span
class="math inline">\(X\)</span>表示)。无论数据是否对齐，这些指令都能正确执行，不过代码优化规则建议32位内存满足4B对齐，64位数据满足8B对齐。内存引用的指定方式与整数数据移动指令相同，包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能的组合。</p>
<p>　　gcc只用标量移动操作从内存移动数据到XMM寄存器或从XMM寄存器移动数据到内存。对于在2个XMM寄存器之间移动数据，gcc会使用指令<code>vmovaps</code>和<code>vmovapd</code>，程序复制整个寄存器还是只复制低位并不会影响程序功能，也不会影响执行速度，所以使用这些指令还是针对标量数据的指令并没有实质上的差别。指令名称中<code>a</code>表示对齐，当用于读写内存时，若地址不满足16B对齐，则会导致异常。</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 11%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>源</th>
<th>目的</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vcvttss2si</code></td>
<td><span class="math inline">\(X/M_{32}\)</span></td>
<td><span class="math inline">\(R_{32}\)</span></td>
<td>用截断的方法将单精度数转换成整数</td>
</tr>
<tr>
<td><code>vcvttsd2si</code></td>
<td><span class="math inline">\(X/M_{64}\)</span></td>
<td><span class="math inline">\(R_{32}\)</span></td>
<td>用截断的方法将双精度数转换成整数</td>
</tr>
<tr>
<td><code>vcvttss2siq</code></td>
<td><span class="math inline">\(X/M_{32}\)</span></td>
<td><span class="math inline">\(R_{64}\)</span></td>
<td>用截断的方法将单精度数转换成四字整数</td>
</tr>
<tr>
<td><code>vcvttsd2siq</code></td>
<td><span class="math inline">\(X/M_{64}\)</span></td>
<td><span class="math inline">\(R_{64}\)</span></td>
<td>用截断的方法将双精度数转换成四字整数</td>
</tr>
</tbody>
</table>
<p>　　浮点数转换整数指令有2个操作数，这类指令会把1个从XMM寄存器或内存中读出的浮点数进行<strong>截断</strong>，即向零舍入，然后将结果存入整数寄存器
(在表中用<span class="math inline">\(R_{32}\)</span>和<span
class="math inline">\(R_{64}\)</span>表示)。</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 25%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>源1</th>
<th>源2</th>
<th>目的</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vcvtsi2ss</code></td>
<td><span class="math inline">\(M_{32}/R_{32}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>将整数转换成单精度数</td>
</tr>
<tr>
<td><code>vcvtsi2sd</code></td>
<td><span class="math inline">\(M_{32}/R_{32}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>将整数转换成双精度数</td>
</tr>
<tr>
<td><code>vcvtsi2ssq</code></td>
<td><span class="math inline">\(M_{64}/R_{64}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>将四字整数转换成单精度数</td>
</tr>
<tr>
<td><code>vcvtsi2sdq</code></td>
<td><span class="math inline">\(M_{64}/R_{64}\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td><span class="math inline">\(X\)</span></td>
<td>将四字整数转换成双精度数</td>
</tr>
</tbody>
</table>
<p>　　整数转换浮点数指令有3个操作数
(2个源和1个目的)，第1个操作数来自内存或整数寄存器，第2个操作数仅影响结果的高位，第3个操作数必须是XMM寄存器。在常见的使用场景中，第2个操作数和第3个操作数相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vunpcklps	%xmm0, %xmm0, %xmm0</span><br><span class="line">vcvtps2pd	%xmm0, %xmm0</span><br></pre></td></tr></table></figure>
<p>　　这2条指令会将单精度数转换为双精度数。指令<code>vunpckls</code>会交叉前2个寄存器的值并将结果放到第3个寄存器，若第1个寄存器的内容为字<span
class="math inline">\([s_3,s_2,s_1,s_0]\)</span>，第2个寄存器的内容是字<span
class="math inline">\([d_3,d_2,d_1,d_0]\)</span>，则第3个寄存器的内容是字<span
class="math inline">\([s_1,d_1,s_0,d_0]\)</span>。指令<code>vcvtps2pd</code>会把第1个寄存器中的2个低位单精度值扩展成第2个寄存器的2个双精度值，得到结果<span
class="math inline">\([dx_0,dx_0]\)</span>，而<span
class="math inline">\(dx_0\)</span>就是转换后的双精度数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmovddup	%xmm0, %xmm0</span><br><span class="line">vcvtpd2psx	%xmm0, %xmm0</span><br></pre></td></tr></table></figure>
<p>　　这2条指令会将双精度数转换为单精度数。若寄存器<code>%xmm0</code>保存着双精度值<span
class="math inline">\([x_1,x_0]\)</span>，指令<code>vmovddup</code>会将它设置为<span
class="math inline">\([x_0,x_0]\)</span>，指令<code>vcvtpd2psx</code>会把这2个值转换为单精度数，再打包到寄存器的低位一半，并将高位一半置0，得到结果<span
class="math inline">\([0.0,0.0,x_0,x_0]\)</span>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">fcvt</span><span class="params">(<span class="type">int</span> i, <span class="type">float</span> *fp, <span class="type">double</span> *dp, <span class="type">long</span> *lp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f = *fp;</span><br><span class="line">    <span class="type">double</span> d = *dp;</span><br><span class="line">    <span class="type">long</span> l = *lp;</span><br><span class="line">    *lp = (<span class="type">long</span>)d;</span><br><span class="line">    *fp = (<span class="type">float</span>)i;</span><br><span class="line">    *dp = (<span class="type">double</span>)l;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fcvt:</span><br><span class="line">	vmovss	(%rsi), %xmm0</span><br><span class="line">	movq	(%rcx), %rax</span><br><span class="line">	vcvttsd2siq	(%rdx), %r8</span><br><span class="line">	movq	%r8, (%rcx)</span><br><span class="line">	vcvtsi2ss	%edi, %xmm1, %xmm1</span><br><span class="line">	vmovss	%xmm1, (%rsi)</span><br><span class="line">	vcvtsi2sdq	%rax, %xmm1, %xmm1</span><br><span class="line">	vmovsd	%xmm1, (%rdx)</span><br><span class="line">	vunpcklps	%xmm0, %xmm0, %xmm0</span><br><span class="line">	vcvtps2pd	%xmm0, %xmm0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　函数<code>fvct()</code>的所有参数都是通过整数寄存器传递，结果通过寄存器<code>%xmm0</code>返回。</p>
<h4 id="浮点运算操作">3.9.2 浮点运算操作</h4>
<table>
<thead>
<tr>
<th>单精度数指令</th>
<th>双精度数指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vaddss</code></td>
<td><code>vaddsd</code></td>
<td><code>D</code> ← <code>S2 + S1</code></td>
<td>浮点加法</td>
</tr>
<tr>
<td><code>vsubss</code></td>
<td><code>vsubsd</code></td>
<td><code>D</code> ← <code>S2 - S1</code></td>
<td>浮点减法</td>
</tr>
<tr>
<td><code>vmulss</code></td>
<td><code>vmulsd</code></td>
<td><code>D</code> ← <code>S2 * S1</code></td>
<td>浮点乘法</td>
</tr>
<tr>
<td><code>vdivss</code></td>
<td><code>vdivsd</code></td>
<td><code>D</code> ← <code>S2 / S1</code></td>
<td>浮点除法</td>
</tr>
<tr>
<td><code>vmaxss</code></td>
<td><code>vmaxsd</code></td>
<td><code>D</code> ← <code>max(S2, S1)</code></td>
<td>浮点最大值</td>
</tr>
<tr>
<td><code>vminss</code></td>
<td><code>vminsd</code></td>
<td><code>D</code> ← <code>min(S2, S1)</code></td>
<td>浮点最小值</td>
</tr>
<tr>
<td><code>sqrtss</code></td>
<td><code>sqrtsd</code></td>
<td><code>D</code> ← <code>sqrt(S1)</code></td>
<td>浮点数平方根</td>
</tr>
</tbody>
</table>
<p>　　对于浮点运算指令，每条指令都有1或2个源操作数以及1个目的操作数。第1个源操作数<code>S1</code>可以是XMM寄存器或内存引用，第2个源操作数<code>S2</code>和目的操作数必须是XMM寄存器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">funct</span><span class="params">(<span class="type">double</span> a, <span class="type">float</span> x, <span class="type">double</span> b, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a * x - b / i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">funct:</span><br><span class="line">	vunpcklps	%xmm1, %xmm1, %xmm1</span><br><span class="line">	vcvtps2pd	%xmm1, %xmm1</span><br><span class="line">	vmulsd	%xmm0, %xmm1, %xmm0</span><br><span class="line">	vcvtsi2sd	%edi, %xmm1, %xmm1</span><br><span class="line">	vdivsd	%xmm1, %xmm2, %xmm2</span><br><span class="line">	vsubsd	%xmm2, %xmm0, %xmm0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　函数<code>funct()</code>的参数<code>a</code>、<code>x</code>和<code>b</code>通过寄存器<code>%xmm0</code>~<code>%xmm2</code>传递，参数<code>i</code>通过寄存器<code>%edi</code>传递。第2~3行会将参数<code>x</code>转换为双精度数，第5行会将参数<code>i</code>转换为双精度数，最后结果通过寄存器<code>%xmm0</code>返回。</p>
<h4 id="浮点常数">3.9.3 浮点常数</h4>
<p>　　AVX浮点操作不能将立即数作为操作数。相反，编译器必须为所有的常量值分配并初始化空间。然后，从内存读取这些值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">cel2fahr</span><span class="params">(<span class="type">double</span> temp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.8</span> * temp + <span class="number">32.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cel2fahr:</span><br><span class="line">	vmulsd	.LC0(%rip), %xmm0, %xmm0</span><br><span class="line">	vaddsd	.LC1(%rip), %xmm0, %xmm0</span><br><span class="line">	ret</span><br><span class="line">.LC0:</span><br><span class="line">	.long	3435973837</span><br><span class="line">	.long	1073532108</span><br><span class="line">.LC1:</span><br><span class="line">	.long	0</span><br><span class="line">	.long	1077936128</span><br></pre></td></tr></table></figure>
<p>　　函数<code>cel2fahr()</code>从标签<code>.LC0</code>处读取值1.8，从标签<code>.LC1</code>处读取值32.0，这些标签里都是一对<code>.long</code>声明和十进制表示的值。对于标签<code>.LC0</code>，这2个值的十六进制是<code>0xcccccccd</code>和<code>0x3ffccccc</code>，因为机器是小端模式，第1个值给出低4B，第2个值给出高4B。从高位字节提取指数字段<code>0x3ff</code>，减去偏移值1023得到指数0。将2个值的小数位组合起来，得到小数字段<code>0xccccccccccccd</code>，二进制小数表示为0.8，加上隐含的1得到1.8。</p>
<h4 id="浮点位级操作和比较操作">3.9.4 浮点位级操作和比较操作</h4>
<table>
<thead>
<tr>
<th>单精度数指令</th>
<th>双精度数指令</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vxorps</code></td>
<td><code>vxorpd</code></td>
<td><code>D</code> ← <code>S2 ^ S1</code></td>
<td>位级异或</td>
</tr>
<tr>
<td><code>vandps</code></td>
<td><code>vandpd</code></td>
<td><code>D</code> ← <code>S2 &amp; S1</code></td>
<td>位级与</td>
</tr>
</tbody>
</table>
<p>　　浮点位级指令类似于整数位级指令在整数寄存器上的操作，这类指令作用于封装后的数据，即更新整个目的XMM寄存器，对2个源寄存器的所有位都执行指定的位级操作。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>基于</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ucomiss  S1, S2</code></td>
<td><code>S2 - S1</code></td>
<td>比较单精度数</td>
</tr>
<tr>
<td><code>ucomissd  S1, S2</code></td>
<td><code>S2 - S1</code></td>
<td>比较双精度数</td>
</tr>
</tbody>
</table>
<p>　　浮点比较指令类似于整数比较指令，这类指令会比较操作数并设置条件码来表示它们的相对值。第1个参数可以是XMM寄存器或内存引用，第2个参数只能是XMM寄存器。</p>
<table>
<thead>
<tr>
<th>顺序为<code>S2 : S1</code></th>
<th>CF</th>
<th>ZF</th>
<th>PF</th>
</tr>
</thead>
<tbody>
<tr>
<td>无序</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>S2 &lt; S1</code></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><code>S2 = S1</code></td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><code>S2 &gt; S1</code></td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>　　浮点比较指令会设置CF、ZF和PF。对于整数操作，当最近的算术或逻辑运算生成的值的最低位所在的字节满足偶校验时
(该字节中有偶数个1)，会将PF置1。对于浮点比较，当操作数中有NaN时，会出现<span
style="background-color: yellow">无序</span>的情况，然后将PF置1。指令<code>jp</code>
(jump on parity)
通常用于条件跳转，条件就是浮点比较结果为无序，除了这种情况，其他情况下，CF和ZF的值都与对应的无符号比较情况相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NEG,</span><br><span class="line">    ZERO,</span><br><span class="line">    POS,</span><br><span class="line">    OTHER</span><br><span class="line">&#125; <span class="type">range_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">range_t</span> <span class="title function_">find_range</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = NEG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = ZERO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = POS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = OTHER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_range:</span><br><span class="line">	vxorps	%xmm1, %xmm1, %xmm1</span><br><span class="line">	vucomiss	%xmm0, %xmm1</span><br><span class="line">	ja	.L5</span><br><span class="line">	vucomiss	%xmm1, %xmm0</span><br><span class="line">	jp	.L8</span><br><span class="line">	movl	$1, %eax</span><br><span class="line">	je	.L3</span><br><span class="line">.L8:</span><br><span class="line">	vucomiss	.LCO(%rip), %xmm0</span><br><span class="line">	setbe	%al</span><br><span class="line">	movzbl	%al, %eax</span><br><span class="line">	addl	$2, %eax</span><br><span class="line">	ret</span><br><span class="line">.L5:</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">.L3:</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>　　在函数<code>find_range()</code>的汇编代码中，会将<code>x</code>和<code>0.0</code>比较3次，即使1次就能获得所需信息。它还生成了2次浮点常数<code>0.0</code>，1次用于指令<code>vxorps</code>，1次从内存读取该值。</p>
<p>　　●
当<code>x &lt; 0.0</code>时，第4行的指令<code>ja</code>会选择跳转到结尾，返回值为<code>NEG</code>
(0)。</p>
<p>　　●
当<code>x = 0.0</code>时，第4行的指令<code>ja</code>和第6行的指令<code>jp</code>都不会跳转，第8行的指令<code>je</code>会跳转，返回<code>ZERO</code>
(1)。</p>
<p>　　●
当<code>x &gt; 0.0</code>时，这3个跳转指令都不会跳转。第11行的指令<code>setbe</code>会得到0，然后，第13行的指令<code>addl</code>会加2，返回<code>POS</code>
(2)。</p>
<p>　　●
当<code>x = NaN</code>时，第6行的指令<code>jp</code>会跳转，第10行的指令<code>vucomiss</code>会设置CF和ZF，所以第11行的指令<code>setbe</code>得到1，然后，第13行的指令<code>addl</code>会加2，返回值为<code>OTHER</code>
(3)。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第6章 存储器层次结构</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_06/</url>
    <content><![CDATA[<p>　　计算机的成功很大程度上源于存储技术的进步。早期的计算机只有几千字节的随机访问存储器。最早的IBM
PC没有磁盘，1982年推出的IBM
PC-XT才有10MB的磁盘。到2015年，常规计算机的磁盘容量是IBM
PC-XT的30万倍，而且磁盘容量以每2年加倍的速度增长。</p>
<p>　　存储器层次结构的本质是上一级存储器作为下一级存储器的缓存。每1级都需要管理逻辑，包括划分缓存、在不同层级之间传输块和判断是否命中及后续处理。管理逻辑可以是硬件、软件或两者的结合。大多数情况下，缓存都是自动运行的，无需程序具体或显式的操作。</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>存储器类型</th>
<th>存储内容</th>
<th>位置</th>
<th>延迟 (时钟周期数)</th>
<th>管理者</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU寄存器</td>
<td>4B或8B的字</td>
<td>芯片上的CPU寄存器</td>
<td>0</td>
<td>编译器</td>
</tr>
<tr>
<td>TLB</td>
<td>地址转换</td>
<td>芯片上的TLB</td>
<td>0</td>
<td>存储管理单元 (MMU)</td>
</tr>
<tr>
<td>L1缓存</td>
<td>64B块</td>
<td>芯片上的L1缓存</td>
<td>4</td>
<td>硬件</td>
</tr>
<tr>
<td>L2缓存</td>
<td>64B块</td>
<td>芯片上的L2缓存</td>
<td>10</td>
<td>硬件</td>
</tr>
<tr>
<td>L3缓存</td>
<td>64B块</td>
<td>芯片上的L3缓存</td>
<td>50</td>
<td>硬件</td>
</tr>
<tr>
<td>虚拟内存</td>
<td>4KB页</td>
<td>内存</td>
<td>200</td>
<td>硬件和OS</td>
</tr>
<tr>
<td>缓冲区缓存</td>
<td>部分文件</td>
<td>内存</td>
<td>200</td>
<td>OS</td>
</tr>
<tr>
<td>磁盘缓存</td>
<td>磁盘扇区</td>
<td>磁盘控制器</td>
<td>100000</td>
<td>控制器硬件</td>
</tr>
<tr>
<td>网络缓存</td>
<td>部分文件</td>
<td>本地磁盘</td>
<td>10000000</td>
<td>NFS客户端</td>
</tr>
<tr>
<td>浏览器缓存</td>
<td>网页</td>
<td>本地磁盘</td>
<td>10000000</td>
<td>浏览器</td>
</tr>
<tr>
<td>网页缓存</td>
<td>网页</td>
<td>远程服务器磁盘</td>
<td>1000000000</td>
<td>网页代理服务器</td>
</tr>
</tbody>
</table>
<p>　　早期计算机的存储器层次结构只有3级：CPU寄存器、内存和磁盘。随着CPU和内存之间的存取速度差距的增加，系统设计者不得不在寄存器文件和内存之间加入SRAM缓存存储器
(L1缓存)，L1缓存的存取速度与寄存器的差不多。之后又在L1缓存和内存之间加入L2缓存，在L2缓存和内存之间加入L3缓存。</p>
<p>　　只存储指令的缓存称为<strong>指令缓存</strong>，只存储数据的缓存称为<strong>数据缓存</strong>。同时存储指令和数据的缓存称为<strong>统一缓存</strong>。</p>
<p>　　良好的计算机程序通常有良好的<strong>局部性</strong>，即倾向于引用<span
style="background-color: yellow">最近引用过的数据项附近的数据项</span>或<span
style="background-color: yellow">最近引用过的数据项本身</span>，这种倾向称为<strong>局部性原理</strong>。</p>
<p>　　局部性有<strong>时间局部性</strong>和<strong>空间局部性</strong>这2种形式。时间局部性好的程序中，被引用过1次的内存位置可能不久后再次被引用。空间局部性好的程序中，内存位置被引用后，可能不久后引用该位置附近的内存位置。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarray</span><span class="params">(<span class="type">int</span> a[n])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于函数<code>sumarray()</code>，变量<code>sum</code>每次迭代都会被引用，所以变量<code>sum</code>有良好的时间局部性。相反，变量<code>sum</code>没有空间局部性。对于数组<code>a</code>，其中的元素会按序被读取。数组<code>a</code>有良好的空间局部性和很差的时间局部性。总体而言，函数<code>sumarray()</code>有良好的局部性。</p>
<p>　　像函数<code>sumarray()</code>这样顺序访问数组的每个元素的模式称为<strong>步长为1的引用模式</strong>
(相对元素数据)，也称为<strong>顺序引用模式</strong>。同理，每次隔<span
class="math inline">\(k\)</span>个元素进行访问的模式就是<strong>步长为<span
class="math inline">\(k\)</span>的引用模式</strong>。一般情况下，随着步长的增加，空间局部性下降。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumarrayrows</span><span class="params">(<span class="type">int</span> a[m][n])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; i &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumarraycols</span><span class="params">(<span class="type">int</span> a[m][n])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; i &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于引用多维数组的程序，步长会成为问题。函数<code>sumarrayrows()</code>按照<span
style="background-color: yellow">优先顺序</span>读数组元素，即先读第1行的元素，再读第2行的元素，依此类推，它有良好的空间局限性。函数<code>sumarraycols()</code>并非按照优先顺序的方式，使用的是步长为<span
class="math inline">\(n\)</span>的引用模式，所以它的空间局部性较差。</p>
<p>　　程序从存储系统读数据的速率称为<strong>读吞吐量</strong>或<strong>读带宽</strong>。若程序在<span
class="math inline">\(s\)</span>秒内读<span
class="math inline">\(n\)</span>字节，则读吞吐量为<span
class="math inline">\(\frac{n}{s}\)</span>，单位是MB/s。</p>
<p>　　<strong>存储器山</strong>是1个读带宽与时间和空间局部性的二维函数。</p>
<h3 id="存储技术">6.1 存储技术</h3>
<p>　　<strong>随机存取存储器</strong>分为静态和动态。SRAM比DRAM更快但更贵。SRAM用于CPU内外的缓存存储器，DRAM用于存储器和图形系统的帧缓冲区。常规桌面系统的SRAM的容量数量级是10MB，而DRAM的容量数量级可以达到1GB。</p>
<p>　　DRAM和SRAM在断电后会丢失信息，所以它们是<strong>易失</strong>的。<strong>非易失性存储器</strong>
(NVM)
在断电后依然保存着信息。一类非易失性存储器是<strong>只读存储器</strong>
(ROM)，由于历史原因，虽然其中的部分类型即可读也可写，但是依然统称ROM。ROM按重编程
(写) 的次数和重编程所用的机制来区分。</p>
<p>　　● <strong>可编程ROM</strong> (PROM)
只能被编程1次，其中的每个存储器单元都有<span
style="background-color: yellow">熔丝</span>，只能用大电流熔断1次。</p>
<p>　　● <strong>可擦写可编程ROM</strong> (EPROM)
有1个透明的石英窗口，允许光到存储单元。紫外线照射到窗口时，EPROM单元会置0。EPROM编程是通过把1写入EPROM的特殊设备完成的，它的擦除和重编程次数可以达到1000次。<strong>电可擦写PROM</strong>类似于EPROM，但无需物理上独立的编程设备，所以可以直接在印制电路卡上编程。EEPROM能编程的次数数量级可以达到<span
class="math inline">\(10^5\)</span>次。</p>
<p>　　另一类非易失性存储器是<strong>闪存</strong>，它基于EEPROM。<strong>固态硬盘</strong>
(SSD) 是基于闪存的磁盘驱动器。</p>
<p>　　存储在ROM设备中的的程序称为<strong>固件</strong>。当计算机系统通电后，它会运行存储在ROM中的固件。一些系统中的固件中提供了少量基本I/O函数，例如，PC的BIOS例程。显卡和磁盘驱动控制器等复杂的设备也依赖固件来转换CPU的I/O请求。</p>
<p>　　不同的存储技术有不同的价格和性能折中，它们的价格和性能正在以截然不同的速度变化。SRAM、DRAM和磁盘的存取速度都滞后于CPU的存取速度，但SRAM的存取速度与CPU的存取速度的差距远小于其他两者的存取速度和CPU的存取速度的差距。</p>
<h4 id="随机存取存储器">6.1.1 随机存取存储器</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/inverted_pendulum.svg" class="">
<p>　　SRAM将每个位存储在<strong>双稳态</strong>的存储器单元里，每个单元用六晶体管电路实现。六晶体管电路类似于倒转的钟摆，当钟摆在最左边或最右边时，它是稳定的。在其他任何地方，钟摆最终都会倒向一边。原则上，钟摆能在垂直位置无期限地保持平衡，但此状态是<strong>亚稳态</strong>的——最细微的扰动就会使它倒下且再也不会恢复到垂直状态。只有有电，它就会永远保持其值。即使有干扰扰乱电压，干扰消除后，电路会恢复到稳定值。</p>
<p>　　DRAM将每个位存储为给电容充电，该电容很小，通常只有<span
class="math inline">\(30\times
10^{-15}\)</span>F。DRAM可以制造得很密集——每个单元由1个电容和1个存取晶体管组成。与SRAM不同，DRAM存储单元的电容的电压被干扰后，就不会再恢复。暴露在光线下会导致电容的电压改变。实际上，数码照相机和摄像机中的传感器本质上就是DRAM单元阵列。</p>
<p>　　很多原因会导致漏电，使得DRAM单元在10~100ms内失去电荷。不过计算机运行的时钟周期是以ns来衡量的，所以相对而言这个保持时间是比较长的。存储器系统必须周期性地读写数据来刷新。有些系统会使用纠错码，其中的字的编码会多出几位，类似于CRC。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 13%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>每位晶体管数</th>
<th>相对存取时间</th>
<th>持续</th>
<th>敏感</th>
<th>相对花费</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SRAM</td>
<td>6</td>
<td>1×</td>
<td>是</td>
<td>否</td>
<td>1000×</td>
<td>缓存存储器</td>
</tr>
<tr>
<td>DRAM</td>
<td>1</td>
<td>10×</td>
<td>否</td>
<td>是</td>
<td>1×</td>
<td>存储器和帧缓冲区</td>
</tr>
</tbody>
</table>
<h5 id="dram">6.1.1.1 DRAM</h5>
<p>　　DRAM芯片中的所有单元 (位) 被分为<span
class="math inline">\(d\)</span>个<strong>超单元</strong>，每个超单元都由<span
class="math inline">\(w\)</span>个DRAM单元组成。<span
class="math inline">\(d\times w\)</span>的DRAM共存储了<span
class="math inline">\(d\times w\)</span>位信息。超单元组织为<span
class="math inline">\(r\)</span>行<span
class="math inline">\(c\)</span>列的长方形阵列，其中<span
class="math inline">\(r\times c=d\)</span>。每个超单元有形如<span
class="math inline">\((i,j)\)</span>的地址，其中<span
class="math inline">\(i\)</span>表示行，<span
class="math inline">\(j\)</span>表示列。</p>
<p>　　DRAM阵列元素实际上并没有标准的名称，计算机架构师称之为
"单元"，表示DRAM存储单元。电路设计师称之为
"字"，表示存储器的1个字。这里为了避免混淆，采用了无歧义的术语
"超单元"。</p>
<p>　　每个DRAM芯片都连接到称为<strong>存储控制器</strong>的电路，该电路可以单次将<span
class="math inline">\(w\)</span>位传入或传出DRAM芯片。为了读出超单元<span
class="math inline">\((i,j)\)</span>的内容，存储控制器先将行地址<span
class="math inline">\(i\)</span>发送给DRAM，再将列地址<span
class="math inline">\(j\)</span>发生给DRAM。最后，DRAM响应对应的内容。内容通过称为<strong>引脚</strong>的外部连接器传入或传出芯片。每个引脚携带1位的信号。行地址<span
class="math inline">\(i\)</span>称为<strong>行地址选通脉冲</strong>
(RAS) 请求，列地址<span
class="math inline">\(j\)</span>称为<strong>列地址选通脉冲</strong>
(CAS) 请求。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/reading_the_contents_of_a_dram_supercell.svg" class="">
<p>　　上图展示了从<span
class="math inline">\(16\times8\)</span>的DRAM中读出超单元<span
class="math inline">\((2,1)\)</span>的过程。在图a中，存储控制器发送行地址2，DRAM将行2的整个内容都复制到内部行缓冲区。在图b中，存储控制器发送列地址1，DRAM复制内部行缓存区中的超单元<span
class="math inline">\((2,1)\)</span>中的8位并发将其发送给存储控制器。这里有2组引脚：8个数据引脚
(能传输1个字节) 和2个地址引脚
(能携带2位的行或列超单元地址)。其他携带控制信息的引脚没有显示出来。</p>
<p>　　若需要<span
style="background-color: yellow">连续读取超单元同一行</span>的<span
class="math inline">\(n\)</span> (<span
class="math inline">\(n&gt;1\)</span>) 个数据：</p>
<p>　　●
对于DRAM，存储控制器会发送RAS/CAS请求，将指定行复制到行缓冲区，读取指定的数据并丢弃其他数据，然后重复这个过程<span
class="math inline">\(n-1\)</span>次。</p>
<p>　　● 对于<strong>快页模式DRAM</strong> (FPM
DRM)，存储控制器会发送RAS/CAS请求，将指定行复制到行缓冲区，然后读取指定数据。剩余<span
class="math inline">\(n-1\)</span>次<span
style="background-color: yellow">只会发送CAS请求</span>，读取指定数据，只有在最后1次读取时，才会丢弃其他数据。<strong>扩展数据输出DRAM</strong>
(EDO DRAM) 是FPM DRAM的增强型，允许各个CAS信号在时间上更紧密。</p>
<p>　　DRAM、FPM DRAM和DEO
DRAM都是异步的，因为它们使用1组显式控制信号来与存储控制器通信。<strong>同步DRAM</strong>
(SDRAM)
用驱动存储控制器的同一外部时钟信号的上升沿代替了很多控制信号。这里不会深入细节，最终效果是SDRAM能比异步的存储器更快地输出超单元的内容。<strong>双数据率同步DRAM</strong>
(DDR SDRAM)
是SDRAM的增强型，它使用了2个时钟沿作为控制信号，从而使DRAM的速率翻倍。DDR
SDRAM按预取缓冲区 (可增加有效带宽) 容量区分类型，分别是DDR (2位)、DDR2
(4位) 和DDR3 (8位)。</p>
<p>　　<strong>显存</strong> (VRAM) 用于图形系统的帧缓冲区，它类似于FPM
DRAM，但有2个不同。第1个不同是VRAM的输出是通过按序移动内部缓冲区的全部内容得到，第2个不同是VRAM允许并行地读写。因此，系统可以在写下一次更新的值的同时，用帧缓冲区的像素刷新屏幕
(读)。</p>
<p>　　直到1995年，大多数计算机都是使用FPM DRAM。1996到1999年，EDO
DRAM主导市场，FPM
DRAM几乎消失。SDRAM最早出现在1995年的高端系统中，到2002年，大多数计算机都是使用SDRAM和DDR
DRAM。到2010年，大多数服务器和桌面系统都是使用DDR3 SDRAM。</p>
<h5 id="存储模块">6.1.1.2 存储模块</h5>
<p>　　DRAM芯片封装在<strong>存储模块</strong>中，它插在主板的扩展槽上。Core
i7系统使用的240个引脚的<strong>双列直插存储模块</strong>以64位为块的形式将数据传入或传出存储控制器。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/reading_the_contents_of_a_memory_module.svg" class="">
<p>　　这里用8个<span
class="math inline">\(8M\times8\)</span>的DRAM芯片来存储64MB，这些芯片编号为0~7。每个超单元存储内存的1B。对应超单元地址<span
class="math inline">\((i,j)\)</span>的8个超单元表示内存中字节地址A的64位字，其中DRAM0表示第1B，DRAM1表示第2B，依此类推。</p>
<p>　　当读取内存地址A的1个字时，存储控制器会将地址转换为超单元地址<span
class="math inline">\((i,j)\)</span>并发送到存储模块，然后存储模块将<span
class="math inline">\(i\)</span>和<span
class="math inline">\(j\)</span>广播到每个DRAM。每个DRAM输出超单元地址<span
class="math inline">\((i,j)\)</span>的1B，模块中的电路收集这些输出并合并成64位的字，最后响应给存储控制器。</p>
<p>　　将多个存储模块连接到存储控制器，能聚合成内存。在这种情况下，当控制器收到地址A时，控制器会选择包含A的模块，将A转换为该模块的超单元地址<span
class="math inline">\((i,j)\)</span>并发送给该模块。</p>
<h5 id="访问内存">6.1.1.3 访问内存</h5>
<p>　　数据通过称为<strong>总线</strong>的共享电子电路在CPU和DRAM之间传输。每次CPU和内存之间的数据传输都是通过称为<strong>总线事务</strong>的一系列步骤来完成的。<strong>读事务</strong>会将数据从内存传输到CPU，<strong>写事务</strong>会将数据从CPU传输到内存。</p>
<p>　　总线是1组并行的导线，能携带地址、数据和控制信号。根据总线的设计，数据和地址信号可以共享同一组总线，也可以使用不同的总线。2个及以上的设备可以共享同一总线，控制线携带的信号会同步事务并标识当前正在执行的事务的类型。第1章提到过，连接CPU和I/O桥接器的是<strong>系统总线</strong>，连接I/O桥接器和内存的是<strong>内存总线</strong>。</p>
<p>　　不同厂商的总线体系结构不同。部分Intel系统使用称为<strong>北桥</strong>和<strong>南桥</strong>的芯片组分别将CPU连接到内存和I/O设备。早期的Pentium和Core
2中，<strong>前端总线</strong> (FSB)
将CPU连接到北桥。AMD将FSB替换为<span
style="background-color: yellow">超传输</span>互联，Intel Core
i7使用的是<span
style="background-color: yellow">快速通道</span>互联。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/memory_read_transaction_for_a_load_operation.svg" class="">
<p>　　这是加载操作<code>movq A, %rax</code>的内存读事务，<span
style="background-color: yellow">总线接口</span>在总线上发起读事务。首先，CPU将地址放到系统总线上，I/O桥将信号传输到内存总线。然后，内存侦测到地址信号，从内存总线上读地址，从DRAM取出对应的字并放回内存总线。I/O桥将内存信号转换为系统总线信号，沿着系统总线传输。最后，CPU侦测到系统总线上的数据，从总线上读数据并复制到对应的寄存器。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/memory_write_transaction_for_a_store_operation.svg" class="">
<p>　　这是存储操作<code>movq %rax, A</code>的内存写事务，<span
style="background-color: yellow">CPU</span>发起写事务。首先，CPU将地址放到系统总线上，内存从内存总线上读地址并等待数据到达。然后，CPU从寄存器中复制数据到系统总线。最后，内存从内存总线上读数据并存储到DRAM中。</p>
<h4 id="磁盘">6.1.2 磁盘</h4>
<p>　　<strong>磁盘</strong>是用于保存大量数据的存储设备，容量数量级可达到1TB，而基于RAM的存储器的容量数量级只能达到1GB。读磁盘的速度数量级是1ms，比读DRAM慢10万倍，比读SRAM慢100万倍。为了区别基于闪存的SSD，磁盘也称为<strong>旋转磁盘</strong>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/disk_geometry.svg" class="">
<p>　　磁盘由<strong>盘片</strong>构成。每个盘片的双面称为<strong>表面</strong>，表面覆盖着磁性记录材料。盘片中央的<strong>主轴</strong>让盘片以固定的速率旋转，通常是5400~15000转每分钟
(RPM)。</p>
<p>　　如图a所示，每个盘面由1组称为<strong>磁道</strong>的同心圆组成。每个磁道划分为1组扇区，每个扇区包含等量的数据位
(通常是512B)，这些数据编码在扇区的磁性材料中。扇区由<strong>间隙</strong>分隔，间隙存储表示扇区的格式化位。如图b所示，磁盘通常包含若干个盘片并封装在密封的容器中，整个设备称为<strong>磁盘驱动器</strong>，简称磁盘。</p>
<p>　　磁盘制造商用术语<strong>柱面</strong>来描述多个盘片驱动器的构造，即所有盘面上到主轴中心的距离相等的磁道集合。例如，若某个驱动器有3个盘片，每个盘面上磁道的编号都一致，柱面<span
class="math inline">\(k\)</span>就是6个磁道<span
class="math inline">\(k\)</span>的集合。</p>
<p>　　磁盘容量由<strong>记录密度</strong>、<strong>磁道密度</strong>和<strong>面密度</strong>决定。记录密度是磁道1英寸的段中可以存储的位数。磁道密度是盘片中心半径1英寸的段内磁道数。面密度是记录密度和磁道密度的乘积。
<span class="math display">\[
磁盘容量=\frac{字节数}{扇区}\times\frac{平均扇区数}{磁道}\times\frac{磁道数}{表面}\times\frac{表面数}{盘片}\times\frac{盘片数}{磁盘}
\]</span>
　　磁盘制造商通过提高面密度来增加容量。最初的磁盘的面密度很低，每个磁道分为数量相同的扇区，扇区的数量由最靠近主轴的磁道的扇区数决定，所以越远离主轴的磁道的扇区的间隔越大。随着面密度的提高，扇区的间隙变得过于大。因此，现代大容量磁盘使用<strong>多区记录</strong>，即将柱面集合划分为称为<strong>记录区</strong>的不相交的子集合。每个区包含1组连续的柱面，这些柱面的所有磁道的扇区数都相同。</p>
<h5 id="磁盘操作">6.1.2.1 磁盘操作</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/disk_dynamics.svg" class="">
<p>　　如图a所示，磁盘用<strong>读/写磁头</strong>来读写存储在磁性盘面的位，磁头连接到<strong>传动臂</strong>的一端，通过运动轨迹呈圆弧的方式移动传动臂，驱动器可以将磁道定位在盘面上的任何磁道上，这样的机械运动称为<strong>寻道</strong>。一旦磁头定位到指定的磁道，磁道上的位通过其下方时，磁头可以感知到该位的值
(读该位)。如图b所示，对于有多个盘片的磁盘，每个盘面都有独立的磁头。磁头垂直排列并一致移动。在任何时刻，所有的磁头都位于同一柱面。</p>
<p>　　磁头和盘面之间有1层大约0.1微米的气垫，磁头的速度大约为80km/h。在这样小的间隙内，磁头碰到盘面上的灰尘都会停止并撞到盘面上，这种情况称为<strong>磁头碰撞</strong>。因此，磁盘是密封包装的。</p>
<p>　　为了读取指定扇区的内容，传动臂会先将磁头定位到指定扇区所在的磁道上方。移动传动臂所需的时间称为<strong>寻道时间</strong>。寻道时间<span
class="math inline">\(T_{seek}\)</span>取决于磁头之前的位置和传动臂在盘面上的移动速度。现代驱动器中的平均寻道时间<span
class="math inline">\(T_{avg \enspace
seek}\)</span>是通过对几千次对随机扇区的寻道取平均值，通常是3~9ms。单次寻道的最大时间<span
class="math inline">\(T_{max\enspace seek}\)</span>高达20ms。</p>
<p>　　一旦磁头到达指定扇区所在的磁道的上方，驱动器会等待指定扇区的第1个位到达磁头下方，这段时间称为<strong>旋转延迟</strong>。旋转延迟取决于磁盘的旋转速度和当磁头到达指定扇区所在的磁道时盘面的位置。在最差的情况下，磁盘刚错过指定扇区，必须等待磁盘旋转1整圈
(需要<span class="math inline">\(T_{max\enspace
rotaion}\)</span>)。平均旋转时间<span
class="math inline">\(T_{avg\enspace rotation}\)</span>是<span
class="math inline">\(T_{max\enspace rotation}\)</span>的一半。 <span
class="math display">\[
T_{max\enspace rotation}=\frac{1}{RPM}\times\frac{60s}{1min}
\]</span>
　　当指定扇区的第1个位到磁头下方时，驱动器就能开始访问该扇区的内容。扇区的<strong>传输时间</strong>取决于旋转速度和每条磁道的平均扇区数。
<span class="math display">\[
T_{avg\enspace
transfer}=\frac{1}{RPM}\times\frac{1磁道}{每条磁道平均扇区数}\times\frac{60s}{1min}
\]</span>
　　扇区内容的平均访问时间为平均寻道时间、平均旋转延迟和平均传输时间之和。</p>
<p>　　例如，某个磁盘的旋转速率为7200RPM，<span
class="math inline">\(T_{avg\enspace
seek}\)</span>为9ms，每条磁道平均有400个扇区。 <span
class="math display">\[
\begin{align}
T_{access}&amp;=T_{avg\enspace seek}+T_{avg\enspace
rotation}+T_{avg\enspace transfer}\\[3px]
&amp;=9ms+\frac{1}{2}\times\frac{60s}{1min\times7200RPM}\times1000ms/s+\frac{60s}{1min\times7200RPM}\times\frac{1磁道}{400扇区}\times1000ms/s\\[3px]
&amp;\approx9ms+4ms+0.02ms\\[3px]
&amp;=13.02ms
\end{align}
\]</span>
　　从这个示例中可以看出，存取时间中寻道时间和旋转延迟的占比极高。由于寻道时间和旋转延迟大致相等，可以直接将寻道时间翻倍来估算存取时间。</p>
<p>　　访问SRAM中的64位字大约需要4ns，访问DRAM中的64位字大约需要60ns。因此，访问SRAM中的512B大约需要256ns，访问DRAM中的512B大约需要4μs，而访问磁盘中的512B大约需要10ms，所以磁盘的访问时间大约是SRAM的4万倍，DRAM的2500倍。</p>
<h5 id="逻辑磁盘块">6.1.2.2 逻辑磁盘块</h5>
<p>　　现代磁盘有多个盘面，每个盘面有不同的记录区。为了对操作系统隐藏这些细节，现代磁盘将其结构呈现为<span
class="math inline">\(B\)</span>个扇区大小的<strong>逻辑块</strong>的序列，其编号为0到<span
class="math inline">\(B-1\)</span>。磁盘封装中有称为<strong>磁盘控制器</strong>的硬件/固件设备，用于维护逻辑块号和实际
(物理) 磁盘扇区间的映射。</p>
<p>　　磁盘控制器必须先格式化磁盘才能访问磁盘中的数据。格式化过程包括<span
style="background-color: yellow">用标识扇区的信息填写扇区之间的间隙</span>、<span
style="background-color: yellow">识别任何有故障的柱面并禁用</span>以及<span
style="background-color: yellow">在每个区预留1组柱面备用</span>。当区域内有柱面出现故障时，会使用备用柱面。因此，磁盘制造商所说的格式化容量比最大容量小。</p>
<p>　　当操作系统执行从磁盘读数据到内存等I/O操作时，会发送命令到磁盘控制器来让其访问某个逻辑块号。控制器上的固件会查找快速表来将逻辑块号转换为
<span style="background-color: yellow">(盘面，磁道，扇区)</span>
的三元组，该三元组唯一地标识对应的物理扇区。控制器上的硬件会根据该三元组移动磁头到对应的柱面，等待扇区移动到磁头下，然后将磁头感知的数据收集到控制器的缓冲区，最后将该数据复制到内存。</p>
<p>　　例如，某个磁盘有4个盘面，扇区容量为512B，旋转速率为13000RPM，<span
class="math inline">\(T_{avg\enspace
seek}\)</span>为6ms，每个磁道平均有5000个扇区。显然，<span
class="math inline">\(T_{max\enspace
rotation}\approx4.61\)</span>ms。若某程序需要 (顺序) 从该磁盘中读文件
(需要10000个逻辑块) ：</p>
<p>　　●
当逻辑块到磁盘扇区的映射是顺序时，文件的第1个位到达磁头下方后，就无需再移动磁头。因此，磁头需要2整圈就能读取所有数据。
<span class="math display">\[
\begin{align}
T_{contiguous}&amp;\approx T_{avg\enspace seek}+T_{avg\enspace
rotation}+2\times T_{max\enspace rotation}\\[3px]
&amp;\approx6ms+2.30ms+9.22ms\\[3px]
&amp;=17.52ms
\end{align}
\]</span> 　　●
当逻辑块到磁盘扇区的映射是乱序时，每次读取新逻辑块时都要移动磁头。 <span
class="math display">\[
\begin{align}
T_{random}&amp;\approx (T_{avg\enspace seek}+T_{avg\enspace
rotation})\times10000\\[3px]
&amp;\approx(6ms+2.30ms)\times10000\\[3px]
&amp;=83s
\end{align}
\]</span></p>
<h5 id="io总线">6.1.2.3 I/O总线</h5>
<p>　　系统总线和内存总线都与CPU相关，但Intel的<strong>外围组件互连</strong>总线等I/O总线与CPU无关。虽然I/O总线比系统总线和内存总线慢，但它可以容纳多种第三方I/O设备。</p>
<p>　　● <strong>通用串行总线</strong> (USB)
是广泛使用的标准，用于连接各种外围I/O设备，例如键盘、鼠标、调制解调器、数码相机、手柄、打印件、外部磁盘驱动器和固态硬盘。USB控制器是连接到USB的设备的中转。USB
3.0的最大带宽为625MB/s。USB 3.1的最大带宽为1250MB/s。</p>
<p>　　● <strong>显卡</strong> (适配器)
包含负责代表CPU在显示器上显示像素的硬件和软件逻辑。</p>
<p>　　●
<strong>主机总线适配器</strong>通过特殊的<strong>主机总线接口</strong>定义的通信协议将若干个磁盘连接到I/O总线，最常用的磁盘接口就是<strong>小型计算机系统接口</strong>
(SCSI) 和<strong>串行高级技术附件</strong>
(SATA)。SCSI磁盘通常比SATA磁盘更快但也更贵。SCSI主机总线适配器
(简称SCSI控制器) 可以支持多个磁盘，而SATA适配器只能支持1个磁盘。</p>
<p>　　其他设备 (包括网络设配器)
可以通过将适配器插在主板上的扩展槽来连接到I/O总线，这些插槽提供了到总线的直接电路连接。</p>
<p>　　在PCI模型中，系统中的所有设备共享总线，同一时刻只能有1个设备访问这些线路。在现代系统中，共享的PCI总线已经被PCI
Express (PCEe)
总线取代，PCIe是1组高速串行、通过交换机连接的点到点链路，类似于以太网。PCI总线的最大吞吐量是533MB/s，PCIe总线的最大吞吐量为16GB/s。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/reading_a_disk_sector.svg" class="">
<p>　　如同a所示，CPU通过<strong>内存映射I/O</strong>来向I/O设备发送命令。在包含内存映射I/O的系统中，地址空间中有为I/O设备通信通信保留的地址，这样的地址称为<strong>I/O端口</strong>。当设备连接到总线时，会关联
(映射) 到若干个端口。</p>
<p>　　若磁盘控制器映射的端口是<code>0xa0</code>，则CPU可能需要执行3条对地址<code>0xa0</code>的存储指令来发起对磁盘的读。第1条指令发送1个命令字来告诉CPU发起读和其他参数
(例如，当读完成时是否中断CPU)。第2条指令指明应该读的逻辑块号。第3条指令指明应该存储磁盘扇区内容的内存地址。</p>
<p>　　当CPU发起了读请求后，在磁盘执行读时，CPU还会进行其他工作。1GHz的CPU时钟周期为1ns，在磁盘执行读的16ms内，CPU可以执行1600万条指令。</p>
<p>　　如同b所示，磁盘控制器收到CPU的读命令后，会将逻辑块号转换为扇区地址并读其中的内容，然后将这些数据通过DMA的方式来将传输到内存。</p>
<p>　　若图c所示，DMA传输完成，磁盘扇区的内容安全地存储在内存中后，磁盘控制器通过给CPU发送中断信号来通知CPU
(中断会发信号到CPU芯片的1个外部引脚上)。这会导致CPU暂停当前工作，跳转到1个操作系统例程，该例程会记录I/O已经完成并将控制权交回给CPU中断的位置。</p>
<h4 id="固态硬盘">6.1.3 固态硬盘</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/ssd.svg" class="">
<p>　　SSD插在I/O总线上的标准磁盘插槽上
(通常是USB和SATA)，行为同其他硬盘相同，处理来自CPU的读写逻辑磁盘块的读写请求。SSD由若干个闪存芯片和<strong>闪存转换层</strong>
(FTL)
组成，闪存芯片对应磁盘中的机械驱动，FTL是硬件/固件设备，对应磁盘中的磁盘控制器。读SSD的速度比写SSD的速度快，这是由底层闪存的基本属性决定。</p>
<p>　　1个闪存由<span
class="math inline">\(B\)</span>个块的序列组成，每个块有<span
class="math inline">\(P\)</span>页。通常，页是512B~4KB，块有32~128页
(16KB~512KB)。数据以页为单元读写。只有在页所属的块<strong>擦除</strong>
(块的所有位置1)
后，才能写该页。块擦除后，块中的每个页都可以直接写。大约写10万次后，块会<strong>磨损</strong>并无法使用。</p>
<p>　　擦除块需要较长的时间
(1ms级)，比访问页所需的时间高1个数量级。若需要写已包含数据的页<span
class="math inline">\(p\)</span> (不全是1)，必须先将<span
style="background-color: yellow">与该页同块</span>的其他所有包含有效数据的页复制到新
(擦除过的)
块。制造商已经在FTL中实现了复杂的逻辑来抵消写块的高昂代价和最小化写时内部副本的数量，但是随机写的速度还是不如随机读。</p>
<p>　　SSD由半导体存储器构成，没有可移动的部件，所以随机存取时间比磁盘快，能耗更低，更坚固。但是，SSD会磨损，FTL中的<strong>磨损均衡</strong>逻辑通过将擦除均匀分布在所有块来最大化每个块的使用寿命，实际使用寿命有好几年。此外，SSD每个字节的价格比磁盘的贵。</p>
<h3 id="存储器层次结构">6.2 存储器层次结构</h3>
<p>　　<strong>高速缓存</strong> (简称<strong>缓存</strong>)
是小而存取速度快的存储设备，它作为存储在更大更慢的设备中的数据对象的缓存区域。使用缓存的过程称为<strong>缓存</strong>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/the_basic_principle_of_caching_in_a_memory_hierarchy.svg" class="">
<p>　　如图所示，<span
class="math inline">\(k+1\)</span>级存储器划分为连续的数据对象块，称为<strong>块</strong>。每个块都有唯一的地址或名称。块可以是固定大小
(大多数情况下)，也可以是可变大小的
(例如，存储在Web服务器上的HTML文件)。例如，图中<span
class="math inline">\(k+1\)</span>级存储器划分为16个固定的块，编号为0~15。</p>
<p>　　<span
class="math inline">\(k\)</span>级存储器也划分为块，块的容量同<span
class="math inline">\(k+1\)</span>级的相同。<span
class="math inline">\(k\)</span>级缓存中的块始终是<span
class="math inline">\(k+1\)</span>级块的某个子集的副本。例如，图中<span
class="math inline">\(k\)</span>级缓存有4个块：块4、9、14和3的副本。</p>
<p>　　数据总是以块为<strong>传输单元</strong>在<span
class="math inline">\(k\)</span>级和<span
class="math inline">\(k+1\)</span>级之间复制。在存储器层次结构中，任何相邻的层级之间的块的容量是固定的，但其他层级之间的块的容量可以不同。例如，寄存器和L1缓存之间的块的容量通常是1个字，而L1缓存和L2缓存之间、L2缓存和L3缓存之间以及L3缓存和内存之间的块的数量级通常是10B。内存和本地磁盘间块的数量级通常是100B或1KB。层次结构中层级较低
(离CPU较远)
的设备的存取时间较长，所以用较大的块来弥补较长的存取时间。</p>
<p>　　当程序需要<span
class="math inline">\(k+1\)</span>级的某个数据对象<code>d</code>，会先在<span
class="math inline">\(k\)</span>级当前存储的块中查找。若<span
class="math inline">\(k\)</span>级缓存中有<code>d</code>
(称为<strong>缓存命中</strong>)，程序会直接从<span
class="math inline">\(k\)</span>级中读取<code>d</code>。相反，若<span
class="math inline">\(k\)</span>级缓存中没有<code>d</code>
(称为<strong>缓存未命中</strong>)，程序会从<span
class="math inline">\(k+1\)</span>级中读取<code>d</code>并在<span
class="math inline">\(k\)</span>级中缓存<code>d</code>。若<span
class="math inline">\(k\)</span>级缓存已满，则会用<code>d</code>覆盖其中1个块。</p>
<p>　　覆盖现存的块的过程称为<strong>替换</strong>或<strong>驱逐</strong>，被替换的块称为<strong>牺牲块</strong>，缓存的<strong>替换策略</strong>决定牺牲块。例如，随机替换策略会选择随机牺牲块，而<strong>最近最少使用</strong>策略会选择最后访问时间距今最长的块，<strong>最不常用使用</strong>策略会选择某个过去时间窗口内引用次数最少的块。所有策略都需要额外的硬件和时间，但是层级越低的缓存出现未命中后，其代价越高。</p>
<p>　　当<span class="math inline">\(k\)</span>级缓存从<span
class="math inline">\(k+1\)</span>级中读取<code>d</code>后，程序以后就能直接从<span
class="math inline">\(k\)</span>级读取<code>d</code>。例如，假设需要读图中<span
class="math inline">\(k+1\)</span>级的块12的某个数据对象，会先出现缓存未命中并直接在<span
class="math inline">\(k+1\)</span>级中读取块12。当<span
class="math inline">\(k\)</span>级中缓存块12后，块12会留在<span
class="math inline">\(k\)</span>级等待后续的访问。</p>
<p>　　若<span class="math inline">\(k\)</span>级缓存为空
(称为<strong>冷缓存</strong>)，任何数据对象的访问都会未命中，此类未命中称为<strong>强制未命中</strong>或<strong>冷未命中</strong>。冷未命中通常是暂时的，当多次访问存储器后，缓存会<strong>热身</strong>并进入稳定态，之后不会再出现冷未命中。</p>
<p>　　一旦出现缓存未命中，<span
class="math inline">\(k\)</span>级缓存必须执行<strong>放置策略</strong>，确定从<span
class="math inline">\(k+1\)</span>级取出的块放置的位置。最灵活的替换策略是允许来自<span
class="math inline">\(k+1\)</span>级的块存储在<span
class="math inline">\(k\)</span>级的任何位置。对于存储器层次结构中层级较高的缓存，该策略的成本很高，因为随机放置的块定位成本高。因此，通常使用更简单的放置策略，即将<span
class="math inline">\(k+1\)</span>级的特定块限制为<span
class="math inline">\(k\)</span>级的块的子集
(有时只有1个块)。例如，图中使用的放置策略是<span
style="background-color: yellow"><span
class="math inline">\(k+1\)</span>级的块<span
class="math inline">\(m\)</span>必须放置在<span
class="math inline">\(k\)</span>级的块<span
class="math inline">\(n\)</span> (<span
class="math inline">\(n=m\bmod4\)</span>) 中</span>，所以<span
class="math inline">\(k+1\)</span>级中的块0、4、8、12会映射到<span
class="math inline">\(k\)</span>级中的块0，<span
class="math inline">\(k+1\)</span>级中的块1、5、9、13会映射到<span
class="math inline">\(k\)</span>级中的块1，依此类推。</p>
<p>　　这种简单的放置策略会导致<strong>冲突未命中</strong>，即使有足够的空间来存储<span
class="math inline">\(k+1\)</span>的块，由于这些块映射到同一位置，缓存会一直未命中。例如，依次读<span
class="math inline">\(k+1\)</span>级的块0、块4，然后循环这个过程。</p>
<p>　　程序通常是按照一系列阶段 (例如，循环)
来执行，每个阶段会存取某个合理且相对固定的缓存块集，例如，嵌套的循环可能反复访问同一数组的元素。这个块集合称为该阶段的<strong>工作集</strong>。当工作集大小超过缓存容量时，会出现<strong>容量未命中</strong>。</p>
<h3 id="缓存存储器">6.3 缓存存储器</h3>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/general_organization_of_cache.svg" class="">
<p>　　若某计算机的每个存储器地址都是<span
class="math inline">\(m\)</span>位，则有<span
class="math inline">\(M=2^m\)</span>个地址。该计算机的缓存构成1个有<span
class="math inline">\(S=2^s\)</span>个<strong>缓存组</strong>的数组，每个缓存组有<span
class="math inline">\(E\)</span>个<strong>缓存行</strong>。每行有1位<strong>有效位</strong>
(表示是否包含有用信息)、<span
class="math inline">\(t\)</span>位<strong>标识位</strong>
(同一组内块的唯一标识) 和<span
class="math inline">\(B\)</span>字节数据块。</p>
<p>　　缓存结构可以用<span
class="math inline">\((S,E,B,m)\)</span>来表示，其容量 (<span
style="background-color: yellow">仅计算数据块</span>) <span
class="math inline">\(C=S\times E\times B\)</span>。</p>
<p>　　<span class="math inline">\(S\)</span>和<span
class="math inline">\(B\)</span>将<span
class="math inline">\(m\)</span>位的地址分为3部分：<span
class="math inline">\(t\)</span>位标识、<span
class="math inline">\(s\)</span>位组索引 (无符号数) 和<span
class="math inline">\(b\)</span>位块偏移。第<span
class="math inline">\(i\)</span>组的组索引是<span
class="math inline">\(i\)</span>。当CPU读内存地址A的内容时，若设置了有效位，<span
class="math inline">\(t\)</span>位标识会指明块，<span
class="math inline">\(s\)</span>位组索引会指明块所属组，最后<span
class="math inline">\(b\)</span>位块偏移指明块的偏移量。若与标识匹配的块未设置有效位，则缓存未命中。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/why_caches_index_with_middle_bits.svg" class="">
<p>　　若将地址的高位作为组索引，那么部分连续的缓存块将会映射到同一缓存组。如图所示，连续四个缓存块映射到同一缓存中。具有良好空间局部性的程序会顺序读取一个数组的元素，若每个组能容纳的行数很少时，会频繁出现缓存未命中。地址中间位作为组索引时，数组相邻的元素会映射到不同的缓存组。</p>
<p>　　抽取缓存行中的字的过程分为<strong>组选择</strong>、<strong>行匹配</strong>和<strong>字抽取</strong>。</p>
<p>　　例如，某32位计算机的缓存容量为1024B，每个缓存组有4个缓存行，每个数据块有8B。
<span class="math display">\[
\begin{align}
S&amp;=\frac{C}{E\times B}=\frac{1024B}{4\times8B}=32\\[3px]
s&amp;=\log_2S=\log_232=5\\[3px]
b&amp;=\log_2B=\log_28=3\\[3px]
t&amp;=m-s-b=32-5-3=24
\end{align}
\]</span></p>
<h4 id="缓存类型">6.3.1 缓存类型</h4>
<p>　　缓存组只有1行 (<span class="math inline">\(E=1\)</span>)
的缓存称为<strong>直接映射缓存</strong>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_06/extracting_a_word_in_direct-mapped_cache.svg" class="">
<p>　　对于直接映射缓存，组选择就是根据组索引选择，这里是<span
class="math inline">\(i\)</span>。组选择完成后，会先判断有效位是否设置。若有效位已设置，则判断标识是否匹配，这里是0100，匹配则得到缓存命中；若有效位未设置或标识不匹配，则得到缓存未命中。最后，根据块偏移来判断数据的偏移量，这里是100
(假设字长是4B)。若缓存未命中，替换策略就替换组索引中唯一的1行。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 21%" />
<col style="width: 16%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr>
<th>地址 (十进制)</th>
<th>标识 (1位)</th>
<th>组索引 (2位)</th>
<th>块偏移 (1位)</th>
<th>块号 (十进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>00</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>00</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>01</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>01</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>10</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>10</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>11</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>0</td>
<td>11</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td>00</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>1</td>
<td>00</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td>01</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>11</td>
<td>1</td>
<td>01</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>12</td>
<td>1</td>
<td>10</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<td>13</td>
<td>1</td>
<td>10</td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td>14</td>
<td>1</td>
<td>11</td>
<td>0</td>
<td>7</td>
</tr>
<tr>
<td>15</td>
<td>1</td>
<td>11</td>
<td>1</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>　　这是直接映射缓存的4位地址空间。标识和组索引组合是内存中的每个块的唯一标识。这里有8个内存块，但只有4组，所以有2个块会映射到同一组。映射到同一组的块由标识区分。例如，块0和块4会映射到同一组，块0的标识是0，块4的标识是1。</p>
<table>
<thead>
<tr>
<th>组</th>
<th>有效位</th>
<th>标识</th>
<th>块0</th>
<th>块1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>m[0]</td>
<td>m[1]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>　　1)
初始时，缓存都是空的。第1次读地址0的字，出现缓存未命中，缓存从内存取出块0并返回m[0]。然后读地址1的字，出现缓存命中，缓存返回m[1]。</p>
<table>
<thead>
<tr>
<th>组</th>
<th>有效位</th>
<th>标识</th>
<th>块0</th>
<th>块1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>m[8]</td>
<td>m[9]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>m[12]</td>
<td>m[13]</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>　　2)
读地址13的字，出现缓存未命中，缓存从内存取出块6并返回m[13]。然后读地址8的字，出现缓存未命中，缓存从内存取出块4替换块0并返回m[8]。</p>
<table>
<thead>
<tr>
<th>组</th>
<th>有效位</th>
<th>标识</th>
<th>块0</th>
<th>块1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>m[0]</td>
<td>m[1]</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>m[12]</td>
<td>m[13]</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>　　3)
读地址0的字，出现缓存未命中，缓存从内存取出块0替换块4并返回m[0]。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">dotprod</span><span class="params">(<span class="type">float</span> x[<span class="number">8</span>], <span class="type">float</span> y[<span class="number">8</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += x[i] * y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于参数<code>x</code>和<code>y</code>，函数<code>dotprod()</code>有良好的空间局部性，但访问这种<span
style="background-color: yellow">元素个数是2的幂的数组</span>通常会出现冲突未命中。这里假设浮点类型为4B，<code>x</code>存储在地址0开始的连续32B，<code>y</code>紧随其后，从地址32开始。变量<code>sum</code>存储在寄存器中。进一步假设缓存有2个组，每个块有16B。第1次迭代引用<code>x[0]</code>时会出现缓存未命中，将块<code>x[0]</code>到<code>x[3]</code>加载到组0，然后引用<code>y[0]</code>时再次出现缓存未命中，将块<code>y[0]</code>到<code>y[3]</code>加载到组0。在之后每次迭代都会如此，这种情况称为<strong>抖动</strong>，即缓存反复地加载和驱逐同一缓存块中的组。</p>
<p>　　这种抖动导致性能下降2或3倍并不罕见。若将<code>x</code>定义为<code>float x[12]</code>，则<code>x[i]</code>不会和<code>y[i]</code>映射到相同的组，也就不会再出现抖动。</p>
<p>　　缓存行数<span class="math inline">\(E\)</span>满足<span
class="math inline">\(1&lt;E&lt;\frac{C}{B}\)</span>的缓存称为<span
class="math inline">\(E\)</span>路<strong>组相联缓存</strong>。它的字抽取过程类似直接映射缓存的。出现缓存未命中时，若缓存组内有空行，则直接替换；反之，则使用替换策略。</p>
<p>　　缓存行数<span
class="math inline">\(E=\frac{C}{B}\)</span>的缓存称为<strong>全相联缓存</strong>，它只有1个缓存组，所以<span
style="background-color: yellow">地址中没有组索引</span>。它的抽取字过程类似直接映射缓存的，但缓存电路必须并行地搜索很多可能匹配的标识，所以构造大且快速的全相联缓存很困难且贵。全相联缓存只适合做较小的缓存
(例如，虚拟内存中的TLB)。</p>
<h4 id="写缓存">6.3.2 写缓存</h4>
<p>　　相比读缓存，写缓存更复杂。假设写一个已缓存的字
(<strong>写命中</strong>)，最简单的方法是<strong>透写</strong>，即该字的块直接写入到下一层级中，但这会占用总线流量。另一种方法是<strong>回写</strong>，即将该字的块写入到下一层级的时间推迟到替换这个更新后的块时。由于局部性，回写的总线流量占用远低于透写的总线流量占用，但它增加了复杂性，需要为每个缓存行维护额外的修改位，指明该缓存块是否被修改过。替换块时若块已修改，则将其写到下一层级再替换；否则，直接替换。</p>
<p>　　若出现写未命中，可以使用<strong>写分配</strong>，即先将下一层级的块先缓存再更新。这种方法充分利用了空间局部性，但每次未命中都会缓存下一层级的块。另一种方法是<strong>非写分配</strong>，即跳过缓存并直接更新下一层级的块。<strong>透写缓存</strong>通常使用非写分配，<strong>回写缓存</strong>通常使用写分配。</p>
<p>　　通常，由于较长的传输时间，存储器层次结构中层级较低的缓存更可能使用回写而非透写。此外，由于逻辑电路密度的提高，回写的复杂性越来越不成为障碍，回写缓存可以出现在存储器层次结构中各个层级。另一方面，与处理读的方式对应，回写缓存写分配更能利用局部性。</p>
<h4 id="缓存参数的性能影响">6.3.3 缓存参数的性能影响</h4>
<p>　　衡量缓存性能的指标有<strong>未命中率</strong>、<strong>命中率</strong>、<strong>命中时间</strong>和<strong>未命中处罚</strong>。</p>
<p>　　未命中率指未命中的内存引用比例。命中率指命中的内存引用比例。命中时间指从缓存传输1个字到CPU所用时间，包括组选择、行确认和字选择的时间。未命中处罚指由于未命中而所需的额外时间。L1缓存未命中时，从L2缓存得到服务的处罚是10个时钟周期，从L3缓存得到服务的处罚是50个时钟周期，从内存得到服务的处罚是200个时钟周期。</p>
<p>　　容量较大的缓存命中率较高，但命中时间也较长。</p>
<p>　　容量较大的缓存块更能利用空间局部性，进而提高命中率。但是，对于给定大小的缓存，缓存块越大表示缓存行数越少，这会降低时间局部性优于空间局部性的程序的命中率。此外，较大的缓存块会增加传输时间，进而增加未命中处罚。</p>
<p>　　较高的相联度 (即缓存行较多)
会降低由于冲突未命中出现的抖动的可能性，但实现成本较高且较复杂，进而导致存取速度更慢，每行都需要更多的标识位、额外的LRU状态位和额外的控制逻辑。此外，较高的相联度会增加命中时间和未命中处罚。</p>
<p>　　透写缓存更易实现，而且能使用独立于缓存的<span
style="background-color: yellow">写缓冲区</span>来更新存储器。回写缓存需要传输的数据更少，能让出更多的存储器带宽给执行DMA的I/O设备。</p>
<h3 id="缓存对程序性能的影响">6.4 缓存对程序性能的影响</h3>
<p>　　局部性较好的程序的命中率较高，命中率高的程序一般比命中率低的程序运行更快。因此，编写<strong>缓存友好</strong>的代码很重要，具体实现方法包括<span
style="background-color: yellow">让常见情况快速进行</span>和<span
style="background-color: yellow">尽量减少每个循环内部的缓存未命中次数</span>。</p>
<p>　　编译器会将局部变量缓存在寄存器文件中，所以应尽量使用局部变量。</p>
<p>　　假设缓存的块容量为<span
class="math inline">\(B\)</span>字节，步长为<span
class="math inline">\(k\)</span> (单位是字)
的引用模式每次迭代平均有<span
class="math inline">\(min(1,\frac{字长\times
k}{B})\)</span>次缓存未命中。当<span
class="math inline">\(k=1\)</span>时，它取最小值。</p>
<p>　　对于<span class="math inline">\(n\times n\)</span>矩阵乘法<span
class="math inline">\(C=AB\)</span>，当<span
class="math inline">\(n=2\)</span>时，有 <span class="math display">\[
\begin{align}
\begin{bmatrix}
c_{11} &amp; c_{12}\\
c_{21}&amp;c_{22}\\
\end{bmatrix}
&amp;=
\begin{bmatrix}
a_{11}&amp;a_{12}\\
a_{21}&amp;a_{22}\\
\end{bmatrix}
\begin{bmatrix}
b_{11}&amp;b_{12}\\
b_{21}&amp;b_{22}\\
\end{bmatrix}\\[3px]
c_{11}&amp;=a_{11}b_{11}+a_{12}b_{21}\\[3px]
c_{12}&amp;=a_{11}b_{12}+a_{12}b_{22}\\[3px]
c_{21}&amp;=a_{21}b_{11}+a_{22}b_{21}\\[3px]
c_{22}&amp;=a_{21}b_{12}+a_{22}b_{22}\\[3px]
\end{align}
\]</span> 　　矩阵乘法函数通常使用3个嵌套的循环来实现，这里分别用<span
class="math inline">\(i\)</span>、<span
class="math inline">\(j\)</span>和<span
class="math inline">\(k\)</span>来表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ijk版本 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i][k] * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">        C[i][j] += sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* jik版本 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i][k] * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">        C[i][j] += sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* jki版本 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = B[k][j];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += A[i][k] * r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kji版本 */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = B[k][j];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += A[i][k] * r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kij版本 */</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = A[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += r * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ikj版本 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = A[i][k];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] += r * B[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这6个函数成对地形成3个等价类，这里用内循环中访问的矩阵来区分。例如，<span
class="math inline">\(ijk\)</span>和<span
class="math inline">\(jik\)</span>版本是类AB，因为它们最内层循环中引用的是矩阵A和B。同理，<span
class="math inline">\(jki\)</span>和<span
class="math inline">\(kji\)</span>版本是类AC，<span
class="math inline">\(kij\)</span>和<span
class="math inline">\(ikj\)</span>版本是类BC。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 11%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th>矩阵乘法版本类</th>
<th>每次迭代加载次数</th>
<th>每次迭代存储次数</th>
<th>每次迭代A未命中次数</th>
<th>每次迭代B未命中次数</th>
<th>每次迭代C未命中次数</th>
<th>每次迭代未命中总次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>AB</td>
<td>2</td>
<td>0</td>
<td>0.25</td>
<td>1.00</td>
<td>0.00</td>
<td>1.25</td>
</tr>
<tr>
<td>AC</td>
<td>2</td>
<td>1</td>
<td>1.00</td>
<td>0.00</td>
<td>1.00</td>
<td>2.00</td>
</tr>
<tr>
<td>BC</td>
<td>2</td>
<td>1</td>
<td>0.00</td>
<td>0.25</td>
<td>0.25</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>　　类AB以步长为1的引用模式扫描A的行，每个缓存块的容量是4个8B的字，每次迭代的命中率是0.25。内循环以步长为<span
class="math inline">\(n\)</span>的引用模式扫描数组B的列，每次对B的访问都未命中。因此，每次迭代共1.25次未命中。</p>
<p>　　对于类AC，每次迭代执行2次加载和1次存储。内循环以步长为<span
class="math inline">\(n\)</span>的引用模式扫描A和C的列，结果每次加载都未命中。因此，每次迭代共有2次未命中。相比AB，交换循环较低了空间局部性。</p>
<p>　　对于类BC，每次迭代执行2次加载和1次存储。内循环为步长为1的引用模式扫描B和C的行，每次迭代的命中率是0.25。因此，每次迭代共0.50次未命中。</p>
<p>　　<strong>分块</strong>可以提高循环的时间局部性，其基本思想是将程序中的数据结构组织为大的片，称为<strong>块</strong>
(此块非彼块)，这样使得单个片能加载到L1缓存并执行相关读写，完成后丢掉该片，加载下一片，依此类推。分块会使得代码更难阅读和理解，所以它只适合优化编译器和频繁执行的库函数。</p>
<p>　　有时循环中的数组远大于任何SRAM缓存，<span
style="background-color: yellow">预取</span>硬件能识别步长为1的引用模式以执行预取，并且其速度能跟上循环中的访问存储器的速度。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第5章 优化程序性能</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_05/</url>
    <content><![CDATA[<p>　　现代编译器通过复杂且精细的算法来确定程序中计算的值和用法，然后尽可能简化表达式，在多个不同的地方使用同一计算来减少特定计算的执行次数。gcc等大多数编译器向用户提供了一些编译器使用的优化的控制。最简单的控制就是指定<strong>优化级别</strong>，例如，命令行选项<code>-Og</code>会使用1组基本的优化，<code>-O1</code>或更高
(例如，<code>-O2</code>和<code>-O3</code>)
会使用更多的优化。这样做可以进一步提升程序的性能，但也可能增加程序大小，也可能使标准调试工具更难对程序进行调试。</p>
<p>　　CPU活动周期由提供某个频率的规律信号的时钟控制，通常用<strong>千兆赫兹</strong>
(GHz) 表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vec_rec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> len;</span><br><span class="line">    <span class="type">data_t</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/vector_abstract_data_type.svg" class="">
<p>　　向量由2个内存块表示：首部和数据数组。这里声明<code>data_t</code>来表示基本元素的数据类型。</p>
<p>　　对于<span
class="math inline">\(\vec{a}=&lt;a_0,a_1,...,a_{n-1}&gt;\)</span>，前缀和<span
class="math inline">\(\vec{p}=&lt;p_0,p_1,...,p_{n-1}&gt;\)</span>定义为
<span class="math display">\[
\begin{align}
p_0&amp;=a_0\\[3px]
p_i&amp;=p_{i-1}+a_i&amp;&amp;1\leqslant i&lt;n
\end{align}
\]</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">psum1</span><span class="params">(<span class="type">float</span> a[], <span class="type">float</span> p[], <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">psum2</span><span class="params">(<span class="type">float</span> a[], <span class="type">float</span> p[], <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> mid_val = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        p[i] = mid_val;</span><br><span class="line">        p[i + <span class="number">1</span>] = mid_val + a[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>psum1()</code>和<code>psum2()</code>都是计算长度为<code>n</code>的向量的前缀和。函数<code>psum1()</code>每次迭代计算结果向量的1个元素，而函数<code>psum2()</code>使用了<strong>循环展开</strong>，每次循环可以计算结果向量的2个元素。</p>
<p>　　这样的过程的运行时间可以用常数加上与被处理元素个数成正比的因子来表示。<code>psum1()</code>和<code>psum2()</code>的运行时间
(单位是时钟周期) 约等于<span
class="math inline">\(368+9.0n\)</span>和<span
class="math inline">\(368+6.0n\)</span>。当<span
class="math inline">\(n\)</span>较大时，运行时间主要由线性因子决定，这些项中的系数是<strong>每元素周期数</strong>
(CPE)。这里使用每元素周期数而非每循环周期数来衡量，因为像循环展开这样的方法能够使用较少的循环来完成计算。</p>
<span id="more"></span>
<h3 id="优化编译器的性能和局限">5.1 优化编译器的性能和局限</h3>
<p>　　编译器必须对程序只使用<span
style="background-color: yellow">安全</span>的优化。对于C，优化前后的版本必须有相同的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">twiddle1</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">twiddle2</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *xp += <span class="number">2</span> * *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>twiddle1()</code>和<code>twiddle2()</code>都是将指针<code>yp</code>指向的值2次加到指针<code>xp</code>指向的值。<code>twiddle1()</code>需要进行6次内存访问
(2次读<code>*xp</code>，2次读<code>*yp</code>，2次写<code>*xp</code>)，而<code>twiddle2()</code>只需要3次内存访问
(读<code>*xp</code>，读<code>*yp</code>，写<code>*xp</code>)。然而，当<code>xp</code>和<code>yp</code>相等时，<code>twiddle1()</code>相当于<code>4 * *xp</code>，而<code>twiddle2()</code>相当于<code>3 * *xp</code>。因此，函数<code>twiddle1()</code>无法优化为函数<code>twiddle2()</code>。</p>
<p>　　这种2个及以上指针指向同一内存位置的情况称为<strong>内存混叠</strong>。在执行安全的优化时，编译器必须假设可能出现内存混叠，这导致了优化障碍之一——程序的某些方面会严重降低编译器生成优化代码的机会。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fun1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> f() + f() + f() + f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fun2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>fun1()</code>调用了4次函数<code>f()</code>，函数<code>fun2()</code>只调用了1次函数<code>f()</code>。这2个函数看似相似，但函数<code>f()</code>有<span
style="background-color: yellow">副作用</span>——会修改全局变量<code>counter</code>，调用<code>fun1()</code>会返回<span
class="math inline">\(0+1+2+3=6\)</span>，调用<code>fun2()</code>会返回<span
class="math inline">\(0\cdot4=0\)</span>。因此，函数<code>fun1()</code>无法优化为函数<code>fun2()</code>。</p>
<p>　　函数调用是第2个优化阻碍。包含函数调用的代码可以通过<strong>内联替换</strong>
(简称<strong>内联</strong>) 来优化，即用函数体替换函数调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">funclin</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">funclopt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = <span class="number">4</span> * counter + <span class="number">6</span>;</span><br><span class="line">    counter += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这里将函数<code>fun1()</code>中的4次函数调用展开为代码得到函数<code>funclin()</code>。这样可以降低函数调用的开销，也达到了优化效果，优化后得到函数<code>funclopt()</code>。对于gcc，可以通过命令函参数<code>-finline</code>或优化等级<code>-O1</code>以及更高等级的优化来进行内联替换，但这种方法只会对<span
style="background-color: yellow">同一文件</span>中定义的函数进行内联。</p>
<p>　　在使用GDB等符号调试器来调试代码和用代码剖析的方式来评估程序性能时，应该阻止编译器进行内联替换。因为内联替换后，对函数调用的追踪和设置的断点会失效。同样，内联替换后的函数调用无法正确剖析。</p>
<h4 id="提升循环效率">5.1.1 提升循环效率</h4>
<p>　　将执行多次但结果不会改变的计算移动到前面不会多次求值的部分的优化方法称为<strong>代码移动</strong>，例如，将循环中可提取的部分移动到循环外。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lower1</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lower2</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] -= (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　理想情况下，编译器会将函数<code>lower1()</code>的循环中的<code>strlen()</code>提取出来，优化为函数<code>lower2()</code>。这需要很复杂的分析，因为<code>strlen()</code>会检查字符串的元素，随着<code>lower1()</code>的执行，这些值会改变。编译器需要检测到，即使字符串的长度在改变，也没有从非0变为0或从0变为非0。即使是使用内联替换，这样的分析也超出了最完善的编译器的能力，所以这样的代码移动必须手动进行。</p>
<p>　　这个示例说明了编程的常见问题之一——看似无足轻重的代码片段有隐藏的<strong>渐进低效</strong>。对于有超过百万个字符的字符串，这段代码将成为主要的性能瓶颈之一。</p>
<h4 id="消除不必要的内存引用">5.1.2 消除不必要的内存引用</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* OP和IDENT由宏定义声明，支持以下2种组合 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">#define OP +</span></span><br><span class="line"><span class="comment">#define IDENT 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">#define OP *</span></span><br><span class="line"><span class="comment">#define IDENT 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine1</span><span class="params">(vec *v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *dest = *dest OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">combine2</span><span class="params">(vec *v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *data = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>combine1()</code>的每次循环都会对内存进行2次读和1次写，这样会浪费性能，因为每次迭代读的值都是上次写的值。这可以通过引入局部变量来解决，就是函数<code>combine2()</code>中的<code>acc</code>，这样可以将每次循环的内存操作减少为1次读。</p>
<h3 id="理解现代cpu">5.2 理解现代CPU</h3>
<p>　　当一系列操作必须严格按照顺序执行时，会遇到<strong>延迟界限</strong>，因为在下一条指令开始前，当前指令必须结束。当代码中的数据依赖限制了CPU的指令并行能力时，延迟界限会限制程序性能。<strong>吞吐量界限</strong>表征CPU功能单元的原始计算能力，这个界限是程序性能的终极界限。</p>
<p>　　最早的乱序CPU是1964年Control Data Corporation的6600
CPU。该CPU的指令由10个不同的功能单元处理，每个单元都能独立地执行。那时，这种时钟频率为10MHz的机器被认为是最好的科学计算机器。</p>
<p>　　1966年，IBM首先在IBM
360/91上实现了乱序处理，但仅用于执行浮点指令。在大约25年的时间里，乱序处理被认为是异类，仅在追求高性能的机器才会使用。直到1990年，IBM在RS/6000系列工作站中重新使用了该技术，并成为了IBM/Motorola
PowerPC系列的基础，1993年推出的型号601成为了第1个使用乱序处理的单芯片CPU。Intel于1995年在PentiumPro中使用了乱序处理。</p>
<h4 id="整体操作">5.2.1 整体操作</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/block_diagram_of_an_out-of-order_cpu.svg" class="">
<p>　　这里展示的CPU设计并不是严格地基于较新的Intel CPU的结构 (这些Intel
CPU在工业界称为<strong>超标量</strong>，表示每个时钟周期可以执行多个操作，而且是<strong>乱序</strong>的，即指令执行顺序不一定与它们在机器级程序中的顺序一致)。乱序CPU有2个主要部分：<strong>指令控制单元</strong>
(ICU) 和<strong>执行单元</strong>
(EU)。前者负责从内存读取指令序列并根据这些指令序列生成1组针对程序数据的基本操作，后者执行这些操作。相比第4章里的<strong>按序</strong>
(流水线)
CPU相比，乱序CPU需要更大、更复杂的硬件，但能更好地达到更高级的指令集并行。</p>
<p>　　ICU从<strong>指令缓存</strong>中读取指令，指令缓存是特殊的高速存储器，其中包含最近访问的指令。ICU通常会提前取出指令，这样才有足够的时间来译码并把操作发送给EU。当程序遇到
(条件移动指令)
分支时，会出现2个可能的方向。现代CPU会使用<strong>分支预测</strong>来预测分支及其目标地址。<strong>取指控制</strong>块包含分支预测，以确定待取出的指令。通过<strong>试探执行</strong>，在确定分支是否正确前，CPU就开始取出并译码预测分支的指令。若确定分支预测错误，会将状态重置为分支点的状态并开始取出和执行另一方向上的指令。</p>
<p>　　<strong>指令译码</strong>块会接收实际的程序指令并转换为1组基本操作
(称为<strong>微操作</strong>)。每个这样的操作仅完成1个简单的任务，例如，加法、从内存读数据和写数据到内存。对于x86等有复杂指令的机器，单条指令可以转换为多个操作，具体操作因机器而异，而且这个过程是高度保密的。</p>
<p>　　操作数都是寄存器的指令只会转换为1个操作。操作数包括内存引用的指令会转换为多个操作来将内存引用和算术运算分开，例如，<code>addq %rax, 8(%rdx)</code>会转换为3个操作，第1个操作将值从内存中加载到CPU，第2个操作将加载的值加上寄存器<code>%rax</code>的值，第3个操作将结果写回内存。这种译码逻辑会将指令拆分，以允许在1组专门的硬件单元之间进行分工，然后这些单元可以并行执行多个指令的不同部分。</p>
<p>　　EU接收来自取指单元的操作。每个周期通常会接收多个操作，这些操作会分派到1组<strong>功能单元</strong>来执行实际的操作。</p>
<p>　　读写内存由加载和存储单元实现，这里的实现中有2个加载单元和1个存储单元。加载单元负责从内存读，其中有加法器来完成地址计算。存储单元负责向内存写，其中也有加法器来完成地址计算。两者都通过<strong>数据缓存</strong>来访问内存，数据缓存是高速存储器，存储着最近访问的数据。加载单元的内部缓存可以存储72个待完成的加载操作，存储单元的内部缓存可以存储42个待完成的存储操作，两者都是<span
style="background-color: yellow">每个时钟周期执行1个操作</span>。</p>
<p>　　使用试探执行对操作求值时，结果不会立即存储到程序寄存器或数据存储器中，只有CPU确定实际应执行的指令时才会存储。分支操作会被送到EU，这样做是为了确定分支预测的正确性而非分支的目标。若预测错误，EU会丢弃分支点后计算的结果，然后发送信号给分支单元告知预测错误并指出正确的分支目标，最后分支单元开始在新的位置取指。由于不同程序之间所需的操作大不相同，算术操作功能单元设计为能执行各种整数和浮点操作的组合。</p>
<p>　　<strong>退役单元</strong>会记录正在执行的处理并确保其遵守机器级程序的顺序语义。除了<strong>寄存器文件</strong>，退役单元还包括整数、浮点以及最近的SSE和AVX寄存器，因为退役单元控制这些寄存器的更新。当指令的操作完成且跳转到该指令的分支点确认预测正确时，该指令会<strong>退役</strong>，<span
style="background-color: yellow">所有对程序寄存器的更新会实际执行</span>。相反，当跳转到该指令的分支点确认预测错误时，该指令会<strong>清空</strong>，丢弃所有计算出来的结果。指令译码时，指令的相关信息存储在1个队列中，直到该指令退役或清空。</p>
<p>　　<strong>操作结果</strong>是为了加快执行单元之间信息交换和将指令结果传递给其他指令的速度，是Y86-64流水线中数据转发的更复杂的形式。</p>
<p>　　控制操作数在执行单元之间移动的最常见的机制是<strong>寄存器重命名</strong>。当更新寄存器<code>r</code>的指令译码时，将生成标记<code>t</code>作为操作结果的唯一标识。同时，会将条目<code>(r, t)</code>加入到维持寄存器<code>r</code>和标记<code>t</code>的关系的<strong>重命名表</strong>。当之后以寄存器<code>r</code>为操作数的指令译码时，发送到执行单元的操作会包含<code>t</code>作为操作数值的源。当某个执行单元完成第1个操作时，会生成结果<code>(v, t)</code>，指明标记为<code>t</code>的操作产生值<code>v</code>。所有等待<code>t</code>做为源的操作都将使用<code>v</code>作为源值，这是数据转发的形式之一。通过这种机制，值可以从某个操作直接转发到其他操作而不必写到寄存器再读，这样第2个操作能在第1个操作完成后尽快完成。</p>
<p>　　重命名表只包含关于写操作的寄存器条目。当译码的指令需要寄存器<code>r</code>且重命名表中没有相关条目时，会直接从寄存器文件中读取。通过寄存器重命名，即使只有在CPU确定了分支结果后才能更新寄存器，也能试探性地执行整个操作序列。</p>
<h4 id="功能单元的性能">5.2.2 功能单元的性能</h4>
<table>
<thead>
<tr>
<th>算术运算</th>
<th>延迟</th>
<th>发出时间</th>
<th>容量</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数加法</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>整数乘法</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>整数除法</td>
<td>3~30</td>
<td>3~30</td>
<td>1</td>
</tr>
<tr>
<td>浮点加法</td>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>浮点乘法</td>
<td>5</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>浮点除法</td>
<td>3~15</td>
<td>3~15</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>　　这是Intel Core i7
Haswell参考机的一些算术运算的性能。<strong>延迟</strong>表示完成运算所需的时间，<strong>发出时间</strong>表示连续
的2个相同类型运算之间的最小时钟周期数，<strong>容量</strong>表示能够执行该运算的功能单元数。发出时间为1的功能单元是<strong>完全流水线化</strong>的。</p>
<p>　　发出时间常用于衡量功能单元的最大吞吐量，即发出时间的倒数。完全流水线化的功能单元有最大的吞吐量。具有多个功能单元可以进一步提高吞吐量。对于容量为<span
class="math inline">\(C\)</span>，发出时间为<span
class="math inline">\(I\)</span>的操作，CPU可能有每个时钟周期<span
class="math inline">\(\frac{C}{I}\)</span>个操作的吞吐量。</p>
<p>　　从整数运算到浮点运算，延迟是增加的。加法和乘法运算的发出时间都是1，即每个时钟周期内，CPU可以开始1条新的这样的运算。这种很短的发出时间是通过流水线实现的。流水线化的功能单元实现了一系列的<span
style="background-color: yellow">阶段</span>，每个阶段完成一部分的运算。例如，典型的浮点加法器包含3个阶段
(所以有3个周期的延迟)，分别用于处理指数值、将小数相加和结果舍入。算术运算可以连续通过各个阶段，只要执行的运算是连续且逻辑上独立的。</p>
<p>　　除法器 (用于整数/浮点除法和计算浮点平方根)
不是完全流水线化的，其发出时间等于延迟，这表示除法器必须完成当前除法后才能开始新的除法。此外，除法的延迟和发出时间不是固定的，因为某些除数和被除数的组合比其他组合需要更多的步骤。</p>
<p>　　这些算术运算的延迟、发出时间和容量会影响组合函数的性能，这里用CPE值的2个基本界限
(延迟和吞吐量) 来描述。</p>
<table>
<thead>
<tr>
<th>算术运算</th>
<th>延迟界限</th>
<th>吞吐量界限</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数加法</td>
<td>1.00</td>
<td>0.50</td>
</tr>
<tr>
<td>整数乘法</td>
<td>3.00</td>
<td>1.00</td>
</tr>
<tr>
<td>浮点加法</td>
<td>3.00</td>
<td>1.00</td>
</tr>
<tr>
<td>浮点乘法</td>
<td>1.00</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>　　延迟界限为任何必须严格按照顺序执行组合操作的函数提供最小CPE值。吞吐量界限根据功能单元可以产生的最大速率为CPE提供最小界限。由于只有1个整数乘法器，其发出时间为1个时钟周期，CPU不可能支持每个时钟周期大于1条乘法的速率。相反，4个功能单元都可以执行整数加法，CPU可以维持每个时钟周期4个加法的速率。但是，2个加载单元限制了CPU每个时钟周期最多只能读2个数据值，所以吞吐量界限是0.50。</p>
<h4 id="cpu操作的抽象模型">5.2.3 CPU操作的抽象模型</h4>
<p>　　<strong>数据流</strong>是图形化的表示方法，可以展示不同操作之间的数据依赖关系如何约束其执行顺序。这些约束形成了图中的<strong>关键路径</strong>，从而成为了执行1组机器指令所需的时钟周期的下限。</p>
<table>
<thead>
<tr>
<th>算术运算</th>
<th><code>combine2()</code></th>
<th>延迟界限</th>
<th>吞吐量界限</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数加法</td>
<td>1.27</td>
<td>1.00</td>
<td>0.50</td>
</tr>
<tr>
<td>整数乘法</td>
<td>3.01</td>
<td>3.00</td>
<td>1.00</td>
</tr>
<tr>
<td>浮点加法</td>
<td>3.01</td>
<td>3.00</td>
<td>1.00</td>
</tr>
<tr>
<td>浮点乘法</td>
<td>5.01</td>
<td>5.00</td>
<td>0.50</td>
</tr>
</tbody>
</table>
<p>　　以函数<code>combine2()</code>为例，除了整数加法，这些值与CPU的延迟界限很接近。这表明函数的性能由其所执行的算术运算的延迟决定。计算<span
class="math inline">\(n\)</span>个元素的加法或乘法大约需要<span
class="math inline">\(L\cdot n+K\)</span>个时钟周期，其中<span
class="math inline">\(L\)</span>是组合操作的延迟，<span
class="math inline">\(K\)</span>是调用函数、初始化和终止循环的开销。因此，CPE约等于延迟界限<span
class="math inline">\(L\)</span>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.L25:</span><br><span class="line">    vmulsd  (%rdx), %xmm0, %xmm0</span><br><span class="line">    addq    $8, %rdx</span><br><span class="line">    cmpq    %rax, %rdx</span><br><span class="line">    jne .L25</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/graphical_representation_of_inner_loop_code_for_combine2.svg" class="">
<p>　　这里将关注循环的计算，因为这是决定较大向量的性能的主要因素。以<code>double</code>类型的乘法组合运算为例
(其他数据类型和运算的组合的结构几乎相同)，循环编译出的代码有4条指令，寄存器<code>%rdx</code>存储指向数组<code>data</code>中第<code>i</code>个元素指针，<code>%rax</code>存储指向数组尾部的指针，<code>%xmm0</code>存储累积值<code>acc</code>。</p>
<p>　　这4条指令会译码为5个步骤，乘法指令会扩展为加载操作
(从内存读源操作数) 和乘法操作 (执行乘法)。</p>
<p>　　图左侧的方框和线给出了各个指令是如何使用和更新寄存器，顶部的方框表示循环开始时寄存器的值，底部的方框表示循环结束时寄存器的值。例如，寄存器<code>%rax</code>只作为操作<code>cmp</code>的源，所以该寄存器在循环结束时的值与循环开始时的值相同。在循环中，寄存器<code>%rdx</code>既被使用也被修改，其初始值被加载和加法操作使用，新值由加法操作产生，然后被操作<code>cmp</code>使用。同样，乘法操作先使用寄存器<code>%xmm0</code>的初始值作为源，然后修改它的值。</p>
<p>　　图右侧的弧线表示某些操作产生的值不对应任何寄存器。加载操作从内存读并把值传递给乘法操作。由于这2个操作是由指令<code>vmulsd</code>译码产生，所以它们之间传递的值没有相关的寄存器。操作<code>cmp</code>会更新CC，然后操作<code>jne</code>判断CC。</p>
<p>　　循环中访问的寄存器可分为<span
style="background-color: yellow">只读</span>、<span
style="background-color: yellow">只写</span>、<span
style="background-color: yellow">局部</span>和<span
style="background-color: yellow">循环</span>寄存器。</p>
<p>　　●
只读寄存器能作为源和数据，也能用于计算内存地址，但在循环中不会被修改，例如，函数<code>combine2()</code>中的寄存器<code>%rax</code>。</p>
<p>　　● 只写寄存器作为数据移动操作的目的地。</p>
<p>　　●
局部寄存器会在循环中被使用和更新，但迭代之间局部寄存器没有依赖，例如，函数<code>combine2()</code>中的CC，操作<code>cmp</code>会修改它们，然后操作<code>jne</code>会使用它们，不过这种依赖都是单次迭代之内。</p>
<p>　　●
循环寄存器能作为源和目的地，并且迭代之间循环寄存器有依赖，例如，函数<code>combine2()</code>中的寄存器<code>%rdx</code>和<code>%xmm0</code>，对应程序值<code>data + i</code>和<code>acc</code>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/abstracting_combine2_operations_as_a_data_flow_graph.svg" class="">
<p>　　这是对图形表示的进一步改进，只给出影响执行时间的操作和数据依赖。此外，还重新排列了操作符，以更清晰地表示从顶部寄存器
(只读寄存器和循环寄存器) 到底部寄存器 (只写寄存器和循环寄存器)
的数据流。</p>
<p>　　图中将不属于循环寄存器依赖链的操作标记为<span
style="background-color: yellow">白色</span>。例如，图(a)的操作<code>cmp</code>和<code>jne</code>不直接影响程序中的数据流。这里假设ICU分支预测正确，所以会继续循环。操作<code>cmp</code>和<code>jne</code>用于是判断分支条件和分支预测错误时通知ICU
(假设判断所需时间短到足以忽略不计)。</p>
<p>　　图(b)去除了图(a)中白色的操作，只保留了循环寄存器，得到表示单次迭代在循环寄存器之间的数据依赖的抽象模板。这里迭代之间有2个数据依赖，左侧的<code>acc</code>旧值乘以加载操作生成的数据元素得到<code>acc</code>新值，右侧<code>i</code>的旧值用于计算加载操作的地址，加法操作会增加<code>i</code>的旧值来计算<code>i</code>的新值。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/data_flow_representation_of_computation_by_n_iterations_of_the_inner_loop_of_combine2.svg" class="">
<p>　　重复数据流图(b)的模板<span
class="math inline">\(n\)</span>次后，可以得到2条数据依赖链，分别对应乘法和加法操作对程序值<code>acc</code>和<code>data + i</code>的修改。假设浮点乘法延迟为5，整数加法延迟为1，左侧的依赖链会成为关键路径，因为左侧的依赖链需要<span
class="math inline">\(5n\)</span>个周期执行，而右侧的依赖链仅需要<span
class="math inline">\(n\)</span>个周期执行。</p>
<p>　　还有一些因素会限制性能，例如，可用的功能单元数量和任何给定步骤中能在功能单元之间传递的数据数量。将整数加法作为组合运算时，数据操作速度大于数据供应速度，所以每个元素的处理时间为1.27个周期。</p>
<h3 id="循环展开">5.3 循环展开</h3>
<p>　　循环展开能从2方面提升程序的性能，首先，减少了不直接影响程序结果的操作的数量，例如，循环索引计算和条件分支。其次，揭示了可以进一步转换代码以减少整体计算的关键路径中的操作数量的方法。</p>
<p>　　当优化等级达到3或更高时，gcc会执行循环展开。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine3</span><span class="params">(vec *v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = (acc OP data[i]) OP data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *data = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是函数<code>combine2()</code>的<span
class="math inline">\(2\times
1\)</span>循环展开版本，即每次循环将循环索引加2并对向量元素<code>i</code>和<code>i + 1</code>使用组合运算。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/cpe_performance_for_k%C3%971_loop_unrolling.svg" class="">
<p>　　对于<span class="math inline">\(k\times
1\)</span>循环展开，向量的长度不一定是<span
class="math inline">\(k\)</span>的整数倍，要确保循环时数值不会越界。为此，对于长度为<span
class="math inline">\(n\)</span>的数值，循环界限设置为<span
class="math inline">\(n-k+1\)</span>，每次循环时索引增加<span
class="math inline">\(k\)</span>，最后将剩下的元素以每次处理1个元素的方式进行循环。根据上图可以得到，对于整数加法，<span
class="math inline">\(2\times1\)</span>循环展开的性能就达到了峰值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.L35:</span><br><span class="line">    vmulsd  (%rax, %rdx, 8), %xmm0, %xmm0</span><br><span class="line">    vmulsd  8(%rax, %rdx, 8), %xmm0, %xmm0</span><br><span class="line">    addq    $2, %rdx</span><br><span class="line">    cmpq    %rdx, %rbp</span><br><span class="line">    jg  .L35</span><br></pre></td></tr></table></figure>
<p>　　这是当<code>data_t</code>为<code>double</code>且操作为乘法时函数<code>combine3()</code>循环部分对应的汇编代码。指令<code>vmulsd</code>出现了2次，分别将<code>data[i]</code>和<code>data[i + 1]</code>乘以<code>acc</code>。每条<code>vmulsd</code>指令会译码为加载操作和乘法操作。相比循环2次，这种<span
class="math inline">\(2\times1\)</span>循环展开仅减少了1个加法操作，而关键路径上的乘法操作并没有减少，所以并没有性能提升。</p>
<p>　　加法和乘法功能单元是完全流水线化的，硬件有能以更高速率执行加成和乘法的潜能，但之前的代码并不能利用这种能力，因为累积值存储在单独的变量<code>acc</code>中，受到组合操作的延迟的限制。</p>
<h4 id="多个累积变量">5.3.1 多个累积变量</h4>
<p>　　对于可交换和可结合的组合运算，可以将其分为2个及以上部分分别计算，最后将结果合并。</p>
<p>　　<span class="math inline">\(P_n\)</span>表示元素<span
class="math inline">\(a_0,a_1,...,a_{n-1}\)</span>的乘积。 <span
class="math display">\[
P_n=\prod^{n-1}_{i=0}a_i
\]</span> 　　若<span class="math inline">\(n\)</span>为偶数，<span
class="math inline">\(P_n\)</span>还可以写为<span
class="math inline">\(P_n=PE_n\times PO_n\)</span>，<span
class="math inline">\(PE_n\)</span>是索引值为偶数的元素的乘积，<span
class="math inline">\(PO_n\)</span>是索引值为奇数的元素的乘积。 <span
class="math display">\[
\begin{align}
PE_n&amp;=\prod^{n/2-1}_{i=0}a_{2i}\\[3px]
PO_n&amp;=\prod^{n/2-1}_{i=0}a_{2i+1}
\end{align}
\]</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine4</span><span class="params">(vec *v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc0 = IDENT;</span><br><span class="line">    <span class="type">data_t</span> acc1 = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">        acc1 = acc1 OP data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *data = acc0 OP acc1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/graphical_representation_of_inner_loop_code_for_combine4.svg" class="">
<p>　　这是函数<code>combine2()</code>的<span
class="math inline">\(2\times
2\)</span>循环展开版本。相比函数<code>combine3()</code>，它将累积值拆分为<code>acc0</code>和<code>acc1</code>，最后再合并。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/abstracting_combine4_operations_as_a_data_flow_graph.svg" class="">
<p>　　函数<code>combin4()</code>的循环中指令<code>vmulsd</code>出现了2次，但是这些指令译码为读写不同寄存器的乘法操作，它们之间没有数据依赖。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/data_flow_representation_of_combine4_operating_on_a_vector_of_length_n.svg" class="">
<p>　　这里有2条关键路径，分别对应索引值为偶数的元素的乘积
(程序值<code>acc0</code>) 和索引值奇数的元素的乘积
(程序值<code>acc1</code>)。每条关键路径只包含<span
class="math inline">\(\frac{n}{2}\)</span>个操作，所以CPE也会减半。同样，延迟为<span
class="math inline">\(L\)</span>的操作的CPE约为<span
class="math inline">\(\frac{L}{2}\)</span>。整数加法由于循环开销，无法达到理论界限0.50。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/cpe_performance_for_k%C3%97k_loop_unrolling.svg" class="">
<p>　　对于<span class="math inline">\(k\times
k\)</span>循环展开，当<span
class="math inline">\(k\)</span>足够大时，程序在任何情况几乎都能达到吞吐量界限。整数加法在<span
class="math inline">\(k=7\)</span>时，CPE达到0.54，接近2个加载单元的吞吐量界限0.5。整数乘法和浮点加法在<span
class="math inline">\(k=3\)</span>时，CPE达到1.01，接近其功能单元的吞吐量界限1.00。浮点乘法在<span
class="math inline">\(k=10\)</span>时，CPE达到0.51，接近2个浮点乘法器和2个加载单元的吞吐量界限0.50。</p>
<p>　　通常，只有程序能保持执行某个操作的所有功能单元的流水线都是满载时，才能达到该操作的吞吐量界限，即对于延迟为<span
class="math inline">\(L\)</span>，容量为<span
class="math inline">\(C\)</span>的操作，需满足循环展开因子<span
class="math inline">\(k\geqslant C\cdot L\)</span>。</p>
<p>　　在进行<span class="math inline">\(k\times
k\)</span>循环展开时，需要考虑结果与原始函数的是否相同。第2章提到过，补码运算是可交换和可结合的，即使溢出亦是如此。因此，整数类型<span
class="math inline">\(k\times k\)</span>循环展开前后结果<span
style="background-color: yellow">相同</span>。相反，由于舍入或溢出，浮点乘法和加法是不可结合的，因此，浮点类型<span
class="math inline">\(k\times k\)</span>循环展开前后结果<span
style="background-color: yellow">可能不同</span>。</p>
<h4 id="重新结合变换">5.3.2 重新结合变换</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">combine5</span><span class="params">(vec *v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(v);</span><br><span class="line">    <span class="type">long</span> limit = length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> acc = IDENT;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = acc OP (data[i] OP data[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *data = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　相比函数<code>combine3()</code>，函数<code>combine5()</code>仅改变了第10行代码中括号的位置，这种变换称为<strong>重新结合变换</strong>，因此，改变了向量元素和累积值<code>acc</code>的合并顺序，产生了<span
class="math inline">\(2\times 1a\)</span>循环展开。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/graphical_representation_of_inner_loop_code_for_combine5.svg" class="">
<p>　　前2条指令译码的加载操作从内存中加载向量元素<code>i</code>和<code>i + 1</code>，第1个乘法操作将它们相乘，第2个乘法操作将结果乘以累积值<code>acc</code>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/abstracting_combine5_operations_as_a_data_flow_graph.svg" class="">
<p>　　函数<code>combine5()</code>虽然有2个乘法操作，但只有1个乘法操作形成了循环寄存器之间的数据依赖链。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/data_flow_representation_of_combine5_operating_on_a_vector_of_length_n.svg" class="">
<p>　　函数<code>combine5()</code>的关键路径上只有<span
class="math inline">\(\frac{n}{2}\)</span>个操作，每次迭代的第1个乘法操作无需等待前一次迭代的结果就可以执行，所以CPE减半。</p>
<p>　　<span class="math inline">\(k\times
1a\)</span>循环展开的性能提升与<span class="math inline">\(k\times
k\)</span>循环展开的差不多。同样，整数类型在<span
class="math inline">\(k\times1a\)</span>循环展开前后结果相同，浮点类型在<span
class="math inline">\(k\times1a\)</span>循环展开前后结果可能不同。</p>
<h4 id="其他限制因素">5.3.3 其他限制因素</h4>
<p>　　循环并行性受到汇编代码描述计算的能力的限制。若并行度<span
class="math inline">\(p\)</span>超过了可用寄存器数量，编译器会诉诸<strong>溢出</strong>，将某些临时值存储在内存中，通常在运行时栈上分配空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmovsd	40(%rsp), %xmm0</span><br><span class="line">vmulsd	(%rdx), %xmm0, %xmm0</span><br><span class="line">vmovsd	%xmm0, 40(%rsp)</span><br></pre></td></tr></table></figure>
<p>　　这是函数<code>combine4()</code>的多累积变量模式扩展到<span
class="math inline">\(k=20\)</span>时循环部分对应的汇编代码，累积值<code>acc</code>保存在栈内，栈指针偏移量为40。程序必须从内存中读<code>acc</code>和<code>data[i]</code>，将它们相乘并将结果写回内存。相比扩展到<span
class="math inline">\(k=10\)</span>，这种循环展开性能更差。</p>
<p>　　一旦编译器诉诸寄存器溢出，维护多个累积变量带来的性能提升很可能消失。但是，x86-64有足够的寄存器，大多数循环在出现寄存器溢出前就达到了吞吐量限制。</p>
<p>　　现代CPU中的分支预测逻辑很擅长识别不同分支指令的<span
style="background-color: yellow">常规模式和长期趋势</span>。例如，在组合函数循环中分支预测逻辑通常会选择继续循环的分支，所以只有最后一次循环会出现分支预测错误。另一个例子就是检测数组边界的条件语句，分支预测逻辑通常会选择数组在界的分支。</p>
<p>　　很多判断是完全不可预测的，它们取决于数据的任意特征。例如，对于判断正负，若编译器能产生使用数据的条件移动的汇编代码，可以极大地提升性能。第3章提到过，编译器无法完成这种优化，所以只能手动优化。</p>
<h3 id="理解内存性能">5.4 理解内存性能</h3>
<p>　　包含加载操作的程序的性能受限于流水线的性能和加载单元的延迟。若函数<code>combine2()</code>在之前的乱序CPU上运行，由于每个待计算的元素都会从内存读1次值，无论如何优化，最后CPE都不会低于0.50。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_element</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">list_len</span><span class="params">(list_element *ls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>list_len()</code>会计算链表的长度，在该函数的循环中<code>ls</code>的后继元素依赖指针引用<code>ls-&gt;next</code>读出的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ls存储在寄存器%rdi，len存储在寄存器%rax</span><br><span class="line">.L3:</span><br><span class="line">    addq    $1, %rax</span><br><span class="line">    movq    (%rdi), %rdi</span><br><span class="line">    testq   %rdi, %rdi</span><br><span class="line">    jne .L3</span><br></pre></td></tr></table></figure>
<p>　　这是函数<code>list_len()</code>循环部分对应的汇编代码。指令<code>movq</code>是该循环的瓶颈，因为之后寄存器<code>%rdi</code>的每个值都依赖加载操作的结果，但加载操作的地址是<code>%rdi</code>。因此，上一次循环的加载操作完成后才能开始下一次循环的加载操作，这也决定了该函数的CPE是4.00。</p>
<p>　　存储操作与加载操作对应，但存储操作只能能影响加载操作。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/detail_of_load_and_store_units.svg" class="">
<p>　　存储单元有1个<strong>存储缓冲区</strong>，其中包含已经达到存储单元但还未完成
(这里的完成包括更新数据缓存)
的存储操作的地址和数据。通过存储缓冲区，可以执行一系列存储操作而无需等待每个操作都更数据缓存。当执行加载操作时，必须检测存储缓冲区中的条目以查找匹配的地址。若有匹配项
(表示正在写的数据和读的数据有相同的地址)，将取出对应的数据条目作为加载操作的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_read</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dst, <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> cnt = n;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst = val;</span><br><span class="line">        val = (*src) + <span class="number">1</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/graphical_representation_of_inner_loop_code_for_write_read.svg" class="">
<p>　　函数<code>write_read()</code>的循环部分对应的汇编代码中，第1个指令<code>movq</code>译码为2个操作，操作<code>s_addr</code>计算存储操作的地址并在存储缓冲区插入1个条目
(包括设置该条目的地址字段)，操作<code>s_data</code>设置该条目的数据字段，这2个操作独立执行。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/abstracting_write_read_operations_as_a_data_flow_graph.svg" class="">
<p>　　图(a)中标签为 "1" 的线表示数据存储前必须先计算出存储地址，标签为
"2"
的线表示加载操作必须先将其地址和所有待完成的存储操作的地址进行匹配，<span
style="background-color: yellow">若匹配</span>，则会出现标签为 "3"
的线，表示数据依赖。图(b)中有2条依赖链，左侧的是存储、加载和增加数据值
(地址匹配)
形成的数据依赖，右侧的是减小变量<code>cnt</code>形成的数据依赖。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/data_flow_representation_of_write_read.svg" class="">
<p>　　当函数<code>write_read()</code>的参数<code>src</code>和<code>dst</code>不同时
(对应左侧)，加载和存储操作可以独立进行，唯一的关键路径源于减小变量<code>cnt</code>，CPE为1。当函数<code>write_read()</code>的参数<code>src</code>和<code>dst</code>相同时
(对应右侧)，存储、加载和增加操作也形成了关键路径，CPE变为7。</p>
<h3 id="确认和消除性能瓶颈">5.5 确认和消除性能瓶颈</h3>
<p>　　至此，只考虑了优化较小的程序。在处理较大的程序时，确定待优化的地方并不简单。</p>
<p>　　<strong>代码剖析程序</strong>运行插入检测代码后的程序，以确定程序的各个部分执行所需时间，可以在实际基准数据上运行实际程序的同时进行剖析。</p>
<p>　　UNIX系统提供了剖析程序GPROF。该程序会提供2种形式的信息。首先，它会确定每个函数的执行时间。其次，它计算每个函数的被调用次数并以调用函数来分类。Intel的VTUNE和Linux的VALGRIND是更完善的剖析程序，可以估计程序每个<strong>基本块</strong>
(没有控制转移的指令序列) 的性能。</p>
<h4 id="程序剖析">5.5.1 程序剖析</h4>
<p>　　用GPROF剖析需要3个步骤，这里以<code>prog.c</code>为例，其命令行参数为<code>file.txt</code>。</p>
<p>　　1)
程序在剖析前需要先编译和链接。对于gcc，就是简单地使用命令行选项<code>-pg</code>。为了保证不使用内联替换，使用优化等级<code>-Og</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Og -pg prog.c -o prog</span></span><br></pre></td></tr></table></figure>
<p>　　2) 执行程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./prog file.txt</span></span><br></pre></td></tr></table></figure>
<p>　　3) 调用GPROF来分析<code>gmon.out</code>中的数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gprof prog</span></span><br></pre></td></tr></table></figure>
<p>　　剖析报告的第1部分是各个函数按降序排序的执行时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%       cumulative  self                self    total</span><br><span class="line">time    seconds     seconds calls       s/call  s/call  name</span><br><span class="line">97.58   203.66      203.66  1           203.66  203.66  sort_words</span><br><span class="line">2.32    208.50      4.85    965027      0.00    0.00    find_ele_rec</span><br><span class="line">0.14    208.81      0.30    12511031    0.00    0.00    Strlen</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，函数<code>sort_words()</code>仅被调用了1次，用时203.66秒，而函数<code>find_ele_rec()</code>被调用了965027次
(不包括递归调用)，用时4.85秒。函数<code>Strlen()</code>通过调用库函数<code>strlen()</code>来计算字符串的长度。GPROF的剖析报告中通常不显示库函数调用。<span
style="background-color: yellow">库函数执行时间通常计算在调用它们的函数内</span>。这里创建包装函数<code>Strlen()</code>来追踪库函数<code>strlen()</code>的调用，库函数<code>strlen()</code>被调用了12511031次，用时0.30秒。</p>
<p>　　剖析报告的第2部分是函数的 (被) 调用历史。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                158655725           find_ele_rec [5]</span><br><span class="line">                4.85    0.10    965027/965027       insert_string [4]</span><br><span class="line">[5]     2.4     4.85    0.10    965027+158655725    find_ele_rec [5]</span><br><span class="line">                0.08    0.01    363039/363039       save_string [8]</span><br><span class="line">                0.00    0.01    363039/363039       new_ele [12]</span><br><span class="line">                                158655725           find_ele_rec [5]</span><br></pre></td></tr></table></figure>
<p>　　这是递归函数<code>find_ele_rec()</code>的 (被)
调用历史。前2行显示的是该函数的被调用信息，自身递归调用158655725次，被函数<code>insert_string()</code>调用965027次
(该函数本身被调用965027次)。函数<code>find_ele_rec()</code>也调用了其他函数：函数<code>save_string()</code>和<code>find_ele_rec()</code>
(都是363039次)。</p>
<p>　　GPROF的计时基于简单的<strong>间隔计数</strong>机制，
编译后的程序为每个函数维护计数器来记录该函数的执行时间。操作系统会让程序在固定时间间隔<span
class="math inline">\(\delta\)</span>后中断1次
(通常是1.0~10.0ms)。当中断发生时，会将程序中正在执行的函数的计数器值增加<span
class="math inline">\(\delta\)</span>。对于执行时间小于<span
class="math inline">\(\delta\)</span>的函数，可能在其执行时发生中断，其执行时间会被设置为<span
class="math inline">\(\delta\)</span>，也可能刚好在中断间隔内完成执行，以至于根本没有记录执行时间。在没有执行内联替换时，编译后的程序会为每对调用者和被调用者维护计数器。每次调用过程时，其对应的计数器会加1。</p>
<h4 id="程序优化示例">5.5.2 程序优化示例</h4>
<p>　　这里以包括几个不同任务和数据结构的程序为例，该程序分析文本文档的n-gram统计信息，n-gram是文档中出现<span
class="math inline">\(n\)</span>个单词的序列。当<span
class="math inline">\(n=1\)</span>时，收集每个单词的统计信息，当<span
class="math inline">\(n=2\)</span>时，收集每对单词的统计信息，依此类推。对于给定的<span
class="math inline">\(n\)</span>，程序会读文本文档，创建不同的n-gram的表，包括每个n-gram出现的次数并按出现次数降序对单词排序。</p>
<p>　　作为基准程序，使用《莎士比亚全集》来运行该程序，《莎士比亚全集》共有965028个单词，其中有23706个不同的单词。当<span
class="math inline">\(n=1\)</span>时，即使性能很差的程序也能在1s内处理，所以这里设置<span
class="math inline">\(n=2\)</span>。在这种情况下，n-gram称为bigram。《莎士比亚全集》有363039个不同的bigram。最常见的是
"I am"，出现了1892次。</p>
<p>　　程序由多个部分组成，这里会创建多个版本，从各部分最简单的算法开始，逐渐换成更成熟完善的算法。</p>
<p>　　1)
从文件中读取每个单词并转换为小写。初始版本使用函数<code>lower1()</code>。</p>
<p>　　2) 对字符串使用散列函数，为有<span
class="math inline">\(s\)</span>个桶的散列表产生1个0到<span
class="math inline">\(s-1\)</span>之间的数。初始版本只是简单对字符的ASCII码求和再对<span
class="math inline">\(s\)</span>取模。</p>
<p>　　3)
每个散列桶都组成1个链表。程序对该链表扫描，寻找匹配的条目。若找到，该n-gram的频率加1。否则，创建1个新的链表元素。初始版本使用递归完成该操作，将新元素插在链表尾部。</p>
<p>　　4)
一旦生成这张表，根据频率对所有的元素排序。初始版本使用插入排序。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_05/profile_results_for_different_versions_of_bigram_frequency_counting_program.svg" class="">
<p>　　Sort表示排序所需时间，List表示匹配链表所需时间，Lower表示转换为小写所需时间，Strlen表示计算字符串长度所需时间，Hash表示计算散列函数所需时间，Rest表示计算所有其他函数的和所需时间。</p>
<p>　　初始版本用时约3.5分钟，大多数时间都花在排序上。在第2个版本
"QuickSort"
中，使用了库函数<code>qsort()</code>来排序，该函数基于快速排序，其时间复杂度是<span
class="math inline">\(O(n\log_2n)\)</span>，该版本用时约5.4秒。</p>
<p>　　改进排序后，链表扫描成为瓶颈，这是由于函数的递归结构，这里用迭代结构替换，得到第3个版本
"Iter first"，该版本用时约7.5秒
(因为新元素插入到链表头部)。为了最大化性能，频率最高的n-gram应该在链表的头部，即新元素应该插入到链表尾部，得到第4个版本
"Iter last"，该版本用时约5.3秒。</p>
<p>　　然后，优化散列表的结构，初始版本只有1021个桶
(桶的个数通常是质数，以增强散列函数将关键字均匀分布在桶的能力)，这里将桶的数量增加到199999，得到第4个版本
"Big table"，该版本用时约5.1秒。</p>
<p>　　即使散列桶变大了，性能提升很小，这是因为散列函数性能较差。字母的最大编码值是122，<span
class="math inline">\(n\)</span>个字符产生的和最多是<span
class="math inline">\(122n\)</span>，而最长的bigram的和也只有3371，大部分桶都是未被使用的。此外，可交换的散列函数可能对不同的关键字生成相同的散列值，例如，"rat"
和 "tar"。散列函数替换为使用移位和异或的散列函数，得到第5个版本 "Better
hash"，该版本用时约0.6秒。</p>
<p>　　最后，将字母转换为小写成为瓶颈，将函数<code>lower1()</code>替换为函数<code>lower2()</code>得到第6个版本
"Linear lower"，该版本用时约0.2秒。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第4章 处理器体系架构</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_04/</url>
    <content><![CDATA[<p>　　CPU支持的指令及其字节级编码称为该CPU的<strong>指令集体系结构</strong>。定义指令集体系结构包括定义各种状态单元、指令集、指令集编码、编码规范和异常事件处理。</p>
<p>　　x86-64也称为<span
style="background-color: yellow">复杂指令集计算机</span> (CISC)，与<span
style="background-color: yellow">精简指令集计算机</span> (RISC)
相对。从历史角度，先出现了CISC，它从最早的计算机演化而来。到20世纪80年代早期，随着计算机设计者加入了很多新指令来支持高级任务
(例如，处理循环缓存、执行十进制数计算和多项式求值)，计算机的指令集已经变得很庞大。最早的CPU出现在20世纪70年代早期，因为当时的集成电路技术极大地限制了芯片的功能，其指令集很有限。CPU发展得很快，到20世纪80年代早期，计算机的指令集复杂度一直都在增加。x86家族沿着这条道路发展到IA32，然后是x86-64。即使是x86系列也仍在不断地变化，基于新出现的应用的需求，添加新的指令类。</p>
<p>　　RISC (发音为risk)
的设计理念发展于20世纪80年代早期，作为上述发展趋势的代替方案。IBM的一些硬件和编译器专家深受IBM研究员John
Cocke的影响，认为可以为更简单的指令集形式生成高效的代码。实际上，很多加到指令集中的高级指令很难被编译器生成，所以很少被用到。较简单的指令集可以用更少的硬件实现，能以高效的流水线结构组织起来。直到多年后，IBM才将这个理念商品化，开发了Power和PowerPC
ISA。加州大学伯克利分校的David Patterson和斯坦福大学的John
Hennessy进一步发展了RISC的概念。Patterson将这种新的机器类型命名为RISC，而将之前的那种机器命名为CISC，因为以前没有必要为1种几乎通用的指令集命名。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>CISC</th>
<th>早期RISC</th>
</tr>
</thead>
<tbody>
<tr>
<td>指令数量很多。</td>
<td>指令数量很少，通常少于100个。</td>
</tr>
<tr>
<td>有些指令的执行时间很长，包括将整个块从内存的某个部分复制到其他部分的指令以及将多个寄存器的值复制到内存或从内存复制到多个寄存器的指令。</td>
<td>没有执行时间较长的指令。部分早期的RISC甚至没有整数乘法指令，要求编译器通过加法来实现。</td>
</tr>
<tr>
<td>编码长度可变，x86-64的指令长度可以是1~15B。</td>
<td>编码长度固定，通常所有的指令都编码为4B。</td>
</tr>
<tr>
<td>指定操作数的形式多样，x86-64中的内存引用可以包括偏移量、基址寄存器、变址寄存器和伸缩因子。</td>
<td>寻址方式简单，通常只有基址和偏移量寻址。</td>
</tr>
<tr>
<td>可以对内存引用和寄存器操作数进行算术和逻辑运算。</td>
<td>只能对寄存器操作数进行算术和逻辑运算。允许使用内存引用操作数的指令只有<code>load</code>和<code>store</code>，<code>load</code>是从内存读数据到寄存器，<code>store</code>是从寄存器写数据到内存，这种方法称为load/store体系结构。</td>
</tr>
<tr>
<td>实现细节对机器级程序不可见。ISA提供了程序和执行细节之间的清晰的抽象。</td>
<td>实现细节对机器级程序可见。有些RSIC机器禁止某些特殊的指令序列，而有些跳转指令要到下一条指令执行完后才会生效。编译器必须在这些约束条件下进行性能优化。</td>
</tr>
<tr>
<td>有条件码。作为指令执行的副产品，设置了一些特殊的标志位，用于条件跳转判断。</td>
<td>没有条件码。对于条件判断，要用明确的判断指令，这些指令会将判断结果存储1个普通寄存器中。</td>
</tr>
<tr>
<td>栈密集的过程链接。栈用于存取过程参数和返回地址。</td>
<td>寄存器密集的过程链接。寄存器用于存取过程参数和返回地址，所以有些过程无需内存引用。CPU通常有更多的寄存器
(最多32个)。</td>
</tr>
</tbody>
</table>
<p>　　20世纪80年代，计算机体系结构领域里关于RISC指令集和CISC指令集优缺点的争论十分激烈。RISC的支持者声称在给定硬件数量的情况下，通过结合简化的指令集设计、高级编译器技术和流水线化的CPU实现，RISC能获得更强的计算性能。CISC的拥趸反驳称完成给定任务需要的RISC指令更少，所以RISC有更强的总体性能。20世纪90年代早期，争论逐渐平息，因为事实很清楚，单独的RISC或CISC都不如结合两者的精华。CISC后来的发展中加入了很多的指令
(包括需要多个执行周期的指令)
和高性能流水线结构。现在的RISC指令集中有数百条指令，几乎与其名称不相匹配，而那种将实现细节暴露给机器级程序的思想已经被证明是目光短浅的。</p>
<p>　　大多数公司都推出了RISC CPU系列产品，包括Sun Microsystem
(SPARC)、IBM和Motorola (PowerPC) 以及Digital Equipment Corporation
(Alpha)。英国公司Acorn Computer Ltd.推出了自己的体系结构Acorn RISC
Machine (ARM)，广泛应用于嵌入式系统中。</p>
<p>　　Y86-64指令集兼具CISC和RISC指令集的特点。和CISC一样，它有条件码和长度可变的指令，并且用栈来保存返回地址。和RISC一样的是，它使用load/store体系结构和常规指令编码，并且通过寄存器来传递过程参数。Y86-64指令集可以视为根据某些RISC原理简化后CISC指令集
(x86)。</p>
<p>　　从头到尾执行1条指令所需的时间称为<strong>延迟</strong>。在现代逻辑设计中，电路延迟以微微秒或皮秒
(<span class="math inline">\(10^{-12}\)</span>s) 为单位来计算。</p>
<p>　　会导致异常的指令称为<strong>异常指令</strong>。</p>
<span id="more"></span>
<h3 id="y86-64指令级体系结构">4.1 Y86-64指令级体系结构</h3>
<p>　　Y86-64程序中的每条指令都会读取或修改CPU状态的某些部分，这些部分称为<strong>程序员可见状态</strong>
(这里的程序员包括用汇编代码编写程序的人和生成机器级代码的编译器)。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/y86-64_programmer_visible_state.svg" class="">
<p>　　Y86-64的状态类似于x86-64，有15个程序寄存器、3个1位的CC、PC、程序状态和内存。相比x86-64，Y86-64省略了寄存器<code>%r15</code>，每个寄存器存储64位的字。CC存储最近的算术或逻辑指令所造成影响的相关信息。PC存储当前正在执行指令的地址。程序状态表明程序执行的总体状态，指示程序是正常运行还是出现了异常。从概念角度，内存是很大的字节数组，保存着程序和数据。Y86-64程序用<strong>虚拟地址</strong>来引用内存。硬件和操作系统软件协同工作来将虚拟地址转换成实际/物理地址，指明数据实际存储位置。</p>
<table>
<thead>
<tr>
<th>十六进制数</th>
<th>寄存器名称</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x0</code></td>
<td><code>%rax</code></td>
</tr>
<tr>
<td><code>0x1</code></td>
<td><code>%rcx</code></td>
</tr>
<tr>
<td><code>0x2</code></td>
<td><code>%rdx</code></td>
</tr>
<tr>
<td><code>0x3</code></td>
<td><code>%rbx</code></td>
</tr>
<tr>
<td><code>0x4</code></td>
<td><code>%rsp</code></td>
</tr>
<tr>
<td><code>0x5</code></td>
<td><code>%rbp</code></td>
</tr>
<tr>
<td><code>0x6</code></td>
<td><code>%rsi</code></td>
</tr>
<tr>
<td><code>0x7</code></td>
<td><code>%rdi</code></td>
</tr>
<tr>
<td><code>0x8</code></td>
<td><code>%r8</code></td>
</tr>
<tr>
<td><code>0x9</code></td>
<td><code>%r9</code></td>
</tr>
<tr>
<td><code>0xA</code></td>
<td><code>%r10</code></td>
</tr>
<tr>
<td><code>0xB</code></td>
<td><code>%r11</code></td>
</tr>
<tr>
<td><code>0xC</code></td>
<td><code>%r12</code></td>
</tr>
<tr>
<td><code>0xD</code></td>
<td><code>%r13</code></td>
</tr>
<tr>
<td><code>0xE</code></td>
<td><code>%r14</code></td>
</tr>
<tr>
<td><code>0xF</code></td>
<td>无寄存器</td>
</tr>
</tbody>
</table>
<p>　　Y86-64的15个程序寄存器都有对应的<strong>寄存器ID</strong>
(范围在<code>0x0</code>~<code>0xE</code>之间)。程序寄存器存在CPU中的寄存器文件中，寄存器文件是以寄存器ID作为地址的存储器。当不需要存取寄存器时，用ID值<code>0XF</code>表示。</p>
<h4 id="y86-64指令">4.1.1 Y86-64指令</h4>
<p>　　Y86-64指令集可以视为是x86-64指令集的子集，它只包括8B整数操作，并且寻址方式和操作更少。由于仅使用8B的数据，所以把<span
style="background-color: yellow">8B的数据称为字</span>也不会有任何歧义。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/y86-64_instruction_set.svg" class="">
<p>　　对于Y86-64，有些指令只有1B，而其他指令更长。首先，可能有额外的<strong>寄存器指示符字节</strong>，用于指定1或2个寄存器：<code>rA</code>和<code>rB</code>。对于只有1个寄存器的指令，另一个寄存器ID为<code>0xF</code>。其次，可能有额外的8B<strong>常数字</strong>，可作为立即数、指令<code>rmmovq</code>和<code>mrmovq</code>的地址指示符的偏移量以及跳转指令和调用指令的目的地址。</p>
<p>　　Y86-64的跳转指令和调用指令的目的地址是<span
style="background-color: yellow">绝对地址</span>，而非像IA32中那样使用PC相对寻址。CPU使用PC相对寻址时，跳转指令的编码会更简洁，同时能允许代码从内存的某部分复制到其他部分而无需更新所有的分支目标地址。</p>
<p>　　Y86-64中的所有整数都是小端编码。例如，用十六进制编码<code>rmmovq  %rsp, 0x123456789abcd(%rdx)</code>时，第1个字节是<code>0x40</code>，栈指针在字段<code>rA</code>中，<code>%rdx</code>在字段<code>rB</code>中，需要偏移量在前面填上<code>0x0</code>使之变成8B，最后结果为<code>0x4042cdab896745230100</code>。</p>
<p>　　Y86-64的数据移动指令<code>movq</code>包括<code>irmovq</code>、<code>rrmovq</code>、<code>mrmovq</code>和<code>rmmovq</code>，其名称中的前2个字母分别表示源和目的操作数的格式，<code>i</code>表示立即数，<code>r</code>表示寄存器，<code>m</code>表示内存引用。内存引用是简单的基址和偏移量形式，<span
style="background-color: yellow">不支持</span>第2变址寄存器和寄存器值的伸缩。同x86-64一样，不允许将立即数移动到内存和直接将数据从某个内存位置移动到其他内存位置。</p>
<p>　　Y86-64的整数操作指令<code>OPq</code>包括<code>adq</code>、<code>subq</code>、<code>andq</code>和<code>xorq</code>，它们<span
style="background-color: yellow">只对寄存器数据进行操作</span>，会设置CC中的零标志ZF、符号标志SF和溢出标志OF。x86-64的同类指令还可以对内存数据进行操作。</p>
<p>　　Y86-64的跳转指令<code>jXX</code>包括<code>jmp</code>、<code>jle</code>、<code>jl</code>、<code>je</code>、<code>jne</code>、<code>jge</code>和<code>jg</code>，根据分支指令的类型和CC的值来选择分支，分支条件和x86-64相同。</p>
<p>　　Y86-64的条件移动指令<code>cmovXX</code>包括<code>cmovle</code>、<code>cmovl</code>、<code>cmove</code>、<code>cmovne</code>、<code>comvge</code>和<code>cmovg</code>，这些指令的操作数格式同指令<code>rrmovq</code>相同，但只有当CC满足条件时才更新目的寄存器的值。</p>
<p>　　Y86-64的指令<code>call</code>会将返回地址压入栈，然后跳转到目的地址，指令<code>ret</code>会从这样的调用中返回。指令<code>pushq</code>和<code>popq</code>同x86-64中相同。指令<code>halt</code>会停止指令的执行，对应x86-64中的指令<code>hlt</code>，但x86-64应用程序不允许使用该指令，因为它会导致整个系统暂停。对于Y86-64，指令<code>halt</code>会导致CPU停止并将状态码置为<code>HLT</code>。</p>
<p>　　大多数Y86-64指令以简单明了的方式修改程序状态，但有2条指令是例外：<code>pushq</code>和<code>popq</code>。<code>pushq</code>会把栈指针减8并将寄存器值写入内存中。因此，当执行<code>pushq  %rsp</code>时，CPU的行为是不确定的，可能有2种情况：压入栈指针的原始值和压入减8后栈指针的值，Y86-64采用了和x86-64一样的做法，<span
style="background-color: yellow">压入的是原始值</span>。同样，对于<code>popq  %rsp</code>，<span
style="background-color: yellow">弹出的是栈顶的值</span>。对于IA32，从Intel
286开始，<code>PUSH ESP</code>会将寄存器的原始值压入栈
(IA32体系结构的实地址模式和虚8086模式以及Intel
64位体系结构也是如此)，而Intel
8086压入的则是减后的值。然而，<code>POP ESP</code>不存分歧。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/function_codes_for_y86-64_instruction_set.svg" class="">
<p>　　Y86-64指令的字节级编码中的第1个字节表示指令的类型，其中高4位表示<span
style="background-color: yellow">代码</span>部分，低4位表示<span
style="background-color: yellow">功能</span>部分。代码部分的值为<code>0x0</code>~<code>0xB</code>，功能部分只有在代码部分相同时才有用。</p>
<p>　　Y86-64状态码Stat用于描述程序程序的总体状态。</p>
<table>
<thead>
<tr>
<th>Stat值</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>AOK</td>
<td>正常操作</td>
</tr>
<tr>
<td>2</td>
<td>HLT</td>
<td>执行<code>halt</code>指令</td>
</tr>
<tr>
<td>3</td>
<td>ADR</td>
<td>非法地址</td>
</tr>
<tr>
<td>4</td>
<td>INS</td>
<td>非法指令</td>
</tr>
</tbody>
</table>
<p>　　当Stat的值不为1时，表示发生了某种类型的<span
style="background-color: yellow">异常</span>，CPU会停止执行指令。在更完整的设计中，CPU通常会调用<strong>异常处理函数</strong>，该过程可以配置为不同的结果，例如，中止程序或调用用户自定义的<strong>信号处理函数</strong>。</p>
<h4 id="y86-64程序">4.1.2 Y86-64程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> *start, <span class="type">long</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += *start;</span><br><span class="line">        start++;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从地址0开始执行</span><br><span class="line">0x000:                          .pos 0</span><br><span class="line">0x000: 30f40002000000000000     irmovq stack, %rsp  # 设置栈指针</span><br><span class="line">0x00a: 803800000000000000       call main           # 执行主程序</span><br><span class="line">0x013: 00                       halt                # 结束程序</span><br><span class="line"></span><br><span class="line"># 包括4个元素的数组</span><br><span class="line">0x018:                          .align 8</span><br><span class="line">0x018:                      array: </span><br><span class="line">0x018: 0d000d000d000000         .quad 0x000d000d000d</span><br><span class="line">0x020: c000c000c0000000         .quad 0x00c000c000c0</span><br><span class="line">0x028: 000b000b000b0000         .quad 0x0b000b000b00</span><br><span class="line">0x030: 00a000a000a00000         .quad 0xa000a000a000</span><br><span class="line"></span><br><span class="line">0x038:                      main:</span><br><span class="line">0x038: 30f71800000000000000     irmovq  array, %rdi</span><br><span class="line">0x042: 30f60400000000000000     irmovq  $4, %rsi</span><br><span class="line">0x04c: 805600000000000000       call sum</span><br><span class="line">0x055: 90                       ret</span><br><span class="line"></span><br><span class="line"># long sum(long *start, long count)</span><br><span class="line"># start在寄存器%rdi, count在寄存器%rsi</span><br><span class="line">0x056:                      sum:</span><br><span class="line">0x056: 30f80800000000000000     irmovq  $8, %r8</span><br><span class="line">0x060: 30f90100000000000000     irmovq  $1, %r9</span><br><span class="line">0x06a: 6300                     xorq    %rax, %rax</span><br><span class="line">0x06c: 6266                     andq    %rsi, %rsi</span><br><span class="line">0x06e: 708700000000000000       jmp test</span><br><span class="line">0x077:                      loop:</span><br><span class="line">0x077: 50a70000000000000000     mrmovq  (%rdi), %r10</span><br><span class="line">0x081: 60a0                     addq    %r10, %rax</span><br><span class="line">0x083: 6087                     addq    %r8, %rdi</span><br><span class="line">0x085: 6196                     subq    %r9, %rsi</span><br><span class="line">0x087:                      test:</span><br><span class="line">0x087: 747700000000000000       jne loop;</span><br><span class="line">0x090: 90                       ret</span><br><span class="line"></span><br><span class="line"># 栈的起始地址</span><br><span class="line">0x200:                          .pos 0x200</span><br><span class="line">0x200:                      stack:</span><br></pre></td></tr></table></figure>
<p>　　<code>.pos</code> (第2行)
表示应该从地址0处开始生成代码，该地址是所有Y86-64程序的起始地址。接下来的指令
(第3行) 会初始化栈指针。在程序的结尾 (第40行)
声明了标签<code>stack</code>并用<code>.pos</code>表示地址<code>0x200</code>
(第39行)，所以栈会从该地址开始并向低地址增长。第8~13行会声明1个4字的数组，标签<code>array</code>表示数组的起始地址，标签<code>.align</code>表示按8B对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 停在34步，PC = 0x13, status &#x27;HLT&#x27;, CC: Z = 1 O = 0</span><br><span class="line"># 寄存器的变化</span><br><span class="line">%rax:   0x0000000000000000  0x0000abcdabcdabcd</span><br><span class="line">%rsp:   0x0000000000000000  0x0000000000000200</span><br><span class="line">%rdi:   0x0000000000000000  0x0000000000000038</span><br><span class="line">%r8:    0x0000000000000000  0x0000000000000008</span><br><span class="line">%r9:    0x0000000000000000  0x0000000000000001</span><br><span class="line">%r10:   0x0000000000000000  0x0000a000a000a000</span><br><span class="line"></span><br><span class="line"># 内存的变化</span><br><span class="line">0x01f0: 0x0000000000000000  0x0000000000000055</span><br><span class="line">0x01f8: 0x0000000000000000  0x0000000000000013</span><br></pre></td></tr></table></figure>
<p>　　这是在通过Y86-64指令集模拟器执行函数<code>sum()</code>的Y86-64代码的输出。第1行表示执行情况以及PC和程序状态的值。之后的输出中左侧是原始值，右侧是改变后的值。栈指针的从<code>0x200</code>开始向低地址增长，栈的使用导致内存地址<code>0x01f0</code>~<code>0x0f18</code>中的值发生了变化。可执行代码的最大地址为<code>0x090</code>，所以出入栈不会损坏可执行代码。</p>
<h3 id="逻辑设计和硬件控制语言">4.2 逻辑设计和硬件控制语言</h3>
<p>　　在硬件设计中，电子电路用于计算位运算的函数以及在各种存储单元中存储位。大多数现代电路技术用信号线上的高电压或低电压来表示不同的位，例如，用1.0V左右的高电压表示逻辑1，用0.0V左右的低电压表示逻辑0。要实现数字系统需要<span
style="background-color: yellow">计算位操作函数的组合逻辑</span>、<span
style="background-color: yellow">存储位的存储器单元</span>和<span
style="background-color: yellow">控制存储器单元更新的时钟信号</span>。</p>
<p>　　过去，硬件设计者通过描绘示意性的逻辑电路图来进行电路设计
(最早是用纸和笔，后来用计算机图像终端)。现在，大多数设计都是用<strong>硬件描述语言</strong>
(HDL)。HDL属于文本表示，看上去类似汇编，但用于描述硬件结构而非程序行为。最常用的HDL是Verilog和VHDL，Verilog的语法类似于C，VHDL的语法类似于Ada语言。这些语言用于表示数字电路的模拟模型。20世纪80年代中期，出现了<strong>逻辑合成</strong>程序，它可以根据HDL的描述生成有效的电路设计。现在有很多商用的合成程序，已成为生成数字电路的主要技术。从手工设计电路到合成生成的转变类似从写汇编程序到写高级语言程序，再用编译器来生成机器代码的转变。</p>
<p>　　之后的内容使用的是<strong>硬件控制语言</strong>
(HCL)。HCL仅描述硬件设计的控制部分，支持的操作很有限，并且没有模块化。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/logic_gate_types.svg" class="">
<p>　　<strong>逻辑门</strong>是数字电路的基本计算单元。逻辑门总是活动的，一旦其输入发生了变化，在很短的时间内，输出就会相应地变化。</p>
<p>　　将很多个逻辑门组合在一起就能构成计算块，称为<strong>组合电路</strong>。</p>
<p>　　● 每个逻辑门要么连接到系统输入 (称为<span
style="background-color: yellow">主输入</span>)，要么是某个存储器单元或逻辑门的输出。</p>
<p>　　●
2个及以上的逻辑门的输出不能连接在一起，否则，可能会导致信号冲突。</p>
<p>　　● 组合电路必须是无环的，否则，可能会导致计算的函数有歧义。</p>
<h4 id="位级的组合电路">4.2.1 位级的组合电路</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/combinational_circuit_to_test_for_bit_equality.svg" class="">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b);</span><br></pre></td></tr></table></figure>
<p>　　这是判断位相等的组合电路的的电路图和HCL函数。从HCL代码中可以看出，数据类型<code>bool</code>表示输出<code>eq</code>是位信号，输入是<code>a</code>和<code>b</code>。<code>!eq</code>是异或，即在输出前加上1个非门。HCL使用了C风格，但其并非将执行结果存储内存中，只是为表达式命名。C的逻辑表达式可能部分求值，对于<code>a &amp;&amp; fun(b)</code>，当<code>a</code>为0时，<code>fun(b)</code>就不会执行，但HCL不会这样，它只是响应输入的变化。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/single-bit_multiplexor_circuit.svg" class="">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool <span class="keyword">out</span> = (s &amp;&amp; a) || (!s &amp;&amp; b);</span><br></pre></td></tr></table></figure>
<p>　　这是位<strong>多路复用器</strong>的组合电路和HCL函数。2个数据信号是输入位<code>a</code>和<code>b</code>，控制信号是输入位<code>s</code>。当<code>s</code>为1时，输出是<code>a</code>；当<code>s</code>为0时，输出是<code>b</code>。</p>
<h4 id="字级的组合电路">4.2.2 字级的组合电路</h4>
<p>　　执行字运算的组合电路由逻辑门构成，根据输入字的每个位来计算输出字的每个位。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/combinational_circuit_to_test_for_word_equality.svg" class="">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool Eq = (A == B);</span><br></pre></td></tr></table></figure>
<p>　　这是判断字相等的组合电路和HCL函数，当且仅当2个字中的所有位都相等时，输出才为1，该电路将64个判断位相等的组合电路的输出和与门连接。此外，也可以通过将64个位异或的组合电路的输出和与门连接，最后在与门后连接1个非门来实现。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/word-level_multiplexor_circuit.svg" class="">
<p>　　这是字多路复用器的组合电路和HCL函数，根据输入控制位<code>s</code>，生成64位的字<code>Out</code>，等于<code>A</code>或<code>B</code>中的1个。该电路由64个位多路复用器组成，但这里仅使用了1个非门。</p>
<p>　　CPU中会使用很多种多路复用器，能够根据某些控制条件，从许多源中选出1个字。在HCL中，多路复用函数用<strong>情况表达式</strong>表示。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    select_1 : expr_1;</span><br><span class="line">    select_2 : expr_2;</span><br><span class="line">    ...</span><br><span class="line">    select_k : expr_k;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>　　情况表达式包含了多种情况，每种情况<code>i</code>都有布尔表达式<code>select_i</code>和整数表达式<code>expr_i</code>，前者表示选择该情况的条件，后者表示得到的值。与C中的<code>case</code>语句不同的时，情况表达式的布尔表达式之间不必互斥。从逻辑角度，这些选择表达式是按顺序计算的，第1个值为1的情况会被选择。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/four-way_multplexor.svg" class="">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word Out4 = </span><br><span class="line">[</span><br><span class="line">    !s1 &amp;&amp; !s0  : A; # <span class="number">00</span></span><br><span class="line">    !s1         : B; # <span class="number">01</span></span><br><span class="line">    !s0         : C; # <span class="number">10</span></span><br><span class="line">    <span class="number">1</span>           : D; # <span class="number">11</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　这是四路复用器的HCL，其中<code>#</code>开头的注释表示选择该情况时<code>s1</code>和<code>s0</code>的值。选择表达式有时可以简化，例如，第2个表达式简写为<code>!s1</code>而非<code>!s1 &amp;&amp; s0</code>，因为当<code>s0</code>为0的情况已经出现在第1个表达式中，同样，第3个表达式简写为<code>!s0</code>，第4个表达式简写为<code>1</code>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/alu.svg" class="">
<p>　　<strong>算术逻辑单元</strong>有2个数据输入 (A和B)
和1个控制输入，电路对数据输入执行的算术或逻辑操作根据控制输入决定。ALU的4个操作对应Y86-64指令集的4种整数操作指令。</p>
<h4 id="存储器和时钟">4.2.3 存储器和时钟</h4>
<p>　　实际上，组合电路不存储任何信息，相反，它们只是简单地响应输入信号，生成对应的输出。为了生成<strong>时序电路</strong>
(具有状态并对此状态进行计算的系统)，必须加入按位存储信息的设备。存储设备都是由同一<strong>时钟</strong>控制，时钟是周期性信号，决定何时把新值加载到设备中。</p>
<p>　　● <strong>时钟寄存器</strong> (简称寄存器)
存储单个位或字。时钟信号控制寄存器输入值的加载。</p>
<p>　　●
<strong>存储器</strong>存储多个字，用地址来决定待读写的字。例如，CPU的虚拟内存系统和寄存器文件。</p>
<p>　　寄存器在硬件和机器级编程的含义略有不同。在硬件中，寄存器直接将其输入和输出线连接到电路的其他部分。在机器级编程中，寄存器表示CPU中为数不多的可寻址的字，地址是寄存器ID，这些字通常存储在寄存器文件中，虽然硬件有时可以直接将字从某个指令移动到其他指令，以避免先写寄存器文件再读的延迟。为了避免歧义，这2类寄存器称为<span
style="background-color: yellow">硬件寄存器</span>和<span
style="background-color: yellow">程序寄存器</span>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/register_operation.svg" class="">
<p>　　硬件寄存器通常都保持在稳定状态<code>x</code>，其输出为其当前状态。信号会沿寄存器前面的组合逻辑传播，生成新的寄存器输入<code>y</code>，但只要时钟保持低电位，寄存器的输出不变。当时钟变为高电位时，输入信号加载到寄存器，寄存器变为下一个状态<code>y</code>，在下一个时钟上升沿前，寄存器的输出不变。寄存器作为电路不同部分中的组合逻辑之间的屏障。每当时钟上升沿时，值才会从寄存器的输入移动到输出。Y86-64会用时钟寄存器保存PC、CC和程序状态。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/register_file.svg" class="">
<p>　　寄存器文件有2个读端口 (A和B) 和1个写端口
(W)，这样的多端口存储器允许同时进行多个读或写操作。它可以读2个程序寄存器的值，同时更新第3个寄存器的状态。每个端口都有1个地址输入
(表示程序寄存器) 和1个数据输入/输出
(表示程序寄存器的值)。地址输入是寄存器ID。2个读端口都有地址输入
(<code>srcA</code>和<code>srcB</code>) 和数据输出
(<code>valA</code>和<code>valB</code>)。写端口有地址输入
(<code>dstW</code>) 和数据输入 (<code>valW</code>)。</p>
<p>　　寄存器文件不是组合电路，因为它有内部存储。不过，在这里的实现中，从寄存器文件读数据就好像它是以地址为输入、数据为输出的组合逻辑块。当<code>srcA</code>或<code>srcB</code>为某个寄存器ID时，在一段时间后，存储在对应程序寄存器的值就会出现在<code>valA</code>或<code>valB</code>。例如，将<code>srcA</code>置为<code>0x3</code>，就会读程序寄存器<code>%rbx</code>的值，这个值会出现在输出<code>valA</code>。</p>
<p>　　写寄存器文件由时钟信号控制，控制方式类似将值加载到时钟寄存器。每次时钟上升时，输入<code>valW</code>的值会写入到输入<code>dstW</code>的寄存器ID对应的程序寄存器。当<code>dstW</code>为<code>0xF</code>时，不会写任何寄存器。若更新某个寄存器的同时在读端口上用该寄存器ID，则会出现从旧值到新值的变化。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/data_memory.svg" class="">
<p>　　CPU有1个存储器用于存储程序数据，该存储器有1个地址输入、1个数据输入和1个数据输出。同寄存器文件一样，该存储器的操作方式类似于组合逻辑，在地址输入中输入地址并将写控制信号置0，经过一段时间后，存储在该地址上的值会出现在数据输出。若地址超出范围
(这里的边界检查就是地址输入的函数，不涉及保存任何状态)，异常信号会置1；否则，置0。写该存储器是时钟控制的，在地址输入输入地址、数据输入输入数据和将写控制信号置1后，只要地址是合法的，就会更新对应的值。CPU还包括1个只读存储器，用于读指令。在大多数实际系统中，这2个存储器合并为1个具有双端口的存储器，分别用于读指令和读写数据。</p>
<h3 id="y86-64的顺序实现">4.3 Y86-64的顺序实现</h3>
<p>　　这里的实现以SEQ为例，每个时钟周期内，SEQ会执行处理1条指令所需的所有步骤，但这需要很长的时钟周期时间，所以时钟周期频率会很低。处理1条指令通常需要<strong>取指</strong>、<strong>译码</strong>、<strong>执行</strong>、<strong>访存</strong>、<strong>写回</strong>、<strong>更新PC</strong>。CPU会一直循环这几个阶段，这里简化了实现，当出现异常时
(执行指令<code>halt</code>/非法指令和读写非法地址)，CPU就会停止，在更完整的设计中，CPU会进入异常处理模式，开始执行异常类型决定的特殊代码。</p>
<p>　　●
在取指阶段，会以PC为内存地址来读取指令，再从指令中提取出指令指示符的2个4位的字段
(<strong>指令代码</strong>和<strong>指令功能</strong>)。这里可能会取出1B的寄存器ID字段，表示1或2个寄存器操作数指示符<code>rA</code>和<code>rB</code>。这里还可能取出8B的常数字段<code>valC</code>，用于计算下一条指令的地址<code>valP</code>
(<code>valP</code>的值为PC的值加上取出指令的长度)。</p>
<p>　　●
在译码阶段，会从寄存器文件读取最多2个操作数，得到值<code>val</code>和/或<code>valB</code>。通常，这里读指令中<code>rA</code>和<code>rB</code>字段指明的寄存器，不过有些指令读栈指针。</p>
<p>　　● 在执行阶段，ALU要么执行指令指明的操作数
(根据<code>ifun</code>)，计算内存引用的有效地址，加/减栈指针，得到值<code>valE</code>，这里可能会设置CC。对于条件移动指令，该阶段会检查CC和移动条件
(由<code>ifun</code>给出)，若条件成立，则更新目标寄存器。同样，条件跳转指令也会进行条件判断。</p>
<p>　　●
在访存阶段，可能会读写内存，这里将读取的值表示为<code>valM</code>。</p>
<p>　　● 在写回阶段，会写最多2个结果到寄存器文件。</p>
<p>　　● 在更新PC阶段，会将PC设置为下一条指令的地址。</p>
<p>　　SEQ并不能充分利用硬件单元，因为每个单元仅在整个时钟周期中的一部分时间才被使用。</p>
<h4 id="将处理组织成阶段">4.3.1 将处理组织成阶段</h4>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 32%" />
<col style="width: 32%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr>
<th>阶段</th>
<th style="text-align: left;"><code>Opq  rA, rB</code></th>
<th><code>rrmovq  rA, rB</code></th>
<th style="text-align: left;"><code>irmovq  V, rB</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>取指</td>
<td style="text-align: left;"><code>icode:ifun</code> ←
<code>M1[PC]</code>; <code>rA:rB</code> ← <code>M1[PC + 1]</code>;
<code>valP</code> ← <code>PC + 2</code></td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>ra:rB</code> ←
<code>M1[PC + 1]</code>; <code>valP</code> ← <code>PC + 2</code></td>
<td style="text-align: left;"><code>icode:ifun</code> ←
<code>M1[PC]</code>; <code>rA:rB</code> ← <code>M1[PC + 1]</code>;
<code>valC</code> ← <code>M8[PC + 2]</code>; <code>valP</code> ←
<code>PC + 10</code></td>
</tr>
<tr>
<td>译码</td>
<td style="text-align: left;"><code>valA</code> ← <code>R[rA]</code>;
<code>valB</code> ← <code>R[rB]</code></td>
<td><code>valA</code> ← <code>R[rA]</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td>执行</td>
<td style="text-align: left;"><code>valE</code> ←
<code>valB OP valA</code>; <code>Set CC</code></td>
<td><code>valE</code> ← <code>valA</code></td>
<td style="text-align: left;"><code>valE</code> ← <code>valC</code></td>
</tr>
<tr>
<td>访存</td>
<td style="text-align: left;"></td>
<td></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td>写回</td>
<td style="text-align: left;"><code>R[rB]</code> ←
<code>valE</code></td>
<td><code>R[rB]</code> ← <code>valE</code></td>
<td style="text-align: left;"><code>R[rB]</code> ←
<code>valE</code></td>
</tr>
<tr>
<td>更新PC</td>
<td style="text-align: left;">PC ← <code>valP</code></td>
<td>PC ← <code>valP</code></td>
<td style="text-align: left;">PC ← <code>valP</code></td>
</tr>
</tbody>
</table>
<p>　　这些指令都是计算1个值并将结果存储在寄存器中。<code>icode:ifun</code>表示指令代码和指令功能，<code>rA:rB</code>表示寄存器指示符字节中的<code>ra</code>和<code>rB</code>。<code>M1[x]</code>表示访存位置<code>x</code>处的1B，同理，<code>M8[x]</code>表示访问该位置的8B。</p>
<p>　　对于整数操作指令，其编码长度为2B，所以取指阶段中<code>valP</code>为<code>PC + 2</code>。在译码阶段，会读取2个操作数。在执行阶段，会将操作数和<code>ifun</code>一起提供给ALU，其中具体的整数操作由<code>ifun</code>指定，得到<code>valE</code>，这里会设置CC。整数操作指令不涉及内存访问，所以访存阶段什么也不做。在写回阶段，会将<code>valE</code>写回寄存器<code>rB</code>。在更新PC阶段，会将<code>PC</code>设置为<code>valP</code>。指令<code>rrmovq</code>和<code>irmivq</code>与之类似。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 4%" />
<col style="width: 47%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr>
<th>阶段</th>
<th><code>rmmovq  rA, D(rB)</code></th>
<th><code>mrmovq  D(rB), rA</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>取指</td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ←
<code>M1[PC + 1]</code>; <code>valC</code> ← <code>M8[PC + 2]</code>;
<code>valP</code> ← <code>PC + 10</code></td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ←
<code>M1[PC + 1]</code>; <code>valC</code> ← <code>M8[PC + 2]</code>;
<code>valP</code> ← <code>PC + 10</code></td>
</tr>
<tr>
<td>译码</td>
<td><code>valA</code> ← <code>R[rA]</code>; <code>valB</code> ←
<code>R[rB]</code></td>
<td><code>valB</code> ← <code>R[rB]</code></td>
</tr>
<tr>
<td>执行</td>
<td><code>valE</code> ← <code>valB + valC</code></td>
<td><code>valE</code> ← <code>valB + valC</code></td>
</tr>
<tr>
<td>访存</td>
<td><code>M8[valE]</code> ← <code>valA</code></td>
<td><code>valM</code> ← <code>M8[valE]</code></td>
</tr>
<tr>
<td>写回</td>
<td></td>
<td><code>R[rA]</code> ← <code>valM</code></td>
</tr>
<tr>
<td>更新PC</td>
<td>PC ← <code>valP</code></td>
<td>PC ← <code>valP</code></td>
</tr>
</tbody>
</table>
<p>　　指令<code>rmmovq</code>和<code>mrmovq</code>的流程和整数操作指令的类似，不过会用ALU来加<code>valC</code>和<code>valB</code>得到内存操作的有效地址。在访存阶段，会将寄存器值<code>valA</code>写到内存或从内存读到<code>valM</code>。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 4%" />
<col style="width: 47%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr>
<th>阶段</th>
<th><code>pushq  rA</code></th>
<th><code>popq  rA</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>取指</td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ←
<code>M1[PC + 1]</code>; <code>valP</code> ← <code>PC + 2</code></td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>rA:rB</code> ←
<code>M1[PC + 1]</code>; <code>valP</code> ← <code>PC + 2</code></td>
</tr>
<tr>
<td>译码</td>
<td><code>valA</code> ← <code>R[rA]</code>; <code>valB</code> ←
<code>R[%rsp]</code></td>
<td><code>valA</code> ← <code>R[%rsp]</code>; <code>valB</code> ←
<code>R[%rsp]</code></td>
</tr>
<tr>
<td>执行</td>
<td><code>valE</code> ← <code>valB - 8</code></td>
<td><code>valE</code> ← <code>valB + 8</code></td>
</tr>
<tr>
<td>访存</td>
<td><code>M8[valE]</code> ← <code>valA</code></td>
<td><code>valM</code> ← <code>M8[valA]</code></td>
</tr>
<tr>
<td>写回</td>
<td><code>R[%rsp]</code> ← <code>valE</code></td>
<td><code>R[%rsp]</code> ← <code>valE</code>; <code>R[rA]</code> ←
<code>valM</code></td>
</tr>
<tr>
<td>更新PC</td>
<td>PC ← <code>valP</code></td>
<td>PC ← <code>valP</code></td>
</tr>
</tbody>
</table>
<p>　　对于指令<code>pushq</code>，在译码阶段，会用栈指针作为第2个操作数并赋值给<code>valB</code>。在执行阶段，会将栈指针减8，得到的值作为访存阶段中的内存地址。</p>
<p>　　指令<code>popq</code>的流程与指令<code>pushq</code>的类似，不同的是译码阶段会读取<span
style="background-color: yellow">2次</span>栈指针分别赋值给<code>valA</code>和<code>valB</code>。在执行阶段，会将栈指针加8，得到的值用于写回阶段中写回给栈指针。在访存阶段，会读取栈指针，得到的值用于写回阶段中写回寄存器<code>rA</code>。</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 35%" />
<col style="width: 35%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>阶段</th>
<th><code>jxx  Dest</code></th>
<th><code>call  Dest</code></th>
<th><code>ret</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>取指</td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>valC</code> ←
<code>M8[PC + 1]</code>; <code>valP</code> ← <code>PC + 9</code></td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>valC</code> ←
<code>M8[PC + 1]</code>; <code>valP</code> ← <code>PC + 9</code></td>
<td><code>icode:ifun</code> ← <code>M1[PC]</code>; <code>valP</code> ←
<code>PC + 1</code></td>
</tr>
<tr>
<td>译码</td>
<td></td>
<td><code>valB</code> ← <code>R[%rsp]</code></td>
<td><code>valA</code> ← <code>R[%rsp]</code>; <code>valB</code> ←
<code>R[%rsp]</code></td>
</tr>
<tr>
<td>执行</td>
<td><code>Cnd</code> ← <code>Cond(CC, ifun)</code></td>
<td><code>valE</code> ← <code>valB - 8</code></td>
<td><code>valE</code> ← <code>valB + 8</code></td>
</tr>
<tr>
<td>访存</td>
<td></td>
<td><code>M8[valE]</code> ← <code>valP</code></td>
<td><code>valM</code> ← <code>M8[valA]</code></td>
</tr>
<tr>
<td>写回</td>
<td></td>
<td><code>R[%rsp]</code> ← <code>valE</code></td>
<td><code>R[%rsp]</code> ← <code>valE</code></td>
</tr>
<tr>
<td>更新PC</td>
<td>PC ← <code>Cnd ? valC : valP</code></td>
<td>PC ← <code>valC</code></td>
<td>PC ← <code>valM</code></td>
</tr>
</tbody>
</table>
<p>　　条件跳转指令的流程与整数操作指令的类似。在执行阶段，会检查CC和跳转条件来确定分支选择
(生成1位的信号<code>Cnd</code>)。在更新PC阶段，会根据<code>Cnd</code>来设置PC，若<code>Cnd</code>为1，则将PC设置为<code>valC</code>
(跳转目标)；若<code>Cnd</code>为0，则将PC设置为<code>valP</code>。</p>
<p>　　指令<code>call</code>和<code>ret</code>的流程与指令<code>pushq</code>和<code>popq</code>的类似，除了将栈指针压入和弹出栈。对于<code>call</code>指令，会将<code>valP</code>压入栈。在更新PC阶段，会将PC设置为<code>valC</code>。对于指令<code>ret</code>，在更新PC阶段，会PC设置为从栈中取出的值<code>valM</code>。</p>
<h4 id="seq">4.3.2 SEQ</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/seq_hardware_structure.svg" class="">
<p>　　在SEQ中，<span
style="background-color: yellow">白色矩形表示时钟寄存器</span>，PC是这里唯一的时钟寄存器。<span
style="background-color: yellow">浅蓝色框表示硬件单元</span>，包括存储器和ALU，这里会使用黑盒
(忽视其细节设计) 来实现。<span
style="background-color: yellow">灰色圆角矩形表示控制逻辑块</span>，这些块用于从1组信号源中进行选择或计算布尔函数。<span
style="background-color: yellow">粗线表示字级别的数据</span>，每条这样的线实际表示1簇64根线，并列地连在一起，将1个字从硬件的某部分移动到其他部分。<span
style="background-color: yellow">细线表示字节级别或更小的数据</span>，根据具体待移动的值，每条这样的线实际表示1簇4或8根线。<span
style="background-color: yellow">虚线表示单个位</span>，表示单元与块之间移动的控制值。</p>
<h4 id="seq时序">4.3.3 SEQ时序</h4>
<p>　　SEQ的实现包括组合逻辑和2种存储器：时钟寄存器 (PC和CC寄存器)
和<span style="background-color: yellow">随机存取存储器</span>
(寄存器文件、指令存储器和数据存储器)。组合逻辑不需要任何时序或控制，只要输入变化，值就通过组合电路传播。读存储器可以视为和组合逻辑一样的操作，根据地址输入生成输出，对于寄存器文件等较小的存储器，这是合理的假设，但对于较大的电路，可以用特殊的时钟电路来模拟。由于指令存储器仅用于读指令，该硬件单元可以视为组合逻辑。</p>
<p>　　这里还有4个硬件单元需要进行时序控制：PC寄存器、CC寄存器、数据存储器和寄存器文件。这些单元通过同一时钟信号控制，该信号会触发将新值加载到寄存器和将值写入RAM。PC在每个时钟周期加载新指令的地址。仅当执行整数操作指令时，才会加载CC寄存器。只有执行指令<code>rmmovq</code>、<code>pushq</code>和<code>call</code>时，才会写数据存储器。寄存器文件的2个写端口允许每个时钟周期更新2个程序寄存器。</p>
<p>　　要控制CPU中活动的时序，只需控制寄存器和存储器的时钟。SEQ硬件实现了与指令执行顺序相同的效果，即使所有状态更新实际上同时发生且仅在时钟上升沿
(即下一个时钟周期的开始)。这种等价性得益于Y86-64指令集的本质——<span
style="background-color: yellow">从不回读</span>，即<span
style="background-color: yellow">CPU永远不需要读指令更新后的状态即可完成指令的处理</span>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/tracing_two_cycles_of_execution_by_seq.svg" class="">
<p>　　标签1~4分别给出了第3~4行代码的开始和结束时的一些信息，包括4个状态单元以及组合逻辑和状态单元之间的连接。组合逻辑将CC寄存器包围，因为一些组合逻辑
(例如，ALU) 生成CC寄存器的输入，而其他部分 (例如，条件判断和PC选择逻辑)
将CC寄存器作为输入。寄存器文件和数据存储器有独立的读连接和写连接，因为读沿着这些单元传播，就好像它们是组合逻辑，而写操作由时钟控制。</p>
<p>　　这里假设处理从CC开始，CC的顺序是ZF、SF和OF，设置为100。在时钟周期3开始时
(标签1)，状态单元保持的是周期2中指令<code>irmovq</code>更新后的状态，该指令用浅灰色表示。组合逻辑用白色表示，表示还未对变化后的状态做出反应。时钟周期以地址<code>0x014</code>载入到PC开始，这样会取出并执行指令<code>addq</code>。值会沿着组合逻辑，包括RAM的读。在该周期结束时
(标签2)，组合逻辑会为CC生成了新值000、寄存器<code>%rbx</code>更新后的值和PC的新值<code>0x016</code>。此时，组合逻辑已经根据指令<code>addq</code>更新，但状态还保持着周期2中指令<code>irmovq</code>设置的值。</p>
<p>　　在时钟周期4开始时
(标签3)，会更新PC、寄存器文件和CC寄存器，所以用蓝色表示，但组合逻辑还未对这些变化做出反应，所以用白色表示。在该周期内，会取出并执行指令<code>je</code>，用深灰色表示。ZF为0，所以不会进行分支选择。在该周期结束时
(标签4)，PC的新值<code>0x01f</code>已经生成，组合逻辑已完成更新，但直到下个周期开始前，状态会保持指令<code>addq</code>设置的值。</p>
<h4 id="seq各阶段的实现">4.3.4 SEQ各阶段的实现</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>十六进制值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IHALT</code></td>
<td><code>0x0</code></td>
<td>指令<code>halt</code>的代码</td>
</tr>
<tr>
<td><code>INOP</code></td>
<td><code>0x1</code></td>
<td>指令<code>nop</code>的代码</td>
</tr>
<tr>
<td><code>IRRMOVQ</code></td>
<td><code>0x2</code></td>
<td>指令<code>rrmovq</code>的代码</td>
</tr>
<tr>
<td><code>IIRMOVQ</code></td>
<td><code>0x3</code></td>
<td>指令<code>irmovq</code>的代码</td>
</tr>
<tr>
<td><code>IRMMOVQ</code></td>
<td><code>0x4</code></td>
<td>指令<code>rmmovq</code>的代码</td>
</tr>
<tr>
<td><code>IMRMOVQ</code></td>
<td><code>0x5</code></td>
<td>指令<code>irmovq</code>的代码</td>
</tr>
<tr>
<td><code>IOPL</code></td>
<td><code>0x6</code></td>
<td>整数运算指令的代码</td>
</tr>
<tr>
<td><code>IJXX</code></td>
<td><code>0x7</code></td>
<td>跳转指令的代码</td>
</tr>
<tr>
<td><code>ICALL</code></td>
<td><code>0x8</code></td>
<td>指令<code>call</code>的代码</td>
</tr>
<tr>
<td><code>IRET</code></td>
<td><code>0x9</code></td>
<td>指令<code>ret</code>的代码</td>
</tr>
<tr>
<td><code>IPUSHQ</code></td>
<td><code>0xA</code></td>
<td>指令<code>pushq</code>的代码</td>
</tr>
<tr>
<td><code>IPOPQ</code></td>
<td><code>0xB</code></td>
<td>指令<code>popq</code>的代码</td>
</tr>
<tr>
<td><code>FNONE</code></td>
<td><code>0x0</code></td>
<td>默认功能码</td>
</tr>
<tr>
<td><code>RRSP</code></td>
<td><code>0x4</code></td>
<td>寄存器<code>%rsp</code>的ID</td>
</tr>
<tr>
<td><code>RNONE</code></td>
<td><code>0xF</code></td>
<td>不访问寄存器</td>
</tr>
<tr>
<td><code>ALUADD</code></td>
<td><code>0x0</code></td>
<td>加法运算</td>
</tr>
<tr>
<td><code>SAOK</code></td>
<td><code>0x1</code></td>
<td>正常操作状态码</td>
</tr>
<tr>
<td><code>SADR</code></td>
<td><code>0x2</code></td>
<td>地址异常状态码</td>
</tr>
<tr>
<td><code>SINS</code></td>
<td><code>0x3</code></td>
<td>非法指令异常状态码</td>
</tr>
<tr>
<td><code>SHLT</code></td>
<td><code>0x4</code></td>
<td><code>halt</code>状态码</td>
</tr>
</tbody>
</table>
<p>　　这是一些整数和布尔信号的定义，可以作为HCL操作的参数。它们都是必须显式引用的常数，按照惯例，常数值都是大写。</p>
<h5 id="取指阶段">4.3.4.1 取指阶段</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/seq_fetch_stage.svg" class="">
<p>　　对于取指阶段，指令存储器会以PC作为第1个字节 (字节0)
的地址从存储器<span
style="background-color: yellow">读取10B</span>。第1个字节会解释为指令字节
(标签Split)，分为2个4位的数。然后，标签为icode和ifun的控制逻辑块会计算指令和功能代码，使之等于从指令存储器读取的值，或者指令地址越界时
(信号<code>imem_error</code>表示)，使之等于对应指令<code>nop</code>的值。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool need_regids =</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool need_valC =</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL &#125;;</span><br></pre></td></tr></table></figure>
<p>　　根据<code>icode</code>计算可以3个1位的信号
(虚线表示)：<code>instr_valid</code>、<code>need_regids</code>和<code>need_valC</code>。第1个信号表示指令字节是否合法，第2个信号表示指令是否包含1个寄存器ID，第3个信号表示指令是否包含常数。</p>
<p>　　信号<code>instr_valid</code>和<code>imem_error</code>在访存阶段用于生成CC。</p>
<p>　　从指令存储器读出的剩余字节是寄存器ID和常数的组合编码
(标签Align)。若<code>need_regids</code>为1，则字节1会拆开并赋值给<code>rA</code>和<code>rB</code>，字节2~9用于生成<code>valC</code>；否则，<code>rA</code>和<code>rB</code>会设置为<code>0xF</code>，字节1~8用于生成<code>valC</code>。</p>
<p>　　若PC的当前值为<span
class="math inline">\(p\)</span>，<code>need_regids</code>的值为<span
class="math inline">\(r\)</span>，<code>need_valC</code>的值为<span
class="math inline">\(i\)</span>，则PC增加后的值为<span
class="math inline">\(p+1+r+8i\)</span>。</p>
<h5 id="译码和写回阶段">4.3.4.2 译码和写回阶段</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/seq_decode_and_write-back_stage.svg" class="">
<p>　　寄存器文件有4个端口，支持同时进行2个读操作 (端口A和B) 和2个写操作
(端口E和M)。每个端口都有1个地址连接和数据连接，地址连接是1个寄存器ID，数据连接是1簇64根线，既可以作为寄存器文件的输出字
(对读端口)，也可以作为输入字
(对写端口)。2个读端口的地址输入为<code>srcA</code>和<code>srcB</code>，而2个写端口的地址输入为<code>dstE</code>和<code>dstM</code>。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word srcA = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ &#125; : rA;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word srcB = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IOPQ, IRMMOVQ, IMRMOVQ &#125; : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"># 不考虑条件移动指令</span><br><span class="line">word dstE = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IIRMOVQ, IOPQ &#125; : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"># 不考虑条件移动指令</span><br><span class="line">word dstM = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ &#125; : rA;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　<code>srcA</code>和<code>srcB</code>分别表示应该读取哪个寄存器来获取<code>valA</code>和<code>valB</code>。<code>desE</code>和<code>destM</code>分别是端口E和M的目的寄存器ID。</p>
<p>　　根据<code>icode</code>、<code>rA</code>和<code>rB</code>，可能还会在执行阶段计算<code>Cnd</code>。</p>
<h5 id="执行阶段">4.3.4.3 执行阶段</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/seq_execute_stage.svg" class="">
<p>　　对于执行阶段，ALU会根据<code>alufun</code>，对输入<code>aluA</code>和<code>aluB</code>进行加、减、与和异或运算，输出是<code>valE</code>。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word aluA =</span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ &#125; : valC;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; ICALL, IPUSHQ &#125; : -<span class="number">8</span>;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRET, IPOPQ &#125; : <span class="number">8</span>;</span><br><span class="line">    # 其他指令无需ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word aluB =</span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ &#125; : valB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ, IIRMOVQ &#125; : <span class="number">0</span>;</span><br><span class="line">    # 其他指令无需ALU</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　执行阶段的第1步是ALU计算，列出的操作数中<code>aluB</code>在前面，<code>aluA</code>在后面，这样可以保证指令<code>subq</code>的执行。根据指令的类型，<code>aluA</code>的值可以是<code>valA</code>、<code>valC</code>和$$8。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word alufun =</span><br><span class="line">[</span><br><span class="line">    icode == IOPQ : ifun;</span><br><span class="line">    i : ALUADD;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool set_cc = icode <span class="keyword">in</span> &#123; IOPQ &#125;;</span><br></pre></td></tr></table></figure>
<p>　　在执行阶段中，ALU通常作为加法器使用，但对于整数操作指令，它还是会使用<code>ifun</code>编码的操作。CC只会在执行整数操作指令时才会设置。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word dstE = </span><br><span class="line">[</span><br><span class="line">    # 用IRRMOVQ实现条件移动指令</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IIRMOVQ, IOPQ &#125; : rB;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　标签为cond的硬件单元会根据CC和功能码来确定是否进行条件分支选择或条件数据移动。它还会生成<code>Cnd</code>，用于设置条件移动的<code>dstE</code>和条件分支中下一个PC的逻辑。对于其他指令，<code>Cnd</code>可以设置为0或1，这取决于指令的功能码和CC，但ALU会忽略它。</p>
<h5 id="访存阶段">4.3.4.4 访存阶段</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/seq_memory_stage.svg" class="">
<p>　　访存阶段的任务是读写程序数据。2个控制块用于生成存储器地址和存储器写入数据的值。另外2个块用于生成控制读写操作的控制信号。当执行读操作时，数据存储器会生成<code>valM</code>。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word mem_addr = </span><br><span class="line">[</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ &#125; : valE;</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IPOPQ, IRET &#125; : valA;</span><br><span class="line">    # 其他指令无需地址</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word mem_data = </span><br><span class="line">[</span><br><span class="line">    # 寄存器的值</span><br><span class="line">    icode <span class="keyword">in</span> &#123; IRMMOVQ, IPUSHQ &#125; : valA;</span><br><span class="line">    # 返回PC</span><br><span class="line">    icode == ICALL : valP;</span><br><span class="line">    # 默认不写数据</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool mem_read = icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool mem_write = icode <span class="keyword">in</span> &#123; IRMMOVQ, IPUSHQ, ICALL &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word Stat = </span><br><span class="line">[</span><br><span class="line">    imem_error || dmem_error : SADR;</span><br><span class="line">    !instr_valid : SINS;</span><br><span class="line">    icode == IHAT : SHLT;</span><br><span class="line">    <span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　访存阶段会根据取指阶段生成的<code>icode</code>、<code>imem_error</code>、<code>instr_valid</code>和数据存储器生成的<code>dmem_error</code>来计算<code>Stat</code>。</p>
<h5 id="pc更新阶段">4.3.4.5 PC更新阶段</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/seq_pc_update_stage.svg" class="">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word new_pc = </span><br><span class="line">[</span><br><span class="line">    # Call指令：指令常数</span><br><span class="line">    icode == ICALL : valC;</span><br><span class="line">    # 条件跳转指令：指令常数</span><br><span class="line">    icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">    # 返回指令：使用栈值</span><br><span class="line">    icode == IRET : valM;</span><br><span class="line">    # 默认：PC增加</span><br><span class="line">    <span class="number">1</span> : valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　PC更新阶段会生成新PC。根据指令类型和是否执行条件跳转，新PC可能是<code>valC</code>、<code>valM</code>或<code>valP</code>。</p>
<h3 id="流水线的通用原理">4.4 流水线的通用原理</h3>
<p>　　流水线化设计的目的是保证<span
style="background-color: yellow">每个时钟周期都发出1条新指令</span>，即每个时钟周期都有1条新指令进入执行阶段并完成。要实现这一点需要吞吐量为每个时钟周期1条指令，也就是在取出当前指令后立即确定下一条指令的位置。若取出的指令是条件分支指令，则需要指令通过执行阶段后，才能知道是否选择分支。同样，若取出的指令是<code>ret</code>，则需要指令通过访存阶段后，才能确定返回地址。</p>
<p>　　通过预测PC的下一个值，在大多数情况下，能够达到流水线化设计的目的。对<span
style="background-color: yellow">大多数</span>类型的指令，这种预测是可靠的。</p>
<p>　　猜测分支方向并根据猜测开始取值的技术称为<strong>分支预测</strong>，实际上所有的CPU都采用某种形式的分支预测。这里只会使用简单的策略——<strong>总是选择</strong>条件分支，所以预测的PC值为<code>valC</code>，该策略的成功率大约是60%。相反，<strong>从不选择</strong>策略的成功率大约为40%。更复杂的<strong>反向选择、正向不选择</strong>策略的成功率大约为65%，这种策略源于事实：循环是由后向分支结束的，而循环通常会多次执行，前向分支用于条件操作，而这种选择的可能性较小。第3章提到过，分支预测错误会极大地降低程序性能，所以尽可能使用条件数据移动而非条件控制移动。</p>
<p>　　不同于条件移动指令，指令<code>ret</code>的PC新可能值几乎是无穷的，因为返回地址是位于栈顶的字，其内容不定。</p>
<p>　　对于大多数程序，预测返回值很容易，因为过程调用和返回是成对出现的。高性能CPU充分利用了该属性，在取指单元中加入<span
style="background-color: yellow">硬件栈</span>
(不属于程序员可见状态)，保存指令<code>call</code>生成的返回地址。每次执行指令<code>call</code>时，都会将其返回值压入栈中。当取出指令<code>ret</code>时，就从这个栈中弹出顶部的值，作为预测的返回值。同分支预测一样，预测错误时需要恢复机制，因为有时调用和返回不匹配。</p>
<h4 id="计算流水线">4.4.1 计算流水线</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/unpipelined_computaion_hardware.svg" class="">
<p>　　假设未流水线化的计算硬件中组合逻辑和寄存器的处理时间分别是300ps和20ps，所以每条指令的延迟为320ps。这种实现中下一条指令只能在前一条指令执行完成后才能执行，指令执行周期为320ps，所以时钟周期为320ps。这里用<span
style="background-color: yellow">每秒千兆条指令</span> (GIPS)
为单位来描述该系统的吞吐量。 <span class="math display">\[
\begin{align}
T_{unpipelined}&amp;=\frac{1条指令}{1条指令的时延}\times\frac{1000ps}{1ns}\\[3px]
&amp;=\frac{1}{320ps}\times\frac{1000ps}{1ns}\\[3px]
&amp;\approx3.12GIPS
\end{align}
\]</span></p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/three-stage_pipelining_timing.svg" class="">
<p>　　在之前的基础上，若<span
style="background-color: yellow">将指令按延迟平均划分3个阶段</span>
(A、B和C)，每个阶段中组合逻辑的处理时间为100ps，而寄存器的处理时间为20ps，所以时钟周期为120ps，这样1条指令需要3个时钟周期来执行，延迟为360ps。从宏观角度，每个时钟周期可以执行1个阶段A、B和C，可视为每个时钟周期执行1条指令。
<span class="math display">\[
\begin{align}
T_{three}&amp;=\frac{1条指令}{1条指令的时延}\times\frac{1000ps}{1ns}\\[3px]
&amp;=\frac{1}{120ps}\times\frac{1000ps}{1ns}\\[3px]
&amp;\approx8.33GIPS
\end{align}
\]</span>
　　相比未流水线化设计，3阶段流水线设计的吞吐量大大增加，代价是增加了一些硬件和少量延迟。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/one_clock_cycle_of_pipeline_operation.svg" class="">
<p>　　在时段240ps~360ps内，指令I1经过阶段C，I2经过阶段B，I3经过阶段A。在时刻239ps，阶段A中计算的指令I2的值已经到达第1个流水线寄存器的输入，但该寄存器的状态和输出还保持为指令I1的阶段A中计算的值。同样，指令I1在阶段B中计算的值已经到达第2个流水线寄存器的输入。在时刻241ps，流水线寄存器的输入载入其中，成为其输出。阶段A的输入设置为发起指令I3的计算。在时刻300ps，信号传播到各个阶段的组合逻辑，这里使用的是曲线化的波阵面，表示信号<span
style="background-color: yellow">可能以不同的速率</span>通过各个部分。在时刻359ps，结果值到达流水线寄存器的输入。</p>
<p>　　这里的流水线化设计是理想情况，实际中会出现一些降低流水线效率的因素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">irmovq	$50, %rax</span><br><span class="line">addq	%rax, %rbx</span><br><span class="line">mrmovq	100(%rbx), %rdx</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，每条相邻的指令之间都有<strong>数据依赖</strong>。指令<code>irmovq</code>会将结果存储在寄存器<code>%rax</code>中。指令<code>addq</code>会读寄存器<code>%rax</code>再将结果存储到寄存器<code>%rbx</code>。最后，指令<code>irmovq</code>会读寄存器<code>%rbx</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop:</span><br><span class="line">	subq    %rdx, %rbx</span><br><span class="line">	jne     targ</span><br><span class="line">	irmovq  $10, %rdx</span><br><span class="line">	jmp     loop</span><br><span class="line">targ:</span><br><span class="line">	halt</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，指令<code>jne</code> (第3行)
有<strong>控制依赖</strong>。条件判断的结果会决定执行的下一条指令是<code>irmovq</code>
(第4行) 还是<code>halt</code> (第7行)。</p>
<p>　　在SEQ设计中，数据和控制依赖都是通过<span
style="background-color: yellow">反馈路径</span>解决。</p>
<h4 id="流水线的限制">4.4.2 流水线的限制</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/limitations_of_pipelining_due_to_nonuniform_stages_daleys.svg" class="">
<p>　　这个示例与之前的流水线系统大致相同，但在阶段划分时<span
style="background-color: yellow">阶段的时间不等</span>。时钟周期为最长的阶段延迟，即阶段B的延迟170ps。对于时钟周期，阶段A和C会分别空闲
(表示为白色框)
100ps和50ps，根据这些可以计算出吞吐量为5.88GIPS。此外，单条指令的周期时间增加到了510ps。</p>
<p>　　对于硬件设计者，将系统计算设计划分为时间相等的多个阶段是个严峻的挑战。此外，CPU中的某些硬件单元
(例如，ALU和内存) 无法进一步划分，这使得划分时间相等的阶段更困难。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/limitations_of_pipelineing_due_to_overhead.svg" class="">
<p>　　这个示例与之前的流水线系统大致相同，但在阶段划分时<span
style="background-color: yellow">平均划分为6个阶段</span>。时钟周期为70ps，根据这些可以计算出吞吐量为14.29GIPS。相比3阶段流水线系统，时钟周期减半，但吞吐量并未加倍。</p>
<p>　　为了提高时钟频率，现代CPU采用了阶段很多 (15及更多阶段)
的流水线。CPU架构师将指令的执行划分为很多很简单的步骤，这样是为了保证每个阶段的延迟很小。电路设计师需要尽可能保证流水线寄存器的延迟足够小。芯片设计师需要小心地设计时钟传播网络以保证时钟在整个芯片上同时改变。所有这些因素都会增加CPU设计的难度。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/limitations_of_pipelining_due_to_logical_dependencies.svg" class="">
<p>　　将反馈机制加入流水线后，在未流水线化的系统中，每条指令的结果都可以反馈给下一条指令。将该系统转化为3阶段流水线系统时
(每条指令的结果只能反馈给其后的第3条指令)，程序的行为将发生改变，所以必须以某种方式处理指令之间的数据和控制依赖来保证得到的行为符合ISA定义的模型。</p>
<h3 id="y86-64的流水线实现">4.5 Y86-64的流水线实现</h3>
<p>　　为了实现流水线化的Y86-64，首先，需要调整顺序SEQ中阶段的顺序，使得更新PC阶段在周期的开始执行，得到<span
style="background-color: yellow">SEQ+</span>。然后，在各个阶段之间加上流水线寄存器，得到<span
style="background-color: yellow">PIPE-</span>
(-表示性能比SEQ+更差)。最后，还需要一些修改来保证正确地处理各种数据和控制依赖。</p>
<h4 id="seq-1">4.5.1 SEQ+</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/seq+_hardware_structure.svg" class="">
<p>　　在SEQ+中，PC更新阶段会使用1组时钟寄存器来保存前一条指令执行过程中计算出来的信号，根据这些信号可以计算出PC值。这种模式是一个小小的例证——可以用不同于ISA隐含的概念模型的方式来实现CPU，只要CPU能正确执行机器语言程序。这种模式中无需将状态编码为程序员可见的状态指示形式，只要CPU能够为程序员可见状态生成正确的值。</p>
<p>　　SEQ到SEQ+中对状态单元的改变是一种很通用的改进方法的示例，这种改进称为<strong>电路重定时</strong>，重定时会改变系统的状态表示，但并不改变其逻辑行为，通常用于平衡流水线系统里各个阶段之间的延迟。</p>
<h4 id="pipe-">4.5.2 PIPE-</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/pipe-_hardware_structure.svg" class="">
<p>　　在PIPE-中，<span
style="background-color: yellow">蓝色方框表示流水线寄存器</span>，每个寄存器包括不同的字段，用白色方框表示。同顺序处理CPU的硬件结构图不同，这些<span
style="background-color: yellow">白色方框表示实际的硬件组成</span>。大写的前缀表示流水线寄存器，所以<code>M_stat</code>表示流水线寄存器<code>M</code>的状态码字段。小写的前缀表示流水线的阶段，所以<code>m_stat</code>表示访存阶段中控制逻辑块生成的状态信号。</p>
<p>　　流水线寄存器<code>F</code>用于保存PC的预测值。流水线寄存器<code>D</code>用于保存最近取出的指令的信息。流水线寄存器<code>E</code>用于保存最近译码的指令和从寄存器文件中读出的值的信息。流水线寄存器<code>M</code>用于保存最近执行的指令的结果和处理条件判断和分支目标的信息。流水线寄存器<code>W</code>用于将反馈路径计算出来的值提供给寄存器文件和指令<code>ret</code>完成后向PC提供返回地址。</p>
<p>　　PIPE-取指阶段负责预测PC的下一个值和取指阶段实际的PC值。标签为Predict
PC的块会在PC增加后的值<code>valP</code>和根据取出的指令得到的值<code>valC</code>中进行选择，选择的值会作为PC的预测值并存储到流水线寄存器<code>F</code>中。标签为Select
PC的块类似于SEQ+中PC更新阶段中标签为PC的块，它会从预测的PC值、存储在流水线寄存器<code>M_valA</code>中的<code>valP</code>
(对于达到流水线寄存器<code>M</code>的不选择分支的指令)
和存储在流水线寄存器<code>W_valM</code>中的返回地址的值
(对于达到流水线寄存器<code>W</code>的指令<code>ret</code>)
中进行选择，得到PC值。</p>
<p>　　标签为Select
A的块会从流水线寄存器<code>D</code>中的<code>valP</code>和寄存器文件A端口中读出的值来中选择，得到值<code>valA</code>。这个块是为了减少要携带给寄存器<code>E</code>和<code>M</code>的状态数量。在所有指令中，只有<code>call</code>的访存阶段和跳转指令的执行阶段
(不需要执行跳转)
会需要值<code>valP</code>，而这2个指令都不从寄存器文件中读取值，所以将它们合并为值<code>valA</code>，这样就不需要标签为Data的块
(功能类似)。</p>
<p>　　SEQ+和PIPE-在译码阶段都生成了值<code>dstE</code>和<code>dstM</code>。SEQ+可以将这些值直接连接到寄存器文件写端口的地址输入。PIPE-会一直携带这些值，直到写回阶段才将其传递给寄存器文件，这样做是为了保证写端口的地址和数据输入来自同一条指令。</p>
<p>　　在SEQ和SEQ+中，同一时刻只能处理1条指令，所以<code>valC</code>、<code>srcA</code>和<code>valE</code>等值有唯一值。在PIPE-中，与各个指令相关联的这些值有多个版本，会随着指令一起流过系统，需要确保使用的是正确的值。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/simple_example_of_instruction_flow_through_pipeline.svg" class="">
<p>　　这个示例描述了每条指令通过流水线各个阶段的行进过程，时间从左到右递增。周期1取出指令I1，然后该指令开始通过流水线各个阶段，到周期5结束后，其结果写入到寄存器文件，依此类推。下方是周期5的流水线的扩展，取指阶段在底部，写回阶段在顶部，同PIPE-一样，因为正常的程序是从上到下执行。</p>
<h4 id="流水线隐患">4.5.3 流水线隐患</h4>
<p>　　数据和控制依赖可能会导致流水线生成错误的计算，称为<strong>隐患</strong>。与依赖类似，隐患可以分为<strong>数据隐患</strong>和<strong>控制隐患</strong>。</p>
<p>　　●
程序寄存器出现数据隐患是因为寄存器文件的读写是在不同阶段进行的，导致不同指令之间可能出现意料之外的相互作用。</p>
<p>　　●
更新和读取PC之间的冲突会导致控制隐患。当取指阶段的逻辑在取下一条指令前正确地预测PC的新值，就不会导致控制隐患。</p>
<p>　　●
数据存储器的读写发生在访存阶段，在读存储器的指令到达这个阶段前，前面所有写存储器的指令都已完成该阶段。在访存阶段中的写数据的指令和在取指阶段中的读数据的指令之间会发生冲突，因为指令和数据存储器引用的是同一地址空间，只有包含自我修改代码的程序才会出现这种情况，在这样的程序中，指令写存储器的某部分，然后再从同一存储器中取出指令。有些系统有复杂的机制来检验和避免此类隐患，而有些系统只能简单强制要求程序不能使用自我修改代码。为了简便，这里<span
style="background-color: yellow">假设程序不能自我修改</span>。</p>
<p>　　●
整数操作指令会在执行阶段写CC寄存器。条件移动指令会在执行阶段读CC寄存器。条件跳转指令会在访存阶段读CC寄存器。在条件移动指令和条件跳转指令到达执行阶段前，前面所有的整数操作指令都已完成该阶段，所以CC寄存器不会有隐患。</p>
<p>　　●
指令通过流水线时，会影响程序状态。这里采用流水线中每条指令都与状态码相关联的机制，使得异常发生时，CPU能够有条理地停止。</p>
<h5 id="避免数据隐患">4.5.3.1 避免数据隐患</h5>
<p>　　<strong>暂停</strong>是避免隐患的常用技术之一，CPU会让部分指令暂停在它们所处的阶段，而允许其他指令继续通过流水线，直到构成的隐患条件不再满足。让指令暂停在译码阶段，直到生成其操作数的指令通过写回阶段，这样就能避免数据隐患。实现暂停的方式就是在执行阶段插入1个<strong>气泡</strong>，气泡就像自动生成的<code>nop</code>指令，代价是性能损失。</p>
<p>　　另一种避免数据隐患的技术是<strong>数据转发</strong>，也称为<strong>转发</strong>或<strong>旁路</strong>，即将值直接从当前阶段转发到更早阶段。数据转发需要在基本的硬件结构中添加一些额外的数据连接和控制逻辑。在PIPE-中加入数据转发会得到<span
style="background-color: yellow">PIPE</span>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/pipe_hardware_structure.svg" class="">
<p>　　相比PIPE-，PIPE在译码阶段中加入了标签为Sel+Fwd A和Fwd
B的2个块，标签为Sel+Fwd A的块是PIPE-中标签为Select
A的块和转发逻辑的结合，它会在PC增加后的值<code>valP</code>、寄存器文件A端口读出的值和某个转发过来的值中进行选择，得到流水线寄存器<code>E</code>中的<code>valA</code>。标签为Fwd
B的块是源操作数<code>valB</code>的转发逻辑。PIPE中有5个转发源
(<code>e_valE</code>、<code>M_valE</code>、<code>m_valE</code>、<code>W_valM</code>和<code>W_valE</code>)
和2个转发目的地 (<code>valA</code>和<code>valB</code>)。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/simple_example_of_load_or_use_hazard.svg" class="">
<p>　　有1类数据隐患不能简单地用转发来避免——<strong>加载/使用隐患</strong>，因为访存阶段是流水线中较晚的阶段。例如，这个示例中第5行的指令<code>irmovq</code>需要在周期8才能将值加载到寄存器<code>%rax</code>，而第6行的指令<code>addq</code>在周期7就需要使用寄存器<code>%rax</code>。用暂停来避免加载/使用隐患的方法称为<strong>加载互锁</strong>，加载互锁与转发结合起来可以避免所有的数据隐患，这个示例可以在第6行插入气泡来避免隐患。</p>
<h5 id="避免控制隐患">4.5.3.2 避免控制隐患</h5>
<p>　　控制隐患只会出现在指令<code>ret</code>和跳转指令，后者只有在条件跳转分支预测错误时才会导致问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000:      irmovq  stack, %rsp</span><br><span class="line">0x00a:      call    proc</span><br><span class="line">0x013:      irmovq  $10, %rdx</span><br><span class="line">0x01d:      halt</span><br><span class="line">0x020:  .pos 0x20</span><br><span class="line">0x020:  proc:</span><br><span class="line">0x020:      ret</span><br><span class="line">0x021:      rrmovq  %rdx, %rbx</span><br><span class="line">0x030:  .pos 0x30</span><br><span class="line">0x030:  stack:</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/processing_instruction_ret.svg" class="">
<p>　　在这个示例中，周期3取出指令<code>ret</code>并沿着流水线继续执行，在周期7进入写回阶段。在其进行译码、执行和访存阶段时，流水线不能执行任何有用的活动，即在这3个周期插入气泡。由于<span
style="background-color: yellow">无法在取指阶段插入气泡</span>，只能在译码阶段插入气泡，PC的新值会预测为<code>0x021</code>
(第8行)，这个地址是错误的。一旦指令<code>ret</code>到达写回阶段，PC选择逻辑会将PC值设为返回地址，然后取指阶段就会取出位于返回点处
(地址<code>0x013</code>) 的指令<code>irmovq</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000:      xorq    %rax, %rax</span><br><span class="line">0x002:      jne     target </span><br><span class="line">0x00b:      irmovq  $1, %rax</span><br><span class="line">0x015:      halt</span><br><span class="line">0x016:  target:</span><br><span class="line">0x016:      irmovq  $2, %rdx</span><br><span class="line">0x020:      irmovq  $3, %rbx</span><br><span class="line">0x02a:      halt</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/processing_mispredicted_branch_instruction.svg" class="">
<p>　　在这个示例中，指令<code>jne</code> (第2行)
并不会执行跳转，但由于预测跳转指令会跳转，所以周期3会取出位于跳转目标处的指令
(第6行)，周期4会取出跳转目标处指令的下一条指令
(第7行)。指令只有到了执行阶段才能改变程序员可见状态，所以通过在下一周期的译码阶段和执行阶段插入气泡并取出指令<code>jne</code>的下一条指令
(第3行) 来<strong>取消</strong> (也称为<strong>指令排除</strong>)
这2条预测错误的指令。</p>
<h4 id="pipe各阶段的实现">4.5.4 PIPE各阶段的实现</h4>
<p>　　PIPE的HCL代码类似于SEQ，不同的是给信号加上了类似PIPE中的前缀。例如，<code>D_</code>表示该信号来自流水线寄存器<code>D</code>，<code>d_</code>表示该信号在译码阶段生成。</p>
<h5 id="取指阶段-1">4.5.4.1 取指阶段</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/pipe_fetch_stage.svg" class="">
<p>　　PIPE取指阶段会选择PC的当前值并预测下一个PC值。从存储器中读指令和提取不同指令字段的硬件单元与SEQ的相同。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word f_pc =</span><br><span class="line">[</span><br><span class="line">    # 预测错误的分支</span><br><span class="line">    M_icode == IJXX &amp;&amp; !M_Cnd : M_valA;</span><br><span class="line">    # 完成ret指令</span><br><span class="line">    W_icode == IRET : W_valM;</span><br><span class="line">    # 默认使用PC预测值</span><br><span class="line">    <span class="number">1</span> : F_predPC;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　PC选择逻辑会从3个PC源中进行选择。当预测错误的分支进入访存阶段时，会从在流水线寄存器<code>M</code>中读取该指令的<code>valP</code>
(存储在<code>M_valA</code>，表示下一条指令的地址)。当指令<code>ret</code>进入写回阶段时，会从流水线寄存器<code>W</code>中读取返回地址
(存储在<code>W_valM</code>)。其他情况使用存储在寄存器<code>F</code>中的PC预测值
(存储在<code>F_predPC</code>)。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word f_predPC =</span><br><span class="line">[</span><br><span class="line">    f_icode <span class="keyword">in</span> &#123; IJXX, ICALL &#125; : f_valC;</span><br><span class="line">    <span class="number">1</span> : f_valP;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　当取出的指令为跳转指令或指令<code>call</code>时，PC预测逻辑会选择<code>valC</code>；否则，选择<code>valP</code>。</p>
<p>　　标签为Instr valid、Need regids和Need valC的块与SEQ中的相同。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word f_stat =</span><br><span class="line">[</span><br><span class="line">    imeme_error : SADR;</span><br><span class="line">    !instr_valid : SINS;</span><br><span class="line">    f_icode == IHALT : SHLT;</span><br><span class="line">    <span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　同SEQ不同，PIPE将指令状态的计算分为2部分。在取指阶段，可以检测非法指令、指令<code>halt</code>和指令地址越界导致的内存异常，但非法数据地址的检测必须推迟到访存阶段。</p>
<h5 id="译码和写回阶段-1">4.5.4.2 译码和写回阶段</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/pipe_decode_and_write-back_stage.svg" class="">
<p>　　标签为dstE、dstM、srcA和srcB的块与SEQ中的相似。此外，提供给寄存器文件写端口的寄存器ID
(信号<code>W_dstE</code>和<code>W_dstM</code>)
来自写回阶段而非译码阶段，因为对目的寄存器的写操作由写回阶段中的指令指定。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word d_valA =</span><br><span class="line">[</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123; ICALL, IJXX &#125; : D_valP;    # 选择增加后的PC</span><br><span class="line">    d_srcA == e_dstE : e_valE;              # 选择执行阶段的valE</span><br><span class="line">    d_srcA == M_dstM : m_valM;              # 选择访存阶段的valM</span><br><span class="line">    d_srcA == M_dstE : M_valE;              # 选择访存阶段的valE</span><br><span class="line">    d_srcA == W_dstM : W_valM;              # 选择写回阶段的valM</span><br><span class="line">    d_srcA == W_dstE : W_valE;              # 选择写回阶段的valE</span><br><span class="line">    <span class="number">1</span> : d_rvalA;                            # 选择寄存器文件A端口的值</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word d_valB =</span><br><span class="line">[</span><br><span class="line">    d_srcB == e_dstE : e_valE;              # 选择执行阶段的valE</span><br><span class="line">    d_srcB == M_dstM : m_valM;              # 选择访存阶段的valM</span><br><span class="line">    d_srcB == M_dstE : M_valE;              # 选择访存阶段的valE</span><br><span class="line">    d_srcB == W_dstM : W_valM;              # 选择写回阶段的valM</span><br><span class="line">    d_srcB == W_dstE : W_valE;              # 选择写回阶段的valE</span><br><span class="line">    <span class="number">1</span> : d_rvalB;                            # 选择寄存器文件B端口的值</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　PIPE译码阶段的复杂之处在于转发逻辑。如前所述，有5个不同的转发源，每个转发源都有1个数据字和1个目的寄存器ID。标签为Sel+Fwd
A的块除了负责源操作数<code>valA</code>的转发，还会将<code>valP</code>合并到<code>valA</code>。合并<code>valA</code>和<code>valP</code>的依据是只有指令<code>call</code>和跳转指令在后面的阶段需要<code>valP</code>，而且这两者都不需要从寄存器文件A端口读取值。</p>
<table>
<thead>
<tr>
<th>数据字</th>
<th>寄存器ID</th>
<th>源描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>e_valE</code></td>
<td><code>e_dstE</code></td>
<td>ALU输出</td>
</tr>
<tr>
<td><code>m_valN</code></td>
<td><code>M_dstM</code></td>
<td>数据存储器输出</td>
</tr>
<tr>
<td><code>M_valE</code></td>
<td><code>M_dstE</code></td>
<td>访存阶段中对端口E即将进行的写</td>
</tr>
<tr>
<td><code>W_valM</code></td>
<td><code>W_dstM</code></td>
<td>写回阶段中对端口M即将进行的写</td>
</tr>
<tr>
<td><code>W_valE</code></td>
<td><code>W_dstE</code></td>
<td>写回阶段中对端口E即将进行的写</td>
</tr>
</tbody>
</table>
<p>　　源操作数<code>valA</code>的转发逻辑中的<span
style="background-color: yellow">5个转发源的优先级很重要</span>，该优先级由HCL代码中检测5个目的寄存器ID的顺序来决定。若选择了其他顺序，则可能会导致某些程序的流水线出错。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/simple_example_of_forwarding_priority.svg" class="">
<p>　　在这个示例中，前2条指令会写寄存器<code>%rdx</code>，第3条指令会将寄存器<code>%rdx</code>作为源操作数。当第3条指令到达译码阶段
(周期4)
时，转发逻辑必须在2个都以寄存器<code>%rdx</code>为目的地的值中选择一个。按照机器语言程序的行为，第3条指令应该从寄存器<code>%rdx</code>中读出3，所以流水线化的实现应该<span
style="background-color: yellow">保证流水线阶段最早的转发源有最高的优先级</span>。按照这一点，转发逻辑会先在执行阶段检测转发源，然后在访存阶段检测转发源，最后在写回阶段检测转发源。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word Stat =</span><br><span class="line">[</span><br><span class="line">    W_stat == SBUB : SAOK;</span><br><span class="line">    <span class="number">1</span> : W_stat;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　PIPE写回阶段正如图中所示，整个流水线的状态<code>Stat</code>根据流水线寄存器<code>W</code>中的状态值计算而来。如前所述，状态码应该指明是正常操作或3种异常之一。流水线寄存器<code>W</code>保存着最近完成指令的状态，所以该值很适合用于表示整个流水线的状态。唯一要考虑的特殊情况是写回阶段出现气泡，但这也属于正常操作。</p>
<h5 id="执行阶段-1">4.5.4.3 执行阶段</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/pipe_execute_stage.svg" class="">
<p>　　PIPE执行阶段中的块同SEQ中的相似，使用的信号也进行了适当的重命名。<code>e_valE</code>和<code>e_dstE</code>作为转发源，转发到译码阶段。与SEQ执行阶段不同的是标签为Set
CC的块以<code>W_stat</code>和<code>m_stat</code>作为输入，决定是否要更新CC，用于检测异常指令正在通过后续流水线阶段的情况。</p>
<h5 id="访存阶段-1">4.5.4.4 访存阶段</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/pipe_memory_stage.svg" class="">
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">word m_stat =</span><br><span class="line">[</span><br><span class="line">    dmem_error : SADR;</span><br><span class="line">    <span class="number">1</span> : M_stat;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>　　PIPE访存阶段与SEQ访存阶段相似，但没有标签为Data的块
(用于数据源<code>valP</code>和<code>valA</code>中进行选择)，因为其功能由译码阶段中标签为Sel+Fwd
A的块负责。该阶段中的其他块同SEQ中的相似，使用的信号进行了适当的重命名。如前所述，访存阶段仅能检测非法数据地址。</p>
<h4 id="异常处理">4.5.5 异常处理</h4>
<p>　　在流水线系统中，异常处理包括一些细节问题。</p>
<p>　　1) 有时可能同时有多个异常指令，例如，<span
style="background-color: yellow">同一流水线周期</span>中取指阶段有<code>halt</code>指令和访存阶段出现指令数据地址越界。在这种情况下，基本原则是<span
style="background-color: yellow">异常指令所处流水线阶段越靠后，优先级越高</span>，所以应该反馈地址越界。</p>
<p>　　2)
当指令被取出并开始执行时导致了异常，但后来由于分支预测错误，取消了该指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000:  6300                    |       xorq    %rax,%rax</span><br><span class="line">0x002:  741600000000000000      |       jne     target</span><br><span class="line">0x00b:  30f00100000000000000    |       irmovq  $1, %rax</span><br><span class="line">0x015:  00                      |       halt</span><br><span class="line">0x016:                          |   target:</span><br><span class="line">0x016:  ff                      |       .byte 0xFF</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，分支预测会取出第6行代码，所以译码阶段会出现非法指令异常。之后，流水线发现不应该选择分支，就会取消该指令。</p>
<p>　　3)
某条指令导致了异常，它后面的指令在异常指令完成前改变了部分状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">irmovq  $1, %rax</span><br><span class="line">xorq    %rsp, %rsp</span><br><span class="line">pushq   %rax</span><br><span class="line">addq    %rax, %rax</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，指令<code>xorq</code>会将栈指针和CC分别设置为<code>0x00</code>和100，指令<code>pushq</code>会减少栈指针进而导致地址异常，访存阶段会发现这个异常。在同一周期内，指令<code>addq</code>处于执行阶段，而它会将CC设置成新值。</p>
<p>　　处理异常的简单而可靠的机制是<span
style="background-color: yellow">携带指令的异常状态和其他信息一起通过流水线</span>。每个流水线寄存器中都有状态码<code>stat</code>，其功能是处理异常。若出现了异常，则<code>stat</code>会设置为表示异常的值并继续执行取指、译码和执行。当异常指令达到访存或写回阶段时，会采取措施禁止修改程序员可见状态，包括<span
style="background-color: yellow">禁止执行阶段中的指令设置CC</span>、<span
style="background-color: yellow">在访存阶段插入气泡以禁止写数据存储器</span>和<span
style="background-color: yellow">在写回阶段有异常指令时暂停写回阶段</span>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/processing_invalid_memory_reference_exception.svg" class="">
<p>　　在这个示例的周期6中，指令<code>pushq</code>到达访存阶段并引起了内存异常，指令<code>addq</code>到达执行阶段并生成了新的CC。当访存或写回阶段中有异常指令时
(检测信号<code>m_stat</code>和<code>W_stat</code>)，会禁止设置CC
(将信号<code>set_cc</code>置0)。从整体角度，处理过程还包括在访存阶段插入气泡和暂停写回阶段。</p>
<h4 id="流水线控制逻辑">4.5.6 流水线控制逻辑</h4>
<p>　　流水线控制逻辑必须处理加载/使用隐患、指令<code>ret</code>、预测错误的分支和异常。</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr>
<th>特殊情况</th>
<th>触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理指令<code>ret</code></td>
<td><code>IRET in &#123; D_icode, E_icode, M_icode &#125;</code></td>
</tr>
<tr>
<td>加载/使用隐患</td>
<td><code>E_icode in &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM in &#123; d_srcA, d_srcB &#125;</code></td>
</tr>
<tr>
<td>预测错误分支</td>
<td><code>E_icode = IJXX &amp;&amp; !e_Cnd</code></td>
</tr>
<tr>
<td>异常</td>
<td><code>m_stat in &#123; SADR, SINS, SHLT &#125; || W_stat in &#123; SADR, SINS, SHLT &#125;</code></td>
</tr>
</tbody>
</table>
<h5 id="流水线控制机制">4.5.6.1 流水线控制机制</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/additional_pipeline_register_operations.svg" class="">
<p>　　相比非流水线寄存器，流水线寄存器加入了<span
style="background-color: yellow">暂停</span>和<span
style="background-color: yellow">气泡</span>这2个控制信号。在正常情况下，这2个控制信号都为0，寄存器会加载输入作为状态。当暂停为1时，寄存器不会更新状态。当气泡为1时，寄存器状态会设置为某个固定的<strong>复位配置</strong>
(等同于<code>nop</code>指令的状态)，复位配置的0/1模式由流水线寄存器中的字段的集合决定。若需要在流水线寄存器<code>D</code>中插入气泡，只需将<code>icode</code>设置为<code>INOP</code>。若需要在流水线寄存器<code>E</code>中插入气泡，需要将<code>icode</code>设置为<code>INOP</code>并将<code>dstE</code>、<code>dstM</code>、<code>srcA</code>和<code>srcB</code>设置为<code>RNONE</code>。此外，这里<span
style="background-color: yellow">将气泡和暂停都置为1视为出错</span>。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 15%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th>特殊情况</th>
<th>流水线寄存器<code>F</code></th>
<th>流水线寄存器<code>D</code></th>
<th>流水线寄存器<code>E</code></th>
<th>流水线寄存器<code>M</code></th>
<th>流水线寄存器<code>W</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>处理指令<code>ret</code></td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>加载/使用隐患</td>
<td>暂停</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>预测错误的分支</td>
<td>正常</td>
<td>气泡</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
</tbody>
</table>
<p>　　这是在3种特殊情况下各个流水线寄存器应采取的行动。在时序方面，流水线寄存器的暂停和气泡控制输入都是由组合逻辑块生成，所以这些值必须是合法的，保证下个时钟周期开始时，每个流水线寄存器要么加载，要么暂停，要么气泡。</p>
<h5 id="控制条件的组合">4.5.6.2 控制条件的组合</h5>
<p>　　在之前的设计中都是假设单个时钟周期内最多只会出现1种特殊情况，这是常见的缺陷之一。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/pipeline_states_for_special_control_conditions.svg" class="">
<p>　　单个时钟周期可能出现2种特殊情况，因为大多数控制条件都是<span
style="background-color: yellow">互斥</span>的。例如，加载/使用隐患不能和预测错误的分支同时出现，因为加载/使用隐患要求执行阶段是加载指令
(<code>mrmovq</code>和<code>popq</code>)，而预测错误的分支要求执行阶段是跳转指令。同样，处于执行或访存阶段的指令<code>ret</code>也不能与加载/使用隐患或预测错误的分支同时出现。只有箭头标明的2种组合可能同时出现。</p>
<p>　　组合A中执行阶段是预测错误的跳转指令，而译码阶段是指令<code>ret</code>，流水线控制逻辑会发现分支预测错误，所以取消指令<code>ret</code>。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 15%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr>
<th>特殊情况</th>
<th>流水线寄存器<code>F</code></th>
<th>流水线寄存器<code>D</code></th>
<th>流水线寄存器<code>E</code></th>
<th>流水线寄存器<code>M</code></th>
<th>流水线寄存器<code>W</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>处理指令<code>ret</code></td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>预测错误的分支</td>
<td>正常</td>
<td>气泡</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>组合A</td>
<td>暂停</td>
<td>气泡</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
</tbody>
</table>
<p>　　这是出现组合A时的流水线应采取的行动
(假设气泡或暂停会覆盖正常)。组合A的处理与预测错误的分支处理相似，区别是取指阶段是暂停。同样，在下一周期，PC选择逻辑会选择正确的地址而非预测值，所以流水线寄存器F的行动不重要。</p>
<p>　　组合B包括加载/使用隐患，其中加载指令设置栈指针，然后指令<code>ret</code>将栈指针作为源操作数，因为它必须从栈中弹出返回地址。流水线控制逻辑应将指令<code>ret</code>暂停在译码阶段。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr>
<th>特殊情况</th>
<th>流水线寄存器<code>F</code></th>
<th>流水线寄存器<code>D</code></th>
<th>流水线寄存器<code>E</code></th>
<th>流水线寄存器<code>M</code></th>
<th>流水线寄存器<code>W</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>处理指令<code>ret</code></td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>加载/使用隐患</td>
<td>暂停</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>组合B</td>
<td>暂停</td>
<td>气泡+暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
<tr>
<td>实际情况</td>
<td>暂停</td>
<td>暂停</td>
<td>气泡</td>
<td>正常</td>
<td>正常</td>
</tr>
</tbody>
</table>
<p>　　这是出现组合B时的流水线应采取的行动，流水线控制逻辑会暂停指令<code>ret</code>来避免加载/使用隐患，同时又因为指令<code>ret</code>而在译码阶段插入气泡。PIPE控制逻辑原本的实现并不能正确处理组合B，因为流水线控制逻辑会将流水线寄存器<code>D</code>的气泡和暂停信号都置1。如前所述，气泡和暂停信号不能都为1，所以译码阶段只采取针对加载/使用隐患的行动并将处理指令<code>ret</code>的行动推迟1个周期。</p>
<h5 id="控制逻辑实现">4.5.6.3 控制逻辑实现</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_04/pipe_pipeline_control_logic.svg" class="">
<p>　　根据来自流水线寄存器和流水线阶段的信号，控制逻辑生成流水线寄存器的暂停和气泡信号，同时也决定是否要更新CC寄存器。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool F_stall = </span><br><span class="line">    # 加载/使用隐患</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125; ||</span><br><span class="line">    # ret指令通过流水线</span><br><span class="line">    IRET <span class="keyword">in</span> &#123; D_icode, E_icode, M_icode &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到加载/使用隐患或指令<code>ret</code>时，流水线寄存器<code>F</code>会暂停。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool D_stall = </span><br><span class="line">    # 加载/使用隐患</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到加载/使用隐患时，流水线寄存器<code>D</code>会暂停。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool D_bubble = </span><br><span class="line">    # 预测错误的分支</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # 不能出现加载/使用隐患和ret指令组合</span><br><span class="line">    !(E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125;) &amp;&amp; IRET <span class="keyword">in</span> &#123; D_icode, E_icode, M_icode &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到预测错误的分支时，流水线寄存器<code>D</code>会插入气泡。不过，遇到加载/使用隐患和指令<code>ret</code>组合时，不会插入气泡。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool E_bubble = </span><br><span class="line">    # 预测错误的分支</span><br><span class="line">    (E_icode == IJXX &amp;&amp; !e_Cnd) ||</span><br><span class="line">    # 加载/使用隐患</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123; IMRMOVQ, IPOPQ &#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123; d_srcA, d_srcB &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到加载/使用隐患或预测错误的分支时，流水线寄存器<code>E</code>会插入气泡。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool set_cc = </span><br><span class="line">    E_icode == IOPQ &amp;&amp;</span><br><span class="line">    # 正常操作</span><br><span class="line">    !m_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125; &amp;&amp; !W_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125;;</span><br></pre></td></tr></table></figure>
<p>　　只有整数操作指令正常执行时才设置CC。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool M_bubble = </span><br><span class="line">    # 异常指令</span><br><span class="line">    m_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125; || W_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到异常指令时，流水线寄存器<code>M</code>会插入气泡。</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">bool W_stall = W_stat <span class="keyword">in</span> &#123; SADR, SINS, SHLT &#125;;</span><br></pre></td></tr></table></figure>
<p>　　遇到异常指令时，流水线寄存器<code>W</code>会暂停。若某个指令在访存阶段暂停过，则该指令不会达到写回阶段。</p>
<h5 id="测试和验证">4.5.6.4 测试和验证</h5>
<p>　　简单地模拟设计和运行一些典型的程序并不足以用于测试系统。相反，全面的测试需要一些方法来系统地生成很多测试，这些测试将尽可能多地使用不同指令和指令组合。在设计Y86-64时，还设计了很多测试脚本，每个脚本都会生成很多不同的测试，运行CPU模拟并比较得到的寄存器/存储器值和YIS指令集模拟器生成的值。</p>
<p>　　●
<strong>optest</strong>：运行49个不同的Y86-64指令的测试，包括不同的源和目的寄存器。</p>
<p>　　●
<strong>jtest</strong>：运行64个不同的跳转指令和指令<code>call</code>的测试，包括不同的分支组合。</p>
<p>　　●
<strong>cmtest</strong>：运行28个不同的条件移动指令的测试，包括不同的控制组合。</p>
<p>　　●
<strong>htest</strong>：运行600个不同的数据隐患可能性的测试，包括不同的源和目的指令的组合，在这些指令之间有不同的数量的<code>nop</code>指令。</p>
<p>　　● <strong>ctest</strong>：测试22个不同的控制组合。</p>
<p>　　●
<strong>etest</strong>：测试12种不同的异常指令和跟在其后可能改变程序员可见状态的指令组合。</p>
<p>　　即使设计通过了大量的测试，也不能保证它能正确运行所有程序。即使只考虑由较短的代码组成的测试，待测试的可能的程序的数量也很庞大。不过，<strong>形式化验证</strong>能够保证有工具能够严格地考虑到系统所有可能的行为并确定是否有设计错误。例如，形式化验证Y86-64的早期版本之一，建立框架来比较PIPE和SEQ，该框架能够证明对于任意的Y86-64程序，两者对程序员可见状态的影响完全相同，该过程使用归纳法。进行这种分析要求用<strong>符号方法</strong>来推导硬件。在符号方法中，所有的程序值都是任意整数，ALU抽象为黑盒并根据其参数计算某个未指定的函数。形式化验证还处于发展的早期阶段，并不能完全验证。</p>
<h4 id="性能分析">4.5.7 性能分析</h4>
<p>　　所有需要流水线控制逻辑进行特殊处理的条件，都会导致流水线不能实现每个时钟周期发出1条新指令，这通过确定往流水线中插入气泡的频率来衡量，因为插入1个气泡会导致1个流水线周期不被使用。返回指令会生成3个气泡，加载/使用隐患会生成1个气泡，预测错误的分支会生成2个气泡。异常的定义表明其出现频率很低，所以可以忽略。可以通过计算流水线执行1条指令所需的平均时钟周期的估计值来量化这些处罚的性能影响，这种衡量方法称为<strong>每指令周期数</strong>
(CPI)。</p>
<p>　　假设在某个CPU上运行某个基准程序并观察执行阶段的运行。每个周期中，执行阶段要么处理1条指令并继续剩下的阶段直到完成；要么处理3种特殊情况之一并插入气泡。若这个阶段一共处理了<span
class="math inline">\(C_i\)</span>条指令和<span
class="math inline">\(C_b\)</span>个气泡，则CPU共需要大约<span
class="math inline">\(C_i+C_b\)</span>个时钟周期来执行<span
class="math inline">\(C_i\)</span>条指令
(忽略了启动指令通过流水线的周期)。 <span class="math display">\[
CPI=\frac{C_i+C_b}{C_i}=1.0+\frac{C_b}{C_i}
\]</span> 　　CPI等于1.0加处罚项<span
class="math inline">\(\frac{C_b}{C_i}\)</span>，这个项表示执行1条指令需要插入的气泡的平均值。
<span class="math display">\[
CPI=1.0+lp+mp+rp
\]</span> 　　处罚项<span
class="math inline">\(\frac{C_b}{C_i}\)</span>可以分为3部分，<span
style="background-color: yellow">加载处罚<span
class="math inline">\(lp\)</span></span>表示由于加载/使用隐患造成暂停而插入的气泡的平均值，<span
style="background-color: yellow">预测错误的分支处罚<span
class="math inline">\(mp\)</span></span>表示由于预测错误的分支造成取消指令而插入的气泡的平均值，<span
style="background-color: yellow">返回处罚<span
class="math inline">\(rp\)</span></span>表示由于指令<code>ret</code>造成暂停而插入的气泡的平均值。</p>
<table>
<thead>
<tr>
<th></th>
<th>处罚</th>
<th>指令出现机率</th>
<th>造成特殊情况的机率</th>
<th>气泡数</th>
<th>乘积</th>
</tr>
</thead>
<tbody>
<tr>
<td>加载指令</td>
<td><span class="math inline">\(lp\)</span></td>
<td>0.25</td>
<td>0.20</td>
<td>1</td>
<td>0.05</td>
</tr>
<tr>
<td>跳转指令</td>
<td><span class="math inline">\(mp\)</span></td>
<td>0.20</td>
<td>0.40</td>
<td>2</td>
<td>0.16</td>
</tr>
<tr>
<td>指令<code>ret</code></td>
<td><span class="math inline">\(rp\)</span></td>
<td>0.02</td>
<td>1.00</td>
<td>3</td>
<td>0.06</td>
</tr>
<tr>
<td>总和</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0.27</td>
</tr>
</tbody>
</table>
<p>　　3种处罚的总和是0.27，得到CPI为1.27。若想要进一步降低CPI，则应该优化预测错误的分支。若使用成功率为65%的分支预测策略，则<span
class="math inline">\(mp=0.35\cdot0.20\cdot2=0.14\)</span>，这个提升并不大，但如果分支预测策略的成本不高，则这个提升还算值得。</p>
<h4 id="未完成的工作">4.5.8 未完成的工作</h4>
<p>　　PIPE还缺乏<span
style="background-color: yellow">多指令周期</span>和<span
style="background-color: yellow">存储系统接口</span>这些CPU设计中必须的关键特性。</p>
<p>　　Y86-64指令集的所有指令都包括一些整数加法等简单的操作。这些操作可以在执行阶段的单周期内处理完成。在一个更完整的指令集中，还将实现一些整数乘除和浮点运算等更复杂的指令。像PIPE这种性能中等的CPU中，这些操作的典型执行时间从浮点加法的3或4个周期到整数除法的64个周期。为了实现这些指令，还需要额外的硬件和协调这些指令的处理和流水线其他部分的机制。</p>
<p>　　实现多指令周期的方法之一是直接用整数和浮点运算单元扩展执行阶段逻辑的功能，但是这种方法需要指令在执行阶段停留多个周期，进而导致取指和译码阶段暂停，所以这种方法的性能并不好。</p>
<p>　　另一种实现多指令周期的方法是使用独立于主流水线的特殊硬件功能单元来处理较复杂的操作，这种方法的性能更好。通常，有1个功能单元来执行整数乘除，还有1个功能单元来执行浮点操作。当指令进入译码阶段时，可以将其发送给特殊单元。在特殊单元处理时，流水线会继续执行其他指令。通常，浮点处理单元本身也是流水线化的，所以多条指令可以在主流水线和各个单元中并发执行。不同单元的操作必须同步以避免出错，这可以通过暂停、气泡、转发和取消等机制来实现。</p>
<p>　　PIPE会假设取指单元和数据存储器都可以在单时钟周期内读写内存中的任意位置，并且忽略了自我修改代码可能造成的隐患。如前所述，CPU的存储系统由多个硬件存储器和管理内存的操作系统共同组成。存储系统被组织成层次结构，典型的CPU有2个L1缓存，分别用于读写指令和数据。另一种缓存是<strong>页表缓存</strong>
(TLB)，用于将虚拟地址快速转换为物理地址。将两者结合起来，在大多数情况下，可以在单周期内读指令并读写数据。</p>
<p>　　缓存总保存最常引用的存储器位置，但还是会出现<strong>未命中</strong>
(引用的位置不在缓存内)。在最好的情况下
(在更高级的缓存或内存中找到未命中的数据)，处理缓存未命中需要3~20个时钟周期。同时，流水线会将指令暂停在取指或访存阶段，直到缓存能够执行读写。</p>
<p>　　在部分情况下，被引用的存储器位置实际上是位于磁盘。此时，硬件会生成<strong>缺页</strong>异常信号。同其他异常一样，该异常会导致CPU调用操作系统的异常处理函数并发起1个磁盘到内存的移动操作。一旦完成，操作系统会返回到原来的程序并重新执行缺页的程序。因为磁盘存取需要数百万个周期，缺页中断处理函数执行所需的几百个时钟周期可以忽略不记。</p>
<p>　　在CPU角度，将暂停 (处理短时间的缓存未命中) 和异常
(处理长时间的缺页)
结合起来，能够解决访问存储器时由于存储器层次结构引起的所有不可预测性而导致的问题。</p>
<p>　　PIPE等5阶段流水线代表了20世纪80年代中期的CPU设计水平。伯克利的Patternson研究组开发的RISC
CPU原型是Sun Microsystem在1987年开发的第一个SPARC
CPU的基础。斯坦福的Hennessy研究组开发的CPU由MIPS Technologies
(Hennessy成立的公司)
在1986年商业化。这两者都使用的是5阶段流水线。i486也是5阶段流水线，只不过阶段之间的职责划分不太相同，它有2个译码阶段和1个合并的执行/访存阶段。这些流水线化设计的CPI也大于1.0。</p>
<p>　　较新的CPU支持<strong>超标量</strong>
(并行地取指、译码和执行多条指令)，可以实现小于1.0的CPI。当超标量CPU已经广泛使用时，性能测量标准变为了CPI的倒数——每周期执行指令数
(IPC)。最新的设计使用称为<strong>乱序</strong>的技术来并行地执行多条指令，顾名思义，执行的顺序可能完全不同于它们在程序中出现的顺序，但保留了顺序ISA模型的整体行为。在芯片上集成许多简单的CPU而非少量更复杂的CPU来提高整体计算能力的策略称为<strong>多核</strong>。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第8章 异常控制流</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_08/</url>
    <content><![CDATA[<p>　　从CPU通电到断电，假设PC的值序列为<span
class="math inline">\(a_0,a_1,..,a_{n-1}\)</span>，其中<span
class="math inline">\(a_k\)</span>是对应的指令<span
class="math inline">\(I_k\)</span>的地址。那么，从<span
class="math inline">\(a_k\)</span>到<span
class="math inline">\(a_{k+1}\)</span>的过渡称为<strong>控制转移</strong>，这样的控制转移序列称为CPU的<strong>控制流</strong>。最简单的控制流就是平滑的序列，即<span
class="math inline">\(I_k\)</span>和<span
class="math inline">\(I_{k+1}\)</span>在内存中是相邻的。这种平滑流的突然变化通常由跳转、调用和返回等指令造成。</p>
<p>　　操作系统必须能够响应内部程序没有捕获的系统状态变化和不一定与程序执行相关的系统状态变化。例如，硬件定时器会定期产生信号，该事件必须得到处理。分组到达网络适配器后，必须存储在内存中。程序向磁盘请求数据，然后睡眠，直到收到数据已就绪的通知。当子进程终止时，其父进程必须收到通知。</p>
<p>　　现代系统通过让控制流发生突然变化来应对这些情况，这些突然变化称为<strong>异常控制流</strong>
(ECF)。ECF发生计算机系统的各个层级。例如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理函数。在操作系统层，内核通过切换上下文来在用户进程之间进行控制转移。在应用层，进程可以发送信号到其他进程，接收者会将控制突然转移到它的信号处理函数。单个程序可以通过回避通常的栈规则并执行到其他函数中任意位置的<strong>非本地</strong>跳转
(即违反常规的调用/返回栈规则的跳转) 来对响应错误。</p>
<p>　　<strong>异常</strong>是ECF的一种形式，由硬件和操作系统共同实现。</p>
<p>　　软件异常允许程序进行非本地跳转来响应。C++和Java等语言通过<code>try</code>、<code>catch</code>和<code>throw</code>语句来提供软件异常机制，C通过函数<code>setjmp()</code>和<code>longjmp()</code>来提供软件异常机制，前者的异常机制相对后者更结构化。<code>catch</code>语句可类比为函数<code>setjmp()</code>，<code>throw</code>语句可类比为函数<code>longjmp()</code>。</p>
<p>　　在CPU中，状态编码为不同的位和信号，状态变化称为<strong>事件</strong>。事件可能和当前执行的指令直接相关。</p>
<p>　　CPU通常通过控制寄存器的<strong>模式位</strong>来限制应用可执行的指令和可访问的地址空间范围。当设置了模式位后，进程就运行在<strong>内核模式</strong>
(也称为<strong>超级用户模式</strong>)，这样该进程可以访问指令集中的任何指令和系统中的任何内存位置。没有设置模式位时，进程运行在用户模式，该模式下不能执行<strong>特权指令</strong>，例如，停止CPU、改变模式位和发起I/O操作。此外，用户模式中的进程不能直接引用地址空间中内核区的代码和数据。</p>
<p>　　Linux提供了很多监控和控制进程的工具。</p>
<p>　　● STRACE：打印正在运行的程序 (及其子进程)
调用的每个系统调用的轨迹。</p>
<p>　　● PS：列出当前系统中的进程 (包括僵尸进程)。</p>
<p>　　● TOP：打印关于当前进程资源使用的信息。</p>
<p>　　● PMAP：显示进程的内存映射。</p>
<p>　　●
<code>proc/</code>：虚拟文件系统，以ASCII文本格式输出大量内核数据结构的信息，用户程序可以读取这些内容。</p>
<p>　　● <code>/sys</code>：Linux
2.6版本内核加入的文件系统，它能输出关于系统总线和设备的额外底层信息。</p>
<span id="more"></span>
<h3 id="异常">8.1 异常</h3>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/anatomy_of_an_exception.svg" class="">
<p>　　当CPU检测到事件发生时，会通过称为<strong>异常表</strong>的跳转表来进行间接过程调用
(异常)，到专门设计来处理此类事件的称为<strong>异常处理函数</strong>的操作系统子程序。当异常处理函数完成处理后，根据引起异常的事件的类型，出现以下情况之一：</p>
<p>　　● 异常处理函数将控制权转移给<span
class="math inline">\(I_{curr}\)</span>，即异常发生时正在执行的指令。</p>
<p>　　● 异常处理函数将控制权转移给<span
class="math inline">\(I_{next}\)</span>，即异常发生时正在执行的指令的下一条指令。</p>
<p>　　● 异常处理函数中止被中断的程序。</p>
<h4 id="异常处理">8.1.1 异常处理</h4>
<p>　　系统中的每种异常都有唯一的非负整数<strong>异常号</strong>。部分异常号由CPU的设计者分配
(例如，除以0、缺页、内存访问越界、断点和算术运算溢出)，其他异常号由操作系统内核的设计者分配
(例如，系统调用和外部I/O设备的信号)。</p>
<p>　　当计算机启动或重启时，操作系统会分配和初始化异常表，使得条目<code>k</code>包含异常<code>k</code>对应的异常处理函数的地址。当CPU检测到事件并确定对应的异常号后，会触发异常，方法是通过异常表的条目来执行到对应异常处理函数的间接过程调用。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/generating_the_address_of_an_exception_handler.svg" class="">
<p>　　对于异常表，索引就是异常号，其起始地址存储在<strong>异常表基址寄存器</strong>中。</p>
<p>　　一旦硬件触发了异常，剩下的工作都由异常处理函数在软件中完成。异常处理函数运行在<span
style="background-color: yellow">内核模式</span>下，所以它们对所有的系统资源都有完全的访问权限。异常处理函数完成处理后，通过特殊的中断返回指令，可选地返回到中断的程序，该指令将适当的状态弹回到CPU的控制和数据寄存器中。若异常中断的是用户程序，则将状态恢复到<span
style="background-color: yellow">用户模式</span>并将控制权转移给中断的程序。</p>
<h4 id="异常类别">8.1.2 异常类别</h4>
<p>　　异常按类型可以分为<span
style="background-color: yellow">中断</span>、<span
style="background-color: yellow">陷阱</span>、<span
style="background-color: yellow">故障</span>和<span
style="background-color: yellow">中止</span>，按同步和异步可以分为<span
style="background-color: yellow">同步异常</span> (陷阱、故障和中止)
和<span style="background-color: yellow">异步异常</span> (中断)。</p>
<table>
<thead>
<tr>
<th>异常类别</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>来自I/O设备的信号</td>
<td>异步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障</td>
<td>可能修复的错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
</tr>
<tr>
<td>中止</td>
<td>不可修复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
<p>　　陷阱、故障和中止是同步发生的，即执行当前指令的结果，而这类指令称为<strong>故障指令</strong>。</p>
<p>　　运行应用程序代码的进程初始默认用户模式，若需要变为内核模式，则需要通过中断、故障或陷阱这样的异常。</p>
<h5 id="中断">8.1.2.1 中断</h5>
<p>　　硬件中断不是由执行任何一条指令造成，所以它是异步的。硬件中断的异常处理函数称为<strong>中断处理函数</strong>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/interrupt_handling.svg" class="">
<p>　　I/O设备向CPU芯片上的中断引脚发送信号并将异常号放到系统总线上来触发中断，该异常号标识了引起中断的设备。在当前指令完成后，CPU检测到中断引脚的电压变高，从系统总线读取异常号并调用对应的中断处理函数。当中断处理函数返回后，将控制权转移给下一条指令，然后程序像没有出现中断一样继续执行。</p>
<h5 id="陷阱">8.1.2.2 陷阱</h5>
<p>　　陷阱是执行某条指令的结果，最重要的用途是在用户程序和内核之间提供像过程一样的接口，称为<strong>系统调用</strong>。用户程序经常会向内核请求服务，例如，读文件<code>read()</code>、创建新进程<code>fork()</code>、加载新程序<code>execve()</code>和中止当前进程<code>exit()</code>，为了允许对此类服务的受控访问，CPU提供了特殊<code>syscall n</code>指令，当用户程序想要请求服务<code>n</code>时，可以执行该指令。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/trap_handling.svg" class="">
<p>　　执行<code>syscall</code>指令会导致陷阱，陷阱处理函数会解析参数并调用对应的内核程序。</p>
<p>　　从程序员角度，系统调用和普通的函数调用是一样的，但它们的实现不同。普通的函数运行在用户模式，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。系统调用运行在内核模式，内核模式允许系统执行特权指令，而且能访问定义在内核中的栈。</p>
<h5 id="故障">8.1.2.3 故障</h5>
<p>　　故障由错误情况引起，它可能能被故障处理函数修复。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/fault_handling.svg" class="">
<p>　　当故障发生时，CPU会将控制权转移给故障处理函数。若故障处理函数能够修复，则它会将控制权转移给导致故障的指令，然后重新执行该指令；否则，从故障处理函数返回到<code>abort</code>例程，该例程会中止导致故障的应用程序。</p>
<p>　　缺页异常就是典型的故障，当指令引用某个虚拟地址，但该虚拟地址对应的物理地址不在内存中，所以必须从磁盘中取出，此时就会发生故障。缺页处理函数会从磁盘加载对应的页面，然后将控制权转移给引起故障的指令。当指令再次执行时，对应的物理页面已驻留在内存中，指令就可以没有故障地完成了。</p>
<h5 id="中止">8.1.2.4 中止</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/abort_handling.svg" class="">
<p>　　中止是不可修复的故障导致的结果，通常是硬件故障，例如，DRAM/SRAM位被损坏时发生的奇偶错误。中止处理函数不会将控制权转移给应用程序。</p>
<h4 id="linuxx86-84系统中的异常">8.1.3 Linux/x86-84系统中的异常</h4>
<p>　　x86-64中有256种异常类型。异常号0~31是Intel架构师定义的异常，所以对所有x86-64系统都相同。异常号32~255是OS定义的中断和陷阱。</p>
<table>
<thead>
<tr>
<th>异常号</th>
<th>描述</th>
<th>异常类别</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>除法错误</td>
<td>故障</td>
</tr>
<tr>
<td>13</td>
<td>一般保护故障</td>
<td>故障</td>
</tr>
<tr>
<td>14</td>
<td>缺页</td>
<td>故障</td>
</tr>
<tr>
<td>18</td>
<td>机器检查</td>
<td>中止</td>
</tr>
<tr>
<td>32~255</td>
<td>OS定义的异常</td>
<td>中断或陷阱</td>
</tr>
</tbody>
</table>
<p>　　当除以0或除法指令的结果比目标操作数大很多时，就会发生除法错误，UNIX会直接中止程序而非试图修复此类故障。shell通常把除法错误称为<strong>浮点异常</strong>。</p>
<p>　　很多原因都会导致一般保护故障，例如，引用未定义的虚拟内存区域和写只读的文件。Linux不会试图修复此类故障。shell通常把一般保护故障称为<strong>段故障</strong>。</p>
<p>　　执行会导致故障的指令时，若遇到硬件故障，则会发生机器检查。机器检查处理函数不会将控制权转移给应用程序。</p>
<p>　　Linux提供数百种系统调用。每种系统调用都有唯一的整数编号，每个编号都对应内核中跳转表的偏移。</p>
<table>
<thead>
<tr>
<th>(系统调用) 编号</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>read</code></td>
<td>读文件</td>
</tr>
<tr>
<td>1</td>
<td><code>write</code></td>
<td>写文件</td>
</tr>
<tr>
<td>2</td>
<td><code>open</code></td>
<td>打开文件</td>
</tr>
<tr>
<td>3</td>
<td><code>close</code></td>
<td>关闭文件</td>
</tr>
<tr>
<td>4</td>
<td><code>stat</code></td>
<td>获取文件信息</td>
</tr>
<tr>
<td>9</td>
<td><code>mmap</code></td>
<td>将内存页映射到文件</td>
</tr>
<tr>
<td>12</td>
<td><code>brk</code></td>
<td>重置栈顶</td>
</tr>
<tr>
<td>32</td>
<td><code>dup2</code></td>
<td>复制文件描述符</td>
</tr>
<tr>
<td>33</td>
<td><code>pause</code></td>
<td>挂起进程直到信号到达</td>
</tr>
<tr>
<td>37</td>
<td><code>alarm</code></td>
<td>调度报警信号的发送</td>
</tr>
<tr>
<td>39</td>
<td><code>getpid</code></td>
<td>获取进程ID</td>
</tr>
<tr>
<td>57</td>
<td><code>fork</code></td>
<td>创建进程</td>
</tr>
<tr>
<td>59</td>
<td><code>execve</code></td>
<td>执行程序</td>
</tr>
<tr>
<td>60</td>
<td><code>_exit</code></td>
<td>终止程序</td>
</tr>
<tr>
<td>61</td>
<td><code>wait4</code></td>
<td>等待进程终止</td>
</tr>
<tr>
<td>62</td>
<td><code>kill</code></td>
<td>发送信号到进程</td>
</tr>
</tbody>
</table>
<p>　　对于大多数系统调用，标准C库都提供了1组便利的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回传递给调用程序。系统调用及其对应的包装函数都称为<strong>系统级函数</strong>。</p>
<p>　　Linux的系统调用的参数都是通过寄存器传递，寄存器<code>%rax</code>存储系统调用号，最多可以有6个参数，按序分别存储在<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%r10</code>、<code>%r9</code>和<code>%r8</code>中。从系统调用返回时，寄存器<code>%rcx</code>和<code>%r11</code>都会被清空，<code>%rax</code>存储返回值。-4095到-1的负数返回值表示出现错误，对应负的的<code>errno</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;hello, world\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .data</span><br><span class="line">string:</span><br><span class="line">  .ascii &quot;hello, world\n&quot;</span><br><span class="line">string_end:</span><br><span class="line">  .equ len, string_end - string</span><br><span class="line">.section .text</span><br><span class="line">.globl main</span><br><span class="line">main:</span><br><span class="line">  # 调用write</span><br><span class="line">  movq  $1, %rax  # write的系统调用号是1</span><br><span class="line">  movq  $1, %rdi  # 参数1，stdout的描述符是1</span><br><span class="line">  movq  $string, %rsi # 参数2</span><br><span class="line">  movq  $len, %rdx  # 参数3</span><br><span class="line">  syscall # 执行系统调用</span><br><span class="line">  # 调用_exit</span><br><span class="line">  movq  $60, %rax # _exit的系统调用号是60</span><br><span class="line">  movq  $0, %rdi  # 参数1</span><br><span class="line">  syscall # 执行系统调用</span><br></pre></td></tr></table></figure>
<p>　　这是使用了系统级函数的<code>hello</code>程序及其对应的汇编代码。函数<code>write()</code>的第1个参数将传递到<code>stdout</code>，第2个参数是待写的字节序列，第3个参数是待写的字节数。</p>
<h3 id="进程">8.2 进程</h3>
<p>　　进程的经典定义是正在执行的程序的<strong>实例</strong>。</p>
<p>　　即使系统中通常有很多其他程序在运行，进程也可以提供<span
style="background-color: yellow">看似独占地使用CPU</span>的假象。若使用调试器单步执行程序，会看到一系列的PC值，这些值唯一地对应程序的可执行文件或共享库中的指令。这个PC值的序列称为<strong>逻辑控制流</strong>，简称<strong>逻辑流</strong>。</p>
<p>　　进程为每个程序提供的另一个假象是<span
style="background-color: yellow">看似独占地使用系统地址空间</span>。在<span
class="math inline">\(n\)</span>位地址的计算机上，地址空间是<span
class="math inline">\(2^n\)</span>个可能地址的集合，即<span
class="math inline">\(0\)</span>到<span
class="math inline">\(2^n-1\)</span>。进程为每个程序提供其<strong>私有地址空间</strong>。一般情况下，和私有地址空间中的某个地址相关联的内存字节不能被其他进程访问。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/logical_control_flow.svg" class="">
<p>　　这里以运行3个进程的系统为例，CPU的物理控制流分为了3个逻辑流。每个竖直的流表示逻辑流的一部分，这里3个逻辑流是交错的。每个进程执行它的流一部分，然后被<strong>抢占</strong>
(暂挂) 并轮到其他进程。</p>
<p>　　内核为每个进程维护对应的上下文，<strong>上下文</strong>就是内核重新启动暂挂进程所需的状态，由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、PC、用户栈、状态寄存器和各种内核数据结构，例如，描述地址空间的<span
style="background-color: yellow">页表</span>、包含当前进程相关信息的<span
style="background-color: yellow">进程表</span>和包含当前进程已打开文件的信息的<span
style="background-color: yellow">文件表</span>。</p>
<p>　　对于流X和Y，当前仅当X在Y开始之后和Y结束之前开始或Y在X开始之后和X结束之前开始，它们才能称为相互<strong>并发</strong>执行，这2个流称为<strong>并发流</strong>。例如，进程A和B是并发执行，A和C也是并发执行，但B和C不是并发执行。</p>
<p>　　<strong>并发</strong>指多个流并发执行。<strong>多任务</strong>指多个进程轮流运行。进程执行其控制流的一部分的时间段称为<strong>时间片</strong>，所以多任务也称为<strong>时间分片</strong>。例如，进程A由2个时间片组成。操作系统内核通过<strong>上下文切换</strong>来实现多任务。</p>
<p>　　若多个流运行在CPU<span
style="background-color: yellow">不同核</span>上，则它们称为<strong>并行流</strong>，它们<strong>并行运行</strong>且<strong>并行执行</strong>。</p>
<p>　　在进程执行时，内核可以抢占当前进程并重新开始某个暂挂的进程，该过程称为<strong>调度</strong>，由内核中的调度程序执行。当内核调度时，会使用上下文切换来将控制权转移给暂挂的进程，即先保存当前进程的上下文，恢复暂挂的进程之前保存的上下文并将控制权转移给该进程。</p>
<p>　　当内核代表用户执行系统调度时，可能会发生上下文切换。若系统调用因等待某个事件而阻塞，则内核可以让当前进程睡眠，切换到其他进程。例如，若<code>read()</code>系统调用需要访问磁盘，内核就可以选择执行上下文切换来运行其他进程而非等待数据到达。<code>sleep()</code>系统调用可以显式地请求调用进程睡眠。一般情况下，即使系统调用没有阻塞，内核也可以决定执行上下文切换而非将控制权转移给调用进程。</p>
<p>　　中断可能导致上下文切换。例如，所有系统都有产生周期性定时器中断的机制，间隔通常是1ms到10ms。每次发生定时器中断时，内核就能判断当前进程已经运行了足够长的时间，并切换到新进程。</p>
<h3 id="系统调用错误处理">8.3 系统调用错误处理</h3>
<p>　　当UNIX系统级函数出错时，通常返回-1并设置全局整数变量<code>errno</code>来表示错误类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>strerror()</code>会返回与<code>errno</code>对应的错误的文本串。通过定义以下的<strong>错误报告函数</strong>，能简化这段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    unix_error(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　通过错误处理包装函数，可以进一步简化代码。对于给定的基本函数<code>foo()</code>，定义具有相同参数的包装函数<code>Foo()</code>
(首字母大写)，包装函数会调用基本函数，检查错误，若出错，则终止。以下是函数<code>fork()</code>的错误处理包装函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程控制">8.4 进程控制</h3>
<p>　　从程序员角度，进程总是处于以下3种状态之一：</p>
<p>　　●
<strong>运行</strong>。进程要么在CPU上执行，要么在等待被执行并最终被内核调度。</p>
<p>　　● <strong>停止</strong>。进程的执行被<span
style="background-color: yellow">挂起</span>且不会被调度。当收到信号<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>或<code>SIGTTOU</code>时，进程会停止并一直持续到收到信号<code>SIGCONT</code>，此时，进程再次开始运行。</p>
<p>　　●
<strong>终止</strong>。进程永远停止。只有当收到默认处理方式是终止进程的信号、从主程序返回或调用函数<code>exit()</code>时，进程才会终止。</p>
<p>　　UNIX提供了C控制进程的系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>exit()</code>会以退出状态<code>status</code>来终止进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程PID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的父进程PID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 子进程返回0，父进程返回子进程PID，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　每个进程都有唯一的正整数进程ID
(PID)。在Linux中，<code>types.h</code>把<code>pid_t</code>定义为<code>int</code>。</p>
<p>　　<strong>父进程</strong>通过调用函数<code>fork()</code>来创建新的正在运行的<strong>子进程</strong>。子进程得到与父进程用户级虚拟地址空间相同但<span
style="background-color: yellow">独立</span>的副本，包括代码段、数据段、堆、共享库和用户栈。子进程还获得与父进程所有文件描述符相同的副本，这表示子进程可以读写父进程调用函数<code>fork()</code>时打开的所有文件。父进程和子进程之间最大的区别是PID。</p>
<p>　　函数<code>fork()</code>只会被调用1次，但父进程和子进程都会返回，
父进程中返回子进程PID，子进程中返回0。因为子进程PID总是非0，返回值可以分辨程序是在父进程还是在子进程中执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: x=%d\n&quot;</span>, ++x);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: x=%d\n&quot;</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/process_graph_for_the_example_program.svg" class="">
<p>　　这个示例会使用函数<code>fork()</code>创建子进程。当函数<code>fork()</code>返回时
(第6行)，父进程和子进程中的<code>x</code>的值都为1，然后父子进程在自己的私有地址空间并发执行。子进程在第8行加1并输出其<code>x</code>的副本
(值为0)，父进程在第13行减1并输出其<code>x</code>的副本 (值为2)。</p>
<p>　　对于运行在单核CPU上的程序，进程图中所有顶点的<strong>拓扑排序</strong>都表示程序中对应的语句的可行总排序。当且仅当画出的每条边的方向都是从左到右时，该排列是拓扑排序。这里，父子进程的<code>printf()</code>语句可以以任意顺序执行，因为每种顺序都对应图顶点的某种拓扑排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    Fork();</span><br><span class="line">    Fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/process_graph_for_a_nested_fork.svg" class="">
<p>　　这个示例的源码中调用了2次函数<code>fork()</code>，而进程图中实际运行了4个进程，每个都调用了1次函数<code>printf()</code>，这样函数<code>printf()</code>可以以任意顺序执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>; <span class="comment">/* 返回剩余待睡眠秒数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 总是返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sleep()</code>会将进程挂起指定时间，若已达到指定挂起时间，则返回0；若提前返回
(被信号中断)，则返回剩余待挂起时间
(单位为秒)。函数<code>pause()</code>也会让函数睡眠直到进程收到信号。</p>
<h4 id="回收子进程">8.4.1 回收子进程</h4>
<p>　　当进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程一直保持终止状态直到被其父进程<strong>回收</strong>。当父进程回收终止的子进程时，内核会将子进程的退出状态传递给父进程，然后清除终止的子进程，此时，该子进程将不复存在。终止但未被回收的进程称为<strong>僵尸</strong>进程。</p>
<p>　　若父进程终止，则其子进程会成为<strong>孤儿</strong>进程，内核会让进程<code>init</code>领养孤儿进程。进程<code>init</code>的PID为1，是系统启动时由内核创建，它不会终止，是所有进程的祖先。若孤儿进程是僵尸进程，则进程<code>init</code>会进行回收。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>; <span class="comment">/* 成功时返回子进程PID，将options指定WNOHANG时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>; <span class="comment">/* 成功时返回子进程PID，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　进程可以通过调用函数<code>waitpid()</code>来等待其子进程终止。默认情况下
(参数<code>options</code>为0时)，函数<code>waitpid()</code>会挂起调用进程，直到其<strong>等待集合</strong>中的某个子进程终止。若等待集合中的某个进程在调用时就已终止，则函数<code>waitpid()</code>会立即返回。在这2种情况下，函数<code>waitpid()</code>会返回导致自身返回的已终止子进程PID。此时，已终止的子进程已被回收，内核会从系统中删除其所有痕迹。</p>
<p>　　等待集合的成员由参数<code>pid</code>确定：</p>
<p>　　●
若<code>pid</code>大于0，则等待集合就是1个单独的子进程，其PID等于<code>pid</code>。</p>
<p>　　● 若<code>pid</code>为-1，则等待集合就是父进程所有的子进程。</p>
<p>　　函数<code>waitpid()</code>还支持其他类型的等待集合，包括UNIX进程组。</p>
<p>　　若调用进程没有子进程，则函数<code>waitpid()</code>会返回-1并将<code>errno</code>设置为<code>ECHILD</code>。若函数<code>waitpid()</code>被信号中断，则返回-1并将<code>errno</code>设置为<code>EINTR</code>。头文件<code>errno.h</code>中定义了<code>errno</code>相关的宏。</p>
<p>　　调用<code>wait(&amp;status)</code>等同于调用<code>waitpid(-1, &amp;status, 0)</code>。</p>
<h5 id="修改默认行为">8.4.1.1 修改默认行为</h5>
<p>　　可以将参数<code>options</code>设置为常量<code>WNOHANG</code>、<code>WUNTRACED</code>和<code>WCONTINUED</code>的各种组合修改来默认行为。</p>
<p>　　●
<code>WNOHANG</code>：若等待集合中的所有子进程都还没终止，则立即返回0。默认的行为是挂起调用进程，直到子进程终止。在等待子进程终止时还想进行其他工作，可以使用该选项。</p>
<p>　　●
<code>WUNTRACED</code>：挂起调用进程直到等待集合中的1个进程变为终止或停止。返回PID为导致返回的已终止或已停止的子进程PID。默认行为是只返回已终止的子进程。当需要检查已终止或已停止的子进程时，该选项会有用。</p>
<p>　　●
<code>WCONTINUED</code>：挂起调用进程直到等待集合中的1个正在运行的进程终止或等待集合中1个停止的进程收到信号<code>SIGCONT</code>重新开始执行。</p>
<p>　　这3个常量可以用或运算来组合。例如，<code>WNOHANG | WUNTRACED</code>：立即返回，若等待集合中的子进程都没有终止或停止，则返回0；若有1个进程终止或停止，则返回该子进程PID。</p>
<h5 id="检查已回收子进程的退出状态">8.4.1.2
检查已回收子进程的退出状态</h5>
<p>　　若参数<code>statusp</code>是非空，则函数<code>waitpid()</code>会设置<code>status</code>来表示导致返回的子进程的状态信息，这里<code>status</code>是<code>statusp</code>指向的值。头文件<code>wait.h</code>定义了<code>status</code>参数的几个宏：</p>
<p>　　●
<code>WIFEXITED</code>：若子进程调用<code>exit()</code>或<code>return</code>正常终止，则返回真。</p>
<p>　　●
<code>WEXITSTATUS</code>：返回1个正常终止的子进程的退出状态。只有在<code>WIFEXITED()</code>返回真时，才会定义此状态。</p>
<p>　　●
<code>WIFSIGNALED</code>：若子进程因1个未捕获的信号终止，则返回真。</p>
<p>　　●
<code>WTERMSIG</code>：返回导致子进程终止的信号的编号。只有在<code>WIFSIGNALED()</code>返回真时，才会定义此状态。</p>
<p>　　●
<code>WIFSTOPPED</code>：若导致返回的子进程已停止，则返回真。</p>
<p>　　●
<code>WIFCONTINUED</code>：若子进程收到信号<code>SIGCONT</code>重新运行，则返回真。</p>
<h5 id="相关示例">8.4.1.3 相关示例</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* waitpid1.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status, i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程创建N个子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">100</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程回收这N个子进程 (无特定顺序) */</span></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated normally with exit status=%d\n&quot;</span>, pid, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated abnormally\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有当没有子进程时才正常终止 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，使用了函数<code>waitpid()</code>来 (不按照特定顺序)
等待所有<code>N</code>个子进程终止。在第11行中，父进程创建了<code>N</code>个子进程，在第13行中，每个子进程以唯一的退出状态退出。</p>
<p>　　在第18行中，父进程用函数<code>waitpid()</code>作为<code>while</code>循环条件，等待其所有子进程终止。函数<code>waitpid()</code>的第1个参数是-1，所以对函数<code>waitpid()</code>的调用会阻塞，直到任意1个子进程终止。每当子进程终止时，对函数<code>waitpid()</code>的调用会返回该子进程PID。第20行会检查子进程退出状态，若是正常终止
(调用函数<code>exit()</code>退出)，则父进程提取退出状态并输出到<code>stdout</code>。</p>
<p>　　当回收所有子进程后，再调用函数<code>waitpid()</code>会返回-1并将<code>errno</code>设置为<code>ECHILD</code>。第31行会检查函数<code>waitpid()</code>是否正常终止，若不是，则返回错误信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* waitpid2.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status, i;</span><br><span class="line">    <span class="type">pid_t</span> pid[N], retpid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程创建N个子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid[i] = Fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">100</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程按序回收这N个子进程 */</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((retpid = waitpid(pid[i++], &amp;status, <span class="number">0</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated normally with exit status=%d\n&quot;</span>, retpid, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated abnormally\n&quot;</span>, retpid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有当没有子进程时才正常终止 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是改进后的版本，按照父进程创建子进程的顺序来回收这些子进程。父进程按照顺序存储了其子进程PID，然后通过适当的PID作为第1个参数来调用函数<code>waitpid()</code>，按照同样的顺序来等待每个子进程。</p>
<h4 id="加载并执行程序">8.4.2 加载并执行程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span>; <span class="comment">/* 成功时不返回，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p><img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/organization_of_function_execve's_arguments.svg" class=""></p>
<p>　　函数<code>execve()</code>会加载并执行可执行文件<code>filename</code>，并且会带参数列表<code>argv</code>和环境变量列表<code>envp</code>。只有出错时
(找不到<code>filename</code>等)，函数<code>execve()</code>才会返回到调用程序。</p>
<p>　　参数<code>argv</code>指向以<code>NULL</code>结尾的指针数组，其中每个指针都指向1个参数字符串。按照惯例，<code>argv[0]</code>是可执行文件的名称。参数<code>envp</code>指向以<code>NULL</code>结尾的指针数组，其中每个指针指向1个环境变量字符串，每个字符串都是形如<code>name=value</code>的键值对。</p>
<p>　　函数<code>execve()</code>加载<code>filename</code>后，会调用7.7中介绍的系统启动函数。系统启动函数会设置栈并将控制权转移给程序的主函数，主函数有2种等价的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span>;</span><br></pre></td></tr></table></figure>
<p>　　主函数有3个参数，参数<code>argc</code>表示<code>argv[]</code>中非空指针的数量，参数<code>argv</code>指向数组<code>argv[]</code>的第1个元素，参数<code>envp</code>指向数组<code>envp[]</code>的第1个元素。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/typical_organization_of_the_user_stack_when_a_new_program_starts.svg" class="">
<p>　　主函数开始执行时，栈底是以<code>NULL</code>结尾的环境变量字符串和命令行参数字符串。其后是以<code>NULL</code>结尾的指针数组，其中每个指针都指向1个环境变量字符串，全局变量<code>environ</code>指向该数组的第1个元素<code>envp[0]</code>。其后是另一个以<code>NULL</code>结尾的指针数组，其中每个指针都指向1个参数字符串。栈顶是系统启动函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 环境变量存在时返回name对应的value字符串，环境变量不存在时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *newvalue, <span class="type">int</span> overwrite)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>getenv()</code>会在环境变量数组中搜索字符串<code>name=value</code>。若找到，则返回指向<code>value</code>的指针；否则，返回<code>NULL</code>。当环境变量数组中有形如<code>name=oldvalue</code>的字符串时，函数<code>unsetenv()</code>会删除它，此时，若<code>overwrite</code>非0，则函数<code>setenv()</code>会用<code>newvalue</code>替换<code>oldvalue</code>。若<code>name</code>不存在，则函数<code>setenv()</code>会把<code>name=newvalue</code>添加到环境变量数组。</p>
<h4 id="用fork和execve运行程序">8.4.3
用<code>fork()</code>和<code>execve()</code>运行程序</h4>
<p>　　UNIX
shell和Web服务器等程序大量地使用了函数<code>fork()</code>和<code>execve()</code>。shell是交互型程序，它代表用户运行其他程序。最早的shell是<code>sh</code>，后来出现了一些变体，例如，<code>csh</code>、<code>tcsh</code>、<code>ksh</code>和<code>bash</code>。shell会执行一系列读/求值步骤，然后终止。读步骤会读来自用户的1个命令行。求值步骤会解析命令行并代表用户运行程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* shellex.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 128</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_commond</span><span class="params">(<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 退出命令行 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略分隔符&amp; */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS]; <span class="comment">/* 函数execve参数列表 */</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];   <span class="comment">/* 保存修改后的命令行 */</span></span><br><span class="line">    <span class="type">int</span> bg;              <span class="comment">/* 是否后台运行 */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;           <span class="comment">/* 进程ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, cmdline);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略空行 */</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!builtin_commond(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 子进程运行用户作业 */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 父进程等待前台作业终止 */</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *delim; <span class="comment">/* 指向第1个空格分隔符 */</span></span><br><span class="line">    <span class="type">int</span> argc;    <span class="comment">/* 参数数量 */</span></span><br><span class="line">    <span class="type">int</span> bg;      <span class="comment">/* 是否后台执行 */</span></span><br><span class="line"></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>; <span class="comment">/* 用空格替换结尾的\n */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略开头的空格 */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        buf++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建参数列表 */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 忽略空格 */</span></span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            buf++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略空行 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否后台执行 */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了简单shell的主函数。shell会打印1个命令行提示符，等待用户在<code>stdin</code>上输入命令行，然后对该命令行求值。这里并没有回收后台子进程。</p>
<p>　　函数<code>eval()</code>会对命令行求值，其首要任务是调用函数<code>parseline()</code>，这个函数会解析以空格为分隔符的命令行参数并构造最终会传递给函数<code>execve()</code>的参数<code>argv</code>。若函数<code>parseline()</code>的最后1个参数是<code>&amp;</code>，则会返回1
(在后台执行)；否则，返回0 (在前台执行)。</p>
<p>　　在解析完命令行后，函数<code>eval()</code>会调用函数<code>builtin_command()</code>，该函数会检查第1个命令行参数是否是内置shell命令，若是，则解释该命令并返回1；否则，返回0。</p>
<p>　　若函数<code>builtin_command()</code>返回0，则shell会创建子进程并在子进程中执行所请求的程序。若用户要求在后台运行该程序，则shell会返回到循环的顶部，等待下一个命令行；否则，shell会用函数<code>waitpid()</code>等待作业终止。当作业终止时，shell会开始下一轮迭代。</p>
<h3 id="信号">8.5 信号</h3>
<p>　　Linux<strong>信号</strong>是更高层的软件形式的异常，允许进程和内核中断其他进程。每种信号类型都对应某种系统事件。底层的硬件异常是由内核异常处理函数处理，正常情况下，对用户进程不可见，信号能通知用户进程发生了这些异常。</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 16%" />
<col style="width: 34%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr>
<th>编号</th>
<th>名称</th>
<th>默认处理方式</th>
<th>对应的事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>SIGHUP</code></td>
<td>终止</td>
<td>终端线挂断</td>
</tr>
<tr>
<td>2</td>
<td><code>SIGINT</code></td>
<td>终止</td>
<td>来自键盘的中断</td>
</tr>
<tr>
<td>3</td>
<td><code>SIGQUIT</code></td>
<td>终止</td>
<td>来自键盘的退出</td>
</tr>
<tr>
<td>4</td>
<td><code>SIGILL</code></td>
<td>终止</td>
<td>非法指令</td>
</tr>
<tr>
<td>5</td>
<td><code>SIGTRAP</code></td>
<td>终止并转储核心</td>
<td>追踪陷阱</td>
</tr>
<tr>
<td>6</td>
<td><code>SIGABRT</code></td>
<td>终止并转储核心</td>
<td>来自函数<code>abort()</code>的中止信号</td>
</tr>
<tr>
<td>7</td>
<td><code>SIGBUS</code></td>
<td>终止</td>
<td>总线错误</td>
</tr>
<tr>
<td>8</td>
<td><code>SIGFPE</code></td>
<td>终止并转储核心</td>
<td>浮点异常</td>
</tr>
<tr>
<td>9</td>
<td><code>SIGKILL</code></td>
<td>终止</td>
<td>杀死进程</td>
</tr>
<tr>
<td>10</td>
<td><code>SIGUSR1</code></td>
<td>终止</td>
<td>用户定义的信号1</td>
</tr>
<tr>
<td>11</td>
<td><code>SIGSEGV</code></td>
<td>终止并转储核心</td>
<td>无效的内存引用 (段故障)</td>
</tr>
<tr>
<td>12</td>
<td><code>SIGUSR2</code></td>
<td>终止</td>
<td>用户定义的信号2</td>
</tr>
<tr>
<td>13</td>
<td><code>SIGPIPE</code></td>
<td>终止</td>
<td>写没有读用户的管道</td>
</tr>
<tr>
<td>14</td>
<td><code>SIGALRM</code></td>
<td>终止</td>
<td>来自函数<code>alarm()</code>的定时器信号</td>
</tr>
<tr>
<td>15</td>
<td><code>SIGTREM</code></td>
<td>终止</td>
<td>软件终止信号</td>
</tr>
<tr>
<td>16</td>
<td><code>SIGSTKFLT</code></td>
<td>终止</td>
<td>协处理器的栈错误</td>
</tr>
<tr>
<td>17</td>
<td><code>SIGCHLD</code></td>
<td>忽略</td>
<td>1个子进程已停止或终止</td>
</tr>
<tr>
<td>18</td>
<td><code>SIGCONT</code></td>
<td>忽略</td>
<td>继续运行停止的进程</td>
</tr>
<tr>
<td>19</td>
<td><code>SIGSTOP</code></td>
<td>停止直到下一个<code>SIGCONT</code></td>
<td>不是来自终端的停止信号</td>
</tr>
<tr>
<td>20</td>
<td><code>SIGTSTP</code></td>
<td>停止直到下一个<code>SIGCONT</code></td>
<td>来自终端的停止信号</td>
</tr>
<tr>
<td>21</td>
<td><code>SIGTTIN</code></td>
<td>停止直到下一个<code>SIGCONT</code></td>
<td>后台进程从终端读</td>
</tr>
<tr>
<td>22</td>
<td><code>SIGTTOU</code></td>
<td>停止直到下一个<code>SIGCONT</code></td>
<td>后台进程从终端写</td>
</tr>
<tr>
<td>23</td>
<td><code>SIGURG</code></td>
<td>忽略</td>
<td>套接字的紧急情况</td>
</tr>
<tr>
<td>24</td>
<td><code>SIGXCPU</code></td>
<td>终止</td>
<td>超出CPU时间限制</td>
</tr>
<tr>
<td>25</td>
<td><code>SIGXFSZ</code></td>
<td>终止</td>
<td>超出文件大小限制</td>
</tr>
<tr>
<td>26</td>
<td><code>SIGVTALRM</code></td>
<td>终止</td>
<td>虚拟定时器过期</td>
</tr>
<tr>
<td>27</td>
<td><code>SIGPROF</code></td>
<td>终止</td>
<td>剖析定时器过期</td>
</tr>
<tr>
<td>28</td>
<td><code>SIGWINCH</code></td>
<td>忽略</td>
<td>窗口大小变化</td>
</tr>
<tr>
<td>29</td>
<td><code>SIGIO</code></td>
<td>终止</td>
<td>在1个描述符上执行I/O操作</td>
</tr>
<tr>
<td>30</td>
<td><code>SIGPWR</code></td>
<td>终止</td>
<td>电源故障</td>
</tr>
</tbody>
</table>
<p>　　当进程除以0时，内核会发送信号<code>SIGFPE</code>给它。当进程执行非法指令时，内核会发送信号<code>SIGILL</code>给它。其他信号对应内核或用户进程中较高层的软件事件。例如，当键盘输入Ctrl+C时，内核会发送信号<code>SIGINT</code>给前台进程组的每个进程。同样，当键盘输入Ctrl+Z时，会发送信号<code>SIGTSTP</code>给前台进程组的每个进程。进程可以向其他进程发送信号<code>SIGKILL</code>信号来强制终止它。当子进程停止或终止时，内核会发送信号<code>SIGCHLD</code>给父进程。</p>
<p>　　转储核心 (dumping core)
是历史术语，表示将代码和数据内存段的映射写到磁盘上
(以前的内存用磁芯存储器来实现)。</p>
<p>　　信号的传输由<strong>发送信号</strong>和<strong>接收信号</strong>组成。</p>
<p>　　●
内核通过更新目的进程上下文中的某个状态来发送信号给目的进程。发送信号可以有2种原因：内核检测到系统事件或进程调用函数<code>kill()</code>。进程可以发送信号给自己。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/signal_handling.svg" class="">
<p>　　●
当目的进程被内核强迫以某种方式来响应信号时，它就接收了信号。进程可以忽略该信号，也可以终止或通过执行称为<strong>信号处理函数</strong>的用户级函数来捕获该信号。信号<code>SIGKILL</code>和<code>SIGSTOP</code>既不能捕获，也不能忽略。</p>
<p>　　发出后未被接收的信号称为<strong>待处理信号</strong>。<span
style="background-color: yellow">同一类型的待处理信号最多只能有1个</span>。若进程有1个类型为<code>k</code>的待处理信号，则之后发送到该进程的类型为<code>k</code>的信号会直接被丢弃。进程可以有选择性地<strong>阻塞</strong>特定信号的接收。当信号被阻塞时，仍可以发送，但不会被接收，直到取消对应的阻塞。</p>
<p>　　内核为每个进程在<code>pengding</code>位向量中维护着待处理信号集，在<code>blocked</code>位向量
(也称为<strong>信号掩码</strong>)
中维护着阻塞的信号集合。当发送类型为<code>k</code>的信号时，内核会设置<code>pending</code>位向量中的第<code>k</code>位。当接收类型为<code>k</code>的信号时，内核会清除<code>pengding</code>位向量中的第<code>k</code>位。</p>
<h4 id="发送信号">8.5.1 发送信号</h4>
<p>　　UNIX提供了大量向进程发送信号的机制，这些机制都是基于<strong>进程组</strong>。</p>
<p>　　每个进程都只属于1个进程组，进程组由1个正整数ID来标识。子进程的默认进程组是父进程的进程组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的进程组ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>; <span class="comment">/* 返回上一个alarm剩余的秒数，上一个alarm不存在时返回0 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>getpgrp()</code>会返回当前进程的进程组ID。</p>
<p>　　函数<code>setpgid()</code>会将PID为<code>pid</code>的进程的进程组ID设置为<code>pgid</code>。若<code>pid</code>为0，则使用当前进程PID；若<code>pgid</code>为0，则将PID为<code>pid</code>的进程的进程组ID设置为<code>pid</code>；若<code>pid</code>和<code>pgid</code>都为0，则将调用进程的进程组ID设置为其PID。</p>
<p>　　函数<code>alarm()</code>会让内核在<code>secs</code>秒后发送信号<code>SIGALRM</code>给调用进程。每次调用函数<code>alarm()</code>时，若上一次调用该函数设置的延时还未结束，则会取消上一次调用该函数设置的延时并返回剩余时间；若上一次调用该函数设置的延时已结束，则返回0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>kill()</code>会发送编号为<code>sig</code>的信号给指定进程
(包括自己)。若<code>pid</code>大于0，则会发送编号为<code>sig</code>的信号给PID为<code>pid</code>的进程；若<code>pid</code>为0，则会发送编号为<code>sig</code>的信号给调用进程所属进程组中的每个进程；若<code>pid</code>小于0，则会发送编号为<code>sig</code>的信号给进程组ID为<code>pid</code><span
style="background-color: yellow">绝对值</span>的进程组中的所有进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* kill.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子进程睡眠，直到收到SIGKILL，然后终止 */</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Pause();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;control should never reach here!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程发送SIGKILL给子进程 */</span></span><br><span class="line">    Kill(pid, SIGKILL);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，父进程会用函数<code>kill()</code>发送信号<code>SIGKILL</code>给其子进程。</p>
<p>　　<code>/bin/kill</code>程序可以向其他进程发送任意信号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/bin/kill -9 15213</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/bin/kill -9 -15213</span></span><br></pre></td></tr></table></figure>
<p>　　第1条命令会发送信号9 (<code>SIGKILL</code>)
给进程15213。第2条命令会发送信号9 (<code>SIGKILL</code>)
给进程组15213中的每个进程。</p>
<p>　　shell使用<strong>作业</strong>来表示对命令行求值而创建的进程。前台作业只能有1个，后台作业可以有任意个。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> | <span class="built_in">sort</span></span></span><br></pre></td></tr></table></figure>
<p>　　这条命令会创建包括2个进程
(分别运行<code>ls</code>和<code>sort</code>程序)
的前台作业，这2个进程通过UNIX管道连接。shell会为每个作业创建独立的进程组。进程组ID通常来自作业中的某个父进程。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/foreground_and_background_process_groups.svg" class="">
<p>　　在这个示例中，shell有1个前台作业和2个后台作业。前台作业的父进程PID为20，进程组ID为20。父进程创建了2个子进程，子进程的进程组ID都是20。</p>
<h4 id="接收信号">8.5.2 接收信号</h4>
<p>　　当内核把进程<code>p</code>从内核模式切换到用户模式时，会检查进程<code>p</code>的未阻塞的待处理信号的集合。若集合为空
(通常情况下)，则内核将控制权转移给<code>p</code>的控制流中的下一条指令；若集合不为空，则选择集合中的某个信号
(通常是编号值最小)
并且强制<code>p</code>接收该信号。收到信号后进程会进行某些操作。一旦进程完成操作，那么控制权将转移给<code>p</code>的控制流的下一条指令。每个信号类型都有预定义的默认处理方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>; <span class="comment">/* 成功时返回指向前一个处理函数的指针，出错时返回SIG_ERR (不设置errno) */</span></span><br></pre></td></tr></table></figure>
<p>　　进程可以使用函数<code>signal()</code>修改信号的处理方式。信号<code>SIGSTOP</code>和<code>SIGKILL</code>的处理方式无法修改。</p>
<p>　　函数<code>signal()</code>通过以下3种方式之一来改变信号的处理方式：</p>
<p>　　●
若<code>handler</code>是<code>SIG_IGN</code>，则忽略编号为<code>signum</code>的信号。</p>
<p>　　●
若<code>handler</code>是<code>SIG_DFL</code>，则恢复编号为<code>signum</code>的信号的默认处理方式。</p>
<p>　　● 若<code>handler</code>是用户定义的函数
(称为<strong>信号处理函数</strong>)
的地址，只要进程接收到编号为<code>signum</code>的信号，就会调用该程序。通过把处理函数的地址传递给函数<code>signal()</code>从而改变其处理方式，称为<strong>注册信号处理函数</strong>。调用信号处理函数称为<strong>捕获信号</strong>。执行信号处理函数称为<strong>处理信号</strong>。</p>
<p>　　当进程捕获编号为<code>k</code>的信号时，会调用对应的信号处理函数并将1个整数参数设置为<code>k</code>，该参数允许同一处理函数捕获不同类型的信号。</p>
<p>　　当程序执行<code>return</code>语句时，控制权通常会转移给控制流中进程被信号中断处的指令，在某些系统中，被中断的系统调用会立即返回错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sigint.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief SIGINT处理函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cought SIGINT\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 注册信号处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sigint_handler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待接收信号 */</span></span><br><span class="line">    pause();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会将信号<code>SIGINT</code>的处理方式修改为输出1条消息再终止该进程。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_08/signal_handler_can_be_interrupted_by_other_signal_handlers.svg" class="">
<p>　　信号处理函数可以被其他信号处理函数中断。在这个示例中，处理函数<code>S</code>和<code>T</code>都是信号处理函数。首先，主程序捕获到信号，信号会中断主程序，将控制权转移给处理函数<code>S</code>。处理函数<code>S</code>运行时，主程序捕获了另一个不同的信号，该信号会中断处理函数<code>S</code>，将控制权转移到处理函数<code>T</code>。从处理函数<code>T</code>返回时，处理函数<code>S</code>从它被中断的地方继续执行。最后，从处理函数<code>S</code>返回，将控制权转移给主程序，主程序从它被中断的地方继续执行。</p>
<h4 id="阻塞和解除阻塞信号">8.5.3 阻塞和解除阻塞信号</h4>
<p>　　Linux提供了隐式和显式的信号阻塞机制。</p>
<p>　　●
隐式阻塞机制就是内核默认阻塞与当前信号处理函数正在处理的信号的类型相同的所有待处理的信号。例如，程序捕获了信号<code>s</code>，当前正在运行信号处理函数<code>S</code>，若该进程收到了另一个信号<code>s</code>，则刚接收的<code>s</code>会变成待处理，并且在从<code>S</code>返回后才会被接收。</p>
<p>　　●
应用程序可以使用函数<code>sigprocmask()</code>及其辅助函数显式地阻塞和解除阻塞指定的信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>; <span class="comment">/* signum在set中时返回1，signum不在set中时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sigprocmask()</code>会改变当前阻塞的信号集合。具体的行为取决于<code>how</code>的值：</p>
<p>　　●
<code>SIG_BLOCK</code>表示将<code>set</code>中的信号添加到<code>blocked</code>位向量。</p>
<p>　　●
<code>SIG_UNBLOCK</code>表示从<code>blocked</code>位向量中删除<code>set</code>中的信号。</p>
<p>　　●
<code>SIG_SETMASK</code>表示将<code>set</code>赋值给<code>blocked</code>位向量。</p>
<p>　　若<code>oldset</code>非空，则其中保存着<code>blocked</code>位向量的旧值。</p>
<p>　　函数<code>sigemptyset()</code>会将<code>set</code>清空。函数<code>sigfillset()</code>会把每个信号都添加到<code>set</code>。函数<code>sigaddset()</code>会把编号为<code>signum</code>的信号添加到<code>set</code>。函数<code>sigdelset()</code>会从<code>set</code>中删除编号为<code>signum</code>的信号。函数<code>sigismember()</code>会判断编号为<code>signum</code>的信号是否在<code>set</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sigset_t</span> mask, prev_mask;</span><br><span class="line"></span><br><span class="line">Sigemptyset(&amp;mask);</span><br><span class="line">Sigaddset(&amp;mask, SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阻塞信号SIGINT并保存blocked位向量的旧值 */</span></span><br><span class="line">Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不会被信号SIGINT中断的代码段 */</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复blocked位向量的旧值，解除阻塞信号SIGINT */</span></span><br><span class="line">Sigprocmask(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过函数<code>sigprocmask()</code>来临时阻塞信号<code>SIGINT</code>。</p>
<h4 id="编写信号处理函数">8.5.4 编写信号处理函数</h4>
<p>　　信号处理函数的几个属性使得它们难以分析。首先，信号处理函数与主程序并发运行，共享全局变量，所以可能与主程序或其他处理函数相互干扰。其次，如何以及何时接收信号的规则是反常的。最后，不同系统有不同的信号处理语义。因此，编写信号处理函数时要保证函数尽可能简单，并且只调用<strong>异步信号安全</strong>的函数
(可重入或不能被信号处理函数中断)。</p>
<h5 id="安全的信号处理">8.5.4.1 安全的信号处理</h5>
<p>　　信号处理函数中调用函数<code>printf()</code>和<code>sprintf()</code>是非异步信号安全的，只能使用函数<code>write()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* csapp.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在标准输出中输出字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s</span></span><br><span class="line"><span class="comment"> * @return ssize_t 成功时返回字节数，出错时返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_puts</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> write(STDOUT_FILEND, s, sio_strlen(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在标准输出中输出长整型数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param v</span></span><br><span class="line"><span class="comment"> * @return ssize_t 成功时返回字节数，出错时返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sio_putl</span><span class="params">(<span class="type">long</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    sio_ltoa(v, s, <span class="number">10</span>); <span class="comment">/* 基于K&amp;R的函数itoa */</span></span><br><span class="line">    <span class="keyword">return</span> sio_puts(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在标准输出中输出错误信息并退出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sio_error</span><span class="params">(<span class="type">char</span> s[])</span></span><br><span class="line">&#123;</span><br><span class="line">    sio_puts(s);</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这里为了方便，用前缀<code>sio</code>表示函数是异步信号安全的I/O函数。例如，函数<code>sio_fun()</code>是I/O函数<code>fun()</code>的异步信号安全版本。第23行的函数<code>sio_ltoa()</code>基于能将整型数转换为字符串的函数<code>itoa()</code>。第35行的函数<code>_exit()</code>是函数<code>exit()</code>的异步信号安全版本。</p>
<p>　　许多Linux异步信号安全的函数都会在出错时设置<code>errno</code>。信号处理函数调用这样的函数可能干扰主程序中其他依赖<code>errno</code>的部分。解决方法是进入信号处理函数后先把<code>errno</code><span
style="background-color: yellow">保存</span>在某个局部变量中，在信号处理函数返回前恢复。若信号处理函数会调用函数<code>_exit()</code>终止该进程，则不必如此。</p>
<p>　　若信号处理函数和主程序或其他处理函数共享同一全局数据结构，则在访问该数据结构时，信号处理函数和主程序应该<span
style="background-color: yellow">暂时阻塞所有信号</span>。这是因为在主程序访问数据结构<code>d</code>通常需要一系列指令，若指令序列被需要访问<code>d</code>的信号处理函数中断，则信号处理函数可能会发现<code>d</code>的状态不一致，得到不可预知的结果。</p>
<p>　　假设信号处理函数和主函数共享全局变量<code>g</code>，信号处理函数更新<code>g</code>，主函数周期性地读<code>g</code>。对于编译器优化，主函数中<code>g</code>的值看似没变，所以使用缓存在寄存器中<code>g</code>的副来满足<code>g</code>的引用是安全的。若真如此，主函数将永远无法看到信号处理函数更新后的值。解决方法是用关键字<code>volatile</code>来修饰变量
(<code>volatile int g</code>)，该关键字指示编译器<span
style="background-color: yellow">不要缓存</span>该变量。同样，和访问全局数据结构相同，访问全局变量时也应该暂时阻塞所有信号。</p>
<p>　　在常见的信号处理函数设计中，信号处理函数会写全局标志来记录收到了信号。主程序周期性地读该标志，响应信号并清除该标志。整形数据类型<code>sig_atomic_t</code>保证<span
style="background-color: yellow">单个的读和写是原子 (不可中断)
的</span>。因此，这个全局标志可以声明为<code>volatile sig_atomic_t flag</code>。</p>
<h5 id="正确的信号处理">8.4.5.2 正确的信号处理</h5>
<p>　　每种类型的待处理信号最多只能有1个。因此，程序正在执行类型为<code>k</code>的信号的处理函数
(阻塞类型为<code>k</code>的信号)
时，若正好有2个类型为<code>k</code>的信号发送给该程序，第2个到达的信号会被直接丢弃。由此可得，不能用信号来对其他进程中发生的事件进行计数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sio_puts(<span class="string">&quot;Handler reaped child\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        Sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGCHLD, handler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello from child%d\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待终端输入并执行 */</span></span><br><span class="line">    <span class="keyword">if</span> ((n = read(STDIN_FILEND, buf, <span class="keyword">sizeof</span>(buf))) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent processing input\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    eixt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例在本质上类似shell和Web服务器等程序，基本结构是父进程创建一些子进程，这些子进程各自独立运行一段时间并终止。然后，父进程回收子进程以避免留下僵尸进程。为了不让父进程显式地等待子进程终止，这里使用了<code>SIGCHLD</code>信号处理函数来回收子进程。</p>
<h5 id="可移植的信号处理">8.4.5.3 可移植的信号处理</h5>
<p>　　不同UNIX系统有不同的信号处理语义。</p>
<p>　　●
函数<code>signal()</code>的语义不同。有些较早版本的UNIX系统在信号<code>k</code>被处理函数捕获后，会把信号<code>k</code>的处理方式设置为<code>SIG_DFL</code>。在这些系统上，每次处理函数运行后，必须调用函数<code>signal()</code>来显式地重新注册。</p>
<p>　　●
系统调用可以被中断。<code>read()</code>、<code>write()</code>和<code>accept</code>等系统调用会隐式地阻塞进程一段较长的时间，称为<strong>慢速系统调用</strong>。在有些较早版本的UNIX系统中，当信号处理函数捕获到信号后，被中断的慢速系统调用在信号处理函数返回时不会再继续，而是立即返回错误条件并将<code>errno</code>设置为EINTR。在这些系统上，必须要包括手动重启被中断的系统调用的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　POSIX定义了函数<code>sigaction()</code>来解决以上问题，该函数允许用户在设置信号的处理方式时，明确指定信号处理语义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* csapp.c */</span></span><br><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* 阻塞信号处理函数正在处理的信号的类型 */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* 只要可能，重启中断的系统调用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action))</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>sigaction()</code>应用并不广泛，因为它要求用户设置结构复杂的参数。更简洁的方法是函数<code>Signal()</code>，该函数最早由W.
Richard
Stevens提出，它是包装函数，会调用函数<code>sigaction()</code>，其调用方式与函数<code>signal()</code>相同。</p>
<p>　　函数<code>Signal()</code>会使用如下信号处理语义来注册信号处理函数：</p>
<p>　　● 只有与信号处理函数正在处理的信号的类型相同的信号会被阻塞。</p>
<p>　　● 信号不会排队。</p>
<p>　　● 只要可能，重启中断的系统调用。</p>
<p>　　●
一旦设置了信号处理函数，它会一直保持，直到<code>Signal()</code>带着<code>handler</code>参数为<code>SIG_IGN</code>或<code>SIG_DFL</code>被调用。</p>
<h4 id="同步流以避免并发漏洞">8.5.5 同步流以避免并发漏洞</h4>
<p>　　对于访问相同位置的并发流程序，流可能交错的数量与指令的数量呈指数关系。基本问题是以某种方式<span
style="background-color: yellow">同步</span>并发流来得到最大的可行的交错的集合，从而每个可行的交错都得到正确的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) <span class="comment">/* 回收子进程 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">        deletejob(pid); <span class="comment">/* 将子进程从作业列表删除 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        Sio_error(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* 初始化作业列表 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) <span class="comment">/* 创建子进程 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            Execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);   <span class="comment">/* 父进程 */</span></span><br><span class="line">        addjob(pid);                               <span class="comment">/* 将子进程加入到作业列表 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* 解除阻塞信号SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了典型UNIX
shell的结构。父进程通过全局作业列表中的条目来追踪当前子进程
(每个作业1个条目)。函数<code>addjob()</code>和<code>deletejob()</code>分别向作业列表中添加和删除作业。</p>
<p>　　当父进程创建新子进程后，它就把该子进程添加到作业列表中。当父进程在<code>SIGCHLD</code>处理函数中回收终止的子进程时，就从作业列表删除该子进程。</p>
<p>　　这段代码看似正确，但可能会出现以下事件序列：</p>
<p>　　1)
父进程执行函数<code>fork()</code>时，内核调度会让新创建的子进程来执行该函数。</p>
<p>　　2)
在父进程能够再次运行前，子进程已终止并变为僵尸进程，使得内核发送信号<code>SIGCHLD</code>给父进程。</p>
<p>　　3)
父进程再次变为可运行但又在它执行前，内核发现有未被处理的信号<code>SIGCHLD</code>，然后通过在父进程中运行信号处理函数来接收该信号。</p>
<p>　　4)
信号处理函数回收终止的子进程并调用函数<code>deletejob()</code>，该函数什么也不做，因为子进程未添加到作业列表。</p>
<p>　　5)
信号处理函数运行完毕后，内核运行父进程，父进程从函数<code>fork()</code>返回，调用函数<code>addjob()</code>错误地把
(不存在的) 子进程添加到作业列表。</p>
<p>　　这种同步错误称为<strong>竞争</strong>。主函数中调用的函数<code>addjob()</code>和信号处理函数中调用的函数<code>deletejob()</code>之间存在竞争。若函数<code>addjob()</code>竞争获胜，则程序会正确运行；否则，程序出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    Sigfillset(&amp;mask_all);</span><br><span class="line">    Sigemptyset(&amp;mask_one);</span><br><span class="line">    Sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">    Signal(SIGCHLD, handler);</span><br><span class="line">    initjobs(); <span class="comment">/* 初始化作业列表 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">/* 阻塞信号SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>)                      <span class="comment">/* 创建子进程 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* 解除阻塞信号SIGCHLD */</span></span><br><span class="line">            Execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);   <span class="comment">/* 父进程 */</span></span><br><span class="line">        addjob(pid);                               <span class="comment">/* 将子进程加入到作业列表 */</span></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">/* 解除阻塞信号SIGCHLD */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是解决竞争的方法之一，在调用函数<code>fork()</code>前阻塞信号<code>SIGCHLD</code>，然后调用函数<code>addjob()</code>，最后取消阻塞该信号，这样保证在子进程添加到作业列表后回收该子进程。子进程继承了父进程的<code>blocked</code>位集合，所以在调用函数<code>execve()</code>前，必须解除子进程中阻塞的信号<code>SIGCHLD</code>。</p>
<h4 id="显式地等待信号">8.5.6 显式地等待信号</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>sigsuspend()</code>会暂时用参数<code>mask</code>替换当前<code>blocked</code>位集合，然后挂起该进程，直到收到处理方式是终止或运行信号处理函数的信号。若收到的信号的处理方式是终止，则进程会直接终止；若收到的信号的处理方式是运行信号处理函数，则会从信号处理函数返回到函数<code>sigsuspend()</code>，然后再从函数<code>sigsuspend()</code>返回，最后将<code>blocked</code>位集合恢复到调用<code>sigsuspend()</code>时的状态。</p>
<p>　　函数<code>sigsuspend()</code>等同于以下的代码的原子版本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>　　原子属性消除了潜在的竞争，即在函数<code>sigprocmask()</code>后和<code>pause()</code>前收到信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sigsuspend.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno = errno;</span><br><span class="line">    pid = Waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line"></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    Signal(SIGINT, sigint_handler);</span><br><span class="line">    Sigemptyset(&amp;mask);</span><br><span class="line">    Sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); <span class="comment">/* 阻塞信号SIGCHLD */</span></span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 等待接收信号SIGCHLD */</span></span><br><span class="line">        pid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pid)</span><br><span class="line">        &#123;</span><br><span class="line">            sigsuspend(&amp;prev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>); <span class="comment">/* (可选) 解除阻塞信号SIGCHLD */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，每次调用函数<code>sigsuspend()</code>前，都会阻塞信号<code>SIGCHLD</code>。函数<code>sigsuspend()</code>会暂时取消阻塞信号<code>SIGCHLD</code>，然后睡眠，直到父进程捕获信号。在返回前，它会恢复之前的<code>blocked</code>位集合，然后再阻塞信号<code>SIGCHLD</code>。由于父进程捕获的信号可能是<code>SIGCHLD</code>，这里可以解除阻塞信号<code>SIGCHLD</code>，这对于有后台作业需要回收的shell可能有用。</p>
<h3 id="非本地跳转">8.6 非本地跳转</h3>
<p>　　C提供了称为<strong>非本地跳转</strong>的用户级异常控制流形式，它将控制权直接从某个函数转移给其他正在执行的函数，而不需要经过正常的调用/返回过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>; <span class="comment">/* 返回0 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>; <span class="comment">/* 返回非0 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> retval)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>setjmp()</code>和<code>longjmp()</code>提供非本地跳转。函数<code>setjmp()</code>会在<code>env</code>缓冲区中保存当前<strong>调用环境</strong>
(包括PC、栈指针和通用目的寄存器)，以供后面的函数<code>longjmp()</code>使用。函数<code>setjmp()</code>的返回值<span
style="background-color: yellow">不能</span>用于赋值，但可以用于<code>switch</code>和<code>if</code>语句的判断。函数<code>longjmp()</code>会从<code>env</code>缓冲区中恢复调用环境并触发从最近1次初始化<code>env</code>的函数<code>setjmp()</code>调用的返回，然后函数<code>setjmp()</code>返回并带有非0的返回值<code>retval</code>。</p>
<p>　　函数<code>setjmp()</code>即使被调用1次，也会返回多次，调用函数<code>setjmp()</code>并将调用环境保存在缓冲区<code>env</code>时会返回1次，之后每个对应的函数<code>longjmp()</code>调用也会返回1次。函数<code>longjmp()</code>无论被调用多少次，都不会返回。</p>
<p>　　函数<code>longjmp()</code>允许其跳过所有中间调用的特性可能会产生意外的结果，例如，某些中间函数调用涉及了数据结构的释放，因为这些代码被跳过，所以会产生内存泄漏。</p>
<p>　　非本地跳转的重要应用之一就是允许从多层嵌套的函数调用中立即返回，通常是由于检测到错误。若在多层嵌套的函数调用中发现了错误，则可以使用非本地跳转直接返回到普通的本地化错误处理函数，而非费力地展开调用栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* setjmp.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">jmp_buf buf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> error1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> error2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>, <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (setjmp(buf))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        foo();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Detected an error1 condition in foo\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Detected an error2 condition in foo\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error1)</span><br><span class="line">    &#123;</span><br><span class="line">        longjmp(buf, <span class="number">1</span>);</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error2)</span><br><span class="line">    &#123;</span><br><span class="line">        longjmp(buf, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，主函数会先调用函数<code>setjmp()</code>以保存当前的调用环境，然后调用函数<code>foo()</code>，函数<code>foo()</code>调用函数<code>bar()</code>。若函数<code>foo()</code>和<code>bar()</code>出错，则立即通过函数<code>longjmp()</code>从函数<code>setjmp()</code>返回。函数<code>setjmp()</code>的非0返回值指明了错误类型，可以做出相应的处理。</p>
<p>　　非本地跳转的另一个重要应用就是使信号处理函数跳转到特殊的代码位置，而非返回到信号到达时指令被中断的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* restart.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sigjmp_buf buf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    siglongjmp(buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sigsetjmp(buf, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Signal(SIGINT, handler);</span><br><span class="line">        Sio_puts(<span class="string">&quot;starting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sio_puts(<span class="string">&quot;restarting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(<span class="number">1</span>);</span><br><span class="line">        Sio_puts(<span class="string">&quot;processing...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，当输入Ctrl+C时，会用信号和非本地跳转来实现软重启。函数<code>sigsetjmp()</code>和<code>setlongjmp()</code>是函数<code>setjmp()</code>和<code>longjmp()</code>的可供信号处理函数使用的版本。为了避免竞争，必须在调用函数<code>sigsetjmp()</code>之后注册信号处理函数。其次，函数<code>sigsetjmp()</code>和<code>siglongjmp()</code>不是异步信号安全的函数，因为函数<code>siglongjmp()</code>可以跳转到任意代码。因此，应该在<code>siglongjmp()</code>可达的代码中仅调用异步信号安全的函数。</p>
<p>　　当程序第1次启动时，对函数<code>sigsetjmp()</code>的第1次调用会保存调用环境和信号的上下文
(包括待处理和已阻塞的信号集)。然后，主函数进入无限处理循环。当键盘输入Ctrl+C时，内核会发送信号<code>SIGINT</code>给该进程，该进程捕获信号。信号处理函数会执行非本地跳转，回到主函数的入口点。当运行该程序时，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./restart</span></span><br><span class="line">starting</span><br><span class="line">processing...</span><br><span class="line">processing...</span><br><span class="line">Ctrl+C</span><br><span class="line">restarting</span><br><span class="line">processing...</span><br><span class="line">Ctrl+C</span><br><span class="line">restarting</span><br><span class="line">processing...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第9章 虚拟内存</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_09/</url>
    <content><![CDATA[<p>　　虚拟内存诞生于20世纪60年代初期，远在CPU和内存之间的差距加大导致出现SRAM缓存之前。因此，虚拟内存系统使用了和SRAM缓存不同的术语，尽管它们的许多概念是相似的。在虚拟内存的习惯说法中，块称为<strong>页</strong>。在磁盘和内存之间传输页称为<strong>交换</strong>或<strong>页面调度</strong>，页<strong>换入</strong>
(也称为<strong>页面调入</strong>) 或<strong>换出</strong>
(也称为<strong>页面调出</strong>)
到磁盘中。现代操作系统都是使用<strong>按需页面调度</strong>，即只有当发生未命中时才换入页面。</p>
<p>　　在虚拟内存中，DRAM缓存未命中称为<strong>缺页</strong>。</p>
<p>　　<strong>地址空间</strong>是非负整数地址的有序集合<span
class="math inline">\(\{0,1,2...\}\)</span>。<strong>线性地址空间</strong>中的整数是连续的。</p>
<p>　　内存被组织为由<span
class="math inline">\(M\)</span>个连续的单字节大小的单元组成的数组。每个字节都有唯一的<strong>物理地址</strong>
(PA)。第1个字节的地址为0，第2个字节的地址为1，依此类推。CPU访问内存的最自然的方式是使用PA，这种寻址方式称为<strong>物理寻址</strong>。系统中有<strong>物理地址空间</strong>对应这<span
class="math inline">\(M\)</span>个字节。</p>
<p>　　以<span
class="math inline">\(n\)</span>位线性地址空间为例，CPU从<span
class="math inline">\(N=2^n\)</span>个地址的地址空间中生成<strong>虚拟地址</strong>
(VA)，这个地址空间称为<strong>虚拟地址空间</strong><span
class="math inline">\(\{0,1,2,..,N-1\}\)</span>。现代系统通常支持32位或64位虚拟地址空间。</p>
<p>　　内存中的每个字节都有1个来自虚拟地址空间的VA和1个来自物理地址空间的PA。</p>
<p>　　DEC PDP-11/70等早期的系统支持比物理内存更小的虚拟地址空间。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/a_system_that_uses_physical_addressing.svg" class="">
<p>　　这个示例的背景是加载1条指令，该指令读PA4处的4B字。当CPU执行该指令时，会生成有效PA并通过内存总线传递给内存。内存取出PA4处的4B字并将它返回给CPU。CPU会将该字存储在某个寄存器中。</p>
<span id="more"></span>
<p>　　早期计算机使用物理寻址，而且数字信号处理器、嵌入式微控制器和Cray超级计算机等系统还在使用这种寻址方式。现代CPU使用<strong>虚拟寻址</strong>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/a_system_that_uses_virtual_addressing.svg" class="">
<p>　　使用虚拟寻址时，CPU通过VA来访问内存，该VA在传递给内存前会先转换为对应的PA。将VA转换为PA的过程称为<strong>地址转换</strong>。地址转换需要CPU硬件和操作系统共同来实现。CPU芯片上的<strong>内存管理单元</strong>通过存储在内存中的查询表来动态转换VA，该表的内容由操作系统管理。</p>
<p>　　Linux中的函数<code>getrusage()</code>可以监测缺页的数量以及很多其他信息。</p>
<h3 id="虚拟内存作为缓存的空间">9.1 虚拟内存作为缓存的空间</h3>
<p>　　和存储器层次结构中其他缓存一样，磁盘上的数据被划分成块，这些块作为磁盘和内存之间的传输单元。为了应对这种情况，虚拟内存系统通过将虚拟内存划分为称为<strong>虚拟页</strong>的固定大小的块。每个虚拟页的大小<span
class="math inline">\(P=2^p\)</span>字节。同样，物理内存被划分为<strong>物理页</strong>
(也称为<strong>页帧</strong>)，大小也是<span
class="math inline">\(P\)</span>字节。</p>
<p>　　虚拟页的集合分为3个不相交的子集：<span
style="background-color: yellow">未分配</span>的页集合
(虚拟内存系统还未分配或创建的页)、<span
style="background-color: yellow">已缓存</span>的页集合
(当前已缓存在物理内存中的已分配的页) 和<span
style="background-color: yellow">未缓存</span>的页集合
(未缓存在物理内存中的已分配的页)。未分配的页没有与任何数据关联，所以不占用任何磁盘空间。</p>
<p>　　在存储器层次结构中，SRAM用于L1、L2和L3缓存，DRAM用于内存。DRAM缓存未命中的代价比SRAM缓存未命中的代价大得多。此外，读磁盘扇区的第1个字节的开销比读这个扇区中连续的字节的开销大得多。因此，VP比较大，通常是4KB~2MB。</p>
<p>　　由于DRAM缓存未命中的代价很大，所以它是全相联的，即任何VP都可以放置在任何PP中。未命中的替换策略也很重要，因为替换错误的VP的代价很高。因此，与硬件对SRAM缓存使用的替换策略相比，操作系统对DRAM缓存使用的替换策略更复杂。此外，磁盘的存取时间很长，所以DRAM缓存使用回写。</p>
<p>　　虚拟内存可能看似效率很低
(因为其严重的未命中代价)，由于局部性，虚拟内存的性能并不差。</p>
<p>　　尽管在整个运行过程中程序引用的页总数可能超过物理内存，但局部性保证了程序将趋于在较小的活动页集合上进行，这个集合称为<strong>工作集</strong>或<strong>常驻集</strong>。在初始化后
(将工作集调度到内存)，之后对该工作集的引用都会命中，而不会产生额外的磁盘流量。只要程序有良好的时间局部性，虚拟内存就能有不错的性能。但实际中并非总是如此，若工作集的大小超过了物理内存，程序会出现<strong>抖动</strong>，即页面不断地调入调出。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/how_a_virtual_memory_system_uses_main_memory_as_a_cache.svg" class="">
<p>　　这个示例中的虚拟内存有8个VP。VP0和3还为被分配，所以在磁盘上不存在。VP1、4和6缓存在物理内存中。VP2、5和7已经被分配但未被缓存在内存中。</p>
<p>　　同缓存一样，虚拟内存系统必须判断VP是否缓存在DRAM中。若已缓存，则需要确定存储VP的PP；若未缓存，则需要判断VP在磁盘中的位置，在物理内存中选择牺牲页并将VP复制到DRAM中替换牺牲页。这些功能需要硬件和软件共同完成，包括操作系统、MMU中的地址转换硬件和存储在物理内存中的称为<strong>页表</strong>的数据结构。</p>
<p>　　页表是<strong>页表条目</strong>组成的数组。每个VP在页表中的1个固定偏移处都有对应的PTE。这里为了展示，将PTE假设为由1位<span
style="background-color: yellow">有效位</span>和<span
class="math inline">\(n\)</span>位地址字段组成。有效位指明该VP当前是否缓存在DRAM中。当设置了有效位时，表示该VP对应的PP已缓存，地址字段就是DRAM中该VP对应的PP的起始地址。当未设置有效位时，若地址字段不为空，则地址字段就是磁盘上该VP的起始地址；若地址字段为空，则表示该VP还未被分配。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/page_table.svg" class="">
<p>　　这个示例中展示了有8个VP和4个PP的系统的页表。VP1、2、4和7缓存在DRAM中。VP0和5还未被分配。VP3和6已经被分配但未被缓存。</p>
<p>　　若CPU需要读VP2中的某个字，而VP2缓存在DRAM中，则地址转换硬件会将该字的VA作为索引来定位PTE2并从内存中读它。因为设置了有效位，地址转移硬件会使用PTE中的地址字段来生成该字的PA。</p>
<p>　　若CPU需要读VP3中的某个字，而VP3未缓存，则地址转换硬件会从内存中读取PTE3，从有效位推断VP3未缓存并触发缺页异常。缺页异常会调用内核中的缺页异常处理函数，该程序会选择牺牲页，这里假设选择了存储在PP3中的VP4。若VP4已修改，则内核会将进行回写
(将VP4复制回磁盘)。无论如何，内核都会修改VP4的PTE来指明VP4不再缓存在内存。然后，内核从磁盘复制VP3到内存中的PP3，更新PTE3，然后返回。当从缺页异常处理函数返回时，会重启导致缺页的指令。</p>
<p>　　若调用函数<code>malloc()</code>来分配VP5，分配过程是在磁盘上创建空间并更新PTE5使之指向磁盘上新创建的页。</p>
<h3 id="虚拟内存作为内存管理的工具">9.2 虚拟内存作为内存管理的工具</h3>
<p>　　操作系统会每个进程都提供独立的页表，即独立的虚拟地址空间。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/how_virtual_memory_provides_processes_with_separate_address_spaces.svg" class="">
<p>　　在这个示例中，进程<code>i</code>的页表将VP1映射到PP2，将VP2映射到PP7。同样，进程<code>j</code>的页表将VP1映射PP7，将VP2映射PP10。多个VP可以映射到同一共享PP上。</p>
<p>　　按需页面调度和独立的虚拟地址空间的结合对系统中内存的使用和管理有深远的影响，尤其是虚拟内存简化了<span
style="background-color: yellow">链接</span>、<span
style="background-color: yellow">加载</span>、<span
style="background-color: yellow">代码和数据的共享</span>以及<span
style="background-color: yellow">程序的内存分配</span>。</p>
<p>　　●
独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存储的物理内存位置。对于64位地址空间，代码段总是从虚拟地址<code>0x400000</code>开始。数据段在代码段之后
(中间有段对齐间隔)，栈在用户地址空间地址值最大的部分并向低地址增长，这样的一致性极大地简化了链接器的设计和实现，允许链接器生成完成链接的可执行文件，这些可执行文件独立于物理内存中代码和数据的最终位置。</p>
<p>　　●
虚拟内存让加载可执行文件和共享库很容易。为了把目标文件中的<code>.text</code>节和<code>.data</code>节加载到新创建进程中，Linux加载器会为代码段和数据段分配VP并将它们标记为无效
(即未被缓存)，然后将PTE指向目标文件中合适的位置。这里，加载器并不会立即从磁盘复制数据到内存。在每个页初次被引用时
(CPU取指令或正在执行的指令引用内存位置)，虚拟内存系统会按需自动调入数据页。</p>
<p>　　●
独立地址空间为操作系统提供了用于管理用户进程或操作系统自身间的共享的一致性机制。通常，每个进程都有私有的代码、数据、堆和栈区域，操作系统创建页表来将对应的VP映射到不连续的PP。在某些情况下，进程需要共享代码和数据。例如，每个进程必须调用相同的操作系统内核代码，而每个C程序都会调用C标准库中的函数，操作系统通过将不同进程中合适的VP映射到相同PP来实现多个进程共享这部分代码的副本。</p>
<p>　　●
虚拟内存为用户进程提供了简单的分配额外内存的机制。若运行在用户进程中的程序请求额外的空间
(通过调用函数<code>malloc()</code>等)，则操作系统会分配<span
class="math inline">\(k\)</span>个连续的VP并将它们映射到<span
class="math inline">\(k\)</span>个不连续的PP
(由于页表的工作方式，操作系统无需分配<span
class="math inline">\(k\)</span>个连续的PP)。</p>
<h3 id="虚拟内存作为内存保护的工具">9.3 虚拟内存作为内存保护的工具</h3>
<p>　　现代计算机系统必须为操作系统提供控制内存访问的方法。不应该允许用户进程写它的只读代码，也不应该允许它访问内核中代码和数据结构，还不应该允许它访问其他进程的私有内存和写任何与其他进程共享的VP
(除非所有的共享者通过显式的进程间通信系统调用来允许)。</p>
<p>　　独立的地址空间使得区分不同进程的私有内存很容易，但地址转换机制可以自然地扩展到提供更好的访问控制。每次CPU生成地址时，地址转换硬件都会读PTE，所以可以在PTE上添加一些额外的权限位来控制对VP的访问。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/using_virtual_memory_to_provide_page-level_memory_protection.svg" class="">
<p>　　在这个示例中，每个PTE中添加了3个权限位。<code>SUP</code>位表示是否只能在内核
(超级用户)
模式下访问该页。<code>READ</code>位和<code>WRITE</code>位表示该页的读和写权限。例如，若进程<code>i</code>运行在用户模式下，则它有VP0的读权限以及VP1的读和写权限。</p>
<p>　　若指令违反了这些权限，CPU会触发一般保护故障，将控制权转移给内核中的异常处理函数。</p>
<h3 id="地址转换">9.4 地址转换</h3>
<p>　　地址转换是<span
class="math inline">\(N\)</span>个元素的虚拟地址空间中的元素和<span
class="math inline">\(M\)</span>个元素的物理地址空间中的元素间的映射。
<span class="math display">\[
MAP: VAS\rightarrow PAS \cup \emptyset
\]</span> <span class="math display">\[
MAP(A) = \begin{cases} A&#39; &amp;&amp;
{若虚拟地址A处的数据在物理地址A&#39;处}\\[2px]
\emptyset &amp;&amp; {若虚拟地址A处的数据不在物理内存中}\end{cases}
\]</span></p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/address_translation_with_a_page_table.svg" class="">
<p>　　CPU中的称为<strong>页表基址寄存器</strong> (PTBR)
的控制寄存器指向当前页表。<span
class="math inline">\(n\)</span>位的VA包括<span
class="math inline">\(p\)</span>位的<strong>虚拟页偏移</strong> (VPO)
和<span class="math inline">\(n-p\)</span>位的<strong>虚拟页号</strong>
(VPN)。MMU通过VPN来选择对应的PTE，VPN0对应PTE0，VPN1对应PTE1，依此类推。将PTE中的<strong>物理页号</strong>
(PPO) 和VA中的VPO连接起来得到PA (PPO和VPO相同)。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/operational_view_of_page_hits_and_page_faults.svg" class="">
<p>　　页命中仅需硬件就可以完成，如图a所示。</p>
<p>　　1) CPU生成VA并发送给MMU。</p>
<p>　　2) MMU生成PTE地址并从缓存/内存请求对应的PTE。</p>
<p>　　3) 缓存/内存向MMU返回请求的PTE。</p>
<p>　　4) MMU生成PA并发送给缓存/内存。</p>
<p>　　5) 缓存/内存返回请求的数据给CPU。</p>
<p>　　缺页处理需要硬件和操作系统内核共同完成，如图b所示。</p>
<p>　　1~3步同页命中的1~3步相同。</p>
<p>　　4)
PTE中的有效位为0，所以MMU触发异常，将控制权转移给缺页异常处理函数。</p>
<p>　　5)
缺页异常处理函数确定物理内存中的牺牲页，若该页已被修改，则进行回写。</p>
<p>　　6) 缺页异常处理函数调入新页并更新内存中的PTE。</p>
<p>　　7)
从缺页异常处理函数返回到原来的程序并再次执行导致缺页的指令。CPU重新发送VA给MMU，此时该VA已缓存，所以会命中，内存会将请求的数据返回给CPU。</p>
<p>　　在同时使用虚拟内存和SRAM缓存的系统中，都有应使用VA还是PA来访问SRAM缓存的问题，大多数系统是选择物理寻址。物理寻址让多个进程同时在缓存中有存储块以及共享来自同一VP的块很简单。此外，缓存无需处理访问权限的问题，因为访问权限控制是地址转换的一部分。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/integrating_virtual_memory_with_a_physically_addressed_cache.svg" class="">
<p>　　结合虚拟内存和物理寻址的缓存的主要思路是让地址转换在查找缓存前执行。此外，PTE可以缓存，就像数据一样。</p>
<h4 id="用tlb加速地址转换">9.4.1 用TLB加速地址转换</h4>
<p>　　每次CPU生成VA，MMU必须查阅PTE来将其转换为PA。在最差的情况下，还需要从内存中读取1次数据，开销是几十到几百个周期。若PTE刚好在L1缓存中，则开销就下降到1或2个周期。然而，很多系统通过在MMU加入称为<strong>转换后备缓存区</strong>的PTE缓存来消除这样的开销。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/components_of_a_virtual_address_that_are_used_to_access_the_tlb.svg" class="">
<p>　　TLB是虚拟寻址的较小的缓存，其中的每行都保存着1个由单个PTE组成的块。TLB通常有很高的相联度。用于组选择和行匹配的索引和标识字段来自VA中的VPN。若TLB有<span
class="math inline">\(T=2^t\)</span>个组，则TLBI由VPN的低<span
class="math inline">\(t\)</span>位组成，TLBT由VPN中的剩余位组成。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/operational_view_of_a_tlb_hit_and_miss.svg" class="">
<p>　　所有的地址转换步骤是由CPU芯片上的MMU执行，所以很快，如图a所示。</p>
<p>　　1) CPU生成VA。</p>
<p>　　2 &amp; 3) MMU从TLB中取出相应的PTE。</p>
<p>　　4) MMU将该VA转换为PA并发送给缓存/内存。</p>
<p>　　5) 缓存/内存将请求的数据返回给CPU。</p>
<p>　　当TLB未命中时，MMU必须从L1缓存中取出对应的PTE，如图b所示。取出的PTE会存储在TLB中，可能会覆盖其中的1个条目。</p>
<h4 id="多级页表">9.4.2 多级页表</h4>
<p>　　到目前为止的情况都是假设只用1个页表来进行地址转换。对于有32位地址空间、4KB的页和4B的PTE的系统，即使程序引用的只是虚拟地址空间中很小的一部分，还是需要4MB的页表驻留在内存中。对于地址空间为64位的系统，问题将变得更复杂。</p>
<p>　　压缩页表的常用方法是使用<span
style="background-color: yellow">层次结构的页表</span>。假设32位虚拟地址空间被分为4KB的页，每个PTE都是4B。此外，还假设内存的前<span
class="math inline">\(2K\)</span>个页分配给代码和数据，接下来的<span
class="math inline">\(6K\)</span>未分配，再接下来的<span
class="math inline">\(1023\)</span>个页也未分配，最后1个页分配给用户栈。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/a_two-level_page_table_hierarchy.svg" class="">
<p>　　1级页表中的每个PTE负责映射虚拟地址空间中的4MB的<span
style="background-color: yellow">片</span>，这里的片都是由1024个连续的页组成。例如，PTE0映射第1片，PTE1映射到接下来的片，依此类推。若地址空间为4GB，1024个PTE足以覆盖整个空间。若片<span
class="math inline">\(i\)</span>中的每个页都未被分配，那么1级PTE<span
class="math inline">\(i\)</span>就为空。</p>
<p>　　2级页表中的每个PTE负责映射4KB的VP。1级页表和2级页表的PTE都是4B，所以1级页表、2级页表和页的大小都是相同的。</p>
<p>　　这种方法从2个方面减少了内存要求。首先，若1级页表中的某个PTE为空，则对应的2级页表就不会存在。这表示巨大的潜在节约，因为对于常规程序，4GB的虚拟地址空间中的大部分都是未被分配的。其次，只有1级页表才需要常驻内存。虚拟内存系统可以在需要时创建、调入或调出2级页表，这样减少了内存的压力。只有最常使用的2级页表才需要缓存在内存中。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/address_translation_with_k-level_page_table.svg" class="">
<p>　　对于使用<span
class="math inline">\(k\)</span>级页表的地址转换，VA划分为<span
class="math inline">\(k\)</span>个VPN和1个VPO。VPN<span
class="math inline">\(i\)</span>是到<span
class="math inline">\(i\)</span>级页表的索引，其中<span
class="math inline">\(1\leqslant i\leqslant k\)</span>。<span
class="math inline">\(j\)</span>级页表中的每个PTE都指向<span
class="math inline">\(j+1\)</span>级中的某个页表的基址，其中<span
class="math inline">\(1\leqslant j\leqslant k-1\)</span>。<span
class="math inline">\(k\)</span>级页表中的每个PTE包含某个PP的PPN或某个磁盘块的地址。为了生成PA，在确定PPN前，MMU必须访问<span
class="math inline">\(k\)</span>个PTE。对于仅有1级的页表结构，PPO和VPO是相同的。</p>
<p>　　访问<span
class="math inline">\(k\)</span>个PTE时，看似开销很大。由于不同层级上页表的PTE已缓存，所以多级页表的地址转换并不会比单级页表的地址转换慢很多。</p>
<h4 id="端到端的地址转换">9.4.3 端到端的地址转换</h4>
<p>　　以有TLB和L1数据缓存的系统为例，为了保证可管理性，做出如下假设：</p>
<p>　　● 内存是按字节寻址的。</p>
<p>　　● 内存访问是针对<span
style="background-color: yellow">1B的字</span>。</p>
<p>　　● VA是14位。</p>
<p>　　● PA是12位。</p>
<p>　　● 页大小是64B。</p>
<p>　　● TLB是4路组相联的，共有16个条目。</p>
<p>　　● L1数据缓存是物理寻址且直接映射的，行大小是4B，共有16个组。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/tlb,page_table,and_cache_for_small_memory_system.svg" class="">
<p>　　每个页都是<span
class="math inline">\(2^6=64\)</span>B，所以VA和PA的低6位分别是VPO和PPO。VA的高8位作为VPN。PA的高6位作为PPN。</p>
<p>　　TLB通过VPN的位进行虚拟寻址。因为TLB有4个组，所以VPN的低2位作为TLBI。VPN的高6位作为TLBT，用于区分映射到同一TLB组的VPN。</p>
<p>　　页表是单级页表，共有<span
class="math inline">\(2^8=256\)</span>个PTE。这里只展示前16个PTE，为了方便，用索引它的VPN来作为标识
(实际中VPN并不存储在内存中)。<code>-</code>表示无效PTE的PPN。</p>
<p>　　直接映射的缓存通过PA中的字段来寻址。每个块都是4B，所以PA中的低2位作为缓存偏移。共有16组，所以PA中接下来的4位用于表示缓存索引，最后6位作为缓存标识。</p>
<p>　　以CPU执行读<code>0x03D4</code>处的字节的加载指令为例，MMU从虚拟地址中提取VPN<code>0x0F</code>，检查TLB来判断它是否已缓存PTE<code>0x0F</code>的副本。TLB从VPN中提取TLBI<code>0x03</code>和TLBT<code>0x3</code>。组<code>0x3</code>中的第2个条目匹配，所以命中，然后将缓存的PPN<code>0x0D</code>返回给MMU。</p>
<p>　　现在MMU能够生成PA，通过来自PTE的PPN<code>0x0D</code>和来自VA的VPO<code>0x14</code>连接起来得到PA<code>0x354</code>。然后，MMU将PA发送给缓存，缓存从PA中提取CO<code>0x0</code>、CI<code>0x5</code>和CT<code>0x0D</code>。</p>
<p>　　组<code>0x5</code>中的标识与CT匹配，所以缓存命中，读出CO处的数据字节<code>0x36</code>并返回给MMU，MMU返回给CPU。</p>
<p>　　转换过程中还有其他可能。例如，若TLB未命中，则MMU必须从页表中的PTE中提取PPN。若得到PTE是无效的，则会出现缺页，内核必须调入合适的页并重新加载这条指令。另一种可能是PTE是有效的，但是所需的内存块未缓存在缓存中。</p>
<h3 id="案例研究intel-core-i7linux内存系统">9.5 案例研究：Intel Core
i7/Linux内存系统</h3>
<p>　　以运行Linux的Intel Core
i7为例，虽然底层的Haswell微体系架构完全支持64位虚拟和物理地址空间，但Core
i7的实现仅支持48位 (256TB) 虚拟地址空间、52位 (4PB) 物理地址空间以及32位
(4GB) 虚拟和物理地址空间的兼容模式。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/the_intel_core_i7_memory_system.svg" class="">
<p>　　Core
i7内存系统的<strong>处理器封装</strong>包括4个核以及所有核共享的L3缓存和DDR3存储控制器。每个核包括1个层次结构的TLB、1个层次结构的数据和指令缓存以及1组高速点到点链路。高速点到点链路基于QuickPath技术，可以让核与其他核以及外部I/O桥直接通信。TLB是虚拟寻址且4路组相联。L1、L2和L3缓存是物理寻址，块大小是64B。L1和L2缓存是8路组相联，L3缓存是16路组相联。页大小可以在启动时配置为4KB和4MB。Linux使用的是4KB页。</p>
<h4 id="core-i7地址转换">9.5.1 Core i7地址转换</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/summary_of_core_i7_address_translation.svg" class="">
<p>　　Core
i7采用4级页表层次结构。每个进程都有私有页表层次结构。当Linux进程运行时，虽然Core
i7体系结构允许页表调度，但与已分配的页关联的页表都会驻留在内存中。CR3控制寄存器指向1级页表的起始处。CR3的值是每个进程上下文中的一部分，每次上下文切换时，CR3的值都会恢复。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/format_of_level_1,level_2,and_level_3_pte.svg" class="">
<p>　　对于1~3级PTE，当P=1时
(Linux中总是如此)，页表物理基址包含40位PPN，它指向对应页表的起始处。此外，这里还要求页表按4KB对齐。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/format_of_level_4_pte.svg" class="">
<p>　　对于4级PTE，当P=1时，页表物理基址包括40位PPN，它指向物理内存中某页的基址。此外，这里还要求PP按4KB对齐。</p>
<p>　　PTE有3个权限位来控制页的访问。R/W位表示页的内容是只读还是可读写的。U/S位表示能否在用户模式下访问页。XD
(禁止执行)
是64位系统中新增的位，表示禁止从页中取指令，这是重要的新特性，通过限制只能执行只读代码段，使得操作系统内核降低了缓冲区溢出攻击的风险。</p>
<p>　　当MMU转换VA时，还会更新2个缺页异常处理函数会用到的位。每次访问页时，MMU会设置A位，称为<strong>引用位</strong>。内核可以用这个引用位来实现页替换算法。每次写页后，MMU会设置D位，称为<strong>修改位</strong>或<strong>脏位</strong>。修改位表示内核在复制替换页前是否需要回写牺牲页。内核可以通过调用特殊的内核指令来清除引用位。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/core_i7_page_table_translation.svg" class="">
<p>　　通过页表将VA转换为PA时，36位VPN会划分为4个9位的部分，每部分用作1个页表的偏移。CR3寄存器包含1级页表的PA。VPN1提供到1级PTE的偏移，该1级PTE包含2级页表的基址。VPN2提供到2级PTE的偏移，依此类推。</p>
<p>　　地址转换分为MMU将VA转换为PA和将PA发送给L1缓存。实际的硬件实现允许这2个步骤部分重叠，所以也加速了L1缓存的访问。例如，对于页大小为4KB的Core
i7，因为8路组相联且物理寻址的L1缓存有64个组和64B的块，PA有6位CI和6位CO，这12位刚好组成PPO，而PPO和VPO完全相同。因此，当MMU向TLB请求PTE时，L1缓存正在通过VPO查找对应的组并读出这个组里的8个标识和对应的数据。当MMU从TLB得到PPN时，缓存已准备好尝试把这个PPN和8个标识进行匹配。</p>
<h4 id="linux虚拟内存系统">9.5.2 Linux虚拟内存系统</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/the_virtual_memory_of_a_linux_process.svg" class="">
<p>　　内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域会映射到所有进程共享的PP，例如，每个进程共享的代码和全局数据结构。Linux也会将1组连续的VP
(大小为系统中DRAM的总大小)
映射到1组连续的PP，这为内核提供了便利的方法来访问物理内存中任何特定的位置，例如，当需要访问页表或在映射到特定物理内存位置的设备上执行内存映射的I/O操作时。</p>
<p>　　内核虚拟内存中的其他区域包含每个进程都不同的数据，例如，页表、内核在进程的上下文中执行代码时使用的栈以及记录虚拟地址空间当前组织的各种数据结构。</p>
<h5 id="linux虚拟内存区域">9.5.2.1 Linux虚拟内存区域</h5>
<p>　　Linux将虚拟内存组织为<strong>区域</strong>
(也称为<strong>段</strong>) 集合。1个区域就是已存在 (已分配)
的虚拟内存的连续片，其中的页以某种方式相关联。例如，代码段、数据段、堆、共享库段以及用户栈都是不同的区域。每个存在的VP都保存在某个区域中，而不属于任何区域的VP是不存在的，并且不能被引用。区域允许虚拟地址空间有间隙。内核不用记录不存在的VP，这样的VP不占用内存、磁盘或内核本身的资源。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/how_linux_organizes_virtual_memory.svg" class="">
<p>　　内核为每个进程维护独立的任务结构<code>task_struct</code>。任务结构中的元素包含或指向内核运行该进程所需的所有信息，例如，PID、指向用户栈的指针、可执行文件的名称和PC。</p>
<p>　　任务结构中的1个条目指向<code>mm_struct</code>，它描述虚拟内存的当前状态。<code>pgd</code>指向1级页表
(页全局目录)
的基址。<code>mmap()</code>指向由区域结构<code>vm_area_struct</code>组成的链表，其中的每个区域结构都描述当前虚拟地址空间的某个区域。当内核运行进程时，会将该进程的<code>pgd</code>放入CR3寄存器中。</p>
<p>　　区域结构包含以下字段：</p>
<p>　　● <code>vm_start</code>指向该区域的起始处。</p>
<p>　　● <code>vm_end</code>指向该区域的结束处。</p>
<p>　　● <code>vm_prot</code>描述该区域包含的所有页的读写权限。</p>
<p>　　● <code>vm_flags</code>表示该区域的页 (还有其他信息)
是与其他进程共享还是该进程私有。</p>
<p>　　● <code>vm_next</code>指向链表中的下一个区域结构。</p>
<h5 id="linux缺页处理">9.5.2.2 Linux缺页处理</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/linux_page_fault_handling.svg" class="">
<p>　　若MMU转换VA时触发了缺页，则会导致控制权转移到缺页异常处理函数，缺页异常处理函数会执行以下步骤：</p>
<p>　　1) <span
style="background-color: yellow">判断该VA是否在某个区域结构定义的区域内</span>。因此，缺页异常处理函数会搜索区域结构链表，将该VA和每个区域结构中的<code>vm_start</code>和<code>vm_end</code>进行匹配。若没有匹配项，则触发段故障，从而终止该进程。进程可以创建任意数量的虚拟内存区域，所以顺序搜索区域结构链表的代价可能很大。在实际中，Linux会使用某些这里没有显示的字段在链表中生成树并在树上进行搜索。</p>
<p>　　2) <span
style="background-color: yellow">判断进程对该区域内的页是否有足够的访问权限</span>。若试图进行的访问不合法
(写只读的页和在用户模式下读内核虚拟内存等)，则缺页异常处理函数会触发保护故障，从而终止该进程。</p>
<p>　　3) <span
style="background-color: yellow">内核确定该缺页是对合法的VA进行合法操作导致的</span>。接下来就是常规的缺页处理，选择牺牲页，若牺牲页被修改过，则进行回写，然后进行页面调度。当从缺页异常处理函数返回时，CPU会重新执行导致缺页的指令，然后MMU正常转换VA。</p>
<h3 id="内存映射">9.6 内存映射</h3>
<p>　　Linux通过将虚拟内存区域与磁盘上的对象关联来初始化该虚拟内存区域的内容，该过程称为<strong>内存映射</strong>。Linux提供了系统调用<code>mmap()</code>来允许程序进行内存映射。虚拟内存区域可以映射到<span
style="background-color: yellow">Linux文件系统中的普通文件</span>和<span
style="background-color: yellow">匿名文件</span>的对象。</p>
<p>　　●
1个区域可以映射到1个普通磁盘文件的连续部分，例如，1个可执行文件。<strong>文件区</strong>被分为页大小的片，每个片都包含1个VP的初始内容。因为按需页面调度，只有当CPU首次引用VP时
(发送在该VP地址空间范围内的VA)，该VP才会调入物理内存。若区域比文件区大，则会用0来填充该区域剩余的部分。</p>
<p>　　●
1个区域也可以映射到1个匿名文件。匿名文件由内核创建，其内容全是二进制0。当CPU首次引用映射到匿名文件的区域内的VP时，内核会在物理内存中选择牺牲页，若牺牲页被修改过，则将牺牲页回写，用二进制0覆盖牺牲页并更新页表。这里磁盘和内存之间没有实际的数据传输。因此，映射到匿名文件的区域的页也称为<strong>请求二进制0的页</strong>。</p>
<p>　　一旦VP初始化，它就在内核维护的<strong>交换文件</strong>之间进行交换，交换文件也称为<strong>交换区域</strong>或<strong>交换空间</strong>。交换空间限制着当前运行的进程能够分配的VP总数。</p>
<h4 id="再看共享对象">9.6.1 再看共享对象</h4>
<p>　　对象可以映射到虚拟内存的某个区域，要么作为共享对象，要么作为私有对象。共享对象映射的虚拟内存区域称为<strong>共享区域</strong>，同样，也有<strong>私有区域</strong>。</p>
<p>　　若进程将共享对象映射到它的虚拟内存的某个区域，则进程对该区域的写操作对其他把该共享对象映射到其虚拟内存的进程是可见的。此外，这些变化也会反映在磁盘的原始对象上。</p>
<p>　　对于映射到私有对象的区域，进程对该区域的修改对其他进程是不可见的，而且进程对该区域的写操作不会反映在磁盘的原始对象上。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/a_shared_object.svg" class="">
<p>　　在这个示例中，进程1将共享对象映射到它的虚拟内存的某个区域中，然后进程2也将同一共享对象映射到它的虚拟内存的某个区域中
(并不一定与进程1的VP相同)。因为每个对象有唯一的文件名，内核可以快速判断进程1已经映射该共享对象并将进程2的PTE指向合适的PP。即使共享对象映射到多个共享区域，物理内存只需存储共享对象的1个副本。这里为了方便，将PP显示为连续的，但一般情况下并非如此。</p>
<p>　　私有对象使用<strong>写时复制</strong>的技术来映射到虚拟内存中。私有对象的开始生命周期的方式基本与共享对象相同，在物理内存中只保存私有对象的1个副本。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/a_private_copy-on-write_object.svg" class="">
<p>　　在这个示例中，2个进程将私有对象映射到虚拟内存的不同区域，但是共享该对象的同一物理副本。对于每个进程，对应私有区域的PTE都是只读，且区域结构为<span
style="background-color: yellow">私有写时复制</span>。当进程写私有区域的页时，写操作会触发保护故障。故障处理函数会在物理内存中创建该页的副本，更新PTE来指向该副本，然后恢复该页的写权限。当从故障处理函数返回时，CPU重新执行写操作，写操作在副本上正常执行。</p>
<p>　　通过尽可能地推迟创建私有对象的副本，写时复制充分利用了物理内存。</p>
<h4 id="再看fork和execve">9.6.2
再看<code>fork()</code>和<code>execve()</code></h4>
<p>　　当进程调用函数<code>fork()</code>时，内核会为子进程创建各种数据结构并分配唯一的PID。为了给子进程创建虚拟内存，会复制父进程的<code>mm_struct</code>、区域结构和页表。最后，将这2个进程的所有页都设置为只读并将这2个进程中的所有区域结构都设置为私有写时复制。</p>
<p>　　当函数<code>fork()</code>从子进程返回时，子进程当前的虚拟内存与调用函数<code>fork()</code>时的虚拟内存相同。然后，当这2个进程之一执行写操作时，写时复制机制会创建新页。因此，这为每个进程保留了私有地址空间。</p>
<p>　　假设当前进程执行<code>execve("a.out", NULL, NULL)</code>，函数<code>execve()</code>会在当前进程中加载并运行可执行文件<code>a.out</code>中包含的程序，然后用该程序代替当前程序。加载并运行可执行文件<code>a.out</code>需要如下步骤：</p>
<p>　　1) <span
style="background-color: yellow">删除已存在的用户区域</span>。删除当前进程VA的用户部分中的已存在的区域结构。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/how_the_loader_maps_the_areas_to_the_user_address_space.svg" class="">
<p>　　2) <span
style="background-color: yellow">映射私有区域</span>。为新程序的代码、数据、<code>bss</code>和栈区域创建新区域结构，这些新区域都是私有写时复制的。代码和数据区域映射到文件<code>a.out</code>的<code>.text</code>节和<code>.data</code>节。<code>bss</code>区域是请求二进制0的，映射到匿名文件，其大小包含在文件<code>a.out</code>中。栈和堆区域也是请求二进制0的，初始长度为0。</p>
<p>　　3) <span
style="background-color: yellow">映射共享区域</span>。若程序<code>a.out</code>与<code>libc.so</code>等共享库链接，则这些共享库会动态链接到该程序，然后映射到用户虚拟地址空间中的共享区域。</p>
<p>　　4) <span
style="background-color: yellow">设置PC</span>。函数<code>execve()</code>做的最后1件事就是设置当前进程上下文中的PC，使之指向代码区域的入口点。下次调度该进程时，它将从该入口点执行。</p>
<h4 id="mmap">9.6.3 <code>mmap()</code></h4>
<p>　　Linux进程可以通过函数<code>mmap()</code>来创建新虚拟内存区域并将对象映射到该区域中。函数<code>munmap()</code>可以删除虚拟内存区域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>; <span class="comment">/* 成功时返回指向映射区域的指针，出错时返回MAP_FAILED(-1) */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>mmap()</code>会让内核创建新虚拟内存区域
(尽量从地址<code>start</code>开始)，然后将文件描述符<code>fd</code>指定的对象的1个连续的片映射到该区域。连续的对象片的大小为<code>length</code>字节，从文件开始处偏移为<code>offset</code>字节开始。地址<code>start</code>仅仅是1个暗示，通常定义为<code>NULL</code>。</p>
<p>　　参数<code>prot</code>包含描述新映射的虚拟内存区域的访问权限位，即对应的区域结构中的<code>vm_prot</code>。</p>
<p>　　●
<code>PROT_EXEC</code>表示该区域内的页由CPU能执行的指令组成。</p>
<p>　　● <code>PROT_READ</code>表示该区域内的页可读。</p>
<p>　　● <code>PROT_WRITE</code>表示该区域内的页可写。</p>
<p>　　● <code>PROT_NONE</code>表示该区域内的页不能被访问。</p>
<p>　　参数<code>flags</code>由描述映射对象类型的位组成。若设置为<code>MAP_ANON</code>，则映射的对象是匿名对象，而对应的VP是请求二进制0的；若设置为<code>MAP_PRIVATE</code>，则映射的对象是私有写时复制的；若设置为<code>MAP_SHARED</code>，则映射的对象是共享对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bufp = Mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_PRIVATE | MAP_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>　　这段代码会创建<code>size</code>字节的只读、私有和请求二进制0的虚拟内存区域。若调用成功，则<code>bufp</code>会包含新区域的地址。</p>
<p>　　函数<code>munmap()</code>会删除从地址<code>start</code>开始的<code>length</code>字节的区域。之后对已删除区域的引用会导致段故障。</p>
<h3 id="动态内存分配">9.7 动态内存分配</h3>
<p>　　虽然可以通过底层的函数<code>mmap()</code>和<code>munmap()</code>来创建和删除虚拟内存区域，但是C的<strong>动态内存分配器</strong>更方便且有更好的可移植性。</p>
<p>　　动态内存分配器维护着<span
style="background-color: yellow">堆</span>。各个系统之间的细节不同，但是不失通用性，这里假设堆是请求二进制0的区域，它紧接着未初始化数据区，并向高地址增长。内核为每个进程维护着指向堆顶部的变量<code>brk</code>。</p>
<p>　　分配器将堆维护为由大小不同的块组成的集合。每个块是1个连续的<span
style="background-color: yellow">虚拟内存片</span>。块要么是已分配的，要么是空闲的。已分配的块显式地保留为应用程序使用。空闲块可用来分配。空闲块会一直保持空闲，直到显式地被应用程序分配。已分配的块会一直保持已分配，直到被释放，这种释放要么由应用程序显式执行，要么由内存分配器隐式执行。</p>
<p>　　分配器有2种形式，两者都要求应用程序显式地分配块，不同之处在于由负责释放已分配的块的实体。</p>
<p>　　● <span
style="background-color: yellow">显式分配器</span>要求应用程序显式地释放所有已分配的块。C通过函数<code>malloc()</code>来分配块并通过函数<code>free()</code>来释放块。C++中的操作符<code>new</code>和<code>delete</code>与C中的函数<code>malloc()</code>和<code>free()</code>类似。</p>
<p>　　● <span
style="background-color: yellow">隐式分配器</span>要求分配器检测到已分配的块不再被使用时，就释放该块。隐式分配器也称为<strong>垃圾回收器</strong>，自动释放未使用的已分配的块称为<strong>垃圾回收</strong>。Lisp、ML和Java等高级语言通过垃圾回收来释放已分配的块。</p>
<p>　　程序使用动态内存分配最重要的原因是经常<span
style="background-color: yellow">到运行时才知道某些数据结构的大小</span>。</p>
<h4 id="malloc和free">9.7.1
<code>malloc()</code>和<code>free()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>; <span class="comment">/* 成功时返回指向分配块的指针，失败时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>malloc()</code>返回指向大小至少为<code>size</code>字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型进行对齐。实际上，对齐取决于代码是在32位模式还是64位模式编译。在32位模式中，函数<code>malloc()</code>返回块的地址总是8的倍数；在64位模式中，该地址总是16的倍数。</p>
<p>　　若函数<code>malloc()</code>出错
(请求的内存块比可用的虚拟内存更大等)，则会返回<code>NULL</code>并设置<code>errno</code>。函数<code>malloc()</code>不会初始化返回的块。若需要返回已初始化的块，则可以使用函数<code>calloc()</code>，该函数是基于函数<code>malloc()</code>的瘦包装函数，会将分配的块初始化为0。若需要改变之前分配的块的大小，则可以使用函数<code>realloc()</code>。</p>
<p>　　函数<code>free()</code>会释放参数<code>ptr</code>指向的块。参数<code>ptr</code>必须指向通过函数<code>malloc()</code>、<code>calloc()</code>或<code>realloc()</code>得到的已分配的块的起始处。否则，函数<code>free()</code>的行为将是未定义的。此外，函数<code>free()</code>不会返回，所以即使出错也不会有反馈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span>; <span class="comment">/* 成功时返回brk的旧值，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sbrk()</code>通过将内核的<code>brk</code>指针增加<code>incr</code>来扩展或收缩堆。若成功，则会返回<code>brk</code>的旧值；若出错，则返回-1并将<code>errno</code>置为<code>ENOMEM</code>。若<code>incr</code>为0，则返回<code>brk</code>的当前值；若<code>incr</code>小于0，则返回值指向新堆顶向上<code>incr</code>字节处。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/allocating_and_freeing_blocks_with_function_malloc_and_free.svg" class="">
<p>　　这个示例展示了通过函数<code>malloc()</code>和<code>free()</code>管理16字且双字对齐的堆
(这里的字为4B)，每个方框代表1个字。图a会请求4字的块，函数<code>malloc()</code>会从空闲块前部分配4字的块。图b会请求5字的块，函数<code>malloc()</code>会从空闲块前部分配6字的块
(为了对齐)。图c会请求6字的块，函数<code>malloc()</code>会从空闲块前部分配6字的块。图d会释放图b中分配的6字的块，但指针<code>p2</code>仍然指向释放后的块。图e会请求2字的块，函数<code>malloc()</code>会从图d释放的块的前部分配2字的块。</p>
<h4 id="分配器的要求和目标">9.7.2 分配器的要求和目标</h4>
<p>　　显式分配器必须在以下约束条件下工作：</p>
<p>　　● <span
style="background-color: yellow">处理任意请求序列</span>。程序可以有任意的分配请求和释放请求序列，只要满足约束条件
(每个释放请求必须对应1个当前已分配的块，这个块由之前的分配请求获得)。因此，分配器不可以假设分配请求和释放请求的顺序。</p>
<p>　　● <span
style="background-color: yellow">立即响应请求</span>。分配器必须立即响应分配请求。因此，不允许分配器为了提高性能重新排列或缓存请求。</p>
<p>　　● <span
style="background-color: yellow">只使用堆</span>。为了保证分配器是可扩展的，分配器使用的任何非标量数据结构必须保存在堆里。</p>
<p>　　● <span
style="background-color: yellow">块对齐</span>。分配器必须对齐块使得可以保存任何类型的数据对象。</p>
<p>　　● <span
style="background-color: yellow">不修改已分配的块</span>。分配器只能操作或修改空闲块。因此，压缩已分配的块等技术是不允许使用的。</p>
<p>　　在这些限制条件下，分配器的编写者需要试图实现<span
style="background-color: yellow">吞吐率最大化</span>和<span
style="background-color: yellow">内存利用率最大化</span>，而这2个性能目标通常是冲突的。</p>
<p>　　吞吐率定义为每个单位时间里完成的请求数，可以通过最小化分配请求和释放请求所需的时间来最大化吞吐率。然而，最差情况下分配请求所需的时间与空闲块的数量呈线性关系，释放请求所需的时间是常数。</p>
<p>　　衡量堆利用率的最有用的标准是<strong>峰值利用率</strong>。对于<span
class="math inline">\(n\)</span>个请求的序列<span
class="math inline">\(R_o,R_1,...,R_k,..,R_{n-1}\)</span>，若程序请求<span
class="math inline">\(p\)</span>字节的块，则得到的已分配的块的<strong>有效载荷</strong>是<span
class="math inline">\(p\)</span>字节。在请求<span
class="math inline">\(R_k\)</span>完成后，<strong>聚合有效载荷</strong>表示为<span
class="math inline">\(P_k\)</span>，即当前已分配的块的有效载荷总和。堆的当前大小
(单调非递减) 表示为<span class="math inline">\(H_k\)</span>。前<span
class="math inline">\(k+1\)</span>个请求的峰值利用率表示为<span
class="math inline">\(U_k\)</span>。 <span class="math display">\[
U_k=\frac{max_{i\leqslant k}P_i}{H_k}
\]</span> 　　这里可以将前<span
class="math inline">\(k+1\)</span>个请求的利用率峰值表示为<span
class="math inline">\(H_k\)</span>，则可以在<span
class="math inline">\(U_k\)</span>的定义中放宽单调非递减的条件并且允许堆扩展和收缩。</p>
<p>　　<strong>碎片</strong>是导致堆利用率低的主要原因之一。当未使用的内存不能满足分配请求时，就会出现这种情况。碎片分为<strong>外部碎片</strong>和<strong>内部碎片</strong>。</p>
<p>　　内部碎片在已分配的块比有效载荷大时出现，很多原因都能造成该问题。例如，分配器的实现可能对分配的块有最小值要求或者分配器为了保证对齐。内部碎片的量化很简单，就是所有已分配的块大小和其有效载荷之间的差的总和，所以内部碎片的数量只取决于之前请求的模式和分配器的实现。</p>
<p>　　外部碎片在空闲块总和能满足某个分配请求，但没有单独的空闲块能满足该分配请求时出现。外部碎片的量化不仅取决于之前请求的模式和分配器的实现，还取决于未来请求的模式。因此，分配器通常采用启发式策略，尽量维持少量的大空闲块而非大量的的小空闲块。</p>
<h4 id="隐式空闲链表">9.7.3 隐式空闲链表</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/format_of_a_simple_heap_block.svg" class="">
<p>　　简单的堆块由<span
style="background-color: yellow">1个字的首部</span>、<span
style="background-color: yellow">有效载荷</span>和<span
style="background-color: yellow">可选的填充部分</span>组成。</p>
<p>　　首部描述该块的大小 (包括首部、有效载荷和填充部分) 和分配状态
(已分配或空闲)。若加上双字对齐的约束条件，则块大小必须8的整数倍，即块大小字段的低3位必须是0。因此，只需要首部的高29位就可以表示块大小，低3位可以表示其他信息，在这种情况下，用最低位表示该块的分配状态。首部后就是调用函数<code>malloc()</code>时请求的有效载荷。填充部分可用于分配器策略、解决外部碎片问题和保证对齐。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/organizing_the_heap_with_an_implicit_free_list.svg" class="">
<p>　　若堆由简单的堆块组成，则可以将堆组织为连续的已分配的块和空闲块的序列，这种结构称为<strong>隐式空闲链表</strong>，因为空闲块通过首部中块大小字段隐式地连接。分配器可以通过遍历堆中所有的块来遍历整个空闲块的集合。此外，需要某种特殊标记的结束块，这里使用的是分配状态为已分配但块大小是0的<strong>终止首部</strong>。</p>
<p>　　隐式空闲链表的优点是简单，缺点是不低的操作成本。例如，对于搜索空闲块，搜索所需时间与堆中块的数量呈线性关系。</p>
<p>　　当程序请求<span
class="math inline">\(k\)</span>字节的块时，分配器会搜索满足请求的空闲块，搜索方式由<strong>放置策略</strong>决定。常见的策略包括<strong>首次适配</strong>、<strong>下次适配</strong>和<strong>最佳适配</strong>。首次适配会从头开始搜索空闲链表，选择第1个合适的空闲块。下次适配类似首次适配，但是从上一次查询结束的地方开始搜索。最佳适配会检查每个空闲块并选择合适的最小空闲块。</p>
<p>　　●
首次适配的优点是趋向于将大的空闲块保留在链表的后面，缺点是趋向于在链表的前面留下小碎片，这增加了对较大块的搜索时间。</p>
<p>　　● 下次适配由Donald Knuth作为首次适配的替代而提出
(若上次在一些空闲块中已发现了匹配项，则下次很可能在剩余块中发现匹配项)。下次适配明显比首次适配更快，尤其是链表的前面布满很多小碎片时。但是，一些研究表明，下次适配的内存利用率比首次适配低很多。</p>
<p>　　●
最佳适配的内存利用率比首次适配和下次适配的更高。但是，对于隐式空闲链表等简单空闲链表，最佳适配需要对堆进行彻底的搜索。</p>
<p>　　在找到匹配的空闲块后，必须使用另一个策略决定从该空闲块中分配的空间。选择之一是直接使用整个空闲块，但这会导致内部碎片。若放置策略倾向于选择最佳的匹配项，则由此导致的内部碎片是可以接受的；若相反，则会导致分配器将空闲块分为2部分，第1部分作为已分配的块，第2部分作为新的空闲块。</p>
<p>　　若分配器无法为请求找到合适的块，解决方法之一就是合并内存中物理上相邻的空闲块来生成更大的空闲块，若这样仍然无法生成足够大的块或空闲块已最大程度地合并，则分配器会通过调用函数<code>sbrk()</code>来向内核请求额外的堆内存，然后将额外的内存转换为大的空闲块并插入空闲链表，最后在新的空闲块中分配请求的块。</p>
<p>　　当分配器释放已分配的块时，可能有其他空闲块与这个新释放的块相邻。这些相邻的空闲块可能导致<strong>假碎片</strong>，即有很多可用的空闲块被分割为小到无法使用的空闲块。</p>
<h4 id="合并空闲块">9.7.4 合并空闲块</h4>
<p>　　为了解决假碎片的问题，分配器必须合并相邻的空闲块，这个过程称为<strong>合并</strong>。分配器可以选择<strong>立即合并</strong>，即每次释放块时，就立即合并所有相邻的空闲块。立即合并可以在常数时间内完成，但对于某些请求模式，立即合并会导致抖动，即块会反复地合并再分割。分配器也可以选择<strong>延迟合并</strong>，即等待一段时间后再合并空闲块，例如，分配器可以将合并推迟到某些分配请求失败时，然后扫描整个堆并合并空闲块。</p>
<p>　　假设待释放的块为<span
style="background-color: yellow">当前块</span>，合并当前块的下一个块很简单，由于当前块的首部指向下一个块的首部，只需检查当前块的首部就能判断下一个块是否空闲。若下一个块为空闲块，则将它的大小直接加到当前块的大小上，这2个块会在常数时间内合并。合并当前块的前一个块更复杂，对于隐式空闲链表，需要搜索整个链表来获取前一个块的位置，所以每次调用函数<code>free()</code>需要的时间与堆的大小呈线性关系。即使使用更复杂的空闲链表组织，搜索时间也不会是常数。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/format_of_a_heap_block_with_a_boundary_tag.svg" class="">
<p>　　Donald
Knuth提出了<strong>边界标记</strong>，可以在常数时间内将当前块与前一个块合并。基本思想是在每个块的结尾添加<strong>脚部</strong>
(即边界标记)，脚部是首部的副本。分配器可以通过检查前一个块的脚部来确定其起始处和分配状态。</p>
<p>　　边界标记有1个潜在的缺点，就是要求每个块都有首部和脚部，在程序运行较长时间后，会显著增加内存开销。例如，某个图像应用通过反复调用函数<code>malloc()</code>和<code>free()</code>来动态地创建和释放图形节点且每个图像节点都是2个字，那么首部和脚部将占用每个已分配的块的一半空间。解决方法就是<span
style="background-color: yellow">已分配的块不添加脚部</span>，因为只有相邻的块都是空闲块时，才能合并
(才需要使用脚部)。</p>
<h4 id="实现简单的分配器">9.7.5 实现简单的分配器</h4>
<p>　　这里将实现基于隐式空闲链表和边界标记的简单分配器。此外，块的最大值为<span
class="math inline">\(2^{32}=4\)</span>GB。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* memlib.c (内存系统模型) */</span></span><br><span class="line"><span class="comment">/* 私有全局变量 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_heap;     <span class="comment">/* 指向堆的第1个字节的指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_brk;      <span class="comment">/* 指向堆的最后1个字节加1的指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_max_addr; <span class="comment">/* 堆的最大地址加1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化内存系统模型</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    mem_heap = (<span class="type">char</span> *)Malloc(MAX_HEAP);</span><br><span class="line">    mem_brk = (<span class="type">char</span> *)mem_heap;</span><br><span class="line">    mem_max_addr = (<span class="type">char</span> *)(mem_heap + MAX_HEAP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数sbrk的简单模型，将堆扩展incr字节并返回新区域的起始地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param incr 堆扩展的字节数 (不能为负)</span></span><br><span class="line"><span class="comment"> * @return void* 新区域的起始地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mem_sbrk</span><span class="params">(<span class="type">int</span> incr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *old_brk = mem_brk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span>) || ((mem_brk + incr) &gt; mem_max_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR: mem_sbrk failed. Ran out of memory...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mem_brk += incr;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)old_brk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<code>memlib.c</code>提供的内存系统模型的目的是允许在不干涉系统层malloc包的情况下运行分配器。</p>
<p>　　函数<code>mem_init()</code>会将堆可用的虚拟内存建模为双字对齐的字节数组。<code>mem_heap</code>和<code>mem_brk</code>之间的字节表示已分配的虚拟内存。<code>mem_brk</code>后的字节表示未分配的虚拟内存。分配器通过调用函数<code>mem_sbrk()</code>来请求额外的堆内存，该函数与函数<code>sbrk()</code>的接口相同且语义也相同，唯一区别是函数<code>mem_sbrk()</code>会拒接收缩堆的请求。</p>
<p>　　分配器在源文件<code>mm.c</code>中，用户可以编译和链接该源文件到指定的程序中。分配器输出以下3个函数到程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">mm_init</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>mm_init()</code>会初始化分配器，若成功，则返回0；若出错，则返回-1。函数<code>mm_malloc()</code>和<code>mm_free()</code>与对应的系统级函数有相同的接口和语义。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/invariant_form_of_the_implicit_free_list.svg" class="">
<p>　　分配器使用的是带有边界标记的堆块。<span
style="background-color: yellow">块的最小值为16B</span>。空闲链表组织为隐式空闲链表。第1个字是用于双字对齐的
(未使用)
填充字。填充字后是<strong>序言块</strong>，这是8B的已分配的块，仅由首部和脚部组成。序言块在初始化时创建且永不释放。序言块后是若干个通过调用函数<code>malloc()</code>和<code>free()</code>得到的普通块。堆总是以<strong>结尾块</strong>结尾，这个块是0B的已分配的块，仅由首部组成。序言块和结尾块用于合并时消除边界条件。分配器使用私有全局变量<code>heap_listp</code>指向序言块
(作为优化，可以将其指向序言块的下一个块)。</p>
<h5 id="操作空闲链表的基本常数和宏">9.7.5.1
操作空闲链表的基本常数和宏</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/* 基本常量和宏 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4             <span class="comment">/* 字、首部和脚部的大小 (字节) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8             <span class="comment">/* 双字的大小 (字节) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12) <span class="comment">/* 堆扩展时扩展部分的大小 (字节) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将大小字段和分配状态标志位打包成1个字 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读写地址p处的字 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读地址p的大小字段和分配状态标志位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; -0x7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取块指针bp指向的块的首部和脚部的地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取块指针bp指向的块的后继块和前驱块的地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br></pre></td></tr></table></figure>
<p>　　第3~5行是分配器会使用的基本参数和宏：字的大小<code>WSIZE</code>、双字的大小<code>DSIZE</code>以及初始块和堆扩展时扩展部分的大小<code>CHUNKSIZE</code>。</p>
<p>　　第10行的宏<code>PACK</code>会将大小字段和分配状态标志位结合起来并返回，可以用于赋值给首部和脚部。</p>
<p>　　第13行的宏<code>GET</code>会读取并返回参数<code>p</code>指向的字，这里的强制类型转换很重要。参数<code>p</code>是<code>void *</code>类型，不能直接进行间接引用。第14行的宏<code>PUT</code>会将参数<code>val</code>存储在参数<code>p</code>指向的字中。</p>
<p>　　第16~17行的宏<code>GET_SIZE</code>和<code>GET_ALLOC</code>会从地址<code>p</code>处的首部或脚部分配返回大小字段和分配状态标志位。</p>
<p>　　其余的宏都是对<span
style="background-color: yellow">块指针</span><code>bp</code>进行操作，块指针指向有效载荷的第1个字节。对于块指针指向的块，宏<code>HDRP</code>和<code>FTRP</code>分别返回指向的该块的首部和脚部的指针，宏<code>NEXT_BLKP</code>和<code>PREV_BLKP</code>分别返回指向该块的后继块和前驱块的指针。</p>
<h5 id="创建初始空闲链表">9.7.5.2 创建初始空闲链表</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief (私有) 用新空闲块扩展堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param words	扩展的字数</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配偶数个字以保证对齐 */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化空闲块的首部、脚部以及结尾块的首部 */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* 空闲块首部 */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* 空闲块脚部 */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">/* 新结尾块首部 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若相邻的块是空闲块则合并 */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建有1个初始空闲块的堆</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建初始空堆 */</span></span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);                          <span class="comment">/* 用于对齐的填充部分 */</span></span><br><span class="line">    PUT(heap_listp + WSIZE, PACK(DSIZE, <span class="number">1</span>));     <span class="comment">/* 序言块首部 */</span></span><br><span class="line">    PUT(heap_listp + <span class="number">2</span> * WSIZE, PACK(DSIZE, <span class="number">1</span>)); <span class="comment">/* 序言块脚部 */</span></span><br><span class="line">    PUT(heap_listp + <span class="number">3</span> * WSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));     <span class="comment">/* 结尾块首部 */</span></span><br><span class="line">    heap_listp += <span class="number">2</span> * WSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用1个CHUNKSIZE字节的空闲块扩展空堆 */</span></span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在调用函数<code>mm_malloc()</code>或<code>mm_free()</code>前，应用程序必须通过调用函数<code>mm_init()</code>来初始化堆。</p>
<p>　　函数<code>mm_init()</code>会从内存系统获取4个字并初始化它们来创建空的空闲链表
(第37~45行)，然后调用函数<code>extend_heap()</code>。函数<code>extend_heap()</code>会将堆扩展<code>CHUNKSIZE</code>字节并创建初始空闲块。此时，分配器已初始化，可以接收来自应用程序的分配和释放请求。</p>
<p>　　函数<code>extend_heap()</code>会在2种不同的环境中被调用：初始化堆和当<code>mm_malloc()</code>不能找到合适的匹配块时。为了保证对齐，函数<code>extend_heap()</code>会将请求大小向上舍入为最接近的双字的整数倍，然后向内存请求额外的堆空间
(第14~18行)。</p>
<p>　　在第21~26行中，堆开始于双字对齐的边界，每次调用函数<code>heap_extend()</code>都返回大小是双字的整数倍的块。因此，每次调用函数<code>mem_sbrk()</code>都会返回双字对齐的内存片，紧跟在结尾块首部后面。结尾块首部会变为新空闲块的首部
(第21行) 且该片的最后1个字变为新的结尾块首部
(第23行)。最后，因为可能出现相邻的块都是空闲块的情况，所以调用函数<code>coalesce()</code>来合并空闲块，该函数会返回指向合并后的块的块指针
(第26行)。</p>
<h5 id="释放和合并块">9.7.5.3 释放和合并块</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过边界标记将指定的空闲块和所有相邻的空闲块合并</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bp 指向空闲块的块指针</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放块并进行合并</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bp 块指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　应用程序可以通过调用函数<code>mm_free()</code>来释放块并合并与之相邻的空闲块。函数<code>coalesce()</code>会合并空闲块。</p>
<h5 id="分配块">9.7.5.4 分配块</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mm.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief (私有) 首次适配搜索</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param asize 块大小</span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *bp;</span><br><span class="line">    <span class="keyword">for</span> (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp))))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief (私有) 放置块，当剩余部分不小于16B时进行分割</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param bp 块指针</span></span><br><span class="line"><span class="comment"> * @param asize 块大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= (<span class="number">2</span> * DSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从空闲链表分配块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size 分配的块的大小</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="type">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略空请求 */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调整块大小 */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        asize = DSIZE * ((size + <span class="number">2</span> * DSIZE - <span class="number">1</span>) / DSIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 寻找合适的空闲块 */</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若找不到合适的空闲块，则分配更多的空间来满足请求 */</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　应用程序可以调用函数<code>mm_malloc()</code>来向内存请求<code>size</code>字节的块。在检查请求是否为空后，分配器必须调整请求块的大小来为首部和脚部保留空间并保证双字对齐。第64~67行保证块最少有16B，其中8B用于对齐，另外8B用于存储首部和脚部。对于超过8B的请求，会加上开销字节并向上舍入到最接近的8的整数倍
(第70行)。</p>
<p>　　分配器调整了块大小后，会搜索空闲链表来寻找合适的空闲块
(第74行)。若有合适的块，则分配器会为请求块分配空间并可选地分割出多余的部分
(第76行)，然后返回指向新分配的块的指针；若没有合适的块，则用新空闲块来扩展堆
(第81~85行) 并可选地分割这个块
(第86行)，然后返回指向新分配的块的指针。</p>
<h4 id="显式空闲链表">9.7.6 显式空闲链表</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/format_of_heap_blocks_that_use_doubly_linked_free_lists.svg" class="">
<p>　　对于隐式空闲链表，块分配与堆块的数量呈线性关系，所以这种结构不合适通用分配器。更好的方法是将空闲块组织为某种形式的<strong>显式空闲链表</strong>。空闲块不需要有效载荷，所以实现显式空闲链表的指针可以存储在空闲块的有效载荷中。例如，堆可以组织成双向空闲链表，每个空闲块中到包含前驱和后继指针。</p>
<p>　　使用双向链表，可以让首次适配所需的时间从块总数的线性时间减少到空闲块数量的线性时间。不过，释放块所需时间可以是线性的，也可以是常数，这取决于空闲链表中块的排序策略。</p>
<p>　　可以用<span
style="background-color: yellow">先进后出</span>顺序来维护链表，将新释放的块放在链表的开始处。使用LIFO顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放块可以在常数时间内完成，若使用边界标记，则合并也可以在常数时间内完成。也可以用<span
style="background-color: yellow">地址顺序</span>来维护链表，
其中链表的每个块的地址都小于其后继块的地址。在这种情况下，释放块需要线性时间来定位前驱块。但是，用地址顺序的首次适配比LIFO顺序的首次适配有更高的内存利用率。</p>
<p>　　显式链表的缺点是空闲块必须足够大以包含所需的指针、首部和可能的脚部，这就导致了更大的块最小值，也潜在地提高了内部碎片的比例。</p>
<h4 id="分离空闲链表">9.7.7 分离空闲链表</h4>
<p>　　使用单向空闲块链表的分配器需要与空闲块呈线性关系的时间来分配块。可以通过<strong>分离存储</strong>来减少分配时间，即维护多个空闲链表，每个链表中的块有大致相等的大小。常规思路是将所有可能的块大小分成一些等价类，称为<strong>大小类</strong>。有很多方式来定义大小类。</p>
<p>　　可以根据2的幂来划分块大小： <span class="math display">\[
\{1\},\{2\},\{3,4\},\{5\sim8\},...,\{1025\sim2048\},\{2049\sim4096\},\{4097\sim\infty\}
\]</span>
　　也可以将较小的块分配到单独的大小类中，而较大的块按照2的幂分类：
<span class="math display">\[
\{1\},\{2\},\{3\},...,\{1023\},\{1024\},\{1025\sim2048\},\{2049\sim4096\},\{4097\sim\infty\}
\]</span>
　　分配器维护着空闲链表数组，每个大小类1个数组，按照大小升序排列。当分配器需要大小为<span
class="math inline">\(n\)</span>的块时，会搜索对应的空闲链表。若不能找到合适的块，则搜索下一个链表，依此类推。</p>
<p>　　动态存储分配的相关文献描述了数十种分离存储的方法，主要区别在于它们如何定义大小类、何时进行合并、何时向操作系统请求额外的堆内存和是否允许分割等。这里仅介绍<strong>简单分离存储</strong>和<strong>分离适配</strong>。</p>
<h5 id="简单分离存储">9.7.7.1 简单分离存储</h5>
<p>　　对于简单分离存储，每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。例如，某个大小类定义为<span
class="math inline">\(\{17\sim32\}\)</span>，则这个类的空闲链表全由大小为32的块组成。</p>
<p>　　为了分配指定大小的块，需要检查相应的空闲链表，若链表非空，则分配其中第1块的全部，空闲块不会分割以满足分配请求；若链表为空，则分配器向操作系统请求固定大小的额外内存片
(通常是页大小的整数倍)，将这个片分成大小相等的块并将这些块链接起来形成新的空闲链表。对于释放块，分配器只需将这个块插入到对应的空闲链表的前部。</p>
<p>　　简单分离存储的优点很多。分配和释放块都能在很快的常数时间内完成，而且每个片中的块都大小相等，不分割，不合并，这意味着每个块只有很少的内存开销。由于每个片中的块都大小相等，则已分配的块的大小能从它的地址中推断出来。因为没有合并，所以已分配的块的首部不需要分配状态标志位，即已分配的块不需要首部，而且也不需要脚部。因为分配和释放操作都是在空闲链表的起始处操作，所以链表只需要是单向的。每个空闲块都需要的字段是1个字的后继指针，所以块的最小值就是1个字。</p>
<p>　　简单分离存储的缺点是很容易产生碎片。因为不会分割空闲块，所以可能产生内部碎片。由于不会合并空闲块，某些引用模式会产生很多的外部碎片。例如，应用程序先向第1个大小类发送大量的分配和释放请求，然后向第2个大小类发送大量的分配和释放请求，然后向第3个大小类发送大量的分配和释放请求，依此类推。对于每个大小类，分配器会向操作系统请求大量永远不会回收的内存，因为不会合并空闲块，应用程序不再请求大小类的块后，该大小类的块将不再被使用。</p>
<h5 id="分离适配">9.7.7.2 分离适配</h5>
<p>　　对于分离适配，分配器维护着空闲链表的数组。每个空闲链表都与1个大小类关联且被组织为某种类型的显式或隐式链表。每个链表包含潜在的大小不同的块，这些块的大小是大小类的成员。有多种不同的分离适配器，这里只介绍比较简单的版本。</p>
<p>　　为了分配块，必须确定请求的大小类，对适当的空闲链表进行首次适配来查找合适的块。若找到合适的块，则可选地分割并将剩余部分插入到合适的空闲链表中；若找不到合适的块，则搜索下一个更大的大小类的空闲链表，依此类推，直到找到合适的块。若空闲链表中没有合适的块，则向操作系统请求额外的堆内存，从这个新的堆内存中分配块，将剩余部分插入到合适的空闲链表中。对于释放块，需要合并并将结果插入到合适的空闲链表中。</p>
<p>　　分离适配是很多分配器的常用选择，C中的malloc包就使用这种方法，因为这种方法既快速，又有较高的内存利用率。搜索时间减少了，因为搜索限定在堆的某个部分而非整个堆。内存利用率提高了，因为对分离空闲链表的首次适配搜索的内存利用率近似于对整个堆的最佳适配搜索的内存利用率。</p>
<p>　　<strong>伙伴系统</strong>就是分离适配的特例之一，其中每个大小类都是2的幂。基本思路是对于大小是<span
class="math inline">\(2^m\)</span>个字的堆，为每个块大小<span
class="math inline">\(2^k\)</span>维护1个分离空闲链表，其中<span
class="math inline">\(0\leqslant k\leqslant
m\)</span>。请求块向上舍入到最接近的2的幂。开始时，只有1个大小为<span
class="math inline">\(2^m\)</span>个字的空闲块。</p>
<p>　　对于分配大小为<span
class="math inline">\(2^k\)</span>的块，需要找到第1个可用且大小为<span
class="math inline">\(2^j\)</span>的块，其中<span
class="math inline">\(k \leqslant j \leqslant m\)</span>。若<span
class="math inline">\(j=k\)</span>，则直接完成；否则，递归地二分这个块，直到<span
class="math inline">\(j=k\)</span>。在进行分割时，每个剩余的半块
(也称为<strong>伙伴</strong>) 会插入到对应的空闲链表中。释放大小为<span
class="math inline">\(2^k\)</span>的块后，需要一直合并空闲的伙伴，直到碰到已分配的伙伴。</p>
<p>　　通过给定地址和块大小可以计算出它的伙伴的地址，因为两者的地址只有1位不同。例如，大小为32B的块的地址为<span
class="math inline">\(xxx...x00000\)</span>，其伙伴的地址为<span
class="math inline">\(xxx...x10000\)</span>。</p>
<p>　　伙伴系统的优点是快速搜索和快速合并，缺点是块大小是2的幂的要求可能产生大量内部碎片。因此，伙伴系统分配器不适合通用目的应用程序，只适合那些块大小为2的幂的应用程序。</p>
<h3 id="垃圾回收">9.8 垃圾回收</h3>
<p>　　在C中的malloc包等显式分配器中，程序调用函数<code>malloc()</code>和<code>free()</code>来分配和释放堆块。程序需要负责释放所有不再需要的已分配的块。未能释放的已分配的块是常见的编程错误之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">garbage</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)Malloc(<span class="number">15213</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* 数组p此时已成为垃圾 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，在函数<code>garbage()</code>返回前应先释放<code>p</code>，这个块会在程序的生命周期内一直保持已分配状态。</p>
<p>　　<strong>垃圾回收器</strong>是动态存储分配器，它自动释放程序不再需要的已分配的块，这些块称为<strong>垃圾</strong>。自动回收堆内存的过程称为<strong>垃圾回收</strong>。在支持垃圾回收的系统中，程序显式分配堆块，无需显式释放它们。</p>
<p>　　垃圾回收可以追溯到John
McCarthy于20世纪60年代早期在MIT开发的Lisp系统，它是Java、ML、Perl和Mathematica等现代语言系统中的重要部分之一，而且它仍然是重要且活跃的研究领域之一。相关文献描述了大量的垃圾回收方法，这里仅介绍John
McCarthy独创的标记-清除算法。</p>
<p><img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/garbage_collector's_view_of_memory_as_a_directed_graph.svg" class=""></p>
<p>　　如图所示，垃圾回收器将内存视为<span
style="background-color: yellow">有向可达图</span>。该图的节点分为<strong>根节点</strong>和<strong>堆节点</strong>。堆节点对应堆中已分配的块。有向边<span
class="math inline">\(p \rightarrow q\)</span>表示块<span
class="math inline">\(p\)</span>中的某个位置指向块<span
class="math inline">\(q\)</span>中的某个位置。根节点对应那些不在堆中且包含指向堆的指针的位置，这些位置可以是寄存器、栈里的变量或虚拟内存中读写数据区域中的全局变量。</p>
<p>　　当存在任意1条从根节点出发并到达<span
class="math inline">\(p\)</span>的有向路径时，则节点<span
class="math inline">\(p\)</span>是<span
style="background-color: yellow">可达</span>的。不可达的节点对应垃圾，是不能再次为程序所用。垃圾回收器负责维护可达图的某种表示，通过释放不可达的节点并将其返回给空闲链表来定期回收垃圾。</p>
<p>　　ML和Java等语言的垃圾回收器对程序如何创建和使用指针有严格的控制，可以维护可达图的精确表示，从而可以回收所有垃圾。C和C++等语言通常不能维护可达图的精确表示，这样的回收器也称为<strong>保守式垃圾回收器</strong>。保守式垃圾回收器是保守的，因为每个可达的节点都会被标记为可达，而一些不可达的节点也会被标记为可达。</p>
<p>　　回收器可以按需提供服务，也可以作为和应用程序并行的独立线程来不断地更新可达图和回收垃圾。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/integrating_a_conservative_garbage_collector_and_a_c_malloc_package.svg" class="">
<p>　　将保守式垃圾回收器加入到C的malloc包后，当需要堆空间时，应用程序会用常规方式调用函数<code>malloc()</code>。若函数<code>malloc()</code>找不到合适的块，则调用垃圾回收器来回收一些垃圾到空闲链表。回收器识别垃圾块并通过调用函数<code>free()</code>来将它们返回给堆。关键思想是回收器代替应用程序去调用函数<code>free()</code>。当从回收器返回时，函数<code>malloc()</code>重新寻找合适的块。若仍然找不到，则会向操作系统请求内存。最后，函数<code>malloc()</code>返回指向请求块的指针
(若成功) 或空指针 (若失败)。</p>
<h4 id="标记-清除垃圾回收器">9.8.1 标记-清除垃圾回收器</h4>
<p>　　标记-清除垃圾回收器包括<span
style="background-color: yellow">标记阶段</span>和<span
style="background-color: yellow">清除阶段</span>。标记阶段标记出所有根节点可达且已分配的节点，随后的清除阶段释放每个未被标记且已分配的节点。块首部中空闲的低位中的1位通常用于表示这个块是否被标记。</p>
<p>　　这里对标记-清除的描述会假设使用以下函数
(其中<code>ptr</code>定义为<code>typedef void *ptr</code>) ：</p>
<p>　　●
<code>ptr isPtr(ptr p)</code>会判断<code>p</code>是否指向已分配的块的某个字。若是，则返回指向该块的起始处的指针<code>b</code>；否则，返回<code>NULL</code>。</p>
<p>　　●
<code>int blockMarked(ptr b)</code>会判断<code>b</code>是否被标记。若是，则返回<code>true</code>。</p>
<p>　　●
<code>int blockAllocated(ptr b)</code>会判断<code>b</code>是否已分配。若是，则返回<code>true</code>。</p>
<p>　　● <code>void markBlock(ptr b)</code>会标记块<code>b</code>。</p>
<p>　　● <code>int length(b)</code>会返回块<code>b</code>的长度
(不包括首部)，单位是字。</p>
<p>　　●
<code>void unmarkBlock(ptr b)</code>会取消块<code>b</code>的标记。</p>
<p>　　●
<code>ptr nextBlock(ptr b)</code>会返回堆中块<code>b</code>的后继块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 伪代码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mark</span><span class="params">(ptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((b = isPtr(p)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blockMarked(b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    markBlock(b);</span><br><span class="line">    len = lenght(b);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mark(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sweep</span><span class="params">(ptr b, ptr end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (b &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (blockMarked(b))</span><br><span class="line">        &#123;</span><br><span class="line">            unmarkBlock(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bloackAllocated(b))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        b = nextBlock(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　标记阶段会为每个根节点调用1次函数<code>mark()</code>。若<code>p</code>不指向已分配且未标记的堆块，则函数<code>mark()</code>立即返回；否则，它会标记该块并对块中的每个字递归地调用自己。每次调用函数<code>mark()</code>都会标记某个根节点的所有未标记且可达的后继节点。在标记阶段的最后，任何未标记且已分配的块被认为是不可达的
(即垃圾)，会在清除阶段被回收。</p>
<p>　　清除阶段会调用1次函数<code>sweep()</code>。函数<code>sweep()</code>会进行循环，释放遇到的所有未标记且已分配的块。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_09/mark&sweep_example.svg" class="">
<p>　　在这个示例中，块边界用粗线表示。每个方块对应内存中的1个字。每个块都有1个字的首部，要么是未标记的，要么是已标记的。开始时，堆中有6个未标记且已分配的块。块3包含指向块1的指针。块4包含指向块3和块6的指针。根节点指向块4，所以在标记阶段后，块1、块3、块4和块6会被标记
(可达)，块2和块5不会被标记
(不可达)。在清除阶段后，块2和块5会被回收到空闲链表。</p>
<h4 id="c程序的保守式标记-清除">9.8.2 C程序的保守式标记-清除</h4>
<p>　　标记-清除看似适合C程序的垃圾回收，因为它可以直接工作，而无需移动任何块。但是，C在实现函数<code>isPtr()</code>时会遇到一些问题。首先，C不会用任何信息来标记内存位置，所以无法判断函数<code>isPtr()</code>的入参<code>p</code>是否是指针。其次，即使知道<code>p</code>是指针，也无法判断<code>p</code>是否指向某个已分配的块的有效载荷中的某个位置。</p>
<p>　　对于第1个问题的解决方法是将已分配的块集合维护成平衡二叉树，该树的左子树中的所有块必须放在较小的地址处，右子树中的所有块放在较大的地址处。这需要在每个已分配的块的首部加入<code>left</code>和<code>right</code>字段，这2个字段指向某个已分配的块的首部。函数<code>isPtr(ptr p)</code>通过树来对已分配的块进行二分查找，每次通过首部的大小字段来判断<code>p</code>是否在这个块的范围内。</p>
<p>　　平衡二叉树会标记所有根节点可达的节点，这是必要的保证，因为应用程序的用户当然不会想过早地把已分配的块返回给空闲链表。然后，这种方法从某种意义上是保守的，因为它可能不正确地标记了实际不可达的块，所以它可能不会释放某些垃圾。</p>
<p>　　C程序的标记-清除必须是保守的，其根本原因在于C不会用任何信息来标记内存位置。因此，<code>int</code>和<code>float</code>等标量可以伪装成指针。例如，若某个可达的已分配的块的有效载荷中包含1个<code>int</code>，其值碰巧对应某个其他已分配的块<code>b</code>的有效载荷中的某个地址。对回收器而言，无法判断这个数据是<code>int</code>还是指针。因此，分配器必须保守地将块<code>b</code>标记为可达。</p>
<h3 id="c程序中常见的内存相关错误">9.9 C程序中常见的内存相关错误</h3>
<p>　　对于C程序员，管理和使用虚拟内存可能是困难且容易出错的，因为内存相关错误经常在时间和空间上与错误源有一段距离后才表现出来。</p>
<h4 id="间接使用坏指针">9.9.1 间接使用坏指针</h4>
<p>　　在进程的虚拟地址空间中有较大的空区域，没有映射到任何有意义的数据，若试图间接引用指向该区域的指针，则操作系统会以段故障中止程序。此外，虚拟内存的某些区域是只读，若试图写这些区域，则会以保护故障中止程序。</p>
<p>　　函数<code>scanf()</code>错误是间接引用坏指针的经典错误之一。若需要通过函数<code>scanf()</code>从<code>stdin</code>读整数到变量。正确的方法是将传递给函数<code>scanf()</code>格式串和<span
style="background-color: yellow">变量的地址</span>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br></pre></td></tr></table></figure>
<p>　　但有时，很容传递<code>val</code>而非其地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, val);</span><br></pre></td></tr></table></figure>
<p>　　在这种情况下，函数<code>scanf()</code>会将<code>val</code>的值解释为地址并试图写该地址。在最好的情况下，程序会立即以异常中止。在最差的情况下，<code>val</code>的值刚好对应虚拟内存中的某个可读写区域，于是就会覆盖该区域的值，这通常会在一段时间才会造成严重后果。</p>
<h4 id="读未初始化的内存">9.9.2 读未初始化的内存</h4>
<p>　　虽然<code>bss</code>区域总是被加载器初始化为0，但是堆内存却不是这样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">matvec</span><span class="params">(<span class="type">int</span> **A, <span class="type">int</span> *x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> *y = (<span class="type">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            y[i] += A[i][j] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，会错误地假设数组<code>y</code>被初始化为0。正确的实现方式是显式地将<code>y[i]</code>设置为0或使用函数<code>calloc()</code>。</p>
<h4 id="栈缓冲区溢出">9.9.3 栈缓冲区溢出</h4>
<p>　　在不检查输入字符串的长度情况下，直接将其写到栈的目标缓冲区会导致<span
style="background-color: yellow">缓冲区溢出</span>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bufoverflow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，函数<code>gets()</code>会复制任意长度的字符串到缓冲区，这会导致缓冲区溢出，应使用函数<code>fgets()</code>，该函数会限制输入字符串的长度。</p>
<h4 id="假设指针与其指向的对象大小相同">9.9.4
假设指针与其指向的对象大小相同</h4>
<p>　　假设指针与其指向的对象大小相同是常见的错误之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **<span class="title function_">markArray1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> **A = (<span class="type">int</span> **)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = (<span class="type">int</span> *)Malloc(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会创建包含<code>n</code>个指针的数组，其中的每个指针都指向包含<code>m</code>个<code>int</code>的数组。但在第4行中，实际创建的是<code>int</code>数组。</p>
<p>　　这个示例在<code>int</code>长度和指针长度相同的机器上可以正常运行，但在Core
i7等指针长度大于<code>int</code>长度的机器上运行会导致第5~8行的循环越界。因为这些字中的某个字很可能是已分配的块的脚部，所以这个错误不会立即出现，直到之后释放该块时，此时，分配器的合并会出错且没有任何明显的原因。这也是
"在远处起作用" 的示例，这类 "在远处起作用" 通常与内存相关错误有关。</p>
<h4 id="相差1错误">9.9.5 相差1错误</h4>
<p>　　<strong>相差1</strong>错误是另一种常见的导致覆盖错误的原因。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **<span class="title function_">markArray2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> **A = (<span class="type">int</span> **)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会创建包含<code>n</code>个指针的数组，其中的每个指针都指向包含<code>m</code>个<code>int</code>的数组。第5~8行会试图初始化该数组的<code>n + 1</code>个元素，这个过程会覆盖数组后面的某个内存位置。</p>
<h4 id="引用指针而非其指向的对象">9.9.6 引用指针而非其指向的对象</h4>
<p>　　若不太注意C操作符的优先级和结合性，可能会错误地将指针作为指针指向的内容来操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">binheapDelete</span><span class="params">(<span class="type">int</span> **binheap, <span class="type">int</span> *size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *packet = binheap[<span class="number">0</span>];</span><br><span class="line">    binheap[<span class="number">0</span>] = binheap[*size - <span class="number">1</span>];</span><br><span class="line">    *size--; <span class="comment">/* 这里应该是(*size)-- */</span></span><br><span class="line">    heapify(binheap, *size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> packet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会删除包含<code>*size</code>项的二叉堆里的第1项，然后对剩下的<code>*size - 1</code>项重新建堆。第5行是为了减少<code>size</code>指向的值，但是一元运算符<code>--</code>和<code>*</code>的优先级相同并从右到左关联，所以减少的就是指针的值。若足够幸运，程序会立即中止，但更有可能发生的是程序在运行较长时间后才会产生不正确的结果。</p>
<h4 id="误解指针运算">9.9.7 误解指针运算</h4>
<p>　　忘记了指针的算术操作是以它们指向的对象的大小作为单位来进行是常见错误之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">search</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (*p &amp;&amp; *p != val)</span><br><span class="line">    &#123;</span><br><span class="line">        p += <span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">/* 应该是p++ */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会扫描<code>int</code>数组并返回指向第1个<code>val</code>的指针。第5行中会把指针加4，就导致函数会错误地扫描数组中的每4个整数。</p>
<h4 id="引用不存在的变量">9.9.8 引用不存在的变量</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">stackref</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">return</span> &amp;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会返回指针，该指针指向随后会弹出栈帧的局部变量。尽管<code>p</code>指向合法的内存地址，但已经不再指向合法的变量。当之后程序调用其他函数时，函数<code>stackref()</code>原本的栈帧会被重用来作为其他函数的栈帧。再后来，若程序分配某个值给<code>*p</code>，则可能实际会修改另一个函数的栈帧的某个条目。</p>
<h4 id="引用空闲堆块中的数据">9.9.9 引用空闲堆块中的数据</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">heapref</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *x, *y;</span><br><span class="line">    x = (<span class="type">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    y = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        y[i] = x[i]++; <span class="comment">/* x[i]在空闲块中 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，第5行分配了整数数组<code>x</code>，在第7行释放了<code>x</code>，但又在第11行引用<code>x</code>，此时，<code>x</code>可能是某个已分配的块的一部分，一段时间后，<code>y</code>的值有问题才会显现出来。</p>
<h4 id="内存泄漏">9.9.10 内存泄漏</h4>
<p>　　内存泄漏是缓慢且隐性的问题，当忘记释放已分配的块时，就会出现这个问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *x = (<span class="type">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　若某个程序经常调用该示例，则堆里会有很多垃圾，在最差的情况下，会占用整个虚拟地址空间。对于守护进程和服务器等程序，内存泄漏是很严重的问题，因为这类程序通常不会终止。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第7章 链接</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_07/</url>
    <content><![CDATA[<p>　　<strong>链接</strong>是收集各种代码和数据并组合成单一文件的过程，合成的文件可以被加载
(复制)
到内存并执行。链接可以在编译时执行，即将源码转换为机器码时；也可以在加载时执行，即使用加载器将程序加载到内存并执行时；也可以在运行时执行，即由应用程序来执行。在早期计算机系统中，链接需要手动执行。在现代计算机系统中，链接由称为<strong>链接器</strong>的程序自动执行。</p>
<p>　　链接器使得程序能够<strong>分离编译</strong>，这样可以将大型程序拆解为更小且更易于管理的模块，这些模块可以单独修改和编译。当修改模块后，只需重新编译并链接该模块，无需编译其他模块。</p>
<p>　　<strong>目标模块</strong>是字节序列，<strong>目标文件</strong>是以文件形式存储在磁盘中的目标模块。目标文件按类型分为<span
style="background-color: yellow">可重定位目标文件</span>、<span
style="background-color: yellow">可执行 (目标) 文件</span>和<span
style="background-color: yellow">共享目标文件</span>。共享目标文件是特殊的可重定位目标文件，可以在加载或运行时动态地加载到内存并链接。</p>
<p>　　不同系统的<strong>目标文件格式</strong>不同。诞生于贝尔实验室的第1个UNIX系统使用的是<code>a.out</code>格式。如今，可执行文件仍然称为<code>a.out</code>文件。Windows使用的是<strong>可移植可执行</strong>
(PE) 格式。Mac
OS-X使用的是Mach-O格式。现代Linux和UNIX系统使用的是<strong>可执行与可链接格式</strong>
(ELF)。</p>
<p>　　Linux
LD等<strong>静态链接器</strong>以1组可重定位目标文件和命令行参数作为输入，输出为可以加载和运行的完全链接的可执行文件。输入的可重定位目标文件由各种不同的代码和<strong>数据节</strong>组成，每个数据节都是连续的字节序列。指令占1节，已初始化的全局变量占1节，未初始化的变量占1节。</p>
<p>　　为了生成可执行文件，链接器必须进行<strong>符号解析</strong>和<strong>重定位</strong>。</p>
<p>　　●
目标文件定义和引用符号，每个符号都对应1个函数或1个全局变量或1个静态变量
(C中关键字<code>static</code>声明的变量)。符号解析将每个符号引用和对应的符号定义关联。</p>
<p>　　●
编译器和汇编器生成从地址0开始的代码和数据节。链接器把每个符号定义和1个内存位置关联，然后修改所有对这些符号的引用，使得它们指向对应的内存位置，这个过程就是重定位。链接器使用汇编器生成的<strong>重定位条目</strong>的详细指令来执行重定位。</p>
<p>　　C++和Java都允许重载方法，即函数名相同但参数列表不同，因为编译器将每个唯一的方法和参数列表组合编码为<span
style="background-color: yellow">对链接器唯一</span>的名称。这种编码过程称为<strong>倾轧</strong>，相反的过程称为<strong>还原</strong>。</p>
<p>　　C++和Java使用兼容的倾轧策略，倾轧过的类名由名称的字符数加上名称构成。例如，类<code>Foo</code>编码为<code>3Foo</code>。函数编码为函数名加上<code>_</code>，再加上倾轧过的类名，最后加上每个参数的类型的首字母。例如，函数<code>Foo::bar(int, long)</code>编码为<code>bar__3Fooil</code>。倾轧全局变量和模板名称的方法与之类似。</p>
<span id="more"></span>
<p>　　Linux中有很多工具可以用于理解和处理目标文件。GNU
binutils包就是其中之一，它可以运行在每个Linux平台上。</p>
<p>　　● AR：创建静态库，插入、删除、列出和提取成员。</p>
<p>　　● STRINGS：列出目标文件中所有可打印的字符串。</p>
<p>　　● STRIP：删除目标文件中的符号表信息。</p>
<p>　　● NM：列出目标文件中符号表中定义的符号。</p>
<p>　　● SIZE：列出目标文件中节的名称和大小。</p>
<p>　　● READELF：显示目标文件的完整结构，包含SIZE和NM的功能。</p>
<p>　　●
OBJDUMP：显示目标文件的所有信息。最大的作用是反汇编<code>.text</code>节中的二进制指令。</p>
<p>　　● LDD：列出可执行文件在运行时所需的共享库。</p>
<h3 id="编译器驱动程序">7.1 编译器驱动程序</h3>
<p>　　大多数编译系统提供<strong>编译器驱动程序</strong>，在需要时代表用户调用预处理器、编译器、汇编器和链接器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sum.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　编译以上源程序可以通过以下命令来调用gcc驱动程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Og -o prog main.c sum.c</span></span><br></pre></td></tr></table></figure>
<p>　　驱动程序首先运行C预处理器，将源程序<code>main.c</code>转换为ASCII中间文件<code>main.i</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cpp [其他参数] main.c /tmp/main.i</span></span><br></pre></td></tr></table></figure>
<p>　　接下来，驱动程序运行C编译器，将<code>main.i</code>转换为ASCII汇编文件<code>main.s</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ccl /tmp/main.i -Og [其他参数] -o /tmp/main.s</span></span><br></pre></td></tr></table></figure>
<p>　　然后，驱动程序运行汇编器，将<code>main.s</code>转换为可重定位目标文件<code>main.o</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">as [其他参数] -o /tmp/main.o /tmp/main.s</span></span><br></pre></td></tr></table></figure>
<p>　　驱动程序以相同的步骤生成<code>sum.o</code>。最后，它运行链接器，将<code>main.o</code>、<code>sum.o</code>和一些必要的系统目标文件组合起来生成可执行文件<code>prog</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ld -o prog [系统目标文件和参数] /tmp/main.o /tmp/sum.o</span></span><br></pre></td></tr></table></figure>
<p>　　通过以下命令可以执行文件<code>prog</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./prog</span></span><br></pre></td></tr></table></figure>
<p>　　shell调用操作系统中的称为<strong>加载器</strong>的函数，将可执行文件<code>prog</code>中的代码和数据复制到内存，然后将控制权转移给该程序的开头。</p>
<h3 id="可重定位目标文件">7.2 可重定位目标文件</h3>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_07/typical_elf_relocatable_object_file.svg" class="">
<p>　　<strong>ELF首部</strong>以16B的序列开始，该序列描述了生成该文件的系统的字长和字节顺序。ELF首部的剩余部分包含链接器语法分析和解释目标文件所需的信息
(包括ELF首部的大小、目标文件类型、机器类型、节首部表的文件偏移以及节首部表条目的数量和大小)。<strong>节首部表</strong>描述各个节的位置和大小，每个节都对应1个固定大小的条目。</p>
<p>　　在ELF首部和节首部表中间的是节。</p>
<p>　　● <code>.text</code>节存储已编译程序的机器代码。</p>
<p>　　●
<code>.rodata</code>节存储只读数据，例如，函数<code>printf()</code>中的格式串和<code>switch</code>语句中的跳转表。</p>
<p>　　● <code>.data</code>节存储已初始化的C全局和静态变量。</p>
<p>　　●
<code>.bss</code>节存储未初始化和初始化为0的C全局和静态变量。该节只是占位符，并不占用目标文件的空间。目标文件区分变量是否初始化是为了空间效率，未初始化变量不占用实际的磁盘空间，运行时由内存分配空间并赋予初始值0。</p>
<p>　　● <code>.symtab</code>节是符号表，存储程序中定义和引用的<span
style="background-color: yellow">函数和全局变量</span>的信息。每个可重定位目标文件的该节中都有符号表，除非使用命令<code>STRIP</code>去除。</p>
<p>　　●
<code>.rel.text</code>节是<code>.text</code>节中位置的列表，当链接器把该目标文件和其他文件组合时，会修改这些位置。任何调用外部函数和引用全局变量的指令都需要修改。调用本地函数的指令则无需修改。可执行文件中并不需要重定位信息，所以通常忽略，除非用户显式地指示链接器包含这些信息。</p>
<p>　　●
<code>rel.data</code>节存储模块定义和引用的所有全局变量的重定位信息。任何已初始化且初始值是全局变量地址或外部定义函数地址的变量都需要修改。</p>
<p>　　●
<code>.debug</code>节是调试符号表，其条目是程序中定义的局部变量、类型定义、定义/引用的全局变量和原始C源文件。只有使用命令行选项<code>-g</code>时，才会生成该表。</p>
<p>　　●
<code>.line</code>节是原始C源程序中的行号和<code>.text</code>节中机器指令之间的映射。只有使用命令行选项<code>-g</code>时，才会生成该表。</p>
<p>　　●
<code>.strtab</code>节是字符串表，包括<code>.symtab</code>节和<code>.debug</code>节中的符号表以及节首部中的节名称。字符串表是以<code>\0</code>结尾的字符串序列。</p>
<p>　　<code>.bss</code>节的名称源于IBM 704汇编语言 (约1957年)
中块存储开始指令的首字母缩写，并沿用至今。</p>
<h3 id="符号和符号表">7.3 符号和符号表</h3>
<p>　　每个可重定位目标文件<code>m</code>都有1个符号表，该表包含<code>m</code>定义和引用的符号的信息。在链接器的上下文中，有3种不同的符号。</p>
<p>　　● 由模块<code>m</code>定义但由其他模块引用的<span
style="background-color: yellow">全局符号</span>，对应非静态的C函数和全局变量。</p>
<p>　　● 由其他模块定义但由模块<code>m</code>引用的<span
style="background-color: yellow">全局符号</span>，对应其他模块定义的非静态的C函数和全局变量。这种符号是<strong>外部</strong>的。</p>
<p>　　● 只被模块<code>m</code>定义和引用的<span
style="background-color: yellow">局部符号</span>，对应C静态函数和静态全局变量。这些符号仅在模块<code>m</code>中可见，不能被其他模块引用。</p>
<p>　　在C中，源文件对应模块，关键字<code>static</code>可用于隐藏模块内部的变量和函数声明，声明为<code>static</code>的全局变量或函数都是模块私有的。相反，任何不声明为<code>static</code>的全局变量或函数是公有的，可以被其他模块访问。</p>
<p>　　C中的局部变量在运行时由栈管理，与链接器无关。但是，声明为<code>static</code>的局部变量由链接器管理，链接器会为其在<code>.data</code>节或<code>.bss</code>节中分配空间并在符号表中创建1个有唯一名称的局部链接器符号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，2个函数都定义了静态局部变量<code>x</code>，编译器会向汇编器提供2个名称不同的局部链接器符号。例如，用<code>x.1</code>表示函数<code>f()</code>中定义的<code>x</code>，用<code>x.2</code>表示函数<code>g()</code>中定义的<code>x</code>。</p>
<p>　　汇编器根据编译器输出到<code>.s</code>汇编文件的符号来生成符号表。<code>.symtab</code>节中包含ELF符号表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Symbol</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">char</span> type : <span class="number">4</span>, binding : <span class="number">4</span>;</span><br><span class="line">    <span class="type">char</span> reserved;</span><br><span class="line">    <span class="type">short</span> section;</span><br><span class="line">    <span class="type">long</span> value;</span><br><span class="line">    <span class="type">long</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　这是ELF符号表条目的格式，<code>name</code>表示字符串表中的字节偏移，指向符号的以<code>\0</code>结尾的字符串名称。<code>value</code>是符号的地址。对于可重定位的模块，<code>value</code>是到定义目标的节的起始处偏移。对于可执行文件，<code>value</code>是绝对运行时地址。<code>size</code>是目标的大小
(以字节为单位)。<code>type</code>只能是数据或函数。符号表还可以包含各个节的条目和原始源文件的路径名的条目，所以这些目标的类型也有所不同。<code>binding</code>表示符号是局部还是全局。</p>
<p>　　每个符号都被分配到目标文件的某个节，由<code>section</code>表示，它是节首部表的索引。有3个特殊的<span
style="background-color: yellow">伪节</span>，它们在节首部表中没有条目：<code>ABS</code>、<code>UNDEF</code>和<code>COMMON</code>。<code>ABS</code>表示不应该被重定位的符号。<code>UNDEF</code>表示未定义的符号，即本目标模块引用但由其他模块定义的符号。<code>COMMON</code>表示未分配空间的未初始化数据条目。对于<code>COMMON</code>符号，<code>value</code>指明对齐要求，<code>size</code>给出最小值。<span
style="background-color: yellow">只有可重定位目标文件才有伪节</span>，可执行文件没有。</p>
<p>　　<code>COMMON</code>和<code>.bss</code>节有细微差别。gcc会将<span
style="background-color: yellow">未初始化的全局变量</span>分配给<code>COMMON</code>，将未初始化的静态变量和初始化为0的全局/静态变量分配给<code>.bss</code>节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Num:	Value           Size	Type	Bind	Vis 	Ndx	Name</span><br><span class="line">  8: 0000000000000000	  24	FUNC	GLOBAL	DEFAULT   1	main</span><br><span class="line">  9: 0000000000000000	   8	OBJECT	GLOBAL	DEFAULT   3	array</span><br><span class="line"> 10: 0000000000000000	   0	NOTYPE	GLOBAL	DEFAULT UND	sum</span><br></pre></td></tr></table></figure>
<p>　　这个示例是7.1中的<code>main.o</code>的符号表中的最后3个条目。READELF用整数索引来标识每个节。<code>Ndx=1</code>表示<code>.text</code>节，<code>Ndx=3</code>表示<code>.data</code>节。全局符号<code>main</code>定义的条目是<code>.text</code>节中偏移为0处的24B的函数。其后是全局符号<code>array</code>的定义，它是<code>.data</code>节中偏移为0处的8B的目标。最后是对外部符号<code>sum</code>的引用。</p>
<h3 id="符号解析">7.4 符号解析</h3>
<p>　　链接器通过将每个引用和其输入重定位目标文件的符号表中的1个的符号定义关联来解析符号引用。对于那些定义和引用在同一模块的局部符号的引用，符号解析是直接明了的。编译器仅允许模块中每个局部符号有1个定义。编译器还确保有局部链接器符号的静态局部变量有唯一的名称。</p>
<p>　　当编译器遇到不在本模块定义的全局符号时，会假设该符号在其他模块中定义，生成链接器符号表条目并将其交给链接器处理。若链接器在它的所有输入模块中都找不到该符号的定义，就输出错误信息
(通常难以阅读)
并终止。有时多个目标文件可能定义名称相同的全局符号，此时，链接器要么标志错误，要么以某种方法选择1个定义并抛弃其他定位。Linux使用的方法涉及编译器、汇编器和链接器之间的协作。</p>
<h4 id="链接器解析重复的符号名称">7.4.1 链接器解析重复的符号名称</h4>
<p>　　在编译时，编译器会向汇编器提供所有全局符号，汇编器会隐式地把它们编码在可重定位目标文件的符号表中。函数和已初始化的全局变量是<strong>强</strong>符号，未初始化的全局变量是<strong>弱</strong>符号。</p>
<p>　　Linux链接器不允许多个同名的强符号。若1个强符号与多个弱符号同名，则选择强符号。若多个弱符号同名，则随机选择1个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* foo.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> y = <span class="number">15212</span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">15213</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = 0x%x y = 0x%x \n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* bar.c */</span></span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">-0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在x86-64/Linux机器上，<code>double</code>是8B，<code>int</code>是4B。当<code>x</code>和<code>y</code>的地址相邻且<code>x</code>的地址在<code>y</code>之前时，<code>bar.c</code>中第6行代码会用<span
style="background-color: yellow">0的双精度浮点表示</span>覆盖<code>foo.c</code>中定义的<code>x</code>和<code>y</code>，此时只会触发警告。当怀疑出现此类情况时，可以用gcc的<code>-fno-common</code>等命令行参数调用链接器，用于指示链接器遇到重名的全局符号时触发错误。也可以用命令行选项<code>-Werror</code>，将所有的警告变为错误。</p>
<h4 id="链接静态库">7.4.2 链接静态库</h4>
<p>　　用所有相关的目标模块打包成的单个文件称为<strong>静态库</strong>，它可以作为链接器的输入。当链接器生成作为输出的可执行文件时，只会复制静态库中被应用程序引用的的目标模块。</p>
<p>　　若不使用静态库，可以通过<span
style="background-color: yellow">让编译器识别标准函数并生成对应的代码</span>或<span
style="background-color: yellow">将所有标准函数都放在同一可重定位目标文件</span>来使用标准函数。Pascal
(仅提供了小部分标准函数)
使用的方法是前者，但C定义了大量的标准函数，若使用前者会显著增加编译器的复杂性，并且每次增删改标准函数时都需要更新编译器来适配。后者的优点是将编译器的实现和标准函数的实现分离，但需要每个可执行文件都包含1份标准函数集合的副本，并且增删改标准函数会要求库的开发者重新编译整个源文件，其改进方法是为每个标准函数生成独立的可重定位目标文件并把它们放在约定俗成的目录中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ...</span></span><br></pre></td></tr></table></figure>
<p>　　静态库正是为了解决以上问题，相关的函数可以编译为单独的目标模块并封装在单独的静态库文件中。然后，应用程序可以在命令行中指定对应的文件名称来使用这些库中定义的函数。例如，以下命令用于使用了C标准库和数学库中的函数的应用程序编译和链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c /usr/lib/libm.a /usr/lib/libc.a</span></span><br></pre></td></tr></table></figure>
<p>　　实际上，C编译器驱动程序每次都会提供标准库文件<code>libc.a</code>给链接器，这里可以省略。</p>
<p>　　在Linux中，静态库存储为称为<strong>存档</strong>的特殊文件格式，其后缀名为<code>.a</code>。存档文件是1组串联的可重定位目标文件的集合，其首部指明其中每个目标文件的大小和位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* addarray.c */</span></span><br><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addarray</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> *z, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    addcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* multarray.c */</span></span><br><span class="line"><span class="type">int</span> multcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multarray</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> *z, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    multcnt++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        z[i] = x[i] * y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　要创建函数<code>addarray()</code>和<code>multarray()</code>的静态库，可以使用AR工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c addarray.c multarray.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar rcs libarray.a addarray.o multarray.o</span></span><br></pre></td></tr></table></figure>
<p>　　这里在头文件<code>array.h</code>中定义了这2个函数的函数原型。若需要使用这个库，只需要引用该头文件即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;array.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    addarray(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　为了创建可执行文件，需要编译和链接输入文件<code>main.o</code>和<code>libarray.a</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c main.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -static -o prog main.o ./libarray.a</span></span><br></pre></td></tr></table></figure>
<p>　　第2条命令等同于以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -static -o prog main.o -L. -larray</span></span><br></pre></td></tr></table></figure>
<p>　　命令行选项<code>-static</code>指示链接器应生成完全链接的可执行文件，<code>-larray</code>是<code>libarray.a</code>的缩写，<code>-L.</code>指示链接器在当前目录查找<code>libarray.a</code>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_07/linking_with_static_libraries.svg" class="">
<p>　　当链接器运行时，它发现<code>main.o</code>引用了<code>addarray.o</code>中定义的<code>addarray</code>符号，所以它会复制<code>addarray.o</code>到可执行文件。程序并没有引用<code>multarray</code>中定义的任何符号，所以链接器不会复制这个模块。链接器还会复制<code>libc.a</code>中的模块<code>printf.o</code>和运行时系统中的部分模块。</p>
<h4 id="链接器使用静态库解析引用">7.4.3 链接器使用静态库解析引用</h4>
<p>　　在符号解析阶段，链接器<span
style="background-color: yellow">从左到右按照它们在编译器驱动程序命令行上出现的顺序</span>来扫描可重定位目标文件和存档文件
(驱动程序自动将命令行中所有的<code>.c</code>文件转换为<code>.o</code>文件)。在扫描时，链接器会维护可重定位目标文件的集合<span
class="math inline">\(E\)</span>
(该集合中的文件会组合成可执行文件)、未解析的符号集合<span
class="math inline">\(U\)</span> (即引用了但未定义的符号)
和之前输入文件中已定义的符号集合<span
class="math inline">\(D\)</span>。初始时，<span
class="math inline">\(E\)</span>、<span
class="math inline">\(U\)</span>和<span
class="math inline">\(D\)</span>均为空。</p>
<p>　　对于命令行上的每个输入文件<span
class="math inline">\(f\)</span>，链接器会判断<span
class="math inline">\(f\)</span>是目标文件还是存档文件。</p>
<p>　　● 若<span class="math inline">\(f\)</span>是目标文件，则将<span
class="math inline">\(f\)</span>添加到<span
class="math inline">\(E\)</span>，更新<span
class="math inline">\(U\)</span>和<span
class="math inline">\(D\)</span>来表示<span
class="math inline">\(f\)</span>中的符号定义和引用。然后，链接器处理下一个输入文件。</p>
<p>　　● 若<span
class="math inline">\(f\)</span>是存档文件，则链接器尝试匹配<span
class="math inline">\(U\)</span>中未解析的符号和存档文件中的模块定义的符号。若存档文件中的某个模块<span
class="math inline">\(m\)</span>定义了符号解析<span
class="math inline">\(U\)</span>中引用的符号，则将<span
class="math inline">\(m\)</span>添加到<span
class="math inline">\(E\)</span>，修改<span
class="math inline">\(U\)</span>和<span
class="math inline">\(D\)</span>来表示<span
class="math inline">\(m\)</span>中的符号定义和引用。这个过程会一直持续到<span
class="math inline">\(U\)</span>和<span
class="math inline">\(D\)</span>不再发生变化。此时，存档文件中任何不包含在<span
class="math inline">\(E\)</span>的模块将会被丢弃。然后，链接器处理下一个输入文件。</p>
<p>　　当链接器完成对命令行中输入文件的扫描后，若<span
class="math inline">\(U\)</span>非空，则链接器会输出错误并终止；否则，它会合并和重定位<span
class="math inline">\(E\)</span>中的目标文件，生成作为输出的可执行文件。</p>
<p>　　文件出现在命令行的顺序至关重要，所以库一般放在命令行的结尾。若库的各个模块相互独立
(同一库的模块之间没有符号引用)，那么这些模块可以以任何顺序出现在命令行结尾处；相反，若同一库的模块之间存在符号引用，则必须对它们进行排序，保证<span
style="background-color: yellow">至少有1个符号的定义在该符号的引用之后</span>。</p>
<p>　　若<code>foo.c</code>调用了<code>libx.a</code>和<code>libz.a</code>中的函数，而这2个库又调用了<code>liby.a</code>中的符号，则命令行上<code>libx.a</code>和<code>libz.a</code>必须在<code>liby.a</code>之前。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc foo.c libx.a libz.a liby.a</span></span><br></pre></td></tr></table></figure>
<p>　　若<code>foo.c</code>调用了<code>libx.a</code>中的函数，<code>libx.a</code>调用了<code>liby.a</code>中的函数，<code>liby.a</code>调用了<code>libx.a</code>中的函数，则<code>libx.a</code>必须在命令行上重复出现。这种情况下，也可以将<code>libx.a</code>和<code>liby.a</code>合并。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc foo.c libx.a liby.a libx.a</span></span><br></pre></td></tr></table></figure>
<h3 id="重定位">7.5 重定位</h3>
<p>　　链接器完成符号解析后，会把代码的每个符号引用和对应的符号定义
(即它的1个输入目标模块的1个符号表条目)
关联起来。此时，链接器就知道器输入模块中的代码节和数据节的确切大小。然后，就可以进行重定位。重定位分为<span
style="background-color: yellow">重定位节和符号定义</span>以及<span
style="background-color: yellow">重定位节中的符号引用</span>。</p>
<p>　　●
在重定位节和符号定义时，链接器会将所有相同类型的节合并为同一类型的聚合节。例如，将所有输入模块的<code>.data</code>节合并为单个节作为输出
(可执行)
文件的<code>.data</code>节。然后，链接器将运行时内存地址赋值给聚合节以及输入模块定义的所有节和符号。完成后，程序中的所有指令和全局变量都有了唯一的运行时内存地址。</p>
<p>　　●
在重定位节的符号引用时，链接器会修改代码节和数据节中的所有符号引用，保证它们指向正确的运行时地址。完成这一步需要使用可重定位目标模块中的<span
style="background-color: yellow">重定位条目</span>。</p>
<h4 id="重定位条目">7.5.1 重定位条目</h4>
<p>　　当汇编器遇到最终位置未知的引用时，会生成<strong>重定位条目</strong>，用于告诉链接器在用目标文件合成可执行文件时如何修改该引用。代码的重定位条目存储在<code>.rel.text</code>节中，数据的重定位条目存储在<code>.rel.data</code>节中。</p>
<p>　　ELF定义了32种重定位类型，这里只介绍2种最基本的重定位类型：R_X86_64_PC32和R_X86_64_32。前者用于重定位使用<span
style="background-color: yellow">32位PC相对地址</span>的引用，后者用于重定位使用<span
style="background-color: yellow">32位绝对地址</span>的引用。此外，两者都支持x86-64<strong>小型代码模型</strong>，该模型默认可执行文件中的代码和数据的总体大小小于2GB，所以在运行时可以用32位PC相对地址来访问。</p>
<p>　　gcc默认使用小型代码模型，更大的程序可以用<code>-mcmodel=medium</code>
(中型代码模型) 和<code>-mcmodel=large</code> (大型代码模型)
命令行参数来编译。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Rela</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> offset;</span><br><span class="line">    <span class="type">long</span> type : <span class="number">32</span>, symbol : <span class="number">32</span>;</span><br><span class="line">    <span class="type">long</span> addend;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　这是ELF重定位条目的格式。<code>offset</code>是待修改的引用的节偏移。<code>type</code>指示链接器如何修改新引用。<code>symbol</code>标识修改后的引用指向的符号。<code>addend</code>是常数，部分类型的重定位用它来偏置修改后的引用的值。</p>
<h4 id="重定位符号引用">7.5.2 重定位符号引用</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foreach section s </span><br><span class="line">&#123;</span><br><span class="line">    foreach relocation entry r </span><br><span class="line">    &#123;</span><br><span class="line">        refptr = s + r.offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 重定位PC相对 (寻址) 引用 */</span></span><br><span class="line">        <span class="keyword">if</span> (r.type == R_X86_64_PC32)</span><br><span class="line">        &#123;</span><br><span class="line">            refaddr = ADDR(s) + r.offset; <span class="comment">/* 引用的运行时地址 */</span></span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(ADDR(r.symbol) + r.addend - refaddr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 重定位绝对 (寻找) 引用 */</span></span><br><span class="line">        <span class="keyword">if</span> (r.type == R_X86_64_32)</span><br><span class="line">        &#123;</span><br><span class="line">            *refptr = (<span class="type">unsigned</span>)(ADDR(r.symbol) + r.addend);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是链接器重定位算法的伪代码，其中节<code>s</code>是字节数组，重定位条目<code>r</code>是<code>Elf64_Rela</code>结构体。链接器为每个节和符号分配的运行时地址表示为<code>ADDR(s)</code>和<code>ADDR(r.symbol)</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:	48 83 ec 08         sub     $0x8, %rsp</span><br><span class="line">   4:	be 02 00 00 00      mov     $0x2, %esi</span><br><span class="line">   9:	bf 00 00 00 00      mov     $0x0, %edi</span><br><span class="line">                        a: R_X86_64_32 array</span><br><span class="line">   e:	e8 00 00 00 00      call    13 &lt;main+0x13&gt;</span><br><span class="line">                        f: R_X86_64_PC32 sum-0x4	</span><br><span class="line">  13:	48 83 c4 08         add     $0x8, %rsp</span><br><span class="line">  17:	c3                  retq</span><br></pre></td></tr></table></figure>
<p>　　这是用OBJDUMP根据7.1中的<code>main.c</code>生成的反汇编代码。主函数引用了2个全局符号：<code>array</code>和<code>sum</code>。汇编器为它们都生成了对应的重定位体条目，显示在引用的后一行
(实际上重定位条目和指令存储在不同的节中，为了方便才将它们显示在一起)。这些重定位条目指示链接器对<code>sum</code>的引用使用32位PC相对地址来重定位，对<code>array</code>的引用使用32位绝对地址来重定位。</p>
<h5 id="重定位pc相对引用">7.5.2.1 重定位PC相对引用</h5>
<p>　　主函数调用了函数<code>sum()</code>，函数<code>sum()</code>是在模块<code>sum.o</code>中定义的。指令<code>call</code>从节偏移<code>0xe</code>处开始，包括1B的操作码<code>0xe8</code>，其后是对目标<code>sum</code>的32位PC相对引用的占位符。对应的重定位条目<code>r</code>由4个字段组成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r.offset = <span class="number">0xf</span>;</span><br><span class="line">r.symbol = sum;</span><br><span class="line">r.type = R_X86_64_PC32;</span><br><span class="line">r.addend = <span class="number">-4</span>;</span><br></pre></td></tr></table></figure>
<p>　　这些字段指示链接器修改偏移量<code>0xf</code>处的32位PC相对引用，这样在运行时它会指向<code>sum</code>例程。此时，假设链接器已经确定：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADDR(s) = ADDR(.text) = <span class="number">0x4004d0</span>;</span><br><span class="line">ADDR(r.symbol) = ADDR(sum) = <span class="number">0x4004e8</span>;</span><br></pre></td></tr></table></figure>
<p>　　使用链接器重定位算法，链接器先计算出引用的运行时地址
(第10行)，得到<code>refaddr = 0x4004df</code>。然后，更新该引用，使其在运行时指向<code>sum</code>
(第11行)，即<code>*refptr = 0x5</code>。在得到的可执行文件中，指令<code>call</code>有如下的重定位形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4004de:	e8 05 00 00 00      callq   4004e8 &lt;sum&gt;</span><br></pre></td></tr></table></figure>
<p>　　在运行时，指令<code>call</code>将存储在地址<code>0x4004de</code>。当CPU执行指令<code>call</code>时，PC的值是<code>0x4004e3</code>，即<code>call</code>的下一条指令的地址。为了执行这条指令，CPU会先将PC压入栈，再将PC值加上<code>0x5</code>得到新PC值。</p>
<h5 id="重定位绝对引用">7.5.2.2 重定位绝对引用</h5>
<p>　　重定位绝对引用更简单。在链接器重定位算法的反汇编代码中的第4行，指令<code>mov</code>将<code>array</code>地址
(32位立即数)
复制到寄存器<code>%edi</code>中。指令<code>mov</code>从节偏移<code>0x9</code>处开始，包括1B的操作码<code>0xbf</code>，其后是<code>array</code>的32位绝对引用的占位符。对应的重定位条目<code>r</code>由4个字段组成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r.offset = <span class="number">0xa</span>;</span><br><span class="line">r.symbol = <span class="built_in">array</span>;</span><br><span class="line">r.type = R_X86_64_32;</span><br><span class="line">r.addend = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>　　这些字段指示链接器要修改偏移量<code>0xa</code>的引用，这样在运行时它会指向<code>array</code>的首字节。此时，假设链接器已经确定：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADDR(r.symbol) = ADDR(<span class="built_in">array</span>) = <span class="number">0x601018</span>;</span><br></pre></td></tr></table></figure>
<p>　　链接器使用重定位算法修改引用，得到<code>*refptr = 0x601018</code>。在得到的可执行文件中，该引用有如下的重定位形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4004d9:	bf 18 10 60 00      mov $0x601018, %edi</span><br></pre></td></tr></table></figure>
<p>　　综上所述，最终可执行文件中已重定位的<code>.text</code>节和<code>.data</code>节如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 已重定位的.text节</span><br><span class="line">00000000004004d0 &lt;main&gt;:</span><br><span class="line">  4004d0:	48 83 ec 08     sub     $0x8, %rsp</span><br><span class="line">  4004d4:	be 02 00 00 00  mov     $0x2, %esi</span><br><span class="line">  4004d9:	bf 18 10 60 00  mov     $0x601018, %edi</span><br><span class="line">  4004de:	e8 05 00 00 00  callq   4004e8 &lt;sum&gt;</span><br><span class="line">  4004e3:	48 83 c4 08     add     $0x8, %rsp</span><br><span class="line">  4004e7:	c3              retq</span><br><span class="line"></span><br><span class="line">00000000004004e8 &lt;sum&gt;:</span><br><span class="line">  4004e8:	b8 00 00 00 00  mov     $0x0, %eax</span><br><span class="line">  4004ed:	ba 00 00 00 00  mov     $0x0, %edx</span><br><span class="line">  4004f2:	eb 09           jmp     4004fd &lt;sum+0x15&gt;</span><br><span class="line">  4004f4:	48 63 ca        movslq  %edx, %rcx</span><br><span class="line">  4004f7:	03 04 8f        add     (%rdi,%rcx,4), %eax</span><br><span class="line">  4004fa:	83 c2 01        add     $0x1, %edx</span><br><span class="line">  4004fd:	39 f2           cmp     %esi, %edx</span><br><span class="line">  4004ff:	7c f3           jl      4004f4 &lt;sum+0xc&gt;</span><br><span class="line">  400501:	f3 c3           repz retq</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 已重定位的.data节</span><br><span class="line">00000000004004e8 &lt;array&gt;:</span><br><span class="line">  601080:	01 00 00 00 02 00 00</span><br></pre></td></tr></table></figure>
<p>　　在加载时，加载器会将这些节中的数据直接复制到内存中，不加修改地执行这些指令。</p>
<h3 id="可执行文件">7.6 可执行文件</h3>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_07/typical_elf_executable_file.svg" class="">
<p>　　可执行文件的格式类似可重定位目标文件，因为可执行文件是完全链接的，所以没有<code>rel</code>节。ELF首部描述文件的总体格式，它还包括程序的<strong>入口点</strong>，即程序运行时执行的首条指令的地址。<code>.init</code>节定义了函数<code>_init()</code>，即程序的初始化函数。<code>.text</code>节、<code>.rodata</code>节和<code>.data</code>节与可重定位目标文件中的相似，区别是这些节已经被重定位到其最终运行时地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 只读代码段</span><br><span class="line">LOAD off	0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**21</span><br><span class="line">	filesz 	0x000000000000069c memsz 0x000000000000069c flags r-x</span><br><span class="line"># 读写代码段</span><br><span class="line">LOAD off	0x0000000000000df8 vaddr 0x0000000000600df8 paddr 0x0000000000600df8 align 2**21</span><br><span class="line">	filesz 	0x0000000000000228 memsz 0x0000000000000230 flags rw-</span><br></pre></td></tr></table></figure>
<p>　　这是可执行文件<code>prog</code>的程序首部表，由OBJDUMP显示。其中<code>off</code>是目标文件的偏移，<code>vaddr</code>和<code>paddr</code>是内存地址，<code>align</code>是对齐要求
(这里<code>2**21</code>表示<span
class="math inline">\(2^{21}\)</span>，即<code>0x200000</code>)，<code>filesz</code>是目标文件中的段大小，<code>memsz</code>是内存中的段大小，<code>flags</code>是运行时访问权限。根据这个程序首部表，有2个内存段将使用可执行文件的内容进行初始化。</p>
<p>　　第1个段 (第2~3行)
是代码段，有读和执行权限，从内存地址<code>0x400000</code>处开始，共占用<code>0x69c</code>字节，并用可执行文件的前<code>0x69c</code>字节初始化，其中包括ELF首部、程序首部表、<code>.init</code>节、<code>.text</code>节和<code>.rodata</code>节。</p>
<p>　　第2个段 (第5~6行)
是数据段，有读和写权限，从内存地址<code>0x600df8</code>处开始，共占用<code>0x230</code>字节，并用可执行文件中偏移量为<code>0xdf8</code>的<code>.data</code>节中的<code>0x228</code>字节初始化前<code>0x228</code>字节，剩下的8字节对应将在运行时初始化为0的<code>.bss</code>节数据。</p>
<p>　　对应任何段<code>s</code>，链接器必须选择起始地址<span
class="math inline">\(vaddr\)</span>，使得 <span class="math display">\[
vaddr\bmod align=off\bmod aligh
\]</span> 　　这里，<span
class="math inline">\(off\)</span>是目标文件中段的第1个节的偏移，<span
class="math inline">\(align\)</span>是程序首部中指定的对齐要求。</p>
<h3 id="加载可执行文件">7.7 加载可执行文件</h3>
<p>　　每个Linux程序都可以调用函数<code>execve()</code>来调用加载器，加载器将可执行文件中的代码和数据从磁盘复制到内存中，然后跳转到程序的入口点来运行程序。这个将程序复制到内存并运行的过程称为<strong>加载</strong>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_07/linux_x86-64_run-time_memory_image.svg" class="">
<p>　　每个Linux程序都有运行时内存映像。在Linux
x86-64系统中，代码段总是从地址<code>0x400000</code>处开始，其后是数据段。运行时堆在数据段之后，通过调用函数<code>malloc()</code>可以向上增长。堆后的区域是为共享库保留。用户级代码地址的最大值是<span
class="math inline">\(2^{48}-1\)</span>，向较小内存地址增长。栈后的区域是内核内存，从地址<span
class="math inline">\(2^{48}\)</span>开始，为<strong>内核</strong>中的代码段和数据保留。</p>
<p>　　由于<code>.data</code>节有对齐要求，所以代码段和数据段之间有间隙
(这里省略了该间隙)。在为栈、共享库和堆分配运行地址时，链接器会使用地址空间布局随机化，每次程序运行时这些区域的地址会改变，但它们的相对位置不变。</p>
<p>　　当加载器运行时，会创建运行时内存映像。在程序首部表的引导下，加载器将可执行文件的片复制到代码段和数据段。然后，加载器跳转到程序的入口点，即函数<code>_start()</code>的地址，该函数定义在系统目标文件<code>ctrl.o</code>中，对所有C程序都相同。函数<code>_start()</code>调用<code>libc.so</code>中定义的<span
style="background-color: yellow">系统启动函数</span><code>__libc_start_main()</code>，它会初始化执行环境，调用用户级函数<code>main()</code>，处理函数<code>main()</code>的返回值并在需要的时候把控制权转移给内核。</p>
<h3 id="动态链接共享库">7.8 动态链接共享库</h3>
<p>　　<strong>动态链接</strong>就是运行/加载时将目标模块加载到内存并和其中的程序链接，该目标模块称为<strong>共享库</strong>或<strong>共享目标</strong>。动态链接由称为<strong>动态链接器</strong>的程序执行，动态链接器本身就是共享库。共享库在Linux和Windows中的后缀分别是<code>.so</code>和<code>.dll</code>。</p>
<p>　　共享库以2种不同的形式共享。首先，在任何给定的文件系统中，1个库<span
style="background-color: yellow">只有1个</span><code>.so</code>文件，所以引用该库的可执行文件共享这个<code>.so</code>文件，而非像静态库的内容那样被复制并嵌入到它们的可执行文件中。其次，在内存中，共享库的<code>.text</code>节的同一副本可以被不同的正在运行的进程共享。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_07/dynamic_linking_with_shared_libraries.svg" class="">
<p>　　这是7.4.2中的示例的动态链接版本。为了生成示例中的数组例程的共享库<code>libarray.so</code>，需要调用编译器驱动程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -shared -fpic -o libarray.so addarray.c multarray.c</span></span><br></pre></td></tr></table></figure>
<p>　　命令行选项<code>-fpic</code>指示编译器生成位置无关代码，<code>-shared</code>指示链接器生成共享库文件。生成共享库后，需要链接到程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -o prog main.c ./libarray.so</span></span><br></pre></td></tr></table></figure>
<p>　　这样就生成了可执行文件<code>prog</code>，该文件的形式使得它能在运行时和<code>libarray.so</code>链接。基本思想是在创建可执行文件时，静态执行部分链接，然后在程序加载时，动态完成剩余链接。静态链接时仅复制了一些重定位和符号表信息，使得它们在运行时可以解析对<code>libarray.so</code>中代码和数据的引用。</p>
<p>　　相比静态链接，动态链接生成的<code>prog</code>包含<code>.interp</code>节，该节包含动态链接器的路径名。加载器会直接加载和运行对应的动态链接器而非将控制权转移给程序，然后动态链接器执行以下的重定位来完成链接任务：</p>
<p>　　● 重定位<code>libc.so</code>的文本和数据到某个内存段。</p>
<p>　　● 重定位<code>libarray.so</code>的文本和数据到另一个内存段。</p>
<p>　　●
重定位<code>prog</code>中所有<code>libc.so</code>和<code>libarray.so</code>定义的符号的引用。</p>
<p>　　最后，动态链接器将控制权转移给程序，此时，共享库的位置就已固定并在程序执行时不会改变。</p>
<h3 id="从应用程序中加载和链接共享库">7.9
从应用程序中加载和链接共享库</h3>
<p>　　实际中，应用程序可能在运行时要求链接器加载和链接某个共享库而非在编译时。</p>
<p>　　动态链接的常见应用场景包括<span
style="background-color: yellow">分发软件</span>和<span
style="background-color: yellow">构建高性能Web服务器</span>。</p>
<p>　　●
Windows应用开发者经常用共享库来分发软件更新，即生成共享库的新版本，用户下载后用新共享库替代旧版本。下一次运行应用程序时，应用将自动加载新共享库。</p>
<p>　　●
很多Web服务器会生成动态内容，例如，个性化的Web页面、账户余额和广告标语。早期的Web服务器通过使用<code>fork()</code>和<code>execve()</code>创建子进程，在子进程的上下文中运行CGI程序来生成动态内容。通过使用动态链接可以更有效和完善地来生成动态内容。基本思想是将每个动态内容打包在共享库中，当Web请求到达时，服务器动态地加载和链接对应的函数并调用它们。函数会一直缓存在服务器的地址空间中，所以只需简单的函数调用就可以处理随后的请求。这样，可以在不停止服务器的情况下更新和增加函数。</p>
<p>　　Linux为动态链接提供了接口，允许应用程序在运行时加载和链接共享库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>; <span class="comment">/* 成功时返回指向句柄的指针，出错时返回空指针 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">char</span> *symbol)</span>; <span class="comment">/* 成功时返回指向符号的指针，出错时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 最近对函数dlopen()、dlsym()或dlerror()的调用失败时返回错误信息，最近对这些函数的调用成功时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>dlopen()</code>会加载和链接共享库<code>filename</code>。<code>filename</code>中的外部符号通过之前使用<code>RTLD_GLOBAL</code>选项打开的库来解析。若当前可执行文件是带<code>-rdynamic</code>选项编译，则其全局符号可用于符号解析。参数<code>flag</code>只能为<code>RTLD_NOW</code>
(指示链接器立即解析外部符号引用) 或<code>RTLD_LAZY</code>
(指示链接器将符号解析推迟到执行来自库中的代码)，两者都可以和<code>RTLD_GLOBAL</code>取或。</p>
<p>　　函数<code>dlsym()</code>的参数<code>handle</code>分别指向之前已打开的共享库的句柄，<code>symbol</code>是符号名，若该符号存在，则返回符号地址；否则，返回<code>NULL</code>。</p>
<p>　　函数<code>dlclose()</code>用于卸载共享库。</p>
<p>　　函数<code>dlerror()</code>用于返回最近对以上3个函数的调用的错误信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dll.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *handle;</span><br><span class="line">    <span class="type">void</span> (*addarrray)(<span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 动态加载包含addarray()的共享库 */</span></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libarray.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取指向刚加载的函数addarray()的指针 */</span></span><br><span class="line">    addarrray = dlsym(handle, <span class="string">&quot;addarray&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 现在就可以调用函数addarray() */</span></span><br><span class="line">    addarrray(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d\n]&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 卸载共享库 */</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会用上述接口动态链接共享库<code>libarray.so</code>并调用其例程<code>addarray</code>。要编译该程序，需要如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -dynamic -o prog dll.c -ldl</span></span><br></pre></td></tr></table></figure>
<p>　　<strong>Java本地接口</strong> (JNI)
允许Java程序调用C/C++函数。JNI的思想就是将本地C函数
(如<code>foo()</code>) 编译到共享库 (如<code>foo.so</code>)
中。当运行的Java程序调用函数<code>foo()</code>时，Java解释器通过<code>dlopen()</code>等接口动态链接和加载<code>foo.so</code>，然后调用<code>foo()</code>。</p>
<h3 id="位置无关代码">7.10 位置无关代码</h3>
<p>　　若多个进程需要共享同一共享库，可以给每个共享库分配事先准备的专用的地址空间并要求加载器总是加载到该区域。显然，这种方法的地址使用率不高，首先，即使进程不是该共享库也会分配空间。其次，分配的空间难以管理，必须保证没有片会重叠。每当修改共享库时，必须确认分配的片的大小合适。若不合适，需要重新找新片。若创建了新共享库，必须为其分配空间。随着系统中共享库及其版本的增加，很可能导致出现很多小到无法使用的地址块。此外，每个系统的共享库的空间分配不同，这会导致更多的问题。</p>
<p>　　以上问题可以用<strong>位置无关代码</strong> (PIC)
避免，即可以加载而无需重定位的代码。对gcc使用<code>-fpic</code>选项可以指示GNU编译系统生成PIC代码。共享库的编译<span
style="background-color: yellow">必须</span>使用该选项。</p>
<p>　　在x86-64系统中，同一目标模块中的符号的引用无需特殊处理就能成为PIC。生成目标文件时，这种引用可以用PC相对寻址来编译，用静态链接器来重定位。</p>
<p>　　无论在内存中的何处加载目标模块，数据段与代码段的距离总是保存不变的。因此，代码段中的任何指令和数据段中的任何变量之间的<span
style="background-color: yellow">距离</span>都是运行时常量。</p>
<h4 id="pic数据引用">7.10.1 PIC数据引用</h4>
<p>　　编译器在生成全局变量PIC引用时，会在数据段起始处创建<strong>全局偏移表</strong>
(GOT)，还会为每个GOT条目生成重定位记录 (GOT条目都是8B)。每个引用全局目标
(过程或全局变量)
的目标模块都有GOT，目标模块引用的每个全局目标都有对应的GOT条目。在加载时，动态链接器会重定位GOT中的每个条目，使其包含目标的绝对地址。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_07/using_the_got_to_reference_a_global_variable.svg" class="">
<p>　　这是共享库<code>libarray.so</code>的GOT。例程<code>addarray</code>通过<code>GOT[3]</code>间接加载全局变量<code>addcnt</code>的地址并在内存中将<code>addcnt</code>加1。若<code>addcnt</code>是非外部符号，编译器可以利用代码段和数据段之间的固定距离直接生成<code>addcnt</code>的PC相对引用，并增加1个重定位用于链接器在生成共享库时解析；若<code>addcnt</code>是外部符号，则需要通过GOT间接访问。这里编译器采用最通用的方法，即对所有引用都使用GOT。</p>
<h4 id="pic函数调用">7.10.2 PIC函数调用</h4>
<p>　　若程序需要调用共享库定义的函数，但编译器无法预测该函数的运行时地址
(共享库在运行时可以加载到任何位置)，常规的方法是为该引用生成重定位记录，动态链接器在程序加载时再解析它。这种方法是并不是PIC，因为它需要链接器修改调用模块的代码段，GNU使用了<strong>延迟绑定</strong>来将过程地址的绑定推迟到首次调用该过程。</p>
<p>　　常规程序只会使用<code>libc.so</code>等包括成大量函数的共享库中的很少一部分函数，把函数地址的解析推迟到实际被调用的地方，能<span
style="background-color: yellow">避免动态链接器在加载时进行大量无意义的重定位</span>。这样只有首次调用过程的运行时开销很大，之后每次调用都只需单条指令和单个间接内存引用。</p>
<p>　　延迟绑定通过GOT和<strong>过程链接表</strong> (PLT)
来实现。若目标模块调用共享库中定义的函数，则它会有自己的GOT和PLT。GOT是数据段的一部分，PLT是代码段的一部分。</p>
<p>　　PLT是由若干个16B的条目组成的数组。<code>PLT[0]</code>是特殊条目，它会跳转到动态链接器中。每个可执行文件调用的库都有自己的PLT条目。每个条目负责调用具体函数。<code>PLT[1]</code>会调用7.7中的<span
style="background-color: yellow">系统启动函数</span>。<code>PLT[2]</code>及以后的条目会调用用户级代码调用的函数。</p>
<p>　　GOT是由若干个8B的条目组成的数组。和PLT共同使用时，<code>GOT[0]</code>和<code>GOT[1]</code>包含动态链接器在解析函数地址时会使用的信息。<code>GOT[2]</code>是动态链接器在模块<code>ld-linux.so</code>中的入口点。其余的每个条目都对应1个被调函数，其地址在运行时被解析。此外，每个GOT条目都有对应的POT条目。初始化时，每个GOT条目都指向对应PLT条目的的<span
style="background-color: yellow">第2条</span>指令。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_07/using_the_got_and_plt_to_call_external_functions.svg" class="">
<p>　　图a是在首次调用<code>addarray()</code>时，GOT和PLT协同工作来延迟解析其运行地址的流程。</p>
<p>　　1)
程序会先调用<code>addarray()</code>的PLT条目而非直接调用该函数。</p>
<p>　　2)
首条PLT指令通过<code>GOT[4]</code>间接跳转。这里<code>GOT[4]</code>指向<code>PLT[2]</code>的第2条指令，因此，这一步只是为了把控制权转移给<code>PLT[2]</code>的第2条指令。</p>
<p>　　3)
把<code>addarray()</code>的ID<code>0x1</code>压入栈后，<code>PLT[2]</code>跳转到<code>PLT[0]</code>。</p>
<p>　　4)
<code>PLT[0]</code>通过<code>GOT[1]</code>间接地把动态链接器的1个参数压入栈，再通过<code>GOT[2]</code>间接地跳转到动态链接器。动态链接器通过2个栈条目来确定的<code>addarray()</code>的运行时地址，用该地址覆写<code>GOT[4]</code>，再把控制权转移给<code>addarray()</code>。</p>
<p>　　图b是后续调用<code>addarray()</code>的控制流。</p>
<p>　　1) 和前面一样，控制权转移到<code>PLT[2]</code>。</p>
<p>　　2)
通过<code>GOT[4]</code>的间接跳转将控制权直接转移给<code>addarray()</code>。</p>
<h3 id="库打桩">7.11 库打桩</h3>
<p>　　Linux链接器的<strong>库打桩</strong>允许追踪指定的共享库函数的调用次数，验证和追踪其输入和输出值，甚至可以将其替换为其他的实现。基本思想是为目标函数创建<strong>包装函数</strong>，其原型与目标函数的原型相同。包装函数通常会执行自己的逻辑，然后调用目标函数，最后将目标函数的返回值传递给调用者。使用某些特殊的库打桩机制，可以达到欺骗操作系统调用包装函数而非目标函数。打桩可以发生在编译时、链接时和运行时。</p>
<h4 id="编译时打桩">7.11.1 编译时打桩</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* int.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 本地的malloc.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(ptr) myfree(ptr);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">myfree</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mymalloc.c中关于编译时打桩的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILETIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d)=%p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">myfree</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    prtinf(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　<code>mymalloc.h</code>中的包装函数会调用目标函数，打印追踪记录，最后返回。本地的<code>malloc.h</code>指示预处理器将目标函数的调用替换为对应的包装函数的调用。编译和链接该程序的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -DCOMPILETIME -c mymalloc.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -I. -o intc int.c mymalloc.c</span></span><br></pre></td></tr></table></figure>
<p>　　命令行选项<code>-I.</code>表示执行打桩，即指示预处理器在搜索系统目录前，先在当前目录中查找<code>malloc.h</code>。这里<code>mymalloc.c</code>中的包装函数是使用标准头文件<code>malloc.h</code>编译。</p>
<h4 id="链接时打桩">7.11.2 链接时打桩</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mymalloc.c中关于链接时打桩的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LINKTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *__real_malloc(<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> __real_free(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *__wrap_malloc(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = __real_malloc(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free的包装函数 */</span></span><br><span class="line"><span class="type">void</span> __wrap_free(<span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    __real_free(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　Linux静态链接器支持用<code>--wrap f</code>参数进行链接时打桩。该参数指示链接器把符号<code>f</code>的引用解析为<code>__wrap_f</code>，把符号<code>__real_f</code>的引用解析为<code>f</code>。以上源文件通过以下命令编译为可重定位目标文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -DLINKTIME -c mymalloc.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c int.c</span></span><br></pre></td></tr></table></figure>
<p>　　然后，把目标文件链接为可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -W1,--warp,malloc -W1,--warp,free -o intl int.o mymalloc.o</span></span><br></pre></td></tr></table></figure>
<p>　　命令行选项<code>-W1,option</code>表示把<code>option</code>传递给链接器，<code>option</code>中的逗号会替换为空格，所以<code>-W1,--wrap,malloc</code>会传递<code>--wrap malloc</code>给链接器。</p>
<h4 id="运行时打桩">7.11.3 运行时打桩</h4>
<p>　　编译时打桩需要能够访问程序的源文件，链接时打桩需要能够访问程序的可重定位目标文件。基于动态链接器的<code>LD_PRELOAD</code>环境变量的运行时打桩只需要能够访问可执行文件。</p>
<p>　　若<code>LD_PRELOAD</code>环境变量设置为共享库路径名的列表
(以空格或分号分隔)，当加载和执行程序并解析未定义的引用时，动态链接器会先搜索<code>LD_PERLOAD</code>中设置的库，再搜索其他库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mymalloc.c中关于运行时打桩的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RUNTIME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc的包装函数 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *(*mallocp)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    mallocp = dlsym(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>); <span class="comment">/* 获取libc中malloc的地址 */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *ptr = mallocp(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(%d) = %p\n&quot;</span>, (<span class="type">int</span>)size, ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free的包装函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*freep)(<span class="type">void</span> *) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freep = dlsym(RTLD_NEXT, <span class="string">&quot;free&quot;</span>); <span class="comment">/* 获取libc中free的地址 */</span></span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    freep(ptr); <span class="comment">/* 调用libc中的free */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free(%p)\n&quot;</span>, ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　每个包装函数中，调用<code>dlsym()</code>会返回指向目标<code>libc</code>函数的指针，然后包装函数调用目标函数，打印追踪记录，最后返回。生成包含这些包装函数的共享库的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl</span></span><br></pre></td></tr></table></figure>
<p>　　编译主程序的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -o intr int.c</span></span><br></pre></td></tr></table></figure>
<p>　　在bash shell运行该程序的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_PERLOAD=<span class="string">&quot;./mymalloc.so&quot;</span> ./intr</span></span><br></pre></td></tr></table></figure>
<p>　　在<code>csh</code>或<code>tcsh</code>中运行该程序的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(setenv LD_PRELOAD <span class="string">&quot;./mymalloc.so&quot;</span>; ./intr; unsetenv LD_PRELOAD)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《剑桥国际英语语音在用》附录</title>
    <url>/english/english_pronunciation_in_use_appx/</url>
    <content><![CDATA[<p>　　 原书及音频下载地址：<a
href="https://github.com/concerto-grosso/english_pronunciation_in_use">点击这里</a>。</p>
<h3 id="a.1-数字相关">A.1 数字相关</h3>
<p>　　100、1000和1000000分别是a hundred、a thousand和a million。</p>
<p>　　对于大于100的数，需要在百分位和十分位之间加上and，部分美国人会省略这个and。例如，350是three
hundred and fifty，27403是twenty-seven thousand, four hundred and
three。</p>
<p>　　对于年份，非100的整数倍且小于2000的年份会进行分割，而100的整数倍或大于等于2000的年份与数字相同。例如，1890是eighteen
ninety，1900是nineteen hundred，1907是nineteen oh seven，2007是two
thousand and seven。</p>
<p>　　对于电话号码，数字组之间会有停顿，0发音为oh，33和77发音为double
three和double seven。例如，0609 655 400是oh six oh nine, six double
five, four double oh。</p>
<p>　　对于温度，14°是fourteen degrees，0°是zero，-12°是minus twelve
(degrees) / twelve (degrees) below zero。</p>
<p>　　对于序数，1st是first，2nd是second，3rd是third，4th是fourth，5th是fifth，13th是thirteenth，20th是twentieth，21是twenty-first，51是fifty-first。</p>
<p>　　对于日期，22 May是May the twenty-second、the twenty-second of
May或May twenty-second (美式英语)。</p>
<p>　　对于分数，<span class="math inline">\(\frac{1}{2}\)</span>是a
half，<span class="math inline">\(\frac{1}{4}\)</span>是a quarter或a
fourth (美式英语)，<span
class="math inline">\(\frac{3}{4}\)</span>是three quarters或three
fourths (美式英语)，其他分数是[数字 + 序数]的形式。例如，<span
class="math inline">\(\frac{1}{3}\)</span>是a third，<span
class="math inline">\(\frac{5}{8}\)</span>是five eighths。</p>
<p>　　对于小数，小数点发音为point。例如，1.6是one point
six，23.95是twenty-three point nine five，0.762是nought point seven six
two或zero point seven six two (美式英语)。</p>
<p>　　对于百分数，1%是one per cent，50%是fifty per
cent，67.3%是sixty-seven point three per cent。</p>
<span id="more"></span>
<h3 id="a.2-相关术语">A.2 相关术语</h3>
<blockquote>
<p><strong>adjective</strong> 形容词</p>
<p><strong>adverb</strong> 副词</p>
<p><strong>adverbial</strong> 状语</p>
<p><strong>article</strong> 冠词</p>
<p><strong>auxiliary verb</strong> 助动词</p>
<p><strong>cleft sentence</strong> 分裂句</p>
<p><strong>compound</strong> 复合词</p>
<p><strong>consonant</strong> 辅音</p>
<p><strong>consonant cluster</strong> 辅音簇</p>
<p><strong>content word</strong> 实词</p>
<p><strong>contraction</strong> 缩写</p>
<p><strong>defining relative clause</strong> 限定性定语从句</p>
<p><strong>determiner</strong> 限定词</p>
<p><strong>ellipsis</strong> 省略</p>
<p><strong>exclamation</strong> 感叹句</p>
<p><strong>function word</strong> 虚词</p>
<p><strong>glottal stop</strong> 喉塞音</p>
<p><strong>imperative</strong> 祈使句</p>
<p><strong>indefinite pronoun</strong> 不定代词</p>
<p><strong>international phonetic alphabet (IPA)</strong> 国际音标</p>
<p><strong>level tone</strong> 平调</p>
<p><strong>main/primary stress</strong> 主重音</p>
<p><strong>modal verb</strong> 情态动词</p>
<p><strong>near ellipsis</strong> 近似省略</p>
<p><strong>non-defining relative clause</strong> 非限定性定语从句</p>
<p><strong>noun</strong> 名词</p>
<p><strong>object</strong> 宾语</p>
<p><strong>reporting verb</strong> 转述动词</p>
<p><strong>participle</strong> 分词</p>
<p><strong>particle</strong> 小品词</p>
<p><strong>phrasal verb</strong> 短语动词</p>
<p><strong>plosive</strong> 塞音</p>
<p><strong>plural</strong> 复数形式</p>
<p><strong>possessive</strong> 所有格</p>
<p><strong>prefix</strong> 前缀</p>
<p><strong>preposition</strong> 介词</p>
<p><strong>prominence</strong> 强读</p>
<p><strong>pronoun</strong> 代词</p>
<p><strong>question tag</strong> 疑问尾句</p>
<p><strong>reflexive pronoun</strong> 反身代词</p>
<p><strong>root</strong> 词根</p>
<p><strong>schwa</strong> 非重读央元音</p>
<p><strong>secondary stress</strong> 次重音</p>
<p><strong>speech unit</strong> 语音单元</p>
<p><strong>statement</strong> 陈述句</p>
<p><strong>stress</strong> 重读；重音</p>
<p><strong>stress shift</strong> 重音转移</p>
<p><strong>subject</strong> 主语</p>
<p><strong>suffix</strong> 后缀</p>
<p><strong>syllabic consonant</strong> 成音节</p>
<p><strong>syllable</strong> 音节</p>
<p><strong>tense</strong> 时态</p>
<p><strong>verb</strong> 动词</p>
<p><strong>vowel</strong> 元音</p>
</blockquote>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
  </entry>
  <entry>
    <title>《ARM Cortex-M3与Cortex-M4权威指南 第3版》第1章 ARM Cortex-M处理器简介</title>
    <url>/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_01/</url>
    <content><![CDATA[<p>　　Cortex-M3和Cortex-M4是ARM设计的处理器。Cortex-M3处理器是ARM于2005年发布的Cortex系列处理器中的第1款
(芯片产品于2006年发布)。Cortex-M4处理器于2010年发布
(产品也于同年发布)。</p>
<p>　　Cortex-M3和Cortex-M4处理器使用的是<span
style="background-color: yellow">32位架构</span>。寄存器组、数据路径和总线接口中的内部寄存器都是32位。Cortex-M处理器使用的指令集架构是基于Thumb-2的<span
style="background-color: yellow">Thumb ISA</span>
(Thumb-2支持16位指令和32位指令的混合)。</p>
<p>　　Cortex-M3和Cortex-M4处理器具有如下特点：</p>
<p>　　● 3阶段流水线设计</p>
<p>　　● 使用统一内存空间的哈佛总线架构
(指令和数据使用相同的地址空间)</p>
<p>　　● 32位地址 (支持4GB的内存空间)</p>
<p>　　● 基于ARM高级微控制器总线架构的片上总线接口
(允许流水线总线操作有更高的带宽)</p>
<p>　　● 嵌套向量中断控制器
(支持最多240个中断请求和8~256个中断优先级)</p>
<p>　　● 支持操作系统实现的各种功能
(例如，系统节拍定时器和影子栈指针)</p>
<p>　　● 支持睡眠模式和各种低功耗功能</p>
<p>　　●
可以通过可选的内存保护单元来提供可编程内存或访问权限控制等内存保护功能</p>
<p>　　● 可以通过<span
style="background-color: yellow">位带</span>来支持2个特定存储器区域的位数据访问</p>
<p>　　● 可用于单处理器或多处理器设计的选项</p>
<p>　　Cortex-M3和Cortex-M4处理器使用的ISA支持：</p>
<p>　　● 通用数据处理指令 (包括硬件除法指令)</p>
<p>　　●
支持8位、16位、32位和64位数据和内存访问指令以及用于传输多个32位数据的指令</p>
<p>　　● 用于处理位域的指令</p>
<p>　　● 乘法累加指令和饱和指令</p>
<p>　　● 用于分支、条件分支和函数调用的指令</p>
<p>　　● 用于系统控制和操作系统支持等功能的指令</p>
<p>　　此外，Cortex-M4处理器使用的ISA还支持：</p>
<p>　　● 单指令多数据操作</p>
<p>　　● 额外的快速MAC和乘法指令</p>
<p>　　● 饱和算术指令</p>
<p>　　● 可选的浮点数指令 (单精度)</p>
<p>　　Cortex-M3和Cortex-M4处理器都广泛用于现代微处理器产品和其他专用芯片设计
(例如，片上系统和专用标准产品)。</p>
<p>　　通常，ARM Cortex-M处理器被视为<span
style="background-color: yellow">精简指令集计算</span>处理器，但Cortex-M3和Cortex-M4处理器的某些特征
(例如，丰富的指令集和混合指令大小)
更接近于复杂指令集计算处理器的功能。随着处理器技术的发展，大多数RISC处理器的指令集变得越来越复杂，以至于RISC和CISC处理器定义的传统界限不再适用。</p>
<p>　　Cortex-M3和Cortex-M4处理器之间有很多相似之处。它们支持的指令大致相同，并且提供的NVIC和MPU等功能的编程模型相同。但是，它们的内部设计存在区别，这使得Cortex-M4处理器能够支持浮点运算以及在DSP应用程序中提供更高的性能。因此，Cortex-M4处理器执行某些两者都支持的指令所需的时钟周期更少。</p>
<p>　　多年来，ARM设计了很多处理器，并且Cortex-M3和Cortex-M4处理器的很多功能都是基于从过去设计的处理器演变而来的技术。</p>
<span id="more"></span>
<h3 id="arm-cortex-m处理器">1.1 ARM Cortex-M处理器</h3>
<p>　　ARM
Cortex-M系列处理器包括Cortex-M0、Cortex-M0+、Cortex-M1、Cortex-M3和Cortex-M4。</p>
<p>　　Cortex-M3和Cortex-M4处理器基于ARMv7-M架构，它们都是专为微控制器设计的高性能处理器。因为Cortex-M4处理器支持SIMD、快速MAC和饱和算术指令，所以该处理器也能运行一些通常运行在数字信号处理器上的数字信号处理应用程序。</p>
<p>　　Cortex-M0、Cortex-M0+和Cortex-M1处理器基于ARMv6-M架构，该架构的支持的指令少于ARMv7-M架构。Cortex-M0和Cortex-M0+的门数都比较少
(低至12K个门)，很适合低功耗微处理器产品。Cortex-M0+有最先进的低功耗优化，并且具有更多的可选功能。</p>
<p>　　Cortex-M1处理器专为FPGA应用程序设计，它具有<span
style="background-color: yellow">紧密耦合存储器</span>功能，该功能可以通过FPGA内部的存储器实现，并且允许在高级FPGA中进行高时钟频率操作
(例如，可以在Altera Stratix III FPGA中以高于200MHz的速度运行)。</p>
<p>　　对于通用数据处理和I/O控制任务，Cortex-M0和Cortex-M0+处理器由于较少的门数设计而具有出色的能效。但是，对于需要处理复杂数据的应用程序，Cortex-M0和Cortex-M0+处理器需要更多的指令和时钟周期，Cortex-M3和Cortex-M4处理器更适合这种情况
(因为ARMv7-M架构可以通过ARMv6-M架构所没有的指令来以更少的指令处理这些数据)。</p>
<p>　　除了Cortex-M系列处理器，通用微控制器产品中还会使用其他ARM处理器，更早的ARM7处理器在市场中也很成功，NXP
(前身为Philips Semiconductor)、Texas
Instruments、Ateml、OKI等供应商还使用ARM7TDMI等经典ARM处理器。此外，也有很多基于ARM9处理器的微处理器。</p>
<h4 id="处理器和微控制器之间的区别">1.1.1
处理器和微控制器之间的区别</h4>
<p>　　ARM成立于1990年，前身为Apple Computers、Acron Computer
Group和VLSI Technology的合资企业Advanced RISC Machines
Ltd.。在1991年，ARM推出了ARM6系统处理器 (用于Apple
Newton)，并且VLSI是第1个被授权方。随后，Texas
Instruments、NEC、Sharp和ST
Microelectronics等公司获得了ARM处理器设计的许可，这将ARM处理器的应用扩展到手机、计算机硬盘、掌上电脑、家用娱乐系统和其他消费产品。</p>
<p>　　不同于其他半导体公司，ARM不直接生产芯片。相反，ARM将处理器设计授权给商业伙伴
(包括大多数世界上领先的半导体公司)。ARM设计芯片设计者所需的处理器和各种组件，并将这些设计授权给各种芯片设计公司
(包括微控制器供应商)。通常，这些设计称为<span
style="background-color: yellow">知识产权</span>
(IP)，这种商业模式称为<span
style="background-color: yellow">IP授权</span>。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_01/a_microcontroller_contains_many_different_blocks.svg" class="">
<p>　　对于典型的微控制器设计，处理器仅占一小部分区域。剩余区域由内存、时钟生成
(即PLL)、分配逻辑、系统总线和外设
(即I/O接口单元、交互接口、定时器、ADC和DAC等硬件) 组成。</p>
<p>　　尽管很多微控制器供应商选择ARM
Cortex-M处理器作为CPU，但存储器系统、内存映射、外设和运行特性
(例如，时钟速度和电压)
可能因产品而异。这使得微控制器制造商可以在其产品中添加其它功能。</p>
<h4 id="arm和微控制器供应商">1.1.2 ARM和微控制器供应商</h4>
<p>　　目前，有超过15个芯片供应商在微控制器产品中使用ARM
Cortex-M3或Cortex-M4处理器。有些公司也将ARM
Cortex-M3或Cortex-M4处理器用于SoC设计。此外，还有部分公司仅使用ARM
Cortex-M0或Cortex-M0+处理器。</p>
<p>　　当某个公司获得Cortex-M处理器授权后，ARM会以Verlog-HDL的形式提供处理器的设计源码。该公司的工程师会添加自己的模块
(例如，外设和存储器)，并且通过各种EDA工具来将整个设计从Verlog-HDL转换为晶体级芯片布局。</p>
<p>　　ARM也提供其他IP产品，并且其中的部分产品可用于微控制器。例如：</p>
<p>　　● 逻辑门和存储器等单元库的设计 (ARM物理IP产品)</p>
<p>　　● 外设和AMBA基础架构组件 (Cortex-M系统设计工具包和ARM CoreLink
IP产品)</p>
<p>　　● 用于多处理器设计中的链接调试系统的附加调试组件 (ARM CoreSight
IP产品)</p>
<p>　　其中，Cortex-M系统设计工具包是适用于Cortex-M处理器的设计工具包，包括AMBA基础架构组件、示例系统和示例软件。该工具包允许芯片设计者快速上手Cortex-M处理器以及通过可重用的IP来减少芯片开发的总工作量。但是，微控制器芯片设计者还需要完成很多工作。</p>
<p>　　从软件角度，ARM拥有Keil
MDK-ARM和DS-5等软件开发平台。这些软件开发套件包括编译器、调试器和指令集模拟器，调试器也可以使用第三方软件开发工具。因为所有的Cortex-M微处理器的处理器内核相同，所以嵌入式产品设计者可以将同一的开发套件用于来自不同供应商的各种微控制器。</p>
<h3 id="背景和历史">1.2 背景和历史</h3>
<p>　　在Cortex-M3处理器之前，已经有很多不同的ARM处理器，并且其中的部分处理器已经用于微控制器。ARM最成功的处理器之一ARM7TDMI广泛使用在32位微控制器中。不同于传统32位处理器，ARM7TDMI同时支持32位的ARM指令集和16位的Thumb指令集，所以代码密度大大增加，从而减少了应用程序代码占用的内存。同时，关键任务仍然可以高速执行。这让ARM处理器可用于低功耗和小内存的移动设备。因此，ARM处理器成为了手机等移动设备的首选。</p>
<p>　　从那时起，ARM不断开发新处理器来满足不同的应用。例如，ARM9系列处理器广泛用于高性能微处理器，ARM11系统处理器广泛用于手机。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_01/diversity_of_processor_products_for_three_areas_in_the_cortex_processor_family.svg" class="">
<p>　　多年来，ARM通过多元化CPU来扩展其产品组合，进而产生了Cortex系列处理器。Cortex处理器设计为服务于3个领域。</p>
<p>　　● Cortex-A系列处理器专为处理嵌入式操作系统
(例如，IOS、Android、Linux和Windows)
等复杂应用设计。这些应用需要极高的处理能力、支持内存管理单元的虚拟内存系统、可选的增强Java支持和安全的程序执行环境。这类产品包括手机、平板电脑、电视和计算服务器。</p>
<p>　　● Cortex-R系列处理器专为较高端的实时应用
(例如，磁盘驱动控制器、用于移动通信的基带控制器和汽车系统)
设计。对于这些应用，较高的处理能力和高可靠性必不可少，低延迟和确定性也很重要。</p>
<p>　　● Cortex-M系列处理器专为较小规模的应用
(例如，微控制器和混合信号设计)
设计。对于这些应用，低成本、低功耗、能效和低中断延迟很重要。同时，处理器设计必须易于使用，并且能够提供很多实时控制系统所需的确定性行为。</p>
<h4 id="架构版本和thumb-isa">1.2.1 架构版本和Thumb ISA</h4>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_01/instruction_set_enhancement.svg" class="">
<p>　　ARM7TDMI基于ARMv4T架构 (T表示支持Thumb指令)。</p>
<p>　　ARMv5TE和ARM9E系列处理器 (包括ARM926E-S和ARM946E-S)
一起推出。该架构为多媒体应用程序添加了增强DSP指令。</p>
<p>　　随着ARM系统处理器的推出，架构发展到了ARMv6，该架构新增了SIMD指令和存储器系统功能。基于ARMv6架构的处理器包括ARM1136J(F)-S、ARM1156T2(F)-S和ARM1176JZ(F)-S。</p>
<p>　　为了满足各种应用领域的不同需求，ARMv7分为3个系列：</p>
<p>　　● 基于ARMv7-A架构的Cortex-A处理器</p>
<p>　　● 基于ARMv7-R架构的Cortex-R处理器</p>
<p>　　● 基于ARMv7-M和ARMv6-M架构的Cortex-M处理器</p>
<p>　　随着Cortex-M3处理器的成功，ARM推出了ARMv6-M架构，以满足超低功耗的需求。该架构使用了与ARMv7-M相同的编程模型和异常处理方法
(即NVIC)，并且通过仅使用Thumb指令来减少设计的复杂度。</p>
<p>　　Cortex-M4的增强DSP版基于ARMv7E-M，与ARMv5TE相同，这里的E表示增强DSP指令。</p>
<p>　　ARMv6-M架构在很多方面与ARMv7-M架构相似，包括中断处理、Thumb-2技术和调试架构，但前者支持的指令集较小。</p>
<p>　　在Cortex-M3处理器之后，ARM决定进一步扩展其在微控制器应用中的产品范围。第1步是允许用户轻松地在FPGA中实现自己的ARM处理器，第2步是解决超低功耗嵌入式处理器的问题。为此，ARM根据现有的ARMv6架构的Thumb指令集和ARMv7-M中的异常和调试功能开发了ARMv6-M架构。</p>
<p>　　所有的Cortex-M处理器都支持Thumb-2技术和Thumb
ISA的不同子集。在Thumb-2技术出现之前，Thumb
ISA只是16位ISA。Thumb-2技术扩展了Thumb
ISA，使其在易用性、代码规模和性能方面具有显著优势。</p>
<p>　　由于Thumb-2指令集同时支持16位指令和32位指令，所以处理器无需在Thumb状态
(16位指令) 和ARM状态 (32位指令) 之间切换。</p>
<p>　　Thumb-2技术是ARMv7非常重要的功能。相比ARM7系列处理器 (ARMv4T架构)
支持的指令，Cortex-M3和Cortex-M4处理器有大量新功能。首先，ARM处理器首次提供了硬件除法指令，并且Cortex-M3和Cortex-M4处理器也提供了很多乘法指令，以提高数据处理性能。Cortex-M3和Cortex-M4处理器还支持访问未对齐的数据，此功能之前仅出现在高端处理器中。</p>
<h4 id="处理器命名">1.2.2 处理器命名</h4>
<p>　　从传统角度，ARM使用数字方案来命名处理器。在早期
(20世纪90年代)，命名时还会使用后缀来表示处理器的功能。例如，对于ARM7TDMI处理器，T表示支持Thumb指令，D表示JTAG调试，M表示快速乘法器，I表示嵌入式ICE模块。</p>
<p>　　后来，这些功能成为了ARM处理器的标准功能，所以处理器命名时不再使用这些后缀。相反，ARM使用了新的数字命名方案来表示内存接口、缓存和TCM。例如，带有缓存和MMU的处理器使用后缀26或36，带有MPU的处理器使用后缀46
(例如，ARM946E-S)。此外，还使用后缀S和J来分别表示可综合和Jazelle技术。</p>
<table>
<thead>
<tr>
<th>处理器名称</th>
<th>架构版本</th>
<th>内存管理功能</th>
<th>其他功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ARM7TDMI</td>
<td>ARMv4T</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ARM7TDMI-S</td>
<td>ARMv4T</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ARM7EJ-S</td>
<td>ARMv5TEJ</td>
<td></td>
<td>DSP和Jazelle</td>
</tr>
<tr>
<td>ARM920T</td>
<td>ARMv4T</td>
<td>MMU</td>
<td></td>
</tr>
<tr>
<td>ARM922T</td>
<td>ARMv4T</td>
<td>MMU</td>
<td></td>
</tr>
<tr>
<td>ARM926EJ-S</td>
<td>ARMv5TEJ</td>
<td>MMU</td>
<td>DSP和Jazelle</td>
</tr>
<tr>
<td>ARM946E-S</td>
<td>ARMv5TE</td>
<td>MPU</td>
<td>DSP</td>
</tr>
<tr>
<td>ARM966E-S</td>
<td>ARMv5TE</td>
<td></td>
<td>DSP</td>
</tr>
<tr>
<td>ARM968E-S</td>
<td>ARMv5TE</td>
<td></td>
<td>DMA和DSP</td>
</tr>
<tr>
<td>ARM966HS</td>
<td>ARMv5TE</td>
<td>可选的MPU</td>
<td>DSP</td>
</tr>
<tr>
<td>ARM1020E</td>
<td>ARMv5TE</td>
<td>MMU</td>
<td>DSP</td>
</tr>
<tr>
<td>ARM1022E</td>
<td>ARMv5TE</td>
<td>MMU</td>
<td>DSP</td>
</tr>
<tr>
<td>ARM1026EJ-S</td>
<td>ARMv5TEJ</td>
<td>MMU或MPU</td>
<td>DSP和Jazelle</td>
</tr>
<tr>
<td>ARM1136J(F)-S</td>
<td>ARMv6</td>
<td>MMU</td>
<td>DSP和Jazelle</td>
</tr>
<tr>
<td>ARM1176JZ(F)-S</td>
<td>ARMv6Z</td>
<td>MMU和TrustZone</td>
<td>DSP和Jazelle</td>
</tr>
<tr>
<td>ARM11 MPCore</td>
<td>ARMv6K</td>
<td>MMU和多处理器缓存支持</td>
<td>DSP和Jazelle</td>
</tr>
<tr>
<td>ARM1156T2(F)-S</td>
<td>ARMv6T2</td>
<td>MPU</td>
<td>DSP</td>
</tr>
</tbody>
</table>
<p>　　从ARMv7开始，ARM放弃了这些复杂的命名方案，转向与处理器系统一致的命名方案，并且将Cortex作为整体品牌。除了表示处理器之间的兼容性之外，该命名方案还消除了架构版本和处理器版本号之间的混淆。Cortex始终用于微处理器应用的处理器，包括ARMv7-M和ARMv6-M产品。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第12章 并发编程</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_12/</url>
    <content><![CDATA[<p>　　若多个逻辑控制流在时间上有重叠，则它们是并发的，这种机制称为<strong>并发</strong>，并且存在于计算机系统的各个层级中，例如，硬件异常处理函数、进程和Linux信号处理函数。</p>
<p>　　<strong>线程</strong>是运行在进程上下文中的逻辑流，由内核自动调度。每个线程有自己的<strong>线程上下文</strong>，包括唯一的整数<strong>线程ID</strong>、栈、栈指针、PC、通用目的寄存器和条件码寄存器。同一进程中所有线程共享虚拟地址空间，包括只读代码区域、读写区域、堆、共享库和打开的文件。</p>
<p>　　栈位于虚拟地址空间中的栈区域，<span
style="background-color: yellow">通常</span>由对应的线程访问。但是，栈并没有严格的访问权限控制，若某个线程以某种方式得到指向其他线程的栈的指针，则它可以读写该栈的任意部分。</p>
<p>　　使用应用级并发的程序称为<strong>并发程序</strong>。现代操作系统提供了3种构建并发程序的基本方法：<span
style="background-color: yellow">进程</span>、<span
style="background-color: yellow">I/O多路复用</span>和<span
style="background-color: yellow">线程</span>。</p>
<p>　　●
对于基于进程的并发编程，每个逻辑流1个进程。内核自动调度每个进程，每个进程都有私有的地址空间，这使得逻辑流共享数据比较困难。</p>
<p>　　●
对于基于I/O多路复用的并发编程，需要手动创建逻辑流并通过I/O多路复用来显式调度这些逻辑流。因为只有1个进程，所以逻辑流共享地址空间。</p>
<p>　　● 对于基于线程的并发编程，它结合前2种方法的特点。</p>
<p>　　函数<code>waitpid()</code>和信号量是基本的IPC机制，它们允许同一主机上的进程相互发送短信息。套接字接口是IPC的重要形式之一，它允许不同主机上的进程通信。术语UNIX
IPC是所有允许同一主机上的进程通信的技术的统称，包括管道、FIFO、系统V共享内存和系统V信号量。</p>
<p>　　实现同步的方法不止有信号量。Java线程可以通过<span
style="background-color: yellow">监视器</span>来实现同步，监视器提供信号量的互斥访问和调度功能的高级抽象。实际上，监视器可以通过信号量来实现。</p>
<p>　　POSIX线程是C程序控制线程的标准接口
(1995年新增)，可用于所有Linux系统上。POSIX线程定义了1组对互斥锁和条件变量的同步操作，前者用于互斥，后者用于调度共享资源的访问。</p>
<p>　　程序可以分为<span
style="background-color: yellow">顺序程序</span>和<span
style="background-color: yellow">并发程序</span>。顺序程序被实现为单个逻辑流。并发程序被实现为多个逻辑流。<span
style="background-color: yellow">并行程序</span>是运行在多核CPU的并发程序。</p>
<span id="more"></span>
<h3 id="基于进程的并发编程">12.1 基于进程的并发编程</h3>
<p>　　最简单的构建并发程序的方法是使用进程，调用类似<code>fork()</code>、<code>exec()</code>和<code>waitpid()</code>的函数。</p>
<p>　　这里以构建并发服务器为例，构建并发服务器最自然的方法是服务器接收客户端的连接请求，然后创建子进程来服务客户端。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_12/simple_example_of_concurrent_programming_with_processes.svg" class="">
<p>　　假设有2个客户端和1个服务器 (监听描述符为描述符3)。</p>
<p>　　如图a所示，服务器接收客户端1的连接请求并返回新的已连接描述符
(描述符4)。</p>
<p>　　如图b所示，客户端创建子进程1，子进程1有服务器的描述符表的完整副本。子进程1<span
style="background-color: yellow">关闭自己的描述符3</span>，服务器<span
style="background-color: yellow">关闭自己的描述符4</span>。然后，子进程1服务客户端1。</p>
<p>　　如图c所示，服务器接收新客户端2的连接请求并返回新的已连接描述符
(描述符5)。</p>
<p>　　如图d所示，服务器创建子进程2，子进程2通过描述符5来服务客户端2。</p>
<p>　　此时，服务器等待下一个连接请求，2个子进程并发地服务对应的客户端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* echoserverp.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Close(listenfd); <span class="comment">/* 子进程关闭它的的监听描述符 */</span></span><br><span class="line">            echo(connfd);    <span class="comment">/* 子进程服务客户端 */</span></span><br><span class="line">            Close(connfd);   <span class="comment">/* 子进程关闭和客户端的连接 */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);         <span class="comment">/* 子进程退出 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd); <span class="comment">/* 服务器关闭它的已连接标识符 (重要) */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于基于进程的并发echo服务器，由于服务器会运行较长时间，必须要加入信号处理函数来回收子进程
(第3~8行)。因为信号SGICHLD在其处理函数运行时会被阻塞，并且信号不会排队，所以<code>SIGCHLD</code>处理函数必须准备回收多个僵尸子进程。由于套接字的文件表条目中的引用次数，只有当父子进程都关闭各自的<code>connfd</code>时，与客户端的连接才会关闭。</p>
<p>　　进程拥有用于父子进程之间共享状态信息的清晰模型，即文件表是共享的，而用户地址空间不是共享的。不共享的地址空间既是优点也是缺点，优点是进程不可能意外地覆写其他进程的虚拟内存，缺点是不共享的地址空间不易于共享状态信息。若需要共享状态信息，必须使用显式IPC机制。基于进程的并发编程的另一个缺点是不低的进程控制和IPC成本，所以更可能会导致效率低下。</p>
<h3 id="基于io多路复用的并发编程">12.2 基于I/O多路复用的并发编程</h3>
<p>　　若需要编写能够响应通过键盘输入的命令行的echo服务器，可以使用I/O多路复用。基本思想是调用函数<code>select()</code>来请求内核挂起进程，并在I/O事件发生后将控制权转移给应用程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> n, fd_set *fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span>; <span class="comment">/* 成功时返回准备好读的描述符数，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于控制描述符集的宏 */</span></span><br><span class="line">FD_ZERO(fd_set *fdset);          <span class="comment">/* 清除fdset的所有位 */</span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset);   <span class="comment">/* 清除fdset的fd位 */</span></span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset);   <span class="comment">/* 启用fdset的fd位 */</span></span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set *fdset); <span class="comment">/* fdset的fd位是否启用 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>select()</code>控制类型为<code>fd_set</code>的集合，称为<strong>描述符集</strong>。从逻辑角度，可以将描述符集视为长度为<span
class="math inline">\(n\)</span>的位向量<span
class="math inline">\([b_{n-1},...,b_{1},b_{0}]\)</span>，<span
class="math inline">\(b_k\)</span>对应描述符<span
class="math inline">\(k\)</span>。当且仅当<span
class="math inline">\(b_k=1\)</span>时，描述符<span
class="math inline">\(k\)</span>才是描述符集的成员。能对描述符集的进行操作只有3个：分配它们、将该类型的变量赋值给其他变量以及通过宏<code>FD_ZERO</code>、<code>FD_CLR</code>、<code>FD_SET</code>和<code>FD_ISSET</code>来修改和查看它们。</p>
<p>　　函数<code>select()</code>有多种应用场景。这里仅介绍其中之一——等待1组描述符准备好读。因此，这里仅需要使用函数<code>select()</code>的2个参数：称为<strong>读集合</strong>的描述符集<code>fdset</code>和读集合的基数
(所有描述符集的最大基数)。函数<code>select()</code>会阻塞，直到读集合中至少有1个描述符准备好读。当前仅当从描述符<code>k</code>读1B的请求不会阻塞时，描述符<code>k</code>才准备好读。</p>
<p>　　函数<code>select()</code>有1个副作用，它会让参数<code>fdset</code>指向<code>fd_set</code>来指示读集合的子集，该子集称为<strong>准备集合</strong>，由准备好读的描述符组成。该函数返回的值表示准备集合的基数。因此，每次调用函数<code>select()</code>时必须更新读集合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* select.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">command</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    fd_set read_set, ready_set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;read_set);              <span class="comment">/* 清空读集合 */</span></span><br><span class="line">    FD_SET(STDIN_FILENO, &amp;read_set); <span class="comment">/* 将标准输入加入读集合 */</span></span><br><span class="line">    FD_SET(listenfd, &amp;read_set);     <span class="comment">/* 将监听描述符加入读集合 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ready_set = read_set;</span><br><span class="line">        Select(listenfd + <span class="number">1</span>, &amp;ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;ready_set))</span><br><span class="line">        &#123;</span><br><span class="line">            command(); <span class="comment">/* 从标准输入读命令行 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;ready_set))</span><br><span class="line">        &#123;</span><br><span class="line">            clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">            connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">            echo(connfd); <span class="comment">/* echo客户端输入，直到EOF */</span></span><br><span class="line">            Close(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">command</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">if</span> (!Fgets(buf, MAXLINE, <span class="built_in">stdin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* EOF */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf); <span class="comment">/* 处理命令 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例通过函数<code>select()</code>来实现能够响应通过键盘输入的命令行的迭代echo服务器。</p>
<p>　　首先，通过函数<code>open_listenfd()</code>来打开监听描述符
(第34行)，调用宏<code>FD_ZERO</code>来创建空的读集合
(第36行)。然后，将描述符0 (标准输入) 和3 (监听描述符)
加入读集合。最后，开始常规的服务器循环，这里调用函数<code>select()</code>来阻塞自己，直到标准输入和监听描述符之一准备好读
(第43行)。函数<code>select()</code>返回后，调用宏<code>FD_ISSET</code>来判断描述符是否准备好读。若标准输入准备好读
(第44行)，则调用函数<code>command()</code>；若监听描述符准备好读
(第48行)，则调用函数<code>accept()</code>和<code>echo()</code>。</p>
<p>　　这个示例有1个问题：一旦它连接客户端，会不断回显输入行，直到客户端关闭其连接端点。因此，若在键盘输入命令到标准输入，则需要在服务器完成服务客户端后才会得到响应，这可以通过每次服务器循环回显最多1行文本来解决。</p>
<h4 id="基于io多路复用的并发事件驱动服务器">12.2.1
基于I/O多路复用的并发事件驱动服务器</h4>
<p>　　I/O多路复用可用于实现并发事件驱动程序，其逻辑流会随着特定事件的完成而进行。基本思想是将逻辑流模型为<strong>状态机</strong>。状态机是状态、输入事件和转换的集合，每个事件将1个输入状态和1个输入事件映射到1个输出状态。<strong>自循环</strong>是输入状态和输出状态相同的转换。状态机通常描述为有向图，节点表示状态，有向弧表示转换，弧标签表示输入事件。状态机在开始执行时有初始状态。每个输入事件会触发从当前状态到下一状态的转换。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_12/state_machine_for_a_logical_flow_in_a_concurrent_event_driven_echo_server.svg" class="">
<p>　　对于每个新的客户端<span
class="math inline">\(k\)</span>，基于I/O多路复用的并发服务器会创建1个新的状态机<span
class="math inline">\(s_k\)</span>并将其关联到描述符<span
class="math inline">\(d_k\)</span>。如图所示，每个状态机<span
class="math inline">\(s_k\)</span>都有1个状态 (等待描述符<span
class="math inline">\(d_k\)</span>准备好读)、输入事件 (描述符<span
class="math inline">\(d_k\)</span>准备好读) 和转换 (从描述符<span
class="math inline">\(d_k\)</span>中读1行文本)。</p>
<p>　　服务器通过I/O多路复用 (由函数<code>select()</code>提供)
来检查输入事件的发生。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* echoservers.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 已连接描述符 (客户端) 池 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> maxfd;                   <span class="comment">/* 读集合中的最大描述符 */</span></span><br><span class="line">    fd_set read_set;             <span class="comment">/* 已启用的描述符集 */</span></span><br><span class="line">    fd_set ready_set;            <span class="comment">/* 准备好读的描述符集*/</span></span><br><span class="line">    <span class="type">int</span> nready;                  <span class="comment">/* 函数select的准备好读的描述符数 */</span></span><br><span class="line">    <span class="type">int</span> maxi;                    <span class="comment">/* 客户端池的最大索引 */</span></span><br><span class="line">    <span class="type">int</span> clientfd[FD_SETSIZE];    <span class="comment">/* 已启用的描述符集 */</span></span><br><span class="line">    <span class="type">rio_t</span> clientrio[FD_SETSIZE]; <span class="comment">/* 已启用的读缓冲区集合 */</span></span><br><span class="line">&#125; pool;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> byte_cnt = <span class="number">0</span>; <span class="comment">/* 服务器接收的字节总数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">static</span> pool pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    init_pool(listenfd, &amp;pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 等待监听/已连接描述符准备好读 */</span></span><br><span class="line">        pool.ready_set = pool.read_set;</span><br><span class="line">        pool.nready = Select(pool.maxfd + <span class="number">1</span>, &amp;pool.ready_set, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若监听描述符准备好读，则将新的客户端加入池中 */</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;pool.ready_set))</span><br><span class="line">        &#123;</span><br><span class="line">            clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">            connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">            add_client(connfd, &amp;pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从每个已连接描述符中回显1行文本行 */</span></span><br><span class="line">        check_clients(&amp;pool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于并发事件驱动echo服务器，客户端集合通过结构体<code>pool</code>来维护。在调用函数<code>init_pool()</code>初始化客户端池后
(第35行)，服务器进入无限循环。在每次迭代时，服务器会调用函数<code>select()</code>来确定2个事件：新客户端的连接请求的到达和已存在客户端的已连接描述符的准备好读。当新客户端的连接请求到达时
(第44行)，服务器会接受连接并调用函数<code>add_client()</code>来将该客户端加入到客户端池
(第47~48行)。最后，服务器调用函数<code>check_clients()</code>来从每个已连接描述符中回显1行文本行
(第52行)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* echoservers.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化客户端池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param listenfd 监听描述符</span></span><br><span class="line"><span class="comment"> * @param p 客户端池指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pool</span><span class="params">(<span class="type">int</span> listenfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始时，没有已连接的描述符 */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始时, 函数select的读集合中只有监听描述符 */</span></span><br><span class="line">    p-&gt;maxfd = listenfd;</span><br><span class="line">    FD_ZERO(&amp;p-&gt;read_set);</span><br><span class="line">    FD_SET(listenfd, &amp;p-&gt;read_set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>init_pool()</code>会初始化客户端池。数组<code>clientfd</code>表示已连接描述符集，整数-1表示有可用的位置。初始时，已连接描述符集是空集合
(第11~15行)，函数<code>select()</code>的读集合中只有监听描述符
(第18~20行)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* echoservers.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将新的客户端加入到客户端池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param connfd 已连接描述符</span></span><br><span class="line"><span class="comment"> * @param p 客户端池指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_client</span><span class="params">(<span class="type">int</span> connfd, pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;nready--;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        <span class="comment">/* 找到可用的位置 */</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;clientfd[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将已连接描述符加入池中 */</span></span><br><span class="line">            p-&gt;clientfd[i] = connfd;</span><br><span class="line">            Rio_readinitb(&amp;p-&gt;clientrio[i], connfd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将该描述符加入函数select的读集合 */</span></span><br><span class="line">            FD_SET(connfd, &amp;p-&gt;read_set);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 更新最大描述符以及相关参数 */</span></span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; p-&gt;maxfd)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;maxfd = connfd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; p-&gt;maxi)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;maxi = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 找不到可用的位置 */</span></span><br><span class="line">        app_error(<span class="string">&quot;add_client error: Too many clients&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>add_client()</code>会将新的客户端加入到客户端池。若在数组<code>clientfd</code>中找到位置，则服务器会将连接描述符加入到该数组并初始化对应的RIO读缓冲区
(第16~17行)。然后，将该已连接描述符加入到函数<code>select()</code>的读集合
(第20行)
并更新客户端池的部分全局属性。变量<code>maxfd</code>表示函数<code>select()</code>的最大文件描述符
(第23~26行)，变量<code>maxi</code>表示数组<code>clientfd</code>中的最大索引。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* echoservers.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 服务客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param p 客户端池指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_clients</span><span class="params">(pool *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, connfd, n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (i &lt;= p-&gt;maxi) &amp;&amp; (p-&gt;nready &gt; <span class="number">0</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        connfd = p-&gt;clientfd[i];</span><br><span class="line">        rio = p-&gt;clientrio[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若描述符准备好读，则从中回显1行文本 */</span></span><br><span class="line">        <span class="keyword">if</span> ((connfd &gt; <span class="number">0</span>) &amp;&amp; (FD_ISSET(connfd, &amp;p-&gt;ready_set)))</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;nready--;</span><br><span class="line">            <span class="keyword">if</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                byte_cnt += n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">                Rio_writen(connfd, buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 检测到EOF，从池中移除描述符 */</span></span><br><span class="line">                Close(connfd);</span><br><span class="line">                FD_CLR(connfd, &amp;p-&gt;read_set);</span><br><span class="line">                p-&gt;clientfd[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>check_clients()</code>会从每个准备好读的已连接描述符中返回1行文本，并将那行文本返回给客户端
(第23~25行)。第23行会维护全局变量<code>byte_cnt</code>来表示从所有客户端接收的总字节数。当客户端关闭连接端点时，服务器会检测到EOF，进而关闭连接端点
(第30行) 并将对应的描述符从客户端池中移除 (第31~32行)。</p>
<p>　　从状态机角度，函数<code>select()</code>用于检测输入事件，函数<code>add_client()</code>用于创建新状态机，函数<code>check_clients()</code>用于执行状态转换
(回显输入行) 和在客户端完成发送文本行时删除状态机。</p>
<h4 id="io多路复用的优点和缺点">12.2.2 I/O多路复用的优点和缺点</h4>
<p>　　I/O多路复用有2个优点和2个缺点。</p>
<p>　　第1个优点是相比进程驱动的设计，事件驱动的设计能让程序员更好地基于程序行为来控制程序。例如，若需要设计优先服务某些客户端的并发服务器，使用进程驱动的设计来实现会比较复杂。</p>
<p>　　第2个优点是基于I/O多路复用的事件驱动服务器可以运行在单个进程的上下文中，所以每个逻辑流都可以访问该进程的地址空间，这样易于逻辑流之间共享数据。运行在单个进程还可以使用GDB等调试工具来像调试顺序程序一样调试并发服务器。此外，事件驱动的设计通常比进程驱动的设计高效很多，因为无需执行进程上下文切换来调度新的逻辑流。</p>
<p>　　第1个缺点是事件驱动的设计的实现代码比较复杂。并发事件驱动echo服务器的代码量是并发进程驱动echo服务器的3倍多。复杂度随着并发粒度
(每个逻辑流在每个时间片上执行的指令数)
的降低而增加。例如，对于12.2.1中的示例，并发粒度就是读1整行文本所需的指令数。当某个逻辑流在读1行文本时，其他逻辑流无法进行，这使得服务器更容易受到恶意客户端的攻击
(仅发送部分文本行，再停止)。修改事件驱动服务器以处理这种攻击并不简单，但进程驱动服务器可以自动处理这种攻击。</p>
<p>　　第2个缺点是事件驱动的设计无法充分利用多核CPU。</p>
<p>　　虽然事件驱动的设计有以上缺点，但Node.js、Nginx和Tornado等现代高性能服务器都是使用基于I/O多路复用的事件驱动来实现，因为相比通过进程或线程来实现，这种方式有良好的性能。</p>
<h3 id="基于线程的并发编程">12.3 基于线程的并发编程</h3>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_12/concurrent_thread_execution.svg" class="">
<p>　　多线程的执行模型与多进程的执行模型有些类似。每个进程的生命周期开始时会有1个进程，称为<strong>主线程</strong>。在某个时刻下，主线程会创建<strong>对等线程</strong>，此时，主线程与对等线程并发运行。一段时间后，主线程会将控制权转移给对等线程
(调用<code>read()</code>和<code>sleep()</code>等慢系统调用或被系统间隔定时器中断)。对等线程执行一段时间后将控制权转移给主线程，依此类推。</p>
<p>　　线程执行与进程执行有一些重要的不同。首先，由于线程上下文比进程上下文小很多，所以线程上下文切换比进程上下文切换快很多。其次，不同于进程组织为严格的父子层次结构，进程关联的线程形成<span
style="background-color: yellow">对等体池</span>，与线程是否由其他线程创建无关。主线程与其他线程的唯一区别是主线程是进程中运行的第1个线程。对等体池的主要作用是某个线程可以终止任意对等体线程或等待任意对等体终止。</p>
<h4 id="posix线程">12.3.1 POSIX线程</h4>
<p>　　POSIX线程定义了大约60种函数来创建线程、终止线程、回收线程、安全地在对等线程之间共享数据和通知对等线程系统状态的改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hello.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，主线程会创建对等线程并等待其终止。对等线程打印<code>Hello, world!\n</code>并终止。当主线程检测到对等线程终止时，会调用函数<code>exit()</code>来终止进程。对等线程的代码称为<strong>线程例程</strong>
(第17~21行)，其输入和输出都是通用指针。若需要给线程例程传递多个参数，则可以将这些参数封装为结构体并将指向该结构体的指针传递给线程例程；若需要线程例程返回多个参数，则可以返回指向结构体的指针。</p>
<p>　　主函数就是主线程的代码。首先，主线程声明局部变量<code>tid</code>来存储对等线程TID并调用函数<code>Pthread_create()</code>来创建对等线程
(第11~12行)，当函数<code>Pthread_create()</code>返回时，对等线程TID会存储在参数<code>tid</code>中且对等线程与主线程并发运行。然后，主线程调用函数<code>Pthread_join()</code>来等待对等线程终止
(第13行)。最后，主线程调用函数<code>exit()</code>来终止进程中的所有线程
(第14行)。</p>
<h4 id="创建线程">12.3.2 创建线程</h4>
<p>　　可以调用函数<code>pthread_create()</code>来创建线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(func)(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tid, <span class="type">pthread_attr_t</span> *attr, func *f, <span class="type">void</span> *arg)</span>; <span class="comment">/* 成功时返回0，出错时返回非0错误码 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">()</span>; <span class="comment">/* 返回调用者TID */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_create()</code>会创建线程并在新线程的上下文中带有参数<code>arg</code>调用线程例程。参数<code>attr</code>可用于改变新线程的默认属性。</p>
<p>　　当函数<code>pthread_create()</code>返回时，参数<code>tid</code>会包含新线程TID。新线程可以调用函数<code>pthread_self()</code>来查看自己TID。</p>
<h4 id="初始化线程">12.3.3 初始化线程</h4>
<p>　　可以调用函数<code>pthread_once()</code>来初始化线程例程的相关状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine)(<span class="type">void</span>))</span>; <span class="comment">/* 总是返回0 */</span></span><br></pre></td></tr></table></figure>
<p>　　变量<code>once_control</code>是全局/静态变量，总是初始化为<code>PTHREAD_ONCE_INIT</code>。第1次带有参数<code>once_control</code>调用函数<code>pthread_once()</code>时，会调用既没输入也没有输出的函数<code>init_routine()</code>。之后带有参数<code>once_control</code>调用函数<code>pthread_once()</code>时，不会做任何事。函数<code>pthread_once()</code>适合初始化多个线程共享的全局变量。</p>
<h4 id="终止和回收线程">12.3.4 终止和回收线程</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>; <span class="comment">/* 成功时返回0，出错时返回非0错误码 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> tid, <span class="type">void</span> **thread_return)</span>; <span class="comment">/* 成功时返回0，出错时返回非0错误码 */</span></span><br></pre></td></tr></table></figure>
<p>　　可以通过以下方式来终止线程：</p>
<p>　　● 当线程的上级线程例程返回时，该线程会<span
style="background-color: yellow">隐式</span>终止。</p>
<p>　　● 调用函数<code>pthread_exit()</code>来显式终止当前线程。</p>
<p>　　●
调用函数<code>exit()</code>来关闭当前进程以及与之关联的所有线程。</p>
<p>　　●
调用函数<code>pthread_cancel()</code>来关闭TID为参数<code>tid</code>的线程。</p>
<p>　　当主线程调用函数<code>pthread_exit()</code>时，会等待所有对等线程终止，再终止主线程，最后整个进程返回<code>thread_return</code>。</p>
<p>　　线程可以调用函数<code>pthread_join()</code>来等待其他线程终止，当前线程会阻塞，直到TID为参数<code>tid</code>的线程终止，然后，将线程例程返回的通用指针<code>void *</code>分配给<code>thread_return</code>指向的位置，最后，回收已终止线程的所有内存资源。</p>
<p>　　不同于函数<code>wait()</code>，函数<code>pthread_join()</code>只会等待1个特定的线程终止，这使得检测进程终止需要使用其他更复杂的机制来实现。</p>
<h4 id="分离线程">12.3.5 分离线程</h4>
<p>　　线程要么是<span
style="background-color: yellow">可合并</span>的，要么是<span
style="background-color: yellow">可分离</span>的。可合并的线程能被其他线程回收或终止，其内存资源不会释放，直到被其他线程回收。相反，可分离的线程不能被其他线程回收或终止，在终止时，其内存资源会被系统自动回收。</p>
<p>　　线程创建时默认是可合并的。为了避免内存泄漏，可合并的线程的内存资源应该显式被其他线程回收或调用函数<code>pthread_detach()</code>来变为可分离的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>; <span class="comment">/* 成功时返回0，出错时返回非0错误码 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_detach()</code>会将TID为参数<code>tid</code>的可合并的线程变为可分离的。</p>
<h4 id="基于线程的并发echo服务器">12.3.6 基于线程的并发echo服务器</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* echoservert.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于线程的并发echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, *connfdp;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfdp = Malloc(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *connfdp = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfdp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> connfd = *((<span class="type">int</span> *)vargp);</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    Free(vargp);</span><br><span class="line">    echo(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　基于线程的并发echo服务器的大体结构与进程驱动的设计相似，主线程等待连接请求并创建对等线程来处理请求。</p>
<p>　　在调用函数<code>pthread_create()</code>时
(第28行)，会将指向已连接描述符的指针<code>connfdp</code>作为参数。在线程例程中，将该指针分配给局部变量
(第34行)。若像之前的示例一样直接使用<code>int</code>来存储已连接描述符会导致对等线程中的赋值语句与主线程中下一次调用函数<code>accept()</code>之间出现<span
style="background-color: yellow">竞争</span>。若前者竞争胜利，则线程例程中局部变量<code>connfd</code>会得到正确的描述符值；若后者竞争胜利，则线程例程中局部变量<code>connfd</code>会得到下一个连接的描述符值。为了避免这种竞争，必须将函数<code>accept()</code>返回的已连接描述符赋值给动态分配的内存块
(第26~27行)。</p>
<p>　　为了避免线程例程中的内存泄漏，这里会将每个线程变为可分离的并释放在主线程中分配的内存块
(第35~36行)。</p>
<h3 id="线程化程序的共享变量">12.4 线程化程序的共享变量</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sharing.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> **ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">char</span> *msgs[N] = &#123;<span class="string">&quot;Hello from foo&quot;</span>, <span class="string">&quot;Hello from bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    ptr = msgs;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, (<span class="type">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line">    Pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myid = (<span class="type">int</span>)vargp;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]: %s (cnt=%d)\n&quot;</span>, myid, ptr[myid], ++cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例中有1个主线程和2个对等线程。主线程会给每个对等线程传递唯一的ID，对等线程通过该ID来输出个性化信息和线程例程被调用的总次数。在第25行，对等线程通过指针<code>ptr</code>来间接引用主线程的栈中的内容。</p>
<p>　　线程化程序中的变量会按照其存储类别映射到虚拟内存：</p>
<p>　　●
全局变量是声明在函数外的变量。在运行时，虚拟内存的读写区域仅包含全局变量的1个实例，例如，第3行声明的指针<code>ptr</code>。当变量仅有1个实例时，可以简单地使用变量名来引用该实例。</p>
<p>　　●
局部自动变量是函数体内声明的变量。在运行时，每个线程的栈都包含所有局部自动变量的私有实例。例如，局部变量<code>tid</code>仅有1个实例，它存储在主线程的栈中，这里用<code>tid.m</code>来表示。局部变量<code>myid</code>有2个实例，分别存储在对等线程1和2的栈中，这里分别用<code>myid.p0</code>和<code>myid.p1</code>来表示。</p>
<p>　　●
局部静态变量是函数体内使用关键字<code>static</code>声明的变量。在运行时，虚拟内存的读写区域仅包含局部静态变量的1个实例。例如，即使每个对等线程都会声明局部静态变量<code>cnt</code>
(第24行)，在运行时，虚拟内存的读写区域仅包含该变量的1个实例，所有对等线程都读写该实例。</p>
<p>　　综上所述，当且仅当变量只有1个实例时，它才是共享的。例如，变量<code>cnt</code>在运行时仅有1个实例，所以它是共享的。变量<code>myid</code>在运行时有2个实例，每个线程引用1个实例，所以它是不共享的。此外，局部自动变量<span
style="background-color: yellow">可能</span>是共享的，例如，第11行声明的<code>msgs</code>。</p>
<h3 id="同步线程与信号量">12.5 同步线程与信号量</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* badcnt.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> niters;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;niters&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    niters = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建线程并等待其结束 */</span></span><br><span class="line">    Pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    Pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查结果 */</span></span><br><span class="line">    <span class="keyword">if</span> (cnt != (<span class="number">2</span> * niters))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;BOOM! cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OK cnt=%ld\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i, niters = *((<span class="type">long</span> *)vargp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会创建2个线程，每个线程都会增加共享变量<code>cnt</code>，<code>cnt</code>的最终值应该是<code>2 * niters</code>，但实际并非如此。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_12/assembly_code_for_the_counter_loop.svg" class="">
<p>　　这里将线程例程中循环部分的汇编代码分为5部分。对于线程<span
class="math inline">\(i\)</span>，<span
class="math inline">\(H_i\)</span>表示循环首部的指令块。<span
class="math inline">\(L_i\)</span>表示将共享变量<code>cnt</code>加载到累加寄存器<code>%rdx</code>的指令。<span
class="math inline">\(U_i\)</span>表示更新寄存器<code>%rdx</code>的指令。<span
class="math inline">\(S_i\)</span>表示将寄存器<code>%rdx</code>更新后的值存回共享变量<code>cnt</code>的指令。<span
class="math inline">\(T_i\)</span>表示循环尾部的指令块。这里<span
class="math inline">\(H_i\)</span>和<span
class="math inline">\(T_i\)</span>操作局部栈变量，<span
class="math inline">\(L_i\)</span>、<span
class="math inline">\(U_i\)</span>和<span
class="math inline">\(S_i\)</span>操作共享变量<code>cnt</code>。</p>
<p>　　当2个对等线程在单核CPU上并发运行时，指令会按照某种顺序执行。每次并发执行会定义2个线程中指令的顺序，其中的某些顺序可能会产生正确的结果，而其他则不会。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>线程</th>
<th>指令</th>
<th style="text-align: left;"><code>%rdx</code> (线程1)</th>
<th style="text-align: left;"><code>%rdx</code> (线程2)</th>
<th style="text-align: left;"><code>cnt</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td><span class="math inline">\(H_1\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td><span class="math inline">\(L_1\)</span></td>
<td style="text-align: left;">0</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td><span class="math inline">\(U_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td><span class="math inline">\(S_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td><span class="math inline">\(H_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td><span class="math inline">\(L_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>7</td>
<td>2</td>
<td><span class="math inline">\(U_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
<td><span class="math inline">\(S_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">2</td>
</tr>
<tr>
<td>9</td>
<td>2</td>
<td><span class="math inline">\(T_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">2</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td><span class="math inline">\(T_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
<p>　　这是首次迭代的正确指令执行顺序。在2个线程都更新共享变量<code>cnt</code>后，其值为2。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>线程</th>
<th>指令</th>
<th style="text-align: left;"><code>%rdx</code> (线程1)</th>
<th style="text-align: left;"><code>%rdx</code> (线程2)</th>
<th style="text-align: left;"><code>cnt</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td><span class="math inline">\(H_1\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td><span class="math inline">\(L_1\)</span></td>
<td style="text-align: left;">0</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td><span class="math inline">\(U_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td><span class="math inline">\(H_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td><span class="math inline">\(L_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td><span class="math inline">\(S_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td><span class="math inline">\(T_1\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
<td><span class="math inline">\(U_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>9</td>
<td>2</td>
<td><span class="math inline">\(S_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td><span class="math inline">\(T_2\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
</tbody>
</table>
<p>　　这是首次迭代的错误指令执行顺序。线程2过早地加载共享变量<code>cnt</code>
(第5步)。</p>
<h4 id="进度图">12.5.1 进度图</h4>
<p>　　<strong>进度图</strong>将<span
class="math inline">\(n\)</span>个并发进程的执行模型化为通过<span
class="math inline">\(n\)</span>维笛卡尔空间的轨迹。轴<span
class="math inline">\(k\)</span>对应线程<span
class="math inline">\(k\)</span>的进度。每个点都对应某个状态。点<span
class="math inline">\(I_k\)</span>表示线程<span
class="math inline">\(k\)</span>已完成指令<span
class="math inline">\(I_k\)</span>。原点对应初始状态，表示没有线程完成指令。</p>
<p>　　进度图将指令执行模型化为从某个状态到其他状态的<strong>过渡</strong>，表示为某个点到相邻点的有向边。过渡只能是向右
(线程1完成指令) 或向上 (线程2完成指令)，不允许对角线过渡
(2个指令同时完成)。程序的执行过程模型化为通过状态空间的<strong>轨迹</strong>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_12/an_example_trajectory.svg" class="">
<p>　　在这个示例中，轨迹对应的指令顺序为<span
class="math inline">\(H_1\)</span>、<span
class="math inline">\(L_1\)</span>、<span
class="math inline">\(U_1\)</span>、<span
class="math inline">\(H_2\)</span>、<span
class="math inline">\(L_2\)</span>、<span
class="math inline">\(S_1\)</span>、<span
class="math inline">\(T_1\)</span>、<span
class="math inline">\(U_2\)</span>、<span
class="math inline">\(S_2\)</span>和<span
class="math inline">\(T_2\)</span>。</p>
<p>　　对于线程<span
class="math inline">\(i\)</span>，操作共享变量<code>cnt</code>的指令<span
class="math inline">\(L_i\)</span>、<span
class="math inline">\(U_i\)</span>和<span
class="math inline">\(S_i\)</span>组成<strong>临界区</strong>。某个线程的临界区不应该与其他线程的临界区重叠，即线程在执行其临界区的指令时，对共享变量有互斥访问权限，这种情况称为<strong>互斥</strong>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_12/safe_and_unsafe_trajectories.svg" class="">
<p>　　在进度图中，2个临界区的交集定义了状态空间的<strong>不安全区域</strong>，不安全区域不包括边界
(例如，状态<span class="math inline">\((H_1,H2)\)</span>和<span
class="math inline">\((S_1,U_2)\)</span>毗邻不安全区域，但并不属于不安全区域)。绕开不安全区域的轨迹称为<strong>安全轨迹</strong>，通过不安全区域的轨迹称为<strong>不安全轨迹</strong>。所有安全轨迹都会正确地更新共享变量<code>cnt</code>。</p>
<p>　　进度图提供了很好的方法来可视化运行在单核CPU上的并发程序和理解同步。但是，进度图并不适用于运行在多核CPU的并发程序。多核CPU的存储系统可以处于与进度图中任何轨迹都不对应的状态。</p>
<h4 id="信号量">12.5.2 信号量</h4>
<p>　　并发编程先驱Edsger Dijkstra (1930~2002，荷兰人)
提出了不同线程的同步问题的经典解决方法之一，该方法基于称为<strong>信号量</strong>的特殊类型变量。信号量<code>s</code>是非负的整数值，只能通过2种特殊操作来控制：<code>P</code>和<code>V</code>。<code>P</code>和<code>V</code>
源于荷兰语proberen (尝试) 和verhogen (增加)。</p>
<p>　　●
<code>P(s)</code>会判断<code>s</code>。若<code>s</code>非0，则将<code>s</code>减1并立即返回；若<code>s</code>是0，则挂起线程，直到<code>s</code>变为非0，然后通过<code>V</code>操作来恢复该线程。在恢复后，<code>P</code>操作将<code>s</code>减1并将控制权转移给调用者。</p>
<p>　　●
<code>V(s)</code>会将<code>s</code>加1。若存在线程阻塞在<code>P</code>操作
(等待<code>s</code>变为非0)，则恢复其中的<span
style="background-color: yellow">1个</span>线程。</p>
<p>　　<code>P</code>中的判断和递减操作是不可分割的。<code>V</code>操作中的递增操作也是不可分割的。V操作并<span
style="background-color: yellow">未定义</span>等待线程的恢复顺序。</p>
<p>　　<code>P</code>和<code>V</code>的定义确保正在运行的程序不会进入正确初始化的信号量为负值的状态，这个属性称为<strong>信号量不变式</strong>，它提供了用于控制并发程序的轨迹的有效工具。</p>
<p>　　POSIX定义了多个函数来操作信号量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="number">0</span>, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* P(s) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* V(s) */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* sem_wait的包装函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">sem_t</span> *s)</span>; <span class="comment">/* sem_post的包装函数 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sem_init()</code>会将信号量<code>sem</code>初始化为<code>value</code>
(这里将第2个参数直接设置为0)，在使用信号量前必须先将其初始化。可以调用函数<code>sem_wait()</code>和<code>sem_post()</code>来执行<code>P</code>和<code>V</code>操作，为了简洁，这里使用它们的包装函数。</p>
<h4 id="使用信号量来互斥">12.5.3 使用信号量来互斥</h4>
<p>　　信号量提供了便利的方法来实现共享变量的互斥访问。基本思想是将每个共享变量与1个初始值为1的信号量关联，然后将对应的临界区用<code>P</code>和<code>V</code>操作包围起来。</p>
<p>　　用于实现共享变量的互斥访问的信号量称为<strong>二进制信号量</strong>
(因为其值只能是0和1)
或<strong>互斥锁</strong>。执行<code>V</code>操作的过程称为<strong>解锁</strong>。已上锁的线程<strong>持有</strong>锁。用作可用资源计数器的信号量称为<strong>计数信号量</strong>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_12/using_semaphores_for_mutual_exclusion.svg" class="">
<p>　　以同步12.5中的计数器程序为例，这里每个状态都标上了对应的<code>s</code>值，其关键思想是<code>P</code>和<code>V</code>操作的结合产生了称为<strong>禁止区域</strong>的状态集，其中<code>s</code>的值为负。由于信号量非负，所有可行的轨迹都不能通过禁止区域。由于禁止区域包含不安全区域，所以所有可行的轨迹都是安全的，无论指令运行时以何种顺序执行，程序总能正确地增加计数器。</p>
<p>　　首先，声明互斥锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> cnt = <span class="number">0</span>; <span class="comment">/* 计数器 */</span></span><br><span class="line"><span class="type">sem_t</span> mutex;           <span class="comment">/* 包含计数器的信号量 */</span></span><br></pre></td></tr></table></figure>
<p>　　然后，在主函数将信号量初始化为1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>　　最后，将线程例程中共享变量<code>cnt</code>的更新用<code>P</code>和<code>V</code>操作包围起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++)</span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用信号量来调度共享资源">12.5.4 使用信号量来调度共享资源</h4>
<p>　　除了提供互斥访问，信号量的另一个重要用途是调度共享资源的访问。在这种情况下，线程通过信号量操作来通知其他线程程序状态中某些条件变为真，例如，生产者-消费者问题和读者-写者问题。</p>
<h5 id="生产者-消费者问题">12.5.4.1 生产者-消费者问题</h5>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_12/producer-consumer_problem.svg" class="">
<p>　　生产者线程和消费者线程共享<span
style="background-color: yellow">有限</span>缓冲区。生产者线程反复生成新项并将其放入缓冲区。消费者线程反复从缓冲区取出项并使用。此外，可能出现多个生产者和消费者的情况。</p>
<p>　　由于放入和取出项涉及更新共享变量，必须确保对缓冲区的互斥访问，但这还不够，还需要调度缓冲区的访问。若缓冲区已满，则生产者线程必须等待缓冲区中有空位；若缓冲区为空，则消费者必须等待缓冲区中有可用项。</p>
<p>　　这里将实现包<code>SBUF</code>，用于实现生产者-消费者程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sbuf.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> *buf;    <span class="comment">/* 缓冲区数组 */</span></span><br><span class="line">    <span class="type">int</span> n;       <span class="comment">/* 缓冲区大小 */</span></span><br><span class="line">    <span class="type">int</span> front;   <span class="comment">/* 第1个项buf[(front+1)%n] */</span></span><br><span class="line">    <span class="type">int</span> rear;    <span class="comment">/* 最后1个项buf[rear%n] */</span></span><br><span class="line">    <span class="type">sem_t</span> mutex; <span class="comment">/* 互斥锁 */</span></span><br><span class="line">    <span class="type">sem_t</span> slots; <span class="comment">/* 缓冲区的可用空位数 */</span></span><br><span class="line">    <span class="type">sem_t</span> items; <span class="comment">/* 缓冲区的可用项数 */</span></span><br><span class="line">&#125; <span class="type">sbuf_t</span>;</span><br></pre></td></tr></table></figure>
<p>　　<code>SBUF</code>通过结构体<code>sbuf_t</code>来操作缓冲区。项存储在大小为<code>n</code>的动态分配的整数数组<code>buf</code>中。<code>front</code>和<code>rear</code>表示数组中第1个和最后1个项。3个信号量用于同步缓冲区的访问，<code>mutex</code>提供缓冲区的互斥访问，<code>slots</code>和<code>items</code>分别计算缓冲区中可用空位和可用项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sbuf.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 生成带有n个空位的FIFO缓冲区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param n 缓冲区大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    sp-&gt;n = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">/* 互斥锁 */</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, <span class="number">0</span>, n); <span class="comment">/* 缓冲区初始化有n个空位  */</span></span><br><span class="line">    Sem_init(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">/* 缓冲区初始化没有数据项 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放缓冲区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将项放入到缓冲区的尾部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param item 项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);                          <span class="comment">/* 等待可用空位 */</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                          <span class="comment">/* 对缓冲区上锁 */</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item; <span class="comment">/* 放入项 */</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                          <span class="comment">/* 解锁缓冲区 */</span></span><br><span class="line">    V(&amp;sp-&gt;items);                          <span class="comment">/* 更新可用项 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从缓冲区的头部取出项</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sp 缓冲区指针</span></span><br><span class="line"><span class="comment"> * @return int 取出的项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);                           <span class="comment">/* 等待可用空位 */</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                           <span class="comment">/* 对缓冲区上锁 */</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)]; <span class="comment">/* 取出项 */</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                           <span class="comment">/* 解锁缓冲区 */</span></span><br><span class="line">    V(&amp;sp-&gt;slots);                           <span class="comment">/* 更新可用空位 */</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>sbuf_init()</code>会给缓冲区分配堆空间，设置<code>front</code>和<code>rear</code>以及初始化3个信号量，该函数在调用其他3个函数前会被调用1次。函数<code>sbuf_deinit()</code>会释放缓冲区。函数<code>sbuf_insert()</code>会等待空位，对缓冲区上锁，放入项，解锁缓冲区并更新可用项数。函数<code>sbuf_remove()</code>会等待可用项，对缓冲区上锁，取出项，解锁缓冲区并更新可用空位数。</p>
<h5 id="读者-写者问题">12.5.4.2 读者-写者问题</h5>
<p>　　读者-写者问题是互斥问题的综合。1组并发线程访问同一共享变量，例如，内存中的某个数据结构和磁盘上的某个数据库。部分线程只会读对象，其他线程会修改对象，前者称为<span
style="background-color: yellow">读者</span>，后者称为<span
style="background-color: yellow">写者</span>。写者必须互斥地访问对象，读者可能会与其他任意数量的读者共享对象。读者和写者的数量通常可以是任意个。</p>
<p>　　读者-写者问题有多个变体，都基于读者和写者的优先级。</p>
<p>　　●
对于偏向于读者的读者-写者问题，读者无须等待，除非有写者已被授权使用该对象，即读者不应该因为写者在等待而等待。</p>
<p>　　●
对于偏向于写者的读者-写者问题，一旦写者准备好写，就会尽快开始。若读者在写者后到达，即使写者在等待，读者也必须等待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 全局变量 */</span></span><br><span class="line"><span class="type">int</span> readcnt;    <span class="comment">/* 初始值为0 */</span></span><br><span class="line"><span class="type">sem_t</span> mutex, w; <span class="comment">/* 初始值都为1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">1</span>) <span class="comment">/* 先进 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            P(&amp;w);</span><br><span class="line">        &#125;</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        <span class="comment">/* 执行读操作 */</span></span><br><span class="line"></span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span> (readcnt == <span class="number">0</span>) <span class="comment">/* 后出 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            V(&amp;w);</span><br><span class="line">        &#125;</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;w);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        <span class="comment">/* 执行写操作 */</span></span><br><span class="line"></span><br><span class="line">        V(&amp;w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是第1个读者-写者问题的解决方法。信号量<code>w</code>控制临界区的访问。信号量<code>mutex</code>控制共享变量<code>cnt</code>的访问，该变量用于给当前正在访问临界区的读者计数。写者每次访问临界区时都会上锁并在完成访问时解锁，这保证了同时最多有1个写者访问临界区。只有第1个读者访问临界区时才会上锁，并且只有最后1个读者完成访问时才会解锁，中间的读者可以无视锁。这表示<span
style="background-color: yellow">只要有读者持有锁</span>，其他读者可以直接访问临界区而无需等待。</p>
<p>　　这2个读者-写者问题的解决方法都会导致<strong>饥荒</strong>，即线程无期限地阻塞。例如，第1个读者-写者问题会可能导致大量读者到达时，写者长时间等待。</p>
<h4 id="基于预线程的并发服务器">12.5.5 基于预线程的并发服务器</h4>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_12/organization_of_a_prethreaded_concurrent_server.svg" class="">
<p>　　基于<strong>预线程</strong>的服务器可以通过生产者-消费者模型来减少创建新线程的成本，该服务器有1个主线程和多个工作线程。主线程反复接收客户端的连接请求并将作为结果的描述符放入缓冲区。工作线程反复从缓冲区取出描述符，服务客户端并等待下一个描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* echoservert-pre.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sbuf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUFSIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sbuf_t</span> sbuf; <span class="comment">/* 共享的已连接描述符缓冲区 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基于预线程的并发echo服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>); <span class="comment">/* 创建工作线程 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd); <span class="comment">/* 将已连接描述符放入缓冲区 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> connfd = sbuf_remove(&amp;sbuf); <span class="comment">/* 从缓冲区取出已连接描述符 */</span></span><br><span class="line">        echo_cnt(connfd);                <span class="comment">/* 服务客户端 */</span></span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会使用包<code>SBUF</code>来实现基于预线程的并发echo服务器。在初始化缓冲区<code>sbuf</code>后
(第28行)，主线程会创建工作线程
(第29~32行)，开始无限循环，接收连接请求并将作为结果的已连接描述符放入缓冲区。工作线程会一直等待，直到缓冲区中有可用已连接描述符，然后从缓冲区取出已连接描述符
(第47行) 并调用函数<code>echo_cnt()</code>来回显客户端输入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* echo-cnt.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> byte_cnt; <span class="comment">/* 字节计数器 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">sem_t</span> mutex;  <span class="comment">/* 字节计数器的互斥锁 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_echo_cnt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    byte_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 计算从所有客户端接收的字节总数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param connfd 已连接描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo_cnt</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line">    Pthread_once(&amp;once, init_echo_cnt);</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        byte_cnt += n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d (%d total) bytes on fd %d\n&quot;</span>, n, byte_cnt, connfd);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>echo_cnt()</code>会通过全局变量<code>byte_cnt</code>来计算从所有客户端接收的字节总数。这里需要初始化计数器<code>byte_cnt</code>和信号量<code>mutex</code>，可以通过包<code>SBUF</code>和<code>RIO</code>来初始化
(需要主线程显式调用1次初始化函数)，这里通过函数<code>pthread_once()</code>来初始化
(第22行)。这种初始化方法的优点是易用，缺点是每次调用函数<code>echo_cnt()</code>也会调用函数<code>pthread_once()</code>
(大多数对函数<code>pthread_once()</code>的调用都是无效的)。</p>
<p>　　初始化后，函数<code>pthread_once()</code>会初始化包<code>RIO</code>的缓冲区
(第23行)
并回显从客户端收到的每行文本。共享变量<code>byte_cnt</code>的访问是互斥的
(第26~29行)。</p>
<p>　　实现事件驱动并非只能通过I/O多路复用，预线程也可以用于实现事件驱动。对于这里的示例，主线程有2个状态
(等待连接请求和等待可用缓冲区空位)、2个I/O事件
(连接请求到达和缓冲区中有可用空位) 和2个转换
(接收连接请求和将描述符放入缓冲区)。工作线程有1个状态
(等待缓冲区中的可用描述符)、1个I/O事件 (缓冲区中有可用描述符) 和1个转换
(从缓冲区取出描述符)。</p>
<h3 id="使用线程来实现并行">12.6 使用线程来实现并行</h3>
<p>　　以并行地计算0到<span class="math inline">\(n-1\)</span>这<span
class="math inline">\(n\)</span>个数的和为例，最直接的方法是将这<span
class="math inline">\(n\)</span>个数分为<span
class="math inline">\(t\)</span>组，然后让<span
class="math inline">\(t\)</span>个线程分别计算这<span
class="math inline">\(t\)</span>组。此外，假设<span
class="math inline">\(n\)</span>是<span
class="math inline">\(t\)</span>的整数倍，所以每组有<span
class="math inline">\(\frac{n}{t}\)</span>个元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* psum-mutex.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTHREADS 32</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sum_mutex</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局共享变量 */</span></span><br><span class="line"><span class="type">long</span> gsum = <span class="number">0</span>;          <span class="comment">/* 总和 */</span></span><br><span class="line"><span class="type">long</span> nelems_per_thread; <span class="comment">/* 每个线程中参与计算的元素数 */</span></span><br><span class="line"><span class="type">sem_t</span> mutex;            <span class="comment">/* 总和的互斥锁 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通过多线程来计算多个元素序列的和</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i, nelems, log_nelems, nthreads, myid[MAXTHREADS];</span><br><span class="line">    <span class="type">pthread_t</span> tid[MAXTHREADS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;nthreads&gt; &lt;log_nelems&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nthreads = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    log_nelems = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    nelems = (<span class="number">1L</span> &lt;&lt; log_nelems);</span><br><span class="line">    nelems_per_thread = nelems / nthreads;</span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建对等线程并等待它们结束 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        myid[i] = i;</span><br><span class="line">        Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, sum_mutex, &amp;myid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查总和 */</span></span><br><span class="line">    <span class="keyword">if</span> (gsum != (nelems * (nelems - <span class="number">1</span>)) / <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: result=%ld\n&quot;</span>, gsum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　最直白的实现方法是让线程通过共享变量来计算总和。在第38~46行，主线程创建对等线程并等待它们终止，这里主线程给每个对等线程都传递了ID来作为其TID。每个对等线程会通过其TID来决定它应该计算序列的哪个组。最后，主线程通过封闭解来验证结果
(第49~52行)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* psum-mutex.c的线程例程 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sum_mutex</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> myid = *((<span class="type">long</span> *)vargp);          <span class="comment">/* 提取TID */</span></span><br><span class="line">    <span class="type">long</span> start = myid * nelems_per_thread; <span class="comment">/* 开始元素索引 */</span></span><br><span class="line">    <span class="type">long</span> end = start + nelems_per_thread;  <span class="comment">/* 结束元素索引 */</span></span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        gsum += i;</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在函数<code>sum_mutex()</code>中，第3行会从参数中提取TID并通过TID来决定它应该计算序列的哪个组
(第4~5行)。第8~13行会迭代求和。</p>
<p>　　当在4核CPU上对有<span
class="math inline">\(2^{32}\)</span>个元素的序列调用函数<code>sum_mutex()</code>时，可以得到以下结果：</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>函数<code>sum_mutex()</code>运行时间 (单位是s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>68</td>
</tr>
<tr>
<td>2</td>
<td>432</td>
</tr>
<tr>
<td>4</td>
<td>719</td>
</tr>
<tr>
<td>8</td>
<td>552</td>
</tr>
<tr>
<td>16</td>
<td>599</td>
</tr>
</tbody>
</table>
<p>　　在这种情况下，程序并行运行比单线程运行的效率低很多，并且效率会随着核的数量增加继续降低，这是因为同步操作的开销很大。因此，<span
style="background-color: yellow">应尽量避免使用同步操作</span>，若无法避免，则通过尽可能多有用的计算来摊销。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* psum-local.c的线程例程 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sum_local</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> myid = *((<span class="type">long</span> *)vargp);          <span class="comment">/* 提取TID */</span></span><br><span class="line">    <span class="type">long</span> start = myid * nelems_per_thread; <span class="comment">/* 开始元素索引 */</span></span><br><span class="line">    <span class="type">long</span> end = start + nelems_per_thread;  <span class="comment">/* 结束元素索引 */</span></span><br><span class="line">    <span class="type">long</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    psum[myid] = sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　避免在线程例程中使用同步操作的方法之一是让对等线程用局部变量来计算每个组的和，这里是在主线程中定义了全局数组<code>psum</code>，对等线程将对应组的和存储在数组<code>psum</code>中的索引为自身TID的元素中。最后，主线程只需计算数组<code>psum</code>中的元素的和。</p>
<p>　　当在4核CPU上对有<span
class="math inline">\(2^{32}\)</span>个元素的序列调用函数<code>sum_local()</code>时，可以得到以下结果：</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>函数<code>sum_local()</code>运行时间 (单位是s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1.06</td>
</tr>
<tr>
<td>2</td>
<td>0.54</td>
</tr>
<tr>
<td>4</td>
<td>0.28</td>
</tr>
<tr>
<td>8</td>
<td>0.29</td>
</tr>
<tr>
<td>16</td>
<td>0.30</td>
</tr>
</tbody>
</table>
<p>　　在理想情况下，运行时间应该随着线程数的增加而线性减少，即每次都减少一半。但事实并非如此，因为在<span
style="background-color: yellow">同一核上进行线程上下文需要额外的时间</span>。因此，并行程序通常被实现为每个核1个线程。</p>
<p>　　并行程序的<strong>加速比</strong>定义为<span
class="math inline">\(S_p=\frac{T_1}{T_p}\)</span>，该公式也称为<strong>强缩放</strong>。<span
class="math inline">\(p\)</span>是CPU核心数，<span
class="math inline">\(T_p\)</span>是程序在<span
class="math inline">\(p\)</span>核CPU上的运行时间。当<span
class="math inline">\(T_1\)</span>是并行程序的顺序版本的运行时间时，<span
class="math inline">\(S_p\)</span>是<strong>绝对加速比</strong>。当<span
class="math inline">\(T_1\)</span>是并行程序在单核CPU上的运行时间时，<span
class="math inline">\(S_p\)</span>是<strong>相对加速比</strong>。相比相对加速比，绝对加速比能更真实地衡量并行的提升。</p>
<p>　　即使并行程序在单核CPU上运行，也需要受到同步操作的影响
(即增加相对加速比)，因为它会增加加速比公式的分子。绝对加速比相对加速比更难以衡量，因为绝对加速比需要2个版本的程序。对于复杂的并行代码，编写对应的顺序代码并非易事。</p>
<p>　　<strong>效率</strong>是加速比的相关度量之一，定义为<span
class="math inline">\(E_p=\frac{S_p}{p}=\frac{T_1}{pT_p}\)</span>，其取值范围是
(0,1]。效率用于衡量并行的影响。相比低效率的程序，高效率的程序将更多的时间用在执行有用的工作，将更少的时间用在同步和通信上。</p>
<p>　　函数<code>sum_local()</code>的加速比和效率如下：</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 28%" />
<col style="width: 36%" />
<col style="width: 13%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>线程数<span class="math inline">\(t\)</span></th>
<th>CPU核心数<span class="math inline">\(p\)</span> (实际使用)</th>
<th>函数<code>sum_local()</code>运行所需<span
class="math inline">\(T_p\)</span></th>
<th>加速比<span class="math inline">\(S_p\)</span></th>
<th>效率<span class="math inline">\(E_p\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1.06</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0.54</td>
<td>1.9</td>
<td>0.98</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>0.28</td>
<td>3.8</td>
<td>0.95</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>0.29</td>
<td>3.7</td>
<td>0.91</td>
</tr>
<tr>
<td>16</td>
<td>4</td>
<td>0.30</td>
<td>3.5</td>
<td>0.88</td>
</tr>
</tbody>
</table>
<p>　　这里展示的示例的效率都很高，但实际中并非如此。数十年来，并行编程一直都是活跃的研究领域。</p>
<p>　　除了强缩放，另一种加速比的理解是<strong>弱缩放</strong>，它让问题的大小随着CPU核心数的增加而增加，即随着CPU核心数的增加，每个核心上执行的工作量保存不变。在这种情况下，加速比和效率表示为单位时间内完成的工作量。例如，若在将CPU核心数加倍后，完成的工作量也能加倍，则加速比是线性的，效率是1。</p>
<p>　　弱缩放通常比强缩放更符合实际情况，因为它能更准确地表达用更好的机器去完成更多的工作的愿景。但是，对于那些工作量不易轻易增加的程序，强缩放更合适。例如，实时信号处理函数的工作量通常由产生信号的物理传感器来决定，这类程序通常通过并行来尽快完成固定量的工作。</p>
<h3 id="其他并行问题">12.7 其他并行问题</h3>
<p>　　同步会导致一些顺序程序中根本不会出现的问题，这里主要介绍线程安全和可重入性的相关问题。</p>
<h4 id="线程安全">12.7.1 线程安全</h4>
<p>　　当且仅当函数被多个线程反复调用且都产生正确的结果时，该函数才是<span
style="background-color: yellow">线程安全</span>的。线程不安全的函数可以分为4类：<span
style="background-color: yellow">不保护共享变量的函数</span>、<span
style="background-color: yellow">多个调用中保持状态的函数</span>、<span
style="background-color: yellow">返回静态变量指针的函数</span>、<span
style="background-color: yellow">调用线程不安全的函数的函数</span>。</p>
<p>　　●
不保护共享变量的函数很容易变为线程安全，只需要将共享变量用同步操作来保护起来。这种方法的优点是调用者无需进行任何更改，缺点是同步操作会降低性能。</p>
<p>　　●
线程不安全的伪随机数生成器就是多个调用中保持状态的函数的简单示例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> next_seed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回0~32767内的伪随机整数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return unsigned </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">rand</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    next_seed = next_seed * <span class="number">1103515245</span> + <span class="number">12543</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span>)(next_seed &gt;&gt; <span class="number">16</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置函数rand的种子</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param new_seed 种子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> new_seed)</span></span><br><span class="line">&#123;</span><br><span class="line">    next_seed = new_seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>rand()</code>是线程不安全的，因为本次调用的结果取决于上次调用产生的结果。当在单线程中调用函数<code>srand()</code>来设置种子并反复调用函数<code>rand()</code>时，得到的结果是符合预期的。但当多个线程调用函数<code>rand()</code>时，得到的结果就不再符合预期。</p>
<p>　　将函数<code>rand()</code>改为线程安全的方法是不再使用静态数据，而是调用者将状态信息作为参数传递。这种方法的缺点是必须修改代码。</p>
<p>　　●
<code>ctime</code>和<code>gethostbyname</code>等函数会将结果存储在静态变量中，然后返回指向该静态变量的指针。若在并发线程中调用这类函数会导致严重后果，因为返回的结果可能会被其他线程覆盖。</p>
<p>　　将此类函数变为线程安全的函数有2种方法。第1种方法是重写函数，调用者传递某个变量的地址，函数将结果保存在该变量中。第2种方法是使用<span
style="background-color: yellow">上锁并复制</span>技术，即每次调用前先上锁，然后将结果复制到私有内存中，最后解锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief C标准库函数ctime的线程安全的包装函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timep</span></span><br><span class="line"><span class="comment"> * @param privatep</span></span><br><span class="line"><span class="comment"> * @return char*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime_ts</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="type">char</span> *privatep)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *sharedp;</span><br><span class="line"></span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    sharedp = ctime(timep);</span><br><span class="line">    <span class="built_in">strcpy</span>(privatep, sharedp); <span class="comment">/* 将字符串复制到私有区域 */</span></span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> privatep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于第2种方法，为了修改最少的代码，应使用对应的线程安全的包装函数，并将对原来函数的调用修改为对包装函数的调用。</p>
<p>　　●
对于调用线程不安全的函数<code>g()</code>的函数<code>f()</code>，若函数<code>g()</code>是多个调用中保持状态的函数，则只能重写函数<code>g()</code>来让函数<code>f()</code>变为线程安全的；若函数<code>g()</code>是其他类型的线程不安全的函数，则可以用上锁并复制技术来让函数<code>f()</code>变为线程安全的。</p>
<h4 id="可重入性">12.7.2 可重入性</h4>
<p>　　<strong>可重入的函数</strong>是重要的线程安全的函数之一，其特点是当它们被多个线程调用时，它们<span
style="background-color: yellow">不会引用任何共享数据</span>。</p>
<p>　　可重入的函数比非可重入的线程安全的函数更高效，因为它无需同步操作。将多个调用中保持状态的函数变为线程安全的函数的唯一方法是将其重写为可重入的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数rand的可重入的版本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param nextp</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand_r</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *nextp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *nextp = *nextp * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(*nextp / <span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是函数<code>rand()</code>的可重入的版本，关键思想是将共享变量<code>next_seed</code>替换为作为参数的指针。</p>
<p>　　对于可重入函数，若所有的函数参数都是值传递 (即没有指针)
且所有的数据引用都是指向局部自动栈变量，则该函数是<span
style="background-color: yellow">显式可重入</span>的；若将条件放宽到所有的函数参数可以有引用传递
(即有指针)，则该函数是<span
style="background-color: yellow">隐式可重入</span>的。例如，函数<code>rand_r()</code>就是隐式可重入的。</p>
<h4 id="竞争">12.7.3 竞争</h4>
<p>　　当程序的正确执行需要线程A的控制流在线程B的控制流到达<span
class="math inline">\(y\)</span>点前到达<span
class="math inline">\(x\)</span>点时，就会出现<span
style="background-color: yellow">竞争</span>。竞争的出现通常是程序员假设线程将在执行状态空间中按照特定的轨迹执行，而这与程序必须能适用于所有可行的轨迹相矛盾。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* race.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[N];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, &amp;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myid = *((<span class="type">int</span> *)vargp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d\n&quot;</span>, myid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，主线程会创建4个对等线程并会给对等线程传递指向唯一整数ID的指针。对等线程将参数复制到局部变量并输出包含该ID的字符串
(第27~28行)。</p>
<p>　　当主线程创建对等线程并传递指针给该对等线程时
(第16行)，竞争出现在<code>i</code>的增加 (第14行) 与参数的解引用和赋值
(第27行)。若前者先执行，则得到其他线程的ID；若后者先执行，则得到正确的ID。是否得到正确的ID完全取决于内核如何调度线程的执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* norace.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[N];</span><br><span class="line">    <span class="type">int</span> i, *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = Malloc(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *ptr = i;</span><br><span class="line">        Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myid = *((<span class="type">int</span> *)vargp);</span><br><span class="line">    Free(vargp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %d\n&quot;</span>, myid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　为了消除竞争，可以给每个ID动态分配空间并将对应的指针传递给线程例程
(第16~18行)，线程例程需要释放对应的空间 (第30行)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread, (<span class="type">void</span> *)i);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="type">int</span> myid = (<span class="type">int</span>)vargp;</span><br></pre></td></tr></table></figure>
<p>　　另一种消除竞争的方法是将<code>i</code>转换成指针并作为参数传递给线程例程，然后线程例程将参数转换为<code>int</code>。这种方法无需分配和释放空间，但需要指针的长度至少和<code>int</code>的长度相同。</p>
<h4 id="死锁">12.7.4 死锁</h4>
<p>　　信号量引入了称为<strong>死锁</strong>的运行时错误，即1组线程阻塞，等待永远不会为真的条件。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_12/progress_graph_for_a_program_that_can_deadlock.svg" class="">
<p>　　在这个示例中，2个线程使用2个信号量来进行互斥。若按照错误的顺序使用<code>P</code>和<code>V</code>操作，则2个信号量的禁止区域会有重叠。重叠的禁止区域包括1组<strong>死锁状态</strong>
(即<strong>死锁区域</strong>)。若某些轨迹碰巧到达死锁状态，则这2个线程都会等待对方执行<code>V</code>操作。</p>
<p>　　可以通过<span
style="background-color: yellow">互斥锁排序原则</span>来避免死锁，即规定所有互斥锁的总顺序，线程按序申请互斥锁，并按反序释放互斥锁。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第11章 网络编程</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_11/</url>
    <content><![CDATA[<p>　　互联网起源于1957年，正处于冷战最激烈的时期，苏联第1颗人造卫星的发射震惊世界。作为响应，美国成立了高级研究计划署
(ARPA)，其任务是重建美国在科学和技术上领导地位。1967年，ARPA的Lawrence
Roberts提出了建立ARPANET网络的计划。第1个ARPANET节点在1969年建立并运行。到1971年，已有13个ARPANET节点，电子邮件作为其第1个重要的网络应用出现。</p>
<p>　　1972年，Robert Kahn提供了互联网的基本原则：1组互联的网络通过称为
"路由器" 的黑盒子按照 "尽力而为原则"
在相互独立处理的网络间通信。1974年，Kahn和Vinton
Cerf发表了TCP/IP的第1本详细资料，到1982年，它成为了ARPANET的标准网络互联协议。1983年1月1日，ARPANET的每个节点都切换到了TCP/IP，这标志着全球互联网的诞生。</p>
<p>　　1985年，Paul
Mockapetris发明了DNS，此时，有1000多台主机。1986年，(美国)
国家科学基金会 (NFS)
用56KB/s的电话线连接了13个节点来构建NSFNET的骨干网，其速率在1988年升级到1.5MB/s，1991年又升级到45MB/s。1988年，有超过50000台主机。1989年，原始ARPANET正式退休。1995年，有几乎千万台主机，此时，NSF取消了NSFNET并用现代互联网架构取代它，该架构基于公共网络接入点连接的私有商业骨干网。</p>
<p>　　所有网络应用程序都基于<strong>客户端-服务器</strong>模型。在该模型中，有1个服务器进程和若干个客户端进程。服务器管理一些<span
style="background-color: yellow">资源</span>并通过控制这些资源来为客户端提供一些服务。例如，Web服务器管理1组磁盘文件并代表客户端检索和执行这些文件。</p>
<p>　　Web客户端和服务器通过基于文本的应用层协议HTTP来通信。HTTP是简单的协议。Web客户端
(即浏览器)
打开到服务器的连接并请求一些内容，然后，服务器响应内容并关闭连接，最后，浏览器读取内容并显示在屏幕上。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_11/a_client-server_transaction.svg" class="">
<p>　　客户端-服务器模型中的基本操作是<strong>事务</strong>
(这里的事务和数据库里的事务毫无关联)，它是客户端和服务器执行的一系列步骤。</p>
<p>　　1)
当客户端需要服务时，它通过发送<strong>请求</strong>给服务器来初始化事务。例如，浏览器需要某个文件，它会发送请求给Web服务器。</p>
<p>　　2)
服务器收到请求，解析它并通过合适的方式操作其资源。例如，当Web服务器收到浏览器的请求，它会读磁盘文件。</p>
<p>　　3)
服务器发送<strong>响应</strong>给客户端，然后等待下一个请求。例如，Web服务器将文件发回给浏览器。</p>
<p>　　4)
客户端收到响应并处理。例如，浏览器收到来自服务器的页面并将其显示到屏幕上。</p>
<span id="more"></span>
<p>　　客户端和服务器是<span
style="background-color: yellow">进程</span>而非主机。1个主机可以同时运行多个不同的客户端和服务器。1个事务可以在相同或不同的主机上。客户端-服务器模型与客户端和服务器到主机的映射无关。</p>
<p>　　全球IP互联网最早起源于1969年。虽然互联网的内部架构很复杂且不断变化，但自20世纪80年代以来，客户端-服务器应用程序的组织一直保存着非常稳定的状态。</p>
<p>　　所有互联网主机都运行实现<span
style="background-color: yellow">TCP/IP</span>的软件。互联网客户端和服务器通过<strong>套接字接口</strong>和UNIX
I/O函数来通信。套接字函数通常被实现为嵌入内核的系统调用，它能调用TCP/IP中的各种内核模式函数。</p>
<p>　　最初的套接字接口是加州大学伯克利分校的研究人员在20世纪80年代早期开发的，所以也称为伯克利套接字。伯克利分校的研究人员开发的套接字接口适用于所有底层协议。第1个实现是针对TCP/IP，该实现包含在UNIX
4.2 BSD的内核中，并且分发给了很多大学和实验室。</p>
<p>　　瑞士物理实验室CERN的软件工程师Tim
Berners-Lee发明了万维网。1989年，Berners-Lee开发了1个内部备忘录，提出了能连接
"用链接组成的笔记网络"
的分布式超文本系统，该系统旨在帮助CERN的科学家分享和管理信息。在之后的2年内，在Berners-Lee实现了第1个Web服务器和浏览器后，在CERN内部和其他一些网站中，Web拥有了小规模的拥护者。1993年，Marc
Andreesen (之后成立Netscape和Andreessen Horowitz)
和他在NCSA的同事发布了图形化的浏览器MOSAIC，该浏览器可用于Linux、Windows和Macintosh。自此以后，Web网站以每年10倍或更高的数量暴增。</p>
<p>　　互联网的官方信息资源存储在1组可免费获取的带编号的文档中，这些文档称为<span
style="background-color: yellow">请求评论</span> (RFC)。</p>
<h3 id="网络">11.1 网络</h3>
<p>　　客户端和服务器通常运行在不同的主机上，通过<strong>计算机网络</strong>的硬件和软件资源来通信。网络是复杂的系统，这里只介绍一些简单的内容。</p>
<p>　　对于主机，网络只是I/O设备，作为数据的源和接收器。插在I/O总线扩展槽的网络适配器提供网络的物理接口。从网络接收的数据会从适配器通过I/O和内存总线复制到内存，通常通过DMA传输。同样，也能从内存复制到网络。</p>
<p>　　从物理角度，网络是按地理邻近性组织的层次结构系统。最底层是跨越建筑或校区的<strong>局域网</strong>
(LAN)。迄今为止最流行的LAN技术是在Xerox
PARC于20世纪70年代中期开发的<strong>以太网</strong>。以太网有出色的弹性，支持的速率从3Mb/s到10Gb/s。</p>
<p>　　<strong>以太网段</strong>由1组电缆 (通常是双绞线)
和1个称为<strong>集线器</strong>的小盒子组成。以太网段通常跨越房间或楼层等较小的区域。每根电缆都有相同的最大位带宽，通常是100Mb/s或1Gb/s。电缆的一端连接着主机的网络适配器，另一端连接着集线器上的<strong>端口</strong>。集线器将端口收到的每个位直接复制到所有其他端口。因此，每个端口都能看到每个位。</p>
<p>　　每个以太网适配器都有存储在内置非易失存储器中的全球唯一的48位地址。主机可以发送1组位
(称为<strong>帧</strong>)
到以太网段上的其他主机。每个帧都有固定的首部字段来表示其源、目的地和大小，其后是存储数据的有效载荷。每个主机适配器都可以看到帧，但只有对应的目的主机能读。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_11/bridged_ethernet_segments.svg" class="">
<p>　　多个以太网段可以通过1组电缆和称为<strong>网桥</strong>的小盒子来连接到更大的以太网中，称为<strong>桥接以太网</strong>。桥接以太网能跨越整个建筑物或校区。在桥接以太网中，有些电缆连接网桥和网桥，其他电缆连接网桥和集线器。</p>
<p>　　网桥比集线器更能充分利用线路带宽。通过巧妙的分配算法，它们能随着时间自动学习哪些端口可以访问哪些主机，然后仅在必要时可选地将帧从某个端口复制到其他端口。
例如，若主机A需要发送帧到同一网段的主机B，则当该帧到达网桥X的输入端口时，网桥X会直接丢弃，这样可以节约其他网段的带宽。若主机A需要发送帧到其他网段的主机C，则当帧到达网桥X的输入端口时，网桥X只会将帧复制到通往网桥Y的端口，网桥Y只会将帧复制到通往主机C所属网段的端口。</p>
<p>　　在层次结构的较高层中，多个兼容的LAN通过称为<strong>路由器</strong>的特殊计算机连接来形成互联网络。每个路由器对它连接的每个网络都有1个适配器
(端口)。路由器也能连接<strong>广域网</strong> (WAN)
等高速点对点电话连接。WAN比LAN有更大的地理覆盖范围。路由器通常可以使用任意LAN和WAN集合来构建互联网络。</p>
<p>　　为了让源主机跨越不兼容的网络发送数据给目的主机，需要使用能屏蔽底层网络差异的<strong>协议软件</strong>
(运行在所有主机和路由器上)，该软件会实现能协调主机和路由器来传输数据的协议。该协议必须提供<span
style="background-color: yellow">命名方案</span>和<span
style="background-color: yellow">传输机制</span>。</p>
<p>　　●
不同的LAN技术通过不同且不兼容的方式来分配主机地址，网络协议需要通过定义统一的地址格式来屏蔽这些差异。每个主机必须分配最少1个<strong>网络地址</strong>，作为其唯一标识。</p>
<p>　　●
不同的网络技术通过不同且不兼容的方式来编码电缆上的位并将这些位封装成帧。网络协议需要通过定义统一的将数据位封装成独立的片的方法来屏蔽这些差异，这些片称为<strong>分组</strong>。分组包括首部和有效载荷，首部包含分组大小、源主机地址和目的主机地址，有效载荷包含数据位。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_11/how_data_travel_from_one_host_to_another_on_an_internet.svg" class="">
<p>　　为了简化，这里用较粗的线表示集线器、网桥以及连接它们的电缆。客户端运行在LAN1的主机A上，服务器运行在LAN2的主机B上。客户端发送数据到服务器需要8个步骤，这里仅介绍主要部分，省去了很多细节
(例如，如何处理不同网络的帧大小不同的情况、如何路由和丢包后的处理)。</p>
<p>　　1)
主机A上的客户端通过系统调用来复制客户端的虚拟内存中的数据到内核缓冲区。</p>
<p>　　2)
主机A上的协议软件将网络分组首部和LAN1帧首部附加到数据末尾来生成LAN1帧。分组首部的地址是主机B的地址。LAN1帧的地址是路由器的地址。这里LAN1帧的有效载荷是分组，分组的有效载荷才是数据。这种<strong>封装</strong>是网络互联的基本方法之一。</p>
<p>　　3) LAN1适配器将帧复制到网络。</p>
<p>　　4)
当帧到达路由器时，路由器的LAN1适配器会从电缆上读取帧并将其传递给协议软件。</p>
<p>　　5)
路由器的协议软件从分组首部提取目的网络地址，根据网络地址路由分组。路由器去除原来的LAN1帧首部，生成地址为主机B地址的LAN2帧首部，然后将它们封装成帧并发送到适配器。</p>
<p>　　6) 路由器的LAN2适配器复制帧到网络。</p>
<p>　　7)
当帧到达主机B时，它的适配器会从电缆上读取帧并将其传递给协议软件。</p>
<p>　　8)
主机B的协议软件去除帧首部和分组首部。当服务器通过系统调用来读数据时，协议软件会复制数据到服务器虚拟内存。</p>
<h3 id="全球ip互联网">11.2 全球IP互联网</h3>
<p>　　TCP/IP实际是1组协议，其中的每个协议负责不同的功能。IP负责基础的命名方案和传输机制，IP对应的分组称为<strong>数据报</strong>。当数据报丢失或重复时，IP不会尝试恢复，所以IP的传输机制是不可靠的。UDP稍微扩展了IP，它会在进程之间传输数据报
(而非主机之间)。TCP是基于IP构建的复杂协议，可在进程之间提供可靠的全双工连接。这里为了简化，这里会将TCP/IP视为单个协议，忽略其内部细节和UDP，仅介绍TCP和IP为应用程序提供的部分基础功能。</p>
<p>　　地址是32位的IP称为<strong>IPv4</strong>。1996年，IETF提出了用于代替IPv4的128位地址的新版本IP，称为<strong>IPv6</strong>。这里的内容还是基于IPv4。</p>
<p>　　从程序员角度，可以将互联网视为带有以下属性的全球主机集合：</p>
<p>　　● 主机集合映射到32位IP地址集。</p>
<p>　　● IP地址集映射到1组称为<strong>域名</strong>的标识符。</p>
<p>　　●
主机上的进程通过<strong>连接</strong>与其他主机上的进程通信。</p>
<h4 id="ip地址">11.2.1 IP地址</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* IP地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> s_addr; <span class="comment">/* 大端对齐 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　IP地址是32位无符号整数。由于主机可以有不同的字节顺序，TCP/IP为所有整数数据项定义了统一的<strong>网络字节顺序</strong>——大端对齐。在结构体<code>in_addr</code>中存储标量地址是早期实现中不幸的产物，将其定义为标量类型更有意义，但现在更改已经太迟了，因为大量应用程序都基于该结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转换为网络字节顺序 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 转换为主机字节顺序 */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>htonl()</code>和<code>htons()</code>会将参数从主机字节顺序转换到网络字节顺序。函数<code>ntohl()</code>和<code>ntohs()</code>会将参数从网络字节顺序转换到主机字节顺序。</p>
<p>　　IP地址通常以<strong>点分十进制表示法</strong>的形式呈现
(例如，128.2.194.242是<code>0x8002c2f2</code>的点分十进制表示形式)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>; <span class="comment">/* 成功时返回1，src是无效点分十进制时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>; <span class="comment">/* 成功时返回点分十进制字符串，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>inet_pton()</code>会将点分十进制字符串<code>src</code>转换为网络字节顺序的二进制形式的IP地址<code>dst</code>。若<code>src</code>不是有效的点分十进制字符串，则返回0；若出错，则返回-1并设置<code>errno</code>。函数<code>inet_ntop()</code>会将网络字节顺序的二进制形式的IP地址<code>src</code>转换为点分十进制字符串，并将结果中的最多<code>size</code>字节复制到<code>dst</code>。</p>
<h4 id="域名">11.2.2 域名</h4>
<p>　　客户端和服务器通过IP地址通信，但是IP地址很难让人记住，于是就有了域名。</p>
<p>　　域名集形成1个层次结构，每个域名编码它在层次结构中的位置。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_11/subset_of_the_internet_domain_name_hierarchy.svg" class="">
<p>　　域名的层次结构展示为树。树的节点表示域名，子树表示子域名。1级域名由非盈利组织ICANN定义，通用1级域名包括<code>com</code>、<code>edu</code>、<code>gov</code>、<code>org</code>和<code>net</code>。2级域名按照先到先得的原则由ICANN代理分配
(例如，<code>cmu.edu</code>)。当机构收到2级域名后，该机构就可以免费创建该2级域名的所有子域名
(例如，<code>cs.cmu.edu</code>)。</p>
<p>　　互联网定义了域名集到IP地址集的映射。直到1988年，域名映射通过手动维护文本文件<code>hosts.txt</code>实现。自此以后，域名映射通过称为<strong>域名系统</strong>
(DNS)
的分布式全球数据库实现。DNS包含数百万条主机条目，每个条目定义1组域名和1组IP地址的映射，从数学角度，每个主机条目可以视为域名和IP地址的等式。可以通过命令<code>nslookup</code>来查看DNS映射：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nslookup localhost</span></span><br><span class="line">Address: 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>　　每个主机都有本地定义的域名<code>localhost</code>，该域名会映射到<strong>环回地址</strong>127.0.0.1，这对同一主机运行客户端和服务器的情况很有用。命令<code>hostname</code>可以查看主机的通用域名和IP地址。</p>
<p>　　在最简单的情况下，域名和IP地址之间是一对一映射。有时，多个域名会映射到同一IP地址。通常，多个域名会映射到同一组IP地址。</p>
<h4 id="网络连接">11.2.3 网络连接</h4>
<p>　　客户端和服务器通过连接发送和接收字节流来通信。连接的特点包括点对点
(连接2个进程)、全双工 (数据能同时在2个方向流动) 和可靠
(发送的数据总能被接收，除非出现切断电缆等灾难性故障)。</p>
<p>　　套接字是连接的一端。每个套接字都有对应的<strong>套接字地址</strong>，套接字地址由IP地址和16位的整数端口组成，其格式为<code>address:port</code>。</p>
<p>　　当客户端发起连接请求时，内核会自动分配客户端套接字地址中的端口，该端口是<span
style="background-color: yellow">临时端口</span>。服务器套接字地址中的端口通常是与服务永久关联的<span
style="background-color: yellow">知名端口</span>
(例如，Web服务器通常使用端口80，邮件服务器通常使用端口25)。与知名端口关联的服务有对应的<span
style="background-color: yellow">知名服务名</span>
(例如，Web服务也称为http，邮件服务也称为smtp)。知名服务名和知名端口之间的映射存储在文件<code>/etc/services</code>中。</p>
<p>　　连接的唯一标识是形如<code>(cliaddr:cliport, servaddr:servport)</code>的<strong>套接字对</strong>
(2个端口的套接字地址)。</p>
<h3 id="套接字接口">11.3 套接字接口</h3>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_11/overview_of_network_applications_based_on_the_sockets_interface.svg" class="">
<p>　　套接字接口是1组函数，通常与UNIX
I/O函数一起使用来构建网络应用程序。大多数现代操作系统中已经实现了套接字接口，包括UNIX的所有版本、Windows和Macintosh。</p>
<p>　　对于网络连接，进程关闭其连接端后，连接另一个端的进程试图从该连接读取数据时，会出现EOF。</p>
<h4 id="套接字地址">11.3.1 套接字地址</h4>
<p>　　从Linux内核角度，套接字是连接的一端。从Linux程序角度，套接字就是具有对应标识符的打开的文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 互联网套接字地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_family;     <span class="comment">/* 协议族 (总是AF_INET) */</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;       <span class="comment">/* 网络字节顺序的端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* 网络字节顺序的IP地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通用套接字地址 (对于函数connect、bind和accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> sa_family; <span class="comment">/* 协议族 */</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];   <span class="comment">/* 地址数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　互联网套接字地址存储在16字节的结构体<code>sockaddr_in</code>中，这里的后缀<code>_in</code>表示互联网而非输入。对于网络应用程序，成员<code>sin_family</code>是<code>AF_INET</code>，成员<code>sin_port</code>是16位端口号，成员<code>sin_addr</code>是32位IP地址。IP地址和端口号总是按照网络字节顺序存储。</p>
<p>　　函数<code>connect()</code>、<code>bind()</code>和<code>accept()</code>需要1个指向特定于协议的套接字地址结构体的指针。套接字接口设计者当时碰到的问题是如何让这些函数能适用于各种类型的套接字地址，那时，通用指针<code>void *</code>还不存在。当时的解决方法是定义结构体<code>sockaddr</code>，然后要求应用程序将所有特定于协议的套接字地址转换为该结构体。为了简化，这里将结构体<code>sockaddr</code>定义为以下类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="socket">11.3.2 <code>socket()</code></h4>
<p>　　客户端和服务器通过函数<code>socket()</code>创建<strong>套接字描述符</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>; <span class="comment">/* 成功时返回非负描述符，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　当需要让套接字成为连接端时，可以通过以下参数调用函数<code>socket()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clientfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>　　<code>AF_INET</code>表示使用32位IP地址，<code>SOCK_STREAM</code>表示套接字会成为连接端。不过，最好的方法是调用函数<code>getaddrinfo()</code>来自动生成这些参数，这样代码就与协议无关。</p>
<p>　　函数<code>socket()</code>返回的描述符<code>clientfd</code>只是部分打开的，还无法进行读写。</p>
<h4 id="connect">11.3.3 <code>connect()</code></h4>
<p>　　客户端调用函数<code>connect()</code>来与服务器建立连接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> clientfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>connect()</code>会与服务器建立套接字地址为<code>addr</code>的连接。参数<code>addrlen</code>是<code>sizeof(sockaddr_in)</code>。函数<code>connect()</code>会阻塞，直到连接成功建立或出错。若成功，则描述符<code>clientfd</code>可以进行读写，得到的连接对应的套接字对为<code>(x:y, addr.sin_addr:addr.sin_port)</code>，这里<code>x</code>是客户端的IP地址，<code>y</code>是客户端的端口号。同函数<code>socket()</code>一样，最好的方法是调用函数<code>getaddrinfo()</code>来为函数<code>connect()</code>提供参数。</p>
<h4 id="bindlisten和accept">11.3.4
<code>bind()</code>、<code>listen()</code>和<code>accept()</code></h4>
<p>　　服务器调用函数<code>bind()</code>、<code>listen()</code>和<code>accept()</code>来与客户端建立连接。</p>
<p>　　客户端是初始化连接请求的主动实体，服务器是等待客户端连接请求的被动实体。默认情况下，内核假设通过函数<code>socket()</code>创建的描述符对应客户端上的<strong>主动套接字</strong>。服务器调用函数<code>listen()</code>来告知内核描述符会被服务器使用，调用函数<code>accept()</code>来等待客户端的连接请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span>; <span class="comment">/* 成功时返回非负描述符，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>bind()</code>会请求内核将服务器的套接字地址<code>addr</code>与套接字描述符<code>sockfd</code>关联。参数<code>addrlen</code>是<code>sizeof(sockaddr_in)</code>。同函数<code>socket()</code>和<code>connect()</code>一样，最好的方法是调用函数<code>getaddrinfo()</code>来为函数<code>bind()</code>提供参数。</p>
<p>　　函数<code>listen()</code>会将<code>sockfd</code>从主动套接字转换为可以接收客户端的连接请求的监听套接字。参数<code>backlog</code>是关于内核在开始拒绝请求前应排队的未完成的连接请求数的提示，其具体含义涉及超出本书范围的TCP/IP内容，这里将其设置为1024等较大的值。</p>
<p>　　函数<code>accept()</code>会等待客户端的连接请求到达<strong>监听描述符</strong><code>listenfd</code>，然后填充<code>addr</code>中的客户端套接字地址并返回<strong>已连接描述符</strong>。已连接描述符可以用于调用UNIX
I/O函数来与客户端通信。</p>
<p>　　监听描述符是服务于客户端连接请求的连接端，它通常只会被创建1次并在服务器的生命周期内会一直存在。已连接描述符是客户端和服务器已建立的连接的连接端，它会在服务器每次接收请求连接时被创建并只会在服务器服务对应的客户端时存在。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_11/the_roles_of_the_listending_and_connected_descriptors.svg" class="">
<p>　　监听描述符和已连接描述符的作用如图所示。</p>
<p>　　1)
服务器调用函数<code>accept()</code>来等待连接请求到达监听描述符<code>listenfd</code>。由于标准文件占用描述符0~2，这里假设监听描述符的描述符号是3。</p>
<p>　　2)
客户端调用函数<code>connect()</code>来发起到<code>listenfd</code>的连接请求。</p>
<p>　　3)
函数<code>accept()</code>打开新的已连接描述符<code>connfd</code>
(这里假设为描述符4)，建立<code>cliendfd</code>和<code>connfd</code>的连接，然后将<code>connfd</code>返回给应用程序。客户端也从函数<code>connect()</code>返回。此时，客户端和服务器可以读写<code>cliendfd</code>和<code>connfd</code>来传输数据。</p>
<p>　　监听描述符和已连接描述符看似没有必要区分，但事实证明区分两者会很有用，因为这样可以建立能同时处理多个客户端连接的并发服务器。例如，每当连接请求到达监听描述符时，可以派生新进程来通过已连接描述符与客户端通信。</p>
<h4 id="主机和服务的转换">11.3.5 主机和服务的转换</h4>
<p>　　Linux提供了函数<code>getaddrinfo()</code>和<code>getnameinfo()</code>来完成二进制套接字地址与主机名、主机地址、服务名和端口号的字符串形式的相互转换。当它们与套接字接口一同使用时，可以使应用程序独立于IP协议版本。这2个函数分别包含函数<code>inet_pton()</code>和<code>inet_ntop()</code>的功能，而且它们提供独立于任何特定地址格式的更高级抽象。</p>
<h5 id="getaddrinfo">11.3.5.1 <code>getaddrinfo()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **result)</span>; <span class="comment">/* 成功时返回0，出错时返回非0错误码 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span><span class="params">(<span class="type">int</span> errcode)</span>; <span class="comment">/* 返回错误信息 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> ai_flags;             <span class="comment">/* 提示参数标志 */</span></span><br><span class="line">    <span class="type">int</span> ai_family;            <span class="comment">/* 函数socket的第1个参数 */</span></span><br><span class="line">    <span class="type">int</span> ai_socktype;          <span class="comment">/* 函数socket的第2个参数 */</span></span><br><span class="line">    <span class="type">int</span> ai_protocol;          <span class="comment">/* 函数socket的第3个参数 */</span></span><br><span class="line">    <span class="type">char</span> *ai_canonname;       <span class="comment">/* 规范主机名 */</span></span><br><span class="line">    <span class="type">size_t</span> ai_addrlen;        <span class="comment">/* 结构体ai_addr的大小 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span> <span class="comment">/* 指向套接字地址的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span> <span class="comment">/* 指向后继项的指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>getaddrinfo()</code>会将主机名、主机地址、服务名和端口号的字符串形式转换为套接字地址，它是已过时的函数<code>gethostbyname()</code>和<code>getservbyname()</code>的替代函数。和这些已过时的函数不同，该函数是可重入且独立于任何协议的。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_11/data_structure_returned_by_function_getaddrinfo.svg" class="">
<p>　　给定参数<code>host</code>和<code>service</code>，函数<code>getaddrinfo()</code>返回的<code>result</code>会指向由结构体<code>addrinfo</code>组成的链表，其中的每个元素指向的套接字地址都对应<code>host</code>和<code>service</code>。若函数<code>getaddrinfo()</code>返回非0的错误码，则应用程序可以调用函数<code>gai_strerror()</code>来将错误码转换为错误字符串。默认情况下，函数<code>getaddrinfo()</code>返回的套接字地址能被客户端作为调用函数<code>connect()</code>的主动套接字。</p>
<p>　　参数<code>host</code>可以是主机名和点分十进制IP地址等数字形式的地址。参数<code>service</code>可以是http等服务名和十进制端口号。若无需将主机名转换IP地址，则可以将参数<code>host</code>设置为<code>NULL</code>。服务名也是同样。但是，参数<code>host</code>和<code>service</code><span
style="background-color: yellow">不能</span>全为<code>NULL</code>。</p>
<p>　　可选的参数<code>hints</code>是结构体<code>addrinfo</code>，可以提供对函数<code>getaddrinfo()</code>返回的套接字地址列表的更好的控制。当传递该参数时，只有成员<code>ai_flags</code>、<code>ai_family</code>、<code>ai_socktype</code>和<code>ai_protocol</code>能设置，其他成员必须设置为0或<code>NULL</code>。实际中，可以调用函数<code>memset</code>将结构体<code>addrinfo</code>的所有成员设置为0，然后再按需设置成员。</p>
<p>　　成员<code>ai_flags</code>是用于修改默认行为的位掩码，可以设置为多个值的或运算。</p>
<p>　　●
<code>AI_ADDRCONFIG</code>表示仅当本地主机配置了IPv4时，函数<code>getaddrinfo()</code>会返回IPv4地址。IPv6也是同样。</p>
<p>　　●
<code>ÀI_CANONNAME</code>会让函数<code>getaddrinfo()</code>将列表中第1个结构体<code>addrinfo</code>中的成员<code>ai_cannonname</code>指向主机的规范主机名。</p>
<p>　　●
<code>AI_NUMERICSERV</code>会强制参数<code>service</code>为端口号。</p>
<p>　　●
<code>AI_PASSIVE</code>会让函数<code>getaddrinfo()</code>返回的套接字能被服务器用作监听套接字。这种情况下，参数<code>host</code>必须为<code>NULL</code>。返回的套接字地址的地址字段将会是<span
style="background-color: yellow">通配符地址</span>，通配符地址会告知内核此服务器将接收对此主机的任何IP地址的请求。</p>
<p>　　当函数<code>getaddrinfo()</code>在输出列表创建结构体<code>addrinfo</code>时，会填充除成员<code>ai_flags</code>外的所有成员。成员<code>ai_addr</code>指向套接字地址，成员<code>ai_addrlen</code>表示该套接字地址的大小，成员<code>ai_next</code>指向列表中的下一个结构体<code>addrinfo</code>。</p>
<p>　　默认情况下，函数<code>getaddrinfo()</code>能返回IPv4和IPv6套接字地址。可以将成员<code>ai_family</code>设置为<code>AF_INET</code>来限制为仅返回IPv4地址，或设置为<code>AF_INET6</code>来限制为仅返回IPv6地址。</p>
<p>　　默认情况下，对于主机关联的每个唯一地址，函数<code>getaddrinfo()</code>能返回最多3个结构体<code>addrinfo</code>，它们的成员<code>ai_socktype</code>都不同，分别用于连接、数据报和原始套接字。可以将成员<code>ai_socktype</code>设置为<code>SOCK_STREAM</code>来限制为每个唯一地址最多1个结构体<code>addrinfo</code>，该结构体对应的套接字地址能用作连接端。</p>
<p>　　当客户端调用函数<code>getaddrinfo()</code>后，会遍历列表并依次尝试套接字地址，直到成功调用函数<code>socket()</code>和<code>connect()</code>并完成连接建立。同样，服务器也会尝试列表中的每个套接字地址，直到成功调用函数<code>socket()</code>和<code>bind()</code>并将描述符绑定到合法的套接字地址。为了防止内存泄漏，应用程序最后必须调用函数<code>freeaddrinfo()</code>来释放列表。</p>
<p>　　函数<code>getaddrinfo()</code>的优点之一是结构体<code>addrinfo</code>的字段是不透明的，因为它们可以直接传递给套接字接口中的函数，应用程序代码无需任何进一步的操作。例如，成员<code>ai_family</code>、<code>ai_socktype</code>和<code>ai_protocol</code>能直接传递给函数<code>socket()</code>。同样，成员<code>ai_addr</code>和<code>ai_addrlen</code>能直接传递给函数<code>connect()</code>和<code>bind()</code>。这个属性允许客户端和服务器独立于任何版本的IP协议。</p>
<h5 id="getnameinfo">11.3.5.2 <code>getnameinfo()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen, <span class="type">char</span> *host, <span class="type">size_t</span> hostlen, <span class="type">char</span> *service, <span class="type">size_t</span> servlen, <span class="type">int</span> flags)</span>; <span class="comment">/* 成功时返回0，出错时返回非0错误码 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>getnameinfo()</code>和函数<code>getaddrinfo()</code>是相反的。该函数会将套接字地址转换为主机名和服务名的字符串形式，它是已过时的函数<code>gethostbyaddr()</code>和<code>getservbyport()</code>的替代函数。与这些已过时的函数不同，该函数是可重入且独立于任何协议的。</p>
<p>　　参数<code>sa</code>指向<code>salen</code>字节的套接字地址，参数<code>host</code>指向<code>hostlen</code>字节的字符串，参数<code>service</code>指向<code>servlen</code>字节的字符串。若函数<code>getnameinfo()</code>返回非0的错误码，应用程序可以调用函数<code>gai_strerror()</code>将其转换为字符串。</p>
<p>　　若不需要主机名，则可以将<code>host</code>设置为<code>NULL</code>并将<code>hostlen</code>设置为0。服务名也是同样。但是，参数<code>host</code>和<code>service</code><span
style="background-color: yellow">不能</span>全为<code>NULL</code>。</p>
<p>　　参数<code>flags</code>是用于修改默认行为的位掩码，可以设置为多个值的或运算。</p>
<p>　　●
<code>NI_NUMERICHOST</code>会让函数<code>getnameinfo()</code>在参数<code>host</code>中返回数字形式的地址。</p>
<p>　　●
<code>NI_NUMERICSERV</code>会强制函数<code>getnameinfo()</code>跳过查询<code>/etc/services</code>并简单地返回端口号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hostinfo.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">p</span>, *<span class="title">listp</span>, <span class="title">hints</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> rc, flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;domain name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取结构体addrinfo列表 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_family = AF_INET;       <span class="comment">/* 仅限于IPv4 */</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">/* 仅限于连接 */</span></span><br><span class="line">    <span class="keyword">if</span> ((rc = getaddrinfo(argv[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;hints, &amp;listp)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getaddrinfo error: %s\n&quot;</span>, gai_strerror(rc));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历列表并输出每个IP地址 */</span></span><br><span class="line">    flags = NI_NUMERICHOST; <span class="comment">/* 输出地址字符串而非域名 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        Getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, <span class="literal">NULL</span>, <span class="number">0</span>, flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放 */</span></span><br><span class="line">    Freeaddrinfo(listp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会调用函数<code>getaddrinfo()</code>和<code>getnameinfo()</code>来输出域名和IP地址的映射，它和<code>nslookup</code>类似。首先，初始化函数<code>getaddrinfo()</code>的参数<code>hints</code>，以便于<code>getaddrinfo()</code>返回可用于连接端的32位IP地址
(第15~16行)。因为这里只需要获取域名，所以将函数<code>getaddrinfo()</code>的参数<code>service</code>设置为<code>NULL</code>。</p>
<p>　　调用函数<code>getaddrinfo()</code>后，会遍历结构体<code>addrinfo</code>列表并通过函数<code>getnameinfo()</code>将每个套接字地址转换为点分十进制地址字符串。遍历完成后，会调用函数<code>freeaddrinfo()</code>来释放该列表
(尽管对这个示例不是必需的)。</p>
<h4 id="套接字接口的辅助函数">11.3.6 套接字接口的辅助函数</h4>
<p>　　函数<code>getaddrinfo()</code>和套接字接口看似有些麻烦，这里会实现更高级的包装它们的辅助函数<code>open_clientfd()</code>和<code>open_listenfd()</code>，客户端和服务器可以使用这2个函数来进行通信。</p>
<h5 id="open_clientfd">11.3.6.1 <code>open_clientfd()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* csapp.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 成功时返回描述符，出错时返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param hostname 服务器的主机名</span></span><br><span class="line"><span class="comment"> * @param port 服务器的端口号</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_clientfd</span><span class="params">(<span class="type">char</span> *hostname, <span class="type">char</span> *port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取潜在的服务器地址列表 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">/* 打开连接 */</span></span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV; <span class="comment">/* 使用数字端口号参数 */</span></span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG;</span><br><span class="line">    Getaddrinfo(hostname, port, &amp;hints, &amp;listp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历列表来获取可连接的服务器 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 创建套接字描述符 */</span></span><br><span class="line">        <span class="keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 连接失败，尝试下一个 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 连接服务器 */</span></span><br><span class="line">        <span class="keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 成功 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(clientfd); <span class="comment">/* 连接失败，尝试其他 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放 */</span></span><br><span class="line">    Freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* 所有连接失败 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 最后1个连接成功 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　客户端可以调用函数<code>open_clientfd()</code>来与运行在主机<code>hostname</code>上的监听端口<code>port</code>上的连接请求的服务器建立连接，它会返回打开的套接字描述符，该套接字描述符可以通过UNIX
I/O函数来进行输入和输出。</p>
<p>　　调用函数<code>getaddrinfo()</code>后，返回的由结构体<code>addrinfo</code>组成的列表中的每个元素都指向可用于建立连接的套接字地址。然后，遍历该列表中的每个元素，直到成功调用函数<code>socket()</code>和<code>connect()</code>。若调用函数<code>connect()</code>失败，则会在尝试下一个元素前关闭套接字描述符；若调用函数<code>connect()</code>成功，则释放列表并返回套接字描述符给客户端。</p>
<h5 id="open_listenfd">11.3.6.2 <code>open_listenfd()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* csapp.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 成功时返回描述符，出错时返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param port 端口号</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_listenfd</span><span class="params">(<span class="type">char</span> *port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">listp</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> listenfd, optval = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取潜在的服务器地址列表 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;             <span class="comment">/* 接受连接 */</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="comment">/* 任何IP地址 */</span></span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV;            <span class="comment">/* 使用端口号 */</span></span><br><span class="line">    Getaddrinfo(<span class="literal">NULL</span>, port, &amp;hints, &amp;listp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历列表来获取可绑定的服务器 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = listp; p; p = p-&gt;ai_next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 创建套接字描述符 */</span></span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 调用函数socket失败，尝试下一个 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 消除函数bind中的地址已使用错误 */</span></span><br><span class="line">        Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span> *)&amp;optval, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将描述符和地址绑定 */</span></span><br><span class="line">        <span class="keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 成功 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        Close(listenfd); <span class="comment">/* 调用函数bind失败，尝试下一个 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放 */</span></span><br><span class="line">    Freeaddrinfo(listp);</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="comment">/* 没有合适的地址 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 让监听套接字准备好接收连接请求 */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　服务器可以调用函数<code>open_listenfd()</code>来获取可以接收端口<code>port</code>上的连接请求的监听描述符。</p>
<p>　　与函数<code>open_clientfd()</code>有些类似，调用函数<code>getaddrinfo()</code>后，会遍历结果列表，直到成功调用函数<code>socket()</code>和<code>connect()</code>。第29行的函数<code>setsockopt()</code>会设置服务器，使其能被终止、重启和立即重新接收连接请求。默认情况下，重启服务器后大约30s内不会接受连接请求，这会严重妨碍调试。</p>
<p>　　调用函数<code>getaddrinfo()</code>时，参数<code>flag</code>中有<code>AI_PASSIV</code>，参数<code>host</code>为<code>NULL</code>，所以每个套接字地址中的地址字段都会被设置为通配符地址，即告知内核此服务器将接收对此主机的任何IP地址的请求。</p>
<p>　　最后，调用函数<code>listen()</code>将<code>listenfd</code>转换为监听描述符并将其返回给调用者。若调用函数<code>listen()</code>失败，会在返回前将描述符关闭来避免内存泄漏。</p>
<h4 id="echo客户端和服务器示例">11.3.7 echo客户端和服务器示例</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* echoclient.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientfd;</span><br><span class="line">    <span class="type">char</span> *host, *port, buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;host&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        Fputs(buf, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于echo客户端，在建立与服务器的连接后，它会进入从标准输入读取文本行，发送文本行到服务器，从服务器读取echo行以及输出结果到标准输出的循环。当函数<code>fget()</code>在标准输入遇到EOF、键盘输入Ctrl+D或读取完重定向输入文件的文本行时，循环终止。</p>
<p>　　当循环终止时，客户端会关闭描述符，这会导致发送EOF通知给服务器。当服务器从函数<code>rio_readlineb()</code>中收到的返回值为0时，它就检测该通知。关闭描述符后，客户端会终止。当程序关闭时，内核会关闭程序打开的描述符，所以，第29行的函数<code>close()</code>不是必要的。但是，显式关闭打开的描述符是良好的编程习惯之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* echo.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, (<span class="type">int</span>)n);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* echoserveri.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span> <span class="comment">/* 足够的空间来容纳任何地址 */</span></span><br><span class="line">    <span class="type">char</span> client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA *)&amp;clientaddr, clientlen, client_hostname, MAXLINE, client_port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected to (%s, %s)\n&quot;</span>, client_hostname, client_port);</span><br><span class="line">        echo(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于echo服务器，在打开监听描述符后，它会进入无限循环。每次迭代会等待来自客户端的连接请求，输出客户端的主机名和端口，然后调用函数<code>echo()</code>来服务客户端。从函数<code>echo()</code>返回后，服务器会关闭已连接描述符。一旦客户端和服务器关闭各自的描述符后，连接会终止。这里的服务器每次只能处理1个客户端，这种类型的服务器称为<strong>迭代服务器</strong>。相反，同时能处理多个客户端的服务器称为<strong>并发服务器</strong>。</p>
<p>　　第28行的变量<code>clientaddr</code>是将作为参数传递给函数<code>accept()</code>的套接字地址。在函数<code>accept()</code>返回前，会用客户端的套接字地址来填充<code>clientaddr</code>，这里<code>clientaddr</code>的类型是<code>struct sockaddr_storage</code>，该类型足以容纳任何类型的套接字地址，这样代码就与协议无关。</p>
<p>　　函数<code>echo()</code>会反复读写文本行，直到函数<code>rio_readlineb()</code>遇到EOF
(第13行)。</p>
<h3 id="web服务器">11.4 Web服务器</h3>
<p>　　相比FTP等常规的文件检索服务，Web服务的内容使用的是HTML。HTML页包含指示浏览如何显示各种文本和图形对象的标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Make me bold!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.cmu.edu/index.html&quot;</span>&gt;</span>Carnegie Mellon<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　第1行代码会告知浏览器将<code>&lt;b&gt;</code>和<code>&lt;/b&gt;</code>标签之间的文本加粗。第2行代码会告知浏览器高亮<code>&lt;a&gt;</code>和<code>&lt;/a&gt;</code>标签之间的文本并创建到HTML文件<code>index.html</code>的超链接，该HTML文件存储在Web服务器上。若用户点击高亮的文本对象，浏览器会从Web服务器请求对应的HTML文件并显示它。</p>
<h4 id="web内容">11.4.1 Web内容</h4>
<p>　　对于Web客户端和服务器，<strong>内容</strong>就是关联MIME类型的字节序列。</p>
<table>
<thead>
<tr>
<th>MIME类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text/html</code></td>
<td>HTML页</td>
</tr>
<tr>
<td><code>text/plain</code></td>
<td>未格式化的文本</td>
</tr>
<tr>
<td><code>application/postscript</code></td>
<td>Postscript文档</td>
</tr>
<tr>
<td><code>image/gif</code></td>
<td>GIF格式编码的二进制图像</td>
</tr>
<tr>
<td><code>image/png</code></td>
<td>PNG格式编码的二进制图像</td>
</tr>
<tr>
<td><code>image/jpeg</code></td>
<td>JPEG格式编码的二进制图像</td>
</tr>
</tbody>
</table>
<p>　　Web服务器通过以下2种方式提供内容给客户端：</p>
<p>　　● <span
style="background-color: yellow">取磁盘文件并将其内容返回给客户端</span>。该磁盘文件称为<strong>静态内容</strong>。将磁盘文件返回给客户端的过程称为<strong>服务静态内容</strong>。</p>
<p>　　● <span
style="background-color: yellow">运行可执行文件并将其输出返回给客户端</span>。可执行文件在运行时产生的输出称为<strong>动态内容</strong>。运行程序并将其输出返回给客户端的过程称为<strong>服务动态内容</strong>。</p>
<p>　　Web服务器返回的每条内容都关联其管理的某些文件，这些文件都有称为URL的唯一名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.google.com:80/index.html</span><br></pre></td></tr></table></figure>
<p>　　该URL标识主机<code>www.google.com</code>上的HTML文件<code>/index.html</code>，该文件由监听80端口的Web服务器管理。</p>
<p>　　可执行文件的URL能包含程序参数，即文件名加上<code>?</code>，再加上<code>&amp;</code>分隔的参数。参数中不允许出现特殊字符，这些特殊字符需要转换为ASCII码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://bluefish.ics.cs.cmu.edu:8000/cgi-bin/adder?15000&amp;213</span><br></pre></td></tr></table></figure>
<p>　　该URL标识可执行文件<code>/cgi-bin/adder</code>，并且带有2个参数字符串<code>15000</code>和<code>213</code>。</p>
<p>　　在事务中，客户端和服务器使用URL的不同部分。例如，客户端使用前缀<code>https://www.google.com:80</code>来决定服务器的类型、位置和监听端口。服务器使用后缀<code>/index</code>来在文件系统中查找文件并决定请求的是静态内容还是动态内容。</p>
<p>　　没有标准规定来确定URL引用的静态内容还是动态内容，所以每个服务器都有自己的规定。经典方法之一是将所有可执行文件存储在某组目录。</p>
<p>　　URL中的<code>/</code>并不表示Linux的根目录，它表示请求内容类型的主目录。例如，某个服务器可能设置为将所有静态内容和所有动态内容分别存储在<code>/usr/httpd/html</code>和<code>/usr/httpd/cgi-bin</code>中。</p>
<p>　　URL中最短的后缀是<code>/</code>，所有服务器会将其扩展为某个默认的主页，例如，<code>/index.html</code>。因此，可以直接在浏览器输入域名来访问主页。浏览器会给URL附上缺失的<code>/</code>并传递给服务器，服务器将其扩展给某个默认的文件名。</p>
<h4 id="http事务">11.4.2 HTTP事务</h4>
<p>　　由于HTTP是基于网络连接的文本行，可以使用Linux的程序<code>telnet</code>来与网络上的所有Web服务器执行事务。<code>telnet</code>程序在很大程度被远程登录工具ssh取代，但对于调试通过基于连接的文本行来与客户端通信的服务器很有用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">telnet www.aol.com 80             客户端: 打开到服务器的连接</span></span><br><span class="line">Trying 205.188.146.23...            telnet打印3行到终端</span><br><span class="line">Connected to aol.com.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">GET / HTTP/1.1                      客户端: 请求行</span><br><span class="line">Host: www.aol.com                   客户端: 请求的HTTP/1.1首部</span><br><span class="line">                                    客户端: 终止首部的空行</span><br><span class="line">HTTP/1.0 200 OK                     服务器: 响应行</span><br><span class="line">MIME-Version: 1.0                   服务器: 紧接的5行响应首部</span><br><span class="line">Date: Mon, 8 Jan 2010 4:59:42 GMT</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Content-Type: text/html             服务器: 响应体预计是HTML</span><br><span class="line">Content-Length: 42092               服务器: 响应体预计有42092字节</span><br><span class="line">                                    服务器: 终止响应首部的空行</span><br><span class="line">&lt;html&gt;                              服务器: 响应体中第1行HTML</span><br><span class="line">...                                 服务器: 766行HTML未展示</span><br><span class="line">&lt;/html&gt;                             服务器: 响应体中最后1行HTML</span><br><span class="line">Connection closed by foreign host.  服务器: 关闭连接</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">                                  服务器: 关闭连接和终端</span></span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，第1行会打开到AOL
Web服务器的连接。<code>telnet</code>打印3行输出到终端，打开连接并等待用户输入
(第5行)。当输入文本行并按下enter键时，<code>telnet</code>读该行，附上回车符和换行符
(C中的<code>\r\n</code>)
并发送给服务器。这与HTTP标准相符，HTTP标准要求每个文本行都<span
style="background-color: yellow">以回车符和换行符结尾</span>。为了初始化事务，输入HTTP请求
(第5~7行)。服务器返回HTTP响应并关闭连接 (第8~18行)。</p>
<h5 id="http请求">11.4.2.1 HTTP请求</h5>
<p>　　HTTP请求由请求行 (第5行)、若干行请求首部 (第6行)、终止首部的空行
(第7行) 和请求体组成。请求行的格式为<code>方法 URI 版本</code>。</p>
<p>　　HTTP支持多种<strong>方法</strong>，包括<code>PUT</code>、<code>POST</code>、<code>OPTIONS</code>、<code>HEAD</code>、<code>PUT</code>、<code>DELETE</code>和<code>TRACE</code>。</p>
<p>　　●
<code>GET</code>方法指示服务器生成并返回由URI标识的内容。当服务器请求内容时，URI是对应URL的后缀
(包括文件名和参数)。但是，代理服务器请求内容时，URI必须是完整的URL。</p>
<p>　　● <code>POST</code>方法的参数通过请求体传递。</p>
<p>　　请求行的<strong>版本</strong>表示请求的HTTP版本。HTTP/1.0诞生于1996年，HTTP/1.1在其基础上加上了额外的首部，用于提供缓存、安全以及允许客户端和服务器在同一<span
style="background-color: yellow">持久连接</span>上执行多个事务等功能。实际上，这2个版本是兼容的，HTTP/1.0会直接忽略HTTP/1.1首部。</p>
<p>　　综上所述，第5行的请求行会请求服务器返回HTML文件<code>/index.html</code>，并且版本为HTTP/1.1。</p>
<p>　　请求首部会提供额外信息给服务器，例如，浏览器的品牌名和MIME类型。请求首部的格式为<code>首部名: 首部数据</code>。这里仅关注首部<code>Host</code>
(第6行)，该首部是HTTP/1.1必需的。<strong>代理缓存</strong>会使用首部<code>Host</code>，代理缓存有时作为浏览器和管理被请求文件的<strong>原始服务器</strong>之间的中转。客户端和原始服务器之间可以有多个代理，称为<strong>代理链</strong>。首部<code>Host</code>的数据标识原始服务器的域名，使得代理链中的代理能够判断它是否可以在本地缓存中拥有所请求内容的副本。</p>
<p>　　第7行的空行 (通过输入回车键生成)
终止首部并指示服务器发送所请求的HTML文件。</p>
<h5 id="http响应">11.4.2.2 HTTP响应</h5>
<p>　　HTTP响应与HTTP请求类似，HTTP响应包含响应行
(第8行)、若干行响应首部 (第9~13行)、终止首部的空行 (第14行) 以及响应体
(第15~17行)。响应行的格式为<code>版本 状态码 状态信息</code>。</p>
<p>　　版本字段表示响应体的支持的HTTP版本。状态码字段是表示请求状态的3位数的正整数。状态信息字段表示错误码的英文描述。</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th>状态码</th>
<th>状态信息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>请求被正常处理</td>
</tr>
<tr>
<td>301</td>
<td>Moved permanently</td>
<td>内容已移动到首部<code>Location</code>中的主机名</td>
</tr>
<tr>
<td>400</td>
<td>Bad request</td>
<td>服务器无法解析请求</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器无权访问所请求的文件</td>
</tr>
<tr>
<td>404</td>
<td>Not found</td>
<td>服务器找不到所请求的文件</td>
</tr>
<tr>
<td>501</td>
<td>Not implemented</td>
<td>服务器不支持请求方法</td>
</tr>
<tr>
<td>505</td>
<td>HTTP version not supported</td>
<td>服务器不支持所请求的版本</td>
</tr>
</tbody>
</table>
<p>　　响应首部提供关于响应的额外信息
(第9~13行)，这里仅介绍首部<code>Content-Type</code>和<code>Content-Length</code>。前者表示响应体中的内容的MIME类型，后者表示响应体中的内容的大小
(单位是字节)。</p>
<p>　　第14行的空行终止首部，其后是包含所请求内容的响应体。</p>
<h4 id="服务动态内容">11.4.3 服务动态内容</h4>
<p>　　CGI定义了CGI程序在运行时可以设置的很多环境变量。</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QUERY_STRING</code></td>
<td>程序参数</td>
</tr>
<tr>
<td><code>SERVER_PORT</code></td>
<td>父进程正在监听的端口</td>
</tr>
<tr>
<td><code>REQUEST_METHOD</code></td>
<td><code>GET</code>或<code>POST</code></td>
</tr>
<tr>
<td><code>REMOTE_HOST</code></td>
<td>客户端域名</td>
</tr>
<tr>
<td><code>REMOTE_ADDR</code></td>
<td>客户端点分十进制IP地址</td>
</tr>
<tr>
<td><code>CONTENT_TYPE</code></td>
<td>请求体的MIME类型 (仅限于<code>POST</code>方法)</td>
</tr>
<tr>
<td><code>CONTENT_LENGTH</code></td>
<td>请求体的以字节为单位的大小 (仅限于<code>POST</code>方法)</td>
</tr>
</tbody>
</table>
<p>　　在服务器收到请求后，例如，<code>GET /cgi-bin/adder?15000&amp;213 HTTP/1.1</code>，它会调用函数<code>fork()</code>来创建子进程并在子进程的上下文调用函数<code>execve()</code>来运行程序<code>/cgi-bin/adder</code>。类似<code>adder</code>的程序通常称为<span
style="background-color: yellow">CGI程序</span>，因为它们遵循CGI标准。在调用函数<code>execve()</code>前，子进程会将环境变量<code>QUERY_STRING</code>设置为<code>15000&amp;213</code>，程序<code>adder</code>能在运行时使用Linux函数<code>getenv()</code>引用。</p>
<p>　　CGI程序会传递其动态内容到标准输出。在子进程加载和运行CGI程序前，它会调用Linux函数<code>dup2()</code>来将标准输出重定向到与客户端关联的已连接描述符。因此，CGI程序对标准输出的所有写操作会重定向到客户端。</p>
<p>　　父进程并不知道子进程生成内容的大小和类型，所以子进程需要生成响应首部中的<code>Content-Type</code>、<code>Content-Length</code>和终止响应首部的空行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* adder.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf, *p;</span><br><span class="line">    <span class="type">char</span> arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE];</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提取2个参数 */</span></span><br><span class="line">    <span class="keyword">if</span> ((buf = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(arg1, buf);</span><br><span class="line">        <span class="built_in">strcpy</span>(arg2, p + <span class="number">1</span>);</span><br><span class="line">        n1 = atoi(arg1);</span><br><span class="line">        n2 = atoi(arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造响应体 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;QUERY_STRING=%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;Welcome to add.com: &quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThe Internet addition portal.\r\n&lt;p&gt;&quot;</span>, content);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThe answer is: %d + %d = %d\r\n&lt;p&gt;&quot;</span>, content, n1, n2, n1 + n2);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThanks for visiting!\r\n&quot;</span>, content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造HTTP响应 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-length: %d\r\n&quot;</span>, (<span class="type">int</span>)<span class="built_in">strlen</span>(content));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-type: text/html\r\n\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会计算2个参数的和并返回带有结果的HTML文件给客户端。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">telnet kittyhawk.cmcl.cs.cmu.edu 8000             客户端: 打开连接</span></span><br><span class="line">Trying 128.2.194.242...</span><br><span class="line">Connected to kittyhawk.cmcl.cs.cmu.edu.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">GET /cgi-bin/adder?15000&amp;213 HTTP/1.0               客户端: 请求行</span><br><span class="line">                                                    客户端: 终止首部的空行</span><br><span class="line">HTTP/1.0 200 OK                                     服务器: 响应行</span><br><span class="line">Server: Tiny Web Server                             服务器: 标识服务器</span><br><span class="line">Content-length: 115                                 Adder: 响应体预计有115字节</span><br><span class="line">Content-type: text/html                             Adder: 响应体预计是HTML</span><br><span class="line">                                                    Adder: 终止首部的空行</span><br><span class="line">Welcome to add.com: THE Internet addition portal.   Adder: 响应体中第1行HTML</span><br><span class="line">&lt;p&gt;The answer is: 15000 + 213 = 15213               Adder: 响应体中第2行HTML</span><br><span class="line">&lt;p&gt;Thanks for visiting!                             Adder: 响应体中第3行HTML</span><br><span class="line">Connection closed by foreign host.                  服务器: 关闭连接</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">                                                  客户端: 关闭连接和终端</span></span><br></pre></td></tr></table></figure>
<p>　　这个示例是某个HTTP事务，它提供程序<code>adder</code>的动态内容。</p>
<h3 id="tiny-web服务器">11.5 TINY Web服务器</h3>
<p>　　这里将实现称为TINY的Web服务器，它结合了进程控制、UNIX
I/O、套接字接口和HTTP。虽然它缺乏了真实服务器的功能性、可靠性和安全性，但足以提供静态和动态内容给真实浏览器。TINY是基于HTTP/1.0的简单迭代服务器，使用<code>GET</code>方法提供静态内容和动态内容。</p>
<p>　　若服务器写已被客户端关闭的连接，第1次写会正常返回，第2次写会导致发送信号<code>SIGPIPE</code>，该信号的默认处理方式是关闭进程。若信号<code>SIGPIPE</code>被捕获或忽略，则第2次写操作会返回-1并将<code>errno</code>设置为<code>EPIPE</code>。函数<code>strerr()</code>和<code>perror()</code>会将错误<code>EPIPE</code>报告为
"Broken pipe"，这个信息并不直观。</p>
<h4 id="主函数">11.5.1 主函数</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tiny.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_filetype</span><span class="params">(<span class="type">char</span> *filename, <span class="type">char</span> *filetype)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_static</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">int</span> filesize)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_dynamic</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clienterror</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *cause, <span class="type">char</span> *errnum, <span class="type">char</span> *shortmsg, <span class="type">char</span> *longmsg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查命令行参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA *)&amp;clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);</span><br><span class="line">        doit(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是TINY的主函数，它监听连接请求的端口通过命令行传递。在调用函<code>open_listenfd()</code>打开监听套接字后，TINY会进行常规的服务器无限循环——反复接收连接请求
(第28行)、执行事务 (第31行) 和关闭连接端 (第32行)。</p>
<h4 id="doit">11.5.2 <code>doit()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tiny.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 处理HTTP事务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> is_static;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="type">char</span> filename[MAXLINE], cgiargs[MAXLINE];</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读请求行和首部 */</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Request headers:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not implemented&quot;</span>, <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    read_requesthdrs(&amp;rio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从请求中解析URI */</span></span><br><span class="line">    is_static = parse_uri(uri, filename, cgiargs);</span><br><span class="line">    <span class="keyword">if</span> (stat(filename, &amp;sbuf) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clienterror(fd, filename, <span class="string">&quot;404&quot;</span>, <span class="string">&quot;Not found&quot;</span>, <span class="string">&quot;Tiny couldn&#x27;t find this file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_static)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 服务静态内容 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR &amp; sbuf.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>, <span class="string">&quot;Tiny couldn&#x27;t read the file&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serve_static(fd, filename, sbuf.st_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 服务动态内容 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR &amp; sbuf.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>, <span class="string">&quot;Tiny couldn&#x27;t run the CGI program&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serve_dynamic(fd, filename, cgiargs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>doit()</code>会处理HTTP事务。首先，读并解析请求行
(第16~19行)，这里使用函数<code>rio_readlineb()</code>来读取请求行。</p>
<p>　　TINY仅支持<code>GET</code>方法。若客户端请求其他方法，则发送错误信息并返回到主函数
(第20~24行)，主函数会关闭连接并等待下一个连接请求；否则，进行读操作并忽略所有请求首部
(第25行)。</p>
<p>　　然后，解析URI为文件名和CGI参数字符串，这里使用了1个标志来指示请求的是静态内容还是动态内容
(第28行)。若在磁盘上找不到所请求的文件，则立即发送错误信息给客户端并返回。</p>
<p>　　最后，当请求的是静态内容时，会验证该文件是否是普通文件以及是否有读权限
(第38行)，若是，则提供静态内容给客户端
(第43行)。当请求的是动态内容，会验证该文件是否是可执行文件，若是，则提供动态内容
(第53行)。</p>
<h4 id="clienterror">11.5.3 <code>clienterror()</code></h4>
<p>　　TINY缺乏真实服务器的多种错误处理功能。但是，它会检查一些常见的错误并反馈给客户端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tiny.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 发送错误信息给客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param cause 原因</span></span><br><span class="line"><span class="comment"> * @param errnum 错误码</span></span><br><span class="line"><span class="comment"> * @param shortmsg 短信息</span></span><br><span class="line"><span class="comment"> * @param longmsg 长信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clienterror</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *cause, <span class="type">char</span> *errnum, <span class="type">char</span> *shortmsg, <span class="type">char</span> *longmsg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], body[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建HTTP响应体 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;body bgcolor=&quot;</span><span class="string">&quot;ffffff&quot;</span><span class="string">&quot;&gt;\r\n&quot;</span>, body);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s%s: %s\r\n&quot;</span>, body, errnum, shortmsg);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;p&gt;%s: %s\r\n&quot;</span>, body, longmsg, cause);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n&quot;</span>, body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印HTTP响应 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 %s %s\r\n&quot;</span>, errnum, shortmsg);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-length: %d\r\n\r\n&quot;</span>, (<span class="type">int</span>)<span class="built_in">strlen</span>(body));</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    Rio_writen(fd, body, <span class="built_in">strlen</span>(body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>clienterror()</code>会发送HTTP响应给客户端，响应行会包含合适的状态码和状态信息，响应体会包含解释错误的HTML文件。</p>
<p>　　HTTP响应需要指明大小和内容类型，所以选择将HTTP内容构建为单个字符串，这样易于判断其大小。这里对所有的输出使用了函数<code>rio_writen()</code>。</p>
<h4 id="read_requesthdrs">11.5.4 <code>read_requesthdrs()</code></h4>
<p>　　TINY不会使用请求首部中的任何信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tiny.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读并忽略请求首部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rp 指向读缓冲区的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_requesthdrs</span><span class="params">(<span class="type">rio_t</span> *rp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    Rio_readlineb(rp, buf, MAXLINE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Rio_readlineb(rp, buf, MAXLINE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>read_requsethdrs()</code>会读并忽略请求首部。第11行会检查终止请求首部的空行
(以<code>\r\n</code>结束)。</p>
<h4 id="parse_uri">11.5.5 <code>parse_uri()</code></h4>
<p>　　TINY会假设静态内容的主目录是当前目录，可执行文件的主目录是<code>./cgi-bin</code>。所有包含字符串<code>./cgi-bin</code>的URI都会被假设为动态内容请求。默认文件名是<code>./home.html</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tiny.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解析HTTP URI</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param uri</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param cgiargs CGI参数</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_uri</span><span class="params">(<span class="type">char</span> *uri, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(uri, <span class="string">&quot;cgi-bin&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 静态内容 */</span></span><br><span class="line">        <span class="built_in">strcpy</span>(cgiargs, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">if</span> (uri[<span class="built_in">strlen</span>(uri) - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(filename, <span class="string">&quot;home.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 动态内容 */</span></span><br><span class="line">        ptr = index(uri, <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, ptr + <span class="number">1</span>);</span><br><span class="line">            *ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>parse_uri()</code>会将URI解析为文件名和可选的CGI参数字符串。若请求的是静态内容
(第13行)，则清除CGI参数字符串并将URI转换为对应的Linux路径名
(第16~17行)，若URI以<code>/</code>结尾，则附上默认文件名
(第21行)；若请求的是动态内容，则提取CGI参数 (第28~37行)
并将URI的剩余部分转换为相关的Linux文件名 (第38~39行)。</p>
<h4 id="serve_static">11.5.6 <code>serve_static()</code></h4>
<p>　　TINY提供5种类型的静态内容：HTML文件、未格式化的文本文件、GIF格式图片、PNG格式图片和JPEG格式图片。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tiny.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据文件名获取文件类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param filetype 文件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_filetype</span><span class="params">(<span class="type">char</span> *filename, <span class="type">char</span> *filetype)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.html&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.gif&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/gif&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.png&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.jpg&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 提供静态内容给客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param filesize 文件大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_static</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">int</span> filesize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> srcfd;</span><br><span class="line">    <span class="type">char</span> *srcp, filetype[MAXLINE], buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送响应首部到客户端 */</span></span><br><span class="line">    get_filetype(filename, filetype);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sServer: Tiny Web Server\r\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sConnection: close\r\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sContent-length: %d\r\n&quot;</span>, buf, filesize);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%sContent-type: %s\r\n\r\n&quot;</span>, buf, filetype);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Response headers:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送响应体到客户端 */</span></span><br><span class="line">    srcfd = Open(filename, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    srcp = Mmap(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>);</span><br><span class="line">    Close(srcfd);</span><br><span class="line">    Rio_writen(fd, srcp, filesize);</span><br><span class="line">    Munmap(srcp, filesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>serve_static()</code>会发送HTTP响应到客户端，响应体包含本地文件的内容。首先，根据文件名的后缀来决定文件类型
(第44行)，发送响应行和响应首部到客户端，这里包含终止首部的空行
(第45~50行)。</p>
<p>　　然后，将所请求的文件复制到已连接描述符<code>fd</code>来发送响应体。第55行会打开<code>filename</code>来读和获取描述符。第56行会调用函数<code>mmap()</code>来将所请求的文件映射到虚拟内存区域，即将文件<code>srcfd</code>的前<code>filesize</code>字节映射到虚拟内存中地址<code>srcp</code>处的私有只读区域。</p>
<p>　　将文件映射到内存后，就不会再使用它的描述符，所以需要关闭文件
(第57行)。第58行才会真正将文件传输给客户端。函数<code>rio_writen()</code>会将位置<code>srcp</code>处的<code>filesize</code>字节
(被映射到所请求的文件)
复制到客户端的已连接描述符。最后，第59行会释放映射的虚拟内存区域。</p>
<h4 id="serve_dynamic">11.5.7 <code>serve_dynamic()</code></h4>
<p>　　TINY通过派生子进程来提供任何类型的动态内容，然后在子进程的上下文中运行CGI程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tiny.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 提供动态内容给客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param filename 文件名</span></span><br><span class="line"><span class="comment"> * @param cgiargs CGI参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_dynamic</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *filename, <span class="type">char</span> *cgiargs)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], *emptylist[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送HTTP响应的第1部分 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Web Server\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 子进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (Fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 真实服务器会在这里设置所有的CGI变量 */</span></span><br><span class="line">        setenv(<span class="string">&quot;QUERY_STRING&quot;</span>, cgiargs, <span class="number">1</span>);</span><br><span class="line">        Dup2(fd, STDOUT_FILENO);              <span class="comment">/* 将标准输出重定向到客户端 */</span></span><br><span class="line">        Execve(filename, emptylist, environ); <span class="comment">/* 运行CGI程序 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    Wait(<span class="literal">NULL</span>); <span class="comment">/* 父进程等待并回收子进程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>serve_dynamic()</code>会先给客户端发送表明成功的响应行和包含信息的首部<code>Server</code>。CGI程序负责发送HTTP响应的剩余部分。这里并没有考虑CGI程序可能会碰到某些错误。</p>
<p>　　在发送HTTP响应的第1部分后，会派生子进程
(第20行)。子进程会使用请求URI中的CGI参数来初始化环境变量<code>QUERY_STRING</code>，真实服务器还会在这里设置其他CGI环境变量
(这里为了简化，省略这一步)。</p>
<p>　　然后，子进程将其标准输出重定向到已连接描述符
(第24行)，加载并运行CGI程序
(第25行)。由于CGI程序运行在子进程的上下文，它可以访问调用函数<code>execve()</code>之前存在的所有打开的文件和环境变量。因此，CGI程序对标准输出的所有写操作会重定向到客户端，父进程调用函数<code>wait()</code>来阻塞自己并在子进程终止时将其回收
(第27行)。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《剑桥国际英语语音在用》</title>
    <url>/english/english_pronunciation_in_use/</url>
    <content><![CDATA[<h3 id="字母和发音">1 字母和发音</h3>
<p>　　音素分为元音 (V) 和辅音 (C)。在单词duck <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dʌk/</span>中，有3个音素
(CVC)。单词的音素数通常与其字母数不同。作家经常在写作时可能会押韵，即多个单词的结尾的部分音素相同，例如，news
and views。</p>
<h4 id="元音">1.1 元音</h4>
<p>　　在有2个及以上音节的单词中，至少有1个音节是非重音音节。对于非重音音节，以英语为母语的人会经常使用弱元音<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪ/</span>。例如，carrot中的字母o发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>，cabbage中的字母a发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪ/</span>。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
<th>
有时
</th>
<th>
注意
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/iː/
</td>
<td>
ee (feet) ea (eat) <span>e-e</span> (scene)
</td>
<td>
e (me) ie (piece)
</td>
<td>
字母ea还能发音为其他元音，但发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/iː/</span>是最常见的情况
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/e/
</td>
<td>
e (men)
</td>
<td>
ea (death) ie (friend) a (many) ai (said)
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>　　当单词以字母r结尾，并且字母r前是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/iː/</span>时，很多人会给该单词加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>并不发音这个<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>，很多词典在这个情况下给出的音标是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪə/</span>，例如，near、pier和hear。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/ʌ/
</td>
<td>
o (come) oe (does) oo (blood) ou (young) u (cut)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/ʊ/
</td>
<td>
o (wolf) oo (foot) ou (would) u (full)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/uː/
</td>
<td>
ew (new) oe (shoe) oo (shoot) ou (soup)
</td>
</tr>
</tbody>
</table>
<p>　　英格兰北部的人会用<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʊ/</span>代替<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʌ/</span>，所以luck
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/lʌk/</span>听起来像look
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/lʊk/</span>。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
e / i / o / u + r
</th>
<th>
其他字母
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/ɜː/
</td>
<td>
er (her) ir (girl)  ur (hurt)
</td>
<td>
ear (heard) or (word)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/ʊ/
</td>
<td>
or (form)
</td>
<td>
a (call) al (walk) ar (war) au (cause) augh (taught) aw (saw) ough
(thought) our (four)
</td>
</tr>
</tbody>
</table>
<p>　　当发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔː/</span>的字母中没有r时，部分美国人会用<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɑː/</span>代替<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔː/</span>。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/eɪ/
</td>
<td>
<span>a-e</span> (mate) ay (say) ey (grey) ei (eight) ai (wait) ea
(great)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/æ/
</td>
<td>
a
</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
<th>
有时
</th>
<th>
注意
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/aɪ/
</td>
<td>
<span>i-e</span> (smile) ie (die) y (cry)
</td>
<td>
igh (high) uy (buy)
</td>
<td>
这些字母并不总是发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aɪ/</span>
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/ɪ/
</td>
<td>
i (win)
</td>
<td>
y (gym)
</td>
<td>
非重音音节中能发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪ/</span>的字母有多个
</td>
</tr>
</tbody>
</table>
<p>　　当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aɪ/</span>后是字母r或l时，很多人会在中间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>，所以hire
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈhaɪə(r)/</span>听起来就像higher。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
<th>
有时
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/ɑː/
</td>
<td>
ar (car) al (half)
</td>
<td>
ear (heart) a (ask)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/eə/
</td>
<td>
are (care) air (fair) ear (bear) ere (where)
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>　　在英格兰西南部，当字母a后是字母s、f、th或n时，通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɑː/</span>。在美国北部，字母o通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɑː/</span>。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
<th>
有时
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/ɒ/
</td>
<td>
o (dog)
</td>
<td>
a (wash)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/əʊ/
</td>
<td>
o (old) <span>o-e</span> (stone) ow (show) oa (coat) oe (toe)
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>　　在美国北部，会用<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɑː/</span>代替<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɒ/</span>，所以pot听起来就和英式口音的part差不多。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
<th>
注意
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/ɔɪ/
</td>
<td>
oi (coin) oy (boy)
</td>
<td>
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/aʊ/
</td>
<td>
ou (loud) ow (cow)
</td>
<td>
字母ou和ow有多种发音
</td>
</tr>
</tbody>
</table>
<p>　　当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔɪ/</span>后是字母l时，很多人会在中间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>。同样，当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aʊ/</span>后是字母r或l时，很多人会在中间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>。</p>
<span id="more"></span>
<h4 id="辅音">1.2 辅音</h4>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
<th>
有时
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/f/
</td>
<td>
f (fell) ff (offer) ph (photo) gh (laugh)
</td>
<td>
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/v/
</td>
<td>
v (never)
</td>
<td>
f (of)
</td>
</tr>
</tbody>
</table>
<p>　　元音在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span>比在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/v/</span>前更短，例如，leaf和leave，若无法区分两者，可以延长leave中的元音。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
<th>
有时
</th>
<th>
极少数情况
</th>
<th>
注意
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/d/
</td>
<td>
d (dog) dd (address)
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/t/
</td>
<td>
t (tie) tt (butter)
</td>
<td>
-(e)d过去式
</td>
<td>
th (Thomas)
</td>
<td>
字母t有时不发音
</td>
</tr>
</tbody>
</table>
<p>　　在很多口音 (包括美式口音)
中，当字母t在元音之间时，其发音听起来像<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>，所以writer
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/raɪtə/</span>听起来像raider
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/raɪdə/</span>。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
开头
</th>
<th>
中间
</th>
<th>
结尾
</th>
<th>
注意
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/k/
</td>
<td>
c (can) k (king)
</td>
<td>
cc (soccer) ck (locker)
</td>
<td>
k (milk) ck (black) c (comic) ch (ache)
</td>
<td>
有些以字母k开头的单词中的字母k不发音 (know和knife)
</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
<th>
有时
</th>
<th>
注意
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/g/
</td>
<td>
g (go) gg (bigger)
</td>
<td>
gh (ghost) gu (guest)
</td>
<td>
字母g有时不发音 (sign和foreign)
</td>
</tr>
</tbody>
</table>
<p>　　元音在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>比在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/g/</span>前更短，例如，back和bag。qu发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kw/</span>
(quick)。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
<th>
有时
</th>
<th>
注意
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/b/
</td>
<td>
b (job)
</td>
<td>
</td>
<td>
字母b有时不发音 (comb)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/p/
</td>
<td>
p (open) pp (apple)
</td>
<td>
</td>
<td>
字母p有时不发音 (psychology)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/s/
</td>
<td>
s (sad) ss (class) c (place)
</td>
<td>
sc (science)
</td>
<td>
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/z/
</td>
<td>
z (zero) s (nose) -se结尾 (rise)
</td>
<td>
zz (buzz) ss (scissor)
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>　　字母x能发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ks/</span> (mix)
和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/gz/</span>
(exact)。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
总是
</th>
<th>
大多数情况
</th>
<th>
有时
</th>
<th>
注意
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/l/
</td>
<td>
</td>
<td>
l (leg) ll (call)
</td>
<td>
</td>
<td>
字母l有时不发音 (half)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/r/
</td>
<td>
</td>
<td>
r (run) rr (carrot)
</td>
<td>
wr (wrong) rh (rhyme)
</td>
<td>
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/θ/
</td>
<td>
th (three)
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/ð/
</td>
<td>
th (then)
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>　　很多以英语为母语的人将字母th发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/v/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span>而非<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θ/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ð/</span>，例如，有些爱尔兰人将thick
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θɪk/</span>发音为tick
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/tɪk/</span>。</p>
<p>　　伦敦的有些人将three <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θriː/</span>发音为free
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/friː/</span>。尼日利亚的有些人将then
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ðen/</span>发音为den
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/den/</span>。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
<th>
极少数情况
</th>
<th>
注意
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/h/
</td>
<td>
h (hill)
</td>
<td>
wh (who)
</td>
<td>
字母h经常不发音 (hour和honest)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/w/
</td>
<td>
w (will) wh (when)
</td>
<td>
o (one和once)
</td>
<td>
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/j/
</td>
<td>
y (you) i (view) e (few) u (cute)
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>　　伦敦等地的有些人不发音字母h，所以hair <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/heə/</span>听起来像air
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/eə/</span>。</p>
<p>　　美国人会省略new、student和tune等单词中的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>，所以newspaper
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈnjuːspeipə/</span>听起来像noose
paper <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈnuːspeipə/</span>。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
开头
</th>
<th>
中间
</th>
<th>
结尾
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/ʃ/
</td>
<td>
sh (shoe) s (suger)
</td>
<td>
sh (fashion) ss (Russia) ti (nation) c (ocean)
</td>
<td>
sh (fish)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/dʒ/
</td>
<td>
j (jaw) g (general)
</td>
<td>
g (page) j (major)
</td>
<td>
ge (rage) dge (ledge)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/tʃ/
</td>
<td>
ch (chair)
</td>
<td>
ch (teacher) t (future)
</td>
<td>
tch (watch)
</td>
</tr>
</tbody>
</table>
<p>　　当前一单词的结尾和后一单词的开头都是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dʒ/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/tʃ/</span>时，它们<span
style="background-color: yellow">不会</span>合并。</p>
<table>
<thead>
<tr>
<th>
</th>
<th>
大多数情况
</th>
<th>
注意
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/m/
</td>
<td>
m (miss)
</td>
<td>
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>后可能有不发音的字母b或n
(comb和autumn)，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>前可能有不发音的字母k
(knife)
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/n/
</td>
<td>
n (now)
</td>
<td>
</td>
</tr>
<tr>
<td style="font-family:Lucida Sans Unicode,Lucida Grande;white-space: nowrap;">
/ŋ/
</td>
<td>
ng (sing) n (sink)
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>　　当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>之后是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/g/</span>时，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>会变为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ŋ/</span>。</p>
<h3 id="单词和短语的发音">2 单词和短语的发音</h3>
<p>　　很多英语单词源于其他语言，其中的部分单词甚至不再被认为是外来词，例如，bungalow
(源于印度语)、caravan (源于波斯语)、tomato
(源于西班牙语)。由于近期才引用或保持着原始语言的特点，其他单词依然是外来词。</p>
<h4 id="辅音簇">2.1 辅音簇</h4>
<p>　　<strong>辅音簇</strong>是多个辅音的组合。辅音簇能出现在单词的开头、中间和结尾，甚至跨越2个单词。</p>
<h5 id="单词开头的辅音簇">2.1.1 单词开头的辅音簇</h5>
<p>　　以下是单词开头可能出现的双辅音簇：</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/w/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span></td>
<td>play</td>
<td>pray</td>
<td>✕</td>
<td>pure</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span></td>
<td>✕</td>
<td>trip</td>
<td>twins</td>
<td>tube</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span></td>
<td>class</td>
<td>crime</td>
<td>queen</td>
<td>queue</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/b/</span></td>
<td>black</td>
<td>brown</td>
<td>✕</td>
<td>beauty</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span></td>
<td>✕</td>
<td>drop</td>
<td>dwell</td>
<td>due</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/g/</span></td>
<td>glass</td>
<td>grow</td>
<td>✕</td>
<td>✕</td>
</tr>
<tr>
<td>/<span
style="font-family:Lucida Sans Unicode,Lucida Grande">m</span>/</td>
<td>✕</td>
<td>✕</td>
<td>✕</td>
<td>music</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span></td>
<td>✕</td>
<td>✕</td>
<td>✕</td>
<td>news</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span></td>
<td>fly</td>
<td>fry</td>
<td>✕</td>
<td>few</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/v/</span></td>
<td>✕</td>
<td>✕</td>
<td>✕</td>
<td>view</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θ/</span></td>
<td>✕</td>
<td>three</td>
<td>✕</td>
<td>✕</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃ/</span></td>
<td>✕</td>
<td>shrink</td>
<td>✕</td>
<td>✕</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span></td>
<td>✕</td>
<td>✕</td>
<td>✕</td>
<td>huge</td>
</tr>
</tbody>
</table>
<p>　　 此外，单词开头可能出现的双辅音簇中还有<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>
(slow)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/w/</span>
(swim)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>
(spot)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>
(star)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>
(sky)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>
(smile)、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>
(snow)和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span> + <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span>
(sphere)。</p>
<p>　　以下是单词开头可能出现的三辅音簇：</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/w/</span></th>
<th>+ <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/sp/</span></td>
<td>splash</td>
<td>spray</td>
<td>✕</td>
<td>✕</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/st/</span></td>
<td>✕</td>
<td>straw</td>
<td>✕</td>
<td>stew</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">/sk/</span></td>
<td>✕</td>
<td>scream</td>
<td>squeak</td>
<td>skewer</td>
</tr>
</tbody>
</table>
<p>　　
以上表格中用✕表示的部分辅音簇会出现在非重读央元音和人名等不常见的单词中。</p>
<h5 id="单词结尾的辅音簇">2.1.2 单词结尾的辅音簇</h5>
<p>　　可能出现在单词结尾的辅音簇最多包括4个辅音。</p>
<p>　　即使对以英语为母语的人，部分出现在单词结尾的辅音簇也可能很难发音，所以这些辅音簇会被简化。例如，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kts/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/mps/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/mpt/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/nts/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ndz/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/skt/</span>中的<span
style="background-color: yellow">第2个辅音</span>几乎听不到，有时甚至被省略。此外，twelfth
→ twel<s>f</s>th <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/twelθ/</span>，fifths
→ fi<s>f</s>ths <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/fɪθs/</span>或fif<s>th</s>s
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/fɪfs/</span>。</p>
<p>　　省略单词结尾的辅音簇中的最后1个辅音可能会导致误解，尤其是复数形式和第三人称单数形式中的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>以及动词和形容词中的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>。</p>
<h5 id="跨越单词的辅音簇">2.1.3 跨越单词的辅音簇</h5>
<p>　　说话时会将所说的内容划分为<strong>语音单元</strong>。每个语音单元都有1个主音。同一语音单元的单词之间没有停顿，语音单元之间有停顿。语音单元的边界用
// 表示。</p>
<p>　　当前一单词以辅音结尾，后一单词以辅音开头时，会形成跨越单词的辅音簇。当这种辅音簇出现在语音单元中时，通常很难发音。例如，//
it's an el<u>m tr</u>ee//。当辅音簇内有停顿时，将更容易发音。例如，// if
Tom can't take you to the fil<u>m// tr</u>y Mike//。</p>
<p>　　短语和复合词中的单词通常处于同一语音单元，所以经常会形成辅音簇。例如，civi<u>l
s</u>ervant。</p>
<h4 id="单词和短语的重音">2.2 单词和短语的重音</h4>
<p>　　大多数词典在给出单词的发音的同时也会给出<strong>重音</strong>音节。在音标中，主重音用
<span style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>
表示，次重音用 <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>
表示，例如，controversial <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˌkɒntrəˈvɜːʃl/</span>。</p>
<p>　　当强调某个单词时，该单词中的某个重音音节将会变为<strong>强读</strong>音节，这里会用大写来进行区分。对于单重音音节词，强读音节就是重音音节；对于双重音音节词，强读音节一般是<strong>主重音</strong>，例如，It
was controVERsial。</p>
<p>　　当controversial等次重音在主重音之前的单词后是强读音节开头的单词时，这类单词的强读<span
style="background-color: yellow">可能</span>会转移到次重音，这种情况称为<strong>重音转移</strong>，例如，She
gave a CONtroversial ANswer。</p>
<h5 id="后缀和单词的重音">2.2.1 后缀和单词的重音</h5>
<p>　　有些单词由词根和<strong>后缀</strong>组成。例如，对于dangerous，danger是词根，ous是后缀，其重音与词根的重音相同。对于commercial，commerce是词根，ial是后缀，后缀会改变次重音。</p>
<p>　　后缀-able、-ag、-al、-er、-ful、-less、-ness、-ous和-fy通常不会改变词根重读模式。<span
style="background-color: yellow">例外</span>包括ad<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>mire -
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>admireable、pre<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>fer -
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>preferable、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>medicine -
me<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>dicinal和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>agriculture
- agri<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>cultural。</p>
<p>　　后缀-ious、-ulous、-orous和-eous会让主重音移动到这些后缀所属音节的前一音节，例如，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>industry -
in<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>dustrious、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>miracle -
mi<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>raculous、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>carnivore
- car<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>nivorous和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>outrage -
out<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>rageous。</p>
<p>　　后缀-ee、-eer、-ese和-ette所属音节通常是主重音。<span
style="background-color: yellow">例外</span>包括<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>omelette、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>etiquette、em<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>ployee。</p>
<p>　　带有后缀-ial、-ic、-ion、-ive或-ity的单词的主重音通常是这些后缀所属音节的前一音节。带有后缀-ative的单词的主重音通常与对应的词根的主重音是同一音节。很多带有这些后缀的单词都可能出现重音转移的情况。</p>
<p>　　当单词以字母s或t加上后缀-ion结尾时：</p>
<p>　　● 若-tion前是字母s，则-tion发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/tʃən/</span>。</p>
<p>　　● 若-tion前是除字母s外的其他字母，则-tion发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃn/</span>。</p>
<p>　　● 若-sion前是辅音字母，则-sion发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃn/</span>。</p>
<p>　　● 若-sion前是元音字母，则-sion发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʒn/</span>。</p>
<p>　　● -ssion发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃn/</span>。</p>
<p>　　带有后缀-ant、-ent、-ance或-ence的名词和形容词的重音通常取决于这些后缀所属音节的前一音节：</p>
<p>　　● 若这些后缀所属音节的前一音节以1个元音字母 (V)
或1个元音字母加上1个辅音字母 (VC)
结尾，则重音音节通常是倒数第3个音节。</p>
<p>　　●
若这些后缀所属音节的前一音节以字母i结尾，词根以重音音节结尾，并且最后1个字母是y，则重音音节通常是这些后缀所属音节的前一音节。</p>
<p>　　● 若为其他情况，则重音音节通常是这些后缀所属音节的前一音节。</p>
<p>　　部分带有后缀-ant、-ent、-ance或-ence的单词的重音音节不同于词根的重音音节，例如，ig<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>nore -
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>ignorant和re<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>fer -
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>reference。</p>
<p>　　后缀-ment通常不会词根的重读模式。<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>advertise
- ad<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>vertisement是常见的例外之一。</p>
<p>　　有些后缀不会改变词根的重读模式，但会改变主重音中元音字母的发音，例如，wise和wisdom。对于这种情况下的部分单词，当重音音节中的元音字母的发音改变时，该元音字母后的辅音字母
(簇) 的发音或字母 (簇) 也会改变，例如，sign - signature和repeat -
repetitive。</p>
<p>　　当后缀会改变词根的重读模式时，通常也会改变其中若干个音节的发音，例如，pre<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>fer -
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>preferable。</p>
<h5 id="前缀和单词的重音">2.2.2 前缀和单词的重音</h5>
<p>　　有些单词由<strong>前缀</strong>和词根组成。常见的前缀包括de-、dis-、il-和un-。</p>
<p>　　有些单词的前缀不会重读，例如，dis<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>like、il<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>legal、re<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>claim和un<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>easy。这类单词通常只有1个重音音节，而其他带有这些前缀的单词在该前缀上有次重音。</p>
<p>　　对于带有前缀de-和re-的单词，若前缀非重读，则通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dɪ-/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/rɪ-/</span>；若前缀有次重音，则通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/diː-/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/riː-/</span>。例如，de<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>grade中的前缀de-发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dɪ-/</span>，而<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>decom<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>pose中的前缀de-发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/diː-/</span>。re<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>claim中的前缀re-发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/rɪ-/</span>，而<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>recon<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>sider中的前缀re-发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/riː-/</span>。</p>
<p>　　对于少数带有前缀de-和re-的单词，当它们作为动词时，前缀的发音中通常会有<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/-ɪ-/</span>；当它们作为名词时，前缀的发音中通常会有通常会有<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/-iː-/</span>。例如，decrease作为动词时，发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dɪˈkriːs/</span>；作为名词时，发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈdiːkriːs/</span>。</p>
<p>　　有些以re-开头的单词的发音和含义会根据re-是否表示 "再"
而改变。例如，resign <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˌriːˈsaɪn/</span>表示再次签名，而resign
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/rɪˈzaɪn/</span>表示辞职。</p>
<p>　　对于有些单词，前缀co-、counter-、hyper-、inter-、sub-、super-和under-会重读。在句子中，这些单词中的主重音通常会强读，例如，We
took the SUBway和I'm just off to the SUpermarket.</p>
<p>　　在很多带前缀的单词中，前缀是次重音，主重音在其后，例如，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>imper<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>cise和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>hyper<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>active。在日常口语中，这些单词可能会重音转移，例如，She
gave an IMpercise ANswer。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>一般会重音转移的单词</th>
<th>很少重音转移的单词</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>decom<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>pose <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>de<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>code</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>de<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>fame</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>diso<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>bedient <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>disre<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>spectful</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>dis<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>honest</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>imma<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>ture <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>impo<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>lite</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>im<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>practical</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>mis<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>place <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>mis<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>spelt</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>mis<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>judge</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>recon<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>sider <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>repro<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>dure</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>re<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>place</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>unac<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>ceptable <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>unsuc<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>cessful</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>un<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>popular</td>
</tr>
</tbody>
</table>
<h5 id="短语动词中的重音">2.2.3 短语动词中的重音</h5>
<p>　　<strong>短语动词</strong>是与介词或/和副词结合后的动词，这个介词/副词称为<strong>小品词</strong>。</p>
<p>　　单重音短语动词中的小品词通常是介词，双重音短语动词中的小品词通常是副词。少数短语动词既可以作为单重音短语动词，又可以作为双重音短语动词，其含义也会随之改变。</p>
<p>　　在日常口语中，通常不会将单重音短语动词中的小品词强读。有时，为了强调或对比，可以强读单重音短语动词中的小品词。</p>
<p>　　很多单重音短语动词中的小品词有重音和非重音形式。在日常口语中，通常会使用这些小品词的非重音形式。当这些小品词位于句子的末尾时，通常使用其重音模式。</p>
<p>　　对于2个单词的短语动词，要么主重音在动词，小品词没有重音；要么主重音在小品词，次重音在动词。</p>
<p>　　当在日常口语中使用双重音短语动词时，动词和小品词通常都会强读。若动词和小品词之间有代词，则代词通常不会强读。</p>
<p>　　对于双重音短语动词，当<span
style="background-color: yellow">特殊强调短语动词中的动词</span>、(同一句子中)
<span style="background-color: yellow">短语动词后是名词 (即宾语)
</span>或 (同一句子中) <span
style="background-color: yellow">短语动词中的动词和小品词之间有强读的名词
(即宾语) </span>时，小品词通常不会强读。</p>
<p>　　3个单词的短语动词是双重音短语动词，主重音在第2个单词
(即第1个小品词)，次重音在第1个单词。即使 (同一句子中)
3个单词的短语动词后是名词，该短语动词的前2个单词都可以强读。</p>
<h5 id="复合词中的重音">2.2.4 复合词中的重音</h5>
<p>　　复合词是一种固定表达式，由多个单词组成。</p>
<p>　　● 复合名词的拼写形式可以是 (连词符连接的) 2个单词或1个单词。</p>
<p>　　● 复合形容词的拼写形式通常是连词符连接的2个单词
(有时是1个单词)。</p>
<p>　　● 长复合词由最多3个单词组成。</p>
<p>　　大多数主重音在第2部分的复合词能进行重音转移。</p>
<p>　　2~4个字母的缩写形式发音为单独的字母时，主重音通常在最后1个字母，次重音通常在第1个字母。这些缩写形式能进行重音转移。</p>
<h6 id="复合名词中的重音">2.2.4.1 复合名词中的重音</h6>
<p>　　[名词 + 名词]、[名词 + -ing形式]、[-ing形式 + 名词]和[动词 +
名词]的复合名词的主重音通常在第1部分。<span
style="background-color: yellow">例外</span>包括如下：</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>[名词 + 名词]</th>
<th>[名词 + -ing形式]</th>
<th>[-ing形式 + 名词]</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>family
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>doctor</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>ball <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>bearing</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>casting
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>vote</td>
</tr>
<tr>
<td>infor<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>mation
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>technology</td>
<td>pe<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>destrian
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>crossing</td>
<td>de<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>fining
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>moment</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>town <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>hall</td>
<td>thanks<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>giving</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>managing
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>director</td>
</tr>
</tbody>
</table>
<p>　　若复合名词的第1部分表示第2部分的组成材料，则主重音通常在第2部分，例外包括大部分以-cake、-bread和-juice结尾的复合名词。</p>
<p>　　大部分[形容词 + 名词]、[形容词 + -ing形式]或[过去分词 +
名词]的复合名词的主重音在第2部分，次重音在第1部分。<span
style="background-color: yellow">例外</span>包括<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>blind
spot、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>broadband、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>dental
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>floss、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>easy <span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>chair、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>greenhouse。</p>
<p>　　很多复合名词派生自双重音短语动词，这类复合名词的重音通常在第1部分，例如<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>mix-up和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>washout。</p>
<p>　　有些<span
style="background-color: yellow">不是复合名词</span>的短语的拼写形式和复合名词相同，这些短语的主重音通常在第2部分。</p>
<h6 id="复合形容词中的重音">2.2.4.2 复合形容词中的重音</h6>
<p>　　[名词 + ing形式]和[名词 +
过去分词]和拼写形式为1个单词的复合形容词的主重音通常在第1部分，<span
style="background-color: yellow">例外</span>包括如下：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>拼写形式为1个单词</th>
<th>[名词 + 过去分词]</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>hand<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>made</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>eagle-<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>eyed</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>nation<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>wide</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>home-<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>grown</td>
</tr>
</tbody>
</table>
<p>　　[名词 + 形容词]、[形容词 + 名词]、[副词/形容词 +
过去分词]、[副词/形容词 +
ing形式]和self-是第1部分的复合形容词的主重音通常在第2部分。</p>
<h6 id="长复合名词中的重音">2.2.4.3 长复合名词中的重音</h6>
<p>　　很多3部分的长复合词的主重音在第3部分，次重音在第1部分。</p>
<p>　　● 对于由1个2部分的复合词加上1个单词构成的3部分的长复合词，若<span
style="background-color: yellow">2部分的复合词的重音在第1部分</span>或<span
style="background-color: yellow">2部分的复合词 (通常使用连词符)
作为形容词来描述第3部分</span>，则长复合词的主重音通常在第3部分。</p>
<p>　　● 以数字开头的3部分的长复合词的主重音通常在第3部分。</p>
<p>　　有些3部分的长复合词的主重音在第2部分，次重音在第1部分。</p>
<p>　　●
对于由1个2部分的复合词加上1个单词构成的3部分的长复合词，若2部分的复合词的重音在第2部分，则长复合词的主重音通常在第2部分。</p>
<p>　　●
对于由1个单词加上1个2部分的复合词构成的3部分的长复合词，若2部分的复合词的重音在第1部分，则长复合词的主重音通常在第2部分。</p>
<p>　　有些3部分的长复合词的主重音在第1部分，其中的大部分单词的第3部分有次重音。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>主重音在第3部分，次重音在第1部分</th>
<th>主重音在第2部分，次重音在第1部分</th>
<th>主重音在第1部分</th>
</tr>
</thead>
<tbody>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>desktop
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>publishing</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>central
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>heating
system</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>brother-in-low</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>one-parent
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>family</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>parent-<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>teacher
association</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>on-man's
land</td>
</tr>
<tr>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>state-owned
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>industry</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>safety
de<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>posit
box</td>
<td><span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˈ</span>sell-by
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ˌ</span>date</td>
</tr>
</tbody>
</table>
<h4 id="重音和非重音音节">2.3 重音和非重音音节</h4>
<p>　　<strong>实词</strong>是主要用于表意的名词、动词、形容词和副词。<strong>虚词</strong>是对句子的语法而非含义很重要的单词。</p>
<p>　　单音节实词中的元音的发音不会改变。单音节虚词中的元音的发音可能会改变。</p>
<h5 id="虚词的弱读音形态">2.3.1 虚词的弱读音形态</h5>
<table>
<colgroup>
<col style="width: 68%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr>
<th>在日常口语中通常不会强读的虚词</th>
<th>例句</th>
</tr>
</thead>
<tbody>
<tr>
<td>人称代词I、me、we、us、you、he、him、she、her、it、they和them</td>
<td>She SAW me.</td>
</tr>
<tr>
<td>所有格限定词my、your、his、her、its、our和their</td>
<td>He's my BROTHer.</td>
</tr>
<tr>
<td>each other和one another</td>
<td>They were HITing each other.</td>
</tr>
<tr>
<td>冠词a、an和the</td>
<td>It's an OWL.</td>
</tr>
<tr>
<td>限定词some和any</td>
<td>Do you WANT some?</td>
</tr>
<tr>
<td>作为宾语的不定代词some-/anybody、some-/anyone和some-/anything</td>
<td>I didn't SEE anyone.</td>
</tr>
<tr>
<td>there be句型中的there</td>
<td>There's some CAKE left.</td>
</tr>
<tr>
<td>助动词和情态动词的除否定形态以外的形态</td>
<td>I can HEAR it.</td>
</tr>
<tr>
<td>介词</td>
<td>They're from SPAIN.</td>
</tr>
<tr>
<td>连词</td>
<td>He's OLDer than me.</td>
</tr>
</tbody>
</table>
<p>　　有些虚词有强读音和弱读音形态。弱读音形态是常规发音。当这些单词强读、单独使用或在句末时，会使用强读音形态。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>弱读音形态例句</th>
<th>强读音形态例句</th>
</tr>
</thead>
<tbody>
<tr>
<td>带有<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>的虚词the、a、an、and、but、that、your、them、us、at、for、from、of、to、as、there、can、could、shall、should、would、must、do、does、am、are、was、were和some</td>
<td>I can (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kən/</span>)
SWIM.</td>
<td>I CAN (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kæn/</span>) come
after ALL.</td>
</tr>
<tr>
<td>she、he、we和you以弱元音发音为弱读音形态<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃi/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/hi/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/wi/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/jə/</span></td>
<td>Are you (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/jə/</span>)
TIRED?</td>
<td>YOU (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/juː/</span>)!</td>
</tr>
<tr>
<td>his、her、he、him、has和had在弱读音形态中经常省略<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>
(除非在句首)</td>
<td>Was he (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/hi/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/i/</span>)
THERE?</td>
<td>HE (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/hiː/</span>) was
THERE, but SHE (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃiː/</span>)
wasn't.</td>
</tr>
</tbody>
</table>
<p>　　在快速口语中，弱读音形态可能导致语句难以理解。因此，有时为了区分，不使用弱读音形态。</p>
<h5 id="虚词强读">2.3.2 虚词强读</h5>
<img src="/english/english_pronunciation_in_use/when_it_is_prominent.svg" class="">
<p>　　it很少强读，只有出现在带有this和that的某些特定句子的句末时，才会强读。</p>
<p>　　some在以下情况通常会强读：</p>
<p>　　● 表示 "有些人"，例如，SOME consider him to be the best golfer in
the world.</p>
<p>　　● 表示数量很多，例如，I didn't see her again for SOME YEARS.</p>
<p>　　● 表示未指明的特定的人或物，例如，There must be SOME time we're
all free for a meeting.</p>
<p>　　any在以下情况通常会强读：</p>
<p>　　● 表示 "任意1个"，例如，ANY of the camera shops in town will sell
them.</p>
<p>　　● 用于强调且位于否定动词后，例如，Haven't you done ANY of your
homework yet?</p>
<p>　　somebody和anybody等词作为句子的主语时，通常会强读，例如，SOMEBODY
must have seen it.</p>
<p>　　当the表示事物最好或最重要等含义时，会强读 (发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ðiː/</span>)，例如，You
should go to the Maldives. It's THE place to see coral.</p>
<p>　　助动词和情态动词为否定形态/特殊强调、表示反驳和进行时间对比时，通常会强读。</p>
<p>　　do、does和did用于现在/过去时态的强调时，通常会强读，例如，Wo DID
warn you.</p>
<p>　　在新信息或仅由虚词组成的问题中，最后1个虚词通常强读，例如，There
was nothing I could DO和What was it aBOUT?</p>
<h5 id="实词的非重音音节中的元音">2.3.3 实词的非重音音节中的元音</h5>
<p>　　对于实词，重音音节中的元音的发音通常不会随着其是否强读而改变，但非重音音节的元音的发音可以变化很大。</p>
<p>　　● 在正式场合的口语中，非重音音节的元音发音为完全形态。</p>
<p>　　● 在日常口语中，非重音音节的元音经常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>
(有时也发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪ/</span>)，例如，calendar可以发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈkælɪndə(r)/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈkæləndə(r)/</span>。</p>
<p>　　当实词中以元音结尾的非重音音节后是以元音开头的非重音音节时，这2个音节可能会合并为1个音节，这仅发生在日常口语中，正式场合的口语中不会出现这种情况。例如，casual在日常口语中可以发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kæʒ.əl/</span>，类似的词还有virtual、actual、adverbial、colonial、studious、obedient、ingredient和gradient。</p>
<h5 id="成音节">2.3.4 成音节</h5>
<p>　　大多数音节都包含1个元音。但是，有些音节仅由辅音组成，这种音节称为<strong>成音节</strong>。<span
style="background-color: yellow">可以</span>在成音节中加入元音<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>来将其发音为常规音节。因此，在部分词典中，会在成音节的前面使用符号
<sup>ə</sup>，例如，listen <span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈlɪs.<sup>ə</sup>n/</span>。</p>
<p>　　当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/b/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>后时，经常作为非重音成音节，在这种情况下，其拼写形式通常为-le
(有时是-al、-el和-ol)，例如，pistol、saddle、principal、able、hassle、hazel、knuckle和communal。</p>
<p>　　当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/v/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θ/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʃ/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʒ/</span>后时，经常作为非重音成音节，在这种情况下，其拼写形式通常为-en、-an、-ion和-ian，例如，button、sadden、happen、person、cousin、often、seven、marathon、musician和illusion。</p>
<p>　　以后缀-sm结尾的单词用会有成音节<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>，例如，criticism和enthusiasm。</p>
<p>　　didn't、haven't、shouldn't、wouldn't等形式的单词会有成音节<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/nt/</span>，例如，haven't
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈhævnt/</span>。</p>
<p>　　部分单词有2个连续的成音节，例如，conditional、diagonal、general、literal、national和veteran。</p>
<p>　　当以成音节结尾的单词后加上后缀-ing时，成音节通常会和-ing发音为1个音节，成音节会作为合并后的音节的第1个辅音。</p>
<h3 id="口语中的发音">3 口语中的发音</h3>
<h4 id="流利口语">3.1 流利口语</h4>
<p>　　如前所述，同一语音单元的单词之间通常没有停顿。前一单词末尾的音会与后一单词开头的音连在一起，从而达到平滑过渡的效果。</p>
<p>　　● 前一单词末尾的辅音会与后一单词开头的元音连在一起。</p>
<p>　　● 若前一单词末尾的辅音和后一单词开头的辅音<span
style="background-color: yellow">不同</span>，则前一单词末尾的辅音可能会变为更像后一单词开头的辅音的音。在这种情况下，若前一单词末尾的辅音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/b/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/g/</span>，并且后一单词开头的辅音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/b/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/g/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>，则前一单词末尾的辅音不会释放气流，并且会平滑地变为后一单词开头的辅音。</p>
<p>　　●
若前一单词末尾的辅音和后一单词开头的辅音相同，则两者会合并为1个更长的辅音。</p>
<p>　　●
若前一单词末尾的音和后一单词开头的音都是元音，则会在两者之间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/w/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>。在这种情况下，若前一单词末尾的元音是通过将舌头的最高端靠近口腔的<span
style="background-color: yellow">前部</span>而发出 (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/iː/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/eɪ/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aɪ/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔɪ/</span>)，则新增的音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>；若前一单词末尾的元音是通过将舌头的最高端靠近口腔的<span
style="background-color: yellow">后部</span>而发出 (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/uː/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/aʊ/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/əʊ/</span>)，则新增的音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/w/</span>。</p>
<p>　　●
若前一单词以字母-r或-re结尾，并且发音以元音结尾，而后一单词以元音开头，则会在两者之间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>。在这种情况下，某些词典为前者给出的发音中会加上符号
<span style="font-family:Lucida Sans Unicode,Lucida Grande">(r)</span>
或 <span
style="font-family:Lucida Sans Unicode,Lucida Grande"><sup>r</sup></span>，例如，car
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kɑː(r)/</span>和more
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/mɔː<sup>r</sup>/</span>。除英式口音外的很多其他口音中
(例如，苏格兰口音、爱尔兰口音和大部分北美口音)，前一单词结尾的-r或-re会一直发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>，例如，car
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/kɑːr/</span>和more
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/mɔːr/</span>。</p>
<p>　　● 在极少数情况下，若前一单词以<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɑː/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔː/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɜː/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɪə/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/eə/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ʊə/</span>结尾，并且拼写形式不以字母-r或-re结尾，后一单词以元音开头，也会在两者之间加上<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>。但是，部分以英式英语为母语的人不认可这种发音。</p>
<h5 id="缩写形式">3.1.1 缩写形式</h5>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr>
<th>缩写形式</th>
<th>对应的虚词</th>
<th>发音</th>
</tr>
</thead>
<tbody>
<tr>
<td>'d</td>
<td>had和would</td>
<td>在元音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>，在辅音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/əd/</span></td>
</tr>
<tr>
<td>'s</td>
<td>is和has</td>
<td>在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/p/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/f/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/θ/</span>后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>，其他情况下发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span></td>
</tr>
<tr>
<td>'ll</td>
<td>will</td>
<td>发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span></td>
</tr>
<tr>
<td>'ve</td>
<td>have</td>
<td>在元音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/v/</span>，在辅音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/əv/</span></td>
</tr>
<tr>
<td>'re</td>
<td>are</td>
<td>在元音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ər/</span>，在辅音后发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span></td>
</tr>
<tr>
<td>n't</td>
<td>not</td>
<td>发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/nt/</span></td>
</tr>
</tbody>
</table>
<p>　　有些虚词有缩写形式，这些缩写形式中通常包含符号
'。除了n't，其他缩写形式都不能出现在句末。在口语中，这些缩写形式常用于wh-词、名词、this/that/these/those以及there后。有时，did在wh-词后可以缩写为'd，例如，why
did you do that可以缩写为why'd you do
that。这些缩写形式在书写中的使用频率不高。</p>
<p>　　I am可以缩写为I'm，let us可以缩写为let's。</p>
<p>　　在口语中，有时会将[would/will + have]和[not +
have]都进行缩写，例如，I'll've finished it by tomorrow和I'wouldn't've
minded doing it。这种形式的缩写在书写中极少使用。</p>
<p>　　在日常口语中，句子中有had better和have got to时，缩写词'd (had)
和've (have) 有时可以省略，例如，You ('d) better apologise to her和You
('ve) gotta (=go to) be joking。</p>
<h5 id="省略">3.1.2 省略</h5>
<p>　　在口语中，可以省略部分根据语境可以得出的单词，该过程称为<strong>省略</strong>，例如，Not
sure (I'm not
sure)。但是，经常出现的情况是省略的部分留下了其中部分单词的发音，例如，'m
not sure (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/mnɒt.../</span>)，这里称之为<strong>近似省略</strong>。</p>
<p>　　省略和近似省略经常出现句首，省略的部分包括如下：</p>
<p>　　● [人称主语 + be/have]，例如，He's gone home. / Gone home. / 's
gone home.</p>
<p>　　● [it + is/has]，例如，It's really hot. / Really hot. / 'ts
really hot.</p>
<p>　　● be，例如，Is that Ken? / That Ken? / 's that Ken?</p>
<p>　　● [助动词/be + 主语]，例如，Do you want another drink? / Want
another drink? / d'y (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dʒ/</span>) want
another drink?、Have you seen my keys? / Seen my keys? / v'y (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/vj/</span>) seen
my keys?和Are you leaving already? / Leaving already? / r'y (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/əj/</span>)
leaving already? / 'y (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>)
leaving already?</p>
<p>　　wh-疑问句中疑问词和主语之间的be和have经常可以省略，例如，What are
you doing? / What you doing? / What're you doing?</p>
<p>　　dose在wh-词后时，只能近似省略 (发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/z/</span>)，例如，When
dose it start? / When's it start?</p>
<h5 id="省略辅音">3.1.3 省略辅音</h5>
<p>　　当前一单词以辅音簇结尾，并且最后1个辅音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>，后一单词以除<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>之外的其他辅音开头时，经常会省略前一单词结尾的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>，例如，las<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">t</span>
night和I collec<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">t</span>
coins。</p>
<p>　　当前一单词以辅音簇<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/skt/</span>结尾时，若后一单词以元音或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>开头，则经常会省略前一单词结尾辅音簇中的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>；若后一单词以除<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>之外的其他辅音开头，则经常会省略前一单词结尾辅音簇中的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/k/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>。例如，He
ris<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">k</span>ed
his life (...<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/rɪstɪz/</span>...)
和He ris<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">ked</span>
losing (...<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/rɪsluː/</span>...)。</p>
<p>　　在日常口语中，当<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>在音节末，并且之前的音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/或元音</span>时，若<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>之后的音节以辅音开头或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>所属音节位于句末，部分人则会将<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>替换为<span
style="background-color: yellow">喉塞音</span>，即声门关闭引起的气流瞬时中断而成的塞音，其国际音标符号为
<span
style="font-family:Lucida Sans Unicode,Lucida Grande">ʔ</span>。例如，football
(<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈfʊʔbɔːl/</span>)、pointless
(<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈpɔɪnʔləs/</span>)和It
cost a lot (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/lɒʔ/</span>)。</p>
<p>　　若前一单词以<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>结尾，后一单词以<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>开头，则<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>通常会合并为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/tʃ/</span>，只要满足条件，这种情况下也可以将<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/t/</span>替换为喉塞音。例如，las<u>t
y</u>ear (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/tʃ/</span>) 和I
can't let you (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/letʃuː/</span>或<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/leʔjuː/</span>)
do it。</p>
<p>　　当前一单词以辅音簇结尾，并且最后1个辅音是<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>，后一单词以除<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/m/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/s/</span>之外的其他辅音开头时，经常会省略前一单词结尾的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>，例如，a
ol<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">d</span>
car和I chang<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">ed</span>
clothes。</p>
<p>　　若前一单词以<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>结尾，后一单词以<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>开头，则<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/d/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/j/</span>通常会合并为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dʒ/</span>，例如，I'll
len<u>d y</u>ou (<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/dʒ/</span>)
one。</p>
<p>　　代词he/her/his/him、助动词have/has/had和疑问词who中开头的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/h/</span>经常会省略，除非这些词重读或位于句首，例如，ask
<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">h</span>im和<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">wh</span>o
did it。</p>
<p>　　同一单词中，很多人会省略<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ɔː/</span>后的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>，例如，a<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">l</span>most和a<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">l</span>so。</p>
<p>　　and通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ən/</span>，例如，red
an<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">d</span>
blue和pen an<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">d</span>
ink。</p>
<p>　　若of后的单词以辅音开头时，则of通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>；若of后的单词以元音开头时，则of通常发音为<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/əv/</span>。例如，a
waste o<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">f</span>
time和a can of oil。</p>
<h5 id="省略音节">3.1.4 省略音节</h5>
<p>　　在日常口语中，有些单词的元音可以省略，在这种情况下，这些单词会省略1个非重音音节，例如，av<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>rage和happ<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>ning。有些词典会将用符号
<span
style="font-family:Lucida Sans Unicode,Lucida Grande"><sup>ə</sup></span>
代表可以省略的<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ə/</span>，例如，<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈæv<sup>ə</sup>rɪdʒ/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/ˈhæp<sup>ə</sup>nɪŋ/</span>。</p>
<p>　　当元音在<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>前时，通常都可以省略，在这种情况下，单词可能会省略1个非重音音节。例如，accident<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">a</span>lly、batt<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>ry、conf<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>rence、consid<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>rable、deaf<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>ning、nati<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">o</span>nal、second<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">a</span>ry。</p>
<p>　　少数单词中除<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/r/</span>、<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/l/</span>和<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/n/</span>外的其他辅音前的元音可以省略，例如，gov<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">ern</span>ment、med<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">i</span>cine和veg<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>table。</p>
<p>　　在快速口语中，少数重音在第2个音节的双音节词中的第1个元音经常会省略，从而导致单词变为单音节词，例如，I
don't b<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">e</span>lieve
(<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/bliːv/</span>) in
you和I s<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">u</span>ppose
(<span
style="font-family:Lucida Sans Unicode,Lucida Grande">/spəʊz/</span>)
so。少数单词可以省略第1个音节，例如，<span
style="text-decoration: line-through; text-decoration-thickness: 2px;">a</span>bout
five o'clock、I brought it <span
style="text-decoration: line-through; text-decoration-thickness: 2px;">be</span>cause
it was cheap和I've invited everyone <span
style="text-decoration: line-through; text-decoration-thickness: 2px;">ex</span>cept
Jack，在这种情况下，这些单词的拼写形式中会变为'bout、'cause和'cept。</p>
<h4 id="在对话中组织信息">3.2 在对话中组织信息</h4>
<p>　　在说话时，通常会根据含义和强调来将划分语音单元。尽管如何划分语音单元没有确切的规则，但为了让语句更通顺，有些词更容易组合成语音单元。例如，通常是//
we stuck a picture// of an elephant//，而非// we stuck a// picture of an
elephant//或// we stuck a picture of// an elephant//。</p>
<p>　　有时，语句的含义会根据语音单元的划分不同而不同。例如，对于// we
were rather than naughty// once// we stuck a picture// of an
elephant//和// we were rather than naughty once// we stuck a picture//
of an elephant//，前者表示多次并举例其中1次，而后者表示仅有1次。</p>
<h5 id="语音单元中的强读词">3.2.1 语音单元中的强读词</h5>
<p>　　在同一语音单元中，部分单词会强读
(提供重要/有趣的信息、对比、强调或纠正)，其他则不会 (旧信息)。</p>
<img src="/english/english_pronunciation_in_use/the_last_prominent_word_in_a_speech_unit.svg" class="">
<p>　　对于包含多个强读词的语音单元，其中的最后1个强读词是该语音单元的主要的升/降调的起点。</p>
<h5 id="语音单元中的固定短语和习语">3.2.2
语音单元中的固定短语和习语</h5>
<p>　　固定短语和习语通常处于同一语音单元，不会跨域多个语音单元。但是，较长的习语通常会划分为多个语音单元。例如，//
a race against time//、// I could barely hear myself think//和// I could
count// on the fingers of one hand// the number of times I've seen her
this year。</p>
<p>　　很多固定短语和习语有2个强读音节，其中的部分固定短语和习语的最后1个单词中有1个强读音节，其他则不然。例如，a
RACE against TIME、to CALL it a DAY、THROW your WEIGHT around和a WHOLE
new BALL name。</p>
<h5 id="无实义实词的非强读">3.2.3 无实义实词的非强读</h5>
<p>　　部分语音单元末尾的单词不会强读，因为这些单词<span
style="background-color: yellow">无实义</span> (不包含新信息)。</p>
<p>　　●
部分单词引用已提及的内容或内容与之前已提及的内容重复，所以它们无实义。例如，Gail
talked to me about Oscar as if I knew him well, although I've never MET
her brother中，her brother表示Oscar，所以不会强读。</p>
<p>　　●
部分单词的意义可以根据前文和特殊场景预测出来，所以它们无实义。例如，I
must get my HAIR cut中，cut可以根据语境预测出来，所以不会强读。</p>
<p>　　● 部分惯用短语的末尾会有若干个无实义的单词。例如，It was her
fourth novel that she really MADE a NAME for herself和Being a builder is
a hard job, even at the BEST of times。</p>
<h5 id="模糊表达的非强读">3.2.4 模糊表达的非强读</h5>
<p>　　当无需具体描述时，通常会使用模糊表达。大部分模糊表达位于语音单元的末尾。它们通常不会强读，并且紧跟着强读单词。</p>
<p>　　当引用已提及的事物或地点时，可以使用the stuff、the place(s)和the
thing(s)。可以用sort of加上这些词来进行举例，sort of前可以加上 (all)
this/that/these/those。例如，My car's always breaking down. I HATE the
thing和Before we could use the laboratory, we had to learn about safety
and all THAT sort of stuff。</p>
<p>　　可以用and stuff、and things和and
places等方式来粗略引用事物和地点，例如，We went through Berlin, BONN and
places。</p>
<p>　　and that表示涉及其他事情 (不给出详情)，例如，Kate is gone
upstairs to do her HAIR and that。</p>
<p>　　可以用or something/anything
(etc.)来让刚才所说的内容更模糊或间接。or something/anything (etc.) like
that与之类似。例如，Let me know if you want any HELP or anything。</p>
<p>　　短语or/and +
whatever/whenever/wherever/whoever会使句子更非正式或间接，例如，When we
move into the flat, we can change the carpets and LIGHTS and
whatever。</p>
<p>　　短语or
so与表示次数或时间的句子一起使用时，可以使次数或时间更不准确，例如，About
a WEEK or so。</p>
<h5 id="反身代词和人称代词的强读">3.2.5 反身代词和人称代词的强读</h5>
<p>　　当反身代词引用主语或紧跟动词/介词时，通常不会强读。为了强调，反身代词也可以强读。</p>
<p>　　● 反身代词在名称和代词后，用于强调该名称/代词，例如，I'm flying
to Rome, but the AIRport itSELF is miles from the city。</p>
<p>　　● 反身代词在句末，用于强调主语，例如，They drew the posters
themSELVES。</p>
<p>　　● 反身代词强调某人将/已经独立进行某事，例如，We had the beach all
to ourSELVES。</p>
<p>　　人称代词通常不会强读。为了将某个/群人与其他人进行对比，人称代词也可以强读，例如，Throw
it to ME, not to HIM。</p>
<h4 id="语调">3.3 语调</h4>
<p>　　在每个语音单元中，声音有1个主要的变化
(降调或升调)，始于语音单元的最后1个强读词。升调和降调的范围可以是语音单元末尾的1个单词，也可以是语音单元末尾的多个非强读音节。</p>
<img src="/english/english_pronunciation_in_use/falling_and_rising_tones.svg" class="">
<p>　　降调表示语音单元中的信息是<span
style="background-color: yellow">新信息</span>，升调表示语音单元中的信息是<span
style="background-color: yellow">旧信息</span>。</p>
<h5 id="尾句">3.3.1 尾句</h5>
<p>　　在日常口语中，为了强调刚才所说的内容，会使用<strong>尾句</strong>。尾句是1个名称
(短语)，通常是升调，因为它是对之前所说内容的引用或扩展。例如，在She's a
JUDGE, my AUNT中，my aunt就是升调的尾句。</p>
<p>　　●
有些尾句包含this、that、these、those或以这些单词开头的短语。</p>
<p>　　● 其他尾句则是对之前所说内容的引用。</p>
<p>　　在日常口语中，另一种类型的尾句也是升调，这种尾句是重复之前说过的[主语
+ 动词]。</p>
<p>　　部分其他尾句是降调，例如，在wh-疑问句后加上尾句来使问题更明确。在What
time's it ON, this THOW?中，this show是降调的尾句。</p>
<h5 id="疑问尾句">3.3.2 疑问尾句</h5>
<p>　　<strong>疑问尾句</strong>是添加在陈述句后的疑问句。</p>
<p>　　● 向对方确定自己所说的内容是否正确时
(给出自己的意见等)，疑问尾句通常是降调，例如，GREAT FILEM, WASn't
it?中，WASn't it就是降调的疑问尾句。</p>
<p>　　● 询问对是否赞成自己所说的内容时
(不太确定自己所说的内容是否正确等)，疑问句通常是升调，例如，NOT on a
DIET again, ARE you?中，are you是升调的疑问尾句。</p>
<p>　　当疑问尾句之前的句子显然是正确时，疑问尾句通常是降调。</p>
<p>　　为了让对方同意对方之前可能不同意的某事时
(实际上是正确的)，疑问尾句会使用降调。</p>
<p>　　疑问尾句也可以添加在感叹句后，此时，疑问尾句是降调。</p>
<p>　　当疑问尾句和之前的句子都是肯定句时，疑问尾句通常是升调，例如，Came
by CAR, DID you?中，did
you是升调。这种模式有时会用于批评和讽刺，此时，通常以So和Oh开头。</p>
<p>　　疑问尾句还可以添加在祈使句后 (通常是will you、can't you、would
you和shall we)，此时，疑问尾句通常是升调，作用是让祈使句更温和。</p>
<h5 id="分裂句">3.3.3 分裂句</h5>
<p>　　<strong>分裂句</strong>分为2部分，有助于将重点放在其中的1部分。分裂句在口语中很常见，例如，在What
I lost was gold necklace中，my gold necklace是重点。</p>
<p>　　what-分裂句的第1部分是[what + 主语 + 动词]，第2部分是[be +
重点]。第1部分通常是先降调再升调，第2部分通常是降调。有时，what-分裂句的第1部分和第2部分的顺序是相反的，此时，它们的语调与正常情况下相同。为了强调只有1件事，可以用all代替what。</p>
<p>　　it-分裂句的第1部分是[it + be + 重点]，第2部分是相关句子
(that或who)。第1部分通常是降调，第2部分的语调取决于其内容，若其内容是新信息，则是先降调再升调；若其内容是旧信息，则是降调。</p>
<h5 id="疑问句">3.3.4 疑问句</h5>
<p>　　当提问时，可能是为了了解不知道的事情，也可能是为了确定所了解的情况是否正确。前者通常以降调结尾，后者通常升调或先降调再升调结尾。</p>
<p>　　当为了确定所了解的情况是否正确而提问时，先降调再升调比升调<span
style="background-color: yellow">更礼貌</span>。例如，Are you SURE you
can MANage that?就是先降调再升调。</p>
<p>　　wh-疑问句经常是为了了解不知道的事情，yes-no疑问句经常是为了确定所了解的情况是否正确。有时，wh-疑问句也可以用于确定所了解的情况是否正确，yes-no疑问句也可以用于了解不知道的事情。</p>
<p>　　带有would you mind、perhaps和I
wonder的疑问句用于请求帮助时，通常是降调。wh-疑问句和yes-no疑问句用于提供帮助时，通常是降调
(表示真诚)。例如，Can I HELP you?和WHAT can I DO for you?都是降调。</p>
<p>　　为了获得对方答复的陈述句通常是升调，因为是为了了解不知道的事情。例如，You
HAVEen't even STARted?是升调。</p>
<p>　　疑问句也经常用于发表评论和感叹，此时，回答不是必要的。</p>
<p>　　● 否定yes-no疑问句用于表示惊讶和高兴时
(尤其是希望对方同意自己)，通常是降调，例如，WASn't it
TERrible?是降调。在日常口语中，肯定yes-no疑问句可用于批评，此时，通常是升调，例如，Are
you CRAzy?是升调。</p>
<p>　　● wh-疑问句用于发表评论时
(尤其是与情态动词一起使用)，通常是降调，例如，HOW was I supposed to
know?是降调。</p>
<p>　　有时，会在疑问句后加上1个自己的回答
(确定自己所想的内容是否正确)，此时，通常是先降调在升调，例如，Where are
you off to? The SUpermarket?就是先降调再升调。</p>
<p>　　疑问句还可以用于给出指示或建议
(经常会包含情态动词)，此时，通常是降调，例如，WHY don't you go by
TRAIN?是降调。</p>
<p>　　有时，为了让对方重复刚才所说的全部或部分内容，会提问，此时，疑问句是为了确定所了解的情况是否正确，所以经常是升调。</p>
<p>　　●
部分重复问题的组成结构可以是1个wh-词，也可以是以wh-词开头的短语/疑问句，还可以是常规单词/短语。</p>
<p>　　●
重复问题可以是对方刚才所说的内容或将对方刚才所说的内容中的部分词替换为[do
+ what]/wh-词，例如，You're staying with WHO?和You did WHAT?是升调。</p>
<p>　　用于重复问题时，相比SORRy?和PARdon?等，WHAT?和You
WHAT?相对更不礼貌，有些人会避免使用。</p>
<h5 id="比较和对比">3.3.5 比较和对比</h5>
<img src="/english/english_pronunciation_in_use/comparisons_and_contrasts.svg" class="">
<p>　　当对比2个单词/短语时，会将对比部分强读来强调。同样，新信息是降调，旧信息是升调。</p>
<p>　　比较和对比的常用模式如下：</p>
<p>　　● 使用形容词的比较级，例如，在I think it's more important to have
COMfortable clothes than STYlish ones中，comfortable
clothes是降调，stylish ones是升调。</p>
<p>　　● 使用either...or，例如，在I've either left my wallet at HOME or
I've LOST it中，home是先降调再升调，lost it是降调。</p>
<p>　　● 使用..., not...或...not ..., ...，例如，He's got bronCHItis,
not just a COUGH中，bronchitis是降调，cough是先降调再升调。</p>
<p>　　● 使用其他比较短语，例如，Rather than catch the BUS, maybe we
could WALK home中，bus是先降调再升调，walk home是降调。</p>
<h5 id="反驳请求和保留意见">3.3.6 反驳、请求和保留意见</h5>
<p>　　当反驳某件事时，会强调侧重双方观点差异的单词，该单词通常是降调，并且音高会升高。</p>
<p>　　●
在反驳肯定形态动词时，可以使用not和包含n't的缩写形式，此时，not和缩写形式会强读。</p>
<p>　　●
在反驳否定形态动词时，会使用助动词和情态动词的肯定形式，此时，助动词和情态动词会强读。</p>
<p>　　● 进行其他类型的反驳时，会强调用于纠正对方的单词。</p>
<img src="/english/english_pronunciation_in_use/contradictions.svg" class="">
<p>　　有时，用于反驳的强调候选词可能有多个。</p>
<p>　　当提出请求、表达对某事的保留意见和谈论已经被取消的安排时，通常先降调再升调。</p>
<img src="/english/english_pronunciation_in_use/the_meaning_of_a_negative_sentence_may_change_according_the_sentence's_tone.svg" class="">

&#12288;&#12288;有时，否定句的含义会随着降调或先降调再升调而改变。

##### 3.3.7 态度词和短语

<img src="/english/english_pronunciation_in_use/attitude_words_and_phrases_1.svg" class="">

&#12288;&#12288;很多单词和短语可用于表示态度，这些单词和短语通常位于句首或句末，经常是1个单独的语音单元，并且其语调通常是固定的。

&#12288;&#12288;有些态度词和短语用于强调自己所说的内容是真实的，例如，believe 'me、'surely、to put it 'mildly和to say the 'least。当它们位于句首或句末时，通常是降调。

&#12288;&#12288;有些单词用于表明所说的内容的视角，即确定讨论的内容的特征，例如，physically、logically、economically、outwardly、politically、statistically、superficially和technically。这些单词通常是升调或先降调再升调。

&#12288;&#12288;短语mind you通常位于句首，并且是降调，用于强调后面的信息。

&#12288;&#12288;短语the (only) thing is ...通常位于句首，并且是升调或先降调再升调，用于突出问题与刚才所说的内容有关。

&#12288;&#12288;短语the fact/point is ...用于指明将要说的内容很重要，短语the question/problem is ...用于指明将要说的内容是重要的问题或难题，它们都通常是升调或先降调后升调。

<img src="/english/english_pronunciation_in_use/attitude_words_and_phrases_2.svg" class="">

&#12288;&#12288;以下态度词和短语在句首 (或and和but后) 时，通常是先降调再升调；在句末时，通常是升调：

&#12288;&#12288;● 很多副词可用于表示对自己所说的内容的看法，例如，unfortunately、amazingly、astonishingly、curiously、fortunately、funnily、interestingly、luckily、oddly、regrettably、remarkably、sadly、strangely、surprisingly和unbelievably。部分列举的单词 (尤其是curiously、funnily、interestingly、luckily、oddly、strangely和surprisingly) 可以与enough组成短语来表达看法。

&#12288;&#12288;● actually位于句首或句末时，可以让其后的内容更礼貌，尤其是纠正他人所说的内容、给出不同的看法以及拒绝请求或提议。

&#12288;&#12288;● apparently、presumably和supposedly表示并不能很确定自己所说的内容是正确的。

&#12288;&#12288;● 有些态度词和短语表示所说的内容只是大致情况，例如，'basically、es'sentially、'generally、as a 'rule、by and 'large、in 'general和on the 'whole。

##### 3.3.8 感叹句

<img src="/english/english_pronunciation_in_use/exclamations.svg" class="">
<p>　　感叹句可以是1个形容词，此时，通常是向升调再降调。部分积极的形容词独立成句并使用降调时，通常表示讥讽。</p>
<p>　　当感叹句是1个完整的句子，并且强调的是形容词时
(经常与absolutely、completely和totally一起使用)，该形容词通常是先升调再降调。</p>
<p>　　部分感叹句的结构是[how + 形容词]，形容词通常是先升调再降调。</p>
<p>　　名词和不包含形容词的短语也能作为感叹句，通常是先升调再降调。</p>
<p>　　really作为感叹句时，通常是先升调再降调。</p>
<h5 id="保持对话的进行">3.3.9 保持对话的进行</h5>
<img src="/english/english_pronunciation_in_use/keeping_conversation_going_1.svg" class="">
<p>　　在对话中，经常会使用单词或短语来让对方继续
(通常是升调)，例如，mm、uhuh、mhm、okay、right、yeah和I
see。当这些单词或短语是降调时，经常表示自己认为对方已经说完或想要改变话题。</p>
<img src="/english/english_pronunciation_in_use/keeping_conversation_going_2.svg" class="">
<p>　　有些单词和短语可以添加到肯定句后，以确认对方是否理解或接受所说的内容，此时，通常是升调，例如，alright、you
know、okay、you
see和right。对应的回答经常是mm、uhuh、mhm、okay、right、yeah和I
see等单词或短语 (通常是降调)，表示自己已经理解或接受。</p>
<p>　　为了表示对对方所说的内容感兴趣或希望对方继续，可以使用较短的疑问句，例如，really、did
you、were they、haven't we，这些疑问句通常先降调再升调。</p>
<h5 id="补充信息和改变话题">3.3.10 补充信息和改变话题</h5>
<img src="/english/english_pronunciation_in_use/adding_information_and_changing_topic_1.svg" class="">
<p>　　很多单词和短语可以用于补充与之前所说内容相关的信息。部分这样的单词通常是1个单独的语音单元，并且是升调或先升调再降调，例如，also、otherwise、similarly、at
the same time、better still、by the some token、even better、in that
case、in the same way、in other words、on top of that和worse still。</p>
<img src="/english/english_pronunciation_in_use/adding_information_and_changing_topic_2.svg" class="">
<p>　　当需要改变话题或讨论当前话题的其他方面时，经常会使用anyhow、anyway、incidentally
(将要说的内容不如之前说的内容重要)、now (then)、okay、right、well和by
the way等单词或短语，它们通常是降调，并且是1个单独的语音单元。</p>
<img src="/english/english_pronunciation_in_use/adding_information_and_changing_topic_3.svg" class="">
<p>　　部分人会使用look来引入希望对方注意的当前话题的其他方面
(降调)，但是，其他人只通过这种方式来表达生气。</p>
<p>　　besides可以用于提供某事的其他理由或论据 (降调)。</p>
<h3 id="正式场合的发音">4 正式场合的发音</h3>
<img src="/english/english_pronunciation_in_use/dividing_prepared_speech_into_units_1.svg" class="">
<p>　　在演讲中，倾向于按照句子的边界 (标点符号等)
来划分语音单元的边界。</p>
<p>　　● 根据连接2个句子的and和but划分语音单元。</p>
<p>　　● 根据状语从句划分语音单元。</p>
<p>　　● 根据主语从句划分。</p>
<p>　　● 根据非限定性定语从句划分语音单元。</p>
<p>　　限定性定语从句很少与其引用的名词处于不同的语音单元，例如，在Thu
number of people who are emigrating// is increasing
steadily中，people与who are emigrating处于同一语言单元。</p>
<p>　　由多个较短的句子组成的句子可能不会划分语音单元，例如，We'll leave
when we can只有1个语音单元。</p>
<img src="/english/english_pronunciation_in_use/dividing_prepared_speech_into_units_2.svg" class="">
<p>　　对于演讲，除了按照句子的边界划分语音单元，还会按照特定的语法单元来划分语音单元。</p>
<p>　　● 根据引用整个句子的状语划分语音单元。</p>
<p>　　● 当主语是较长的短语时，主语会作为单独的语音单元。</p>
<p>　　● 根据包含连词或形容词的缩略句划分语音单元。</p>
<p>　　● 根据句首的非主语的单词或短语划分，包括<span
style="background-color: yellow">提供时间或地点相关信息的状语短语</span>、<span
style="background-color: yellow">表示所说内容的联系的连接副词或短语</span>
(furthermore和in the meantime等)、<span
style="background-color: yellow">表示所说内容的所处阶段的单词和短语</span>
(firstly和in summary等) 和<span
style="background-color: yellow">位于动词之前的宾语</span>。</p>
<p>　　此外，也可以将希望听者重点关注的单词或短语放在1个单独的语音单元中，例如，在the
name of the process is//
electrolysis中，electrolysis是1个单独的语音单元。</p>
<h4 id="插入语">4.1 插入语</h4>
<img src="/english/english_pronunciation_in_use/inserts.svg" class="">
<p>　　在写作时，有时会在某些单词前后加上破折号或括号，这些单词会为句子补充可以忽略的信息，这些单词称为<strong>插入语</strong>。</p>
<p>　　● 插入语可以表示内容是如何组织的。</p>
<p>　　● 插入语可用于举例。</p>
<p>　　● 插入语可用于限制所说的内容。</p>
<p>　　● 插入语可用于给出更多细节。</p>
<p>　　● 插入语可用于表达个人看法。</p>
<p>　　在演讲中，插入语通常是1个单独的语音单元，前后都会有停顿，通常是先降调再升调。但是，对于较长的插入语，其发音可能包括更多升调和降调。</p>
<h4 id="升高和降低音高">4.2 升高和降低音高</h4>
<img src="/english/english_pronunciation_in_use/contrasts_and_new_topics.svg" class="">
<p>　　在演讲中，为了进行对比或开始新话题，通常会让对应的语音单元的第1个强读词的音高升高。</p>
<img src="/english/english_pronunciation_in_use/adding_information_and_ending_topics.svg" class="">
<p>　　当用名词短语来为之前的提到的名词短语补充相关信息时
(或这2个名词短语都是引用同一人或物)，通常会让该名词短语的音高相对其所属的语音单元更低。若名词短语是新信息，则使用降调；反之，则使用升调或先降调再升调。这种方式也同样适用于句子。此外，在演讲中，为了结束话题，也会使用这种方式。</p>
<h4 id="一系列相似项中的语调">4.3 一系列相似项中的语调</h4>
<img src="/english/english_pronunciation_in_use/tones_in_a_series_of_similar_items.svg" class="">
<p>　　在演讲中，当列举2个以上的相似项时，每个项通常都是1个单独的语音单元。在大多数情况下，只有最后1个项是降调
(表示结束)，其他项都是升调或先降调再升调
(表示它们在某种程度上相似)。但是，在日常口语中，情况并非完全如此，例如，1个语音单元可以包含多个项或不完整的一系列项。</p>
<p>　　● 若项中的单词不提供新信息，则通常不会强读。</p>
<p>　　●
对于作为例程一部分或重复的一系列项，除了最后1个项是降调，其他项都是平调
(有时是升调)。</p>
<p>　　● 若需要强调每个项都是独立和重要的，则每个项都会使用降调。</p>
<h4 id="引用和建立悬念时的平调">4.4 引用和建立悬念时的平调</h4>
<img src="/english/english_pronunciation_in_use/level_tone_in_quoting_and_building_suspense.svg" class="">
<p>　　当引用别人所说的话时，经常会使用平调并在最后1个语音单元使用降调，以表示只是简单引用别人所说的话而非解析其含义。</p>
<p>　　引用别人所说的话时所用<strong>转述动词</strong>通常是平调，其音高通常相对较高。转述动词后会有停顿，然后是引用的话，引用的话的第1个单词的音高也会相对较高。</p>
<p>　　可以通过升高音高、平调和停顿来建立悬念。</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
  </entry>
  <entry>
    <title>《ARM Cortex-M3与Cortex-M4权威指南 第3版》第3章 技术综述</title>
    <url>/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_03/</url>
    <content><![CDATA[<p>　　所有Cortex-M处理器都是32位RISC处理器，其寄存器、内部数据路径和总线接口都是32位。</p>
<p>　　除了能够处理32位数据之外，Cortex-M处理器也能高效地处理8位和16位数据。Cortex-M3和Cortex-M4处理器还支持一些涉及64位数据的操作
(例如，乘法和累加)。</p>
<p>　　Cortex-M处理器使用了32位地址 (4GB的地址空间)
和统一内存映射，所以程序代码、数据、外设和处理器内部的部分调试支持组件共享内存空间。</p>
<p>　　与其他ARM处理器一样，Cortex-M处理器基于加载-存储架构，这表示数据需要从存储器中加载，然后进行处理，最后通过多个独立的指令写回到存储器。例如，增加存储在SRAM中数据的值需要3条指令。第1条指令会将数据从SRAM读取到处理器内部的寄存器，第2条指令会增加数据的值，第3条指令会将数据写回到存储器。处理器内部的寄存器细节称为<span
style="background-color: yellow">程序员模型</span>。</p>
<p>　　对于ARM处理器，术语架构可以指2个方面：</p>
<p>　　● 架构 (ISA、程序员模型和调试方法)</p>
<p>　　● 微架构
(接口信号、指令执行时序和流水线阶段等特定于处理器设计的细节)</p>
<p>　　不同ARM处理器使用的架构不尽相同。ISA可以通过各种微架构实现
(例如，不同数量的流水线阶段和不同类型的总线接口协议)。</p>
<p>　　Cortex-M处理器的总线接口是32位，并且基于AMBA标准
(AMBA包含一系列总线协议规范)。</p>
<p>　　Cortex-M3和Cortex-M4处理器使用了3阶段流水线设计
(取指阶段、译码阶段和执行阶段) 和哈佛总线架构
(可以同时取指和访问数据)。</p>
<span id="more"></span>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_03/block_diagram_of_the_cortex-m3_and_cortex-m4_processor.svg" class="">
<p>　　从宏观角度，Cortex-M3和Cortex-M4处理器极其相似。尽管内部数据路径设计存在显著差异，但处理器的某些部分
(例如，NVIC、取指缓冲区以及译码和执行阶段的某些部分)
是相似的。此外，处理器核心之外的组件几乎相同。</p>
<p>　　Cortex-M3和Cortex-M4处理器包含处理器核心、NVIC、SysTick定时器和可选的浮点处理单元
(FPU)。除此之外，处理器还包含内部总线系统、可选的内存保护单元和一系列用于支持软件调试操作的组件。内部总线互联用于将处理器和调试器的传输路由到设计的各个部分。</p>
<p>　　Cortex-M3和Cortex-M4处理器具有高度可配置性。例如，调试功能是可选的，以允许片上系统设计者在产品不需要调试支持时移除调试组件，进而减少芯片面积。在某些情况下，芯片设计者还可以选择减少硬件指令断点和数据观察点比较器的数量来减少门数。中断输入的数量、中断优先级的数量和MPU等很多功能也是可配置的。</p>
<p>　　Cortex-M3和Cortex-M4处理器支持多处理器设计的独占访问
(对多处理器设计中的信号量很重要)。</p>
<h3 id="指令集">3.1 指令集</h3>
<p>　　ARM7TDMI等经典处理器有2种工作状态：32位的ARM状态和16位的Thumb状态。当处于ARM状态时，指令是32位，并且核心能以非常高的性能执行指令。当处于Thumb状态时，指令是16位
(提供出色的代码密度)，但Thumb指令不具备ARM指令的所有功能，并且完成特定类型的操作需要更多指令。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_03/switching_between_arm_code_and_thumb_code_in_classic_arm_processors_such_as_arm7tdmi.svg" class="" title="switching_between_arm_code_and_thumb_code_in_classic_arm_processors_such_as_arm7tdmi">
<p>　　为了两全其美，很多经典ARM处理器的应用程序都支持ARM代码和Thumb代码的混合。但是，混合代码的设计也存在问题。在这2种状态之间切换存在开销，并且这2种状态的分离会增加软件编译过程的复杂度。</p>
<p>　　随着Thumb-2技术的推出，Thumb指令集扩展为同时支持16位和32位指令编码，这让不需切换状态就能完成所有处理成为可能。实际上，Cortex-M处理器完全不支持32位ARM指令
(经典ARM处理器会在处理中断时会切换到ARM状态，但Cortex-M处理器不会)。借助Thumb-2技术，Cortex-M处理器在某些方面比经典ARM处理器更具优势：</p>
<p>　　● 没有状态切换开销 (节省了执行时间和指令空间)。</p>
<p>　　● 无需在源文件中指定ARM状态或Thumb状态 (让软件开发更简单)。</p>
<p>　　● 同时获取最佳的代码密度、效率和性能。</p>
<p>　　●
相比ARM7TDMI等经典ARM处理器，Thumb-2技术大幅扩展了Thumb指令集。</p>
<p>　　尽管所有Cortex-M处理器支持Thumb-2技术，但它们实现的指令集只是Thumb
ISA的各种子集：</p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 25%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr>
<th>指令组</th>
<th>Cortex-M0和Cortex-M1</th>
<th>Cortex-M3</th>
<th>Cortex-M4</th>
<th>带有FPU的Cortex-M4</th>
</tr>
</thead>
<tbody>
<tr>
<td>16位ARMv6-M指令</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>带有链接的32位分支指令</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>32位系统指令</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>16位ARMv7-M指令</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>32位ARMv7-M指令</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>DSP扩展</td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>浮点指令</td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>　　Cortex-M处理器不支持Thumb ISA的部分指令
(例如，尽管添加了独立的内存映射数据处理引擎，但依然不支持协处理器指令)。此外，Cortex-M处理器也不支持部分来自经典ARM处理器的Thumb指令
(例如，会导致处理器立即从Thumb状态切换到ARM状态的带有链接和切换的分支指令、部分会导致处理状态切换的指令以及设置大端或小端的指令)。</p>
<h3 id="存储器系统">3.2 存储器系统</h3>
<p>　　Cortex-M3和Cortex-M4处理器本身没有存储器
(即没有程序存储器、SRAM和缓存)。相反，它们通常配备了通用片上总线接口，所以微控制器供应商可以添加自己的存储器系统。微控制器供应商通常会将程序存储器
(通常是闪存)、数据存储器 (通常是SRAM) 和外设添加到存储器系统。</p>
<p>　　通过这种方式，不同的微控制器产品可以具有不同的存储器配置、不同的存储器容量和不同的外设。</p>
<p>　　Cortex-M3和Cortex-M4处理器主要使用的总线接口协议是AHB Lite
(用于程序存储器和系统总线接口)。AHB
Lite是流水线总线协议，允许高频率操作和低硬件面积成本。此外，AHB
Lite还支持插入等待状态、多个总线主机共享同一总线和总线错误条件。另一个使用的总线协议是APB
(用于基于ARM的微控制器的外设系统)。此外，APB还用于Cortex-M3和Cortex-M4处理器的调试支持。</p>
<p>　　不同于片外总线协议，AHB
Lite和APB相当简单，因为芯片内部的硬件配置是固定的，所以不需要复杂的初始化协议来控制各种可能的配置。</p>
<p>　　使用开放且通用的总线架构允许芯片设计者为ARM处理器开发外设、存储控制器和片上存储器模块。</p>
<p>　　Cortex-M3和Cortex-M4处理器还支持可选的位带功能：SRAM和外设区域中的2个位寻址区域。通过位带别名地址的位值修改会转换为对位带区域的原子读-修改-写操作。</p>
<p>　　虽然Cortex-M3和Cortex-M4处理器在大端和小端模式下都可以运行，但几乎所有微控制器都设计为大端或小端模式之一。大多数Cortex-M微控制器产品使用的是小端模式。</p>
<h3 id="低功耗">3.3 低功耗</h3>
<p>　　Cortex-M处理器设计为低功耗实现。很多Cortex-M3和Cortex-M4微控制器的运行电流可以低于200μA/MHz
(在1.8V的供电电压下约为0.36mW/MHz)，其中的部分微控制器的运行电流甚至可以低于100μA/MHz。Cortex-M处理器包括以下低功耗特性：</p>
<p>　　● Cortex-M3处理器专为低成本微控制器设计，其芯片面积较小
(门数较少)。Cortex-M4处理器由于添加了SIMD指令和浮点指令而略微增加了芯片面积。3阶段流水线设计在性能和芯片面积之间达到了良好的平衡。</p>
<p>　　●
Cortex-M处理器的高代码密度允许软件开发者以更小的程序存储器来实现其目的
(更小的程序存储器可以降低功耗)。</p>
<p>　　●
Cortex-M处理器提供了大量低功耗功能，包括架构中定义的睡眠模式和集成的架构时钟门控支持。</p>
<p>　　●
完全静态、异步和可合成的设计使处理器能够使用任何低功耗和标准半导体工艺制造。从Cortex-M3的第2版开始
(以及目前所有的Cortex-M4版本)，处理器还支持额外的WIC，以进一步降低功耗。</p>
<p>　　除了能够延长电池寿命之外，微控制器的低功耗还有助于减少电磁干扰，并可能简化电源设计
(或减小电池尺寸)，从而降低系统成本。</p>
<h3 id="内存保护单元">3.4 内存保护单元</h3>
<p>　　MPU是Cortex-M3和Cortex-M4处理器的可选功能。微控制器供应商可以选择是否添加该功能。MPU是监控总线事务的可编程设备，并且需要通过软件
(通常是嵌入式OS)
配置。若添加了MPU，则应用程序可以将内存划分为多个区域，并定义每个区域的访问权限。当违反访问规则时，会生成故障异常。故障处理函数能够分析故障，并在可能时进行修复。</p>
<p>　　MPU可以以多种方式使用。通常，OS可以设置MPU来保护OS内核和其他特权任务使用的数据，防止不受信任的用户程序损坏它们。此外，OS也能在不同的任务之间隔离内存区域。这些措施可以更好地检测系统故障，并使系统在处理错误条件时更具健壮性。</p>
<p>　　MPU也可用于将内存区域设置为只读来防止意外擦除SRAM中的数据被或覆盖指令码。</p>
<p>　　在默认情况下，MPU会关闭，并且不使用该功能的应用程序不必对其进行初始化。</p>
<h3 id="中断处理">3.5 中断处理</h3>
<p>　　Cortex-M3和Cortex-M4处理器包含1个称为NVIC的中断控制器。NVIC提供了以下功能：</p>
<p>　　●
支持多达240个中断输入、1个NMI输入以及多个系统异常。除了NMI之外，其他中断都可以启用或关闭。</p>
<p>　　●
支持可编程优先级。对于Cortex-M3和Cortex-M4处理器，优先级可以在运行时动态修改
(Cortex-M0和Cortex-M0+不支持动态修改优先级)。</p>
<p>　　● 支持中断/异常优先级自动处理和嵌套中断/异常处理。</p>
<p>　　● 支持向量中断/异常，这表示处理器会自动获取中断/异常向量
(无需软件确定目标中断/异常)。</p>
<p>　　● 向量表可以重定位到内存的不同区域。</p>
<p>　　● 低中断延迟 (对于零等待状态内存系统，中断延迟仅为12个周期)。</p>
<p>　　● 中断和很多异常可以由软件触发。</p>
<p>　　● 各种优化以减少在不同异常上下文之间切换时的中断处理开销。</p>
<p>　　● 支持中断/异常屏蔽机制
(允许屏蔽NMI之外的所有中断和异常，或屏蔽优先级低于某个阈值的中断/异常)。</p>
<p>　　为了支持以上功能，NVIC有很多可编程寄存器。这些寄存器是映射到内存的，并且CMSIS-Core提供了大多数常见中断控制任务所需的寄存器定义和访问函数
(这些访问函数在Cortex-M0等其他Cortex-M处理器上也能使用)。</p>
<p>　　存储着中断和系统异常的起始地址的向量表是系统内存的一部分。在默认情况下，向量表位于内存空间的<span
style="background-color: yellow">起始处</span>
(地址<code>0x0</code>)，但向量表偏移量可以在运行时修改。对于大多数应用程序，向量表在编译时可以设置为应用程序映像的一部分，并在运行时保持不变。</p>
<p>　　NVIC提供的信号的数量和支持的可编程中断优先级由微控制器供应商在设计芯片时决定。</p>
<h3 id="os支持和系统级功能">3.6 OS支持和系统级功能</h3>
<p>　　Cortex-M3和Cortex-M4处理器设计为高效地支持嵌入式OS。内置的系统节拍
(SysTick) 定时器可以设置为生成周期性定时器中断
(用于OS时间记录)。由于Cortex-M3和Cortex-M4处理器都提供了SysTick定时器，所以嵌入式OS的源码可以轻松地在这些设备上使用，而无需针对特定于设备的定时器进行修改。</p>
<p>　　Cortex-M3和Cortex-M4处理器有多种栈指针：用于OS内核和中断的主栈指针和用于应用程序任务的进程栈指针。通过这种方式，OS内核使用的栈可以与应用程序任务使用的栈分离。这不仅提高了可靠性，还能优化栈空间的使用。对于不需要使用OS的简单应用程序，可以直接使用主栈指针。</p>
<p>　　为了进一步提供系统可靠性，Cortex-M3和Cortex-M4处理器支持特权工作模式和非特权工作模式的分离。处理器默认以特权模式启动。当在OS中执行用户任务时，用户任务的执行在非特权工作模式下进行。特权工作模式和非特权工作模式的分离可以与MPU一起使用来防止非特权任务访问特定内存区域。通过这种方式，用户任务无法损坏OS内核和其他任务使用的数据。</p>
<p>　　Cortex-M处理器还支持多个故障处理函数。若检测到故障
(例如，访问无效内存地址)，则会触发故障异常，而故障处理函数可以作为防止系统进一步故障和诊断错误的措施。</p>
<h3 id="调试支持">3.7 调试支持</h3>
<p>　　Cortex-M3和Cortex-M4处理器的闪存补丁和断点单元支持多达8个用于断点的硬件比较器
(6个用于指令地址，2个用于字面数据地址)。当触发这些比较器时，会停止处理器或将数据传输重映射到SRAM位置。重映射功能允许修改只读的程序内存位置。</p>
<p>　　Cortex-M3和Cortex-M4处理器的数据观察点和跟踪单元支持多达4个硬件数据观察点比较器。这些比较器可用于在访问特定数据时停止处理器或生成可以通过跟踪接口收集的跟踪信息
(无需停止处理器)。然后，调试器可以在IDE中显示数据值和额外信息，以可视化数据随时间的变化。</p>
<p>　　Cortex-M3和Cortex-M4处理器还包含1个可选的嵌入式跟踪宏单元模块，该模块可以用于跟踪指令。</p>
<p>　　可以通过JTAG连接或串行线调试接口来调试Cortex-M3和Cortex-M4处理器。很多开发工具供应商都支持这2种协议。跟踪信息可以通过串行线查看器接口收集。若需要高跟踪带宽
(例如，使用指令跟踪)，则需要使用跟踪端口接口来收集跟踪信息。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第1章 历史和标准</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_01/</url>
    <content><![CDATA[<p>　　贝尔实验室 (电话公司AT&amp;T的部门之一) 的Ken
Thompson于1969年用汇编语言开发了第1个UNIX实现 (同年Linus
Torvalds出生)，用于Digtial PDP-7微型计算机。名称UNIX是<span
style="background-color: yellow">多路复用信息与计算服务</span> (MULTICS)
的双关语，MULTICS是AT&amp;T与麻省理工学院和通用电气公司合作的早期操作系统项目的名称的。此时，AT&amp;T已经退出MULTICS，因为该项目最初未能开发出有经济收益的系统。Thompson根据MULTICS为他的新操作系统拟定了一些想法，包括树状结构的文件系统、用于解释命令的独立程序
(即shell) 和将文件视为非结构化的字节流的概念。</p>
<p>　　在1970年，UNIX被用汇编语言重写，用于新收购的Digtial
PDP-11微型计算机和之后的功能更强大的新型计算机。大部分UNIX实现和Linux中使用的多个名称中仍然有PDP-11遗产的痕迹。</p>
<p>　　不久之后，Dennis
Ritchie设计并实现了C，他是Thompson在贝尔实验室的同事和UNIX的早期合作者。这是革命性的进程，C遵循更早的解释型语言B。B最早由Thompson实现，从更早的编程语言BCPL中吸收了很多思想。到1973年，C已经很成熟，UNIX内核几乎可以完全用C重写。因此，UNIX成为了用高级语言编写的最早的操作系统之一，这使得后续将UNIX移植到其他硬件架构成为可能。</p>
<p>　　C的起源解释了为何如今C和C++被广泛使用。之前广泛使用的语言在设计时都考虑了其他用途
(FORTRAN可用于工程师和科学家执行的数学任务，而COBOL可用于处理面向记录的数据流的商业系统)。C的设计源于少数人的想法和需求，他们朝着同一目标努力：开发1种用于实现UNIX内核和相关软件的高级语言。就像UNIX操作系统本身，C由专业程序员为自己使用而设计。</p>
<span id="more"></span>
<h3 id="unix简介">1.1 UNIX简介</h3>
<p>　　从1969年到1979年，UNIX进行多次版本发布。从本质上说，这些版本是AT&amp;T不断发展的开发版本的快照。</p>
<p>　　●
第1版发布于1971年11月。该版本可运行在PDP-11上，并且包含1个FORTRAN编译器和多个现在依旧在使用的程序的早期版本
(包括<code>ar</code>、<code>cat</code>、<code>chmod</code>、<code>chown</code>、<code>cp</code>、<code>dc</code>、<code>ed</code>、<code>find</code>、<code>ln</code>、<code>ls</code>、<code>mail</code>、<code>mkdir</code>、<code>mv</code>、<code>rm</code>、<code>sh</code>、<code>su</code>和<code>who</code>)。</p>
<p>　　●
第2版发布于1972年1月。此时，UNIX已经安装在AT&amp;T内部的10台机器上。</p>
<p>　　●
第3版发布于1973年2月。该版本包含1个C编译器和第1个管道的实现。</p>
<p>　　● 第4版发布于1973年11月。该版本是第1个几乎完全用C开发的版本。</p>
<p>　　● 第5版发布于1974年1月。此时，UNIX已经安装在50多个系统中。</p>
<p>　　●
第6版发布于1975年5月。该版本是第1个在AT&amp;T之外被广泛使用的版本。</p>
<p>　　在这段时间内，AT&amp;T对美国电话系统拥有政府批准的垄断权。AT&amp;T与美国政府的协议中的条目让AT&amp;T无法出售软件，所以UNIX也不能作为商品出售。从1974年的第5版开始，尤其是第6版，AT&amp;T以象征性的发行费来授权在大学中使用UNIX。大学发行版包括文档和内核代码
(大约1万行)。</p>
<p>　　AT&amp;T将UNIX发布到大学的行为极大地促进了操作系统的使用和普及。在1977年，UNIX运行在大约500个站点上，包括美国和其他国家的125所大学。UNIX为大学提供了便宜且功能强大的交互式多用户操作系统
(当时的商业操作系统十分昂贵)。这也为大学的计算机科学系提供了真实操作系统的源码，这些源码可以被修改以及提供给学生来学习和实验。有些掌握了UNIX的学生成为了UNIX的布道者，其他学生则后来成立或加入初创公司，销售运行UNIX的廉价计算机工作站。</p>
<p>　　1977年到1978年，UNIX系统第1次被移植到PDP-11之外的硬件。Dennis
Ritchie和Steve Johnson将UNIX移植到Interdata
8/32，同时，澳大利亚伍伦贡大学的Richard Miller将UNIX移植到Interdata
7/32。伯克利数字VAX移植版基于John Reiser和Tom London的早期 (1978年)
移植版，也称为32V，该版本与PDP-11的第7版大致相同，除了更大的地址空间和数据类型。</p>
<p>　　1979年1月，UNIX第7版发布，该版本提升了系统的稳定性，并提供了1个增强型文件系统。此外，该版本还包含<code>awk</code>、<code>make</code>、<code>sed</code>、<code>tar</code>、<code>uucp</code>、Bourne
shell和FORTRAN
77编译器等大量新工具。该版本意义重大，因为自此开始，UNIX分化出了2个重要变体——<span
style="background-color: yellow">伯克利软件套件</span> (BSD) 和<span
style="background-color: yellow">System V</span>。</p>
<p>　　Thompson于1975/1976学年担任其母校加州大学伯克利分校的客座教授。在这里，他与几位研究生一起为UNIX添加了很多特性
(其中的学生Bill Joy参与了Sun
Microsystem的创立)。随着时间的流逝，加州大学伯克利分校开发了很多特性和工具，包括C
shell、<code>vi</code>编辑器、改良型文件系统
(伯克利快速文件系统)、<code>sendmail</code>、Pascal编译器和新型数字VAX架构的虚拟内存管理。</p>
<p>　　在BSD的名义下，这个版本的UNIX (包含源码)
被广泛发行。第1个完整的发行版是1979年12月的3BSD。加州大学伯克利分校早期的发行版BSD和2BSD是该校开发的新工具集，而非完整的UNIX发行版。</p>
<p>　　在1983年，加州大学伯克利分校的计算机系统研究组发布了4.2BSD，该版本拥有完整的TCP/IP实现，包含套接字API和大量网络工具。4.2BSD及其前身4.1BSD在世界各地的大学广泛传播，它们也构成了SunOS
(第1次发布于1983年)
的基础，SunOS是Sun公司销售的UNIX变体。其他重要的BSD发行版包括1986年的4.3BSD和1993年的4.4BSD
(最终发行版)。</p>
<p>　　与此同时，美国反垄断法迫使AT&amp;T分立
(该事件始于20世纪70年代中期，AT&amp;T分立生效于1982年)。其结果是AT&amp;T不再垄断电话系统，但被允许销售UNIX。因此，AT&amp;T发布了System
III，System
III由AT&amp;T的UNIX支持组开发，UNIX支持组雇佣了数百名开发者来优化UNIX和开发UNIX应用程序。System
V第1次发布于1983年，并在1989年进行多次版本发现，最终推出了System V
Release 4 (SVR4)。此时，System
V已经集成了BSD的很多特性，包括网络工具。System
V被授权给多个商业供应商，这些供应商将其作为UNIX实现的基础。</p>
<p>　　最后，除了BSD在学术界的传播，在20世纪80年代晚期，UNIX在很多硬件上都有大量商业化实现，包括Sun的Sun
OS和后来的Solaris、Digtial的Ultrix和OSF/1
(经过了一系列的改名和收购后，成为了如今的HP True 64
UNIX)、IBM的AIX、HP的HP-UX、NeXT的NeXTStep、苹果为麦金塔开发的A/UX、微软和SCO为Intel
x86-32架构共同开发的XENIX。当时，更常见的情况是每个供应商生产1种或最多几种专有计算机芯片架构，并在其架构上销售自己的专有操作系统。大多数供应商系统的专有性质使得采购商只能选择1个供应商。若需要切换到其他专有系统和硬件平台，则需要移植现有应用程序和重新培训员工，其成本十分高昂。这一因素再加上各种供应商的廉价单用户UNIX工作站的出现，使得UNIX系统更具有商业吸引力。</p>
<p>　　20世纪90年代早期，支持x86-32的免费UNIX已经出现。Bill
Jolitz和其妻子Lynne
Jolitz为x86-32开发了成熟的BSD移植版，称为386/BSD。386/BSD基于4.3BSD源码的版本之一BSD
Net/2 (1991年1月)，其中的AT&amp;T专有代码要么被删除，要么被替换
(其中6个源文件已经琐碎到无法重写，只能移除)。Jolitz夫妇将Net/2代码移植到x86-32，重写了缺失的源文件，并在1992年2月发布了386/BSD的第1版0.0。</p>
<p>　　在最初的成功和流行后，由于各种原因，386/BSD的开发停滞。随着补丁的积压，2个替代开发组很快出现，它们基于386/BSD分别开发自己的版本——NetBSD和FreeBSD，前者侧重于各种硬件平台的可移植性，后者侧重于性能
(也是如今最传播最广的现代BSD)。NetBSD的第1版0.7发布于1993年4月。FreeBSD
CD-ROM (版本1.0) 出现于1993年12月。另一种BSD OpenBSD出现于1996年
(初始版本号2.0)，它是NetBSD项目的分支，侧重于安全性。2003年年中出现了新BSD
DragonFly BSD，它从FreeBSD 4.x中分裂出来。DragonFly
BSD在对称多处理架构方面使用了与FreeBSD 5.x不同的方法。</p>
<p>　　在20世纪90年代早期，UNIX系统实验室
(AT&amp;T用于开发和销售UNIX的子公司)
与加州大学伯克利分校出现了法律纠纷。1992年初，伯克利软件设计公司
(如今已成为WInd River的一部分) 开始发行商业支持的BSD BSD/OS
(基于Net/2发行版和Jolitz夫妇的386/BSD附件)，发行的二进制文件和源码售价995美元，该公司还支持潜在的客户拨打它们的电话号码1-800-ITS-UNIX。</p>
<p>　　在1992年4月，UNIX系统实验室起诉了伯克利软件设计公司，以阻止其销售包含UNIX系统实验室的专有代码和商业机密的产品。UNIX系统实验室还要求伯克利软件设计公司停止使用欺骗性的电话号码。该诉讼最终扩大到包括对加州大学伯克利分校的索赔。法院最终驳回了UNIX系统实验室的2项索赔外的其他索赔。随后，加州大学反诉UNIX系统实验室，声称System
V在未经许可的情况下中使用了BSD的代码。</p>
<p>　　在这些诉讼悬而未决期间，UNIX系统实验室被Novell收购。Novell的CEO
Ray Noorda (目前已故)
公开表示更愿意在市场上竞争，而非在法庭上竞争。最终在1994年1月达成和解，加州大学被要求删除出Net/2发行版的18000个文件中的3个，对其他小部分文件进行小幅修改，并在大约70个其他文件中添加UNIX系统实验室版权声明，但该大学仍然可以继续发行这些文件。修改后的系统以4.4BSD-Lite发布于1994年6月
(该大学的最后1个发行版本4.4BSD-Lite版本2发布于1995年6月)。法律条款还要求伯克利软件设计公司、FreeBSD和NetsBSD用修改后的4.4BSD-Lite源码替换基于Net/2的代码部分。这场法律纠纷导致BSD衍生系统的开发出现了一些滞后，但也有积极意义，即这些系统与加州大学的计算机系统研究组自Net/2发布以来所做的3年开发工作再次同步。</p>
<h3 id="linux简介">1.2 Linux简介</h3>
<p>　　通俗意义上的Linux (即整个Linux系统)
的大部分源码来自GNU项目，GNU的创建者Richard
Stallman倾向于用GNU/Linux来表示整个Linux系统。命名问题在自由软件社区的引起了一些争论。因为之后的内容主要与Linux内核的API相关，所以这里使用术语Linux来表示整个系统。</p>
<p>　　对于早期Linux，
用户需要装配软件、创建文件系统并在文件系统上正确地放置和配置所有软件，这需要大量的时间和专业知识。Linux发行商便应运而生，负责创建用于自动化大部分安装过程、创建文件系统和安装内核以及必需软件的包
(发行版)。</p>
<p>　　最早的一批Linux发行商出现在1992年，包括MCC Interim
Linux、TAMU和SoftLanding Linux系统
(SLS)。目前仍然存在的历史最悠久的Linux发行商Slackware出现在1993年。非商业的Debian发行版大约出现在这一时间，随后是SUSE和Red
Hat。Ubuntu发行版最早出现在2004年。现在，很多Linux发行公司都会雇佣积极为自由软件项目做出贡献和启动新项目的程序员。</p>
<h4 id="gnu项目">1.2.1 GNU项目</h4>
<p>　　在1984年，受雇于MIT的程序员Stallman着手于创建1个 "free"
UNIX实现。在他的观点中，这里的free是法律意义上的自由，而非经济意义上的免费。然而，Stallman所描述的法律上的自由有1个隐含的后果——操作系统等软件将以非常低的价格甚至免费提供。</p>
<p>　　Stallman反对计算机供应商对专有操作系统的法律限制。这些限制使得计算机软件的购买者通常无法看见所购软件的源码，他们当然不能复制、修改或发行。他指出，这种情况会鼓励程序员与其他程序员竞争并隐藏其成果，而非协作和分享。为此，Stallman发起了GNU
(GNU's not UNIX)
项目来开发1个自由获取的完整的类UNIX系统，包含内核及相关软件包，并且他还鼓励其他来加入他。在1985年，Stallman创建了非营利性组织——自由软件基金会
(FSF)，用于支持GNU项目和自由软件的开发。</p>
<p>　　当GNU项目成立时，BSD并非Stallman所指的自由，BSD的使用需要AT&amp;T的许可证，用户不能自由地修改和发行BSD中AT&amp;T的专有代码部分。</p>
<p>　　<strong>GNU通用公共许可证</strong> (GPL)
是GNU项目的重要成果之一，这是Stallman自由软件理论的法律体现。Linux发行版中的大部分软件
(包括内核)
都是使用GPL或类似的许可证授权。使用GPL的软件必须以源码的形式提供，并且必须可以根据GPL条款再次发行。此外，可以自由地对GPL授权的软件进行修改，修改后的软件也必须符合GPL条款。若修改后的软件以可执行文件的形式发行，则开发者必须允许接收者以不高于发行成本的价格获取修改后的源码。GPL第1版发布于1989年。GPL第3版
(即最新版)
发布于2007年。GPL第2版发布于1991年，该版本如今仍然被广泛使用，Linux内核的许可证就是该版本。</p>
<p>　　GNU项目最初没有开发出可运行的UNIX内核，但是开发了大量的其他程序。因为这些程序设计为可以运行在类UNIX操作系统上，所以它们可以运行在UNIX实现上，甚至可以移植到其他操作系统。GNU开发的软件中，比较知名的软件包括Emacs文本编辑器、GCC
(原为GNU
C编译器，现已更名为GNU编译器合集，包括C、C++和其他语言的编译器)、bash
shell和glibc (GNU C库)。</p>
<p>　　在20世纪90年代早期，GNU项目开发出了近乎完整的操作系统，除了可以运行的UNIX内核。GNU项目开始开发基于Mach微内核的内核——GNU/HURD，但是HURD的完成度很低
(在撰写本书时，HURD的开发工作仍在继续，此时，HURD还是只能运行在x86-32架构上)。</p>
<h4 id="linux内核">1.2.2 Linux内核</h4>
<p>　　在1991年，芬兰赫尔辛基大学的学生Linus Torvalds萌生了为他的Intel
80386 PC开发操作系统的想法。在他的学习过程中，Torvalds曾接触过Minix
(20世纪80年代中期阿姆斯特丹自由大学的教授Andrew
Tanenbaum开发的类UNIX操作系统内核)。Tanenbaum提供了Minix的源码，作为在大学中教授操作系统设计的工具。Minix内核可以在386系统上构建和运行。但是，由于Minix主要作为教学工具，其设计很大程度上独立于硬件架构，并且没有完全发挥386
CPU的性能。</p>
<p>　　因此，Torvalds成立了1个项目来开发了可运行在386上的高效且功能齐全的UNIX内核。数月后，Torvalds开发了1个能编译和运行各种GNU程序的基础内核。在1991年10月，Torvalds请求其他程序员的帮助：</p>
<blockquote>
<p>Do you pine for the nice days of Minix-1.1, when men were men and
wrote their own device drivers? Are you without a nice project and just
dying to cut your teeth on a OS you can try to modify for your needs?
Are you finding it frustrating when everything works on Minix? No more
all-nighters to get a nifty program working? Then this post might be
just for you. As I mentioned a month ago, I'm working on a free version
of a Minix-look-alike for AT-386 computers. It has finally reached the
stage where it's even usable (though may not be depending on what you
want), and I am willing to put out the sources for wider distribution.
It is just version 0.02 . . . but I've successfully run bash, gcc,
gnu-make, gnu-sed, compress, etc. under it.</p>
</blockquote>
<p>　　遵循类UNIX系统以字母X结尾的悠久传统，该内核最终命名为Linux。最初，Linux使用的许可证更严格。随后，Torvalds将许可证改为GPL。</p>
<p>　　事实证明，呼吁支持很有效。其他开发者纷纷加入了Torvalds，共同开发Linux和添加新特性
(例如，更高级的文件系统、网络支持、设备驱动和多处理器支持)。Linux
1.0发布于1994年3月。Linux 1.2发布于1995年3月。Linux
2.0发布于1996年6月。Linux 2.2发布于1999年1月。Linux
2.4发布于2001年1月。Linux 2.5的开发始于2001年11月，这使得Linux
2.6能在2003年12月发布。</p>
<p>　　Linux的最初开发目标是Intel
80386上的高效实现，而非移植到其他处理器架构。随着Linux的普及，Linux移植版开始出现。开始只有Digital
Alpha移植版，后来LInux移植到了很多硬件架构，包括x86-64、Motorola/IBM
PowerPC和PowerPC64、Sun SPARC和SPARC64 (UltraSPARC)、MIPS、ARM
(Acorn)、IBM z系列 (以前称为System/390)、Intel IA-64、Hitachi SuperH、HP
PA-RISC和Motorola 68000。</p>
<h4 id="linux内核版本号">1.2.3 Linux内核版本号</h4>
<p>　　与大多数自由软件项目一样，Linux使用了 "早发布、常发布"
的模型，所以内核版本的发布频率很高。随着Linux用户基数的增加，发布模型也进行了调整，以减少对现有用户的影响。从Linux
1.0开始，内核开发者采用了x.y.z的版本命名方案，x表示主要版本，y表示主要版本的次要版本，z表示次要版本的修订版本
(次要版本改进和漏洞修复)。</p>
<p>　　在此模型下，有2个内核版本同时开发——稳定分支
(用于生产系统，其次要版本号是偶数) 和开发分支
(其次要版本号是奇数，表示稳定分支的下一个更大的次要版本号)。实际中并非严格如此，所有新特性都应该添加到当前开发分支，而稳定分支中的修订版本仅包含次要版本改进和漏洞修复。当当前开发分支适合发布时，会作为新的稳定分支并分配偶数次要版本号。例如，开发分支2.3.z可以发布时，会发布为稳定分支2.4。</p>
<p>　　随着内核版本2.6的发布，开发模型发生了改变，主要因为稳定分支间隔过长而导致的问题
(2.4.0和2.6.0的间隔时间接近3年)。开发模型的细节会不定期地修改，但基本细节不变：</p>
<p>　　●
开发分支和稳定分支不再分离。每个新的2.6.z版都可以包括新特性，其生命周期从添加新特性开始，然后通过多个候选版本稳定下来。当候选版本足够稳定时，会发布为2.6.z稳定版。发布周期通常是3个月。</p>
<p>　　●
有时，2.6.z稳定版可能需要小补丁来修复漏洞和安全问题。若这些修复优先级较高且补丁简单到看似明显正确，则会发布为版本2.6.z.r，r是2.6.z的当前次要版本的序列号。</p>
<p>　　● 确定发行版内核稳定的责任转移给了发行版供应商。</p>
<h3 id="标准化">1.3 标准化</h3>
<p>　　在20世纪90年代晚期，各种可用的UNIX实现都有自己的缺点。有些UNIX实现基于BSD，其他UNIX实现基于System
V，部分UNIX实现从BSD和System
V中都吸收了特性。此外，每个商业供应商都为自己的UNIX实现添加了额外特性。结果是当人员和软件从某个UNIX实现转移到其他UNIX实现时，情况变得越来越困难。这种情况为C和UNIX系统的标准化带来了很大的压力，应用程序的移植也因此变得更简单。</p>
<p>　　除了参考由独立或多方团体制定的标准，有时还会参考BSD最终版
(即4.4BSD) 和AT&amp;T的System V Release 4 (即SVR4)
制定的实现标准。SVR4实现标准是通过AT&amp;T发布的System V接口定义 (SVID)
正式确定的。在1989年，AT&amp;T发布了SVID Issue
3，该版本定义了SVR4必须提供的接口。</p>
<p>　　由于SVR4和BSD的部分系统调用和库函数的行为之间的差距，很多UNIX实现提供了兼容性库和条件编译工具来模拟该实现未使用的基础UNIX风格
(SVR4或BSD) 的行为，这减少了移植应用程序时遇到的阻力。</p>
<h4 id="c语言">1.3.1 C语言</h4>
<p>　　在20世纪90年代早期，C已经存在10年了，并实现在各种UNIX实现和其他操作系统上。各个实现之间的小差异越来越多，部分原因是Kernighan和Ritchie于1978年出版的书《The
C Programming
Language》中没有详述C运作的某些方面。因此，1985年出现的C++强调在不破坏现有程序的情况下对C进行改进和添加新特性，尤其是函数原型、结构体赋值、类型限定符
(<code>const</code>和<code>volatile</code>)、枚举类型和关键字<code>void</code>。</p>
<p>　　这些因素推动着C的标准化。1989年美国国家标准学会 (ANSI)
批准了C标准，该标准随后在1990年被国际标准化组织 (ISO) 采用 (ISO/IEC
9899:1990)。除了定义C的语法和语义外，该标准还描述了标准C库，其中包括标准I/O函数、字符串处理函数、数学函数和各种头文件。该标准称为<span
style="background-color: yellow">C89</span>或<span
style="background-color: yellow">ISO
C90</span>，Kernighan和Ritchie于1988年出版的《The C Programming
Language》第2版全面地描述了该版本。</p>
<p>　　在1999年，ISO发布了C标准第2版 (ISO/IEC
9899:1999)。该标准称为<span
style="background-color: yellow">C99</span>，包括对于大量C和标准库的修改，这些修改包括添加<code>long long</code>和布尔数据类型、C++风格注释<code>//</code>、受限指针以及长度可变的数组。在2011年，ISO发布了C标准第3版
(ISO/IEC 9899:2011)。该标准称为<span
style="background-color: yellow">C11</span>或<span
style="background-color: yellow">C1X</span>。</p>
<p>　　从历史角度，C89过去经常被称为<span
style="background-color: yellow">ANSI
C</span>，即使如今的有些情况下也是如此。例如，gcc就使用了这一含义，限定符<code>-ansi</code>表示支持所有ISO
C90程序。但是，随着ANSI采用了C99，ANSI应该表示C99。这里为了避免歧义，之后的内容不会使用该术语。</p>
<p>　　C标准独立于操作系统，这表示仅使用标准库的C程序可以移植到任何带有C实现的电脑和操作系统上。</p>
<h4 id="posix.1">1.3.2 POSIX.1</h4>
<p>　　在<span
style="background-color: yellow">电气与电子工程师协会</span> (IEEE)
的<span style="background-color: yellow">可移植应用程序标准委员会</span>
(PASC) 主持下制定的一系列标准称为<strong>可移植操作系统接口
</strong>(POSIX)。PASC标准的目标是在源码级别上提高应用程序的可移植性。</p>
<p>　　POSIX.1在1988年成为IEEE标准，其修订版在1990年成为了ISO标准
(ISO/IEC 9945-1:1990)。POSIX.1最初基于早期的非官方标准
(1984年)，该标准由名为/usr/group的UNIX供应商协会制定。</p>
<p>　　POSIX.1记录了1组服务共有的1个API，这些服务应该由符合标准的操作系统提供给应用程序。符和标准的操作系统可以认证为<span
style="background-color: yellow">符合POSIX.1</span>。</p>
<p>　　POSIX.1基于UNIX系统调用和C库函数API，但它不需要任何特定的实现与该接口关联，即所有操作系统都可以实现该接口，而非特定UNIX操作系统。实际上，有些供应商会为它们的专有UNIX操作系统添加接口来保证其符合POSIX.1，同时保持底层操作系统基本不变。</p>
<p>　　POSIX.1的很多扩展也很重要。IEEE POSIX 1003.1b (也称为<span
style="background-color: yellow">POSIX.1b</span>，以前称为POSIX.4或POSIX
1003.4) 于1993年获批，包含大量基于POSIX基础标准的实时扩展。IEEE POSIX
1003.1c (也称为<span style="background-color: yellow">POSIX.1c</span>)
于1995年获批，定义了POSIX线程。1996年，POSIX.1的修订版发布 (ISO/IEC
9945-1:1996)，其核心内容不变，但加入了实时和线程扩展。IEEE POSIX 1003.1g
(也称为<span style="background-color: yellow">POSIX.1g</span>)
定义了套接字等网络接口。IEEE POSIX 1003.1d (也称为<span
style="background-color: yellow">POSIX.1d</span>) 于1999年获批。<span
style="background-color: yellow">POSIX.1j</span>于2000年获批，定义了POSIX基础标准的额外实时扩展。</p>
<p>　　POSIX.1b的实时扩展包含文件同步、异步I/O、进程调度、高精度时钟和定时器以及使用信号量、共享内存和消息队列的进程间通信。前缀POSIX经常用于3种进程间通信方式，以区分相似但更早的System
V信号量、共享内存和消息队列。</p>
<p>　　POSIX.2发布于1992年 (ISO/IEC
9945-2:1993)，它标准化了shell和各种UNIX工具
(包括C编译器的命令行界面)。</p>
<p>　　美国政府采购计算机系统时所用的标准称为<span
style="background-color: yellow">美国联邦信息处理标准</span>
(FIPS)。FIPS 151-1发布于1989年，基于1988年的POSIX.1和ANSI
C标准草案。FIPS 151-1和POSIX.1 (1988)
的主要区别是POSIX.1中的部分可选项在FIPS
151-1中是必需的。由于美国政府是计算机系统的主要购买者之一，大部分计算机供应商都会保证其UNIX系统符合POSIX.1的FIPS
151-1版本。FIPS 151-2与1990年的ISO版POSIX.1完全相同。现已过时的FIPS
151-2于2000年2月被撤销。</p>
<h4 id="xopen-company和the-open-group">1.3.3 X/Open Company和The Open
Group</h4>
<p>　　<span style="background-color: yellow">X/Open
Company</span>是1个由国际计算机供应商集团组成的联盟，旨在采用和调整现有标准，以制定1套全面且一致的开放系统标准。该联盟推出了1套基于POSIX的可移植性指南——<strong>X/Open可移植性指南</strong>
(XPG)，该指南的第1个重要版本是1989年发布的Issue 3
(XPG3)，然后是1992年发布的XPG4。XGP4在1994年进行了修订，得到了XPG4第2版，该标准还成为了AT&amp;T的SVID
Issue 3的一部分。XPG4第2版也称为<span
style="background-color: yellow">Spec
1170</span>，其中1170表示标准定义的接口 (包括函数、头文件和命令)
的数量。</p>
<p>　　1993年初，Novell收购了AT&amp;T的UNIX系统业务，然后将其剥离并将UNIX商标转让给了X/Open
(转让于1993年宣布，但由于法律要求而被推迟到1994年初执行)。XPG4第2版之后被重新打包为<strong>单一UNIX规范</strong>
(SUS)，也称为<span style="background-color: yellow">SUSv1</span>或<span
style="background-color: yellow">UNIX
95</span>，其中包括XPG第2版、X/Open Curses Issue 4第2版规范以及X/Open
Networking Services (XNS) Issue 4规范。SUSv2 (有时也称为XPG5)
出现于1997年，通过该规范认证的UNIX实现可以称为<span
style="background-color: yellow">UNIX 98</span>。</p>
<p>　　20世纪80年代晚期UNIX之战期间形成的2个对立的供应商联盟：<span
style="background-color: yellow">开放软件基金会</span> (OSF)
和UNIX国际联盟，前者包括Digtial、IBM、HP、Apollo、Bull、Nixdorf和Siemens等公司，后者包括AT&amp;T和Sun等公司。</p>
<p>　　在1996年，X/Open与OSF合并为<span
style="background-color: yellow">The Open
Group</span>。如今，几乎每个与UNIX相关的组织和公司都是The Open
Group的成员，而The Open Group还在继续制定API标准。</p>
<h4 id="susv3和posix.1-2001">1.3.4 SUSv3和POSIX.1-2001</h4>
<p>　　1999年初，IEEE、The Open Group和ISO/IEC联合技术委员会1在<span
style="background-color: yellow">奥斯汀通用标准修订小组</span>
(名称源于其成立会议于1998年9月在德州奥斯汀举行)
中合作，以修订和整合POSIX和SUS。结果是POSIX 1003.1-2001 (也称为<span
style="background-color: yellow">POSIX.1-2001</span>)
获批，并在2001年12月成为了ISO标准 (ISO/IEC
9945:2002)。POSIX.1-2001替代了SUSv2、POSIX.1、POSIX.2和大量早期POSIX，该标准也称为SUS第3版
(即SUSv3)。通过SUSv3认证的UNIX实现可以称为<span
style="background-color: yellow">UNIX 03</span>。</p>
<p>　　SUSv3基础规范包含3700页，分为以下4部分：</p>
<p>　　● <strong>基础定义</strong> (XBD)
包含头文件内容的定义、术语、概念和规范，共提供了84个头文件规范。</p>
<p>　　● <strong>系统接口</strong> (XSH)
从各种有用的背景信息开始，主体包含各种函数的规范
(这些函数在特定UNIX实现上被实现为系统调用或库函数)。该部分共包含1123个系统接口。</p>
<p>　　● <strong>shell和工具</strong> (XCU)
详细说明了shell操作和各种UNIX命令，共详细说明了160个工具。</p>
<p>　　● <strong>基本原理</strong> (XRAT)
包括前3部分的相关信息文本和原由。</p>
<p>　　此外，SUSv3还包括X/Open CURSES Issue 4第2版规范
(详细说明了curses屏幕处理API的372个函数和3个头文件)。</p>
<p>　　SUSv3共详细说明了1742个接口。相比之下，POSIX.1-1990 (包括FIPS
151-2) 仅详细说明了199个接口，POSIX.2-1992仅详细说明了130个工具。</p>
<p>　　SUSv3获批后，经过了数次小幅的修复和改进，这导致了Technical
Corrigendum
Number1和2的出现，它们分别被纳入了SUSv3的2003年修订版和2004年修订版。</p>
<p>　　从历史角度，SUS和XPG符合对应的POSIX并构建为POSIX的功能性超集。除了详细说明额外的接口外，SUS还让很多在POSIX中可选的接口和行为成为了标准的一部分。</p>
<p>　　这种区别在POSIX 1003.1-2003中表现得很微妙。POSIX
1003.1-2003是早期POSIX和SUS的结合体，它既是IEEE标准，又是Open
Group技术标准。该标准定义了2种符合级别：</p>
<p>　　● <span
style="background-color: yellow">POSIX符合级别</span>定义了符合标准的实现必须提供的接口基准。它还允许这些实现提供其他可选的接口。</p>
<p>　　● <span style="background-color: yellow">X/Open系统接口 (XSI)
符合级别</span>要求符合标准的实现除了符合POSIX，还必须提供大量在POSIX中可选的接口和行为，这些接口和行为统称为<span
style="background-color: yellow">XSI扩展</span>。要获取The Open
Group的UNIX
03品牌标识，实现必须达到该符合级别。在之后的内容中，会用符合SUSv3来表示符合XSI。</p>
<p>　　XSI扩展包括对线程、<code>mmap()</code>和<code>munmap()</code>、dlopen
API、资源限制、伪终端、System V IPC、syslog
API、<code>poll()</code>和登录账号的支持。</p>
<p>　　有时，会用 "未说明" 或 "简要说明"
来描述SUSv3中的某个接口。前者表示标准中完全未定义的接口，在极少数情况下，它们在背景或原由说明中会提及。后者表示标准中重要细节未定义的接口，通常因为现有实现之间的差距而导致委员会成员之间没有达成共识。当接口为未说明或简要说明时，无法完全保证应用程序可以移植到其他UNIX实现上，尽管如此，少数情况下，这种接口在各个实现之间相当一致。</p>
<p>　　SUSv3会将部分特定的特性标为LEGACY，表示为兼容旧应用程序而保留的特性，但是其限制意味着在新应用程序中应该避免使用。在很多情况下，会存在一些等效API。</p>
<h4 id="susv4和posix.1-2008">1.3.5 SUSv4和POSIX.1-2008</h4>
<p>　　在2008年，奥斯汀小组完成了对合并后的POSIX.1和SUS的修订。与之前的版本一样，该版本由1个标准规范和1个XSI扩展组成。这里将该版本称为<span
style="background-color: yellow">SUSv4</span>。</p>
<p>　　SUSv4的修改幅度不如SUSv3的修改幅度。重要修改包括以下内容：</p>
<p>　　● SUSv4为一系列函数添加了新规范。</p>
<p>　　●
部分在SUSv3中可选的函数成为了SUSv4的一部分，包括<code>dlopen()</code>
API、实时信号API、POSIX信号量API和POSIX定时器API。</p>
<p>　　●
部分SUSv3中的函数在SUSv4中被标记为已过时，包括<code>asctime()</code>、<code>ctime()</code>、<code>ftw()</code>、<code>gettimeofday()</code>、<code>getitimer()</code>、<code>setitimer()</code>和<code>siginterrupt()</code>。</p>
<p>　　●
部分SUSv3中标记为已过时的函数规范在SUSv4中被移除，包括<code>gethostbyname()</code>、<code>gethostbyaddr()</code>和<code>vfork()</code>。</p>
<p>　　● SUSv3中已存在的大量规范细节在SUSv4中被修改。</p>
<h4 id="unix标准时间线">1.3.6 UNIX标准时间线</h4>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_01/relationships_between_various_unix_and_c_standards.svg" class="">
<p>　　如图所示，这里总结了之前内容介绍的各个标准间的关系并根据时间对它们进行了排序。实线表示2个标准直接相关。虚线箭头表示2个标准间接相关，即某个标准符合其他标准或其他标准的一部分纳入到该标准。</p>
<p>　　网络标准的情况有些复杂。该领域的工作始于20世纪80年代晚期，当时成立了POSIX
1003.12委员会来标准化套接字API、X/Open传输接口 (XTI)
API和大量相关API。XTI是基于System
V传输层接口的备选网络编程API。该标准的酝酿经过数年，在此期间，POSIX
1003.12更名为POSIX 1003.1g并于2000年获批。</p>
<p>　　在POSIX 1003.1g制定的同时，X/Open也在制定自己的X/Open网络规范
(XNS)。该规范的第1版XNS Issue 4成为了SUSv1的一部分。其后的XNS Issue
5成为了SUSv2的一部分，该版本与当时的POSIX.1g草案基本相同。再往后的XNS
Issue 5.2与XNS Issue
5和获批的POSIX.1g都不同，该版本将XTI标记为已过时并包含了20世纪90年代中期设计的IPv6。XNS
Issue 5.2构成了SUSv3中的网络规范的基础
(如今已被取代)。因此，POSIX.1g在获批不久后就被撤销。</p>
<h4 id="linux标准和linux标准基础">1.3.7 Linux、标准和Linux标准基础</h4>
<p>　　作为总体目标，Linux (包括内核、glibc和工具)
的开发旨在符合各种UNIX标准，尤其是POSIX和SUS。但是，在撰写本书时，The
Open
Group没有为任何Linux发行版授予UNIX品牌标识，主要是因为时间和费用。每个供应商的发行版都需要通过标准符合测试才能获得UNIX品牌标识，并且发行版的每个新版本都需要通过测试。尽管如此，正是Linux对各种标准的基本符合才使得其在UNIX市场如此成功。</p>
<p>　　对于大多数商业UNIX实现，同一家公司既开发操作系统，也发行操作系统。对于Linux，情况则不同，因为实现与发行是分开的，并且存在多个组织
(包括商业组织和非商业组织) 负责发行Linux。</p>
<p>　　Linus
Torvalds不参与或支持任何Linux发行版。但是，对于其他负责Linux开发的开发者，情况则更复杂。很多从事Linux内核和其他自由软件项目开发的开发者都受雇于Linux发行公司或IBM和HP等对Linux有浓厚兴趣的公司。虽然这些公司可以通过将开发者分配到某个项目来影响Linux的发展方向，但无法控制Linux。当然，其他很多为Linux内核和GNU做过贡献的人都是出于自愿。</p>
<p>　　在撰写本书时，Linus Torvalds受雇于Linux基金会
(前身为开源开发实验室)
——由商业组织和非商业组织组成的非营利性联盟，旨在促进Linux的发展。</p>
<p>　　因为Linux内核实现不控制发行版的内容，并且存在多个Linux发行商，所以并不存在
"标准" 商业版Linux。每个Linux发行商的内核都是基于主线 (即Torvalds)
Linux的某个时间点的快照，并使用了一些补丁。这些补丁提供的特性被认为具有商业吸引力，以在商业竞争中获得优势。有时，这些补丁之后会加入到主线内核。事实上，主线内核的部分新特性本来是发行公司开发的，最初出现在其发行版中，然后才合并到主线中。例如，Reiserfs日志文件系统第3版最初是部分Linux发行版的一部分，然后才合并到了主线2.4内核。</p>
<p>　　以上几点得到的结果是各个Linux发行公司提供的系统存在差异
(大部分差异都是细微的)。从更微观的角度，这让人想起了UNIX早期出现的实现分裂。<span
style="background-color: yellow">Linux标准基础</span> (LSB)
便应运而生，旨在保证各个Linux发行版之间的可移植性。为此，LSB为Linux系统制定一系列标准并对它们进行了推广，以确保二进制应用程序可以运行在任何符合LSB的系统上。</p>
<p>　　LSB推广的二进制可移植性有别于POSIX推广的源码可移植性。前者表示在符合LSB的系统上编译的C程序可以运行在其他任何符合LSB的系统上，这在不同的硬件平台上通常不可行。后者表示C程序代码可以在任何符合POSIX的系统上编译并运行。二进制可移植性是独立软件供应商的Linux应用程序的商业可行性的基本要求。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第3章 系统编程概念</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_03/</url>
    <content><![CDATA[<p>　　<strong>系统调用</strong>是内核中的受控入口点，允许进程请求内核代表自己执行某些操作
(命令<code>strace</code>可用于追踪程序中的系统调用)。</p>
<p>　　●
系统调用会将处理器状态从用户模式切换到内核模式，以便CPU访问受保护的内核内存。</p>
<p>　　● 系统调用集是固定的，每个系统调用都有唯一的数字标识符
(这些标识符通常对程序不可见，因为程序通过名称来标识系统调用)。</p>
<p>　　● 系统调用可能有参数，指定要从用户空间 (进程的虚拟地址空间)
传输到内核空间的信息或相反的情况。</p>
<p>　　在Linux中，系统调用服务例程的名称通常是<code>sys_xyz()</code>，其中<code>xyz()</code>是对应的系统调用名。</p>
<p>　　<strong>库函数</strong>是构成标准C库的众多函数之一。很多库函数都不会使用系统调用。相反，有些库函数就是系统调用的包装函数，这些库函数提供的接口通常比对应的系统调用提供的接口更易于使用。</p>
<p>　　从C程序角度，调用C库中的包装函数等同于调用对应的系统调用服务例程。在之后的内容，会用诸如
"调用系统调用<code>xyz()</code>" 的措辞表示
"调用系统调用<code>xyz()</code>的包装函数"。</p>
<p>　　各种UNIX实现上有很多标准C库的实现。Linux上最广泛使用的实现是GNU
C库 (即glibc)。glibc的主要开发者和维护者最初是Roland
McGrath。如今，这项工作由Ulrich
Drepper接班。Linux上还有其他可用的C库，包括用于嵌入式设备应用程序的内存要求较小的库
(例如，uClibc和diet libc)。</p>
<p>　　在C中，术语<strong>左值</strong>指引用存储区域的表达式。最常见的示例就是变量标识符。部分运算符也会生成左值
(若<code>p</code>是指向存储区域的指针，则<code>*p</code>就是左值)。</p>
<p>　　对于POSIX.1-1990说明的很多函数，POSIX.1-1990都要求头文件<code>sys/types.h</code>的引用先于其他与这些函数有关联的头文件。但是，这个要求是多余的，因为当时的大部分UNIX实现都不要求应用程序为这些函数引用该头文件。因此，SUSv1移除了该要求。尽管如此，在开发可移植程序时，尽量将该头文件作为第1批引用的头文件。</p>
<span id="more"></span>
<h3 id="系统调用">3.1 系统调用</h3>
<p>　　从编程角度，调用系统调用与调用C函数极其相似。但是，系统调用的执行包含很多步骤。以x86-32为例，其流程如下：</p>
<p>　　1) 应用程序调用C库中的系统调用包装函数。</p>
<p>　　2)
包装函数必须保证系统调用的所有参数都可用于系统调用陷阱处理例程。这些参数会通过栈传递给包装函数，但内核希望这些参数位于特定的寄存器中。包装函数会将这些参数复制到内核指定的寄存器。</p>
<p>　　3)
因为所有系统调用都以相同的方式进入内核，所以内核需要识别系统调用的方法。为了实现这一点，包装函数将系统调用号复制到CPU寄存器<code>%eax</code>。</p>
<p>　　4)
包装函数执行陷阱指令<code>int 0x80</code>，该指令会将处理器从用户模式切换到内核模式并执行系统陷阱向量的位置<code>0x80</code>指向的代码。</p>
<p>　　5) 内核调用例程<code>system_call()</code>
(位于汇编文件<code>arch/i386/entry.S</code>)
来处理陷阱，该处理函数的执行分为5个步骤。第1步，<span
style="background-color: yellow">将寄存器值保存到内核栈</span>。第2步，<span
style="background-color: yellow">检查系统调用号的有效性</span>。第3步，<span
style="background-color: yellow">调用合适的系统调用服务例程</span>，通过系统调用号索引包含所有系统调用服务例程的表
(对应内核变量<code>sys_call_table</code>)
来查找例程。若系统调用服务例程有参数，则会先验证其有效性。然后，服务例程执行请求的任务
(这些任务可能会涉及根据参数指定的地址修改值或在用户内存和内核内存中传输数据)，最后，服务例程返回结果状态给例程<code>system_call()</code>。第4步，<span
style="background-color: yellow">从内核栈中恢复寄存器值并将系统调用返回值压入栈</span>。第5步，<span
style="background-color: yellow">返回到包装函数，同时处理器切换到用户模式</span>。</p>
<p>　　6)
若系统调用服务例程的返回值表示出错，则包装函数会根据该返回值设置全局变量<code>errno</code>。然后，包装函数返回到调用函数，提供1个整数返回值来指示系统调用是否成功。</p>
<p>　　在Linux中，系统调用服务例程遵循非负返回值表示成功的约定。当出错时，例程会返回负值，该值是<code>errno</code>的某个值的相反数。当返回值为负时，C库中的包装函数会取它的相反数，将结果复制到<code>errno</code>，然后返回-1作为结果，表示出错。</p>
<p>　　非负返回值表示成功的约定基于假设：系统调用服务例程成功时不会返回负值。对于少数系统调用服务例程，此假设不成立。一般情况下，这不是问题，因为<code>errno</code>的负值范围不与有效的负返回值重叠。但是，对于系统调用<code>fcntl()</code>的操作<code>F_GETOWN</code>，这个约定会导致问题。</p>
<p>　　较新的x86-32架构实现了指令<code>sysenter</code>，该指令提供了比传统的陷阱指令<code>int 0x80</code>更快速地切换到内核模式的方法。内核2.6和glibc
2.3.2及以上版本支持该指令。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_03/steps_in_the_execution_of_a_system_call.svg" class="">
<p>　　上图是系统调用<code>execve()</code>的执行步骤。对于Linux/x86-32，<code>execve()</code>的系统调用号是11
(<code>__NR_execve</code>)。因此，在向量<code>sys_call_table</code>中，条目11包含系统调用服务例程<code>sys_execve()</code>的地址。</p>
<p>　　以系统调用<code>getppid()</code>为例，该系统调用会返回调用进程的父进程ID，对于运行在x86-32上的Linux
2.6.25，1千万次调用大约耗时2.2s。在同样的系统上，1千万次调用简单地返回1个整数的C函数大约耗时0.11s。此外，大多数系统调用的耗时都远高于<code>getppid()</code>的耗时。</p>
<h3 id="glibc">3.2 glibc</h3>
<p>　　当需要确定系统上的glibc的版本时，可以在shell中以运行程序的方式运行glibc共享库文件，这会显示大量文本
(包括版本号) ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/lib/libc.so.6</span></span><br><span class="line">GNU C Library stable release version 2.10.1, by Roland McGrath et al.</span><br><span class="line">Copyright (C) 2009 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 4.4.0 20090506 (Red Hat 4.4.0-4).</span><br><span class="line">Compiled on a Linux &gt;&gt;2.6.18-128.4.1.el5&lt;&lt; system on 2009-08-19.</span><br><span class="line">Available extensions:</span><br><span class="line">    The C stubs add-on version 2.1.2.</span><br><span class="line">    crypt add-on version 2.1 by Michael Glad and others</span><br><span class="line">    GNU Libidn by Simon Josefsson</span><br><span class="line">    Native POSIX Threads Library by Ulrich Drepper et al</span><br><span class="line">    BIND-8.2.3-T5B</span><br><span class="line">    RT using linux kernel aio</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/libc/bugs.html&gt;.</span><br></pre></td></tr></table></figure>
<p>　　对于某些Linux发行版，glibc的路径并非<code>/lib/libc.so.6</code>，可以对动态链接glibc的可执行文件运行程序<code>ldd</code>
(列出动态依赖) 来确定库的位置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd myprog | grep libc</span></span><br><span class="line">    libc.so.6 =&gt; /lib/tls/libc.so.6 (0x4004b000)</span><br></pre></td></tr></table></figure>
<p>　　应用程序可以通过2种方法来确定系统中现有的glibc的版本：判断常量和调用库函数。从2.0版本开始，glibc定义了2个常量
(<code>__GLIBC__</code>和<code>__GLIBC_MINOR__</code>)，可以在编译时进行判断，即<code>#ifdef</code>语句
(例如，对于glibc版本是2.12的系统，这2个常量的值分别是2和12)。但是，这种方法不适用于程序运行时的系统和编译时的系统不同的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gnu/libc-version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gnu_get_libc_version</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回字符\0结尾的静态分配的字符串，其中包含glibc的版本号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>gnu_get_libc_version()</code>可以在运行时确定glibc的版本，该函数会返回形如<code>2.12</code>的字符串。</p>
<p>　　函数<code>confstr()</code>也可用于确定glibc的版本，通过该函数检索配置变量<code>_CS_GNU_LIBC_VERSION</code>
(仅限于glibc) 的值，会返回形如<code>2.12</code>的字符串。</p>
<h3 id="处理系统调用和库函数中的错误">3.3
处理系统调用和库函数中的错误</h3>
<p>　　几乎所有系统调用和库函数都会返回某种类型的状态值，表示调用是否成功。应<span
style="background-color: yellow">始终</span>检查状态值以确定调用是否成功。若出错，则采取合适的行动
(至少应该显示错误信息，警告发生了意外情况)。</p>
<p>　　少部分系统调用不会出错。例如，<code>getpid()</code>总是会返回进程的进程ID，<code>_exit()</code>总是会终止进程。对于这些系统调用，检查返回值并不是必需的。</p>
<h4 id="处理系统调用错误">3.3.1 处理系统调用错误</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cnt = read(fd, buf, numbytes);</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read was interrupted by a signal\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Some other error occurred */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　每个系统调用的说明都给出了返回值，并且指出了那些值表示出错。返回值-1通常表示出错。当系统调用出错时，会将全局整数变量<code>errno</code>设置为正值，以标识特定的错误。头文件<code>errno.h</code>提供了<code>errno</code>的声明和相关错误号的常量，这些常量名都以<code>E</code>开头。错误相关说明提供了每个系统调用可能的<code>errno</code>值。</p>
<p>　　成功的系统调用和库函数不会将<code>errno</code>置0。但是，SUSv3允许成功的函数调用将<code>errno</code>设置为非0值
(尽管只有少数函数如此)。因此，在检查错误时，应先检查函数返回值是否表示出错，只有返回值表示出错时，才继续检查<code>errno</code>以确定导致错误的原因。</p>
<p>　　<code>getpriority()</code>等少数系统调用在成功时也会返回-1。对于这些函数，在调用之前应先把<code>errno</code>置0，在调用后再进行判断。若调用返回-1并且<code>errno</code>非0，则表示出错。少数相似的库函数也是同理。</p>
<p>　　当调用出错后，通常采取的行动是根据<code>errno</code>值打印错误信息。库函数<code>perror()</code>和<code>strerror()</code>正是用于此目的。这2个函数返回的错误信息的语言是系统设置的语言。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>perror()</code>会打印参数<code>msg</code>指向的字符串加上当前<code>errno</code>值对应的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>; <span class="comment">/* 返回errnum对应的字符串 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>strerror()</code>会返回参数<code>errnum</code>中的错误号对应的错误信息。该函数返回的字符串是静态分配的，所以它能被后续的<code>strerror()</code>调用覆盖。</p>
<p>　　若<code>errnum</code>指定的错误号不存在，则函数<code>strerror()</code>返回<code>Unknown error nnn</code>形式的字符串
(某些实现在这种情况下会返回<code>NULL</code>)</p>
<h4 id="处理库函数错误">3.3.2 处理库函数错误</h4>
<p>　　各种库函数会返回不同的数据类型和不同的值来表示错误。这里将库函数分为3类：</p>
<p>　　●
第1类库函数返回错误信息的方式与系统调用相同，即返回-1并设置<code>errno</code>。函数<code>remove()</code>便是其中之一，该函数会删除文件
(通过系统调用<code>unlink()</code>) 或目录
(通过系统调用<code>rmdir()</code>)。这类函数的错误处理与系统调用的错误处理相同。</p>
<p>　　●
第2类函数的错误返回值不是-1，但仍然会设置<code>errno</code>。函数<code>fopen()</code>便是其中之一，该函数出错时会返回空指针，并且会根据出错的底层系统调用设置<code>errno</code>。函数<code>perror()</code>和<code>strerror()</code>可用于处理此类函数出错。</p>
<p>　　●
第3类函数不使用<code>errno</code>。确定此类函数是否出错及其原因需要基于函数说明。</p>
<h3 id="关于本书中示例程序的说明">3.4 关于本书中示例程序的说明</h3>
<p>　　本书中的大量示例程序依赖命令行选项和参数来决定其行为。</p>
<p>　　传统的UNIX命令行选项由1个连字符<code>-</code>加上1个标识选项的字母和1个可选的参数组成。GNU工具提供的扩展选项语法由2个连字符<code>-</code>加上1个标识选项的字母和1个可选的参数组成。可以通过标准<code>getopt()</code>库函数来解析这些选项。</p>
<p>　　本书中的每个示例程序都提供了简单的帮助工具。如果使用选项<code>--help</code>调用程序，程序会给出命令行选项和参数的语法的相关信息。</p>
<h4 id="常用函数头文件">3.4.1 常用函数头文件</h4>
<p>　　大部分示例程序都引用了包含常用定义的头文件，并且这些程序也会使用1组常用函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tlpi_hdr.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TLPI_HDR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TLPI_HDR_H           <span class="comment">/* 防止意外的多重引用 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>       <span class="comment">/* 很多程序使用的类型定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>           <span class="comment">/* 标准I/O函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>          <span class="comment">/* 常用库函数的原型以及常量EXIT_SUCCESS和EXIT_FAILURE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>          <span class="comment">/* 很多系统调用的原型 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>           <span class="comment">/* errno声明和errno常量 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>          <span class="comment">/* 常用字符串处理函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;get_num.h&quot;</span>         <span class="comment">/* 用于处理数字参数的自定义函数getInt()和getLong()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;error_functions.h&quot;</span> <span class="comment">/* 用于处理错误的自定义函数的声明 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FALSE,</span><br><span class="line">    TRUE</span><br><span class="line">&#125; Boolean;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(m, n) ((m) &lt; (n) ? (m) : (n))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(m, n) ((m) &gt; (n) ? (m) : (n))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　几乎本书中的所有示例程序都会使用头文件<code>tlpi_hdr.h</code>。该头文件引用了各种头文件，并且定义了数据类型<code>Boolean</code>和用于计算2个数字的最大值和最小值的宏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* error_functions.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ERROR_FUNCTIONS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_FUNCTIONS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="comment">/* 该宏可以保证使用以下函数来终止主函数或其他一些有返回值的函数时，</span></span><br><span class="line"><span class="comment">    gcc -Wall不会提示&quot;control reaches end of non-void function&quot; */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NORETURN __attribute__((__noreturn__))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NORETURN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errMsg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExitEN</span><span class="params">(<span class="type">int</span> errnum, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usageErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmdLineErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span> NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　为了简化示例程序中的错误处理，会使用这里展示的错误诊断函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errMsg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExitEN</span><span class="params">(<span class="type">int</span> errnum, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<p>　　这里会使用函数<code>errMsg()</code>、<code>errExit()</code>、<code>err_exit()</code>和<code>errExitEN()</code>诊断系统调用和库函数中的错误。</p>
<p>　　函数<code>errMsg()</code>会在标准错误中打印1条信息
(末尾自动加上换行符)，其参数列表与函数<code>prtinf()</code>的相同。该函数打印的的字符串是<code>errno</code>当前值对应的错误信息
(其中包含错误名，例如，EPERM)
加上函数<code>strerror()</code>返回的错误描述加上参数指定格式的输出。</p>
<p>　　函数<code>errExit()</code>的用法与<code>errMsg()</code>类似，但会终止程序。若环境变量<code>EF_DUMPCORE</code>的值为非空字符串，则该函数会通过<code>abort()</code>终止程序，同时生成核心转储文件
(与调试程序一起使用)；否则，该函数会通过<code>exit()</code>终止程序。</p>
<p>　　函数<code>err_exit()</code>在功能上与<code>errExit()</code>类似，但在2个方面有所不同。首先，函数<code>err_exit()</code>在打印错误信息前不会刷新标准输出。其次，函数<code>err_exit()</code>通过<code>_exit()</code>终止进程，这导致进程终止时不会刷新stdio缓存或调用退出处理函数。</p>
<p>　　函数<code>errExitEN()</code>会打印参数<code>errnum</code>指定的错误号对应的信息
(所以函数以后缀<code>EN</code>结尾)。除此之外，其他方面与<code>errExit()</code>相同。</p>
<p>　　不同于传统的UNIX系统调用，POSIX线程函数会返回错误号
(成功时返回0)。因此，通常会在使用POSIX线程函数的程序中使用函数<code>errExitEN()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s;</span><br><span class="line">s = pthread_create(&amp;thread, <span class="literal">NULL</span>, func, &amp;arg);</span><br><span class="line"><span class="keyword">if</span> (s)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何确定POSIX线程函数是否出错。不直接使用<code>errno</code>的原因是POSIX线程函数中的<code>errno</code>被重定义为宏，该宏会扩展为返回可修改左值的函数调用，所以每次使用<code>errno</code>都会调用1次函数。</p>
<p>　　对于其他类型错误的诊断，可以使用函数<code>fatal()</code>、<code>usageErr()</code>和<code>cmdLineErr()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usageErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmdLineErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>fatal()</code>用于通用错误的诊断，包括那些不设置<code>errno</code>的库函数，其参数列表与函数<code>prtinf()</code>的相同。该函数会在标准错误中输出格式化的字符串
(自动在末尾加上换行符)，然后像函数<code>errExit()</code>一样终止程序。</p>
<p>　　函数<code>usageErr()</code>用于命令行参数错误的诊断，其参数列表与函数<code>prtinf()</code>的相同。该函数会在标准错误中输出字符串<code>Usage:</code>加上格式化的输出，然后调用<code>exit()</code>来终止程序。</p>
<p>　　函数<code>cmdLineErr()</code>与<code>usageErr()</code>类似，但主要用于程序的命令行参数错误的诊断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* error_functions.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;error_functions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ename.c.inc&quot;</span> <span class="comment">/* ename和MAX_ENAME的定义 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">__attribute__((__noreturn__))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">terminate</span><span class="params">(Boolean useExit3)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="comment">/* 若环境变量EF_DUMPCORE定义为非空字符串，则生成核心转储文件；</span></span><br><span class="line"><span class="comment">    否则，根据useExit3的值调用exit(3)或_exit(2) */</span></span><br><span class="line">    s = getenv(<span class="string">&quot;EF_DUMPCORE&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">NULL</span> &amp;&amp; *s != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (useExit3)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">outputError</span><span class="params">(Boolean useErr, <span class="type">int</span> err, Boolean flushStdout,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 500</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE], userMsg[BUF_SIZE], errText[BUF_SIZE];</span><br><span class="line">    vsnprintf(userMsg, BUF_SIZE, format, ap);</span><br><span class="line">    <span class="keyword">if</span> (useErr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(errText, BUF_SIZE, <span class="string">&quot; [%s %s]&quot;</span>,</span><br><span class="line">                 (err &gt; <span class="number">0</span> &amp;&amp; err &lt;= MAX_ENAME) ? ename[err] : <span class="string">&quot;?UNKNOWN?&quot;</span>, strerror(err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(errText, BUF_SIZE, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;ERROR%s %s\n&quot;</span>, errText, userMsg);</span><br><span class="line">    <span class="keyword">if</span> (flushStdout)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>); <span class="comment">/* 刷新所有待处理的标准输出 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>); <span class="comment">/* 防止标准错误是行缓存 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errMsg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    <span class="type">int</span> savedErrno;</span><br><span class="line">    savedErrno = errno; <span class="comment">/* 防止errno被修改 */</span></span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errno, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errno, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errno, FALSE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExitEN</span><span class="params">(<span class="type">int</span> errnum, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(TRUE, errnum, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fatal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    outputError(FALSE, <span class="number">0</span>, TRUE, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    <span class="built_in">terminate</span>(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usageErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">/* 刷新所有待处理的标准输出 */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &quot;</span>);</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>); <span class="comment">/* 防止标准错误是行缓存 */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cmdLineErr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>); <span class="comment">/* 刷新所有待处理的标准输出 */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Command-line usage error: &quot;</span>);</span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>); <span class="comment">/* 防止标准错误是行缓存 */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是上述错误诊断函数的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ename.c.inc */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *ename[] = &#123;</span><br><span class="line">    <span class="comment">/* 0 */</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* 1 */</span> <span class="string">&quot;EPERM&quot;</span>, <span class="string">&quot;ENOENT&quot;</span>, <span class="string">&quot;ESRCH&quot;</span>, <span class="string">&quot;EINTR&quot;</span>, <span class="string">&quot;EIO&quot;</span>, <span class="string">&quot;ENXIO&quot;</span>, <span class="string">&quot;E2BIG&quot;</span>,</span><br><span class="line">    <span class="comment">/* 8 */</span> <span class="string">&quot;ENOEXEC&quot;</span>, <span class="string">&quot;EBADF&quot;</span>, <span class="string">&quot;ECHILD&quot;</span>, <span class="string">&quot;EAGAIN/EWOULDBLOCK&quot;</span>, <span class="string">&quot;ENOMEM&quot;</span>,</span><br><span class="line">    <span class="comment">/* 13 */</span> <span class="string">&quot;EACCES&quot;</span>, <span class="string">&quot;EFAULT&quot;</span>, <span class="string">&quot;ENOTBLK&quot;</span>, <span class="string">&quot;EBUSY&quot;</span>, <span class="string">&quot;EEXIST&quot;</span>, <span class="string">&quot;EXDEV&quot;</span>,</span><br><span class="line">    <span class="comment">/* 19 */</span> <span class="string">&quot;ENODEV&quot;</span>, <span class="string">&quot;ENOTDIR&quot;</span>, <span class="string">&quot;EISDIR&quot;</span>, <span class="string">&quot;EINVAL&quot;</span>, <span class="string">&quot;ENFILE&quot;</span>, <span class="string">&quot;EMFILE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 25 */</span> <span class="string">&quot;ENOTTY&quot;</span>, <span class="string">&quot;ETXTBSY&quot;</span>, <span class="string">&quot;EFBIG&quot;</span>, <span class="string">&quot;ENOSPC&quot;</span>, <span class="string">&quot;ESPIPE&quot;</span>, <span class="string">&quot;EROFS&quot;</span>,</span><br><span class="line">    <span class="comment">/* 31 */</span> <span class="string">&quot;EMLINK&quot;</span>, <span class="string">&quot;EPIPE&quot;</span>, <span class="string">&quot;EDOM&quot;</span>, <span class="string">&quot;ERANGE&quot;</span>, <span class="string">&quot;EDEADLK/EDEADLOCK&quot;</span>,</span><br><span class="line">    <span class="comment">/* 36 */</span> <span class="string">&quot;ENAMETOOLONG&quot;</span>, <span class="string">&quot;ENOLCK&quot;</span>, <span class="string">&quot;ENOSYS&quot;</span>, <span class="string">&quot;ENOTEMPTY&quot;</span>, <span class="string">&quot;ELOOP&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* 42 */</span> <span class="string">&quot;ENOMSG&quot;</span>, <span class="string">&quot;EIDRM&quot;</span>, <span class="string">&quot;ECHRNG&quot;</span>, <span class="string">&quot;EL2NSYNC&quot;</span>, <span class="string">&quot;EL3HLT&quot;</span>, <span class="string">&quot;EL3RST&quot;</span>,</span><br><span class="line">    <span class="comment">/* 48 */</span> <span class="string">&quot;ELNRNG&quot;</span>, <span class="string">&quot;EUNATCH&quot;</span>, <span class="string">&quot;ENOCSI&quot;</span>, <span class="string">&quot;EL2HLT&quot;</span>, <span class="string">&quot;EBADE&quot;</span>, <span class="string">&quot;EBADR&quot;</span>,</span><br><span class="line">    <span class="comment">/* 54 */</span> <span class="string">&quot;EXFULL&quot;</span>, <span class="string">&quot;ENOANO&quot;</span>, <span class="string">&quot;EBADRQC&quot;</span>, <span class="string">&quot;EBADSLT&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;EBFONT&quot;</span>, <span class="string">&quot;ENOSTR&quot;</span>,</span><br><span class="line">    <span class="comment">/* 61 */</span> <span class="string">&quot;ENODATA&quot;</span>, <span class="string">&quot;ETIME&quot;</span>, <span class="string">&quot;ENOSR&quot;</span>, <span class="string">&quot;ENONET&quot;</span>, <span class="string">&quot;ENOPKG&quot;</span>, <span class="string">&quot;EREMOTE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 67 */</span> <span class="string">&quot;ENOLINK&quot;</span>, <span class="string">&quot;EADV&quot;</span>, <span class="string">&quot;ESRMNT&quot;</span>, <span class="string">&quot;ECOMM&quot;</span>, <span class="string">&quot;EPROTO&quot;</span>, <span class="string">&quot;EMULTIHOP&quot;</span>,</span><br><span class="line">    <span class="comment">/* 73 */</span> <span class="string">&quot;EDOTDOT&quot;</span>, <span class="string">&quot;EBADMSG&quot;</span>, <span class="string">&quot;EOVERFLOW&quot;</span>, <span class="string">&quot;ENOTUNIQ&quot;</span>, <span class="string">&quot;EBADFD&quot;</span>,</span><br><span class="line">    <span class="comment">/* 78 */</span> <span class="string">&quot;EREMCHG&quot;</span>, <span class="string">&quot;ELIBACC&quot;</span>, <span class="string">&quot;ELIBBAD&quot;</span>, <span class="string">&quot;ELIBSCN&quot;</span>, <span class="string">&quot;ELIBMAX&quot;</span>,</span><br><span class="line">    <span class="comment">/* 83 */</span> <span class="string">&quot;ELIBEXEC&quot;</span>, <span class="string">&quot;EILSEQ&quot;</span>, <span class="string">&quot;ERESTART&quot;</span>, <span class="string">&quot;ESTRPIPE&quot;</span>, <span class="string">&quot;EUSERS&quot;</span>,</span><br><span class="line">    <span class="comment">/* 88 */</span> <span class="string">&quot;ENOTSOCK&quot;</span>, <span class="string">&quot;EDESTADDRREQ&quot;</span>, <span class="string">&quot;EMSGSIZE&quot;</span>, <span class="string">&quot;EPROTOTYPE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 92 */</span> <span class="string">&quot;ENOPROTOOPT&quot;</span>, <span class="string">&quot;EPROTONOSUPPORT&quot;</span>, <span class="string">&quot;ESOCKTNOSUPPORT&quot;</span>,</span><br><span class="line">    <span class="comment">/* 95 */</span> <span class="string">&quot;EOPNOTSUPP/ENOTSUP&quot;</span>, <span class="string">&quot;EPFNOSUPPORT&quot;</span>, <span class="string">&quot;EAFNOSUPPORT&quot;</span>,</span><br><span class="line">    <span class="comment">/* 98 */</span> <span class="string">&quot;EADDRINUSE&quot;</span>, <span class="string">&quot;EADDRNOTAVAIL&quot;</span>, <span class="string">&quot;ENETDOWN&quot;</span>, <span class="string">&quot;ENETUNREACH&quot;</span>,</span><br><span class="line">    <span class="comment">/* 102 */</span> <span class="string">&quot;ENETRESET&quot;</span>, <span class="string">&quot;ECONNABORTED&quot;</span>, <span class="string">&quot;ECONNRESET&quot;</span>, <span class="string">&quot;ENOBUFS&quot;</span>, <span class="string">&quot;EISCONN&quot;</span>,</span><br><span class="line">    <span class="comment">/* 107 */</span> <span class="string">&quot;ENOTCONN&quot;</span>, <span class="string">&quot;ESHUTDOWN&quot;</span>, <span class="string">&quot;ETOOMANYREFS&quot;</span>, <span class="string">&quot;ETIMEDOUT&quot;</span>,</span><br><span class="line">    <span class="comment">/* 111 */</span> <span class="string">&quot;ECONNREFUSED&quot;</span>, <span class="string">&quot;EHOSTDOWN&quot;</span>, <span class="string">&quot;EHOSTUNREACH&quot;</span>, <span class="string">&quot;EALREADY&quot;</span>,</span><br><span class="line">    <span class="comment">/* 115 */</span> <span class="string">&quot;EINPROGRESS&quot;</span>, <span class="string">&quot;ESTALE&quot;</span>, <span class="string">&quot;EUCLEAN&quot;</span>, <span class="string">&quot;ENOTNAM&quot;</span>, <span class="string">&quot;ENAVAIL&quot;</span>,</span><br><span class="line">    <span class="comment">/* 120 */</span> <span class="string">&quot;EISNAM&quot;</span>, <span class="string">&quot;EREMOTEIO&quot;</span>, <span class="string">&quot;EDQUOT&quot;</span>, <span class="string">&quot;ENOMEDIUM&quot;</span>, <span class="string">&quot;EMEDIUMTYPE&quot;</span>,</span><br><span class="line">    <span class="comment">/* 125 */</span> <span class="string">&quot;ECANCELED&quot;</span>, <span class="string">&quot;ENOKEY&quot;</span>, <span class="string">&quot;EKEYEXPIRED&quot;</span>, <span class="string">&quot;EKEYREVOKED&quot;</span>,</span><br><span class="line">    <span class="comment">/* 129 */</span> <span class="string">&quot;EKEYREJECTED&quot;</span>, <span class="string">&quot;EOWNERDEAD&quot;</span>, <span class="string">&quot;ENOTRECOVERABLE&quot;</span>, <span class="string">&quot;ERFKILL&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ENAME 132</span></span><br></pre></td></tr></table></figure>
<p>　　这是<code>error_functions.c</code>引用的文件<code>ename.c.inc</code>，其中定义了字符串数组<code>ename</code>，该数组中的字符串就是对应的<code>errno</code>值的名称。该文件中的内容仅限于运行在x86-32的Linux
2.6 ，因为不同架构的<code>errno</code>值不同。</p>
<p>　　函数<code>stderror()</code>返回的字符串没有标识其错误消息对于的符号常量，而参考手册使用符号名来描述错误。通过数组<code>ename</code>，错误处理函数就可以获取<code>errno</code>对应的符号名。</p>
<p>　　数组<code>ename</code>中有部分空字符串，因为这些字符串对应的错误号未使用。此外，数组<code>ename</code>中有部分字符串是斜杠<code>/</code>分隔的2个错误名，因为这2个错误名对应的值相同。</p>
<p>　　<code>EAGAIN</code>和<code>EWOULDBLOCK</code>对应同一值，SUSv3明确允许这样做，大部分UNIX系统也是如此。这2个错误通常由系统调用返回，在这种情况下，系统调用通常被阻塞
(即在完成前必须先等待)，但调用函数要求系统调用返回错误，而非阻塞。<code>EAGAIN</code>源于System
V，它是执行I/O、信号量操作、消息队列操作和文件上锁
(<code>fcntl()</code>)
的系统调用返回的错误。<code>EWOULDBLOCK</code>源于BSD，它是文件上锁
(<code>flock()</code>) 和套接字相关的系统调用返回的错误。</p>
<p>　　在SUSv3中，<code>EWOULDBLOCK</code>仅在套接字相关接口中提及。对于这些接口，SUSv3允许非阻塞的系统调用返回<code>EAGAIN</code>和<code>EWOULDBLOCK</code>。对于其他所有非阻塞的系统调用，SUSv3仅指定了<code>EAGAIN</code>。</p>
<h4 id="用于解析数值命令行参数的函数">3.4.2
用于解析数值命令行参数的函数</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* get_num.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GET_NUM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_NUM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_NONNEG 01 <span class="comment">/* 值必须不小于0 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_GT_0 02   <span class="comment">/* 值必须大于0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 整数默认十进制 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_ANY_BASE 0100 <span class="comment">/* 可用于任何情况 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_BASE_8 0200   <span class="comment">/* 值以八进制表示 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GN_BASE_16 0400  <span class="comment">/* 值以十六进制表示 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getInt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 将字符串转换为int类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">getLong</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 将字符串转换为long类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　头文件<code>get_num.h</code>定义了用于解析数值命令行参数的函数<code>getInt()</code>和<code>getLong()</code>。相比函数<code>atoi()</code>、<code>atol()</code>和<code>strtol()</code>，这2个函数提供了一些基本的数值参数的有效性检查。</p>
<p>　　若参数<code>arg</code>不是有效的整数字符串，则这2个函数会打印错误信息并终止程序。</p>
<p>　　若参数<code>name</code>非空，则它应该包含参数<code>arg</code>的标识字符串，该字符串会作为这2个函数打印的错误信息的一部分。</p>
<p>　　参数<code>flags</code>用于控制这2个函数的行为。在默认情况下，这2个函数会假定字符串为有符号的十进制整数。通过对任意个<code>GN_</code>开头的常量进行与操作并赋值给参数<code>flags</code>，就能选择转换模式，并且限制范围和正负。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* get_num.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;get_num.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gnFail</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fname, <span class="type">const</span> <span class="type">char</span> *msg, <span class="type">const</span> <span class="type">char</span> *arg, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s error&quot;</span>, fname);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; (in %s)&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;: %s\n&quot;</span>, msg);</span><br><span class="line">    <span class="keyword">if</span> (arg != <span class="literal">NULL</span> &amp;&amp; *arg != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot; offending text: %s\n&quot;</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">getNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fname, <span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> res;</span><br><span class="line">    <span class="type">char</span> *endptr;</span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="literal">NULL</span> || *arg == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;null or empty string&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    base = (flags &amp; GN_ANY_BASE) ? <span class="number">0</span> : (flags &amp; GN_BASE_8) ? <span class="number">8</span></span><br><span class="line">                                   : (flags &amp; GN_BASE_16)  ? <span class="number">16</span></span><br><span class="line">                                                           : <span class="number">10</span>;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    res = strtol(arg, &amp;endptr, base);</span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;strtol() failed&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*endptr != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;nonnumeric characters&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; GN_NONNEG) &amp;&amp; res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;negative value not allowed&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; GN_GT_0) &amp;&amp; res &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(fname, <span class="string">&quot;value must be &gt; 0&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getInt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> res;</span><br><span class="line">    res = getNum(<span class="string">&quot;getInt&quot;</span>, arg, flags, name);</span><br><span class="line">    <span class="keyword">if</span> (res &gt; INT_MAX || res &lt; INT_MIN)</span><br><span class="line">    &#123;</span><br><span class="line">        gnFail(<span class="string">&quot;getInt&quot;</span>, <span class="string">&quot;integer out of range&quot;</span>, arg, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">getLong</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getNum(<span class="string">&quot;getLong&quot;</span>, arg, flags, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是函数<code>getInt()</code>和<code>getLong()</code>的实现。</p>
<h3 id="可移植性问题">3.5 可移植性问题</h3>
<p>　　各种标准控制着系统调用和库函数API的行为。部分标准由The Open
Group等标准机构定义，其他标准由历史上2个重要的UNIX实现定义：BSD和System
V Release 4 (和相关的SVID)。</p>
<p>　　在开发可移植应用程序时，可能需要在头文件中仅公开特定标准的定义
(例如，常量和函数原型)。为此，在编译时需要定义<strong>特性测试宏</strong>。</p>
<p>　　第1种定义特性测试宏的方法是在引用头文件前定义宏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE 1</span></span><br></pre></td></tr></table></figure>
<p>　　第2种定义特性测试宏的方法是对于C编译器使用命令行参数<code>-D</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -D_BSD_SOURCE prog.c</span></span><br></pre></td></tr></table></figure>
<h4 id="特性测试宏">3.5.1 特性测试宏</h4>
<p>　　相关标准详细说明了特性测试宏<code>_POSIX_SOURCE</code>、<code>_POSIX_C_SOURCE</code>和<code>_XOPEN_SOURCE</code>，所以这些宏的使用可以移植到所有支持这些标准的系统。</p>
<p>　　 当定义了宏<code>_POSIX_SOURCE</code>后，会公开POSIX.1-1990和ISO
C (1990) 的定义，该宏现已被<code>_POSIX_C_SOURCE</code>取代。</p>
<p>　　当定义了宏<code>_POSIX_C_SOURCE</code>后，会公开以下定义：</p>
<p>　　● 若值为1，则会公开POSIX.1-1990和ISO C (1990) 的定义。</p>
<p>　　● 若值不小于199309，则还会公开POSIX.1b (实时) 的定义。</p>
<p>　　● 若值不小于199506，则还会公开POSIX.1c (线程) 的定义。</p>
<p>　　● 若值不小于200112，则还会公开POSIX.1-2001基础规范的定义
(在版本2.3.3之前，glibc的头文件会无视这种情况)。</p>
<p>　　● 若值不小于200809，则还会公开POSIX.1-2008基础规范的定义
(在版本2.10之前，glibc的头文件会无视这种情况)。</p>
<p>　　当定义了宏<code>_POSIX_C_SOURCE</code>后，除了会公开POSIX.1、POSIX.2和X/Open
(XPG4) 的定义之外，还可能会公开以下定义
(值500、600和700源于SUSv2、SUSv3和SUSv4分别是X/Open规范的Issue
5、6和7)：</p>
<p>　　● 若值不小于500，则还会公开SUSv2 (UNIX 98和XPG5) 扩展的定义。</p>
<p>　　● 若值不小于600，则还会公开SUSv3 XSI (UNIX 03)
扩展和C99扩展的定义 (在版本2.2之前，glibc的头文件会无视这种情况)。</p>
<p>　　● 若值不小于700，则还会公开SUSv4扩展的定义
(在版本2.10之前，glibc的头文件会无视这种情况)。</p>
<p>　　特性测试宏<code>_BSD_SOURCE</code>、<code>_SVID_SOURCE</code>和<code>_GNU_SOURCE</code>仅适用于glibc。</p>
<p>　　●
若定义了宏<code>_BSD_SOURCE</code>，则会公开BSD的定义，而且也会将宏<code>_POSIX_C_SOURCE</code>定义为值199506。</p>
<p>　　● 若定义了宏<code>_SVID_SOURCE</code>，则会公开SVID的定义。</p>
<p>　　●
若定义了宏<code>_GNU_SOURCE</code>，则会公开通过设置所有上述宏而提供的定义和各种GNU扩展的定义。</p>
<p>　　若调用GNU
C编译器时没有使用特殊选项，则会自动设宏<code>_POSIX_SOURCE</code>、<code>_POSIX_C_SOURCE</code>
(若glibc的版本小于2.4，则设置为值199506；若glibc的版本在2.5到2.9之间，则设置为值200112；否则，设置为值200809)、<code>_BSD_SOURCE</code>和<code>_SVID_SOURCE</code>。</p>
<p>　　若定义了上述宏之一或通过任意标准模式调用编译器
(例如，<code>cc -ansi</code>或<code>cc -std=c99</code>)，则只有定义的宏会生效。但是，存在1个例外，若未定义宏<code>_POSIX_C_SOURCE</code>，并且编译器未以其标准模式之一调用，则该宏会自动定义
(若glibc的版本小于2.4，则设置为值199506；若glibc的版本在2.5到2.9之间，则设置为值200112；否则，设置为值200809)。头文件<code>features.h</code>提供了上述宏的更多信息。</p>
<p>　　可以定义多个特性测试宏。例如，使用如下命令来显式设置默认宏：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -D_POSIX_SOURCE -D_POSIX_C_SOURCE=199506 \ -D_BSD_SOURCE -D_SVID_SOURCE prog.c</span></span><br></pre></td></tr></table></figure>
<p>　　POSIX.1-2001详细说明了<code>_POSIX_C_SOURCE</code>
，并要求定义为值200112。SUSv3详细说明了<code>_XOPEN_SOURCE</code>，并要求定义为值600。POSIX.1-2008和SUSv4与之类似，要求将这2个宏分别定义为值200809和700。</p>
<p>　　SUSv3要求将<code>_XOPEN_SOURCE</code>定义为值600时，应该提供将宏<code>_POSIX_C_SOURCE</code>定义为值200112时提供的所有功能。SUSv4与之类似。</p>
<h4 id="系统数据类型">3.5.2 系统数据类型</h4>
<p>　　为了避免可移植性问题，SUSv3详细说明了各种标准系统数据类型，并且要求UNIX实现合适地定义和使用这些类型。</p>
<p>　　标准系统数据类型都通过关键字<code>typedef</code>定义，并且其名称几乎都以<code>_t</code>结尾。大部分标准系统数据类型都声明在头<code>sys/types.h</code>中，少部分声明在其他头文件中。</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 28%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr>
<th>数据类型</th>
<th>SUSv3类型要求</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>blkcnt_t</code></td>
<td>有符号整数</td>
<td>文件块计数</td>
</tr>
<tr>
<td><code>blksize_t</code></td>
<td>有符号整数</td>
<td>文件块大小</td>
</tr>
<tr>
<td><code>cc_t</code></td>
<td>无符号整数</td>
<td>终端特殊字符</td>
</tr>
<tr>
<td><code>clock_t</code></td>
<td>整数或实浮点数</td>
<td>时钟节拍的系统时间</td>
</tr>
<tr>
<td><code>clockid_t</code></td>
<td>算术类型</td>
<td>POSIX.1b时钟和定时器函数的时钟标识符</td>
</tr>
<tr>
<td><code>comp_t</code></td>
<td>未提及</td>
<td>压缩时钟节拍</td>
</tr>
<tr>
<td><code>dev_t</code></td>
<td>算术类型</td>
<td>设备ID (包括主ID和次ID)</td>
</tr>
<tr>
<td><code>DIR</code></td>
<td>无要求</td>
<td>目录流</td>
</tr>
<tr>
<td><code>fd_set</code></td>
<td>结构体</td>
<td>函数<code>select()</code>的文件描述符集</td>
</tr>
<tr>
<td><code>fsblkcnt_t</code></td>
<td>无符号整数</td>
<td>文件系统块计数</td>
</tr>
<tr>
<td><code>fsfilcnt_t</code></td>
<td>无符号整数</td>
<td>文件计数</td>
</tr>
<tr>
<td><code>gid_t</code></td>
<td>整数</td>
<td>数字组标识符</td>
</tr>
<tr>
<td><code>id_t</code></td>
<td>整数</td>
<td>存储标识符的通用类型，足以容纳<code>pid_t</code>、<code>uid_t</code>和<code>gid_t</code></td>
</tr>
<tr>
<td><code>in_addr_t</code></td>
<td>32位无符号整数</td>
<td>IPv4地址</td>
</tr>
<tr>
<td><code>in_port_t</code></td>
<td>16位无符号整数</td>
<td>IP端口号</td>
</tr>
<tr>
<td><code>ino_t</code></td>
<td>无符号整数</td>
<td>文件i-node号</td>
</tr>
<tr>
<td><code>key_t</code></td>
<td>算术类型</td>
<td>System V IPC密钥</td>
</tr>
<tr>
<td><code>mode_t</code></td>
<td>整数</td>
<td>文件权限和类型</td>
</tr>
<tr>
<td><code>mqd_t</code></td>
<td>除了数组之外的类型</td>
<td>POSIX消息队列描述符</td>
</tr>
<tr>
<td><code>msglen_t</code></td>
<td>无符号整数</td>
<td>System V消息队列允许的字节数</td>
</tr>
<tr>
<td><code>msgqnum_t</code></td>
<td>无符号整数</td>
<td>System V消息队列中的消息数</td>
</tr>
<tr>
<td><code>nfds_t</code></td>
<td>无符号整数</td>
<td>函数<code>poll()</code>的文件描述符数</td>
</tr>
<tr>
<td><code>nlink_t</code></td>
<td>整数</td>
<td>文件的硬链接数</td>
</tr>
<tr>
<td><code>off_t</code></td>
<td>有符号整数</td>
<td>文件偏移或大小</td>
</tr>
<tr>
<td><code>pid_t</code></td>
<td>有符号整数</td>
<td>进程ID、进程组ID和会话ID</td>
</tr>
<tr>
<td><code>ptrdiff_t</code></td>
<td>有符号整数</td>
<td>2个指针值之间的差值</td>
</tr>
<tr>
<td><code>rlim_t</code></td>
<td>无符号整数</td>
<td>资源限制</td>
</tr>
<tr>
<td><code>sa_family_t</code></td>
<td>无符号整数</td>
<td>套接字地址族</td>
</tr>
<tr>
<td><code>shmatt_t</code></td>
<td>无符号整数</td>
<td>System V共享内存段的相关进程计数</td>
</tr>
<tr>
<td><code>sig_atomic_t</code></td>
<td>整数</td>
<td>可原子访问的数据类型</td>
</tr>
<tr>
<td><code>siginfo_t</code></td>
<td>结构体</td>
<td>信号源的信息</td>
</tr>
<tr>
<td><code>sigset_t</code></td>
<td>整数或结构体</td>
<td>信号集</td>
</tr>
<tr>
<td><code>size_t</code></td>
<td>无符号整数</td>
<td>对象的大小 (以字节为单位)</td>
</tr>
<tr>
<td><code>socklen_t</code></td>
<td>至少32位的整数</td>
<td>套接字地址结构体的大小 (以字节为单位)</td>
</tr>
<tr>
<td><code>speed_t</code></td>
<td>无符号整数</td>
<td>终端行速度</td>
</tr>
<tr>
<td><code>ssize_t</code></td>
<td>有符号整数</td>
<td>字节计数或错误指示 (负值)</td>
</tr>
<tr>
<td><code>stack_t</code></td>
<td>结构体</td>
<td>备用信号栈的描述</td>
</tr>
<tr>
<td><code>suseconds_t</code></td>
<td>[-1, 1000000] 内的有符号整数</td>
<td>微秒时间间隔</td>
</tr>
<tr>
<td><code>tcflag_t</code></td>
<td>无符号整数</td>
<td>终止模式标志位掩码</td>
</tr>
<tr>
<td><code>time_t</code></td>
<td>整数或实浮点数</td>
<td>自纪元以来的日历时间 (以秒为单位)</td>
</tr>
<tr>
<td><code>timer_t</code></td>
<td>算术类型</td>
<td>POSIX.1b间隔计时器函数的计时器标识符</td>
</tr>
<tr>
<td><code>uid_t</code></td>
<td>整数</td>
<td>数字用户标识符</td>
</tr>
</tbody>
</table>
<p>　　SUSv3要求某些系统数据类型为算术类型，即整数或浮点数。</p>
<p>　　当打印数值系统数据类型时，必须保证在调用函数<code>printf()</code>时没有<span
style="background-color: yellow">表示依赖</span>
(C的参数提升规则会将<code>short</code>转换为<code>int</code>
，而<code>int</code>和<code>long</code>不变)。函数<code>printf()</code>无法在运行时确定参数的类型，所以调用时必须显式地提供<code>%d</code>或<code>%ld</code>等格式说明符。常用的解决方法是将系统数据类型转换为<code>long</code>并在调用<code>printf()</code>时使用格式说明符<code>%ld</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> mypid;</span><br><span class="line">mypid = getpid();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My PID is %ld\n&quot;</span>, (<span class="type">long</span>)mypid);</span><br></pre></td></tr></table></figure>
<p>　　这种解决方法有1个例外。数据类型<code>off_t</code>在某些编译环境中的长度与<code>long long</code>相同，所以需要将它转换为<code>long long</code>并使用格式说明符<code>%lld</code>。</p>
<p>　　C99标准为函数<code>printf()</code>定义了格式说明符<code>%zd</code>和<code>%jd</code>，前者对应类型<code>size_t</code>和<code>sszie_t</code>，后者对应足以表示任何类型的整数的类型<code>intmax_t</code>
(或<code>uintmax_t</code>)。但是，并非所有UNIX实现都使用glibc，所以应该避免使用这些格式说明符。</p>
<h4 id="其他可移植性问题">3.5.3 其他可移植性问题</h4>
<p>　　每个UNIX实现都给出了用于系统调用和库函数的大量标准结构体。这里以结构体<code>sembuf</code>
(用于表示系统调用<code>semop()</code>执行的信号量操作) 为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sem_num; <span class="comment">/* 信号量号 */</span></span><br><span class="line">    <span class="type">short</span> sem_op;           <span class="comment">/* 执行的操作 */</span></span><br><span class="line">    <span class="type">short</span> sem_flg;          <span class="comment">/* 操作标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　尽管SUSv3详细说明了<code>sembuf</code>等结构体，但通常不会指定这些结构体中的字段定义顺序。在某些情况下，这些结构体可能会包含额外的特定于某些UNIX实现的字段。</p>
<p>　　因此，为了保证可移植性，应使用如下方法初始化结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">s</span>;</span></span><br><span class="line">s.sem_num = <span class="number">3</span>;</span><br><span class="line">s.sem_op = <span class="number">-1</span>;</span><br><span class="line">s.sem_flg = SEM_UNDO;</span><br></pre></td></tr></table></figure>
<p>　　若使用了C99，则可以使用C99的新语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">s</span> =</span> &#123;.sem_num = <span class="number">3</span>, .sem_op = <span class="number">-1</span>, .sem_flg = SEM_UNDO&#125;;</span><br></pre></td></tr></table></figure>
<p>　　有时，并非所有UNIX实现都定义了某个宏。例如，用于检查子进程是否生成了核心转储的宏<code>WCOREDUMP</code>在大部分UNIX实现中都可用，但SUSv3并未说明该宏。因此，该宏并不适用于所有UNIX实现。为了保证可移植性，可以使用<code>#ifdef</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>　　此外，为系统调用和库文件提供原型的头文件可能因UNIX实现而异。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《ARM Cortex-M3与Cortex-M4权威指南 第3版》第2章 嵌入式软件开发简介</title>
    <url>/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/</url>
    <content><![CDATA[<p>　　有超过10家不同的供应商销售用于Cortex-M微控制器的C编译器套件，其范围从开源免费的工具到廉价的工具，再到高端商业包。当前可用的选择包括以下供应商的产品：</p>
<p>　　● Keil Microcontroller Development Kit (MDK-ARM)</p>
<p>　　● ARM DS-5 (Development Studio 5)</p>
<p>　　● IAR Systems (Embedded Workbench for ARM Cortex-M)</p>
<p>　　● Red Suite from Code Red Technologies (已于2013年被NXP收购)</p>
<p>　　● Mentor Graphics Sourcery CodeBench (前身为CodeSourcery Sourcery
g++)</p>
<p>　　● mbed.org</p>
<p>　　● Altium Tasking VX-toolset for ARM Cortex-M</p>
<p>　　● Rowley Associates (CrossWorks)</p>
<p>　　● Coocox</p>
<p>　　● Texas Instruments Code Composer Studio (CCS)</p>
<p>　　● Raisonance RIDE</p>
<p>　　● Atollic TrueStudio</p>
<p>　　● GNU Compiler Collection (gcc)</p>
<p>　　● ImageCraft ICCV8</p>
<p>　　● Cosmic Software C Cross Compiler for Cortex-M</p>
<p>　　● mikroElektronika mikroC</p>
<p>　　● Arduino</p>
<p>　　有些开发板还包括开发套件的基础版或评估版。此外，还存在其他语言的开发套件：</p>
<p>　　● Oracle Java ME Embedded</p>
<p>　　● IS2T MicroEJ Java virtual machine</p>
<p>　　● mikroElektronika mikroBasic, mikroPascal</p>
<span id="more"></span>
<p>　　为了将程序代码下载到微控制器，并进行停止和单步执行等调试操作，需要使用调试适配器，以将PC的USB连接转换为微控制器使用的调试通信协议。大部分C编译器供应商都有自己的调试适配器
(例如，Keil对应ULINK系列产品，IAR对应I-Jet产品)。大多数开发套件也支持第三方调试适配器。此外，不同的供应商可能对这些调试适配器使用不同的术语
(例如，调试探测器、USB-JTAG适配器、JTAG/SW仿真器、JTAG在线仿真器)。</p>
<p>　　有些开发套件会含板载的USB调试适配器 (例如，Texas Instruments、ST
Microelectronics、NXP和Energy
Micro等公司的部分廉价评估板)，并且主流商业开发套件也支持其中的很多板载USB适配器。对于很多评估板或开发板，板载USB调试适配器也可用于连接到其他开发板。此外，这些调试适配器也有开源版本
(例如，ARM的CMSIS-DAP和Coocox的CoLink)。</p>
<p>　　微控制器也有<strong>设备驱动程序</strong>，但其含义与PC的设备驱动程序大不相同。为了帮助微控制器软件开发者，微控制器供应商通常会提供包含外设寄存器定义、外设配置函数和外设访问函数的头文件和C文件，这些文件就是微控制器的设备驱动程序。</p>
<h3 id="软件开发流程">2.1 软件开发流程</h3>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/a_simplified_software_development_flow.svg" class="">
<p>　　软件开发流程取决于使用的编译器套件。这里以带有IDE的编译器为例，软件开发流程通常包含以下步骤：</p>
<p>　　1)
创建项目，项目将指定源文件的位置、编译目标、内存配置和编译选项等设置，很多IDE都有用于此步骤的项目创建引导。</p>
<p>　　2)
添加项目所需的源文件。此外，可能还需要在项目选项中指定所有引用的头文件的路径名。此步骤可以使用设备驱动程序库来减少编写新文件的工作量
(包括启动代码、头文件和部分外设控制函数)。</p>
<p>　　3)
设置项目选项。在大多数情况下，创建的项目文件允许设置编译器优化、内存映射和输出文件类型等项目选项。基于使用的开发板和调试适配器，可能还需要设置调试和下载程序的选项。</p>
<p>　　4)
编译和链接。在大多数情况下，项目会包含大量需要单独编译的文件。在编译后，每个源文件都有对应的目标文件。为了生成最终的可执行镜像，还需要进行链接。在链接后，IDE也可以生成其他文件格式的程序映像，以便将映像下载到设备上。</p>
<p>　　5)
闪存编程。几乎所有Cortex-M微处理器使用闪存来存储程序。在程序映像创建后，需要将其下载到微控制器的闪存。为此，需要使用调试适配器。实际的闪存编程过程相当复杂，但该过程通常由IDE完成。此外，程序也可以下载到SRAM，并在SRAM中执行。</p>
<p>　　6)
执行程序和调试。在程序下载到微控制器后，可以运行程序，并检查是否正常运行
(使用IDE中的调试环境来停止处理器并检查系统状态)。若程序不正常运行，则可以使用单步执行等调试功能来获取程序执行细节。这些操作都需要调试适配器来连接IDE与微控制器。当找到程序漏洞后，需要编辑程序代码和重新编译，然后将程序下载到微控制器，以再次测试。</p>
<p>　　若使用的是没有IDE的开源工具链，则需要使用脚本或makefile来控制编译和链接过程。此外，可能还需要第三方工具来将程序下载到微控制器，这取决于使用的微控制器产品。</p>
<p>　　在执行程序的过程中，可以通过UART接口或LCD模块等I/O机制来输出信息，以检查执行状态和结果。</p>
<h3 id="编译程序">2.2 编译程序</h3>
<p>　　编译嵌入式程序的流程取决于使用的开发工具。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/common_software_compilation_flow.svg" class="">
<p>　　首先，假设使用的是微控制器软件开发中最常用的编程语言——C语言，项目中可能包含一些汇编语言文件
(例如，微控制器供应商提供的启动代码)。在大多数情况下，编译流程与上图所示的流程类似。</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>C编译器</td>
<td>将C程序文件编译为目标文件</td>
</tr>
<tr>
<td>汇编器</td>
<td>将汇编代码文件汇编为目标文件</td>
</tr>
<tr>
<td>链接器</td>
<td>将多个目标文件合并在一起并定义内存配置</td>
</tr>
<tr>
<td>闪存编程器</td>
<td>将编译后的程序映像下载到微控制器的闪存</td>
</tr>
<tr>
<td>调试器</td>
<td>控制微控制器的操作和访问内部运行信息，以便检查系统状态和程序操作</td>
</tr>
<tr>
<td>模拟器</td>
<td>在没有实际硬件的情况下模拟程序运行</td>
</tr>
<tr>
<td>其他工具</td>
<td>文件转换程序 (将编译后的文件转换为其他格式) 等工具</td>
</tr>
</tbody>
</table>
<p>　　不同的开发工具使用不同的方法来指定微控制器中的程序和数据内存的布局。对于ARM工具链，可以使用<span
style="background-color: yellow">分散加载文件</span> (Keil
MDK-ARM的μVision会自动生成分散加载文件)。对于有些ARM工具链，也可以使用命令行选项来指定ROM和RAM的位置。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/common_software_compilation_flow_for_gnu_toolchain.svg" class="">
<p>　　对于基于GNU的工具链，内存配置由链接器脚本指定，链接器脚本通常包含在商业gcc工具链的安装过程中。但是，有些gcc用户会创建自己的链接器脚本。GNU
gcc工具链通常会编译整个程序，而非将编译过程和链接过程分开。</p>
<p>　　若有需要，gcc在编译时会自动调用链接器和汇编器，以保证所需参数和库会正确地转递给链接器。将链接过程作为单独的步骤很可能出错，所以大多数gcc工具供应商都不建议这样做。</p>
<h3 id="软件流程">2.3 软件流程</h3>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/polling_method_for_application_with_multiple_devices_that_need_processing.svg" class="">
<p>　　对于简单的应用程序，处理器可以一直等待，直到待处理的数据出现，然后处理该数据并继续等待。在大多数情况下，微控制器会服务多个接口，所以需要处理多个请求。<span
style="background-color: yellow">轮询</span>方法可以轻松地支持处理多个请求，这种设计有时也称为超级循环。</p>
<p>　　轮询方法很适合简单的应用程序，但它有多个缺点。例如，当程序变得复杂时，轮询的循环设计将可能会变得非常困得。此外，这种方法难以定义优先级，并且效率不高。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/simple_interrupt-driven_application.svg" class="">
<p>　　当外设不需要服务时，轮询方法会浪费系统资源。为此，几乎所有微控制器都支持睡眠模式
(以降低功耗)。在睡眠模式下，外设在需要服务时会唤醒处理器。此外，来自不同外设的中断可以指定不同的中断优先级。这种设计通常称为<span
style="background-color: yellow">中断驱动</span>。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/application_with_both_polling_method_and_interrupt-driven_arrangement.svg" class="">
<p>　　在某些情况下，来自外设服务的数据处理可以分为2个部分：第1部分需要快速完成，第2部分可以稍后完成。此时，可以同时使用轮询与中断驱动设计来构建程序。当外设需要服务时，会触发中断请求。一旦中断服务的第1部分完成，程序会更新软件变量来让服务的第2部分由基于轮询的代码完成。通过这种设计，可以减少高优先级的中断处理函数的运行时间，所以低优先级的中断服务可以更快地得到服务。</p>
<p>　　当应用程序足够复杂时，同时使用轮询与中断驱动设计可能都无法处理请求。例如，并发执行多个耗时较长的任务，这可以通过将处理器时间划分为多个时间片，并将时间片分配给任务来完成。从技术角度，这可以通过手动对任务分类和创建简单的调度程序来实现，但在实际项目中这样做往往不切实际，因为这样不仅耗时，而且会使程序难以维护和调试。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/using_an_rtos_to_handle_multiple_tasks.svg" class="">
<p>　　对于这些应用程序，RTOS可用于处理任务调度。RTOS通过将处理器时间划分为时间片，并将时间片分配给任务，以支持并发执行多个处理。RTOS的内部记录需要使用定时器，并且在时间片结束时生成定时器中断，然后定时器中断触发任务调度程序，决定是否切换任务。若是，则当前执行的处理会被挂起，处理器执行其他处理。</p>
<p>　　除了任务调度之外，RTOS还具有信号量和信息传递等功能。为Cortex-M处理器开发的RTOS有很多，并且其中的很多RTOS都是免费的。</p>
<h3 id="c编程中的数据类型">2.4 C编程中的数据类型</h3>
<p>　　C支持大量标准数据类型。但是，硬件如何表示数据取决于处理器架构和C编译器。在不同的处理器架构中，特定数据结构的长度可能不同。ARM架构的常用数据类型如下
(包括所有Cortex-M处理器)：</p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 6%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr>
<th>C和C99数据类型 (<code>stdint.h</code>)</th>
<th>位数</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char</code>/<code>int8_t</code>/<code>uint8_t</code></td>
<td>8</td>
<td>-128到127 (有符号) 或0到255 (无符号)</td>
</tr>
<tr>
<td><code>short int16_t</code>/<code>uint16_t</code></td>
<td>16</td>
<td>-32768到32767 (有符号) 或0到65535 (无符号)</td>
</tr>
<tr>
<td><code>int</code>/<code>int32_t</code>/<code>uint32_t</code></td>
<td>32</td>
<td>-2147483648到2147483647 (有符号) 或0到4294967295 (无符号)</td>
</tr>
<tr>
<td><code>long</code></td>
<td>32</td>
<td>-2147483648到2147483647 (有符号) 或0到4294967295 (无符号)</td>
</tr>
<tr>
<td><code>long long</code>/<code>int64_t</code>/<code>uint64_t</code></td>
<td>64</td>
<td>-2<sup>63</sup>到2<sup>63</sup>-1 (有符号) 或0到2<sup>64</sup>-1
(无符号)</td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>-3.4028234×10<sup>38</sup>到3.4028234×10<sup>38</sup></td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>-1.7976931348623157×10<sup>308</sup>到1.7976931348623157×10<sup>308</sup></td>
</tr>
<tr>
<td><code>long double</code></td>
<td>64</td>
<td>-1.7976931348623157×10<sup>308</sup>到1.7976931348623157×10<sup>308</sup></td>
</tr>
<tr>
<td>指针</td>
<td>32</td>
<td><code>0x0</code>到<code>0xFFFFFFFF</code></td>
</tr>
<tr>
<td>枚举</td>
<td>8/16/32</td>
<td>尽可能小的数据类型 (除非被编译器选项覆盖)</td>
</tr>
<tr>
<td><code>_Bool</code> (仅限于C) /<code>bool</code> (仅限于C++)</td>
<td>8</td>
<td><code>true</code>或<code>false</code></td>
</tr>
<tr>
<td><code>wchar_t</code></td>
<td>16</td>
<td>0到65536</td>
</tr>
</tbody>
</table>
<p>　　因为特定数据类型之间的不同，所以将8位或16位微处理器中的应用程序移植到Cortex-M微控制器时可能需要进行修改。</p>
<p>　　在ARM编程时，可能会使用术语<strong>字节</strong>
(8位)、<strong>半字</strong> (16位)、<strong>字</strong> (32位)
和<strong>双字</strong> (64位)。</p>
<h3 id="io和外设访问">2.5 I/O和外设访问</h3>
<p>　　几乎所有微控制器都有各种I/O以及定时器和实时时钟等外设。对于Cortex-M3和Cortex-M4，会有GPIO、SPI、UART和IAC等常见外设，可能还有USB、CAN和以太网等高级接口外设以及ADC和DAC等模拟接口
(这里的大部分接口外设都是特定于供应商的)。</p>
<p>　　对于这些微控制器，外设是映射到内存的，所以外设寄存器可以从系统内存映射访问
(通过指针)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Configuration Register Low */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_CRL (*((volatile unsigned long *)(0x40010800)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Configuration Register High */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_CRH (*((volatile unsigned long *)(0x40010804)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Input Data Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_IDR (*((volatile unsigned long *)(0x40010808)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Output Data Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_ODR (*((volatile unsigned long *)(0x4001080C)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Bit Set/Reset Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_BSRR (*((volatile unsigned long *)(0x40010810)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Bit Reset Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_BRR (*((volatile unsigned long *)(0x40010814)))</span></span><br><span class="line"><span class="comment">/* STM32F100RBT6B - GPIO A Port Configuration Lock Register */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_LCKR (*((volatile unsigned long *)(0x40010818)))</span></span><br></pre></td></tr></table></figure>
<p>　　通常，外设需要在使用前初始化，初始化可能包含以下步骤：</p>
<p>　　●
对时钟控制电路进行编程，以启用到外设的时钟信号连接，并在需要时启用到对应I/O引脚的时钟信号连接。很多现代微控制器允许对时钟信号进行调整
(例如，启用/关闭到每个独立外设的时钟连接，以降低功耗)。到外设的时钟通常都是关闭的，所以在对外设进行编程前需要启用时钟。在某些情况下，可能还需要启用到外设总线系统的时钟。</p>
<p>　　●
在部分情况下，可能需要配置I/O引脚的工作模式。大多数微控制器都有用于多个目的的复用I/O引脚。为了使用外设，可能需要配置I/O引脚，以匹配用途
(例如，I/O方向和函数)。此外，可能还需要设置额外的配置寄存器，以定义预期的电器特性
(例如，电压、上拉或下拉以及开漏)。</p>
<p>　　●
配置外设。大多数外设包含大量可编程的寄存器，使用外设前需要先配置这些寄存器。微控制器供应商通常会提供相关的设备驱动程序库。</p>
<p>　　● 中断配置。若外设需要与中断操作一起使用，则需要对中断控制器
(NVIC) 进行编程，以启用中断和配置中断优先级。</p>
<p>　　以上初始化步骤都是通过对外设模块中的外设寄存器进行编程来完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIOA_reset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 将所有引脚设置为模拟输入模式 */</span></span><br><span class="line">    GPIOA_CRL = <span class="number">0</span>;</span><br><span class="line">    GPIOA_CRH = <span class="number">0</span>;</span><br><span class="line">    GPIOA_ODR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　可以直接使用之前的定义来初始化外设寄存器，这种方法适用于外设寄存器较少的情况。对于外设寄存器较多的情况，这种方法可能会导致问题：</p>
<p>　　●
对于每个寄存器地址定义，程序都需要对应的常量，进而增加代码量。</p>
<p>　　● 若外设有多个实例
(例如，STM32微控制器有5个GPIO外设)，则每个实例都需要重复相同的定义。</p>
<p>　　●
编写可以在同一外设的多个实例之间共享的函数并不容易。例如，在使用示例中的定义时，可能需要为每个GPIO端口都创建相同的GPIO重置函数，进而增加代码量。</p>
<p>　　为了解决这些问题，通常会将外设寄存器定义为结构体。例如，在微控制器供应商提供的设备驱动程序库中可以找到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> CRL;</span><br><span class="line">    __IO <span class="type">uint32_t</span> CRH;</span><br><span class="line">    __IO <span class="type">uint32_t</span> IDR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> ODR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> BSRR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> BRR;</span><br><span class="line">    __IO <span class="type">uint32_t</span> LCKR;</span><br><span class="line">&#125; GPIO_TypeDef;</span><br></pre></td></tr></table></figure>
<p>　　然后，所有外设的基地址都定义为指向该结构体的指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE ((uint32_t)0x40000000)</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2PERIPH_BASE (PERIPH_BASE + 0x10000)</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_BASE (APB2PERIPH_BASE + 0x0800)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE (APB2PERIPH_BASE + 0x0C00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_BASE (APB2PERIPH_BASE + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_BASE (APB2PERIPH_BASE + 0x1400)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_BASE (APB2PERIPH_BASE + 0x1800)</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA ((GPIO_TypeDef *)GPIOA_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB ((GPIO_TypeDef *)GPIOB_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC ((GPIO_TypeDef *)GPIOC_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD ((GPIO_TypeDef *)GPIOD_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE ((GPIO_TypeDef *)GPIOE_BASE)</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>
<p>　　这里的<code>__IO</code>是CMSIS标准头文件定义的关键字
(类似关键字<code>volatile</code>)，表示软件可以读写。此外，还有类似的关键字<code>__I</code>和<code>__O</code>，前者表示只读，后者表示只写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __I volatile</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __I volatile const</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __O volatile</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IO volatile</span></span><br></pre></td></tr></table></figure>
<p>　　<code>uint32_t</code> (无符号32位整数)
是从C99开始支持的数据类型，它会确保数据的长度是32位
(无论处理器架构)。为了使用该数据类型，项目需要引用头文件<code>stdint.h</code>
(若使用的是符合CMSIS的设备头文件，则设备头文件会完成该任务)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="comment">/* C99标准数据类型：</span></span><br><span class="line"><span class="comment">uint8_t - 无符号8位整数</span></span><br><span class="line"><span class="comment">int8_t - 有符号8位整数</span></span><br><span class="line"><span class="comment">uint16_t - 无符号16位整数</span></span><br><span class="line"><span class="comment">int16_t - 有符号16整数</span></span><br><span class="line"><span class="comment">uint32_t - 无符号32位整数</span></span><br><span class="line"><span class="comment">int32_t - 有符号32整数</span></span><br><span class="line"><span class="comment">uint64_t - 无符号64位整数</span></span><br><span class="line"><span class="comment">int64_t - 有符号64整数</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>　　当外设以这种方式声明后，就可以轻松地编写适用于外设的多个实例的函数。例如，重置GPIO端口的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_reset</span><span class="params">(GPIO_TypeDef *GPIOx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 将所有引脚设置为模拟输入模式 */</span></span><br><span class="line">    GPIOx-&gt;CRL = <span class="number">0</span>;</span><br><span class="line">    GPIOx-&gt;CRH = <span class="number">0</span>;</span><br><span class="line">    GPIOx-&gt;ODR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　调用该函数时，只需要将外设基地址作为参数转递：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_reset(GPIOA);</span><br><span class="line">GPIO_reset(GPIOB);</span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>
<p>　　几乎所有Cortex-M微控制器设备驱动程序库都使用这种声明外设寄存器的方法。</p>
<h3 id="微控制器接口">2.6 微控制器接口</h3>
<p>　　不同于PC应用程序，大多数嵌入式应用程序都没有丰富的GUI。虽然应用程序本身可能不需要用户接口，但基于文本的简单通信方法有时可能很有用
(例如，在程序执行期间打印通过ADC获取的数据)。很多方法可用于显示此类信息：</p>
<p>　　● 使用连接到微控制器I/O引脚的字符LCD显示模块。</p>
<p>　　● 使用简单的UART来与运行在PC上的终端程序通信。</p>
<p>　　●
在微控制器上将USB接口设置为虚拟COM端口，以便与运行在PC上的终端程序通信。</p>
<p>　　● 使用指令跟踪宏单元 (ITM) 来与调试器软件通信。</p>
<p>　　在某些情况下，字符LCD可能是嵌入式产品的一部分，所以使用该硬件来显示信息很方便。但是，屏幕的尺寸会限制每次显示的信息量。</p>
<p>　　UART易于使用，并且允许传递更多的信息给开发者。Cortex-M3/M4没有将UART作为标准模块，但大多数微控制器供应商都在其微控制器设计中加入了UART外设。但是，大多数PC都没有UART接口
(COM端口)，所以可能需要额外的USB转UART适配器来实现通信。此外，还需要TTL转RS232适配器来转换信号电压。</p>
<p>　　对于某些开发板 (例如，Texas Instruments Stellaris
LaunchPad)，板载调试器包含UART转USB的功能。</p>
<p>　　若使用的微控制器包含USB接口，则可以使用该接口来与PC通信。例如，通过使用虚拟COM端口来与运行在PC上的终端程序进行基于文本的通信。这需要对软件进行额外的配置，但允许微控制器硬件直接与PC连接，省去了RS232适配器。</p>
<p>　　若使用了Keil ULINK2和Segger
J-LINK等商业调试适配器，则可以使用ITM来将传输信息到调试主机
(运行在PC上的调试器)，并在开发软件中显示。这不需要额外的硬件，并且软件开销也不大。</p>
<p>　　将<code>printf()</code> (C语言函数) 中的文本信息重定向到指定硬件
(例如，UART和字符LCD) 的技术称为<span
style="background-color: yellow">重定向</span>。重定向在处理用户输入和系统函数时很有用。用于重定向的C代码是特定于工具链的。</p>
<h3 id="cortex微控制器软件接口标准">2.7 Cortex微控制器软件接口标准</h3>
<p>　　ARM制定的<span
style="background-color: yellow">Cortex微控制器软件接口标准</span>
(CMSIS)
允许微控制器和软件供应商使用一致的软件基础设施为Cortex-M微控制器开发软件。CMSIS旨在提升软件的可重用性和兼容性、保证软件的开源性以及让软件易于学习和独立于工具链。因此，很多Cortex-M微控制器开发的软件都是符合该标准的。</p>
<p>　　CMSIS是1个持续发展的项目。它最初用于保证Cortex-M微控制器的设备驱动程序库之间的一致性，该部分现已成为CMSIS-Core。从那时起，其他CMSIS项目已经开始：</p>
<p>　　● CMSIS-Core (Cortex-M处理器支持)
是1组API，供应用程序和中间件开发者访问Cortex-M处理器的功能。CMSIS目前支持的处理器包括Cortex-M0、Cortex-M0+、Cortex-M3、Cortex-M4以及SC000和SC300等SecurCore产品
(Cortex-M1同Cortex-M0)。</p>
<p>　　●
CMSIS-DSP库于2010年发布，支持FFT和滤波器等常用DSP操作。CMSIS-DSP旨在允许软件开发者轻松地在Cortex-M微控制器上开发DSP应用程序。</p>
<p>　　● CMSIS-SVD (CMSIS系统视图描述)
是基于XML的文件格式，用于描述微控制器产品的外设。调试工具供应商可以使用微控制器供应商准备的CMSIS-SVD文件来快速构建外设查看器。</p>
<p>　　●
CMSIS-RTOS是运行在微控制器的嵌入式OS的API规范，允许为多个嵌入式OS平台开发中间件和应用程序代码，同时也能提高可重用性和兼容性。</p>
<p>　　● CMSIS-DAP是调试接口设配器的参考设计
(支持USB到JTAG/串口协议的转换)，允许开发适用于多个开发工具链的低成本调试适配器。</p>
<h4 id="cmsis-core的标准化范围">2.7.1 CMSIS-Core的标准化范围</h4>
<p>　　从软件开发角度，CMSIS-Core标准化了多个领域：</p>
<p>　　●
CMSIS-Core标准化了处理器外设的定义，包括包括NVIC寄存器、处理器中的系统节拍定时器
(SysTick)、可选的MPU、系统控制模块中的各种可编程寄存器以及与有些与调试功能相关的软件可编程寄存器。</p>
<p>　　●
CMSIS-Core标准化了处理器功能访问函数，包括通过NVIC进行中断控制的各种函数和访问处理器中的特殊寄存器的函数。尽管在必要时可以直接访问寄存器，但使用访问函数
(或API) 的通用编程可以提高程序的可移植性。</p>
<p>　　●
CMSIS-Core标准化了用于访问特殊指令的函数。Cortex-M处理器支持很多用于特殊目的的寄存器
(例如，等待中断、WFI和进入睡眠模式)，这些指令无法使用通用的IEC/ISO
C语言生成。因此，CMSIS实现了1组函数，以便在C程序代码中访问这些指令。若没有这些函数，则用户只能使用特定于工具链的解决方案，这会降低程序的可重用性，并且可能需要对工具链有比较深入的了解。CMSIS提供了1个用于这些函数的标准API，以便应用程序开发者可以轻松使用。</p>
<p>　　● CMSIS-Core标准化了系统异常处理函数的命名。</p>
<p>　　●
CMSIS-Core标准化了系统初始化函数。大多数功能丰富的微控制器产品在应用程序启动之前需要对时钟电路和电源控制寄存器进行配置。对于符合CMSIS的设备驱动程序库，这些配置步骤实现在函数<code>SystemInit()</code>中。</p>
<p>　　●
CMSIS-Core标准化了表示时钟频率信息的软件变量。这一点可能不明显，但应用程序代码可能经常需要访问系统的时钟频率
(例如，设置UART的波特率分频器或初始化嵌入式OS的SysTick)。CMSIS-Core定义了软件变量<code>SystemCoreClock</code>
(CMSIS 1.3及以上版本) 或<code>SystemFrequency</code> (更早的CMSIS版本)
来表示时钟频率。</p>
<p>　　此外，CMSIS-Core还提供了用于设备驱动程序库的通用平台。所有设备驱动程序库的用法都相似，以便于初学者快速上手这些设备和软件开发者为多个Cortex-M产品开发软件。</p>
<h4 id="cmsis-core的组织结构">2.7.2 CMSIS-Core的组织结构</h4>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/cmsis-core_structure.svg" class="">
<p>　　微控制器供应商的设备驱动程序库集成了CMSIS文件。设备驱动程序库中的某些文件由ARM准备，并且这些文件是各种微控制器供应商的通用文件。其他文件是特定于供应商/设备的。通常，CMSIS定义为多个层次：核心外设访问层、设备外设访问层、外设访问函数和可选的中间件访问层。</p>
<p>　　● 核心外设访问层是特定于处理器的
(由ARM提供)，包括名称定义、地址定义和用于访问核心寄存器和核心外设的辅助函数。</p>
<p>　　●
设备外设访问层是特定于设备的，包括名称定义、外设寄存器的地址定义和系统实现
(例如，中断分配和异常向量定义)。</p>
<p>　　●
外设访问函数是用于访问外设的驱动程序代码。这些函数是特定于供应商的，并且是可选的。</p>
<p>　　●
中间件访问层用于访问外设设备，其思想是开发1组API来连接UART、SPI和以太网等常见外设。若该层存在，则中间件的开发者可以基于该层开发应用程序，以便在设备之间移植软件。</p>
<p>　　在有些情况下，设备驱动程序库可能包含微控制器供应商实现的特定于供应商的附加NVIC函数。</p>
<h4 id="cmsis-core的用法">2.7.3 CMSIS-Core的用法</h4>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/using_cmsis-core_in_a_project.svg" class="">
<p>　　微控制器供应商提供的符合CMSIS的设备驱动程序库会包含CMSIS文件。当不使用这些库时，通常需要通过以下步骤来使用CMSIS-Core：</p>
<p>　　● 将源文件添加到项目，包括特定于设备和工具链的启动代码
(C或汇编)、特定于设备的设备初始化代码
(例如，<code>system_device.c</code>)
和可选的特定于供应商的外设访问函数代码。对于CMSIS
2.00及以下版本的CMSIS-Core库，若需要使用某些核心寄存器访问函数，则可能还需要添加特定于处理器的C文件
(例如，<code>core_cm3.c</code>)，CMSIS
2.10及以上版本的CMSIS-Core库不需要如此。</p>
<p>　　●
将头文件添加到项目的搜索路径，包括外设寄存器定义和中断分配定义对应的特定于设备的头文件
(例如，<code>device.h</code>)、设备初始化代码对应的特定于设备的头文件
(例如，<code>system_device.h</code>)、各种特定于处理器的头文件
(例如，<code>core_cm3.h</code>和<code>core_cm4.h</code>)
和可选的外设访问函数对应的特定于供应商的头文件。此外，开发组件可能会包含一些预装的通用CMSIS支持文件。</p>
<p>　　在程序中引用将特定于设备的头文件后，这些头文件还会自动引用其他头文件，所以需要为这些头文件设置项目搜索路径，以保证程序可以正确编译。</p>
<p>　　在部分情况下，IDE在创建项目时会自动设置启动代码。否则，需要手动从设备驱动程序库中将启动代码复制到项目。处理器的启动序列需要启动代码，并且启动代码中还包含中断所需的异常向量表定义。</p>
<h4 id="cmsis的版本">2.7.4 CMSIS的版本</h4>
<p>　　CMSIS项目一直在发展。在过去的几年里，已经发布了多个版本，带来了更广泛的处理器支持和优化。除了优化代码之外，还有很多其他变化：</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 12%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr>
<th>CMSIS版本</th>
<th>发布时间</th>
<th>主要变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.0</td>
<td>2008年11月</td>
<td>第1次发布，仅支持Cortex-M3。</td>
</tr>
<tr>
<td>1.10</td>
<td>2009年2月</td>
<td>添加对Cortex-M0的支持。</td>
</tr>
<tr>
<td>1.20</td>
<td>2009年5月</td>
<td>添加对TASKING编译器的支持。添加用于管理NVIC优先级设置的更多函数。</td>
</tr>
<tr>
<td>1.30</td>
<td>2009年10月</td>
<td>系统初始化函数<code>SystemInit()</code>修改为由启动代码调用
(而非在主函数的开头调用)。变量<code>SystemFrequency</code>重命名为<code>SystemCoreClock</code>，以更好地体现其含义。添加函数<code>void SystemCoreClockUpdate(void)</code>。添加对调试通信的数据接收的支持
(以前的版中通过ITM来输出调试通信中的数据)。添加处理器的外设寄存器的位定义。修改目录结构。</td>
</tr>
<tr>
<td>2.0</td>
<td>2010年11月</td>
<td>添加对Cortex-M4的支持。添加用于Cortex-M3和Cortex-M4的CMSIS DSP库
(CMSIS-DSP)。添加头文件<code>core_cm4_simd.h</code>、<code>core_cmFunc.h</code>和<code>core_cmInst.h</code>，并将大量核心访问函数移入到这些头文件
(内联)。添加CMSIS系统视图描述。</td>
</tr>
<tr>
<td>2.10</td>
<td>2010年1月</td>
<td>添加用于Cortex-M0的CMSIS-DSP库。添加对DSP库的大端支持。简化目录结构。特定于处理器的C文件将
(例如，<code>core_cm3.h</code>和<code>core_cm4.h</code>)
不再需要并被删除。重写CMSIS-DSP库示例。更新文档。</td>
</tr>
<tr>
<td>3.0</td>
<td>2010年10月</td>
<td>添加对ARM嵌入式处理器的GNU工具的支持。添加函数<code>_ROR()</code>。添加TPIU和DWT的寄存器映射。添加对SC000和SC300的支持。修复函数<code>ITM_SendChar()</code>。修复用于gcc编译器段的函数<code>__STREXB()</code>和<code>__STREXH()</code>。重组文档。</td>
</tr>
<tr>
<td>3.01</td>
<td>2012年3月</td>
<td>添加对Cortex-M0+的支持。集成CMSIS-DSP库版本1.1.0。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第4章 文件I/O：通用I/O模型</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_04/</url>
    <content><![CDATA[<p>　　所有执行I/O的系统调用都通过<strong>文件描述符</strong>
(通常是较小的非负整数)
打开文件。文件描述符用于引用所有类型的打开的文件，包括无名管道、有名管道、套接字、终端、设备和常规文件。每个进程都有自己的文件描述符集。</p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>目的</th>
<th>POSIX名称</th>
<th>stdio流</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>标准输入</td>
<td><code>STDIN_FILENO</code></td>
<td><code>stdin</code></td>
</tr>
<tr>
<td>1</td>
<td>标准输出</td>
<td><code>STDOUT_FILENO</code></td>
<td><code>stdout</code></td>
</tr>
<tr>
<td>2</td>
<td>标准错误</td>
<td><code>STDERR_FILENO</code></td>
<td><code>stderr</code></td>
</tr>
</tbody>
</table>
<p>　　按照惯例，大多数程序都期望能够使用3个标准文件描述符
(即文件描述符0~2)。程序会继承打开它的shell的文件描述符，而shell通常在这3个文件描述符打开的情况下运行。对于交互性shell，这3个文件描述符通常指运行shell的终端。若在命令行中指定了I/O重定向，则shell会保证在启动程序前就适当地修改文件描述符。</p>
<p>　　在程序中可以直接使用数字0~2来引用标准文件描述符，更好的方法是使用头文件<code>unistd.h</code>中定义的POSIX标准名。</p>
<p>　　变量<code>stdin</code>、<code>stdout</code>和<code>stderr</code>最初引用进程的标准输入、输出和错误，但可以使用库函数<code>freopen()</code>来让它们引用其他文件。作为其操作的一部分，<code>freopen()</code>可能改变重新打开的流的底层描述符
(例如，对<code>stdout</code>使用<code>freopen()</code>后，无法保证其底层描述符一定是1)。</p>
<p>　　以下是4个重要的执行文件I/O的系统调用：</p>
<p>　　●
<code>fd = open(pathname, flags, mode)</code>会打开参数<code>pathname</code>对应的文件，然后返回打开的文件描述符。若文件不存在，则<code>open()</code>可能会创建
(根据参数<code>flags</code>的值)。参数<code>flags</code>还指定打开文件是为了读或/和写。参数<code>mode</code>指定<code>open()</code>创建的文件的访问权限，若此次调用<code>open()</code>不会创建文件，则该参数会被忽略。</p>
<p>　　●
<code>numread = read(fd, buffer, count)</code>会从参数<code>fd</code>引用的打开的文件中读取最多<code>count</code>字节，然后将这些字节存储在<code>buffer</code>中。<code>read()</code>会返回实际读取的字节数。若文件中没有可读的字节，即文件结尾
(EOF)，则<code>read()</code>会返回0。</p>
<p>　　●
<code>numwritten = write(fd, buffer, count)</code>会将<code>buffer</code>中的最多<code>count</code>字节写入到参数<code>fd</code>引用的打开的文件。<code>write()</code>会返回实际写入的字节数
(不会大于<code>count</code>)。</p>
<p>　　●
<code>status = close(fd)</code>会释放参数<code>fd</code>及其相关内核资源。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* copy.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE <span class="comment">/* 允许用cc -D覆盖定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> inputFd, outputFd, openFlags;</span><br><span class="line">    <span class="type">mode_t</span> filePerms;</span><br><span class="line">    <span class="type">ssize_t</span> numRead;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s old-file new-file\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开输入和输出文件 */</span></span><br><span class="line">    inputFd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (inputFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;opening file %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    openFlags = O_CREAT | O_WRONLY | O_TRUNC;</span><br><span class="line">    filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |</span><br><span class="line">                S_IROTH | S_IWOTH; <span class="comment">/* rw-rw-rw- */</span></span><br><span class="line">    outputFd = open(argv[<span class="number">2</span>], openFlags, filePerms);</span><br><span class="line">    <span class="keyword">if</span> (outputFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;opening file %s&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 传输数据，直到遇到输入结束或出错 */</span></span><br><span class="line">    <span class="keyword">while</span> ((numRead = read(inputFd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(outputFd, buf, numRead) != numRead)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;couldn&#x27;t write whole buffer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(inputFd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close input&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close(outputFd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close output&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是包含上述4个系统调用的用法的示例代码，其功能与命令<code>cp</code>的相同，会复制第1个命令行参数指定的文件中的内容到第2个命令行参数指定的文件。用法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./copy oldfile newfile</span></span><br></pre></td></tr></table></figure>
<p>　　由于I/O通用性，上述4个系统调用可以对所有类型的文件执行I/O。因此，仅使用这些系统调用的程序也能作用于所有类型的文件。</p>
<p>　　为了实现I/O通用性，需要确保所有文件系统和设备驱动程序都实现相同的I/O系统调用集。特定于文件系统或设备的细节都是在内核中处理，所以在开发应用程序时通常可以忽略特定于设备的因素。若需要访问特定于文件系统或设备的特性，可以使用通用系统调用<code>ioctl()</code>，该系统调用会提供I/O通用模型之外的特性的接口。</p>
<h3 id="打开文件">4.1 打开文件</h3>
<p>　　系统调用<code>open()</code>会打开已存在的文件或创建新文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, ... <span class="comment">/* mode_t mode */</span>)</span>; <span class="comment">/* 成功时返回文件描述符，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　参数<code>pathname</code>标识打开的文件
(若它是符号链接，则会解引用)。若<code>open()</code>成功，则返回文件描述符；若出错，则返回-1并设置<code>errno</code>。</p>
<table>
<thead>
<tr>
<th>访问模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code></td>
<td>以只读模式打开文件</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td>以只写模式打开文件</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td>以读写模式打开文件</td>
</tr>
</tbody>
</table>
<p>　　参数<code>flags</code>是位掩码，可用于指定文件访问模式。早期UNIX实现直接使用数字0~2表示访问模式。大多数现代UNIX实现都会将这些访问模式定义为这些值。因此，<code>O_RDWR</code>并不等同于<code>O_RDONLY | O_WRONLY</code>，后者会被认为是逻辑错误。</p>
<p>　　当<code>open()</code>用于创建新文件时，位掩码参数<code>mode</code>会指定新创建的文件的访问权限。若调用<code>open()</code>时不将参数<code>flags</code>指定为<code>O_CREAT</code>，则<code>mode</code>会被忽略。</p>
<p>　　实际上，<code>open()</code>创建的新文件的权限并非仅取决于参数<code>mode</code>，还取决于父目录的进程umask和
(可选的) 默认访问控制列表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以只读模式打开文件 */</span></span><br><span class="line">fd = open(<span class="string">&quot;startup&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以读写模式打开已存在文件或创建新文件，截断为0字节；</span></span><br><span class="line"><span class="comment">拥有者对文件有读写权限，其他用户没有任何访问权限 */</span></span><br><span class="line">fd = open(<span class="string">&quot;myfile&quot;</span>, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以只写模式打开已存在文件或创建新文件；</span></span><br><span class="line"><span class="comment">写入的数据位于文件结尾 */</span></span><br><span class="line">fd = open(<span class="string">&quot;w.log&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC | O_APPEND,</span><br><span class="line">          S_IRUSR | S_IWUSR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>open()</code>的用法
(使用了参数<code>flags</code>)。</p>
<p>　　SUSv3要求<code>open()</code>成功时返回的文件描述符是进程未使用的最小的文件描述符，该特性可用于通过特定的文件描述符打开文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (close(STDIN_FILENO) == <span class="number">-1</span>) <span class="comment">/* 关闭文件描述符0 */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd = open(pathname, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这段代码中，因为文件描述符0未被使用，所以<code>open()</code>用该描述符打开文件。</p>
<h4 id="参数flags">4.1.1 参数<code>flags</code></h4>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 76%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr>
<th>标志</th>
<th>目的</th>
<th>SUS?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code></td>
<td>以只读模式打开</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td>以只写模式打开</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td>以读写模式打开</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_CLOEXEC</code></td>
<td>设置close-on-exec标志 (Linux 2.6.23及以上版本)</td>
<td>SUSv4</td>
</tr>
<tr>
<td><code>O_CREAT</code></td>
<td>若文件不存在，则创建文件</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_DIRECT</code></td>
<td>文件I/O绕过缓冲区</td>
<td></td>
</tr>
<tr>
<td><code>O_DIRECTORY</code></td>
<td>若<code>pathname</code>不是目录，则失败</td>
<td>SUSv4</td>
</tr>
<tr>
<td><code>O_EXCL</code></td>
<td>与<code>O_CREAT</code>一起使用时会显式地创建文件</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_LARGEFILE</code></td>
<td>用于在32位系统中打开大文件</td>
<td></td>
</tr>
<tr>
<td><code>O_NOATIME</code></td>
<td>调用<code>read()</code>时不更新文件的最后访问时间 (Linux
2.6.8及以上版本)</td>
<td></td>
</tr>
<tr>
<td><code>O_NOCTTY</code></td>
<td>不会将<code>pathname</code>解释为终端</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_NOFOLLOW</code></td>
<td>不会对符号链接进行解引用</td>
<td>SUSv4</td>
</tr>
<tr>
<td><code>O_TRUNC</code></td>
<td>将现有文件截断为0字节</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_APPEND</code></td>
<td>总是在文件结尾写入数据</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_ASYNC</code></td>
<td>当I/O可能时，生成信号</td>
<td></td>
</tr>
<tr>
<td><code>O_DSYNC</code></td>
<td>提供同步的I/O数据完整性</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_NONBLOCK</code></td>
<td>以非阻塞模式打开</td>
<td>SUSv3</td>
</tr>
<tr>
<td><code>O_SYNC</code></td>
<td>使文件写入同步</td>
<td>SUSv3</td>
</tr>
</tbody>
</table>
<p>　　这是参数<code>flags</code>支持的所有标志常量。这些标志常量可以分为3类：<span
style="background-color: yellow">文件访问模式标志</span>、<span
style="background-color: yellow">文件创建标志</span>和<span
style="background-color: yellow">打开文件状态标志</span> (也称为<span
style="background-color: yellow">文件状态标志</span>)。</p>
<p>　　●
文件访问模式标志是表中的第1~3行。这些标志可以通过系统调用<code>fcntl()</code>的操作<code>F_GETFL</code>来检索。</p>
<p>　　●
文件创建标志是表中的第4~13行，控制着<code>open()</code>的行为以及后续的I/O操作。这些标志无法检索或修改。</p>
<p>　　●
打开文件状态标志是第14~18行。这些标志可以通过<code>fcntl()</code>的操作<code>F_GETFL</code>和<code>F_SETFL</code>来检索和修改。</p>
<p>　　这18个标志常量的详细信息如下：</p>
<p>　　● <code>O_APPEND</code>表示写入的数据总是在文件结尾。</p>
<p>　　●
<code>O_ASYNC</code>表示可以对<code>open()</code>返回的文件描述符进行I/O时，生成信号，这个特性称为<strong>信号驱动I/O</strong>。该特性仅适用于特定的文件类型，例如，终端、有名管道和套接字。SUSv3并未说明该标志，但大多数UNIX实现都提供了该标志或等效标志<code>FASYNC</code>。对于Linux，在调用<code>open()</code>时指定<code>O_ASYNC</code>无效。为了启用信号驱动I/O，必须通过<code>fcntl()</code>的操作<code>F_SETFL</code>来设置该标志
(部分UNIX实现也是如此)。</p>
<p>　　● <code>O_CLOEXEC</code>表示启用新文件描述符的close-on-exec标志
(<code>FD_CLOEXEC</code>)。相比通过<code>fcntl()</code>的操作<code>F_GETFL</code>来启用该标志，通过<code>open()</code>启用该标志可以避免多线程程序中的竞争条件。</p>
<p>　　●
<code>O_CREAT</code>表示若文件不存在，则创建新的空文件。若指定了该标志，则必须设置参数<code>mode</code>；否则，新文件的访问权限会被设置为随机权限。</p>
<p>　　●
<code>O_DIRECT</code>表示允许文件I/O绕过缓冲区。若需要使用该标志，则需要定义特性测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p>
<p>　　●
<code>O_DIRECTORY</code>表示当参数<code>pathname</code>不是目录时，<code>open()</code>会失败，并将<code>errno</code>设置为<code>ELOOP</code>。该标志是专为实现<code>opendir()</code>而设计的扩展。若需要使用该标志，则需要定义特性测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p>
<p>　　●
<code>O_DSYNC</code>表示根据同步I/O数据完整性的完成条件来写文件。</p>
<p>　　●
<code>O_EXCL</code>与<code>O_CREAT</code>一起使用时，表示若文件已存在，则不会打开文件。同时，<code>open()</code>会失败，并将<code>errno</code>设置<code>EEXIST</code>。换句话说，该标志会保证调用进程是创建文件的进程。文件存在的检测和创建会自动执行。SUSv3要求，当<code>O_EXCL</code>与<code>O_CREAT</code>一起出现在<code>flags</code>中时，若参数<code>pathname</code>是符号链接，则<code>open()</code>会失败，并将<code>errno</code>设置<code>EEXIST</code>。这样是为了让特权应用程序可以在已知位置创建文件，而不会出现符号链接导致在不同位置
(例如，系统目录) 创建文件的可能性。</p>
<p>　　●
<code>O_LARGEFILE</code>表示支持打开大文件，主要用于32位系统。SUSv3并未说明该标志，但在数个UNIX实现中都可以找到该标志。对于Alpha和IA-64等64位Linux实现，该标志无效。</p>
<p>　　●
<code>O_NOATIME</code>表示读文件时不更新文件的最后访问时间，该标志是非标准Linux扩展。若需要使用该标志，则调用进程必须是特权进程
(能力<code>CAP_FOWNER</code>)
或其有效用户ID匹配文件的所有者；否则，<code>open()</code>会出错
(<code>EPERM</code>)。在实际中，当非特权进程使用该标志时，需要与文件的所有者匹配的是进程的文件系统用户ID。该标志旨在供索引和备份系统使用。该标志能显著减少磁盘活动，因为无需重复进行磁盘查找来读文件内容和更新文件的i-node中的最后访问时间。可以使用<code>mount()</code>的标志<code>MS_NOATIME</code>和<code>FS_NOATIME_FL</code>来达到类似的功能。若需要使用该标志，则需要定义特性测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p>
<p>　　●
<code>O_NOCTTY</code>表示打开的终端设备不会成为控制终端。若打开的文件不是终端，则该标志无效。</p>
<p>　　●
<code>O_NOFOLLOW</code>表示当<code>pathname</code>是符号链接时，<code>open()</code>会失败，并将<code>errno</code>设置为<code>ELOOP</code>。若需要使用该标志，则需要定义特性测试宏<code>_GNU_SOURCE</code>，该标志的定义会出现在头文件<code>fcntl.h</code>中。</p>
<p>　　● <code>O_NONBLOCK</code>表示以非阻塞模式打开文件。</p>
<p>　　● <code>O_SYNC</code>表示打开同步I/O的文件。</p>
<p>　　●
<code>O_TRUNC</code>表示若文件已存在并且是常规文件，则将其截断为长度0来破坏文件内容。对于Linux，无论文件以只读或只写模式打开，都可以截断
(需要写权限)。SUSv3并没有说明<code>O_RDONLY</code>和<code>O_TRUNC</code>的组合，但大多数UNIX实现都有类似于Linux的行为。</p>
<p>　　从内核2.6.22开始，可以读目录<code>/proc/PID/fdinfo</code>下的特定于Linux的文件来获取系统中的所有进程的文件描述符的信息。对于进程的每个打开的文件描述符，该目录下都有1个对应的文件。该文件的字段<code>pos</code>表示当前文件偏移量，字段<code>flags</code>
(八进制数) 表示文件访问模式标志和打开文件状态标志。</p>
<h4 id="来自open的错误">4.1.2 来自<code>open()</code>的错误</h4>
<p>　　当打开文件出错时，<code>open()</code>会返回-1并将<code>errno</code>设置为对应的值：</p>
<p>　　●
<code>EACCES</code>表示文件权限不允许调用进程以<code>flags</code>指定的模式打开文件。此外，由于目录权限，文件可能无法访问，或文件不存在并且无法被创建。</p>
<p>　　●
<code>EISDIR</code>表示调用进程试图以只写模式打开类型为目录的文件。</p>
<p>　　●
<code>EMFILE</code>表示进程的打开的文件描述符数的资源限制达到上限
(<code>RLIMIT_NOFILE</code>)。</p>
<p>　　●
<code>ENFILE</code>表示系统的打开的文件描述符数的资源限制达到上限。</p>
<p>　　●
<code>ENOENT</code>表示出现2种情况之一。第1种情况是指定的文件不存在，但<code>flags</code>未指定<code>O_CREAT</code>。第2种情况是<code>flags</code>指定了<code>O_CREAT</code>，但<code>pathname</code>是死链接或其中的某个目录不存在。</p>
<p>　　●
<code>EROFS</code>表示指定的文件位于只读文件系统，并且试图写该文件。</p>
<p>　　●
<code>ETXTBSY</code>表示指定的文件是正在运行的可执行文件，对此类文件的修改是禁止的。</p>
<h4 id="creat">4.1.3 <code>creat()</code></h4>
<p>　　在早期UNIX实现中，<code>open()</code>仅有2个参数，并且不能用于创建文件。相反，系统调用<code>creat()</code>用于创建并打开新文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 成功时返回文件描述符，失败时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>creat()</code>会创建并打开参数<code>pathname</code>指定的文件，若文件已存在，则将其截断为长度0。该系统调用会返回文件描述符。调用<code>creat()</code>等同于以以下方式调用<code>open()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure>
<p>　　因为<code>open()</code>的参数<code>flags</code>提供了对文件打开方式的更多控制，所以<code>creat()</code>现已过时。</p>
<h3 id="读写文件">4.2 读写文件</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buffer, <span class="type">size_t</span> count)</span>; <span class="comment">/* 成功时返回读取的字节数，遇到EOF时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buffer, <span class="type">size_t</span> count)</span>; <span class="comment">/* 成功时返回写入的字节数，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>read()</code>会从参数<code>fd</code>引用的打开的文件中读数据。参数<code>count</code>表示读取的字节数。参数<code>buffer</code>表示用于存储读取的数据的内存缓冲区
(长度至少是<code>count</code>字节) 的地址，因为<span
style="background-color: yellow">系统调用不会为用于存储返回信息的缓冲区分配内存</span>。若<code>read()</code>成功，则返回实际读取的字节数；若遇到EOF，则返回0；若出错，则返回-1。</p>
<p>　　系统调用<code>write()</code>会向参数<code>fd</code>引用的打开的文件中写数据，其参数与<code>read()</code>相似。参数<code>buffer</code>表示待写入数据的地址。参数<code>count</code>表示写入的字节数。若<code>write()</code>成功，则返回实际写入的字节数；若出错，则返回-1。</p>
<p>　　对于每个打开的文件，内核都记录了<strong>文件偏移量</strong>
(也称为<strong>读写偏移</strong>或<strong>读写指针</strong>)，即下次<code>read()</code>或<code>write()</code>开始的位置。它是相对于文件开头的序号字节位。文件的第1个字节的偏移量是0。当打开文件时，文件偏移量会设置为0。文件偏移量会在调用<code>read()</code>或<code>write()</code>后自动调整。因此，连续调用<code>read()</code>和<code>write()</code>会按序进行。</p>
<p>　　<code>read()</code>实际读取的字节数可能会少于要求的字节数。对于常规文件，这可能是因为文件偏移量靠近EOF。对于无名管道、有名管道、套接字和终端等其他类型的文件，可能导致该情况的因素较多
(例如，当<code>read()</code>读取终端时，默认遇到换行符<code>\n</code>就结束读取)。同样，<code>write()</code>实际写入的字节数也可能会少于要求的字节数。对于磁盘文件，这可能是因为磁盘已满或进程的文件大小的资源限制达到上限
(<code>RLIMIT_FSIZE</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_READ 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[MAX_READ + <span class="number">1</span>];</span><br><span class="line"><span class="type">ssize_t</span> numRead;</span><br><span class="line"></span><br><span class="line">numRead = read(STDIN_FILENO, buffer, MAX_READ);</span><br><span class="line"><span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buffer[numRead] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The input data was: %s\n&quot;</span>, buffer);</span><br></pre></td></tr></table></figure>
<p>　　当通过<code>read()</code>读字符串时，<span
style="background-color: yellow">不会</span>将字符串结束符<code>\0</code>读取到缓冲区。若需要打印缓冲区中的字符串，则需要加上结束符。</p>
<p>　　当对磁盘文件执行I/O时，<code>write()</code>的非-1返回值并不保证数据已经传输到磁盘，因为内核会缓存磁盘I/O来减少磁盘活动和加快<code>write()</code>调用。</p>
<h3 id="关闭文件">4.3 关闭文件</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>close()</code>会关闭参数<code>fd</code>引用的打开的文件。当进程终止时，它的所有打开的文件描述符都会自动关闭。</p>
<p>　　通常，最好显式关闭不再使用的文件描述符，这会提高代码在后续修改时的可读性和健壮性。此外，文件描述符是有限资源，所以未关闭的文件描述符可能会导致进程耗尽描述符。对于处理多文件的生命周期长的程序，这会导致严重的问题。</p>
<p>　　就像其他系统调用一样，对<code>close()</code>的调用应该用错误处理代码包围起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (close(fd) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这种错误处理代码会捕捉关闭未打开的文件描述符和重复关闭同一描述符等错误，并且也能用于捕获特定文件系统在执行关闭操作时可能诊断的错误情况。NFS提供了特定于文件系统的错误的示例，若NFS提交失败
(数据无法到达远程磁盘)，则将该错误作为调用<code>close()</code>失败反馈给应用程序。</p>
<h3 id="修改文件偏移量">4.4 修改文件偏移量</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>; <span class="comment">/* 成功时返回新文件偏移量，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>lseek()</code>会根据参数<code>offset</code>和<code>whence</code>调整参数<code>fd</code>引用的打开的文件的文件偏移量。参数<code>offset</code>是以字节为单位的值。参数<code>whence</code>是参数<code>offset</code>的基点，其值如下：</p>
<p>　　●
<code>SEEK_SET</code>表示文件偏移量设置为距文件开头<code>offset</code>个字节处的位置。</p>
<p>　　●
<code>SEEK_CUR</code>表示文件偏移量设置为距当前文件偏移量<code>offset</code>个字节处的位置。</p>
<p>　　●
<code>SEEK_END</code>表示文件偏移量设置为距文件最后1个字节的后1个字节<code>offset</code>个字节处的位置。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_04/interpreting_the_whence_argument_of_lseek.svg" class="">
<p>　　若<code>lseek()</code>成功，则返回新文件偏移量。</p>
<p>　　当参数<code>whence</code>是<code>SEEK_CUR</code>或<code>SEEK_END</code>时，参数<code>offset</code>可以是正值或负值；当参数<code>whence</code>是<code>SEEK_SET</code>时，参数<code>offset</code>只能是非负值。</p>
<p>　　在早期UNIX实现中，使用的是整数0~2，而非<code>SEEK_SET</code>、<code>SEEK_CUR</code>和<code>SEEK_END</code>。在旧版本的BSD中，使用的是<code>L_SET</code>、<code>L_INCR</code>和<code>L_XTND</code>。</p>
<p>　　某些UNIX实现 (不包括Linux)
中有非标准函数<code>tell(fd)</code>，其功能与<code>lseek()</code>相同。</p>
<p>　　以下是<code>lseek()</code>的用法示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);     <span class="comment">/* 文件开头处 */</span></span><br><span class="line">lseek(fd, <span class="number">0</span>, SEEK_END);     <span class="comment">/* 当前文件结尾的后1个字节处 */</span></span><br><span class="line">lseek(fd, <span class="number">-1</span>, SEEK_END);    <span class="comment">/* 当前文件结尾处 */</span></span><br><span class="line">lseek(fd, <span class="number">-10</span>, SEEK_CUR);   <span class="comment">/* 当前文件偏移量的前10个字节处 */</span></span><br><span class="line">lseek(fd, <span class="number">10000</span>, SEEK_END); <span class="comment">/* 当前文件结尾后的第10001个字节处 */</span></span><br></pre></td></tr></table></figure>
<p>　　<code>lseek()</code>仅仅会修改文件描述符关联的内核文件记录，不涉及物理设备访问。<code>lseek()</code>不适用于所有类型的文件，不能对无名管道、有名管道、套接字和终端使用。若必要时，可以对设备使用<code>lseek()</code>
(例如，查询磁盘或磁带上的特定位置)。</p>
<p>　　<code>lseek()</code>名称中的<code>l</code>源于事实：参数<code>offset</code>和返回值的类型本质上是<code>long</code>。早期UNIX实现提供了系统调用<code>seek()</code>，并将这些值定义为<code>int</code>。</p>
<h4 id="文件空洞">4.4.1 文件空洞</h4>
<p>　　文件结尾和新写入的字节之间的空间称为<strong>文件空洞</strong>。从编程角度，空洞里的字节是存在的，读空洞会返回只包含空字节
(即0) 的缓冲区。</p>
<p>　　文件空洞占用的磁盘空间很少。大多数文件系统的文件空间以块为单位分配。块的大小取决于文件系统，通常是1024字节的整数倍。若空洞的边界在块中
(而非在块的边界)，则会分配整个块来存储数据
(空洞对应的部分用0填充)。除了这种情况之外，文件系统不会为空洞分配磁盘空间，直到向空洞写入数据。文件空洞可以节省磁盘空间，尤其是那些稀疏填充的文件。核心转储文件就是包含大量空洞的常见示例。</p>
<p>　　大多数原生UNIX文件系统都支持文件空洞，但很多非原生的文件系统
(例如，Microsoft的VFAT) 不支持文件空洞。</p>
<p>　　文件空洞的存在表示文件的常规大小可能大于实际占用的磁盘空间。<span
style="background-color: yellow">在文件空洞的中间写数据会减少可用磁盘空间</span>
(尽管文件大小并没有增加)，因为内核会分配块来填充空洞。</p>
<p>　　SUSv3详细说明了函数<code>posix_fallocate(fd, offset, len)</code>，该函数会在磁盘上由<code>offset</code>和<code>len</code>指定的字节范围内为<code>fd</code>引用的磁盘文件分配空间。这可用于确保应用程序在随后对文件调用<code>write()</code>时不会因磁盘空间耗尽
(向文件中的空洞写数据或者其他应用程序使用了磁盘空间)
而失败。从历史角度，glibc通过向指定范围内的所有块写入1个字节0来实现该函数。从版本2.6.23开始，Linux提供了系统调用<code>fallocate()</code>，该系统调用提供了更高效的方式来保证必要的空间会被分配，并且glibc的<code>posix_fallocate()</code>实现在会在该系统调用可用时使用它。</p>
<p>　　系统调用<code>stat()</code>可用于获取当前文件的大小和实际分配给该文件的块的数量。</p>
<h4 id="示例程序">4.4.2 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* seek_io.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">off_t</span> offset;</span><br><span class="line">    <span class="type">int</span> fd, ap, j;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">ssize_t</span> numRead, numWritten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s file &#123;r&lt;length&gt;|R&lt;length&gt;|w&lt;string&gt;|s&lt;offset&gt;&#125;...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR | O_CREAT,</span><br><span class="line">              S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH); <span class="comment">/* rw-rw-rw- */</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ap = <span class="number">2</span>; ap &lt; argc; ap++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (argv[ap][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>: <span class="comment">/* 以文本显示当前偏移量 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: <span class="comment">/* 以十六进制显示当前偏移量 */</span></span><br><span class="line">            len = getLong(&amp;argv[ap][<span class="number">1</span>], GN_ANY_BASE, argv[ap]);</span><br><span class="line">            buf = <span class="built_in">malloc</span>(len);</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            numRead = read(fd, buf, len);</span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: end-of-file\n&quot;</span>, argv[ap]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: &quot;</span>, argv[ap]);</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numRead; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (argv[ap][<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>((<span class="type">unsigned</span> <span class="type">char</span>)buf[j]) ? buf[j] : <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)buf[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>: <span class="comment">/* 在当前偏移量处写入字符串 */</span></span><br><span class="line">            numWritten = write(fd, &amp;argv[ap][<span class="number">1</span>], <span class="built_in">strlen</span>(&amp;argv[ap][<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">if</span> (numWritten == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: wrote %ld bytes\n&quot;</span>, argv[ap], (<span class="type">long</span>)numWritten);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: <span class="comment">/* 修改文件偏移量 */</span></span><br><span class="line">            offset = getLong(&amp;argv[ap][<span class="number">1</span>], GN_ANY_BASE, argv[ap]);</span><br><span class="line">            <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: seek succeeded\n&quot;</span>, argv[ap]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cmdLineErr(<span class="string">&quot;Argument must start with [rRws]: %s\n&quot;</span>, argv[ap]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>lseek()</code>与<code>read()</code>和<code>write()</code>一起使用时的情况。该程序的第1个命令行参数是待打开文件的名称。其余参数指定对文件执行的I/O操作，这些I/O操作由1个字母和1个值组成
(没有进行分隔)：</p>
<p>　　●
<code>soffset</code>表示将文件偏移量设置为距文件开头的<code>offset</code>个字节处的位置。</p>
<p>　　●
<code>rlength</code>表示从当前文件偏移量处读<code>length</code>个字节，并以文本显示。</p>
<p>　　●
<code>Rlength</code>表示从当前文件偏移量处读<code>length</code>个字节，并以十六进制显示。</p>
<p>　　●
<code>wstr</code>表示向当文件偏移量写<code>str</code>指定的字符串。</p>
<p>　　以下shell命令展示了该程序的用法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> tfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./seek_io tfile s100000 wabc</span></span><br><span class="line">s100000: seek succeeded</span><br><span class="line">wabc: wrote 3 bytes</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l tfile</span></span><br><span class="line">-rw-r--r-- 1 mtk users 100003 Feb 10 10:35 tfile</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./seek_io tfile s10000 R5</span></span><br><span class="line">s10000: seek succeeded</span><br><span class="line">R5: 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>　　第1行的命令会创建文件<code>tfile</code>。第2行的命令会将文件偏移量设置为距文件开头100000个字节处的位置，并向该位置写入字符串<code>abc</code>。第5行的命令会显示文件的信息。第7行的命令会将文件偏移量设置为距文件开头10000个字节处的位置
(也就是空洞)，并且从该位置读5个字节。</p>
<h3 id="通用io模型之外的操作">4.5 通用I/O模型之外的操作</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, ... <span class="comment">/* argp */</span>)</span>; <span class="comment">/* 成功时返回request对应的值，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>ioctl()</code>可用于执行通用I/O模型外的文件和驱动操作。参数<code>fd</code>是文件或设备的打开的文件描述符，参数<code>request</code>指定在该描述符上执行的控制操作。特定于设备的头文件中定义了可通过参数<code>request</code>传递的常量。</p>
<p>　　由C省略号<code>...</code>表示的第3个参数
(这里用<code>argp</code>表示)
可以是任何类型。参数<code>request</code>的值使得<code>ioctl()</code>能够决定<code>argp</code>预期的类型。<code>argp</code>通常是指向整数或结构体的指针，有时也不会使用。</p>
<p>　　SUSv3只要求<code>ioctl()</code>用于控制STREAMS设备。STREAMS是System
V的特性，但主线Linux内核不支持该特性
(尽管可以通过附加组件实现)。SUSv3并没有说明本书中描述的<code>ioctl()</code>的其他操作。但是，从UNIX系统的早期版本开始，<code>ioctl()</code>就一直作为UNIX系统的一部分，因此，很多UNIX实现都提供了本书描述的<code>ioctl()</code>的部分操作。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第2章 基本概念</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_02/</url>
    <content><![CDATA[<p>　　术语<strong>操作系统</strong>通常有2种不同的含义：</p>
<p>　　● 操作系统是由管理计算机资源 (即CPU、RAM和设备)
的核心软件和所有随附的标准软件工具
(例如，命令行解释器、图形用户界面、文件工具和编辑器) 组成的软件包。</p>
<p>　　● 从更狭义的角度，操作系统是管理和分配计算机资源的核心软件。</p>
<p>　　术语<strong>内核</strong>通常是第2种含义的同义词，本书关注的正是此含义。</p>
<p>　　尽管在没有内核的计算机上运行是程序是可能的，但是内核的存在可以大幅度简化程序的开发和使用，并且可以增加程序员可用的功能和灵活度。内核通过提供管理计算机资源的软件层来实现这一点。</p>
<p>　　Linux内核程序通常位于路径名<code>/boot/vmlinuz</code>或相似路径名下。对于早期UNIX实现，内核程序名是<code>unix</code>。对于之后实现了虚拟内存的UNIX实现，内核程序改名为<code>vmunix</code>。对于Linux，内核程序名与系统名相似，但是用z替换了末尾的x，以表示内核是压缩的可执行文件。</p>
<p>　　现代处理器架构通常会允许CPU在2种模式下工作：<strong>用户模式</strong>和<strong>内核模式</strong>
(有时也称为<strong>超级用户模式</strong>)。硬件指令允许从当前模式切换到其他模式。相应地，虚拟内存的区域可以被标记为<strong>用户空间</strong>或<strong>内核空间</strong>的一部分。当运行在用户模式下时，CPU只能访问标记为用户空间的内存区域，若试图访问标记为内核空间的内存区域，则会导致硬件异常。当运行在内核模式下时，CPU能访问用户空间和内核空间的内存区域。</p>
<p>　　只有当CPU在内核模式下时，特定操作才能执行
(例如，执行<code>halt</code>指令、访问内存管理硬件和初始化I/O操作)。通过这种硬件设计来将操作系统置于内核空间，操作系统实现者能确保用户进程无法访问内核的指令和数据结构或者执行不利于系统运行的操作。</p>
<p>　　<strong>程序</strong>通常以2种形式存在。第1种形式是<span
style="background-color: yellow">源代码</span>，即由一系列C等编程语言编写的语句组成的人类可读的文本。源代码必须转换成计算机可以理解的<span
style="background-color: yellow">二进制机器语言指令</span>才能执行，也就是第2种形式。这2种形式通常被认为是等同的，因为编译和链接步骤能将源代码转换为语义相同的二进制机器代码。</p>
<p>　　<strong>过滤器</strong>指从标准输入中读输入并对其进行转换，然后将转换结果写到标准输出的程序
(例如，<code>cat</code>、<code>grep</code>、<code>tr</code>、<code>sort</code>、<code>wc</code>、<code>sed</code>和<code>awk</code>)。</p>
<span id="more"></span>
<p>　　C程序可以访问<strong>命令行参数</strong>，即执行程序时命令行中提供的参数。为了访问命令行参数，程序的主函数必须声明为<code>int main(int argc, char *argv[])</code>。参数<code>argc</code>表示命令行参数的数量。参数<code>argv</code>的第1个成员<code>argv[0]</code>是程序名，其他成员是各个命令行参数。</p>
<p>　　<strong>shell</strong>是专用程序，用于读用户输入的命令并执行合适的程序来响应，这种程序也称为<strong>命令解释程序</strong>。<span
style="background-color: yellow">登录shell</span>是用户第1次登录时为运行shell而创建的进程。</p>
<p>　　除了用于交互，shell还可以用于解释<span
style="background-color: yellow">shell脚本</span>
(即包含shell命令的文本文件)。出于该目的，shell会提供部分通常与编程语言相关的功能，包括变量、循环、条件语句、I/O命令和函数。</p>
<p>　　对于大多数Linux文件系统，文件名最长为255个字符。文件名可以包含除了斜杠<code>/</code>和空字符<code>\0</code>之外的所有字符。在实际中，文件名建议使用字母、数字、英文句号<code>.</code>、下划线<code>_</code>和连字符<code>-</code>的组合，由这65个字符组成的集合<code>[-._a-zA-Z0-9]</code>在SUSv3中被称为<strong>可移植文件名字符集</strong>。</p>
<p>　　应该避免在文件名中使用除了可移植文件名字符集之外的字符，因为这些字符在shell、正则表达式或其他上下文中可能有特殊含义。若需要在这些上下文中的文件名使用包含特殊含义的字符，则必须对这些字符进行<strong>转义</strong>，即在每个待转义的字符前面都加上反斜杠<code>\</code>来表示它们不需要解释为特殊含义。在不支持转义的上下文中，包含特殊含义的字符的文件名将不可用。此外，应该避免文件名以连字符<code>-</code>开头，因为这种文件名可能会被shell命令解释为参数。</p>
<p>　　为了执行文件I/O，C程序通常会调用标准库stdio中的部分函数，包括<code>fopen()</code>、<code>fclose()</code>、<code>printf()</code>、<code>scanf()</code>、<code>fputs()</code>、<code>fgets()</code>。库stdio中的函数是<code>open()</code>、<code>close()</code>、<code>read()</code>、<code>write()</code>等I/O系统调用的包装函数。</p>
<p>　　<strong>进程</strong>是运行中的程序的1个实例。当执行程序时，内核会将程序的代码加载到虚拟内存，为程序变量分配空间并设置内核记录数据结构来记录该进程的各种信息
(例如，进程ID、终止状态、用户ID和组ID)。从内核角度，进程是内核必须与之共享各种计算机资源的实体。对于内存等有限资源，内核会先分配部分资源给进程，然后在进程的生命周期中根据进程的请求和整个系统对该资源的需求来调节资源分配。当进程终止时，为该进程分配的所有有限的资源会释放。对于CPU和网络带宽等可再生资源，所有进程必须平等地共享它们。</p>
<p>　　运行中的Linux系统包含大量进程，其中的很多进程都独立于彼此运行。但是，有些进程需要合作才能达到目的，为此，需要保证<strong>进程间通信</strong>
(IPC) 和同步操作。</p>
<p>　　从逻辑角度，进程分为4个称为<strong>段</strong>的部分：</p>
<p>　　● <span
style="background-color: yellow">文本</span>段包含程序的指令。</p>
<p>　　● <span
style="background-color: yellow">数据</span>段包含程序所用的静态变量。</p>
<p>　　● <span
style="background-color: yellow">栈</span>段是会随着函数调用和返回而伸缩的区域，用于为局部变量和函数调用链信息分配空间。</p>
<p>　　● <span
style="background-color: yellow">堆</span>段是用于程序动态分配额外空间的区域。</p>
<p>　　进程中有2种重要的时间：<span
style="background-color: yellow">实际时间</span>和<span
style="background-color: yellow">进程时间</span>。</p>
<p>　　● 实际时间基于某个标准点 (日历时间) 或固定点
(通常是进程生命周期的起点)
测量。在UNIX系统中，日历时间以秒为单位，自1970年1月1日凌晨开始计时
(即UTC)，并且以英国格林威治的经线定义的时区为基准进行协调。这个日期接近UNIX系统的诞生，也称为<strong>纪元</strong>。</p>
<p>　　● 进程时间也称为<span
style="background-color: yellow">CPU时间</span>，是自进程启动以来所有的CPU时间总和。CPU时间可以进一步划分为<span
style="background-color: yellow">系统CPU时间</span>和<span
style="background-color: yellow">用户CPU时间</span>，前者是在内核模式下执行代码所用的时间
(系统调用和其他代表进程执行的内核服务)，后者是在用户模式下执行代码所用的时间
(常规程序代码)。</p>
<p>　　命令<code>time</code>会显示执行管道中的进程所用的实际时间、系统CPU时间和用户CPU时间。</p>
<p>　　在现代UNIX实现中，每个进程可以有多个执行<strong>线程</strong>，线程可以类比为多个共享虚拟内存和大量其他属性的进程。每个线程都会执行相同的程序代码、数据和堆。但是，每个线程都有自己的栈，用于存储局部变量和函数调用链信息。线程可以通过共享的全局变量通信。线程API提供了<strong>互斥锁</strong>和<strong>条件变量</strong>，用于同一进程的线程的通信和同步操作。线程还能通过IPC和同步机制通信。</p>
<p>　　线程的主要优势是易于共享数据，并且某些算法更容易用多线程实现。此外，多线程程序可以透明地利用多处理器硬件上的并行处理的可能性。</p>
<p>　　<strong>伪终端</strong>是1对连接的虚拟设备：<span
style="background-color: yellow">主设备</span>和<span
style="background-color: yellow">从设备</span>。这对设备提供了IPC通道，以允许双向传输数据。</p>
<p>　　伪终端的关键点在于从设备提供了行为与终端相似的接口，这使得可以将从设备连接到面向终端的程序，然后用另一个连接到主设备的程序来驱动面向终端的程序。驱动程序的输出通过终端驱动程序执行的常规输入处理
(例如，在默认模式下，回车符会映射为换行符)，然后作为输入传递给连接到从设备的面向终端的程序。面向终端的程序写到从设备的所有内容都会
(在经过所有终端输出处理后)
作为输入传递给驱动程序，即驱动程序会执行用户在常规终端上通常执行的功能。</p>
<p>　　伪终端用于各种应用程序，其中最著名的是X
Window系统登录时提供的终端窗口的实现以及<code>telnet</code>和<code>ssh</code>等提供网络登录服务的程序。</p>
<p>　　<span
style="background-color: yellow">实时应用程序</span>是需要及时响应输入的应用程序。通常，这些输入来自于外部传感器或专用设备，而输出则采用控制某些外部硬件的形式。尽管很多实时应用程序需要对输入做出快速响应，但决定性因素是保证触发事件后的特定时间内做出响应。</p>
<p>　　实时响应 (尤其是短时间内)
需要底层操作系统的支持。大多数操作系统没有实时响应的原生支持，因为实时响应的要求于与多用户分时操作系统的要求相冲突。传统UNIX实现并不是实时操作系统，尽管实时变体已经出现。Linux的实时变体也已经出现，而且Linux内核也在向完全支持实时应用程序的方向发展。</p>
<p>　　POSIX.1b定义了大量支持实时应用程序的POSIX.1扩展，包括异步I/O、共享内存、内存映射文件、内存上锁、实时锁、实时定时器、备选调度策略、实时信号、信息队列和信号量。尽管它们并不严格地符号实时，但是大部分UNIX实现都支持部分或全部扩展。</p>
<p>　　类似于有些UNIX实现，Linux提供了<code>/proc</code>文件系统，它由挂载在目录<code>/proc</code>的1组目录和文件组成。该文件系统属于<span
style="background-color: yellow">虚拟文件系统</span>
(VFS)，以文件系统中的文件和目录的形式提供内核数据结构的接口。这为查看和修改各种系统属性提供了1种简单的机制。此外，有1组名称为<code>/proc/PID</code>的目录
(PID即进程ID)，允许查看系统中正在运行的所有进程的信息。</p>
<p>　　<code>/proc</code>文件的内容通常是人类可读的文本形式，并且能被shell脚本解析。程序可以简单地对<code>/proc</code>文件进行打开、读和写操作。在大多数情况下，进程需要拥有权限才能修改<code>/proc</code>目录下的文件的内容。</p>
<h3 id="内核">2.1 内核</h3>
<p>　　内核负责<span
style="background-color: yellow">进程调度</span>、<span
style="background-color: yellow">内存管理</span>、<span
style="background-color: yellow">提供文件系统</span>、<span
style="background-color: yellow">创建和终止进程</span>、<span
style="background-color: yellow">访问设备</span>、<span
style="background-color: yellow">网络</span>和<span
style="background-color: yellow">提供系统调用API</span>。</p>
<p>　　● 计算机有1个或多个用于执行程序指令的中央处理单元
(CPU)。与其他UNIX系统一样，Linux是<strong>抢占式多任务</strong>操作系统。多任务表示多个进程可以同时驻留于内存中，并且都可以使用CPU。抢占式表示内核进程调度程序决定哪些进程使用CPU以及使用时间。</p>
<p>　　●
虽然以10年前的标准，计算机内存是巨大的，但是软件的大小也相应地变大，所以物理内存仍然是内核必须以公平且有效的方式进行共享的有限资源。与大多数现代操作系统一样，Linux使用了虚拟内存。虚拟内存主要有2个优点。首先，进程间以及进程与内核间是隔离的，所以进程无法读取或修改其他进程或内核的虚拟内存。其次，只有进程的一部分需要常驻在内存中，这降低了进程的内存占用
(允许更多进程同时驻留在内存中)，进而提高了CPU利用率。</p>
<p>　　●
内核在磁盘上提供了文件系统，允许对文件进行创建、检索、更新和删除等操作。</p>
<p>　　●
内核可以将新程序加载到内存并提供该程序运行所需的资源。一旦进程运行完成，内核必须确保该进程使用的资源得到释放，以供其他程序使用。</p>
<p>　　● 连接到计算机的设备
(例如，鼠标、键盘、显示器、磁盘和磁带驱动程序)
允许计算机与外界进行信息通信以及输入或/和输出。内核为计算机提供了1个接口，该接口标准化和简化了设备的访问，同时也会协调多个进程对同一设备的访问。</p>
<p>　　●
内核会代表用户进程发送和接收网络分组，该过程包括将网络分组路由到目标系统。</p>
<p>　　●
进程通过称为<strong>系统调用</strong>的内核入口点来请求内核执行某些任务。</p>
<p>　　除了以上特性，Linux等多用户操作系统通常会为用户提供<strong>虚拟私有计算机</strong>的抽象，即每个用户都能登录系统，并且使用时很大程度上独立于其他用户。例如，每个用户都用自己的磁盘存储空间
(即<span
style="background-color: yellow">主目录</span>)。此外，用户能执行多个程序，这些程序会共享CPU，每个程序会在自己的虚拟地址空间中执行操作，并且这些程序能独立访问设备和通过网络传输信息。内核会解决访问硬件资源时潜在的冲突，所以用户和进程通常不知道这些冲突。</p>
<p>　　运行中的系统通常会有大量进程。对于单个进程，很多事情异步发生。运行中的进程不知道它何时被挂起以及之后运行的进程，或者它运行完成后接着运行的进程。信号的传递和IPC事件的发生由内核协调，对进程而言，这可能随时发生。很多事情对进程是不可见的。进程并不知道它在RAM中的位置，或者其内存空间的特定部分是在内存中还是在交换空间
(用于补充RAM的磁盘空间保留区域)
中。同样，进程也不知道它访问的文件所处的磁盘驱动位置，进程仅通过文件名来访问文件。进程是独立运行的，进程间无法直接通信。进程无法创建新进程或终止自己。最后，进程无法直接与连接到电脑的I/O设备通信。</p>
<p>　　相比之下，运行中的系统仅有1个内核，内核知道并控制所有事情。内核推动着系统中所有进程的运行。内核决定进程调度以及维护包含所有运行中的进程的信息的数据结构和可以将文件名转换为磁盘上的物理位置的底层数据结构。此外，内核还维护将每个进程的虚拟内存转换为物理内存和交换空间的数据结构。进程间的所有通信通过内核提供的机制完成。为了响应进程的请求，内核会创建新进程和终止现有进程。最后，内核
(尤其是设备驱动程序)
执行所有与I/O设备的通信，根据用户进程的请求传输信息。</p>
<h3 id="shell">2.2 shell</h3>
<p>　　尽管在某些操作系统中，命令解释程序是内核的组成部分，而在UNIX系统中，shell是用户进程。存在多个不同的shell，并且同一计算机上的不同用户可以同时使用不同的shell。随着时间的推移，出现了几个重要的shell：</p>
<p>　　● <span style="background-color: yellow">Bourne shell</span>
(即<code>sh</code>) 是最古老的广泛使用的shell，由Steve
Bourne开发。<code>sh</code>是第7版UNIX的标准shell。<code>sh</code>中包含在很多所有shell中都熟悉的特性，包括I/O重定向、管道、文件名生成
(通配符)、变量、环境变量控制、命令替换、后台命令执行和函数。所有后续的UNIX实现除了包含它们可能提供的任何其他shell，还包含<code>sh</code>。</p>
<p>　　● <span style="background-color: yellow">C shell</span>
(即<code>csh</code>) 由加州大学伯克利分校的Bill
Joy开发，其名称源于该shell的很多流控制结构与C中对应的流控制结构相似。<code>csh</code>提供了几个<code>sh</code>所没有的有用的交互特性，包含命令历史、命令行编辑、作业控制和别名。<code>csh</code>与<code>sh</code>不向后兼容。尽管BSD中的标准交互式shell是<code>csh</code>，但是shell脚本通常是为<code>sh</code>编写，以保证可移植到任何UNIX实现。</p>
<p>　　● <span style="background-color: yellow">Korn shell</span>
(即<code>ksh</code>) 由AT&amp;T贝尔实验室的David
Korn开发，作为<code>sh</code>的后继者。除了保证与<code>sh</code>的兼容，<code>ksh</code>还包含与<code>csh</code>类似的交互特性。</p>
<p>　　● <span style="background-color: yellow">Bourne again
shell</span> (即<code>bash</code>)
是GNU项目对<code>sh</code>的重实现，它提供了<code>ksh</code>和<code>csh</code>中类似的交互特性。<code>bash</code>的主要开发者是Brain
Fox和Chet Ramey。<code>bash</code>可能是Linux中最广泛使用的shell
(在Linux中，<code>sh</code>实际是通过<code>bash</code>模拟)。</p>
<p>　　POSIX.2-1992详细说明了shell标准，该标准基于<code>ksh</code>当时的版本。如今，<code>ksh</code>和<code>bash</code>都通过了POSIX认证，两者都提供了很多对标准的扩展，其中的很多扩展存在差异。</p>
<h3 id="用户和组">2.3 用户和组</h3>
<p>　　每个用户都有唯一的<span
style="background-color: yellow">登录名</span> (即用户名)
和对应的数字<span style="background-color: yellow">用户ID</span>
(即UID)。每个用户的用户名和UID都由系统<span
style="background-color: yellow">密码文件</span><code>/etc/passwd</code>中的某行定义，该行包括组ID
(即GID)
字段、主目录字段和登录shell字段。GID字段是用户所属的第1个组的数字GID。主目录字段是用户登录后所在的初始目录。登录shell字段是为解释用户命令而执行的程序的名称。</p>
<p>　　密码文件可能会包含加密后的用户密码。出于安全原因，密码通常存储在单独的<span
style="background-color: yellow">影子密码文件</span>，只有特权用户才能读。</p>
<p>　　出于管理目的
(特别是控制文件和其他系统资源的访问)，将用户组织成<span
style="background-color: yellow">组</span>很有用。在早期的UNIX实现中，1个用户只能属于1个组。BSD允许1个用户同时属于多个组，这个想法之后被其他UNIX实现和POSIX.1-1990吸收。</p>
<p>　　每个组都由系统<span
style="background-color: yellow">组文件</span><code>/etc/group</code>中的某行定义，该行包括组名称字段、GID字段和用户列表字段。组名称字段是组的唯一名称。GID字段是组ID。用户列表字段是以逗号分隔的组成员的用户名
(组成员的判断基于该字段，而非密码文件中的GID字段)。</p>
<p>　　唯一拥有特权的用户是<span
style="background-color: yellow">超级用户</span>。超级用户的UID是0，用户名通常是root。对于常规UNIX系统，超级用户会绕过系统中的所有权限检测。因此，超级用户可以无视文件的访问权限而直接访问任何文件，也可以给任何用户进程发送信号。</p>
<h3 id="单一目录层次结构目录链接和文件">2.4
单一目录层次结构、目录、链接和文件</h3>
<p>　　内核维护了单一目录层次结构来组织系统中的所有文件
(Windows等操作系统的每个磁盘设备都有自己的目录层次结构)。该层次结构的根基是<strong>根目录</strong>
(即<code>\</code>)。所有文件和目录都是根目录的后代。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_02/subset_of_the_linux_single_directory_hierarchy.svg" class="">
<p>　　在文件系统中，每个文件都有<strong>类型</strong>。表示原始数据文件的类型称为<strong>常规文件</strong>或<strong>纯文本文件</strong>，以区分其他文件类型。这些其他文件类型包括设备、管道、套接字、目录和符号链接。</p>
<p>　　<strong>目录</strong>是特殊文件，其内容形式是文件名表与对应文件的引用。这种
"文件名+指针"
的关联称为<strong>链接</strong>。1个文件可以有多个链接，所以也可以有多个文件名
(在不同或相同目录下)。</p>
<p>　　目录可以同时包含文件和其他目录。目录间的链接构成了如图所示的目录层次结构。</p>
<p>　　每个目录至少包括<code>.</code>和<code>..</code>这2个条目，前者表示到目录自己的链接，后者表示到父目录
(即目录层次结构中该目录的上一级目录)
的链接。除了根目录之外的所有目录都有父目录。对于根目录，条目<code>/..</code>等同于<code>/</code>。</p>
<p>　　类似于普通链接，<strong>符号链接</strong>提供文件的别名。普通链接是目录列表中的
"文件名+指针" 条目，而符号链接是特殊标记文件，包含另一个文件的名称
(符号链接也是目录列表中的 "文件名+指针"
条目，其中指针指向的文件包含另一个文件的名称)。符号链接中的 "另一个文件"
通常称为符号链接的<strong>目标</strong>，通常会说符号链接引用或指向目标文件。当系统调用使用路径名时，大多数情况下，内核会自动<strong>解引用</strong>路径名中的每个符号链接，用它指向的文件名来替换它。若符号链接的目标也是符号链接，则解引用会递归
(内核对解引用的次数施加了限制)。目标文件不存在的符号链接称为<strong>死链接</strong>。此外，普通链接也称为<strong>硬链接</strong>，符号链接也称为<strong>软连接</strong>。</p>
<p>　　<strong>路径名</strong>是以可选的斜杠<code>/</code>开头加上以斜杠分隔的一系列文件名组成的字符串。路径名中的除了最后1个文件名之外的所有文件名都会被识别为目录或指向目录的符号链接。路径名中的最后1个文件名可能会被识别为任何类型的文件
(包括目录)。最后1个斜杠前的所有文件名也称为路径名的<span
style="background-color: yellow">目录</span>部分，最后1个斜杠后的文件名也称为路径名的<span
style="background-color: yellow">文件</span>或<span
style="background-color: yellow">基础</span>部分。</p>
<p>　　路径名的读取顺序是从左到右，每个文件名位于路径名中的前一文件名指定的目录下。字符<code>..</code>可以在路径名中的任何位置使用，表示路径名当前指定位置的父目录。</p>
<p>　　每个进程都有<strong>当前工作目录</strong>，简称为<strong>工作目录</strong>或<strong>当前目录</strong>，即进程在单一目录层次结构中的位置。子进程会继承其父进程的工作目录。登录shell的初始当前工作目录是密码文件中对应的主目录字段。shell的工作目录可以用命令<code>cd</code>来修改。</p>
<p>　　可以用<strong>绝对路径名</strong>或<strong>相对路径名</strong>来描述文件在单一目录层次结构中的位置。</p>
<p>　　●
绝对路径名以表示根目录的斜杠<code>/</code>开头，例如，<code>/home/mtk/.bashrc</code>、<code>/usr/include</code>和<code>/</code>。</p>
<p>　　●
相对路径名表示文件相对于进程的当前工作目录的路径名。为了与绝对路径名区分，相对路径名不以斜杠<code>/</code>开头。对于目录<code>usr</code>，文件<code>types.h</code>的相对路径名是<code>include/sys/types.h</code>。对于目录<code>avr</code>，文件<code>.bashrc</code>的相对路径名是<code>../mtk/bashrc</code>。</p>
<p>　　每个文件都有1个关联的用户ID和1个关联的组ID，用户ID定义了该文件的所有者，组ID定义了该文件的所属组。文件的所有权用于决定用户对该文件的访问权限。</p>
<p>　　为了控制文件的访问，系统将用户分为3类。第1类用户是文件的所有者，第2类用户的组ID与文件所属组的组ID相同，第3类用户是其他用户。可以为3类用户分别设置3个权限位，读权限位允许读文件，写权限位允许写文件，执行权限位允许执行文件。目录也可以设置这些权限位，其含义略有不同，读权限位允许列出目录的内容
(例如，文件名)，写权限位允许修改目录的内容 (例如，修改文件名)，执行
(也称为搜索) 权限位允许访问目录下的文件 (受限于文件的访问权限)。</p>
<h3 id="文件io模型">2.5 文件I/O模型</h3>
<p>　　UNIX系统的I/O模型的显著特征之一就是I/O<strong>通用性</strong>的概念：<code>open()</code>、<code>read()</code>、<code>write()</code>和<code>close()</code>等系统调用可用于执行对所有类型的文件
(包括设备)
的I/O。内核会将应用程序的I/O请求转换为对目标文件或设备执行I/O的文件系统操作或事件驱动程序操作。</p>
<p>　　内核本质上提供了称为<span
style="background-color: yellow">字节流序列</span>的文件类型。对于磁盘文件、磁盘和磁带设备，可以通过系统调用<code>lseek()</code>来进行随机访问。</p>
<p>　　很多应用程序和库会将换行符 (ASCII字符的十进制的10)
解释为终止当前行并开始下一行。UNIX系统没有文件结束符，文件的结束通过不返回数据的读来检测。</p>
<p>　　<strong>I/O系统调用</strong>指用文件描述符 (较小的非负整数)
打开文件。文件描述符一般通过调用函数<code>open()</code>获取，该函通过路径名来指定执行I/O操作的文件。</p>
<p>　　通常，当进程被shell启动时，会继承3个已打开的文件描述符：描述符0~2。描述符0是标准输入，进程从该文件描述符读输入。描述符1是标准输出，进程向该文件描述符写输出。描述符2是标准错误，进程向该文件描述符写异常情况的错误信息和通知。对于交互式shell或程序，这3个描述符通常会连接到终端。在库stdio中，这3个描述符分别对应文件流<code>stdin</code>、<code>stdout</code>和<code>stderr</code>。</p>
<h3 id="进程">2.6 进程</h3>
<p>　　每个进程都有唯一的整数<strong>进程标识符</strong>
(即PID)。此外，每个进程还有<strong>父进程标识符</strong>
(即PPID)，表示请求内核创建该进程的进程。</p>
<p>　　进程可以通过系统调用<code>fork()</code>来创建新进程，前者称为<strong>父进程</strong>，后者称为<strong>子进程</strong>。内核通过创建父进程的副本来创建子进程。子进程会继承父进程的数据段、栈段和堆段，子进程之后可以独立地修改这些段。程序在内存中的文本段会被标记为只读，由这2个进程共享。</p>
<p>　　子进程要么执行与父进程相同的代码中的不同函数，要么调用系统调用<code>execve()</code>来加载和执行新程序。系统调用<code>execve()</code>会用基于新程序的代码的文本段、数据段、栈段和堆段来替换已存在的这4个段。</p>
<p>　　C标准库中有几个系统调用<code>execve()</code>的包装函数，这些函数大同小异，并且都以<code>exec</code>开头。之后的内容会将这些函数统称为函数<code>exec()</code>。</p>
<p>　　<strong>守护进程</strong>是特殊进程，其创建方式与普通进程相同，但具有以下特点：</p>
<p>　　●
守护进程的生命周期很长。守护进程通常在系统引导时就会启动，并且会持续到关机。</p>
<p>　　● 守护进程运行在后台，并且没有用于读输入或写输出的控制终端。</p>
<p>　　<code>syslogd</code>和<code>httpd</code>就是守护进程，前者记录系统日志中的信息，后者通过HTTP来提供网页。</p>
<p>　　每个进程都有1个<strong>环境列表</strong>，即<strong>环境变量</strong>的集合。环境变量维护在进程的用户空间内存中。环境变量包含1个名称和1个关联的值。子进程会继承父进程的环境列表，所以环境列表可用于父进程传递信息给子进程。当进程通过函数<code>exec()</code>替换当前正在运行的程序时，新程序要么继承旧程序的环境列表，要么接收作为<code>exec()</code>调用的一部分的新环境列表。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> MYVAR=<span class="string">&#x27;Hello world&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>　　对于大多数shell，环境变量通过命令<code>export</code>来创建。对于<code>csh</code>，环境变量通过命令<code>setenv</code>来创建。</p>
<p>　　C程序可以通过外部变量<code>char **environ</code>来访问环境变量，并且有大量库函数可以用于检索和修改其环境变量的值。</p>
<p>　　环境变量的用途很广。例如，shell定义和使用了大量可以通过脚本或由shell执行的程序访问的环境变量。其中包括环境变量<code>HOME</code>和<code>PATH</code>，前者指定了用户的登录目录的路径名，后者指定了shell在查找与用户输入的命令相对应的程序时应搜索的一系列目录。</p>
<p>　　进程可以以2种方法终止。第1种方法是调用系统调用<code>_exit()</code>及其包装函数来请求终止自己。第2种方法是收到信号而终止。进程终止时会生成<strong>终止状态</strong>
(较小的非负整数)，父进程可以调用系统调用<code>wait()</code>来查看子进程的终止状态。当调用系统调用<code>_exit()</code>及其包装函数时，进程会显式地指明自己的终止状态。当收到信号而终止时，进程的终止状态会根据该信号的类型来设置。</p>
<p>　　按照惯例，终止状态为0时表示进程正常终止，终止状态非0时表示出现错误。大部分shell可以通过shell变量<code>$?</code>来获取最后执行的程序的终止状态。</p>
<p>　　每个进程都有多个关联的用户ID和组ID，包括<span
style="background-color: yellow">实际用户ID</span>、<span
style="background-color: yellow">实际组ID</span>、<span
style="background-color: yellow">有效用户ID</span>、<span
style="background-color: yellow">有效组ID</span>和<span
style="background-color: yellow">辅助组ID</span>。</p>
<p>　　●
实际用户ID和实际组ID是进程所属的用户和组的ID。子进程会继承父进程的实际用户ID和实际组ID。登录shell的实际用户ID和实际组ID取自系统密码文件中对应的字段。</p>
<p>　　● 有效用户ID和有效组ID (与辅助组ID一起使用)
用于确定进程对文件和IPC对象等受保护资源的访问权限。进程的有效用户ID和有效组ID通常与其实际用户ID和实际组ID相同。可以通过修改有效用户ID和有效组ID来允许进程获取其他用户或组的特权。</p>
<p>　　●
辅助组ID可能有多个。辅助组ID是进程所属的附加组的ID。子进程会继承父进程的辅助组ID。登录shell的辅助组ID取自系统组文件。</p>
<p>　　依据传统，在UNIX系统中，有效用户ID为0 (超级用户)
的进程是<strong>特权进程</strong>，此类进程可以绕过内核通常使用的权限限制。相比之下，有效用户ID非0的进程是<strong>非特权进程</strong>，此类进程必须遵守内核的权限限制。特权进程创建的子进程也是特权进程。修改非特权进程的有效用户ID可以将其变为特权进程。</p>
<p>　　从内核2.2开始，Linux将传统上授予超级用户的特权划分为了多个不同的称为<strong>能力</strong>的单元。每个特权操作都与特定的能力关联，进程执行特权操作需要拥有对应的能力。传统的超级用户进程
(有效用户ID为0) 拥有全部能力。</p>
<p>　　在引导系统时，内核会创建特殊进程<code>init</code>，该进程源于文件<code>/sbin/init</code>。系统中的所有进程都是进程<code>init</code>的后代。进程<code>init</code>的进程ID是1，并且拥有超级用户特权。进程<code>init</code>无法被杀死
(超级用户也不能)，只会在关机时终止。进程<code>init</code>的主要任务是创建和监视系统运行所需的一系列进程。</p>
<p>　　通过系统调用<code>strlimit()</code>，进程可以设置其对各种资源的消耗上限。每个这样的<strong>资源限制</strong>都有2个关联的值——软限制和硬限制，前者限制进程可以消耗的资源，后者是前者可以调整的值的上限。非特权进程可以调整某个特定资源的软限制，其值必须在0到对应的硬限制之间
(小于硬限制)。当通过系统调用<code>fork()</code>创建子进程时，子进程会继承父进程的资源限制设置。</p>
<p>　　shell的资源限制可以通过命令<code>ulimit</code>
(<code>csh</code>中的命令<code>limit</code>)
来调整，shell创建的用于执行命令的子进程会继承这些资源限制设置。</p>
<h3 id="内存映射">2.7 内存映射</h3>
<p>　　系统调用<code>mmap()</code>会在调用进程的虚拟地址空间中创建1个新的<strong>内存映射</strong>。内存映射有2种类型——<strong>文件映射</strong>和<strong>匿名映射</strong>。</p>
<p>　　●
文件映射会将1个文件在磁盘上的区域映射到调用进程的虚拟内存。一旦映射，该文件的内容就可以通过对相应的内存区域中的字节的操作来访问。映射的页会按需自动从文件中加载。</p>
<p>　　● 匿名映射没有对应的文件。相反，映射的页会初始化为0。</p>
<p>　　某个进程的映射中的内存可能与其他进程的映射共享。当多个进程映射同一文件的同一区域或子进程继承了父进程的映射时，就会出现这种情况。</p>
<p>　　当多个进程共享同一页时，若映射是私有的，则进程对映射内容的修改对其他进程<span
style="background-color: yellow">不可见</span>，并且这些修改<span
style="background-color: yellow">不会</span>应用到对应的文件；若映射是共享的，则进程对映射内容的修改对其他进程<span
style="background-color: yellow">可见</span>，并且这些修改会应用到对应的文件。</p>
<p>　　内存映射用途广泛，包括通过可执行文件的文本段来初始化进程的文本段、分配新内存
(填充为0)、文件I/O (内存映射I/O) 和IPC (通过共享映射)。</p>
<h3 id="静态库和共享库">2.8 静态库和共享库</h3>
<p>　　<strong>目标库</strong>是包含一系列函数 (通常存在逻辑关联)
编译后的目标代码的文件。将一系列函数放在单个目标库可以简化程序的创建和维护。在现代UNIX系统中，目标库有2种类型——<strong>静态库</strong>
(也称为<strong>归档文件</strong>)
和<strong>共享库</strong>，但早期UNIX系统只有静态库。</p>
<p>　　静态库本质上是已编译的目标模块的结构化包。当需要使用静态库中的某个函数时，会在构建程序的链接命令中指明对应的静态库。在解析完主程序对静态库模块的函数的引用后，链接器会从静态库中提取所需模块的副本，并将这些副本复制到作为结果的可执行文件。这个过程称为<strong>静态链接</strong>。</p>
<p>　　静态链接有多个缺点。第1个缺点是不同的可执行文件可能都包含同一模块的副本，这会浪费磁盘空间。第2个缺点是多个包含同一模块的程序同时运行时，会产生内存浪费，因为每个程序都需要自己的模块副本驻留在内存中。第3个缺点是修改静态库中的函数后，需要重新编译并更新静态库，所有用到该函数的应用程序都需要再次进行静态链接。</p>
<p>　　共享库正是为了解决静态库的问题而设计。当程序链接了1个共享库后，链接器只会在可执行文件中写1条记录，以指示可执行文件在运行时所需的共享库。在可执行文件的运行过程中，当它加载到内存时，<strong>动态链接器</strong>会保证可执行文件所需的共享库会被找到并加载到内存中，然后执行运行时链接来将可执行文件中的函数调用解析为共享库中对应的声明。在运行时，只需要1份共享库的代码驻留在内存中，所有运行中的程序都能使用该副本。</p>
<p>　　共享库不像静态库那样需要每个程序都包含所需模块的副本，这节省了磁盘空间。此外，在修改共享库中的函数并更新共享库后，现有程序会在下次运行时会自动使用修改后的函数。</p>
<h3 id="ipc和同步">2.9 IPC和同步</h3>
<p>　　可以通过读写磁盘文件的信息来实现IPC。但是，对于很多应用程序，这种方法效率很低且不灵活。</p>
<p>　　就像所有现代UNIX实现一样，Linux提供了大量IPC机制，包括<span
style="background-color: yellow">信号</span>、<span
style="background-color: yellow">管道</span>、<span
style="background-color: yellow">套接字</span>、<span
style="background-color: yellow">文件上锁</span>、<span
style="background-color: yellow">消息队列</span>、<span
style="background-color: yellow">信号量</span>和<span
style="background-color: yellow">共享内存</span>。</p>
<p>　　● 信号用于指示事件已经发生。</p>
<p>　　● 无名管道 (类似于shell中的操作符<code>|</code>)
和有名管道用于在进程之间传输数据。</p>
<p>　　●
套接字用于在进程之间传输数据，无论这些进程在同一计算机上，还是在通过网络连接的不同计算机上。</p>
<p>　　●
文件上锁允许进程给文件在磁盘上的区域上锁，以防止其他进程读或更新文件内容。</p>
<p>　　● 消息队列用于在进程之间交换消息 (即数据包)。</p>
<p>　　● 信号量用于同步进程的操作。</p>
<p>　　●
共享内存允许多个进程共享同一片内存区域。当进程修改了共享内存的内容后，其他的所有进程都可以立即看到变化。</p>
<p>　　UNIX系统中的IPC机制繁多，并且有些机制在功能上重复，部分原因是受到了各种标准和UNIX系统的不同变体的影响。例如，有名管道和套接字都可以实现同一系统上的不相关进程之间的信息交换。两者共存于现代UNIX系统是因为有名管道来自于System
V，而套接字来自于BSD。</p>
<h3 id="信号">2.10 信号</h3>
<p>　　除了用于IPC，信号通常在其他情况下也会使用。信号经常被描述为
"软件中断"。信号的到达表示某些事件或异常情况已经发生。信号有多种类型，每种类型对应1种事件或情况。每种信号类型唯一的整数标识符，由形如<code>SIGxxxx</code>的符号名定义。</p>
<p>　　信号可以来自内核、其他进程 (需要合适的权限) 或进程自己。当<span
style="background-color: yellow">用户在终端输入中断字符</span>
(通常是Control-C) 、<span
style="background-color: yellow">进程的子进程终止</span>、<span
style="background-color: yellow">进程设置的定时器过期</span>或<span
style="background-color: yellow">进程试图访问非法内存地址</span>时，内核可能会发送信号给进程。</p>
<p>　　在shell中，命令<code>kill</code>可以用于发送信号给进程。系统调用<code>kill()</code>也提供同样的功能。</p>
<p>　　当进程收到信号时，可以<span
style="background-color: yellow">忽略信号</span>、<span
style="background-color: yellow">被信号终止</span>或<span
style="background-color: yellow">被挂起直到收到特殊用途的信号</span>。</p>
<p>　　对于大部分信号类型，程序都可以忽略信号或触发<strong>信号处理函数</strong>，而非执行接收信号的默认操作。信号处理函数是程序员定义的函数，它会在程序收到对应的信号时自动调用。</p>
<p>　　在信号生成到信号接收的这段时间内，该信号对进程来说是<span
style="background-color: yellow">待处理</span>的。通常情况下，若接收程序已经在运行，则会立即收到待处理信号；否则，接收程序在下次运行时会尽快收到待处理信号。但是，可以通过将信号添加到<strong>信号掩码</strong>来阻塞信号。若信号在阻塞期间生成，则该信号会保持待处理状态，直到解除阻塞
(即从信号掩码中移除该信号)。</p>
<h3 id="进程组和shell作业控制">2.11 进程组和shell作业控制</h3>
<p>　　shell执行的程序都会在新进程中启动。例如，shell会创建3个进程来执行以下管道命令
(列出当前工作目录下的文件并按文件大小排序)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | <span class="built_in">sort</span> -k5n | less</span></span><br></pre></td></tr></table></figure>
<p>　　除了<code>sh</code>之外的所有主要shell都提供了称为<strong>作业控制</strong>的交互特性，该特性允许用户同时执行和控制多个命令或管道。在作业控制shell中，管道中的所有进程都放置在1个新的<strong>进程组</strong>或<strong>作业</strong>。对于仅包含1个命令的shell命令行，新进程组仅包含1个新创建的进程。同一进程组中的进程都有相同的整数<strong>进程组标识符</strong>——进程组的<strong>进程组组长</strong>的进程ID。</p>
<p>　　内核允许进程组中的所有成员执行各种操作，尤其是传递信号。作业控制shell使用该特性来允许用户挂起或恢复管道中的所有进程。</p>
<p>　　<strong>会话</strong>是进程组 (或作业)
集合。同一会话中的所有进程都有相同的<strong>会话标识符</strong>。<strong>会话组长</strong>是创建会话的进程，会话ID也就是会话组长的进程ID。会话主要用于作业控制shell。作业控制shell创建的所有进程组都属于同一会话，其会话组长也就是shell。</p>
<p>　　会话通常有1个关联的<strong>控制终端</strong>。当会话组长第1次打开终端设备时，会创建控制终端。对于交互式shell创建的会话，控制终端就是用户登录的终端。1个终端最多只能作为1个会话的控制终端。</p>
<p>　　打开控制终端后，会话组长会成为控制终端的<strong>控制进程</strong>。当控制进程的终端断开连接时
(例如，终端窗口关闭)，控制终端会收到信号<code>SIGHUP</code>。</p>
<p>　　会话总是有1个<strong>前台进程组</strong>
(或<strong>前台作业</strong>)，用于从终端读输入和写输出到终端。当用户在控制终端输入<span
style="background-color: yellow">中断</span> (通常是Control-C) 或<span
style="background-color: yellow">挂起</span> (通常是Control-Z)
字符后，终端驱动程序会发送信号来杀死或挂起前台进程组。会话可以有任意个<strong>后台进程组</strong>
(或<strong>后台作业</strong>)，它们通过与号字符<code>&amp;</code>创建。</p>
<p>　　作业控制shell提供了列出所有作业、发送信号给作业以及将前台作业改为后台作业或将后台作业改为前台作业的命令。</p>
<h3 id="客户端-服务器架构">2.12 客户端-服务器架构</h3>
<p>　　<span
style="background-color: yellow">客户端-服务器应用程序</span>由2个进程组成：客户端进程和服务器进程。客户端通过发送请求信息给服务器来请求服务器执行某些服务。服务器解释客户端的请求，执行合适的操作，然后发送响应信息给客户端。</p>
<p>　　客户端和服务器可以位于同一计算机，也可以位于通过网络连接的不同计算机。客户端和服务器通过IPC机制通信。</p>
<p>　　有时，客户端和服务器可能会进行请求和响应的扩展对话。</p>
<p>　　通常，客户端应用程序与用户交互，而服务器应用程序提供对某些共享资源的访问。此外，可能出现多个客户端进程的实例与1个或少数几个服务器进程的实例通信的情况。</p>
<p>　　服务器可能会实现多个服务，例如：</p>
<p>　　● 提供对数据库或其他共享信息资源的访问。</p>
<p>　　● 通过网络提供对远程文件的访问。</p>
<p>　　● 封装部分业务逻辑。</p>
<p>　　● 提供对共享硬件资源 (例如，打印机) 的访问。</p>
<p>　　● 提供网页。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第8章 用户和组</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_08/</url>
    <content><![CDATA[<p>　　每个用户都有1个唯一的登录名 (用户名) 和1个关联的数字用户ID
(即UID)。用户可以属于1个或多个组。每个组都有1个唯一的组名和1个组ID
(即GID)。</p>
<p>　　用户ID和组ID的主要用途是确定各种系统资源的所有权和控制进程对系统资源的访问权限。</p>
<h3 id="密码文件和影子密码文件">8.1 密码文件和影子密码文件</h3>
<p>　　系统中的每个用户都在系统密码文件<code>/etc/passwd</code>中有1行记录，每行记录都包括以冒号<code>:</code>分隔的7个字段，如以下示例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mtk:x:1000:100:Michael Kerrisk:/home/mtk:/bin/bash</span><br></pre></td></tr></table></figure>
<p>　　这些字段从左到右依次是<span
style="background-color: yellow">登录名</span>、<span
style="background-color: yellow">加密后的密码</span>、<span
style="background-color: yellow">用户ID</span>、<span
style="background-color: yellow">组ID</span>、<span
style="background-color: yellow">注释</span>、<span
style="background-color: yellow">主目录</span>和<span
style="background-color: yellow">登录shell</span>。</p>
<p>　　●
登录名就是登录时输入的用户名，也可以视为与用户ID关联的符号标识符。当通过<code>ls</code>等程序获取文件的所有者时，返回的就是登录名。</p>
<p>　　●
通常，UNIX会使用DES加密密码。在这种情况下，加密后的密码包括13个字符。当加密后的密码字段不是13个字符的字符串时，对应的登录名将会被禁用。若已启用影子密码
(通常如此)，则该字段会被忽略，此时，该字段通常会包含字符<code>x</code>
(也可能出现其他未加密的字符)，真正的密码会存储在影子密码文件<code>/etc/shadow</code>中。若该字段为空，则对应的登录名无需密码就可以登录
(无论是否启用影子密码)。除了DES，还可以使用MD5等加密算法。MD5会输出128位的消息摘要
(即散列值)，该值会以34个字符的字符串形式存储在 (影子) 密码文件中。</p>
<p>　　●
若用户ID为0时，则表示对应的账户拥有超级用户特权，这样的账户通常只有1个，并且登录名是root。密码文件中可能会出现多行用户ID相同的记录，这允许用户使用不同的登录名来访问相同的资源，并且这些登录名可以属于不同的组。对于Linux
2.2及以下版本，用户ID存储为16位值 (即0~65536)。对于Linux
2.4及以上版本，用户ID存储为32位值。</p>
<p>　　● 组ID是用户所属的第1个组的ID。</p>
<p>　　●
注释是用户的相关信息，可以通过<code>finger</code>等程序获取。</p>
<p>　　●
主目录是用户登录后初始目录。用户登录后，主目录字段会成为环境变量<code>HOME</code>的值。</p>
<p>　　●
用户登录后，控制权会转移给登录shell，登录shell字段会成为环境变量<code>SHELL</code>的值。若该字段为空，则登录shell会默认为<code>/bin/sh</code>
(即<code>sh</code>)。登录shell通常是shell，但可以是任何程序。</p>
<span id="more"></span>
<p>　　对于单机系统，所有密码信息都存储在<code>/etc/passwd</code>中。当使用网络信息系统
(NIS) 或轻量级目录访问协议 (LDAP)
等系统来在网络环境中分发密码时，部分密码信息会存储在远程系统。只要应用程序使用<code>getpwnam()</code>和<code>getpwuid()</code>等函数来访问密码信息，NIS和LDAP的使用就对这些应用程序是透明的。</p>
<p>　　从历史角度，UNIX系统维护着所有用户信息，包括加密后的密码
(在<code>/etc/passwd</code>中)。因为各种非特权系统工具需要读密码文件中的信息，所以密码文件需要对所有用户都是可读的，这为密码破解程序创造了可乘之机
(密码破解文件会尝试对可能的密码进行加密，然后与密码文件中的密码进行匹配)。影子密码文件的设计初衷正是为了防止这类攻击，基本思想是将所有非敏感的用户数据存储在公开可读的密码文件，加密后的密码存储在仅对特权程序可读的影子密码文件。</p>
<p>　　除了登录名字段和加密后的密码字段，影子密码文件还包含很多安全相关的字段。</p>
<p>　　SUSv3没有说明影子密码，而且并非所有UNIX实现都提供了该特性。</p>
<h3 id="组文件">8.2 组文件</h3>
<p>　　用户所属的组由密码文件中的字段和组文件中的字段共同决定。对于早期UNIX实现，用户只能属于1个组。用户登录时的初始组由密码文件中的组ID字段决定，随后可以通过命令<code>newgrp</code>修改
(若对应的组设置了密码，则用户需要提供组密码)。4.2BSD允许用户能属于多个组，随后POSIX.1-1990将其标准化。</p>
<p>　　系统中的每个组都在组文件<code>/etc/group</code>中有1行记录，每行记录都包括以冒号<code>:</code>分隔的4个字段，如以下示例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">users:x:100:</span><br><span class="line">jambit:x:106:claus,felli,frank,harti,markus,martin,mtk,paul</span><br></pre></td></tr></table></figure>
<p>　　这些字段从左到右依次是<span
style="background-color: yellow">组名</span>、 <span
style="background-color: yellow">加密后的密码</span>、<span
style="background-color: yellow">组ID</span>和<span
style="background-color: yellow">用户列表</span>。</p>
<p>　　● 组名可以视为与组ID对应的符号标识符。</p>
<p>　　●
组密码是可选的，特权用户可以通过命令<code>passwd</code>来设置组密码。设置了组密码后，当不属于该组的用户启动属于该组的shell时，命令<code>newgrp</code>会要求用户输入组密码。若已启用影子密码，则该字段会被忽略，此时，该字段通常是字符<code>x</code>
(也可能是其他字符串，甚至是空字符串)，真正的密码会存储在<strong>影子组文件</strong><code>/etc/gshadow</code>
(只有特权用户和程序能访问)。组密码的加密方式与用户密码的相似。</p>
<p>　　● 通常，只有1个组ID为0的组，并且该组的组名是root。对于Linux
2.2及以下版本，组ID存储为16位值 (即0~65536)。对于Linux
2.4及以上版本，组ID存储为32位值。</p>
<p>　　● 用户列表包含以逗号<code>,</code>分隔的组成员的登录名。</p>
<p>　　若用户<code>avr</code>属于组<code>users</code>、<code>staff</code>和<code>teach</code>，则密码文件中会包含如下记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avr:x:1001:100:Anthony Robins:/home/avr:/bin/bash</span><br></pre></td></tr></table></figure>
<p>　　组文件会包含如下记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">users:x:100:</span><br><span class="line">staff:x:101:mtk,avr,martinl</span><br><span class="line">teach:x:104:avr,rlb,alc</span><br></pre></td></tr></table></figure>
<p>　　密码文件中的记录的第4个字段是100，对应组<code>users</code>。用户<code>avr</code>所属的其他组通过组文件的记录的用户列表字段来确定。</p>
<h3 id="检索用户信息和组信息">8.3 检索用户信息和组信息</h3>
<h4 id="从密码文件和组文件中检索记录">8.3.1
从密码文件和组文件中检索记录</h4>
<p>　　函数<code>getpwnam()</code>和<code>getpwuid()</code>可用于从密码文件中检索记录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回指向结构体passwd的指针，出错或未找到记录时返回NULL */</span></span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *pw_name;   <span class="comment">/* 登录名 (用户名) */</span></span><br><span class="line">    <span class="type">char</span> *pw_passwd; <span class="comment">/* 加密后的密码 (若未启用影子密码) */</span></span><br><span class="line">    <span class="type">uid_t</span> pw_uid;    <span class="comment">/* 用户ID */</span></span><br><span class="line">    <span class="type">gid_t</span> pw_gid;    <span class="comment">/* 组ID */</span></span><br><span class="line">    <span class="type">char</span> *pw_gecos;  <span class="comment">/* 注释 (用户的相关信息) */</span></span><br><span class="line">    <span class="type">char</span> *pw_dir;    <span class="comment">/* 初始工作 (主) 目录 */</span></span><br><span class="line">    <span class="type">char</span> *pw_shell;  <span class="comment">/* 登录shell */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　 函数<code>getpwnam()</code>会根据登录名
(即参数<code>name</code>)
检索密码文件，函数<code>getpwuid()</code>会根据用户ID
(即参数<code>uid</code>)
检索密码文件。这2个函数都返回指向结构体<code>passwd</code>的指针。</p>
<p>　　SUSv3并未说明结构体<code>passwd</code>的成员<code>pw_passwd</code>和<code>pw_gecos</code>，但所有UNIX实现都提供了这2个成员。当且仅当未启用影子密码时，成员<code>pw_passwd</code>才包含有效信息。其他部分UNIX实现提供了该结构体的额外的非标准成员。</p>
<p>　　成员<code>pw_gecos</code>的名称源于早期UNIX实现，其中该成员存储用于与运行着通用电气综合运作系统
(GECOS)
的机器通信的信息。尽管这种用法早已过时，但该名称仍然存在。如今，该成员用于保存用户的相关信息。</p>
<p>　　函数<code>getpwnam()</code>和<code>getpwuid()</code>返回的指针指向的结构体是静态分配的，所以这2个函数不是可重入的，并且指针指向的结构体会被后续的<code>getpwnam()</code>、<code>getpwuid()</code>或<code>getpwent()</code>调用覆盖。</p>
<p>　　根据SUSv3，若密码文件中没有匹配的记录，则<code>getpwnam()</code>和<code>getpwuid()</code>会返<code>NULL</code>，并且<span
style="background-color: yellow">不会</span>设置<code>errno</code>。但是，在这一点上，很多UNIX实现并没有遵循SUSv3的规定。在这种情况下，除了返回<code>NULL</code>之外，这些UNIX实现还会将<code>errno</code>设置为非0值
(例如，<code>ENOENT</code>和<code>ESRCH</code>)。对于glibc
2.7之前的版本，会将<code>errno</code>设置为<code>ENOENT</code>，但从glibc
2.7开始，glibc遵循SUSv3的规定
(不设置<code>errno</code>)。这种给跨UNIX实现的差异部分是因为POSIX.1-1990不要求这些函数设置<code>errno</code>，并且允许它们根据情况设置合适的值。这一切造就了移植的不便。</p>
<p>　　函数<code>getgrnam()</code>和<code>getgrgid()</code>可用于从组文件中检索记录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回指向结构体group的指针，出错或未找到记录时返回NULL */</span></span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="keyword">struct</span> group *<span class="title function_">getgrgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *gr_name;   <span class="comment">/* 组名 */</span></span><br><span class="line">    <span class="type">char</span> *gr_passwd; <span class="comment">/* 加密后的密码 (若未启用影子密码) */</span></span><br><span class="line">    <span class="type">gid_t</span> gr_gid;    <span class="comment">/* 组ID */</span></span><br><span class="line">    <span class="type">char</span> **gr_mem;   <span class="comment">/* 除了最后1个元素是NULL之外，其他元素都是组文件中的用户列表字段中的登录名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>getgrnam()</code>会根据组名 (即参数<code>name</code>)
检索组文件，函数<code>getgrgid()</code>会根据组ID
(即参数<code>gid</code>)
检索组文件。这2个函数都返回指向结构体<code>group</code>的指针。</p>
<p>　　SUSv3并未说明结构体<code>group</code>的成员<code>gr_passwd</code>，但所有UNIX实现都提供了该成员。当且仅当未启用影子密码时，成员<code>gr_passwd</code>才包含有效信息。</p>
<p>　　与<code>getpwnam()</code>和<code>getpwuid()</code>类似，<code>getgrnam()</code>和<code>getgrgid()</code>返回的指针指向的结构体也会被后续的这2个函数的调用覆盖。</p>
<p>　　当<code>getgrnam()</code>和<code>getgrgid()</code>找不到匹配的记录时，它们的行为与<code>getpwnam()</code>和<code>getpwuid()</code>的类似。</p>
<p>　　SUSv3详细说明了1组与这4个函数等效的可重入函数：<code>getpwnam_r()</code>、<code>getpwuid_r()</code>、<code>getgrnam_r()</code>和<code>getgrgid_r()</code>，这些函数的参数都包括1个结构体<code>passwd</code>
(或<code>group</code>) 和1个用于存储结构体<code>passwd</code>
(或<code>group</code>)
中的成员指针指向的其他结构体的缓冲区。该缓冲区的大小可以通过调用<code>sysconf(_SC_GETPW_R_SIZE_MAX)</code>来获取
(对于组相关函数，则是调用<code>sysconf(_SC_GETGR_R_SIZE_MAX)</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ugid_functions.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span> <span class="comment">/* 定义函数原型的头文件 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回uid对应的登录名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param uid</span></span><br><span class="line"><span class="comment"> * @return char* 若出错，则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">userNameFromId</span><span class="params">(<span class="type">uid_t</span> uid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span>;</span></span><br><span class="line">    pwd = getpwuid(uid);</span><br><span class="line">    <span class="keyword">return</span> (pwd == <span class="literal">NULL</span>) ? <span class="literal">NULL</span> : pwd-&gt;pw_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回name对应的用户ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name</span></span><br><span class="line"><span class="comment"> * @return uid_t 若出错，则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">userIdFromName</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span>;</span></span><br><span class="line">    <span class="type">uid_t</span> u;</span><br><span class="line">    <span class="type">char</span> *endptr;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span> || *name == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u = strtol(name, &amp;endptr, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (*endptr == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pwd = getpwnam(name);</span><br><span class="line">    <span class="keyword">if</span> (pwd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pwd-&gt;pw_uid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回gid对应的组名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param gid</span></span><br><span class="line"><span class="comment"> * @return char* 若出错，则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">groupNameFromId</span><span class="params">(<span class="type">gid_t</span> gid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">grp</span>;</span></span><br><span class="line">    grp = getgrgid(gid);</span><br><span class="line">    <span class="keyword">return</span> (grp == <span class="literal">NULL</span>) ? <span class="literal">NULL</span> : grp-&gt;gr_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回name对应的组ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name</span></span><br><span class="line"><span class="comment"> * @return gid_t 若出错，则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">groupIdFromName</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">grp</span>;</span></span><br><span class="line">    <span class="type">gid_t</span> g;</span><br><span class="line">    <span class="type">char</span> *endptr;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span> || *name == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g = strtol(name, &amp;endptr, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (*endptr == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grp = getgrnam(name);</span><br><span class="line">    <span class="keyword">if</span> (grp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grp-&gt;gr_gid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，函数<code>userNameFromId()</code>、<code>userIdFromName()</code>、<code>groupNameFromId()</code>、<code>groupIdFromName()</code>用于登录/组名与用户/组ID的相互转换。此外，<code>userNameFromId()</code>和<code>groupNameFromId()</code>允许输入只包含数字的字符串，此时，这2个函数会直接将字符串转换为数字，然后返回给调用者。</p>
<h4 id="扫描密码文件和组文件中的所有记录">8.3.2
扫描密码文件和组文件中的所有记录</h4>
<p>　　函数<code>getpwent()</code>、<code>setpwent()</code>和<code>endpwent()</code>用于对密码文件进行顺序扫描。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> passwd *<span class="title function_">getpwent</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 成功时返回指向结构体passwd的指针，出错或遇到流结尾时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">endpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>　　每次调用函数<code>getpwent()</code>都会返回1条记录。若没有更多记录或出错，则返回<code>NULL</code>。第1次调用该函数时，会自动打开密码文件。当扫描完成后，需要调用函数<code>endpwent()</code>来关闭密码文件。</p>
<p>　　可以通过以下代码来打印密码文件中的所有登录名和用户ID：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((pwd = getpwent()) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-8s %5ld\n&quot;</span>, pwd-&gt;pw_name, (<span class="type">long</span>)pwd-&gt;pw_uid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">endpwent();</span><br></pre></td></tr></table></figure>
<p>　　函数<code>setpwent</code>会让<code>getpwent()</code>从密码文件的开头开始扫描。</p>
<p>　　与<code>getpwent()</code>、<code>setpwent()</code>和<code>endpwent()</code>类似，函数<code>getgrent()</code>、<code>setgrent()</code>和<code>endgrent()</code>用于对组文件进行顺序扫描。</p>
<h4 id="从影子密码文件中检索记录">8.3.3 从影子密码文件中检索记录</h4>
<p>　　函数<code>getspnam()</code>、<code>getspent()</code>、<code>setspent()</code>和<code>endspent()</code>用于从影子密码文件中检索单条记录或扫描所有记录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shadow.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> spwd *<span class="title function_">getspnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 成功时返回指向结构体spwd的指针，出错或未找到记录时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> spwd *<span class="title function_">getspent</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 成功时返回指向结构体spwd的指针，出错或遇到流结尾时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setspent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">endspent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spwd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *sp_namp; <span class="comment">/* 登录名 (用户名) */</span></span><br><span class="line">    <span class="type">char</span> *sp_pwdp; <span class="comment">/* 加密后的密码 */</span></span><br><span class="line">    <span class="comment">/* 剩余成员用于提供 &quot;密码自动过期&quot; 功能，即强制用户定期修改密码 */</span></span><br><span class="line">    <span class="type">long</span> sp_lstchg;        <span class="comment">/* 上次更改密码的时间 (自1970年1月1日起的天数) */</span></span><br><span class="line">    <span class="type">long</span> sp_min;           <span class="comment">/* 密码更改之间的最小天数 */</span></span><br><span class="line">    <span class="type">long</span> sp_max;           <span class="comment">/* 需要更改密码前的最大天数 */</span></span><br><span class="line">    <span class="type">long</span> sp_warn;          <span class="comment">/* 距离警告用户密码即将过期之前的天数 */</span></span><br><span class="line">    <span class="type">long</span> sp_inact;         <span class="comment">/* 账户过期后，账户被视为非活动状态并锁定的天数 */</span></span><br><span class="line">    <span class="type">long</span> sp_expire;        <span class="comment">/* 账户过期时间 (自1970年1月1日起的天数) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sp_flag; <span class="comment">/* 保留供将来使用 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这里不会介绍这些函数的细节，因为这些函数与对应的用于从密码文件中检索记录的函数类似。SUSv3没有说明这些函数，而且并非所有UNIX实现都提供了这些函数。</p>
<h3 id="密码加密和用户认证">8.4 密码加密和用户认证</h3>
<p>　　有些应用程序会要求用户进行身份认证，通常是输入用户名 (即登录名)
和密码。为此，应用程序可能会维护自己的用户名和密码数据库。有时，允许用户输入
(影子)
密码文件中定义的标准用户名和密码是必要或便利的。例如，<code>ssh</code>和<code>ftp</code>等用于登录到远程系统的网络应用程序验证用户名和密码的方式与标准登录程序的相同。</p>
<p>　　出于安全原因，UNIX系统使用<strong>单向加密</strong>算法来加密密码，这表示无法通过加密后的密码来获取密码明文。因此，验证输入的密码是否正确的方法就是将其以相同的算法加密，然后将结果与影子密码文件中的加密后的密码对比。加密算法封装在函数<code>crypt()</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">crypt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *key, <span class="type">const</span> <span class="type">char</span> *salt)</span>; <span class="comment">/* 成功时返回静态分配的加密后的密码字符串，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>crypt()</code>会使用DES加密算法的变体来加密由最多8个字符组成的参数<code>key</code>
(即密码)。参数<code>salt</code>是由2个字符组成的字符串，用于置乱
(使得加密后的密码更难破解)。该函数返回静态分配的由13个字符组成的字符串
(即加密后的密码)。</p>
<p>　　MD5算法生成的以美元符号<code>$</code>开头的由34个字符组成的字符串使得<code>crypt()</code>能够区分DES加密后的密码和MD5加密后的密码。</p>
<p>　　参数<code>salt</code>和<code>crypt()</code>返回的字符串中的字符都是从由64个字符组成的集合<code>[a-zA-Z0-9/.]</code>中选择。因此，对于同一密码明文，DES加密后的密码有4096种可能。</p>
<p>　　<code>crypt()</code>会将<code>salt</code>作为返回的字符串的前2个字符，这表示可以通过影子密码文件中已存在的加密后的密码来获取合适的<code>salt</code>值
(<code>passwd</code>等程序加密密码时会生成随机的<code>salt</code>值)。实际上，<code>salt</code>包含的字符可以多于2个，但函数<code>crypt()</code>会忽略<code>salt</code>的前2个字符之外的所有字符。</p>
<p>　　为了在Linux上使用<code>crypt</code>，编译程序时必须与库<code>crypt</code>一起链接
(使用选项<code>-lcrypt</code>)。</p>
<p>　　通常，通过函数<code>getpass()</code>来读取用户在终端输入的密码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getpass</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *prompt)</span>; <span class="comment">/* 成功时返回静态分配的输入的密码字符串，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>getpass()</code>会先禁用终端特殊字符的回显和处理，然后打印参数<code>prompt</code>指定的字符串和读1行输入，最后将去除换行符后的以<code>NULL</code>结尾的输入作为结果返回
(该字符串是静态分配的，所以会被后续的<code>getpass()</code>调用覆盖)。在<code>getpass()</code>返回之前，会先将终端的设置恢复。</p>
<p>　　SUSv2详细说明了<code>getpass()</code>
(将其标记为LEGACY)，但SUSv3没有说明该函数。大多数UNIX实现都提供了该函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check_password.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE   <span class="comment">/* 定义了该宏后，getpass()会被声明在unistd.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE <span class="comment">/* 定义了该宏后，crypt()会被声明在unistd.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shadow.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *username, *password, *encrypted, *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spwd</span> *<span class="title">spwd</span>;</span></span><br><span class="line">    Boolean authOk;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">long</span> lnmax;</span><br><span class="line"></span><br><span class="line">    lnmax = sysconf(_SC_LOGIN_NAME_MAX);</span><br><span class="line">    <span class="keyword">if</span> (lnmax == <span class="number">-1</span>) <span class="comment">/* 用户名长度上限获取失败 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        lnmax = <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    username = <span class="built_in">malloc</span>(lnmax);</span><br><span class="line">    <span class="keyword">if</span> (username == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Username: &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> (fgets(username, lnmax, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); <span class="comment">/* 遇到EOF时退出 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">strlen</span>(username);</span><br><span class="line">    <span class="keyword">if</span> (username[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        username[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 移除最后的\n */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pwd = getpwnam(username);</span><br><span class="line">    <span class="keyword">if</span> (pwd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;couldn&#x27;t get password record&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    spwd = getspnam(username);</span><br><span class="line">    <span class="keyword">if</span> (spwd == <span class="literal">NULL</span> &amp;&amp; errno == EACCES)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;no permission to read shadow password file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (spwd != <span class="literal">NULL</span>) <span class="comment">/* 在影子密码文件中找到记录 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        pwd-&gt;pw_passwd = spwd-&gt;sp_pwdp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    password = getpass(<span class="string">&quot;Password: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 加密密码和清除密码明文 */</span></span><br><span class="line">    encrypted = crypt(password, pwd-&gt;pw_passwd);</span><br><span class="line">    <span class="keyword">for</span> (p = password; *p != <span class="string">&#x27;\0&#x27;</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        *p++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encrypted == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;crypt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    authOk = <span class="built_in">strcmp</span>(encrypted, pwd-&gt;pw_passwd) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!authOk)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Incorrect password\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Successfully authenticated: UID=%ld\n&quot;</span>, (<span class="type">long</span>)pwd-&gt;pw_uid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行认证完成后的操作 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何通过<code>crypt()</code>来认证用户。该程序会先读取用户名，然后检索对应的
(影子) 密码文件记录。若未找到记录或没有影子密码文件的访问权限
(需要超级用户特权或属于组<code>shadow</code>)，则打印错误信息。当通过<code>getpass()</code>读取密码后，会使用<code>crypt()</code>来对其加密，然后将结果与对应的影子密码文件记录对比。若相同，则打印对应的用户ID。</p>
<p>　　在第18~22行，这里通过调用<code>sysconf(_SC_LOGIN_NAME_MAX)</code>
(获取主机系统中的用户名长度上限)
来决定用于存储用户名的字符串的长度。</p>
<p>　　第62~66行展示了1个重要的安全点：<span
style="background-color: yellow">读取密码后立即加密密码和清除密码明文</span>，这最小化了程序崩溃时生成包含密码明文的核心转储的可能性。实际上，还有其他可能泄漏密码明文的方式。例如，当包含密码明文的虚拟内存页被换出后，特权程序可以从交换文件中读取密码明文。此外，拥有对应特权的进程可以通过读取<code>/dev/mem</code>
(将计算机的物理内存表示为连续的字节流的虚拟设备)
来试图寻找密码明文。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第7章 内存分配</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_07/</url>
    <content><![CDATA[<p>　　程序分段点最初位于未初始化数据段的末尾
(即<code>&amp;end</code>)。当程序分段点增加后，程序能访问新分配区域的所有地址，但对应的物理内存页并非在此时分配。当程序<span
style="background-color: yellow">第1次访问该区域内的地址</span>时，内核才会分配对应的物理页。</p>
<p>　　程序分段点的上限由多个因素决定，包括<span
style="background-color: yellow">进程的数据段大小的资源限制</span>
(即<code>RLIMIT_DATA</code>) 以及<span
style="background-color: yellow">内存映射、共享内存段和共享库的位置</span>。</p>
<p>　　UNIX系统历来提供了2个用于控制程序分段点的系统调用：<code>brk()</code>和<code>sbrk()</code>。Linux也提供了这2个系统调用。但是，这2个系统调用很少直接调用。</p>
<p>　　当程序分配的堆内存由于某种原因未释放或无法释放时，堆会持续增长，直到达到可用虚拟内存的上限，此时，后续的堆内存分配请求会失败。这种情况称为<strong>内存泄漏</strong>。</p>
<h3 id="在堆上分配内存">7.1 在堆上分配内存</h3>
<p>　　进程可以通过扩大堆来分配内存
(见6.1)，这通常使用malloc系列函数来完成，而malloc系统函数基于系统调用<code>brk()</code>和<code>sbrk()</code>。</p>
<h4 id="调整程序分段点">7.1.1 调整程序分段点</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">brk</span><span class="params">(<span class="type">void</span> *end_data_segment)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>; <span class="comment">/* 成功时返回程序分段点的旧值，出错时返回(void *)-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>brk()</code>会将程序分段点设置为参数<code>end_data_segment</code>指定的位置。由于虚拟内存以页为单位，所以<code>end_data_segment</code>会向上取整为下一页的起始地址。</p>
<p>　　若<code>end_data_segment</code>小于程序分段点的初始值，则可能会导致无法预测的行为。当程序访问不属于已初始化数据段或未初始化数据段的数据时，会出现段错误
(信号<code>SIGSEGV</code>)。</p>
<p>　　系统调用<code>sbrk()</code>会将程序分段点增加<code>increment</code>。<code>increment</code>的类型<code>intptr_t</code>是整型数据类型。若<code>sbrk()</code>成功，则返回程序分段点的旧值，即新分配的内存块的起始位置。对于Linux，<code>sbrk()</code>是基于<code>brk()</code>的库函数。</p>
<p>　　<code>sbrk(0)</code>会返回程序分段点的当前值。当需要获取堆的大小时，这会很有用
(也许是为了监视内存分配包的行为)。</p>
<p>　　SUSv2详细说明了<code>brk()</code>和<code>sbrk()</code>
(将它们标记为LEGACY)，但SUSv3没有说明它们。</p>
<span id="more"></span>
<h4 id="malloc和free">7.1.2
<code>malloc()</code>和<code>free()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>; <span class="comment">/* 成功时返回指向新内存块的指针，出错时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>malloc()</code>会从堆中分配<code>size</code>字节的内存块
(不会初始化)，返回值是指向新内存块的指针。</p>
<p>　　<code>malloc()</code>的返回值类型是<code>void *</code>，所以可以将其赋值给所有类型的指针。此外，<code>malloc()</code>分配的内存块会自动对齐，通常按8B或16B对齐。</p>
<p>　　SUSv3规定，<code>malloc(0)</code>会返回<code>NULL</code>，或者指向较小的内存块的指针。对于Linux，<code>malloc(0)</code>的行为遵从后者。</p>
<p>　　若<code>malloc()</code>的请求的内存块无法分配，则会返回<code>NULL</code>，并将<code>errno</code>设置为对应的值。尽管出现这种情况的可能性很小，但还是应该检查<code>malloc()</code>的返回值。</p>
<p>　　函数<code>free()</code>会释放参数<code>ptr</code>指向的在堆上分配的内存块。通常，<code>free()</code>不会减少程序分段点，而是将<code>ptr</code>指向的内存块添加到用于后续<code>malloc()</code>调用的
(双向) 空闲内存块链表。这样做有如下原因：</p>
<p>　　●
待释放的内存块通常位于堆的中间，所以减少程序分段点是不可能的。</p>
<p>　　● 这可以最小化必须的<code>sbrk()</code>的调用次数
(在3.1中提到过，大多数系统调用的耗时都很长)。</p>
<p>　　●
在很多情况下，减少程序分段点对需要分配大量内存的程序没有帮助，因为这些程序通常会长时间占用内存或重复分配和释放内存
(而非一次释放所有内存，然后运行较长时间)。</p>
<p>　　当<code>ptr</code>是<code>NULL</code>时，<code>free()</code>不会执行任何操作，即<span
style="background-color: yellow">不会反馈错误</span>。调用<code>free()</code>后，再次使用<code>ptr</code>会导致错误，产生无法预测的结果。</p>
<p>　　当进程终止时，它的所有内存都会被系统释放，包括通过malloc包分配的堆内存。对于那些在分配堆内存后一直使用的程序，通常不会调用<code>free()</code>，进程终止时的内存自动释放机制足以处理。进程终止时的内存自动释放机制对很多程序都是可以接受的，但显式释放堆内存仍然是值得考虑的，理由如下：</p>
<p>　　●
显式调用<code>free()</code>可能会让程序在后续修改时更易于阅读和维护。</p>
<p>　　●
当使用malloc调试库来检查内存泄漏时，所有未被显式释放的内存都会被反馈为内存泄漏。这可能会使确定
(真正的) 内存泄漏的任务更加困难。</p>
<h5 id="malloc和free的实现">7.1.2.1
<code>malloc()</code>和<code>free()</code>的实现</h5>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_07/memory_block_returned_by_malloc.svg" class="">
<p>　　<code>malloc()</code>分配内存块时，实际分配的内存块除了包含要求的内存块
(即有效载荷) 之外，还包含1个用于表示内存块大小的位于<span
style="background-color: yellow">在内存块之前</span>的整数。</p>
<p>　　<code>malloc()</code>会先扫描空闲内存块链表来寻找大小不小于要求的内存块。扫描策略因实现而异常
(例如，首次适配和最佳适配)。若内存块的大小等于要求，则将其返回给调用者；若大于要求，则先进行分割，然后将符合要求的内存块返回给调用者
(更小的块留在空闲内存块链表)。</p>
<p>　　若空闲内存块链表中没有满足要求的内存块，则<code>malloc()</code>会调用<code>sbrk()</code>来分配更多内存。为了减少<code>sbrk()</code>的调用次数，<code>malloc()</code>调用<code>sbrk()</code>分配的内存的大小会大于要求
(虚拟内存页大小的整数倍)，然后将多余的内存放入空闲内存块链表。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_07/a_block_on_the_free_list.svg" class="">
<p>　　为了将内存块加入到空闲内存块链表，<code>free()</code>会使用内存块的有效载荷来存储前驱块指针和后继块指针。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_07/heap_containing_allocated_blocks_and_a_free_list.svg" class="">
<p>　　随着内存块的分配和释放，已分配的内存块和空闲内存块链表中的空闲内存块会混合在一起。</p>
<p>　　C允许创建指向堆中的任何位置的指针和修改它们指向的内容
(包括块长度、前驱块指针和后继块指针)，若使用不当，则很可能导致漏洞。为了避免这一问题，应当遵守以下规则：</p>
<p>　　● 当分配内存块后，应当避免使用该内存块之外的字节。</p>
<p>　　● 避免重复释放相同的内存块。</p>
<p>　　●
避免对不是通过malloc包中的函数获取的指针调用<code>free()</code>。</p>
<p>　　glibc提供了很多用于监控和控制malloc包的函数的非标准函数。函数<code>mallopt()</code>提供了多个用于控制<code>malloc()</code>使用的算法的参数。函数<code>mallinfo()</code>会返回关于<code>malloc()</code>分配的内存块的各种数据的结构体。很多UNIX实现都提供了这2个函数，但这些函数的实现因UNIX实现而异。</p>
<h5 id="malloc调试工具和库">7.1.2.2 malloc调试工具和库</h5>
<p>　　可以通过malloc调试库或glibc提供的malloc调试工具来定位堆内存漏洞。</p>
<p>　　glibc提供了如下malloc调试工具：</p>
<p>　　●
函数<code>mtrace()</code>和<code>muntrace()</code>可用于启用或关闭跟踪堆内存分配调用。这2个函数与环境变量<code>MALLOC_TRACE</code>一起使用，该环境变量需要被定义为包含用于写入追踪信息的文件的名称。当调用<code>mtrace()</code>时，会检查环境变量<code>MALLOC_TRACE</code>定义的文件是否存在以及对其是否拥有写权限。若是，则所有对malloc包的函数的调用都会被追踪和记录。由于写入的内容不易被人类读取，所以提供了脚本
(也称为<code>mtrace</code>)
来分析文件并生成可读的摘要。出于安全原因，set-user-ID和set-group-ID程序会忽略对<code>mtrace()</code>的调用。</p>
<p>　　●
函数<code>mcheck()</code>和<code>mprobe()</code>允许程序对已分配的内存块进行一致性检查
(例如，捕捉试图写已分配的内存块之外的位置的错误)。这些函数提供的功能与glibc调试库的重叠。使用这些函数的程序必须与mcheck库一起链接
(使用参数<code>cc -lmcheck</code>)。</p>
<p>　　●
环境变量<code>MALLOC_CHECK_</code>提供的功能与<code>mcheck()</code>和<code>mprobe()</code>的相似，但前者无需修改和重新编译程序。通过为环境变量<code>MALLOC_CHECK_</code>设置不同的值，可以控制程序如何响应堆内存分配错误。0表示忽略错误；1表示在<code>stderr</code>中打印诊断错误；2表示调用<code>abor()</code>来终止程序。这种方法无法检查所有堆内存错误，仅适用于检测<span
style="background-color: yellow">常见堆内存错误</span>。相比malloc调试工具，这种方法更高效和易于使用，并且成本更低。出于安全原因，set-user-ID和set-group-ID程序会忽略环境变量<code>MALLOC_CHECK_</code>的设置。</p>
<p>　　malloc调试库提供了与标准malloc包相同的API，但前者会执行额外的步骤来捕捉堆内存分配漏洞。为了使用该调试库，需要链接标准C库。因为该调试库通常以更慢的运行时操作速度和/或更大的内存消耗为代价，所以应该仅在调试时使用。该库包括<code>Electric Fence</code>、<code>dmalloc</code>、<code>Valgrind</code>和<code>Insure++</code>，其中<code>Valgrind</code>和<code>Insure++</code>可以检测多种与堆内存分配无关的错误。</p>
<h5 id="示例程序">7.1.2.3 示例程序</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* free_and_sbrk.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ALLOCS 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr[MAX_ALLOCS];</span><br><span class="line">    <span class="type">int</span> freeStep, freeMin, freeMax, blockSize, numAllocs, j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s num-allocs block-size [step [min [max]]]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numAllocs = getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;num-allocs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (numAllocs &gt; MAX_ALLOCS)</span><br><span class="line">    &#123;</span><br><span class="line">        cmdLineErr(<span class="string">&quot;num-allocs &gt; %d\n&quot;</span>, MAX_ALLOCS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blockSize = getInt(argv[<span class="number">2</span>], GN_GT_0 | GN_ANY_BASE, <span class="string">&quot;block-size&quot;</span>);</span><br><span class="line"></span><br><span class="line">    freeStep = (argc &gt; <span class="number">3</span>) ? getInt(argv[<span class="number">3</span>], GN_GT_0, <span class="string">&quot;step&quot;</span>) : <span class="number">1</span>;</span><br><span class="line">    freeMin = (argc &gt; <span class="number">4</span>) ? getInt(argv[<span class="number">4</span>], GN_GT_0, <span class="string">&quot;min&quot;</span>) : <span class="number">1</span>;</span><br><span class="line">    freeMax = (argc &gt; <span class="number">5</span>) ? getInt(argv[<span class="number">5</span>], GN_GT_0, <span class="string">&quot;max&quot;</span>) : numAllocs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freeMax &gt; numAllocs)</span><br><span class="line">    &#123;</span><br><span class="line">        cmdLineErr(<span class="string">&quot;free-max &gt; num-allocs\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initial program break: %10p\n&quot;</span>, sbrk(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Allocating %d*%d bytes\n&quot;</span>, numAllocs, blockSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numAllocs; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[j] = <span class="built_in">malloc</span>(blockSize);</span><br><span class="line">        <span class="keyword">if</span> (ptr[j] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program break is now: %10p\n&quot;</span>, sbrk(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Freeing blocks from %d to %d in steps of %d\n&quot;</span>, freeMin, freeMax, freeStep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = freeMin - <span class="number">1</span>; j &lt; freeMax; j += freeStep)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After free(), program break is: %10p\n&quot;</span>, sbrk(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>free()</code>对程序分段点的影响
(先分配多个内存块，再根据可选的命令行参数释放部分或全部内存块)。</p>
<p>　　第1个和第2个命令行参数分别指定内存块的数量和大小。第3个命令行参数指定释放内存块前执行的循环步长，若省略该参数或将其指定为1，则程序会释放所有内存块；若指定为2，则每隔1个内存块释放1个内存块；依此类推。第4个和第5个参数指定待分配块的范围，若忽略这2个参数，则释放所有符合第3个参数指定的要求的内存块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./free_and_sbrk 1000 10240 2</span></span><br><span class="line">Initial program break: 0x804a6bc</span><br><span class="line">Allocating 1000*10240 bytes</span><br><span class="line">Program break is now: 0x8a13000</span><br><span class="line">Freeing blocks from 1 to 1000 in steps of 2</span><br><span class="line">After free(), program break is: 0x8a13000</span><br></pre></td></tr></table></figure>
<p>　　在这段输出中，当释放所有指定的内存块后，程序分段点依旧处于峰值
(即分配所有指定内存块时所达到的值)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./free_and_sbrk 1000 10240 1 500 1000</span></span><br><span class="line">Initial program break: 0x804a6bc</span><br><span class="line">Allocating 1000*10240 bytes</span><br><span class="line">Program break is now: 0x8a13000</span><br><span class="line">Freeing blocks from 500 to 1000 in steps of 1</span><br><span class="line">After free(), program break is: 0x852b000</span><br></pre></td></tr></table></figure>
<p>　　在这段输出中，在释放所有指定的内存块后，程序分段点小于峰值。glibc的<code>free()</code>能够识别位于程序分段点的完整的空闲内存块。因此，当释放位于程序分段点的内存块后，会将其与相邻的空闲内存块合并为1个更大的内存块。这样做可以避免空闲内存块链表中有大量小到无法满足<code>malloc()</code>的请求的内存块。</p>
<p>　　当位于程序分段点的空闲内存块<span
style="background-color: yellow">足够大</span>时
(由控制malloc包的参数控制，其值通常是128KB)，glibc的<code>free()</code>才会调用<code>sbrk()</code>来减少程序分段点。</p>
<h4 id="在堆上分配内存的其他方法">7.1.3 在堆上分配内存的其他方法</h4>
<p>　　除了<code>malloc()</code>，C库还提供了大量其他用于堆内存分配的函数。</p>
<h5 id="calloc和realloc">7.1.3.1
<code>calloc()</code>和<code>realloc()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> numitems, <span class="type">size_t</span> size)</span>; <span class="comment">/* 成功时返回指向新内存块的指针，出错时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>; <span class="comment">/* 成功时返回指向调整大小后的内存块的指针，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>calloc()</code>会为数组分配堆内存，并会将分配的内存块<span
style="background-color: yellow">初始化为0</span>。参数<code>numitems</code>指定数组的元素数。参数<code>size</code>指定元素的大小。若成功分配合适大小的内存块，则返回指向该内存块的指针；否则，返回<code>NULL</code>。</p>
<p>　　函数<code>realloc()</code>会调整参数<code>ptr</code>指向的内存块
(由<code>malloc()</code>包的函数分配)
的大小。参数<code>size</code>指定目标大小。若成功调整内存块的大小，则返回指向调整大小后的内存块的指针
；否则，返回<code>NULL</code>，并且不会调整<code>ptr</code>指向的内存块
(SUSv3要求如此)。当使用<code>realloc()</code>扩大内存块时，扩大的部分不会初始化。调用<code>realloc(NULL, size)</code>等同于调用<code>malloc(size)</code>。调用<code>realloc(ptr, 0)</code>等同于调用<code>malloc(0)</code>和<code>free(ptr)</code>。</p>
<p>　　
当使用<code>realloc()</code>扩大内存块时，若紧随其后的内存块是空闲内存块，并且足够大，则<code>realloc()</code>会立即合并它们；若内存块位于堆的末尾，则<code>realloc()</code>会扩展堆；若内存块位于堆的中间，并且紧随其后的内存块无法满足合并要求，则<code>realloc()</code>会分配新内存块，然后将旧内存块的数据复制到新内存块。最后1种情况很常见，并且会占用大量CPU资源。</p>
<p>　　<code>realloc()</code>可能会移动内存块，这会导致很多指向旧内存块的内容的指针无效，只有通过在内存块的指针上加上偏移量而形成的指针依旧生效。综上所述，应尽量避免使用<code>realloc()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 成员定义 */</span></span><br><span class="line">&#125; myStruct;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span> *<span class="title">p</span>, *<span class="title">np</span>;</span></span><br><span class="line">p = <span class="built_in">calloc</span>(<span class="number">1000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> myStruct));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">np = <span class="built_in">realloc</span>(p, newsize);</span><br><span class="line"><span class="keyword">if</span> (nptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 错误处理 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    p = np;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>calloc()</code>和<code>realloc()</code>的用法。这里并不能直接将<code>realloc()</code>的返回值赋值给<code>p</code>，因为一旦<code>realloc()</code>失败，<code>p</code>会被赋值为<code>NULL</code>，导致它原本指向的内存块无法访问。</p>
<h5 id="memalign和posix_memalign">7.1.3.2
<code>memalign()</code>和<code>posix_memalign()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memalign</span><span class="params">(<span class="type">size_t</span> boundary, <span class="type">size_t</span> size)</span>; <span class="comment">/* 成功时返回指向新内存块的指针，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>memalign()</code>会分配<code>size</code>字节的内存块，并且该内存块的起始地址是参数<code>boundary</code>的整数倍。<code>boundary</code>必须是2的幂。在分配合适大小的内存块后，<code>memalign()</code>会返回指向新内存块的指针。若出错，则返回<code>NULL</code>。</p>
<p>　　并非所有的UNIX实现都提供<code>memalign()</code>。很多提供该函数的UNIX实现将其声明在头文件<code>stdlib.h</code>中。</p>
<p>　　对于部分UNIX实现，无法对<code>memalign()</code>返回的内存块调用<code>free()</code>。因为<code>memalign()</code>在通过<code>malloc()</code>分配内存块后，返回的指针是内存块的指针<span
style="background-color: yellow">加上合适的对齐偏移量</span>。glibc的实现没有这个问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">posix_memalign</span><span class="params">(<span class="type">void</span> **memptr, <span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>posix_memalign()</code>与<code>memalign()</code>类似，但在3个方面不同：</p>
<p>　　● 已分配的内存块地址通过参数<code>memptr</code>返回。</p>
<p>　　●
分配的内存块按照参数<code>alignment</code>对齐。<code>alignment</code>必须是<code>sizeof(void *)</code>的2的幂数倍。</p>
<p>　　● 若成功，则返回0；若出错，则返回正错误号
(即通常用于<code>errno</code>的错误号)。</p>
<p>　　SUSv3没有说明<code>memalign()</code>，但详细说明了<code>posix_memalign()</code>。</p>
<h3 id="在栈上分配内存">7.2 在栈上分配内存</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;alloca.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">alloca</span><span class="params">(<span class="type">size_t</span> size)</span>; <span class="comment">/* 返回指向栈内存块的指针 */</span></span><br></pre></td></tr></table></figure>
<p>　　与malloc包的函数类似，函数<code>alloca()</code>会动态分配栈内存。参数<code>size</code>指定栈内存块的大小。该函数会返回指向栈内存块的指针。<code>alloca()</code>通过扩大栈帧来获取内存。因为正在执行的函数的栈帧位于栈顶，所以只需增加栈指针就能获取栈内存。</p>
<p>　　SUSv3没有说明<code>alloca()</code>，但大多数UNIX实现都提供了该函数。对于glibc的旧版本和部分UNIX实现
(主要是BSD衍生实现)，<code>alloca()</code>的声明在头文件<code>stdlib.h</code>中。</p>
<p>　　若栈因为调用<code>alloca()</code>而溢出，则程序的行为将无法预测。此时，<code>alloca()</code>不会返回<code>NULL</code>，但程序会收到信号<code>SIGSEGV</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *y;</span><br><span class="line">y = alloca(size);</span><br><span class="line">func(x, y, z);</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>alloca()</code>的用法。这里并不能将<code>alloca()</code>的返回值直接作为函数的参数传递，因为一旦如此，分配的栈内存块会位于<span
style="background-color: yellow">被调函数</span>的栈帧的中间。</p>
<p>　　通过<code>alloca()</code>分配内存比通过<code>malloc()</code>分配内存更具优势。第1个优势是通过<code>alloca()</code>分配内存更快，因为<code>alloca()</code>由编译器实现为直接调整栈指针的内联代码。此外，<code>alloca()</code>无需维护空闲内存块链表。第2个优势是函数返回时，栈帧会自动释放，包括<code>alloca()</code>分配的内存块
(因为函数返回时会将栈指针寄存器设置为前1个栈帧的末尾)。</p>
<p>　　当通过<code>longjmp()</code>或<code>siglongjmp()</code>来在信号处理函数中执行非本地跳转时，<code>alloca()</code>会很有用。在这种情况下，若使用<code>malloc()</code>来分配内存，则很可能跳过释放内存的代码部分，进而导致内存泄漏。相比之下，<code>alloca()</code>完全避免了这个问题。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第6章 进程</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_06/</url>
    <content><![CDATA[<p>　　<strong>程序</strong>是1个文件，其中包含一系列描述如何在运行时构建进程的信息，包括<span
style="background-color: yellow">二进制格式ID</span>、<span
style="background-color: yellow">机器语言指令</span>、<span
style="background-color: yellow">程序入口点地址</span>、<span
style="background-color: yellow">数据</span>、<span
style="background-color: yellow">符号表和重定位表</span>、<span
style="background-color: yellow">共享库和动态链接信息</span>以及<span
style="background-color: yellow">其他信息</span>。</p>
<p>　　● 每个程序文件都包含描述可执行文件格式的元信息
(即二进制格式ID)，这使内核能够解析文件的剩余信息。从历史角度，有2个广泛使用的UNIX可执行文件格式：原始的<code>a.out</code>
(汇编器输出) 和之后出现的更复杂的<strong>通用目标文件格式</strong>
(COFF)。如今，Linux和大部分UNIX实现使用的都是更具优势的<strong>可执行链接格式</strong>
(ELF)。</p>
<p>　　● 机器语言指令对程序的算法进行编码。</p>
<p>　　● 程序入口点地址是程序执行时的第1条指令的地址。</p>
<p>　　● 程序文件包含用于初始化变量和字符串的值 (即数据)。</p>
<p>　　●
符号表和重定位表描述程序中的函数和变量的名称和位置。这些表用途广泛，包含调试和运行时符号解析
(即动态链接)。</p>
<p>　　●
程序文件包含的字段列出了程序在运行时所需的共享库和加载这些库的动态链接器的路径名。</p>
<p>　　● 程序文件还包含描述如何构建进程的各种其他信息。</p>
<p>　　1个程序可能会构建多个进程，多个进程可能运行相同的程序。</p>
<p>　　<strong>进程</strong>是由内核定义的抽象实体，系统会分配资源给进程来执行程序。</p>
<p>　　从内核角度，进程由用户空间内存 (包含程序代码和代码使用的变量)
和各种内核数据结构 (维护程序状态信息)
组成。内核数据结构中记录的信息包含与进程关联的各种ID、虚拟内存表、打开的文件描述符表、与信号传递和处理相关的信息、进程资源使用情况和限制、当前工作目录和主机的其他信息。</p>
<p>　　每个进程都有正整数的<strong>进程ID</strong>
(即PID)，用于标识系统中的进程。很多系统调用会使用或返回进程ID。除了<code>init</code>
(进程ID为1)
等少数系统进程，程序和为运行程序创建的进程的进程ID之间没有固定关系。</p>
<p>　　每个进程都有<strong>父进程</strong>，即创建该进程的进程。每个进程的父进程ID属性表示系统中的所有进程的树状关系。进程的父进程也有父进程，依此类推，一直追溯到进程<code>init</code>，它是所有进程的祖先。这个
"族谱" 可以通过命令<code>pstree</code>查看。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的进程ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的父进程ID */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getpid()</code>会返回调用进程的进程ID。系统调用<code>getppid()</code>会返回调用进程的父进程ID。</p>
<p>　　若进程因为父进程终止而成为了<strong>孤儿进程</strong>，则它会被进程<code>init</code>收养
(系统调用<code>getppid()</code>会返回1)。任何进程的父进程都可以通过特定于Linux的文件<code>/proc/PID/status</code>中的字段<code>Ppid</code>查看。</p>
<p>　　Linux内核为进程ID设置的最大值是<span
style="background-color: yellow">32767</span>。当新进程创建时，会为其分配下一个按序可用的进程ID。当达到上限32767时，进程会将进程ID计数器重置为<span
style="background-color: yellow">300</span>，因为数值较小的进程ID会永远分配给系统进程和守护进程。</p>
<p>　　对于Linux
2.4及以下版本，进程ID的最大值32767由内核常量<code>PID_MAX</code>定义。这在Linux
2.6发生了变化，进程ID的默认最大值还是32767，不过该上限可通过特定于Linux的文件<code>/proc/sys/kernel/pid_max</code>修改
(32位平台的最大值是2<sup>15</sup>，64位平台的最大值是2<sup>22</sup>)。</p>
<span id="more"></span>
<p>　　每个C程序都有函数<code>main()</code> (即<span
style="background-color: yellow">主函数</span>)，该函数是程序执行的起点。</p>
<p>　　每个进程都有关联的称为<strong>环境列表</strong>
(简称<strong>环境</strong>)
的字符串数组，其中的元素都定义为<code>name=value</code>的形式。因此，环境变量表示1组用于存储任意信息的名称-值对，其中的名称称为<strong>环境变量</strong>。</p>
<p>　　当进程被创建时，进程会继承父进程的环境列表
(这是一种原始但经常使用的进程间通信方式)。随后，进程可以修改自己的环境列表，这些修改对其他进程不可见。</p>
<p>　　环境变量的常见使用场景之一是shell。通过设置环境变量，shell可以保证对应的值会传递给它创建的用于执行用户命令行的进程。</p>
<p>　　有些库函数允许通过设置环境变量来修改其行为，这允许用户无需修改源码或重新链接对应的库，就能通过这些函数控制应用程序的行为。例如，库函数<code>getopt()</code>的行为会根据环境变量<code>POSIXLY_CORRECT</code>来改变。</p>
<p>　　有时，修改环境列表会很有用。第1个原因是对环境列表的修改对后续创建的子进程都是可见的。第2个原因是环境列表的修改对加载到该进程的内存的新程序是可见的。因此，除了用于进程间通信，环境列表还能用于程序间通信。</p>
<h3 id="进程的内存布局">6.1 进程的内存布局</h3>
<p>　　系统分配给进程的内存包含多个部分，通常称为<strong>段</strong>或<strong>节</strong>，包含<span
style="background-color: yellow">文本段</span>、<span
style="background-color: yellow">已初始化数据段</span>、<span
style="background-color: yellow">未初始化数据段</span>、<span
style="background-color: yellow">栈</span>和<span
style="background-color: yellow">堆</span>。</p>
<p>　　●
文本段包含进程运行的程序的机器语言指令。文本段是只读的，所以进程无法通过指针来修改其中的指令。多个进程可能运行相同的程序，所以文本段是共享的
(程序代码的单个副本可以映射到多个进程的虚拟地址空间)。</p>
<p>　　●
已初始化数据段包含显式初始化的全局变量和静态变量。当程序加载到内存时，会从可执行文件中读取这些变量的值。此外，该段也称为<span
style="background-color: yellow">用户初始化数据段</span>。</p>
<p>　　●
未初始化数据段包含未初始化的全局变量和静态变量。在程序启动前，系统会将该段初始化为0。由于历史原因，该段也称为<code>bss</code>段，源于早期汇编器助记符
"block started by
symbol"。当程序存储在磁盘时，没必要为未初始化的数据分配空间。相反，可执行文件只需要记录未初始化数据段的位置和大小，并且这些空间由程序加载器在运行时分配。因此，才会用未初始化数据段来单独存储未初始化的全局变量和静态变量。此外，该段也称为<span
style="background-color: yellow">0初始化数据段</span>。</p>
<p>　　●
栈是包含栈帧的动态伸缩的段。系统会为所有当前被调用的函数分配栈帧，包含函数局部变量、参数和返回值。在C中，函数参数和局部变量称为<strong>自动变量</strong>，因为当函数创建时会自动创建这些变量。当函数返回时，自动变量会自动释放
(因为对应的栈帧已经被释放)。</p>
<p>　　●
堆是运行时为变量动态分配空间的区域。堆的顶端称为<strong>程序分段点</strong>。</p>
<p>　　可以通过命令<code>size</code>来显示二进制可执行文件的文本段、已初始化数据段和未初始化数据段的大小。</p>
<p>　　<strong>应用程序二进制接口</strong> (ABI)
是用于指定二进制可执行文件在运行时如何与某些服务 (例如，内核或库)
交换信息的1组规则。ABI还指定了哪些寄存器或栈位置用于交换信息和交换的值的含义。一旦编译器使用了特定ABI，生成的二进制可执行文件可以运行在所有提供了该ABI的系统。这与仅保证应用程序源码的可移植性的标准化API
(例如，SUSv3) 形成对比。</p>
<p>　　在之后的内容中，有些库函数会返回指向静态分配的内存的指针，也就是已初始化数据段和未初始化数据段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mem_segments.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> globBuf[<span class="number">65536</span>];         <span class="comment">/* 未初始化数据段 */</span></span><br><span class="line"><span class="type">int</span> primes[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;; <span class="comment">/* 已初始化数据段 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">/* 在square()的栈帧中分配空间 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result; <span class="comment">/* 在square()的栈帧中分配空间 */</span></span><br><span class="line">    result = x * x;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">/* 返回值通过寄存器传递 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doCalc</span><span class="params">(<span class="type">int</span> val)</span> <span class="comment">/* doCalc()的栈帧中分配空间 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The square of %d is %d\n&quot;</span>, val, square(val));</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t; <span class="comment">/* doCalc()的栈帧中分配空间 */</span></span><br><span class="line">        t = val * val * val;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The cube of %d is %d\n&quot;</span>, val, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">/* 在main()的栈帧中分配空间 */</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> key = <span class="number">9973</span>;      <span class="comment">/* 已初始化数据段 */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> mbuf[<span class="number">10240000</span>]; <span class="comment">/* 未初始化数据段 */</span></span><br><span class="line">    <span class="type">char</span> *p;                    <span class="comment">/* 在主函数的栈帧中分配空间 */</span></span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="number">1024</span>);           <span class="comment">/* 指向堆的指针 */</span></span><br><span class="line">    doCalc(key);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了各种C变量所在的段。这里展示的情况是基于编译器不执行优化和程序仅通过栈传递参数。当使用编译器优化后，可能会将频繁使用的变量存储在寄存器中，甚至直接优化到不存在。此外，有些ABI要求函数参数和结果通过寄存器传递。</p>
<p>　　Linux和大多数UNIX实现都提供了全局符号<code>etext</code>、<code>edata</code>和<code>end</code>
(SUSv3并未说明这些符号)。这些符号可用于在程序中获取文本段的第1个字节的地址
(对应<code>etext</code>)、未初始化数据段的第1个字节的地址
(对应<code>edata</code>) 和已初始化数据段的第1个字节的地址
(对应<code>end</code>)。为了使用这些符号，需要显式声明它们：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> etext, edata, end;</span><br></pre></td></tr></table></figure>
<p>　　然后，可以通过<code>&amp;etext</code>来获取文本段的结束地址/已初始化数据段的起始地址。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_06/typical_memory_layout_of_a_process_on_linux.svg" class="">
<p>　　如图所示，这是x86-32架构的各种内存段的布局。程序的命令行参数存储在<code>argv</code>和<code>environ</code>
(可以通过主函数的参数<code>argv</code>访问)。图中所示的十六进制地址可能因内核配置和程序链接选项而异。灰色部分表示程序虚拟地址空间中的无效区域，即这些区域的页表还未创建。</p>
<h3 id="虚拟内存管理">6.2 虚拟内存管理</h3>
<p>　　与大多数现代内核相同，Linux使用<strong>虚拟内存管理</strong>。虚拟内存管理通过充分利用<span
style="background-color: yellow">引用局部性</span>来提升CPU和RAM
(物理内存)
的效率。大多数程序都有2种局部性：<strong>空间局部性</strong>和<strong>时间局部性</strong>。空间局部性是程序<span
style="background-color: yellow">访问最近访问过的内存地址附近的内存地址</span>的趋势
(由于指令和数据结构的顺序处理)。时间局部性是程序<span
style="background-color: yellow">访问最近访问过的内存地址</span>的趋势
(由于循环)。</p>
<p>　　引用局部性使得在程序运行时仅在RAM中维护其部分地址空间成为可能。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_06/overview_of_virtual_memory.svg" class="">
<p>　　程序内存划分为称为<strong>页</strong>的大小固定的单元。相应地，RAM被划分为大小相同的<strong>页帧</strong>。在任何时刻，仅需要程序的部分页驻留在页帧中，这些页称为<strong>驻留集</strong>。程序未使用的页的副本维护在<strong>交换空间</strong>中
(交换空间是磁盘空间中的预留区域，用于补充RAM)，仅在有需要时才会加载到物理内存。当程序引用的页未驻留在物理内存中时，会出现<strong>缺页</strong>，缺页处理函数会将对应的页加载到内存
(在此期间，内核会挂起程序)。</p>
<p>　　对于x86-32，页大小是4096字节。部分其他Linux实现使用的页更大。例如，Alpha的页大小是8192字节，IA-64的页大小是可变的
(默认是16384字节)。可以通过调用<code>sysconf(_SC_PAGESIZE)</code>来获取页大小。</p>
<p>　　为了支持虚拟内存，内核会为每个进程维护<strong>页表</strong>。页表描述了进程的每个页在<strong>虚拟地址空间</strong>
(进程可用的虚拟内存页的集合)
中的位置。页表中的每个条目表示虚拟页在RAM中的位置，或者虚拟页当前在磁盘上。通常，虚拟地址空间中的很多虚拟页都是<span
style="background-color: yellow">未使用</span>的，所以无需为它们维护页表条目。当进程试图访问没有对应页表条目的地址时，会收到信号<code>SIGSEGV</code>。</p>
<p>　　在进程的生命周期内，其有效虚拟地址集不是固定的，因为内核会给进程分配和释放页
(以及页表条目)。当<span
style="background-color: yellow">栈向下增长到临界值</span>，<span
style="background-color: yellow">在堆上分配和释放空间</span>
(通过<code>brk()</code>、<code>sbrk()</code>和<code>malloc()</code>等函数)，<span
style="background-color: yellow">连接和分离System V共享内存区域</span>
(通过函数<code>shmat()</code>和<code>shmdt()</code>) 以及<span
style="background-color: yellow">创建内存映射和取消内存映射</span>时，就会出现这种情况。</p>
<p>　　虚拟内存的实现需要<strong>分页式内存管理单元</strong> (PMMU)
形式的硬件支持。PMMU会将虚拟内存地址引用转换为对应的物理内存地址，并且会在虚拟内存地址对应的页没有驻留在RAM中时通知内核出现了缺页。</p>
<p>　　虚拟内存管理将进程的虚拟地址空间与RAM的物理地址空间分开，这有以下优势：</p>
<p>　　●
进程彼此隔离，并且也与内核隔离，所以进程无法访问其他进程或内核的内存
(使每个进程的页表条目都指向RAM或交换空间中的不同物理页)。</p>
<p>　　● 当有需要时，多个进程可以共享内存
(使不同进程的页表条目指向RAM中的相同物理页)。通常，有2种情况会需要内存共享。第1种情况是多个运行同一程序的进程会共享相同的程序代码副本，这种共享是隐式的。第2种情况是进程通过系统调用<code>shmget()</code>和<code>mmap()</code>来显式地请求共享其他进程的内存区域
(为了进程间通信)。</p>
<p>　　● 有助于实现进程保护
(可以通过标记页表条目来指示对应内容的访问权限)。当多个进程共享RAM中的物理页时，可以为每个进程指定不同的访问权限。</p>
<p>　　● 程序员和工具 (例如，编译器和链接器)
无需关注程序在RAM中物理布局。</p>
<p>　　●
因为仅需要程序的一部分页驻留在内存中，所以程序的加载速度和运行速度更快。此外，这使得进程的虚拟内存大小大于RAM大小成为可能。</p>
<p>　　●
因为每个进程使用了更少的RAM，所以RAM中可以驻留更多的进程。同样，因为增加了CPU执行多个进程的可能性，所以提高了CPU利用率。</p>
<h3 id="栈和栈帧">6.3 栈和栈帧</h3>
<p>　　栈会随着函数调用和返回而伸缩。对于Linux/x86-32
(和大多数其他Linux和UNIX实现)，栈位于高地址处，并且向下增长
(栈的实际方向是硬件实现细节，Linux实现HP
PA-RISC使用的是向上增长的栈)。特殊寄存器<strong>栈指针</strong>总是指向栈顶。当调用函数时，会在栈中分配1个栈帧；当函数返回时，会释放对应的栈帧。</p>
<p>　　从虚拟内存角度，栈的大小会随着栈帧的分配而增加。在大多数实现中，其大小不会随着栈帧的释放而减少，对应的内存会直接在分配栈帧时重新使用。"栈会随着栈帧的分配和释放而伸缩"
是从逻辑角度考虑从栈中创建和删除栈帧。</p>
<p>　　<span
style="background-color: yellow">内核栈</span>是系统为每个进程在内核内存中维护的内存区域，用于系统调用执行期间内部函数调用的栈。</p>
<p>　　除了栈和内核栈之外，还有<span
style="background-color: yellow">用户栈</span>，其中包含自动变量和调用链信息。每个函数会使用特定的CPU寄存器
(例如，指向下一条待执行的机器语言指令的程序计数器)。当调用函数时，这些寄存器的副本会存储在被调函数的栈帧中，以便于在函数返回时恢复调用函数的寄存器值。</p>
<p>　　因为函数可以调用函数，所以栈中可以有多个栈帧
(若函数递归调用自己，则栈中会出现多个该函数的栈帧)。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_06/example_of_a_process_stack.svg" class="">
<p>　　如图所示，这是<code>mem_segments.c</code> (见6.1)
的函数<code>square</code>执行期间栈的情况。</p>
<h3 id="命令行参数">6.4 命令行参数</h3>
<p>　　当执行程序时，命令行参数 (shell解析的单个词语)
可以通过主函数的参数访问。第1个参数是<code>int argc</code>，该参数是命令行参数的数量。第2个参数是<code>char *argv[]</code>，该参数是数组，除了最后1个元素是空指针之外，其他元素都是以字符<code>\0</code>结尾的字符串。<code>argv[0]</code>通常是程序名。</p>
<p>　　<code>argv[0]</code>可用于实现1个有用的技巧：先创建多个引用同一程序的链接
(即名称)，然后在程序中根据<code>argv[0]</code>的值来执行不同的操作
(例如，命令<code>gzip</code>、<code>gunzip</code>和<code>zcat</code>，它们引用的文件相同)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* necho.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, j, argv[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_06/values_of_argc_and_argv_for_the_command_necho_hello_world.svg" class="">
<p>　　这个示例会以每行1个参数的形式回显命令行参数。</p>
<p>　　因为<code>argv</code>以<code>NULL</code>结尾，所以可以通过如下方式来迭代命令行参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> **p;</span><br><span class="line"><span class="keyword">for</span> (p = argv; *p; p++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　参数<code>argc</code>和<code>argv</code>仅限于主函数。若需要在其他函数中使用命令行参数，则需要将<code>argv</code>作为参数传递或使用指向<code>argv</code>的全局指针。</p>
<p>　　任何进程的命令行参数都可以通过特定于Linux的文件<code>/proc/PID/cmdline</code>来获取，其中的参数以字符<code>\0</code>结尾
(进程可以通过文件<code>/proc/self/cmdline</code>来访问自己的命令行参数)。</p>
<p>　　glibc提供的全局变量<code>program_invocation_name</code>和<code>program_invocation_short_name</code>可用于获取执行程序的使用的程序名
(<code>argv[0]</code>)。前者提供了用于执行程序的完整路径名，后者则删除了目录前缀。需要使用这2个全局变量需要定义宏<code>_GNU_SOURCE</code>，这2个全局变量就可以通过头文件<code>error.h</code>获取。</p>
<p>　　如6.1中的图所示，数组<code>argv</code>和<code>environ</code>以及它们最初指向的字符串占据单独的内存区域。该区域的容量上限可以存储在该区域。根据SUSv3，该上限可以通过常量<code>ARG_MAX</code>或调用<code>sysconf(_SC_ARG_MAX)</code>来获取。SUSv3还要求<code>ARG_MAX</code>的最小值是<code>_POSIX_ARG_MAX</code>
(即4096)。大部分UNIX实现允许更高的上限。SUSv3并未说明实现在计算<code>ARG_MAX</code>是否需要包含开销字节
(即结尾的字符<code>\0</code>、对齐字节以及<code>argv</code>和<code>environ</code>数组的指针)。</p>
<p>　　从历史角度，Linux的<code>ARG_MAX</code>固定为32页
(即Linux/x86-32上的131072字节)，并且包括开销字节。从内核2.6.23开始，数组<code>argv</code>和<code>environ</code>所处内存区域的限制可以通过资源限制<code>RLIMIT_STACK</code>来控制，并且允许更大的限制，该限制计算为调用<code>execve()</code>时资源限制<code>RLIMIT_STACK</code>的软限制的<span
class="math inline">\(\frac{1}{4}\)</span>。</p>
<p>　　很多程序都是通过库函数<code>getopt()</code>来解析命令行选项
(即以连字符<code>-</code>开头的参数)。</p>
<h3 id="环境列表">6.5 环境列表</h3>
<p>　　对于大多数shell，可以通过命令<code>export</code>来为添加环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">SHELL=/bin/bash</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SHELL</span></span><br></pre></td></tr></table></figure>
<p>　　第1行命令会创建变量<code>SHELL</code>，第2行命令会将该变量添加到shell进程的环境列表中。对于<code>bash</code>和<code>ksh</code>，这2行命令可以缩写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SHELL=/bin/bash</span></span><br></pre></td></tr></table></figure>
<p>　　对于<code>csh</code>，可以通过命令<code>setenv</code>来设置环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">setenv SHELL /bin/bash</span></span><br></pre></td></tr></table></figure>
<p>　　环境变量可以通过命令<code>unset</code>删除
(<code>csh</code>中的命令<code>unsetenv</code>)。</p>
<p>　　对于<code>sh</code>及其继承者
(例如，<code>bash</code>和<code>ksh</code>)，以下语法可用于在执行程序时为执行程序的进程创建环境变量
(不会影响shell)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">NAME=value program1 program2</span></span><br></pre></td></tr></table></figure>
<p>　　命令<code>printenv</code>可用于获取当前环境列表。</p>
<p>　　任何进程的环境列表都可以通过特定于Linux的文件<code>/proc/PID/environ</code>来获取
(形如<code>NAME=value</code>，并且以字符<code>\0</code>结尾)。</p>
<h4 id="在程序中访问环境列表">6.5.1 在程序中访问环境列表</h4>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_06/example_of_process_environment_list_data_structures.svg" class="">
<p>　　在C程序中，环境列表可以通过全局变量<code>char **environ</code>
(C运行时启动代码会定义该变量，并且会将环境列表的地址赋值给它)。与<code>argv</code>类似，<code>environ</code>是数组，除了最后1个元素是空指针之外，其他元素都是以字符<code>\0</code>结尾的字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* display_env.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> **ep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ep = environ; *ep; ep++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(*ep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过访问<code>environ</code>来列出进程的所有环境变量，其输出与命令<code>printenv</code>的相同。</p>
<p>　　还可以通过声明主函数的第3个参数来访问环境列表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span></span><br></pre></td></tr></table></figure>
<p>　　参数<code>envp</code>的用法与<code>environ</code>的相同，但仅限于主函数。尽管很多UNIX实现都支持该特性，但SUSv3未说明该特性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 环境变量存在时返回对应值，环境变量不存时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　对于给定名称的环境变量，<code>getenv()</code>会返回对应值
(字符串)。若环境变量不存在，则返回<code>NULL</code>。</p>
<p>　　● SUSv3明确规定，应用程序<span
style="background-color: yellow">不应该</span>修改<code>getenv()</code>返回的字符串，因为该字符串实际上就是环境列表的一部分
(对于大部分实现)。</p>
<p>　　● SUSv3允许<code>getenv()</code>返回的字符串使用静态分配的缓冲区
(可能被后续的<code>getenv()</code>、<code>setenv()</code>、<code>putenv()</code>和<code>unsetenv()</code>调用覆盖)。尽管glibc的<code>getenv()</code>实现不以这种方式使用静态缓冲区，但为了保证可移植性，还是应该在后续调用这些函数前将<code>getenv()</code>返回的字符串复制到其他位置。</p>
<h4 id="修改环境列表">6.5.2 修改环境列表</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>; <span class="comment">/* 成功时返回0，出错时返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>putenv()</code>会创建环境变量或修改现有的环境变量
(若存在)。参数<code>string</code>是形如<code>name=value</code>的字符串。在调用<code>putenv()</code>后，<code>string</code>会成环境变量的一部分
(并非复制<code>string</code>，而是直接将其赋值给环境列表中的元素)，即后续对<code>string</code>的修改会直接应用到环境变量。因此，<code>string</code>不能是自动变量
(当定义该变量的函数返回后，存储自动变量的内存区域可能会被覆盖)。若<code>putenv()</code>出错，则返回<span
style="background-color: yellow">非0值</span>。</p>
<p>　　glibc的<code>putenv()</code>实现提供了非标准扩展。若<code>string</code>不包含等号<code>=</code>，则会从环境列表中删除名为<code>string</code>的环境变量。</p>
<p>　　函数<code>setenv()</code>会通过为形如<code>name=value</code>的字符串分配内存缓冲区来创建环境变量，然后将参数<code>name</code>和<code>value</code>复制到该缓冲区
(不同于<code>putenv()</code>，后续对<code>name</code>和<code>value</code>的修改不会应用到环境变量，所以这2个参数可以是自动变量)。只有当参数<code>overwrite</code>非0时，才会覆盖现有的环境变量。</p>
<p>　　函数<code>unsetenv()</code>会删除名为<code>name</code>的环境变量。与<code>setenv()</code>相同，<code>name</code>不应该包含等号。</p>
<p>　　<code>setenv()</code>和<code>unsetenv()</code>源于BSD，它们的使用率不如<code>putenv()</code>。POSIX.1和SUSv2没有说明这2个函数，但SUSv3详细说明了它们。对于glibc
2.2.2之前的版本，<code>unsetenv()</code>的返回值类型是<code>void</code>，这也是该函数在BSD中的返回值类型，并且部分UNIX实现依然如此。</p>
<p>　　有时，可能需要清空环境列表，可以直接将<code>NULL</code>赋值给<code>environ</code>，这也是库函数<code>clearenv()</code>执行的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE <span class="comment">/* 或#define _SVID_SOURCE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clearenv</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 成功时返回0，出错时返回非0值 */</span></span><br></pre></td></tr></table></figure>
<p>　　在部分情况下，<code>setenv()</code>和<code>clearenv()</code>一起使用会导致内存泄漏。<code>setenv()</code>会分配内存缓冲区，并会将其作为环境变量的一部分。调用<code>clearenv()</code>时，不会释放缓冲区。在实际中，通常不会这样使用，因为一般仅会在开始时调用<code>clearenv()</code>，或者用于清空继承的环境列表。</p>
<p>　　SUSv3并未说明<code>clearenv()</code>，但很多UNIX实现都提供了该函数。SUSv3规定，若应用程序直接修改<code>environ</code>
(就像<code>clearenv()</code>所做的那样)，则<code>setenv()</code>、<code>unsetenv()</code>和<code>getenv()</code>的行为将会是未定义的
(防止符合规范的应用程序通过修改环境列表来完全控制实现环境变量的数据结构)。SUSv3要求应用程序只能通过先获取所有环境变量，再对其逐个调用<code>unsetenv()</code>的方式来清空环境列表。</p>
<h4 id="示例程序">6.5.3 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">char</span> **ep;</span><br><span class="line"></span><br><span class="line">    clearenv();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (putenv(argv[j]) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;putenv: %s&quot;</span>, argv[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setenv(<span class="string">&quot;GREET&quot;</span>, <span class="string">&quot;Hello world&quot;</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setenv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsetenv(<span class="string">&quot;BYE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ep = environ; *ep; ep++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(*ep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何操作环境变量。在第1次清空环境列表后，该程序会创建命令行参数指定的环境变量。然后，创建环境变量<code>GTEET</code>
(若不存在)，并且删除环境变量<code>BYE</code>。最后，打印当前环境列表。</p>
<h3 id="非本地跳转">6.6 非本地跳转</h3>
<p>　　库函数<code>setjmp()</code>和<code>longjmp()</code>可用于执行<strong>非本地跳转</strong>
(跳转目标在当前执行的函数之外)。</p>
<p>　　与其他编程语言相同，C提供了跳转语句。跳转语句更容易使程序难以阅读和维护，但有时也会使程序更高效和简洁。</p>
<p>　　无法从当前执行的函数跳转到其他函数是C跳转的限制之一。但是，该功能有时可能很有用。考虑如下错误处理场景：在多层嵌套的函数执行期间出错，处理方法是放弃当前执行的任务，经过多个函数返回，然后执行更高层的函数
(甚至高于主函数)。为了完成这些，需要让每个函数都返回合适的返回值。这是完全合理的，并且这通常是理想的处理方法。但是，在有些情况下，直接从嵌套函数的中间跳转到调用它的函数
(调用函数、调用函数的调用函数，依此类推)
会让代码更简洁，这正是<code>setjmp()</code>和<code>longjmp()</code>提供的功能。</p>
<p>　　对于C，无法在函数之间跳转的原因是所有的C函数都在相同的作用域
(标准C中没有函数声明的嵌套，尽管gcc支持这种方式)。因此，对于函数X和Y，编译器无法得知在调用函数Y时函数X的栈帧是否在栈中
(即无法得知能否从函数Y跳转到函数X)。对于Pascal等编程语言，允许函数声明嵌套和从嵌套函数跳转到包含它的函数，并且函数的静态作用域允许编译器确定一些动态作用域的信息。若函数Y在词法上嵌套在函数X中，则编译器会知道当调用函数Y时函数X的栈帧必定在栈中，并且能生成从函数Y跳转函数X的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>; <span class="comment">/* 第1次调用时返回0，longjmp()导致的返回返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure>
<p>　　调用<code>setjmp()</code>会为后续的<code>longjmp()</code>执行的跳转设置目标
(即调用<code>setjmp()</code>的位置)。第1次调用<code>setjmp()</code>会返回0。在调用<code>longjmp()</code>后，<code>setjmp()</code>会像第2次调用它一样返回，返回值是<code>longjmp()</code>的参数<code>val</code>。通过将<code>val</code>指定为不同的值，就可以区分跳转点。当<code>val</code>被指定为0时，为了区分第1次调用<code>setjmp()</code>的返回值，<code>longjmp()</code>会自动将其替换为<span
style="background-color: yellow">1</span>。</p>
<p>　　<code>setjmp()</code>可以将进程的当前环境列表存储在参数<code>env</code>中，<code>longjmp()</code>必须将参数<code>env</code>指定为相同的值。因为<code>setjmp()</code>的调用和<code>longjmp()</code>的调用在不同的函数，所以<code>env</code>应该被声明为全局变量或作为函数参数传递。</p>
<p>　　参数<code>env</code>还存储着调用<code>setjmp()</code>时<span
style="background-color: yellow">程序计数器</span>和<span
style="background-color: yellow">栈指针</span>的副本。这些信息允许后续的<code>longjmp()</code>调用执完成2个关键的步骤：</p>
<p>　　●
从栈中删除<code>longjmp()</code>调用之间以及<code>setjmp()</code>调用之前的无关函数的栈帧。该过程有时称为<span
style="background-color: yellow">展开栈</span>，通过将栈指针重置为<code>env</code>中存储的值来完成。</p>
<p>　　●
通过重置程序计数器来让程序从第1次调用<code>setjmp()</code>的位置执行。同样，这也是通过<code>env</code>中存储的值来完成。</p>
<p>　　若跳转语句会让程序变得难以阅读，则非本地跳转会严重加剧这一点，因为非本地跳转能够在任意2个函数之间进行控制转移。因此，应该尽量不使用非本地跳转。</p>
<h4 id="示例程序-1">6.6.1 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* longjmp.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    longjmp(env, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> argc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        longjmp(env, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (setjmp(env))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Calling f1() after initial setjmp()\n&quot;</span>);</span><br><span class="line">        f1(argc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We jumped back from f1()\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We jumped back from f2()\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是<code>setjmp()</code>和<code>longjmp()</code>的用法示例。该程序会在第1次调用<code>setjmp()</code>时设置跳转目标。后续的<code>switch</code>语句会根据<code>setjmp()</code>返回值来执行不同的操作。若返回值是0
(表示第1次调用<code>setjmp()</code>)，则会调用<code>f1()</code>，而<code>f1()</code>会根据<code>argc</code>来调用<code>longjmp()</code>或<code>f2()</code>。若执行到<code>f2()</code>，则也会调用<code>longjmp()</code>。</p>
<h4 id="setjmp的限制">6.6.2 <code>setjmp()</code>的限制</h4>
<p>　　SUSv3和C99规定，只能在以下上下文中调用<code>setjmp()</code>：</p>
<p>　　● 作为选择或迭代语句
(例如，<code>if</code>、<code>switch</code>和<code>while</code>)
的完整控制表达式。</p>
<p>　　●
作为一元运算符<code>!</code>的操作数，其结果表达式是选择或迭代语句的完整控制表达式。</p>
<p>　　● 作为比较操作
(例如，<code>==</code>、<code>!=</code>和<code>&lt;</code>)
的一部分，其他操作数是整数常量表达式，并且结果表达式是选择或迭代语句的完整控制表达式。</p>
<p>　　● 作为未嵌入到较大表达式中的独立函数调用。</p>
<p>　　显然，赋值语句并不在以上范围，<code>s = setjmp(env)</code>不符合规范。</p>
<p>　　若将<code>setjmp()</code>作为常规函数来实现，则无法保证有足够的信息来存储封闭表达式所使用的所有寄存器和临时栈位置的值
(用于后续调用<code>longjmp()</code>时恢复)。因此，仅允许在不需要临时存储的表达式中调用<code>setjmp()</code>。</p>
<h4 id="longjmp滥用">6.6.3 <code>longjmp()</code>滥用</h4>
<p>　　若将缓存区<code>env</code>声明为全局变量，则可能会按以下步骤执行：</p>
<p>　　1)
调用函数<code>x()</code>，<code>x()</code>会通过<code>setjmp()</code>来在全局变量<code>env</code>中设置跳转目标。</p>
<p>　　2) 从<code>x()</code>返回。</p>
<p>　　3)
调用函数<code>y()</code>，<code>y()</code>会通过<code>env</code>来调用<code>longjmp()</code>。</p>
<p>　　这是很严重的错误，因为无法将已经返回的函数作为跳转目标。在这种情况下，<code>longjmp()</code>会试图展开栈来回到已经不存在的栈帧。程序崩溃是最好的情况。但是，根据栈的状态，其他可能的结果包括无限调用-返回循环和程序的行为如同其真的从已经结束的函数返回
(对于多线程程序，类似的滥用行为是<code>setjmp()</code>的调用和<code>longjmp()</code>的调用在不同的线程)。</p>
<p>　　SUSv3规定，若在嵌套的信号处理函数中调用<code>longjmp()</code>
(即在信号处理函数中调用其他信号处理函数)，则程序的行为将会是未定义的。</p>
<h4 id="编译器优化问题">6.6.4 编译器优化问题</h4>
<p>　　若使用编译器优化，则可能会改变程序的指令执行顺序和将不使用编译器优化时存储在RAM的变量存储在寄存器中。这些优化通常依赖于反映程序词法结构的运行时控制流。因为通过<code>setjmp()</code>和<code>longjmp()</code>执行的跳转操作在运行时生成和执行，并且不会反映在程序词法结构上，所以编译器优化器不会考虑它们。此外，部分ABI实现的语义要求<code>longjmp()</code>恢复调用<code>setjmp()</code>时存储的寄存器副本。这表示<code>longjmp()</code>可能会让优化后的变量最终取得错误的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* setjmp_vars.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doJump</span><span class="params">(<span class="type">int</span> nvar, <span class="type">int</span> rvar, <span class="type">int</span> vvar)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inside doJump(): nvar=%d rvar=%d vvar=%d\n&quot;</span>, nvar, rvar, vvar);</span><br><span class="line">    longjmp(env, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nvar;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> rvar; <span class="comment">/* 尽可能分配在寄存器中 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> vvar;</span><br><span class="line"></span><br><span class="line">    nvar = <span class="number">111</span>;</span><br><span class="line">    rvar = <span class="number">222</span>;</span><br><span class="line">    vvar = <span class="number">333</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setjmp(env) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* setjmp()后执行 */</span></span><br><span class="line">        nvar = <span class="number">777</span>;</span><br><span class="line">        rvar = <span class="number">888</span>;</span><br><span class="line">        vvar = <span class="number">999</span>;</span><br><span class="line">        doJump(nvar, rvar, vvar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* longjmp()后执行 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After longjmp(): nvar=%d rvar=%d vvar=%d\n&quot;</span>, nvar, rvar, vvar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　当正常编译这个程序时，会得到预期的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -o setjmp_vars setjmp_vars.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./setjmp_vars</span></span><br><span class="line">Inside doJump(): nvar=777 rvar=888 vvar=999</span><br><span class="line">After longjmp(): nvar=777 rvar=888 vvar=999</span><br></pre></td></tr></table></figure>
<p>　　但是，当使用编译器优化后，会得到意料之外的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -O -o setjmp_vars setjmp_vars.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./setjmp_vars</span></span><br><span class="line">Inside doJump(): nvar=777 rvar=888 vvar=999</span><br><span class="line">After longjmp(): nvar=111 rvar=222 vvar=999</span><br></pre></td></tr></table></figure>
<p>　　在<code>longjmp()</code>执行完成后，<code>nvar</code>和<code>rvar</code>的值重置为调用<code>setjmp()</code>之前的值。这是因为编译器执行的代码重组由于<code>longjmp()</code>而混乱。所有可能作为优化对象的局部变量
(通常指指针、<code>char</code>、<code>int</code>、<code>float</code>和<code>long</code>)
都可能会遇到这个问题。</p>
<p>　　可以通过关键字<code>volatile</code>
(告诉编译器不对该变量使用优化)
来解决这个问题。<code>vvar</code>就声明为<code>volatile</code>，所以它的值是正确的。</p>
<p>　　因为不同编译器使用的优化类型不同，为了保证可移植性，应该将调用<code>setjmp()</code>的函数中的可能成为优化对象的局部变量都声明为<code>volatile</code>。</p>
<p>　　若对GNU C编译器使用选项<code>-Wextra</code>
(额外的警告)，则会生成如下警告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -Wall -Wextra -O -o setjmp_vars setjmp_vars.c</span></span><br><span class="line">setjmp_vars.c: In function &#x27;main&#x27;:</span><br><span class="line">setjmp_vars.c:16: warning: variable &#x27;nvar&#x27; might be clobbered by &#x27;longjmp&#x27; or &#x27;vfork&#x27;</span><br><span class="line">setjmp_vars.c:17: warning: variable &#x27;rvar&#x27; might be clobbered by &#x27;longjmp&#x27; or &#x27;vfork&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第11章 系统限制和选项</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_11/</url>
    <content><![CDATA[<p>　　每个UNIX实现都对各种系统特性和资源施加了限制，并且提供了/未提供各种标准中定义的选项。但是，限制和选项可能因UNIX实现、运行时环境或文件系统的不同而不同。</p>
<p>　　系统限制和选择可能会影响程序的行为，所以可移植应用程序需要方法来确定限制值和支持的选项。C标准和SUSv3提供了2种用于获取这些信息的方法：</p>
<p>　　●
有些限制和选项可以在编译时确定。例如，<code>int</code>的最大值由硬件架构和编译器设计选择决定。此类限制可能记录在头文件中。</p>
<p>　　●
其他限制和选项在运行时可能有所不同。SUSv3定义了函数<code>sysconf()</code>、<code>pathconf()</code>和<code>fpathconf()</code>来确定这些限制和选项的值。</p>
<p>　　对于SUSv3详细说明的每个限制，SUSv3都要求所有实现支持该限制的上限的<span
style="background-color: yellow">最小值</span>，该最小值通常是定义在头文件<code>limits.h</code>中的带有前缀<code>_POSIX_</code>的常量，并且
(通常)
带有后缀<code>_MAX</code>，所以其名称格式是<code>_POSIX_XXX_MAX</code>。
有时，会使用限制的下限的<span
style="background-color: yellow">最大值</span>，并且其名称带有后缀<code>_MIN</code>。</p>
<p>　　每个限制都有1个与上限的最小值名称对应的名称，其名称格式为<code>XXX_MAX</code>。实现可以在<code>limits.h</code>中定义名称为<code>XXX_MAX</code>的常量来指定的限制的上限，若定义了该常量，则其值必须不小于上限的最小值。</p>
<p>　　除了详细说明系统资源的限制之外，SUSv3还详细说明了UNIX实现可能支持的各种选项，例如，实时信号、POSIX共享内存、作业控制和POSIX线程。SUSv3仅要求实现支持其中的少部分选项。此外，SUSv3允许实现提供在编译时和运行时检测是否支持特定选项的方法。</p>
<p>　　实现可以通过在头文件<code>unistd.h</code>中定义常量来表示它是否支持对应的SUSv3选项。这类常量都带有表示对应标准的前缀
(例如，<code>_POSIX_</code>和<code>_XOPEN_</code>)，其值如下：</p>
<p>　　● 定义为-1表示<span
style="background-color: yellow">不支持</span>对应的选项。实现不能定义该选项相关的头文件、数据类型和函数接口。应用程序可能需要使用<code>#if</code>语句来处理这种可能性。</p>
<p>　　● 定义为0表示<span
style="background-color: yellow">可能支持</span>对应的选项。应用程序必须在运行时确定实现是否支持该选项。</p>
<p>　　● 定义为正值表示<span
style="background-color: yellow">支持</span>对应的选项。实现会定义该选项相关的头文件、数据类型和函数接口，并且其行为如同SUSv3所说。在很多情况下，SUSv3要求该值为<code>200112L</code>，对应SUSv3获批的年份和月份。与之类似，SUSv4要求该值为<code>200809L</code>。</p>
<span id="more"></span>
<h3 id="系统限制">11.1 系统限制</h3>
<p>　　SUSv3将限制分为<strong>运行时不变值</strong>、<strong>路径名可变值</strong>和<strong>运行时可增加值</strong>。</p>
<p>　　●
若<code>limits.h</code>中定义了运行时不变值，则其值是固定的。尽管如此，该值可能是不确定的
(因为取决于可用的内存空间等原因)，此时，<code>limits.h</code>中的定义无效。对于这种情况，应用程序可以通过<code>sysconf()</code>来获取其值。例如，运行时不变值<code>MQ_PRIO_MAX</code>定义了POSIX消息队列中的消息的优先级。SUSv3定义了常量<code>_POSIX_MQ_PRIO_MAX</code>来作为该限制的最小值，并将其指定为32。可以通过调用<code>sysconf(_SC_MQ_PRIO_MAX)</code>来在运行时获取该限制的上限值。</p>
<p>　　● 路径名可变值是是与路径名 (例如，文件、目录和终端)
相关的限制。此类限制可能是常量，也可能因文件系统而异。对于因路径名而异的路径名可变值，应用程序可以使用<code>pathconf()</code>和<code>fpathconf()</code>来获取其值。例如，路径名可变值<code>NAME_MAX</code>定义了特定文件系统中的文件名的最大大小。SUSv3定义了常量<code>_POSIX_NAME_MAX</code>来作为该限制的最小值，并将其指定为14。可以调用<code>pathconf(directory_path, _PC_NAME_MAX)</code>来获取该限制的上限值，其中<code>directory_path</code>是文件系统中的目录。</p>
<p>　　●
对于特定实现，运行时可增加值是上限的固定最小值，并且所有运行该实现的系统提供的此类限制的上限必须不小于该最小值。但是，特定系统可以在运行时增加此类限制的上限值。例如，运行时可增加值<code>NGROUPS_MAX</code>定义了进程的辅助组ID的最大数量。SUSv3定义了常量<code>_POSIX_NGROUPS_MAX</code>来作为该限制的最小值。可以调用<code>sysconf(_SC_NGROUPS_MAX)</code>来在运行时获取该限制的上限值。</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 28%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr>
<th>限制名 (<code>limits.h</code>)</th>
<th><span>最小值</span></th>
<th><code>sysconf()</code>/<code>pathconf()</code>名
(<code>unistd.h</code>)</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ARG_MAX</code></td>
<td>4096</td>
<td><code>_SC_ARG_MAX</code></td>
<td>可以提供给<code>exev()</code>的参数和环境列表的最大字节数</td>
</tr>
<tr>
<td>无</td>
<td>无</td>
<td><code>_SC_CLK_TCK</code></td>
<td><code>times()</code>的测量单位</td>
</tr>
<tr>
<td><code>LOGIN_NAME_MAX</code></td>
<td>9</td>
<td><code>_SC_LOGIN_NAME_MAX</code></td>
<td>登录名的最大字节数 (包括结尾的字符<code>\0</code>)</td>
</tr>
<tr>
<td><code>OPEN_MAX</code></td>
<td>20</td>
<td><code>_SC_OPEN_MAX</code></td>
<td>进程能够同时打开的文件描述符的最大数量
(比可用描述符的最大值大1)</td>
</tr>
<tr>
<td><code>NGROUPS_MAX</code></td>
<td>8</td>
<td><code>_SC_NGROUPS_MAX</code></td>
<td>进程的辅助组ID的最大数量</td>
</tr>
<tr>
<td>无</td>
<td>1</td>
<td><code>_SC_PAGESIZE</code></td>
<td>虚拟内存页的大小 (同<code>_SC_PAGE_SIZE</code>)</td>
</tr>
<tr>
<td><code>RTSIG_MAX</code></td>
<td>8</td>
<td><code>_SC_RTSIG_MAX</code></td>
<td>不重复实时信号的最大数量</td>
</tr>
<tr>
<td><code>SIGQUEUE_MAX</code></td>
<td>32</td>
<td><code>_SC_SIGQUEUE_MAX</code></td>
<td>排队的实时信号的最大数量</td>
</tr>
<tr>
<td><code>STREAM_MAX</code></td>
<td>8</td>
<td><code>_SC_STREAM_MAX</code></td>
<td>可以同时打开的stdio流的最大数量</td>
</tr>
<tr>
<td><code>NAME_MAX</code></td>
<td>14</td>
<td><code>_PC_NAME_MAX</code></td>
<td>文件名的最大字节数 (<span
style="background-color: yellow">不包括</span>结尾的字符<code>\0</code>)</td>
</tr>
<tr>
<td><code>PATH_MAX</code></td>
<td>256</td>
<td><code>_PC_PATH_MAX</code></td>
<td>路径名的最大字节数 (包括结尾的字符<code>\0</code>)</td>
</tr>
<tr>
<td><code>PIPE_BUF</code></td>
<td>512</td>
<td><code>_PC_PIPE_BUF</code></td>
<td>能以原子方式写入到有名/无名管道的最大字节数</td>
</tr>
</tbody>
</table>
<p>　　上表列出了部分与本书相关的SUSv3定义的限制。第1列是限制名，这些限制名可能作为常量定义在<code>limits.h</code>中。第2列是SUSv3定义的限制的上限的最小值
(也定义在<code>limits.h</code>中)，这些最小值通常都是带有前缀<code>_POSIX_</code>的常量
(例如，SUSv3定义了常量<code>_POSIX_RTSIG_MAX</code>来作为限制<code>RTSIG_MAX</code>的最小值，并将其指定为8)。第3列是指定给<code>sysconf()</code>或<code>pathconf()</code>来检索限制的常量名
(带有前缀<code>_SC_</code>的常量用于<code>sysconf()</code>，带有前缀<code>_PC_</code>的常量用于<code>pathconf()</code>和<code>fpathconf()</code>)。</p>
<p>　　●
函数<code>getdtablesize()</code>是获取限制<code>OPEN_MAX</code>的值的已过时的替代方法。SUSv2详细说明了该函数
(标记为LEGACY)，但SUSv3没有说明该函数。</p>
<p>　　●
函数<code>getpagesize()</code>是获取限制<code>_SC_PAGESIZE</code>的值的已过时的替代方法。SUSv2详细说明了该函数
(标记为LEGACY)，但SUSv3没有说明该函数。</p>
<p>　　●
头文件<code>stdio.h</code>中定义的常量<code>FOPEN_MAX</code>等同于<code>STREAM_MAX</code>。</p>
<p>　　●
<code>NAME_MAX</code>不包含结尾的字符<code>\0</code>，但<code>PATH_MAX</code>包含结尾的字符<code>\0</code>。这种不一致修复了POSIX.1中的早期的不一致
(无法确定<code>PATH_MAX</code>是否包含结尾的字符<code>\0</code>)。将<code>PATH_MAX</code>定义为包含结尾的字符<code>\0</code>表示应用程序会为符合规范的路径名分配<code>PATH_MAX</code>字节。</p>
<p>　　对于shell，可以使用命令<code>getconf</code>来获取其限制和选项。该命令的通用格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getconf variable-name [ pathname ]</span></span><br></pre></td></tr></table></figure>
<p>　　参数<code>variable-name</code>是目标限制名
(SUSv3定义的限制名)。若目标限制与路径名相关，则必须指定第2个参数<code>pathname</code>。</p>
<h3 id="在运行时检索系统限制">11.2 在运行时检索系统限制</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">sysconf</span><span class="params">(<span class="type">int</span> name)</span>; <span class="comment">/* 成功时返回name指定的限制的值，限制不确定或出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sysconf()</code>会返回参数<code>name</code>
(<code>unistd.h</code>中定义的带有前缀<code>_SC_</code>的常量)
指定的限制的值。若限制不确定或出错
(只会出现错误<code>EINVAL</code>，表示<code>name</code>无效)，则返回-1。为了区分这2种情况，需要在调用前先将<code>error</code>设置为0，然后在调用完后判断<code>errno</code>。</p>
<p>　　<code>sysconf()</code>的返回值是长整型。SUSv3规定，<code>sysconf()</code>的返回值可以是字符串，但由于实现和使用的复杂性，没有实现这样做。</p>
<p>　　SUSv3要求<code>sysconf()</code>的目标限制在该函数的调用进程的生命周期内是常量。但是，Linux中有几个合理的例外。进程可以在<code>sysconf()</code>返回限制值后调用<code>setrlimit()</code>来修改限制<code>RLIMIT_NOFILE</code>
(决定进程能够同时打开的文件描述符的最大数量，对应<code>_SC_OPEN_MAX</code>)、<code>RLIMIT_NPROC</code>
(SUSv3没有说明的限制，决定每个用户通过该进程可以创建的进程数，对应<code>_SC_CHILD_MAX</code>)
和<code>RLIMIT_STACK</code> (仅限于Linux
2.6.23及以上版本，决定进程的命令行参数和环境列表的最大字节数，对应<code>_SC_ARG_MAX</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_sysconf.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印msg加上name指定的限制的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @param name 限制名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sysconfPrint</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">int</span> name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> lim;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    lim = sysconf(name);</span><br><span class="line">    <span class="keyword">if</span> (lim != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %ld\n&quot;</span>, msg, lim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s (indeterminate)\n&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sysconf %s&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    sysconfPrint(<span class="string">&quot;_SC_ARG_MAX: &quot;</span>, _SC_ARG_MAX);</span><br><span class="line">    sysconfPrint(<span class="string">&quot;_SC_LOGIN_NAME_MAX: &quot;</span>, _SC_LOGIN_NAME_MAX);</span><br><span class="line">    sysconfPrint(<span class="string">&quot;_SC_OPEN_MAX: &quot;</span>, _SC_OPEN_MAX);</span><br><span class="line">    sysconfPrint(<span class="string">&quot;_SC_NGROUPS_MAX: &quot;</span>, _SC_NGROUPS_MAX);</span><br><span class="line">    sysconfPrint(<span class="string">&quot;_SC_PAGESIZE: &quot;</span>, _SC_PAGESIZE);</span><br><span class="line">    sysconfPrint(<span class="string">&quot;_SC_RTSIG_MAX: &quot;</span>, _SC_RTSIG_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过<code>sysconf()</code>来打印各种系统限制。</p>
<h3 id="在运行时检索文件相关的限制">11.3 在运行时检索文件相关的限制</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回name指定的限制的值，限制不确定或出错时返回-1 */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">pathconf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> name)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>pathconf()</code>和<code>fpathconf()</code>都会返回参数<code>name</code>
(<code>unistd.h</code>中定义的带有前缀<code>_PC_</code>的常量)
指定的限制的值。两者唯一的区别是指定文件或目录的方式，<code>pathconf()</code>指定的是路径名，<code>fpathconf()</code>指定的是文件描述符。</p>
<p>　　除了11.1介绍的限制之外，以下限制可用于这2个函数：</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr>
<th>常量名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_PC_NAME_MAX</code></td>
<td>对于目录，这将为该目录下的文件生成1个值
(未指定其他文件类型的行为)</td>
</tr>
<tr>
<td><code>_PC_PATH_MAX</code></td>
<td>对于目录，这将生成此目录的相对路径名的最大长度
(未指定其他文件类型的行为)</td>
</tr>
<tr>
<td><code>_PC_PIPE_BUF</code></td>
<td>对于有名/无名管道，这将生成1个适用于引用的文件的值；对于目录，该值适用于该目录下创建的有名管道
(未指定其他文件类型的行为)</td>
</tr>
</tbody>
</table>
<p>　　当这2个函数返回-1时，处理方法与<code>sysconf()</code>的类似。</p>
<p>　　SUSv3不要求<code>pathconf()</code>和<code>fpathconf()</code>的目标限制在这2个函数的调用进程的生命周期内是常量
(因为在调用进程的运行过程中，文件系统可能以不同的特征卸载和重新挂载)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_fpathconf.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印masg加上fpathconf(fd, name)的返回值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @param fd</span></span><br><span class="line"><span class="comment"> * @param name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fpathconfPrint</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">int</span> fd, <span class="type">int</span> name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> lim;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    lim = fpathconf(fd, name);</span><br><span class="line">    <span class="keyword">if</span> (lim != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %ld\n&quot;</span>, msg, lim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s (indeterminate)\n&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fpathconf %s&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fpathconfPrint(<span class="string">&quot;_PC_NAME_MAX: &quot;</span>, STDIN_FILENO, _PC_NAME_MAX);</span><br><span class="line">    fpathconfPrint(<span class="string">&quot;_PC_PATH_MAX: &quot;</span>, STDIN_FILENO, _PC_PATH_MAX);</span><br><span class="line">    fpathconfPrint(<span class="string">&quot;_PC_PIPE_BUF: &quot;</span>, STDIN_FILENO, _PC_PIPE_BUF);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过<code>fpathconf()</code>来打印标准输入引用的文件的各种限制。</p>
<h3 id="不确定的限制">11.4 不确定的限制</h3>
<p>　　有时，可能会出现系统限制不是由实现限制常量定义的情况，此时，<code>sysconf()</code>或<code>pathconf()</code>会返回-1来表示该限制不确定。对于这种情况，可以使用如下方法来处理：</p>
<p>　　● 当开发可移植应用程序时，可以使用SUSv3指定的上限的最小值
(对应名称为<code>_POSIX_*_MAX</code>的常量)。有时，这种方法可能不可行，因为最小值可能小到不切实际
(例如，<code>_POSIX_PATH_MAX</code>和<code>_POSIX_OPEN_MAX</code>)。</p>
<p>　　●
在某些情况下，实用的解决方法是忽略对限制的检测，并且调用相关系函数。若调用失败，并且<code>errno</code>表示因超出某些系统限制而出错，则可以进行适当的修改，然后再次尝试。例如，大多数UNIX实现对进程的排队的信号的数量施加了限制，一旦达到上限，对该进程继续发送信号会导致错误<code>EAGAIN</code>。对于这种情况，发送进程只需要在等待一段时间，然后再次发送信号。</p>
<p>　　● 编写自己的函数 (或程序)
来预估限制。预估函数在调用<code>sysconf()</code>和<code>pathconf()</code>后，若目标限制不确定，则预估函数返回预估值。尽管这种方法不完美，但在实际中通常是可行的。</p>
<p>　　● 使用autoconf (GNU扩展工具)
等工具来确定各种系统特性和限制是否存在和相关设置。autoconf程序会基于它确定的信息生成可供C程序引用的头文件。</p>
<h3 id="系统选项">11.5 系统选项</h3>
<p>　　当系统选项对应的常量定义为0时，应用程序可以通过函数<code>sysconf()</code>和<code>pathconf()</code>
(或<code>fpathconf()</code>)
来在运行时检测实现是否该选项。传递给这些函数的参数<code>name</code>的名称通常与对应的编译时常量的类似，但前缀是<code>_SC_</code>或<code>_PC_</code>。实现必须提供足以执行运行时检测的头文件、常量和函数接口。</p>
<p>　　SUSv3没有说明将未定义的选项对应的常量定义为0或-1时的含义。标准委员会随后决定将这种情况视为将常量定义为-1
(即不支持该选项)，SUSv4显式地说明了这一点。</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 22%" />
<col style="width: 49%" />
<col style="width: 3%" />
</colgroup>
<thead>
<tr>
<th>选项 (常量) 名</th>
<th><code>sysconf()</code>/<code>pathconf()</code>名</th>
<th>描述</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_POSIX_ASYNCHRONOUS_IO</code></td>
<td><code>_SC_ASYNCHRONOUS_IO</code></td>
<td>异步I/O</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td><code>_POSIX_CHOWN_RESTRICTED</code></td>
<td><code>_SC_CHOWN_RESTRICTED</code></td>
<td>只有特权进程才能通过<code>chown()</code>和<code>fchown()</code>来将文件的用户ID和组ID修改为任意值</td>
<td style="text-align: left;">*</td>
</tr>
<tr>
<td><code>_POSIX_JOB_CONTROL</code></td>
<td><code>_SC_JOB_CONTROL</code></td>
<td>作业控制</td>
<td style="text-align: left;">+</td>
</tr>
<tr>
<td><code>_POSIX_MESSAGE_PASSING</code></td>
<td><code>_SC_MESSAGE_PASSING</code></td>
<td>POSIX消息队列</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td><code>_POSIX_PRIORITY_SCHEDULING</code></td>
<td><code>_SC_PRIORITY_SCHEDULING</code></td>
<td>进度调度</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td><code>_POSIX_REALTIME_SIGNALS</code></td>
<td><code>_SC_REALTIME_SIGNALS</code></td>
<td>实时信号扩展</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td><code>_POSIX_SAVED_IDS</code></td>
<td>无</td>
<td>进程有保存的set-user-ID和保存的set-group-ID</td>
<td style="text-align: left;">+</td>
</tr>
<tr>
<td><code>_POSIX_SEMAPHORES</code></td>
<td><code>_SC_SEMAPHORES</code></td>
<td>POSIX信号量</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td><code>_POSIX_SHARED_MEMORY_OBJECTS</code></td>
<td><code>_SC_SHARED_MEMORY_OBJECTS</code></td>
<td>POSIX共享内存对象</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td><code>_POSIX_THREADS</code></td>
<td><code>_SC_THREADS</code></td>
<td>POSIX线程</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td><code>_XOPEN_UNIX</code></td>
<td><code>_SC_XOPEN_UNIX</code></td>
<td>支持XSI扩展</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>　　上表列出了部分SUSv3详细说明的选项。第1列是选项对应的编译时常量名
(定义在<code>unistd.h</code>中)，第2列是对应的指定给<code>sysconf()</code>
(<code>_SC_*</code>) 或<code>pathconf()</code> (<code>_PC_*</code>)
的参数<code>name</code>的名称。</p>
<p>　　● 对于SUSv3要求提供的选项 (表中用 +
标记)，对应的编译时常量必须为正值。从历史角度，这些选项过去是可选的，但如今是必选的。对于SUSv4，SUSv3中的很多可选的选项成为了必选。尽管SUSv3要求提供这些选项，但有些UNIX实现可能以不符合规范的配置安装。因此，对于可移植应用程序，检测实现是否支持这些选项可能是值得的。</p>
<p>　　● 对于特定选项 (表中用 * 标记)，对应的编译时常量必须非负。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《ARM Cortex-M3与Cortex-M4权威指南 第3版》第4章 架构</title>
    <url>/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/</url>
    <content><![CDATA[<p>　　Cortex-M3和Cortex-M4处理器都是基于ARMv7-M架构。最初的ARMv7-M架构是在开发Cortex-M3处理器时设计的。当Cortex-M4处理器发布时，该架构扩展为ARMv7E-M
(添加了一些指令和特性)。</p>
<p>　　与其它几乎所有处理器类似，Cortex-M3和Cortex-M4处理器的核心中包含大量用于执行数据处理和控制的寄存器，其中的大多数寄存器都被归类于1个称为<strong>寄存器组</strong>的单元。数据处理指令会指定所需的操作、源寄存器和目的寄存器
(若有必要)。对于ARM架构，若存储器中的数据需要被处理，则需要先将其加载到寄存器组来进行数据处理，然后写回到存储器
(若有必要)，这通常称为<span
style="background-color: yellow">加载-存储</span>架构。通过让寄存器组包含足够多的寄存器，这种设计易于使用，并且允许C编译器生成高效的程序代码
(例如，当执行数据处理时，很多数据变量可以短期内存储在寄存器中，而无需每次使用时都更新到系统存储器并再次读取)。</p>
<h3 id="程序员模型">4.1 程序员模型</h3>
<h4 id="工作状态和模式">4.1.1 工作状态和模式</h4>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/operation_states_and_modes.svg" class="">
<p>　　Cortex-M3和Cortex-M4处理器有2种工作状态和2种工作模式。此外，Cortex-M3和Cortex-M4处理器还有2种访问级别：特权访问级别和非特权访问级别。特权访问级别可以访问处理器的所有资源，而非特权访问级别只能访问部分资源，并且只能执行部分操作。在有些文档中，非特权访问级别也称为用户状态
(继承自ARM7TDMI的术语)。</p>
<span id="more"></span>
<p>　　Cortex-M3和Cortex-M4处理器的2种工作状态分别是<span
style="background-color: yellow">Thumb状态</span>和<span
style="background-color: yellow">调试状态</span>。</p>
<p>　　● 若处理器正在运行程序代码 (Thumb指令)，则它处于Thumb状态。</p>
<p>　　● 若处理器因调试器而停止，则它会进入调试状态并停止执行指令。</p>
<p>　　Cortex-M3和Cortex-M4处理器的2种工作模式分别是<span
style="background-color: yellow">处理函数模式</span>和<span
style="background-color: yellow">线程模式</span>。</p>
<p>　　●
当处理器执行常规应用程序代码时，它会进入线程模式。在这种情况下，处理器可以处于特权访问级别或非特权访问级别
(由寄存器CONTROL控制)。</p>
<p>　　●
当处理器执行中断服务例程等异常处理器函数时，它会进入处理函数模式。在这种情况下，处理器总是处于特权访问级别。</p>
<p>　　软件可以将处理器从特权线程模式切换到非特权线程模式，但无法切回到特权线程模式。若有必要，处理器必须通过异常机制来完成从非特权线程模式到特权线程模式的切换。</p>
<p>　　特权访问级别和非特权访问级别的分离允许系统设计者通过提供包含关键区域内存访问机制以及级别安全模型机制来开发健壮的嵌入式系统。例如，系统可以包含1个以特权访问级别运行的嵌入式OS内核和任意个以非特权访问级别运行的应用程序任务。通过这种方式，可以使用MPU来设置内存访问权限，以防止应用程序任务损坏OS内核和其他任务使用的内存和外设。当某个应用程序任务崩溃时，剩余应用程序任务和OS内核可以继续运行。</p>
<p>　　除了内存访问权限和几个特殊指令的访问权限不同之外，特权访问级别的程序员模型和非特权访问级别的程序员模型几乎完全相同
(几乎所有NVIC寄存器的访问都需要特权访问级别)。</p>
<p>　　线程模式和处理函数模式有类似的程序员模型。但是，线程模式可以切换到使用单独的影子栈指针。这允许应用程序任务的栈内存与OS内核使用的栈分开，进而提升系统的可靠性。</p>
<p>　　Cortex-M处理器默认以特权线程模式和Thumb状态启动。对于简单应用程序，无需使用非特权线程模式和影子SP。Cortex-M0处理器没有非特权线程模式，而Cortex-M0+处理器将非特权线程模式作为可选项。</p>
<p>　　调试状态仅用于调试操作，可以通过调试器的断点请求或处理器的调试组件生成的调试事件进入该状态。该状态允许调试器访问或修改处理器寄存器的值。调试器可以访问系统存储器
(包括各种外设)。</p>
<h4 id="寄存器">4.1.2 寄存器</h4>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/register_bank.svg" class="">
<p>　　Cortex-M3和Cortex-M4处理器的寄存器组包含16个寄存器。其中的13个寄存器作为32位通用目的寄存器，剩余寄存器用于特殊目的。</p>
<p>　　R0~R12是通用目的寄存器。前8个寄存器也称为<strong>低位寄存器</strong>，后5个寄存器也称为<strong>高位寄存器</strong>。由于指令集的可用空间有限，很多16位指令只能访问低位寄存器。高位寄存器通常与32位指令一起使用，MOV指令等少部分16位指令也能访问高位寄存器。R0~R12的初始值都是未定义的。</p>
<p>　　R13是<strong>栈指针</strong>
(SP)。PUSH和POP操作会使用该寄存器来访问栈内存。从物理角度，存在2个栈指针：<span
style="background-color: yellow">主栈指针</span> (MSP或SP_main) 和<span
style="background-color: yellow">进程栈指针</span>
(PSP或SP_process)。MSP是默认栈指针，在复位后或处理器位于处理函数模式时会使用该栈指针。PSP仅用于线程模式。栈指针的选择由寄存器CONTROL决定。对于常规程序，只有1个栈指针是可见的。</p>
<p>　　MSP和PSP都是32位，但它们的低2位总是为0，对这2个位的写入会被忽略。对于Cortex-M处理器，PUSH和POP始终为32位，并且栈操作中传输的地址必须按照32位对齐。</p>
<p>　　当应用程序不需要嵌入式OS时，通常不需要使用PSP。很多简单应用程序完全可以仅使用MSP。若涉及嵌入式OS
(OS内核使用的栈和应用程序任务使用的栈是分开的)，则通常会使用PSP。PSP的初始值是未定义的，MSP的初始值取自复位序列中内存的第1个字的地址。</p>
<p>　　R14是<strong>链接寄存器</strong>
(LR)，调用函数或子例程时会使用该寄存器来存储返回地址。当函数或子例程调用完成时，控制权会返回给调用函数，并通过将LR的值加载到程序计数器中来恢复调用函数。当调用函数或子例程时，LR的值会自动更新。在调用函数或子例程之前，需要先将LR的值存储在栈中。否则，调用函数时LR的值会丢失。</p>
<p>　　当处理异常时，LR会自动更新为特殊值EXC_RETURN
(异常返回)，该值随后用于在异常处理函数的末尾触发异常返回。</p>
<p>　　Cortex-M处理器的返回地址值总是为偶数
(最低有效位是0，因为指令必须对齐到32位地址)，但LR的最低有效位是可读和可写的。某些分支/调用操作需要将LR的最低有效位设置为1来表示Thumb状态。</p>
<p>　　R15是<strong>程序计数器</strong>
(PC)，该寄存器是可读和可写的。读PC会返回当前指令的地址加4
(因为流水线设计的特性以及与ARM7TDMI处理器的兼容)。写PC
(例如，通过数据传输/处理指令) 会导致分支操作。</p>
<p>　　指令必须与 (半)
字地址对齐，所以PC的最低有效位是0。但是，当使用某些分支/内存读取指令来更新PC时，需要将PC的新值的最低有效位设置为1来表示Thumb状态。否则，会触发故障异常，因为这表示试图切换到不受支持的ARM指令
(例如，ARM7TDMI中的32位ARM指令)。对于高级编程语言
(包括C和C++)，分支目标的最低有效位的设置由编译器自动处理。</p>
<p>　　在大多数情况下，分支和调用由专门的指令处理。使用数据处理指令来更新PC则较为少见。但是，PC值对于存储在程序内存中的字面数据很有用。</p>
<p>　　对于大多数汇编工具，可以通过多个名称来访问寄存器组中的同一寄存器。对于ARM汇编工具等工具，可以使用大写、小写或大小写混合：</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>可能的寄存器名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>R0~R12</td>
<td>R0~R12或r1~r12</td>
</tr>
<tr>
<td>R13</td>
<td>R13、r13、SP或sp</td>
</tr>
<tr>
<td>R14</td>
<td>R14、r14、LR或lr</td>
</tr>
<tr>
<td>R15</td>
<td>R15、r15、PC或pc</td>
</tr>
</tbody>
</table>
<p>　　此外，特殊寄存器访问指令 (MRS和MSR) 会使用寄存器名MSP和PSP。</p>
<h4 id="特殊寄存器">4.1.3 特殊寄存器</h4>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/special_registers.svg" class="">
<p>　　除了寄存器组中的寄存器之外，还有大量特殊寄存器。这些寄存器包含处理器状态，并且定义了工作状态和中断/异常屏蔽。</p>
<p>　　特殊寄存器没有映射到内存，可以使用MSR和MRS等特殊寄存器访问指令访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRS &lt;reg&gt;, &lt;special_reg&gt; ; 将特殊寄存器的值读取到寄存器</span><br><span class="line">MSR &lt;special_reg&gt;, &lt;reg&gt; ; 将寄存器的值写入到特殊寄存器</span><br></pre></td></tr></table></figure>
<h5 id="程序状态寄存器">4.1.3.1 程序状态寄存器</h5>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/apsr,epsr,ipsr_and_xpsr.svg" class="">
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr>
<th>位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>N</td>
<td>负标志</td>
</tr>
<tr>
<td>Z</td>
<td>零标志</td>
</tr>
<tr>
<td>C</td>
<td>进位 (或非借位) 标志</td>
</tr>
<tr>
<td>V</td>
<td>溢出标志</td>
</tr>
<tr>
<td>Q</td>
<td>粘性饱和标志 (在ARMv6-M中不可用)</td>
</tr>
<tr>
<td>GE[3:0]</td>
<td>每个字节通路的大于或等于标志
(仅限于ARMv7E-M；在ARMv6-M和Cortox-M3中不可用)</td>
</tr>
<tr>
<td>ICI/IT</td>
<td>中断继续指令 (ICI) 位，条件执行的IF-THEN指令状态位
(在ARMv6-M中不可用)</td>
</tr>
<tr>
<td>T</td>
<td>Thumb状态，总是为1，试图清除该位会导致故障异常</td>
</tr>
<tr>
<td>异常号</td>
<td>表示处理器正在处理的异常</td>
</tr>
</tbody>
</table>
<p>　　<strong>程序状态寄存器</strong>由<strong>应用程序PSR</strong>
(APSR)、<strong>执行PSR</strong> (EPSR) 和<strong>中断PSR</strong>
(IPSR)
组成。这3个寄存器可以通过1个组合寄存器访问，在一些文档中称为xPSR。对于ARM汇编器，访问xPSR使用的符号是PSR：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRS r0, PSR</span><br><span class="line">MSR PSR, r0</span><br></pre></td></tr></table></figure>
<p>　　此外，也可以访问独立的PSR：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRS r0, APSR</span><br><span class="line">MRS r0, IPSR</span><br><span class="line">MSR APSR, r0</span><br></pre></td></tr></table></figure>
<p>　　此外，软件代码无法直接使用MRS或MSR来访问EPSR。IPSR是只读的，可以从xPSR中读取。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/comparing_psr_of_various_arm_architectures.svg" class="">
<p>　　APSR和EPSR的部分位字段在ARMv6-M架构 (例如，Cortex-M0处理器)
中不可用，并且与ARM7TDMI等经典处理器有很大的不同。如果将其与ARM7中的当前程序状态寄存器
(CPSR) 比较，会发现ARM7中的某些位字段不再使用。模式 (M)
字段不再使用是因为Cortex-M3不具备ARM7中定义的工作模式。Thumb位 (T)
字段移动到了位24。中断状态 (I和F) 位被新的中断屏蔽寄存器 (PRIMASK)
所取代，并与PSR分离。</p>
<h5 id="寄存器primaskfaultmask和basepri">4.1.3.2
寄存器PRIMASK、FAULTMASK和BASEPRI</h5>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/primask,faultmask_and_basepri_registers.svg" class="">
<p>　　寄存器PRIMASK、FAULTMASK和BASEPRI都用于异常/中断屏蔽。每个异常
(包括中断)
有1个优先级，其数值越小，优先级越高。这些特殊寄存器用于根据优先级屏蔽异常，只能在特权访问级别下被访问这些寄存器
(在非特权访问级别下，写这些寄存器会被忽略，读这些寄存器会返回0)。在默认情况下，这些寄存器都是0，表示屏蔽
(禁用异常/中断) 未被启用。</p>
<p>　　寄存器PRIMASK是1位的中断屏蔽寄存器。当该寄存器被设置后，会屏蔽除NMI和硬故障
(HardFault)
异常之外的所有异常。实际上，它是将当前异常优先级设置为0，这是可编程异常/中断的最高优先级。</p>
<p>　　寄存器PRIMASK最常见的用途是为实时进程禁用所有中断。当实时进程完成后，该寄存器需要被清除
(以启用中断)。</p>
<p>　　寄存器FAULTMASK与PRIMASK相似，但会屏蔽硬故障异常。实际上，它会将当前异常优先级设置为-1。故障处理代码可以通过该寄存器来抑制故障处理期间进一步的故障
(仅限于几种类型) 的触发
(例如，该寄存器可用于绕过MPU或总线故障)，这可能使故障处理代码更容易执行补救措施。此外，FAULTMASK在异常返回后会自动被清除。</p>
<p>　　为了提供更灵活的中断屏蔽，ARMv7-M架构还提供了寄存器BASEPRI。该寄存器会根据优先级屏蔽异常/中断，并且其长度取决于设计中实现的优先级数
(由微控制器供应商提供)。大多数Cortex-M3和Cortex-M4微控制器有8或16个可编程中断优先级，对应的BASEPRI长度为3或4位。当该寄存器被设置为0时，它将被禁用。当该寄存器被设置为非0值时，它会屏蔽不高于指定优先级的异常
(包括中断)。</p>
<p>　　ARMv6-M架构 (例如，Cortex-M0) 没有寄存器FAULTMASK和BASEPRI。</p>
<p>　　CMSIS-Core提供了大量用于访问寄存器PRIMASK、FAULTMASK和BASEPRI的C函数
(只能在特权访问级别下访问这些寄存器)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = __get_BASEPRI();   <span class="comment">/* 读寄存器BASEPRI */</span></span><br><span class="line">x = __get_PRIMARK();   <span class="comment">/* 读寄存器PRIMASK */</span></span><br><span class="line">x = __get_FAULTMASK(); <span class="comment">/* 读寄存器FAULTMASK */</span></span><br><span class="line">__set_BASEPRI(x);      <span class="comment">/* 设置寄存器BASEPRI的值 */</span></span><br><span class="line">__set_PRIMASK(x);      <span class="comment">/* 设置寄存器PRIMASK的值 */</span></span><br><span class="line">__set_FAULTMASK(x);    <span class="comment">/* 设置寄存器FAULTMASK的值 */</span></span><br><span class="line">__disable_irq();       <span class="comment">/* 设置寄存器PRIMASK，禁用IRQ */</span></span><br><span class="line">__enable_irq();        <span class="comment">/* 清除寄存器PRIMASK，启用IRQ */</span></span><br></pre></td></tr></table></figure>
<p>　　也可以通过汇编代码来访问这些异常屏蔽寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRS r0, BASEPRI</span><br><span class="line">MRS r0, PRIMASK</span><br><span class="line">MRS r0, FAULTMASK</span><br><span class="line">MSR BASEPRI, r0</span><br><span class="line">MSR PRIMASK, r0</span><br><span class="line">MSR FAULTMASK, r0</span><br></pre></td></tr></table></figure>
<p>　　此外，改变处理器状态指令 (CPS)
也能用于设置或清除寄存器PRIMASK和FAULTMASK的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPSIE i ; 启用中断 (清除寄存器PRIMASK)</span><br><span class="line">CPSID i ; 禁用中断 (设置寄存器PRIMASK)</span><br><span class="line">CPSIE f ; 启用中断 (清除寄存器FAULTMASK)</span><br><span class="line">CPSID f ; 禁用中断 (设置寄存器FAULTMASK)</span><br></pre></td></tr></table></figure>
<h5 id="寄存器control">4.1.3.3 寄存器CONTROL</h5>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/control_register_in_cortex-m3,cortex-m4_and_cortex-m4_with_fpu.svg" class="">
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr>
<th>位</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>nPRIV (位0)</td>
<td>定义线程模式下的访问级别：若该位为0
(默认)，则线程模式下为特权访问级别；若该位为1，则线程模式下为非特权访问级别。</td>
</tr>
<tr>
<td>SPSEL (位1)</td>
<td>定义栈指针的选择：若该位为0
(默认)，则线程模式使用MSP；若该位为1，则线程模式使用PSP。在处理函数模式下，该位总是为0，并且对该位的写入会被忽略。</td>
</tr>
<tr>
<td>FPCA (位2)</td>
<td>浮点上下文激活
(仅限于带有FPU的Cortex-M4)。异常处理机制使用该位来确定发生异常时是否需要保存FPU中的寄存器。若该位为0
(默认)，则表示当前上下文未使用FPU，所以无需保存浮点寄存器；若该位为1，则表示FPU在当前上下文使用了浮点指令，所以需要保存浮点寄存器。当执行浮点指令时，该位会自动被设置。当进入异常时，硬件会清除该位。浮点寄存器的保存方法有多种。</td>
</tr>
</tbody>
</table>
<p>　　寄存器CONTROL定义了栈指针的选择 (MSP/PSP) 和线程模式下的访问级别
(特权/非特权)。</p>
<p>　　对于带有FPU的Cortex-M4处理器，寄存器CONTROL中的1位会用于表示当前上下文
(当前执行的代码) 是否使用了FPU。</p>
<p>　　对于ARMv6-M，nPRIV和非特权访问级别的支持取决于具体实现。第1代Cortex-M0和Cortex-M1产品没有这些功能，并且Cortex-M0+将其作为可选功能。</p>
<p>　　寄存器CONTROL只能在特权访问级别下被修改，并且可以在特权和非特权访问级别下被读取。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/stack_pointer_selection.svg" class="">
<p>　　在复位后，寄存器CONTROL为0。这表示线程模式使用MSP作为栈指针，并且处于特权访问级别。特权线程模式下的程序可以通过写入寄存器CONTROL来切换栈指针或切换到非特权访问级别。但是，一旦nPRIV
(位0) 被设置，运行在线程模式下的程序将无法再访问寄存器CONTROL。</p>
<p>　　非特权访问级别下的程序不能将自己切换到特权访问级别，这对提供基本的安全使用模型至关重要
(例如，嵌入式系统可能包含运行在非特权访问级别下的不受信任的应用程序，并且必须限制这些应用程序的访问权限，以防止安全漏洞和不可靠的应用程序破坏整个系统)。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/switching_between_privileged_thread_mode_and_unprivileged_thread_mode.svg" class="">
<p>　　当需要从非特权线程模式切换到特权线程模式时，必须使用使用异常机制。在异常处理期间，异常处理函数会清除位nPRIV。当回到线程模式时，处理器将处于特权访问级别。</p>
<p>　　当使用嵌入式OS时，可以在每次切换上下文时重新编程CONTRO寄存器，以允许某些应用程序任务以特权访问级别运行，而其他应用程序任务以非特权访问级别运行。</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr>
<th>nPRIV</th>
<th>SPSEL</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>简单应用程序——整个应用程序运行在特权访问级别。主程序和中断处理函数共用1个栈
(仅使用MSP)。</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>带有嵌入式OS的应用程序，并且当前执行的任务运行在特权线程模式。当前任务使用PSP，而OS内核和异常处理函数使用MSP。</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>带有嵌入式OS的应用程序，并且当前执行的任务运行在非特权线程模式。当前任务使用PSP，而OS内核和异常处理函数使用MSP。</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>线程模式任务运行在非特权访问级别，并且使用MSP，这可以在处理函数模式下观察到。但是，该设置不太可能用于用户任务，因为对于大多数嵌入式OS，应用程序任务的栈与OS内核和异常处理函数使用的栈是分开的。</td>
</tr>
</tbody>
</table>
<p>　　nPRIV和SPSEL的设置是正交的。虽然有4种不同的nPRIV和SPSEL组合，但实际应用程序通常仅使用前3种。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/simple_applications_do_not_require_unprivileged_thread_mode.svg" class="">
<p>　　对于大多数没有嵌入式OS的简单应用程序，无需修改寄存器CONTROL的值。整个应用程序运行在特权访问级别，并且仅使用MSP。</p>
<p>　　为了在C中访问寄存器CONTROL，符合CMSIS的设备驱动程序库会提供以下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = __get_CONTROL(); <span class="comment">/* 读取寄存器CONTROL的值 */</span></span><br><span class="line">__set_CONTROL(x);    <span class="comment">/* 将寄存器CONTROL的值设置为x */</span></span><br></pre></td></tr></table></figure>
<p>　　当修改寄存器CONTROL的值时，需要注意以下2点：</p>
<p>　　●
对于带有FPU的Cortex-M4处理器或带有FPU的ARMv7-M处理器变体，位FPCA会由于浮点指令的出现而自动被设置。若程序包含浮点运算，并且位FPCA被意外清除后发生了中断，则FPU的寄存器中的数据不会被异常进入序列保存，并且可能会被中断处理函数覆写。在这种情况下，程序在从中断返回后可能不会正确地恢复执行。</p>
<p>　　● 从架构角度，修改寄存器CONTROL后应该使用指令同步屏障 (ISB)
指令或符合CMSIS的驱动程序中的函数<code>__ISB()</code>来确保修改后的效果适用于后续代码。由于Cortex-M3、Cortex-M4、Cortex-M0和Cortex-M0+的流水线很简单，所以省略该操作不会造成任何问题。</p>
<p>　　为了在汇编中访问寄存器CONTROL，需要使用MRS和MSR指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRS r0, CONTROL ; 将CONTROL读取到r0</span><br><span class="line">MSR CONTROL, r0 ; 将r0写入到CONTROL</span><br></pre></td></tr></table></figure>
<p>　　此外，可以通过检查寄存器IPSR和CONTROL来判断当前的执行级别是否具有特权：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 是否处于特权访问级别</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return int 1表示有特权，0表示无特权</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">in_privileged</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__get_IPSR() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((__get_CONTROL() &amp; <span class="number">0x1</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="浮点寄存器">4.1.4 浮点寄存器</h4>
<p>　　Cortex-M4处理器包含可选的FPU。除了为浮点数据处理提供额外的寄存器之外，FPU还提供了<strong>浮点状态和控制寄存器</strong>
(FPSCR)。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/registers_in_the_fpu.svg" class="">
<p>　　32位寄存器S0~S31 (S表示单精度)
可以通过浮点指令访问，也可以通过符号D0~D15 (D表示双字/双精度)
成对访问。尽管Cortex-M4中的FPU不支持双精度计算，但仍然使用浮点指令来传输双精度数据。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/fpscr.svg" class="">
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr>
<th>位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>N</td>
<td>负标志 (由浮点比较运算更新)</td>
</tr>
<tr>
<td>Z</td>
<td>零标志 (由浮点比较运算更新)</td>
</tr>
<tr>
<td>C</td>
<td>进位/借位标志 (由浮点比较运算更新)</td>
</tr>
<tr>
<td>V</td>
<td>溢出标志 (由浮点比较运算更新)</td>
</tr>
<tr>
<td>AHP</td>
<td>备用半精度控制位：0表示IEEE半精度格式
(默认)，1表示备用半精度格式</td>
</tr>
<tr>
<td>DN</td>
<td>默认非数字 (NaN) 模式控制位：0表示NaN操作数会传播到浮点运算的输出
(默认)，1表示任何涉及NaN的运算都将返回默认的NaN</td>
</tr>
<tr>
<td>FZ</td>
<td>清零模式控制位：0表示禁用清零模式 (默认)，1表示启用清零模式</td>
</tr>
<tr>
<td>RMode</td>
<td>舍入默认控制字段
(几乎所有浮点指令都使用特定的舍入模式)：00表示向最近值舍入 (RN) 模式
(默认)，01表示向正无穷舍入 (RP) 模式，10表示向负无穷舍入 (RM)
模式，11表示向零舍入 (RZ) 模式</td>
</tr>
<tr>
<td>IDC</td>
<td>输入非规则累积异常位
(发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td>
</tr>
<tr>
<td>IXC</td>
<td>不精确累积异常位
(发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td>
</tr>
<tr>
<td>UFC</td>
<td>下溢出累积异常位
(发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td>
</tr>
<tr>
<td>OFC</td>
<td>上溢出累积异常位
(发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td>
</tr>
<tr>
<td>DZC</td>
<td>除以0累积异常位
(发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td>
</tr>
<tr>
<td>IOC</td>
<td>无效运算累积异常位
(发生浮点异常时会将该位设置为1，可以通过写入0来清除该位)</td>
</tr>
</tbody>
</table>
<p>　　FPSCR包含各种位是为了定义一些浮点运算行为以及提供关于浮点运算结果的状态信息。在默认情况下，行为配置符合IEEE
754单精度运算。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/cpacr.svg" class="">
<p>　　除了浮点寄存器组和FPSCR之外，FPU还向系统添加了几个额外的内存映射寄存器。例如，协处理器访问控制寄存器
(CPACR) 用于启用或禁用FPU。FPU默认禁用
(为了降低功耗)，在使用浮点指令之前必须先编程CPACR来启用FPU。</p>
<p>　　对于带有符合CMSIS的设备驱动程序的C编程环境，可以通过以下代码启用FPU：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SCB-&gt;CPACR |= <span class="number">0xF</span> &lt;&lt; <span class="number">20</span>; <span class="comment">/* 启用对FPU的完全访问 */</span></span><br></pre></td></tr></table></figure>
<p>　　对于汇编，可以通过以下指令来启用FPU：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R0,=0xE000ED88  ; 将R0设置为CPACR的地址</span><br><span class="line">LDR R1,=0x00F00000  ; R1 = 0xF &lt;&lt; 20</span><br><span class="line">LDR R2 [R0] ; 读取CPACR的值</span><br><span class="line">ORRS R2, R2, R1 ; 设置位</span><br><span class="line">STR R2,[R0] ; 将修改后的值写回到CPACR</span><br></pre></td></tr></table></figure>
<h3 id="apsr的行为">4.2 APSR的行为</h3>
<p>　　APSR包含3组状态标志：整数运算的状态标志
(N、Z、C和V)、饱和算术的状态标志 (Q) 以及SIMD操作的状态标志 (GE)。</p>
<h4 id="整数状态标志">4.2.1 整数状态标志</h4>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>N (位31)</td>
<td>设置指令结果的位31 (1表示负值，0表示正值或0)</td>
</tr>
<tr>
<td>Z (位30)</td>
<td>当指令的结果为0或比较指令的操作数相同时，会将该标志设置为1</td>
</tr>
<tr>
<td>C (位29)</td>
<td>结果的进位标志
(对于无符号加法运算，溢出时会将该标志设置为1；对于无符号减法运算，该标志与借位输出状态相反。此外，移位和循环运算也会更新该标志)</td>
</tr>
<tr>
<td>V (位28)</td>
<td>结果的溢出标志
(对于有符号加减运算，有符号溢出时会将该标志设置为1)</td>
</tr>
</tbody>
</table>
<p>　　Cortex-M处理器有4个整数状态标志，它们与很多其他处理器架构的ALU状态标志类似。这些标志受通用数据处理指令的影响，并且对控制条件分支和条件执行很重要。此外，标志C也能用于加减运算。</p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr>
<th>运算</th>
<th>结果和标志</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x70000000 + 0x70000000</code></td>
<td>结果为<code>0xE0000000</code>，N = 1，Z = 0，C = 0，V = 1</td>
</tr>
<tr>
<td><code>0x90000000 + 0x90000000</code></td>
<td>结果为<code>0x30000000</code>，N = 0，Z = 0，C = 1，V = 1</td>
</tr>
<tr>
<td><code>0x80000000 + 0x80000000</code></td>
<td>结果为<code>0x00000000</code>，N = 0，Z = 1，C = 1，V = 1</td>
</tr>
<tr>
<td><code>0x00001234 - 0x00001000</code></td>
<td>结果为<code>0x00000234</code>，N = 0，Z = 0，C = 1，V = 0</td>
</tr>
<tr>
<td><code>0x00000004 - 0x00000005</code></td>
<td>结果为<code>0xFFFFFFFF</code>，N = 1，Z = 0，C = 0，V = 0</td>
</tr>
<tr>
<td><code>0xFFFFFFFF - 0xFFFFFFFC</code></td>
<td>结果为<code>0x00000003</code>，N = 0，Z = 0，C = 1，V = 0</td>
</tr>
<tr>
<td><code>0x80000005 - 0x80000004</code></td>
<td>结果为<code>0x00000001</code>，N = 0，Z = 0，C = 1，V = 0</td>
</tr>
<tr>
<td><code>0x70000000 - 0xF0000000</code></td>
<td>结果为<code>0x80000000</code>，N = 1，Z = 0，C = 0，V = 1</td>
</tr>
<tr>
<td><code>0xA0000000 - 0xA0000000</code></td>
<td>结果为<code>0x00000000</code>，N = 0，Z = 1，C = 1，V = 0</td>
</tr>
</tbody>
</table>
<p>　　对于ARMv7-M和ARMv7E-M架构，大多数16位指令会影响这4个整数状态标志。对于大多数32位指令，指令编码中会有1位用于定义是否应该更新APSR，并且其中的某些指令不会更新标志V或C
(例如，乘法指令只会更新标志N和Z)。</p>
<p>　　除了条件分支和条件指令代码之外，APSR的进位标志可用于将加减运算扩展到32位
(例如，当加法运算的操作数都是64位整数时，可以将低32位加法运算的进位标志作为高32位加法运算的额外输入)。</p>
<p>　　所有ARM处理器 (包括Cortex-M0处理器)
都提供了这4个整数状态标志。</p>
<h4 id="状态标志q">4.2.2 状态标志Q</h4>
<p>　　标志Q表示在饱和算术运算或饱和调整运算期间是否发生饱和。ARMv7-M
(例如，Cortex-M3和Cortex-M4处理器) 提供了该标志，但ARMv6-M
(例如，Cortex-M0处理器)
未提供该标志。当该标志被设置后，该标志会保持设置状态，直到通过软件写入APSR来清除该标志。饱和算术/调整运算不会清除该标志。因此，可以通过该标志来判断饱和算术/调整运算序列结束时是否发生饱和
(无需在逐一检查饱和状态)。</p>
<p>　　饱和算术对数字信号处理很有用。在某些情况下，用于存储计算结果的寄存器的长度可能不够，从而导致向上或向下溢出。若使用了常规算术指令，则结果的最高有效位将会丢失，并且导致输出严重失真。饱和算术不是简单地截断最高有效位，而是强制将结果设置为最大值
(向上溢出) 或最小值 (向下溢出) 来降低信号失真的影响。</p>
<p>　　触发饱和的实际最大值和最小值取决于使用的指令。在大多数情况下，饱和算术指令都是以
"Q" 开头
(例如，对于指令QADD16，若发生饱和，则设置标志Q；否则，不修改标志Q)。</p>
<p>　　Cortex-M3处理器提供了部分饱和调整指令，Cortex-M4处理器了全套饱和算术指令
(包括Cortex-M3处理器提供的饱和调整指令)。</p>
<h4 id="标志ge">4.2.3 标志GE</h4>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr>
<th>SIMD操作</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD16、SSUB16、USUB16、SASX和SSAX</td>
<td>若低半字结果大于等于0，则GE的低2位为11；否则，GE的低2位为00。<br>若高半字结果大于等于0，则GE的高2位为11；否则，GE的高2位为00。</td>
</tr>
<tr>
<td>UADD16</td>
<td>若低半字结果大于等于<code>0x10000</code>，则GE的低2位为11；否则，GE的低2位为00。<br>若高半字结果大于等于<code>0x10000</code>，则GE的高2位为11；否则，GE的高2位为00。</td>
</tr>
<tr>
<td>SADD8、SSUB8和USUB8</td>
<td>若字节0结果大于等于0，则GE的最低位为1；否则，GE的最低位为0。<br>若字节1结果大于等于0，则GE的次低位为1；否则，GE的次低位为0。<br>若字节2结果大于等于0，则GE的次高位为1；否则，GE的次高位为0。<br>若字节3结果大于等于0，则GE的最高位为1；否则，GE的最高位为0。</td>
</tr>
<tr>
<td>UADD8</td>
<td>若字节0结果大于等于<code>0x100</code>，则GE的最低位为1；否则，GE的最低位为0。<br>若字节1结果大于等于<code>0x100</code>，则GE的次低位为1；否则，GE的次低位为0。<br>若字节2结果大于等于<code>0x100</code>，则GE的次高位为1；否则，GE的次高位为0。<br>若字节3结果大于等于<code>0x100</code>，则GE的最高位为1；否则，GE的最高位为0。</td>
</tr>
<tr>
<td>UASX</td>
<td>若低半字结果大于等于0，则GE的低2位为11；否则，GE的低2位为00。<br>若高半字结果大于等于<code>0x10000</code>，则GE的高2位为11；否则，GE的低2位为00。</td>
</tr>
<tr>
<td>USAX</td>
<td>若低半字结果大于等于<code>0x10000</code>，则GE的低2位为11；否则，GE的低2位为00。<br>若高半字结果大于等于0，则GE的高2位为11；否则，GE的低2位为00。</td>
</tr>
</tbody>
</table>
<p>　　GE (大于等于)
是Cortex-M4处理器的APSR中的4位标志。该标志由SIMD指令更新，在大多数情况下，GE的每个位分别代表SIMD的每个字节的正溢出或负溢出。对于带有16位数据的SIMD指令，位0和1由结果或低半字结果控制，位2和3由高半字结果控制。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/sel_operation.svg" class="">
<p>　　标志GE由SEL指令使用，该指令会根据GE的每个位来复用2个源寄存器的字节值。当结合多条SIMD指令和单条SEL指令时，可以在SIMD指令排列中创建简单的条件数据选择来获取更好的性能。</p>
<h3 id="存储器系统">4.3 存储器系统</h3>
<p>　　Cortex-M3和Cortex-M4处理器拥有以下存储器系统特性：</p>
<p>　　●
4GB线性地址空间——通过32位寻址，ARM处理器可以访问高达4GB的内存空间。虽然很多嵌入式系统需要超过1MB的内存，但32位寻址能力可以保证未来的升级和扩展可能性。Cortex-M3和Cortex-M4处理器提供了使用AHB
LITE的32位总线。该总线允许通过合适的存储器接口控制器来连接8/16/32位的存储器设备。</p>
<p>　　●
架构定义的内存映射——4GB的内存被划分为多个区域，用于各种预定义的存储器和外设用途。这允许处理器设计能够进行性能优化
(例如，Cortex-M3和Cortex-M4处理器有多个总线接口，允许在访问CODE区域的程序代码期间对SRAM或外设区域进行数据操作)。</p>
<p>　　●
支持大端和小端内存系统——Cortex-M3和Cortex-M4处理器能够适用于大端或小端内存系统。实际上，微控制器产品通常被设计为仅使用其中的1种字节顺序配置。</p>
<p>　　● 可选的位带访问——若使用了位带
(由微控制器/SoC供应商决定)，内存映射中的2个1MB区域可以通过2个位带区域进行位寻址。这允许对SRAM或外设地址空间中的单个位进行原子访问。</p>
<p>　　●
写缓冲区——当对可缓冲内存区域的写入传输需要多个周期时，该传输可以通过Cortex-M3和Cortex-M4处理器内核的写缓冲区进行缓冲，以便处理器进行执行下一条指令
(若有需要)。这允许更高的程序执行速度。</p>
<p>　　●
可选的MPU——MPU是定义了各种内存区域的访问权限的可编程单元。Cortex-M3和Cortex-M4处理器的MPU支持8个可编程区域，并且可以与嵌入式OS一起使用来增加系统的健壮性。</p>
<p>　　●
支持未对齐传输——所有支持ARMv7-M架构的处理器都支持未对齐的数据传输。</p>
<p>　　Cortex-M处理器的总线接口是通用总线接口，并且能够通过存储控制器连接到不同类型和大小的存储器。微控制器的存储器系统包含多种类型的存储器：用于程序代码的闪存、用于数据的静态RAM
(SRAM) 以及仅用于某些场景的电可擦除只读存储器
(EEPROM)。在大多数情况下，这些存储器位于片上，并且实际的存储器接口细节对软件开发者是透明的。因此，软件开发者只需要知道程序存储器和SRAM的地址和大小。</p>
<h4 id="内存映射">4.3.1 内存映射</h4>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/memory_map.svg" class="">
<p>　　Cortex-M处理器的4GB地址空间被划分为大量内存区域。这种分区基于使用场景，以便不同的区域分别用于程序代码访问
(例如，CODE区域)、数据访问 (例如，SRAM区域)、外设 (例如，外设区域)
以及处理器的内部控制和调试组件 (例如，私有外设总线)。</p>
<p>　　该架构还具有高度灵活性，允许将内存区域用于其他用途
(例如，程序可以在CODE区域或SRAM区域执行，微控制器也可以将SRAM区域集成到CODE区域)。</p>
<p>　　在实际中，很多微控制器设备只会使用程序闪存、SRAM和外设区域的一小部分，并且不会使用某些区域。存储器大小和外设地址位置因微控制器而异。</p>
<p>　　所有Cortex-M处理器的内存映射都是一致的
(例如，NVIC的寄存器、处理器配置寄存器以及调试组件寄存器总是位于PPB地址空间)。这使得在Cortex-M设备之间移植软件更容易，并提供了软件的可重用性。Cortex-M3和Cortex-M4设备的调试工作方式的一致也为工具供应商带来了便利。</p>
<h4 id="栈内存">4.3.2 栈内存</h4>
<p>　　与几乎其他所有处理器架构一样，Cortex-M处理器需要栈内存来运行，并且使用栈指针。栈是允许将一部分内存用作后进先出的数据存储缓冲区的内存使用机制。ARM处理器使用主系统内存进行栈内存操作，使用PUSH指令将数据存储在栈中，使用POP指令从栈中检索数据。当前使用的栈指针会根据PUSH和POP操作自动调整。</p>
<p>　　栈可用于<span
style="background-color: yellow">临时存储函数使用寄存器进行数据处理时的原始数据</span>
(这些数据会在函数返回时恢复，所以调用函数不会丢失数据)、<span
style="background-color: yellow">传递函数和子例程的信息</span>、<span
style="background-color: yellow">存储局部变量</span>以及<span
style="background-color: yellow">在发生异常时保存处理器状态和寄存器值</span>。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/stack_push_and_pop.svg" class="">
<p>　　当处理器启动时，栈指针被设置为为栈内存保留的内存空间的末尾。</p>
<p>　　●
对于PUSH操作，处理器会先减少SP，然后将值存储在SP指向的内存位置。在此期间，SP指向的最后1个数据会被压入栈中。</p>
<p>　　●
对于POP操作，SP指向的内存位置的值会被读取，然后SP的值会自动增加。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH (R4) ; 将R4压入栈并调整SP</span><br><span class="line">PUSH (R5) ; 将R5压入栈并调整SP</span><br><span class="line">PUSH (R6) ; 将R6压入栈并调整SP</span><br><span class="line">; 执行任务</span><br><span class="line">POP (R4) ; 将R4弹出栈并调整SP</span><br><span class="line">POP (R5) ; 将R5弹出栈并调整SP</span><br><span class="line">POP (R6) ; 将R6弹出栈并调整SP</span><br><span class="line">BX LR ; 返回</span><br></pre></td></tr></table></figure>
<p>　　PUSH和POP指令最常见的用途是调用函数/子例程时保持寄存器组的内容。当函数调用开始时，某些寄存器的内容可以通过PUSH指令保存在栈中，然后函数返回时通过POP指令恢复寄存器的值。对于每个PUSH操作，必须有1个对应的POP操作，并且POP的地址应与PUSH操作的地址匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH (R4-R6) ; 将R4、R5和R6压入栈</span><br><span class="line">; 执行任务</span><br><span class="line">POP (R4-R6) ; 将R4、R5和R6弹出栈</span><br><span class="line">BX LR ; 返回</span><br></pre></td></tr></table></figure>
<p>　　每个PUSH和POP指令可以传输多个数据到栈内存。因为寄存器组中的寄存器都是32位，栈PUSH和POP会至少传输1字
(4字节) 的数据，并且地址总是会对齐到4字节边界。SP的低2位总是为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH (R4-R6, LR) ; 保持寄存器 (包括链接寄存器)</span><br><span class="line">; 执行任务</span><br><span class="line">POP (R4-R6, PC) ; 恢复寄存器并返回</span><br></pre></td></tr></table></figure>
<p>　　返回和POP操作可以结合起来，即先将LR压入栈，然后在函数/子例程结束时将其弹出到PC。</p>
<p>　　将寄存器状态保存在栈的操作称为<span
style="background-color: yellow">入栈</span>，将栈中的状态恢复到寄存器的操作称为<span
style="background-color: yellow">出栈</span>。对于使用嵌入式OS的嵌入式系统，应用程序栈和内核栈通常使用不同的内存区域，入栈和出栈阶段使用的是PSP。除了可以防止应用程序任务中的栈损坏或错误破坏操作系统的栈之外，栈分离的设计还简化了操作系统设计，从而允许更快的上下文切换。</p>
<p>　　尽管在任何时间只有1个SP是可见的
(通过SP或R13访问)，但可以直接访问MSP或PSP，而不会对SP/R13产生混淆。对于特权级别，可以使用以下CMSIS函数访问MSP和PSP：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = __get_MSP(); <span class="comment">/* 读MSP */</span></span><br><span class="line">__set_MSP(x);    <span class="comment">/* 将MSP设置为x */</span></span><br><span class="line">x = __get_PSP(); <span class="comment">/* 读PSP */</span></span><br><span class="line">__set_PSP(x);    <span class="comment">/* 将PSP设置为x */</span></span><br></pre></td></tr></table></figure>
<p>　　通常，不应该在C函数中修改当前SP的值，因为部分栈内存可能用于存储局部变量或其他数据。为了在汇编中访问MSP和PSP，可以使用以下MSR和MRS指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRS R0, MSP ; 将MSP读到R0</span><br><span class="line">MSR MSP, R0 ; 将R0写到MSP</span><br><span class="line">MRS R0, PSP ; 将PSP读到R0</span><br><span class="line">MSR PSP, R0 ; 将R0写到PSP</span><br></pre></td></tr></table></figure>
<p>　　大多数应用程序无需显示地访问MSP和PSP。访问MSP和PSP通常是嵌入式OS所需要的
(例如，通过MRS指令读取PSP的值，OS可以读取应用程序任务中API压入栈的数据)。此外，在上下文切换期间，OS的上下文切换代码会更新PSP。</p>
<p>　　当上电后，MSP由处理器硬件读取向量表来自动初始化。PSP不会自动初始化，必须在使用前由软件初始化。</p>
<h3 id="异常和中断">4.4 异常和中断</h3>
<p>　　异常是能够改变程序流的事件。当发生异常时，处理器会挂起当前执行流，并执行<span
style="background-color: yellow">异常处理函数</span>的一部分。当异常处理函数的执行完成后，处理器会恢复程序的执行。对于ARM架构，中断属于异常。中断通常由外设或外部输入生成，并且在某些情况下，软件也可以触发中断。中断的异常处理函数称为<strong>中断服务例程</strong>
(ISR)。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/various_exception_sources.svg" class="">
<p>　　Cortex-M处理器包含大量异常源。NVIC负责处理异常。NVIC能够处理多个<strong>中断请求</strong>
(IRQ) 和1个<strong>不可屏蔽中断</strong>
(NMI)。IRQ通常由片上外设或通过I/O端口的外部中断输入生成。NMI可供看门狗定时器或掉电检测器
(当电源电压降低至某个水平以下时向处理器发送警告的电压监控单元)
使用。处理器内部的SysTick定时器可以周期性地生成定时器IRQ，可供嵌入式OS用于计时，或在不需要OS的应用程序中用于简单的计时控制。</p>
<p>　　处理器本身也是异常事件源。这些异常事件可能是指示系统错误情况的故障事件，也可能是由软件生成以支持嵌入式OS运行的异常。下表列出了各种异常类型：</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 11%" />
<col style="width: 12%" />
<col style="width: 9%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr>
<th>异常号</th>
<th>CMISI中断号</th>
<th>异常类型</th>
<th>优先级</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
<td>复位</td>
<td>-3 (最高)</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>-14</td>
<td>NMI</td>
<td>-2</td>
<td>不可屏蔽中断</td>
</tr>
<tr>
<td>3</td>
<td>-13</td>
<td>硬故障</td>
<td>-1</td>
<td>各类故障
(当对应的故障处理函数由于被禁用或被异常屏蔽而无法激活时)</td>
</tr>
<tr>
<td>4</td>
<td>-12</td>
<td>内存管理故障</td>
<td>可设置</td>
<td>由于MPU违规或无效访问</td>
</tr>
<tr>
<td>5</td>
<td>-11</td>
<td>总线故障</td>
<td>可设置</td>
<td>从总线系统收到错误响应 (由于指令预取中止或数据访问错误)</td>
</tr>
<tr>
<td>6</td>
<td>-10</td>
<td>使用故障</td>
<td>可设置</td>
<td>通常是因为无效指令或无效状态转换尝试</td>
</tr>
<tr>
<td>7~10</td>
<td></td>
<td></td>
<td></td>
<td>保留</td>
</tr>
<tr>
<td>11</td>
<td>-5</td>
<td>SVC</td>
<td>可设置</td>
<td>通过SVC指令进行管理程序调用</td>
</tr>
<tr>
<td>12</td>
<td>-4</td>
<td>调试监视器</td>
<td>可设置</td>
<td>用于基于软件的调试</td>
</tr>
<tr>
<td>13</td>
<td></td>
<td></td>
<td></td>
<td>保留</td>
</tr>
<tr>
<td>14</td>
<td>-2</td>
<td>PendSV</td>
<td>可设置</td>
<td>系统服务的挂起请求</td>
</tr>
<tr>
<td>15</td>
<td>-1</td>
<td>SYSTICK</td>
<td>可设置</td>
<td>系统节拍定时器</td>
</tr>
<tr>
<td>16~255</td>
<td>0~239</td>
<td>IRQ</td>
<td>可设置</td>
<td>IRQ输入#0~239</td>
</tr>
</tbody>
</table>
<p>　　每种异常源有1个异常号。异常号1~15属于系统异常，异常号16及以上用于中断。Cortex-M3和Cortex-M4处理器的NVIC设计支持最多240个异常输入。但是，实际设计中实现的中断输入数量通常是16~100，因为这样做可以减小芯片体积和降低功耗。</p>
<p>　　异常号出现在各种寄存器中
(包括IPSR)，并且用于确定异常向量地址。异常向量存储在向量表中，处理器会通过读向量表来获取异常进入序列中的异常处理函数的起始地址。此外，异常号不同于CMSIS设备驱动程序库中的中断号。对于CMSIS设备驱动程序库，中断号从0开始，而系统异常号为负值。</p>
<p>　　与ARM7TDMI等经典ARM处理器相反，Cortex-M处理器没有快速中断
(FIQ)。但是，Cortex-M3和Cortex-M4处理器的中断延迟很低
(12个时钟周期)，所以不会产生任何问题。</p>
<p>　　复位是特殊类型的异常。当处理器退出复位时，它会进入线程模式执行复位处理函数
(而非像其他异常那样进入处理函数模式)。此外，IPSR中的异常号读取为0。</p>
<h4 id="nvic">4.4.1 NVIC</h4>
<p>　　NVIC是可编程的，其寄存器位于内存映射的系统控制空间中。NIVC控制异常和中断配置、优先级以及中断屏蔽。NVIC的功能包括<span
style="background-color: yellow">灵活的异常和中断管理</span>、<span
style="background-color: yellow">嵌套异常/中断支持</span>、<span
style="background-color: yellow">向量异常/中断条目</span>以及<span
style="background-color: yellow">中断屏蔽</span>。</p>
<p>　　每个异常 (除了NMI)
都可以被启用或禁用，并且可以通过软件设置或清除其挂起状态。NVIC可以处理各种类型的中断源：</p>
<p>　　●
脉冲中断请求——中断请求至少持续1个时钟周期。当NIVIC在其中断输入收到脉冲时，挂起状态会被设置并保持，直到中断得到服务。</p>
<p>　　● 电平触发中断请求——中断源保持高电平，直到中断得到服务。</p>
<p>　　NVIC信号输入电平为高电平时有效。但是，微控制器的外部中断输入可以设计得不同，并通过片上逻辑转换为有效的高电平信号。</p>
<p>　　所有异常都有优先级。中断等异常有可编程的优先级，而NMI等异常有固定的优先级。NVIC会在发生异常时将异常的优先级和当前优先级进行对比。若异常的优先级更高，则当前运行的任务会被挂起。某些寄存器会被存储在栈内存中，并且处理器会开始执行对应的异常处理函数。该过程称为<span
style="background-color: yellow">抢占</span>。当高优先级的异常处理函数完成时，它将以异常返回操作终止，处理器会自动从栈中恢复寄存器并继续之前的任务。该机制允许在不产生软件开销的情况下异常服务嵌套。</p>
<p>　　当发生异常时，处理器需要定位对应的异常处理函数的起始地址。对于ARM7TDMI等经典ARM处理器，软件处理这一步。Cortex-M处理器会根据内存中的向量表定位异常处理函数的起始地址。因此，从异常开始到异常处理函数执行的延迟得以减少。</p>
<p>　　NVIC提供了多种异常屏蔽掩码。寄存器PRIMASK可用于禁用所有异常
(包括硬故障和NMI)，这种屏蔽对不应被中断的操作很有用
(例如，实时多媒体解码器)。寄存器BASEPRI可用于禁用指定优先级以下的异常/中断。</p>
<p>　　CMSIS提供了1组用于访问各种中断功能的函数。NVIC的灵活性和功能使得Cotex-M处理器非常易于使用，并通过减少中断处理中的软件开销来提供更好的系统响应，从而减小代码体积。</p>
<h4 id="向量表">4.4.2 向量表</h4>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 18%" />
<col style="width: 22%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr>
<th>异常类型</th>
<th>CMSIS中断号</th>
<th>地址偏移</th>
<th>向量</th>
</tr>
</thead>
<tbody>
<tr>
<td>18~255</td>
<td>2~239</td>
<td><code>0x48</code>~<code>0x3FF</code></td>
<td>IRQ #2~239 (最低有效位为1)</td>
</tr>
<tr>
<td>17</td>
<td>1</td>
<td><code>0x44</code></td>
<td>IRQ #1 (最低有效位为1)</td>
</tr>
<tr>
<td>16</td>
<td>0</td>
<td><code>0x40</code></td>
<td>IRQ #0 (最低有效位为1)</td>
</tr>
<tr>
<td>15</td>
<td>-1</td>
<td><code>0x3C</code></td>
<td>SysTick (最低有效位为1)</td>
</tr>
<tr>
<td>14</td>
<td>-2</td>
<td><code>0x38</code></td>
<td>PendSV (最低有效位为1)</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>0x34</code></td>
<td>保留</td>
</tr>
<tr>
<td>12</td>
<td>-4</td>
<td><code>0x30</code></td>
<td>调试监视器 (最低有效位为1)</td>
</tr>
<tr>
<td>11</td>
<td>-5</td>
<td><code>0x2C</code></td>
<td>SVC (最低有效位为1)</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>0x28</code></td>
<td>保留</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>0x24</code></td>
<td>保留</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>0x20</code></td>
<td>保留</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>0x1C</code></td>
<td>保留</td>
</tr>
<tr>
<td>6</td>
<td>-10</td>
<td><code>0x18</code></td>
<td>使用故障 (最低有效位为1)</td>
</tr>
<tr>
<td>4</td>
<td>-11</td>
<td><code>0x14</code></td>
<td>总线故障 (最低有效位为1)</td>
</tr>
<tr>
<td>4</td>
<td>-12</td>
<td><code>0x10</code></td>
<td>内存管理故障 (最低有效位为1)</td>
</tr>
<tr>
<td>3</td>
<td>-13</td>
<td><code>0x0C</code></td>
<td>硬故障 (最低有效位为1)</td>
</tr>
<tr>
<td>2</td>
<td>-14</td>
<td><code>0x08</code></td>
<td>NMI (最低有效位为1)</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td><code>0x04</code></td>
<td>复位 (最低有效位为1)</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>0x00</code></td>
<td>MPS的初始值</td>
</tr>
</tbody>
</table>
<p>　　当发生异常事件并执行对应的异常处理函数时，为了获取异常处理函数的起始地址，需要使用向量表机制。向量表是系统内存中的字数据数组，每个字数据表示1种异常类型的起始地址。向量表是可重定位的，并且重定位由NVIC中的<strong>向量表偏移寄存器</strong>
(VTOR)
控制。VTOR是可编程的。当复位后，VTOR会被重置为0，所以向量表也会被定位到地址<code>0x0</code>。</p>
<p>　　若复位为异常类型1，则复位向量的地址为<code>0x00000004</code>
(每个字是4字节)，并且NMI向量 (类型2)
会位于地址<code>0x00000008</code>。地址<code>0x00000000</code>用于存储MSP的起始值。</p>
<p>　　每个异常向量的最低有效位表示执行该异常时是否处于Thumb状态。因为Cortex-M处理器仅支持Thumb指令，所以所有异常向量的最低有效位必须为1。</p>
<h4 id="故障处理">4.4.3 故障处理</h4>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/fault_exceptions_usages.svg" class="">
<p>　　Cortex-M3和Cortex-M4处理器的几种异常是故障处理异常。当处理器检测到未定义的指令等异常或总线系统向内存访问返回错误时，会触发故障异常。故障异常机制可以快速检测错误，并可能允许软件执行补救措施。</p>
<h4 id="系统控制块">4.4.4 系统控制块</h4>
<p>　　处理器的一部分合并到了NIVC，该部分是<strong>系统控制块</strong>
(SCB)。SCB包含用于以下目的的寄存器：</p>
<p>　　● 控制寄存器配置 (例如，低功耗模式)</p>
<p>　　● 提供故障状态信息 (故障状态寄存器)</p>
<p>　　● 向量表重定位 (VTOR)</p>
<p>　　SCB是映射到内存的。与NVIC寄存器类似，SCB寄存器通过<span
style="background-color: yellow">系统控制空间</span> (SCS) 访问。</p>
<h3 id="调试">4.5 调试</h3>
<p>　　Cortex-M处理器提供了调试接口和跟踪接口，两者都是使用调试适配器。</p>
<p>　　调试接口允许调试适配器连接到Cortex-M微处理器，以控制调试功能和访问内存空间。Cortex-M处理器支持传统的JTAG协议和较新的<span
style="background-color: yellow">串口线调试</span> (SWD)
协议。前者使用4或5个引脚 (nTRST、TCK、TDI、TMS和TDO)，后者使用2个引脚
(串行线时钟和串行线数据)。SWD协议由ARM开发，仅使用2个引脚即就能在不损失调试性能的情况下提供与JTAG相同的调试功能。很多调试适配器都支持这2种协议。这2种协议可以使用同一连接器，JTAG的TCK与串行线时钟共用同一引脚，而JTAG的TMS与串行线数据共用同一引脚。</p>
<p>　　跟踪接口用于在运行时收集信息。Cortex-M处理器支持2种跟踪接口：<span
style="background-color: yellow">串行线查看器</span> (SWV) 和<span
style="background-color: yellow">跟踪端口</span>。</p>
<p>　　●
SWV仅使用1个引脚，成本低，跟踪数据带宽也较低，但足以处理选择性数据跟踪、事件跟踪和基本性能分析的捕获。SWV的输出信号称为<span
style="background-color: yellow">串行线输出</span>
(SWO)，可以与JTAG的TDO共享同一引脚。</p>
<p>　　● 跟踪端口需要1个时钟引脚 (TRACECLK) 和多个数据引脚
(TRACEDATA)。数据引脚的数量是可配置的，在大多数情况下，Cortex-M3和Cortex-M4处理器支持最多4个数据引脚。跟踪端口的数据带宽比SWV的更高。</p>
<p>　　此外，Cortex-M3和Cortex-M4处理器的内部还有ITM等其他调试组件。</p>
<h3 id="复位和复位序列">4.6 复位和复位序列</h3>
<p>　　对于典型Cortex-M处理器，存在3种复位：</p>
<p>　　●
上电复位：重置整个微处理器，包括处理器、调试支持组件和外设。</p>
<p>　　● 系统复位：仅重置处理器和外设。</p>
<p>　　● 处理器复位：仅重置处理器。</p>
<p>　　在系统调试或处理器复位操作期间，Cortex-M3和Cortex-M4处理器的调试组件不会重置，所以调试主机和微控制器之间的连接会被保留。调试主机可以通过SCB寄存器执行系统复位或处理器复位。</p>
<p>　　上电复位和系统复位所需的时间取决于微控制器设计。在某些情况下，复位会持续几毫秒，因为复位控制器需要等待时钟源
(例如，晶体振荡器) 稳定。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/reset_sequence.svg" class="">
<p>　　在复位之后以及处理器开始执行程序之前，Cortex-M处理器会从内存读取前2个字。向量表位于内存空间的开头，并且前2个字是MSP的初始值和复位向量
(即复位处理函数的起始地址)。当读取前2个字后，处理器会使用这些值设置MSP和PC。</p>
<p>　　设置MSP是必要的。NMI或硬故障等异常会在复位不久后发生，处理这些异常需要使用栈内存，所以MSP需要在处理异常之前将某些处理器状态压入栈中。</p>
<p>　　对于大部分C开发环境，C起始代码也会在进入主函数
(<code>main()</code>)
之前更新MSP。这2个初始化步骤允许具有外部存储器的微控制器设备将外部存储器作为栈
(例如，它可以在位于小型内部SRAM中的栈中启动，并在重置处理函数中初始化外部存储控制器，然后执行C启动代码，该代码随后会将外部存储器作为栈)。</p>
<p>　　栈指针初始化行为不同于ARM7TDMI等经典ARM处理器。对于这些处理器，复位后会从地址<code>0x0</code>开始执行指令，栈指针必须由软件初始化。此外，这些处理器的向量表存储着指令代码
(而非地址值)。</p>
<img src="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/initial_stack_pointer_value_and_initial_program_counter_value_example.svg" class="">
<p>　　如图所示，栈内存的地址范围从<code>0x20007C00</code>到<code>0x20007FFF</code>
(1KB)，栈的初始值是<code>0x20008000</code>。向量表中的向量地址的最低有效位应该被设置为1
(表示Thumb代码)。因此，复位向量的地址为<code>0x00000101</code>
(引导代码的起始地址)。当读取复位向量后，Cortex-M处理器会从复位向量地址开始执行代码。</p>
<p>　　各种软件开发工具可能会使用不同的方法来指定起始栈指针和复位向量。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第9章 进程凭证</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_09/</url>
    <content><![CDATA[<p>　　每个进程都有1组关联的数字用户ID和组ID，包括<span
style="background-color: yellow">实际用户ID和实际组ID</span>、<span
style="background-color: yellow">有效用户ID和有效组ID</span>、<span
style="background-color: yellow">保存的set-user-ID和保存的set-group-ID</span>、<span
style="background-color: yellow">文件系统用户ID和文件系统组ID</span>
(特定于Linux) 和<span
style="background-color: yellow">辅助组ID</span>。这些ID统称为<strong>进程凭证</strong>。</p>
<p>　　实际用户ID和实际组ID分别是进程的所有者和所属组的ID。作为登录过程的一部分，登录shell会将用户的密码文件记录的第3个和第4个字段作为其实际用户ID和实际组ID。当进程被创建时，会继承父进程的实际用户ID和实际组ID。</p>
<p>　　对于大多数UNIX实现
(Linux略有不同)，有效用户ID和有效组ID与辅助组ID一起使用来确定进程访问文件、System
V
IPC对象和其他系统资源时拥有的权限。此外，系统会通过有效用户ID来决定进程是否能发送信号给其他进程。</p>
<p>　　辅助组ID是进程所属的附加组的ID。子进程会从父进程继承辅助组ID。登录shell会从系统组文件获取辅助组ID。</p>
<p>　　有效用户ID为0 (root的用户ID)
的进程是<strong>特权进程</strong>，该进程拥有超级用户的所有特权。特定系统调用只能由特权进程执行。</p>
<p>　　通常，有效用户ID和有效组ID与对应的实际用户ID和实际组ID相同。但是，可以通过2种方式来让有效用户ID和有效组ID异于对应的实际用户ID和实际组ID。第1种方式是通过系统调用，第2种方式是通过set-user-ID和set-group-ID程序。</p>
<p>　　所有进程的凭证都可以通过特定于Linux的文件<code>/proc/PID/status</code>的行<code>Uid</code>、<code>Gid</code>和<code>Groups</code>来获取，行<code>Uid</code>和<code>Gid</code>按序列出了实际用户ID、实际组ID、有效用户ID、有效组ID、保存的set-user-ID、保存的set-group-ID、文件系统用户ID和文件系统组ID。</p>
<p>　　Linux将超级用户特权划分为不同的能力，其中与修改进程的用户ID和组ID相关的能力有2个：</p>
<p>　　● 能力<code>CAP_SETUID</code>允许进程修改其用户ID。</p>
<p>　　● 能力<code>CAP_SETGID</code>允许进程修改其组ID。</p>
<span id="more"></span>
<h3 id="set-user-id程序和set-group-id程序">9.1
set-user-ID程序和set-group-ID程序</h3>
<p>　　set-user-ID程序会通过将进程的有效用户ID设置为可执行文件的所有者的用户ID来让进程获得它通常没有的特权。set-group-ID程序对进程的有效组ID执行类似的操作。set-user-ID程序和set-group-ID程序有时会缩写为<span
style="background-color: yellow">set-UID程序</span>和<span
style="background-color: yellow">set-GID程序</span>。</p>
<p>　　与其他文件一样，可执行文件有1个关联的用户ID和1个关联的组ID
(即所有者的用户ID和所属组的组ID)。可执行文件有2个特殊的权限位：set-user-ID位和set-group-ID位
(实际上，所有文件都有这2个权限位，但可执行文件的这2个权限位的功能不同于其他文件)。这2个权限位可以通过命令<code>chmod</code>修改。非特权用户只能修改它拥有的文件的这2个权限位，特权用户
(能力<code>CAP_FOWNER</code>) 可以修改所有文件的这2个权限位。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l prog</span></span><br><span class="line">-rwxr-xr-x 1 root root 302585 Jun 26 15:05 prog</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> u+s prog</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> g+s prog</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l prog</span></span><br><span class="line">-rwsr-sr-x 1 root root 302585 Jun 26 15:05 prog</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>
<p>　　第2行和第6行的命令会列出<code>prog</code>的访问权限，包括set-user-ID位和set-group-ID位。第4行和第5行的命令会启用<code>prog</code>的set-user-ID位和set-group-ID位。启用后，<code>prog</code>的权限位中的x
(表示执行权限) 被替换为s。第8行的命令会退出会话。</p>
<p>　　由于某些原因，set-user-ID位和set-group-ID位对Linux的shell脚本无效。</p>
<p>　　当set-user-ID程序启动时
(通过<code>exec()</code>来将其加载到进程的内存)，内核会将用于运行该程序的进程的有效用户ID设置为该程序的所有者的用户ID。set-group-ID程序对用于运行程序的进程的有效组ID执行类似的操作。当用于运行程序的进程的有效用户ID或有效组ID以这种方式修改后，进程将拥有通常没有的特权。例如，若可执行文件的所有者是root，并且启用了set-user-ID位，则用于运行该可执行文件的进程将拥有超级用户特权。</p>
<p>　　有时，可能需要通过set-user-ID程序或set-group-ID程序来将进程的有效ID更改为非0值。例如，为了提供对受保护文件
(或其他系统资源) 的访问，需要创建1个仅拥有访问该文件所需特权的专用用户ID
(或组ID)，然后通过set-user-ID程序 (或set-group-ID程序)
来将进程的有效用户ID (或有效组ID) 设置为该用户ID
(或组ID)。这样可以避免进程滥用超级用户特权。</p>
<p>　　对于Linux，常用的set-user-ID程序包括<code>passwd</code>
(修改用户密码)、<code>mount</code>和<code>unmount</code>
(挂载和卸载文件系统) 以及<code>su</code>
(允许用户以不同的用户ID来运行shell)，常用的set-group-ID程序包括<code>wall</code>
(发送1条信息到所有属于组<code>tty</code>的终端，而所有终端通常都属于该组)。</p>
<h3 id="保存的set-user-id和保存的set-group-id">9.2
保存的set-user-ID和保存的set-group-ID</h3>
<p>　　保存的set-user-ID和保存的set-group-ID旨在与set-user-ID程序和set-group-ID程序一起使用。当运行程序时，会执行以下步骤
(以及很多其他步骤)：</p>
<p>　　1) 若可执行文件启用了set-user-ID位
(或set-group-ID位)，则用于运行可执行文件的进程的有效用户ID (或有效组ID)
会设置为可执行文件的所有者的用户ID
(或组ID)；若未启用，则不会修改用于运行可执行文件的进程的有效用户ID
(或有效组ID)。</p>
<p>　　2)
将有效用户ID和有效组ID的值复制给对应的保存的set-user-ID和保存的set-group-ID。无论执行时是否启用了set-user-ID位和set-group-ID位，该步骤都会发生。</p>
<p>　　例如，实际用户ID、有效用户ID和保存的set-user-ID都是1000的进程运行所有者是root的set-user-ID程序后，进程的实际用户ID仍然是1000，但有效用户ID和保存的set-user-ID会变为0。</p>
<p>　　很多系统调用允许set-user-ID程序的有效用户ID在实际用户ID和保存的set-user-ID之间切换。类似的系统调用允许set-group-ID程序修改其有效组ID。通过这种方式，程序可以暂时失去和重新获得与可执行文件的用户ID
(或组ID) 关联的所有特权。</p>
<p>　　保存的set-user-ID和保存的set-group-ID有时也称为<span
style="background-color: yellow">保存的用户ID</span>和<span
style="background-color: yellow">保存的组ID</span>。</p>
<p>　　保存的set-user-ID和保存的set-group-ID源于System
V，随后POSIX将其标准化。4.4BSD之前的版本不提供该这些ID。最初的POSIX.1标准将这些ID的支持作为可选项，后来的标准
(从1988年的FIPS 151-1开始) 强制要求支持这些ID。</p>
<h3 id="文件系统用户id和文件系统组id">9.3
文件系统用户ID和文件系统组ID</h3>
<p>　　对于Linux，执行打开文件、修改文件的所有者和修改文件的访问权限等文件系统操作时决定相关权限的ID是文件系统用户ID和文件系统组ID
(与辅助组ID一起)，而非有效用户ID和有效组ID。</p>
<p>　　通常，文件系统ID与对应的有效ID相同。此外，当有效ID被修改时，对应的文件系统ID也会自动变为相同的值。文件系统ID可以通过特定于Linux的系统调用<code>setfsuid()</code>和<code>setfsgid()</code>来修改。</p>
<p>　　文件系统ID首次出现在Linux
1.2中，在这个内核版本中，只有进程A的有效用户ID与进程B的实际用户ID或有效用户ID相同时，进程A才能发送信号给进程B。这影响了Linux
NFS服务器等程序，因为这些程序需要经常访问文件，所以需要将自己的有效用户ID修改为对应的客户端进程的有效用户ID。但是，当NFS服务器修改了自己的有效用户ID后，它容易受到来自非特权用户进程的信号的影响。于是，Linux加入了文件系统ID。通过仅修改自己的文件系统ID，NFS服务器可以伪装成其他用户来访问文件，而不会受到来自用户进程的信号的影响。</p>
<p>　　从内核
2.0开始，Linux采用了SUSv3的关于信号发送权限的规则，这些规则不涉及目标进程的有效用户ID。因此，文件系统ID不再是必要的，但为了兼容现有软件，这些ID得以存留下来。</p>
<h3 id="检索和修改进程凭证">9.4 检索和修改进程凭证</h3>
<p>　　Linux提供了大量用于检索和修改进程凭证的系统调用和库函数，但SUSv3仅详细说明了其中的部分函数。</p>
<p>　　为了区分set-user-ID程序，这里会使用术语set-user-ID-root程序来表示拥有超级用户特权的set-user-ID程序。</p>
<h4
id="检索和修改实际id有效id保存的set-user-id和保存的set-group-id">9.4.1
检索和修改实际ID、有效ID、保存的set-user-ID和保存的set-group-ID</h4>
<h5 id="检索实际id和有效id">9.4.1.1 检索实际ID和有效ID</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的实际用户ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">geteuid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的有效用户ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的实际组ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getegid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的有效组ID */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getuid()</code>和<code>getgid()</code>会返回调用进程的实际ID。系统调用<code>geteuid()</code>和<code>getegid()</code>会返回调用进程的有效ID。这4个系统调用不会失败。</p>
<h5 id="修改有效id">9.4.1.2 修改有效ID</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>setuid()</code>会将调用进程的有效用户ID
(可能还有实际用户ID和保存的set-user-ID)
修改为参数<code>uid</code>指定的值。系统调用<code>setgid()</code>会对调用进程的组ID执行类似的操作。</p>
<p>　　<code>setuid()</code>和<code>setgid()</code>对调用进程的有效ID做出的修改取决于该进程是否是特权进程
(有效用户ID是0)。以下规则适用于<code>setuid()</code>：</p>
<p>　　1)
对于非特权进程，只能修改有效用户ID，并且有效用户ID只能修改为对应的实际用户ID或保存的set-user-ID的当前值
(否则，会导致错误<code>EPERM</code>)。这意味着，对于非特权用户，只有运行set-user-ID程序时，对<code>setuid()</code>的调用才有效，因为运行常规程序时，进程的实际用户ID、有效用户ID和保存的set-user-ID相同。对于部分BSD衍生实现，非特权进程对<code>setuid()</code>或<code>setgid()</code>的调用有所不同：该调用会将实际ID、有效ID、保存的set-user-ID和保存的set-group-ID修改为实际ID或有效ID的当前值。</p>
<p>　　2)
对于特权进程，只有调用<code>setuid()</code>时将<code>uid</code>指定为非0值，实际用户ID、有效用户ID和保存的set-user-ID才会修改为<code>uid</code>指定的值。这个过程是不可逆的，一旦修改后，进程将失去所有特权，所以不能通过<code>setuid()</code>将这些ID恢复为0。</p>
<p>　　<code>setgid()</code>的情况与<code>setuid()</code>的类似。规则1同样适用于<code>setgid()</code>。对于规则2，因为修改组ID并不会导致进程失去特权，所以特权进程可以任意修改其组ID。</p>
<p>　　当需要让有效用户ID为0的set-user-ID-root程序永久失去特权时，应该将其有效用户ID和保存的set-user-ID都修改为实际用户ID。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">seteuid</span><span class="params">(<span class="type">uid_t</span> euid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setegid</span><span class="params">(<span class="type">gid_t</span> egid)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>seteuid()</code>会将调用进程的有效用户ID修改为参数<code>euid</code>指定的值。系统调用<code>setegid()</code>会将调用进程的实际组ID修改为参数<code>egid</code>指定的值。</p>
<p>　　<code>seteuid()</code>和<code>setegid()</code>对进程的有效ID做出的修改遵循以下规则：</p>
<p>　　1)
对于非特权进程，有效ID只能修改为实际ID或保存的set-user-ID/set-group-ID的当前值。因此，调用<code>seteuid()</code>等同于调用<code>setuid()</code>，调用<code>setegid()</code>等同于调用<code>setgid()</code>
(除了部分BSD衍生实现之外)。</p>
<p>　　2)
对于特权进程，有效ID可以修改为任意值。若特权进程通过<code>seteuid()</code>将其有效用户ID修改为非0值，则该进程将会失去特权。由于规则1，该进程可以再次获取特权。</p>
<p>　　使用<code>seteuid()</code>是让set-user-ID程序和set-group-ID程序临时失去特权，然后再次获取特权的首选方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">euid = geteuid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (seteuid(getuid()) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (seteuid(euid) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<code>seteuid()</code>和<code>setegid()</code>源于BSD，SUSv3将其标准化，并且大多数UNIX实现都提供了这2个函数。</p>
<h5 id="修改实际id和有效id">9.4.1.3 修改实际ID和有效ID</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setreuid</span><span class="params">(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setregid</span><span class="params">(<span class="type">gid_t</span> rgid, <span class="type">gid_t</span> egid)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>setreuid()</code>允许调用进程分别修改其实际用户ID
(参数<code>ruid</code>) 和有效用户ID
(参数<code>euid</code>)。系统调用<code>setregid()</code>允许调用进程分别修改其实际组ID
(参数<code>rgid</code>) 和有效组ID
(参数<code>eguid</code>)。若只需要修改实际ID或有效ID，则应该把不需要修改的ID指定为-1。</p>
<p>　　<code>setreuid()</code>对进程的用户ID做出的修改遵循以下规则
(<code>setregid()</code>与之类似)：</p>
<p>　　1)
对于非特权进程，实际用户ID只能修改为实际用户ID或有效用户ID的当前值，有效用户ID只能修改为实际用户ID、有效用户ID或保存的set-user-ID的当前值。</p>
<p>　　2) 对于特权进程，实际用户ID和有效用户ID可以修改为任意值。</p>
<p>　　3)
若<code>ruid</code>不为-1，或者有效用户ID被设置为调用该函数之前的实际用户ID值以外的值，则保存的set-user-ID也会自动被修改为有效用户ID的新值。换句话说，若进程只通过<code>setreuid()</code>来将有效用户ID修改为实际用户ID的当前值，则保存的set-user-ID不变，并且随后对<code>setreuid()</code>
(或<code>seteuid()</code>)
的调用可以将有效用户ID恢复成保存的set-user-ID值
(SUSv3没有说明<code>setreuid()</code>和<code>setregid()</code>对保存的set-user-ID和保存的set-group-ID的影响，但SUSv4详细说明了这里描述的行为)。</p>
<p>　　规则3为set-user-ID程序提供了1种永久失去特权的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setreuid(getuid(), getuid());</span><br></pre></td></tr></table></figure>
<p>　　如果set-user-ID-root程序需要修改其用户凭证和组凭证，应该先调用<code>setregid()</code>，再调用<code>setreuid()</code>。若以相反的顺序调用这2个函数，则<code>setregid()</code>会失败，因为调用<code>setreuid()</code>后，程序会失去特权。</p>
<p>　　<code>setreuid()</code>和<code>setregid()</code>源于BSD，SUSv3将其标准化，并且大多数UNIX实现都提供了这2个函数。</p>
<p>　　SUSv3没有说明非特权进程能否通过<code>setreuid()</code>来将其实际用户ID修改为实际用户ID、有效用户ID或保存的set-user-ID的当前值，并且具体可以对实际用户ID做出哪些修改因实现而异。</p>
<p>　　SUSv3描述的<code>setregid()</code>的行为略有不同：非特权进程能够将其实际组ID修改为保存的set-group-ID的当前值，或将有效组ID修改为实际组ID或保存的set-group-ID的当前值。同样，具体可以对实际组ID和有效组ID做出哪些修改因实现而异。</p>
<p>　　4.3BSD及以下版本没有保存的set-user-ID和保存的set-group-ID
(SUSv3强制要求提供这2个ID)。因此，对于BSD，<code>setreuid()</code>和<code>setregid()</code>允许进程通过来回切换实际ID和有效ID的值来失去和重获特权。但是，这种行为有副作用：必须通过修改实际用户ID来修改有效用户ID。</p>
<p>　　对于glibc
2.0及以下版本，<code>seteuid(euid)</code>被实现为<code>setreuid(–1, euid)</code>。对于之后的版本，
<code>seteuid(euid)</code>被实现为<code>setresuid(–1, euid, –1)</code>。这2种实现都允许将<code>euid</code>指定为有效用户ID的当前值
(不进行修改)。但是，SUSv3没有说明这种行为，并且部分UNIX实现不允许这种行为。</p>
<p>　　对于glibc的所有版本，<code>setegid()</code>都被实现为<code>setregid(–1, egid)</code>。与<code>seteuid()</code>类似，<code>egid</code>可以指定为有效组ID的当前值，尽管SUSv3没有说明这种行为。这表示将有效组ID修改为实际组ID以外的值时，<code>setegid()</code>还会修改保存的set-group-ID
(通过<code>setreuid()</code>实现的<code>seteuid()</code>会出现类似的行为)。同样，SUSv3没有说明这种行为。</p>
<h5
id="检索和修改实际id有效id保存的set-user-id和保存的set-group-id-1">9.4.1.4
检索和修改实际ID、有效ID、保存的set-user-ID和保存的set-group-ID</h5>
<p>　　对于大多数UNIX实现，进程无法直接检索和修改其保存的set-user-ID和保存的set-group-ID。但是，Linux提供了4个用于此目的的系统调用：<code>getresuid()</code>、<code>getresgid()</code>、<code>setresuid()</code>、<code>setresgid()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getresuid</span><span class="params">(<span class="type">uid_t</span> *ruid, <span class="type">uid_t</span> *euid, <span class="type">uid_t</span> *suid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getresgid</span><span class="params">(<span class="type">gid_t</span> *rgid, <span class="type">gid_t</span> *egid, <span class="type">gid_t</span> *sgid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setresuid</span><span class="params">(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid, <span class="type">uid_t</span> suid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setresgid</span><span class="params">(<span class="type">gid_t</span> rgid, <span class="type">gid_t</span> egid, <span class="type">gid_t</span> sgid)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getresuid()</code>会将调用进程的实际用户ID、有效用户ID和保存的set-user-ID的当前值保存在3个参数指向的位置。系统调用<code>getresgid()</code>会对对应的组ID执行类似的操作。</p>
<p>　　系统调用<code>setresuid()</code>会将调用进程的实际用户ID、有效用户ID和保存的set-user-ID修改为3个参数指定的值。系统调用<code>setresgid()</code>会对对应的组ID执行类似的操作。若只需要修改这3个ID中的部分ID，则应该把不需要修改的ID指定为-1。</p>
<p>　　<code>setresuid()</code>对进程的用户ID做出的修改遵循以下规则
(<code>setresgid()</code>与之类似)：</p>
<p>　　1)
对于非特权进程，实际用户ID、有效用户ID和保存的set-user-ID只能修改为实际用户ID、有效用户ID和保存的set-user-ID的当前值。</p>
<p>　　2)
对于特权进程，实际用户ID、有效用户ID和保存的set-user-ID可以修改为任意值。</p>
<p>　　3)
无论该函数如何修改ID，文件系统用户ID都会与有效用户ID的当前值相同。</p>
<p>　　对<code>setresuid()</code>和<code>setresgid()</code>的调用要么修改所有请求的ID，要么不做修改。SUSv3没有说明这2个函数，并且只有少部分UNIX实现提供了这2个函数。</p>
<h4 id="检索和修改文件系统id">9.4.2 检索和修改文件系统ID</h4>
<p>　　特定于Linux的系统调用<code>setfsuid()</code>和<code>setfsgid()</code>用于修改文件系统ID。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fsuid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setfsuid</span><span class="params">(<span class="type">uid_t</span> fsuid)</span>; <span class="comment">/* 返回调用之前的文件系统用户ID值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setfsgid</span><span class="params">(<span class="type">gid_t</span> fsgid)</span>; <span class="comment">/* 返回调用之前的文件系统组ID值 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>setfsuid()</code>会将调用进程的文件系统用户ID修改为<code>fsuid</code>指定的值。系统调用<code>setfsgid()</code>会将调用进程的文件系统组ID修改为<code>fsgid</code>指定的值。</p>
<p>　　<code>setfsuid()</code>对进程的文件系统用户ID做出的修改遵循以下规则
(<code>setfsgid()</code>与之类似)：</p>
<p>　　1)
对于非特权进程，文件系统用户ID只能修改为实际用户ID、有效用户ID、文件系统用户ID和保存的set-user-ID的当前值。</p>
<p>　　2) 对于特权进程，文件系统用户ID可以修改为任意值。</p>
<p>　　这2个系统调用的实现存在些许问题。首先，没有对应的系统调用来检索文件系统ID的当前值。其次，这2个系统调用没有错误检测。当非特权进程试图将其文件系统ID修改为无效值时，这2个系统调用会直接忽略此次修改。无论是否出错，这2个系统调用都会返回调用之前的文件系统ID值。因此，可以通过修改文件系统ID
(无论是否出错) 来获取文件系统ID的值。</p>
<h4 id="检索和修改辅助组id">9.4.3 检索和修改辅助组ID</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getgroups</span><span class="params">(<span class="type">int</span> gidsetsize, <span class="type">gid_t</span> grouplist[])</span>; <span class="comment">/* 成功时返回grouplist中的组ID数，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getgroups()</code>用于获取调用进程所属的组
(集)，结果存储在参数<code>grouplist</code>指定的数组中。调用进程必须分配<code>grouplist</code>，并在参数<code>gidsetsize</code>中指定其长度。</p>
<p>　　若<code>getgroups()</code>成功，则会返回<code>grouplist</code>中的组ID数。</p>
<p>　　对于Linux和大多数UNIX实现，<code>grouplist</code>仅包含调用进程的辅助组ID，但SUSv3允许<code>grouplist</code>包含调用进程的有效组ID。</p>
<p>　　若调用进程所属的组的数量大于<code>gidsetsize</code>，则<code>getgroups()</code>会返回-1，并将<code>errno</code>设置为<code>EINVAL</code>。为了防止这种情况，可以在声明<code>grouplist</code>时将其大小指定为大于常量<code>NGROUPS_MAX</code>
(定义在头文件<code>limits.h</code>中)
的值，该常量定义了进程最多能属于多少个辅助组。因此，可以以如下方式声明<code>grouplist</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">gid_t</span> grouplist[NGROUPS_MAX + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>　　对于Linux
2.6.4及以上版本，<code>NGROUPS_MAX</code>是65536。对于之前的版本，<code>NGROUPS_MAX</code>是32。</p>
<p>　　应用程序可以在运行时通过特定于Linux的文件<code>/proc/sys/kernel/ngroups_max</code>
(Linux 2.6.4及以上版本)
或调用<code>sysconf(_SC_NGROUPS_MAX)</code>来获取<code>NGROUPS_MAX</code>的值。</p>
<p>　　应用程序在调用<code>getgroups()</code>时可以将<code>gidsetsize</code>指定为0。此时，<code>grouplist</code>不会被修改，但返回值会给出调用进程所属的组的数量。</p>
<p>　　特权进程可以通过系统调用<code>setgroups()</code>和<code>initgroups()</code>来修改其辅助组ID。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setgroups</span><span class="params">(<span class="type">size_t</span> gidsetsize, <span class="type">const</span> <span class="type">gid_t</span> *grouplist)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">initgroups</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *user, <span class="type">gid_t</span> group)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>setgroups()</code>会将调用进程的辅助组ID替换为参数<code>grouplist</code>指定的组ID。参数<code>gidsetsize</code>指定<code>grouplist</code>中的组ID的数量。</p>
<p>　　系统调用<code>initgroups()</code>会扫描<code>/etc/groups</code>，并且生成参数<code>user</code>指定的用户所属的组的列表，然后通过该组列表来初始化调用进程的辅助组ID。此外，参数<code>group</code>指定的组ID也会添加到进程的辅助组ID。</p>
<p>　　<code>initgroups()</code>主要用于创建登录会话的程序，此类程序通常通过读系统密码文件中的用户记录的组ID字段来获取用于参数<code>group</code>的值。</p>
<p>　　SUSv3没有说明<code>setgroups()</code>和<code>initgroups()</code>，但所有UNIX实现都提供了这2个函数。</p>
<h4 id="示例程序">9.4.4 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* idshow.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fsuid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span> <span class="comment">/* userNameFromId() &amp; groupNameFromId() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SG_SIZE (NGROUPS_MAX + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uid_t</span> ruid, euid, suid, fsuid;</span><br><span class="line">    <span class="type">gid_t</span> rgid, egid, sgid, fsgid;</span><br><span class="line">    <span class="type">gid_t</span> suppGroups[SG_SIZE];</span><br><span class="line">    <span class="type">int</span> numGroups, j;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getresuid(&amp;ruid, &amp;euid, &amp;suid) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;getresuid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getresgid(&amp;rgid, &amp;egid, &amp;sgid) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;getresgid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对于非特权进程，对文件系统ID的修改会被忽略，尽管如此，以下调用会返回当前的文件系统ID */</span></span><br><span class="line">    fsuid = setfsuid(<span class="number">0</span>);</span><br><span class="line">    fsgid = setfsgid(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UID: &quot;</span>);</span><br><span class="line">    p = userNameFromId(ruid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;real=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)ruid);</span><br><span class="line">    p = userNameFromId(euid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;eff=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)euid);</span><br><span class="line">    p = userNameFromId(suid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;saved=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)suid);</span><br><span class="line">    p = userNameFromId(fsuid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fs=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)fsuid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GID: &quot;</span>);</span><br><span class="line">    p = groupNameFromId(rgid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;real=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)rgid);</span><br><span class="line">    p = groupNameFromId(egid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;eff=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)egid);</span><br><span class="line">    p = groupNameFromId(sgid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;saved=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)sgid);</span><br><span class="line">    p = groupNameFromId(fsgid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fs=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)fsgid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    numGroups = getgroups(SG_SIZE, suppGroups);</span><br><span class="line">    <span class="keyword">if</span> (numGroups == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;getgroups&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Supplementary groups (%d): &quot;</span>, numGroups);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numGroups; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = groupNameFromId(suppGroups[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s (%ld) &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)suppGroups[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过上述系统调用和库函数来检索和打印进程的用户ID和组ID。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《深入理解计算机系统 第3版》第10章 系统级I/O</title>
    <url>/misc/computer_systems_a_programmer&#39;s_perspective_3e_chpt_10/</url>
    <content><![CDATA[<p>　　<strong>输入/输出</strong>就是在内存与硬盘驱动或网络等外部设备之间复制数据的过程，输入就是从I/O设备复制数据到内存，输出就从内存复制数据到I/O设备。</p>
<p>　　Linux<strong>文件</strong>就是<span
class="math inline">\(m\)</span>字节的序列<span
class="math inline">\(B_0,B_1,...,B_k,...B_{m-1}\)</span>。所有I/O设备都会被模型化为文件，并且所有I/O通过读/写合适的文件来执行。这种从设备到文件的映射允许Linux内核输出称为<strong>UNIX
I/O</strong>的底层应用接口，这使得I/O能以统一且一致的方式执行。</p>
<p>　　1) <span
style="background-color: yellow">打开文件</span>。应用程序通过向内核请求打开对应的文件来声明其想要访问I/O设备的意图。内核会返回较小的非负整数，称为<strong>描述符</strong>，它会在之后所有的对该文件的操作中标识该文件。内核会保留该文件的所有信息的记录。应用程序只会保留描述符。</p>
<p>　　2) <span
style="background-color: yellow">改变当前文件位置</span>。内核会为每个文件都维护<strong>文件位置</strong><span
class="math inline">\(k\)</span>，其初始化值为0。文件位置是从文件起始处的字节偏移。应用程序可以通过seek操作
(调用函数<code>lseek()</code>) 显式地设置文件位置。</p>
<p>　　3) <span
style="background-color: yellow">读写文件</span>。读操作会从文件的当前文件位置<span
class="math inline">\(k\)</span>处复制<span
class="math inline">\(n\)</span>字节到内存，然后将<span
class="math inline">\(k\)</span>增加<span
class="math inline">\(n\)</span>。同样，写操作会从内存复制<span
class="math inline">\(n\)</span>字节到文件的当前文件位置<span
class="math inline">\(k\)</span>处，然后更新<span
class="math inline">\(k\)</span>。对于<span
class="math inline">\(m\)</span>字节的文件，执行读操作时<span
class="math inline">\(k\geqslant
m\)</span>会触发称为<strong>文件结束符</strong>的条件，应用程序能检测到该条件。文件结尾并没有显式的文件结束符。</p>
<p>　　4) <span
style="background-color: yellow">关闭文件</span>。当应用程序完成访问文件时，它会通过请求内核关闭文件来通知内核。内核通过释放打开文件时创建的数据结构并将描述符恢复到可用描述符池来响应。当进程终止时，内核会关闭所有打开的文件并释放它们的内存资源。</p>
<p>　　C中定义了1组高级的输入和输出函数，称为<strong>标准I/O库</strong>，这为程序员提供了UNIX
I/O的更高级的替代方案，该库提供的功能有打开和关闭文件
(<code>fopen()</code>和<code>fclose()</code>)、读写字节
(<code>fread()</code>和<code>fwrite()</code>)、读写字符串
(<code>fgets()</code>和<code>fputs()</code>) 以及复杂的格式化I/O
(<code>scanf()</code>和<code>printf()</code>)。标准I/O库将打开的文件模型化为<strong>流</strong>，从程序员角度，流就是指向<code>FILE</code>类型结构体的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdin</span>;  <span class="comment">/* 标准输入 */</span></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdout</span>; <span class="comment">/* 标准输出 */</span></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stderr</span>; <span class="comment">/* 标准错误 */</span></span><br></pre></td></tr></table></figure>
<p>　　shell创建的每个进程都会在生命周期开始时打开3个文件：标准输入<code>stdin</code>
(描述符0)、标准输出<code>stdout</code> (描述符1)
和标准错误<code>stderr</code>
(描述符2)。头文件<code>unistd.h</code>包含常量<code>STDIN_FILEND</code>、<code>STDOUT_FILEND</code>和<code>STDERR_FILEND</code>，它们能够代替显式描述符值。</p>
<p>　　<code>FILE</code>类型的流就是<span
style="background-color: yellow">文件描述符</span>和<span
style="background-color: yellow">流缓冲区</span>的抽象，流缓冲区是为了最小化Linux
I/O系统调用的次数。例如，某程序会反复调用标准I/O函数<code>getc()</code>，该函数会返回文件的下一个字符。当首次调用函数<code>getc()</code>时，标准I/O库会调用1次函数<code>read()</code>用来填充流缓冲区并将流缓冲区的第1个字节返回给程序。只要流缓冲区中还有未读的字节，随后对函数<code>getc()</code>的调用都会直接从流缓冲区中得到服务。</p>
<span id="more"></span>
<h3 id="文件">10.1 文件</h3>
<p>　　每个Linux文件都有<strong>类型</strong>，用于指示它在系统中的作用。</p>
<p>　　●
<strong>常规文件</strong>可以包含任意数据。应用程序通常会区分文本文件和二进制文件，而内核不会。</p>
<p>　　●
<strong>目录</strong>是包含1组<strong>链接</strong>的文件，其中的每个链接将文件名映射到文件，这里的文件可以是其他目录。每个目录至少包括2个条目：<code>.</code>和<code>..</code>。<code>.</code>是到当前目录的链接，<code>..</code>是目录结构中当前目录的父目录的链接。</p>
<p>　　● <strong>套接字</strong>是用于通过网络与其他进程通信的文件。</p>
<p>　　●
其他文件类型还有<strong>命名管道</strong>、<strong>字符链接</strong>、<strong>字符设备</strong>和<strong>块设备</strong>。</p>
<p>　　命令<code>mkdir</code>可以创建目录，命令<code>ls</code>可以查看目录的内容，命令<code>rmdir</code>可以删除目录。</p>
<p>　　Linux文本文件只包括ASCII或Unicode字符，其中包括若干个<strong>文本行</strong>，每行包括若干个字符，以换行符<code>\n</code>结尾。<code>\n</code>等同于ASCII中的换行符LF，其值是<code>0xa</code>。Windows和网络协议的换行符是<code>\r\n</code>，其值是<code>0xd 0xa</code>，等同于Linux中的回车符加上换行符。当用Linux打开Windows中创建的文本文件时，行尾会有回车符<code>^M</code>，这可以通过如下命令移除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">perl -pi -e <span class="string">&quot;s/\r\n/\n/g&quot;</span> text.txt</span></span><br></pre></td></tr></table></figure>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_10/portion_of_the_linux_directory_hierarchy.svg" class="">
<p>　　Linux内核将文件组织为由根目录<code>/</code>锚定的单个目录层次结构。所有文件都是根目录的直接或间接后代。每个进程的<strong>当前工作目录</strong>作为其上下文的一部分。可以通过命令<code>cd</code>来改变当前工作目录。</p>
<p>　　目录层次结构中的位置由<strong>路径名</strong>指定。路径名是可选的<code>/</code>加上以<code>/</code>分隔的文件名组成的字符串。路径名有<span
style="background-color: yellow">相对路径名</span>和<span
style="background-color: yellow">绝对路径名</span>这2种形式。绝对路径名以<code>/</code>开头
(表示根目录)，相对路径名以文件名开头
(表示当前工作目录)。<code>hello.c</code>的绝对路径名是<code>/home/droh/hello.c</code>。若当前工作目录是<code>/home/droh</code>，则<code>hello.c</code>的相对路径名是<code>./hello.c</code>；若当前工作目录是<code>/home/bryant</code>，则<code>hello.c</code>的相对路径名是<code>../home/droh/hello.c</code>。</p>
<h3 id="打开和关闭文件">10.2 打开和关闭文件</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span> *filename, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 成功时返回文件描述符，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　进程可以通过函数<code>open()</code>打开已存在的文件或创建新文件。函数<code>open()</code>会将参数<code>filename</code>转换为文件描述符并返回描述符号，即进程未打开的最小描述符号。参数<code>flags</code>表示进程对文件的访问权限。</p>
<p>　　● <code>O_RDONLY</code>表示只读。</p>
<p>　　● <code>O_WRONLY</code>表示只写。</p>
<p>　　● <code>O_RDWR</code>表示可读写。</p>
<p>　　参数<code>flag</code>能与多个提供额外写指令的位掩码进行或操作。</p>
<p>　　●
<code>O_cREAT</code>表示若文件不存在，则创建文件名为<code>filename</code>的空文件。</p>
<p>　　● <code>O_TRUNC</code>表示若文件存在，则进行截断。</p>
<p>　　●
<code>O_APPEND</code>表示在写操作前，将文件位置设置为文件结尾。</p>
<p>　　例如，需要打开已存在的文件并在且结尾加上一些数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = Open(<span class="string">&quot;foo.txt&quot;</span>, O_WRONLY | O_APPEND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>　　参数<code>mode</code>表示新文件的访问权限位，这些位的符号名定义在头文件<code>sys/stat.h</code>中。</p>
<table>
<thead>
<tr>
<th>访问权限位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_IRUSR</code></td>
<td>用户 (所有者) 能读该文件</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td>用户 (所有者) 能写该文件</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td>用户 (所有者) 能执行该文件</td>
</tr>
<tr>
<td><code>S_IRGRP</code></td>
<td>用户所属组的成员能读该文件</td>
</tr>
<tr>
<td><code>S_IWGRP</code></td>
<td>用户所属组的成员能写该文件</td>
</tr>
<tr>
<td><code>S_IXGRP</code></td>
<td>用户所属组的成员能执行该文件</td>
</tr>
<tr>
<td><code>S_IROTH</code></td>
<td>其他用户 (所有用户) 能读该文件</td>
</tr>
<tr>
<td><code>S_IWOTH</code></td>
<td>其他用户 (所有用户) 能写该文件</td>
</tr>
<tr>
<td><code>S_IXOTH</code></td>
<td>其他用户 (所有用户) 能执行该文件</td>
</tr>
</tbody>
</table>
<p>　　每个进程的<code>umask</code>会作为其上下文的一部分，<code>umask</code>可以通过调用函数<code>umask()</code>来设置。当进程通过带参数<code>mode</code>调用函数<code>open()</code>创建新文件时，该文件的访问权限位会设置为<code>mode &amp; ~umask</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_MODE S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_UMASK S_IWGRP | S_IWOTH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">umask(DEF_MODE);</span><br><span class="line">fd = open(<span class="string">&quot;foo.txt&quot;</span>, O_CREAT | O_TRUNC | O_WRONLY, DEF_MODE);</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，函数<code>open()</code>会创建新文件，该文件的所有者有读写权限，其他用户有读权限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　进程可以调用函数<code>close()</code>来关闭打开的文件。关闭已关闭的文件会出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1, fd2;</span><br><span class="line">    fd1 = Open(<span class="string">&quot;foo.txt&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    Close(fd1);</span><br><span class="line">    fd2 = Open(<span class="string">&quot;baz.txt&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个示例中，由于UNIX进程在生命周期开始时会打开<code>stdin</code>
(描述符0)、<code>stdout</code> (描述符1) 和<code>stderr</code>
(描述符2)，第1次调用函数<code>open()</code>会返回描述符3，函数<code>close()</code>会关闭文件。因此，第2次调用函数<code>open()</code>也会返回描述符3。</p>
<h3 id="读和写文件">10.3 读和写文件</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>; <span class="comment">/* 成功时返回字节数，遇到EOF时返回0，失败时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span>; <span class="comment">/* 成功时返回字节数，失败时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　应用程序可以调用函数<code>read()</code>和<code>write()</code>来执行输入和输出。</p>
<p>　　函数<code>read()</code>会从文件描述符<code>fd</code>的当前文件位置处复制最多<code>n</code>字节到内存位置<code>buf</code>。若出错，则返回-1；若到达文件结尾，则返回0；若正常执行，则返回值就是实际传输的字节数。</p>
<p>　　函数<code>write()</code>会从内存位置<code>buf</code>处复制最多<code>n</code>字节到文件描述符<code>fd</code>的当前文件位置。</p>
<p>　　有时，函数<code>read()</code>和<code>write()</code>实际传输的字节数少于应用程序请求的字节数，这种<strong>计数不足</strong>的情况不属于错误，造成原因如下：</p>
<p>　　● <span
style="background-color: yellow">读时遇到EOF</span>。若需要读50B，而当前文件位置仅剩余20B，则本次读会返回20，而下次读该文件会返回0。</p>
<p>　　● <span
style="background-color: yellow">在终端读文本行</span>。若打开的文件与终端关联，例如，键盘和显示器，则每次执行函数<code>read()</code>会传输1行，返回值等于该行的长度。</p>
<p>　　● <span
style="background-color: yellow">读写套接字</span>。若打开的文件对应套接字，则网络缓冲区的限制和网络时延可能会导致计数不足。当在Linux管道中调用函数<code>read()</code>和<code>write()</code>时，也可能会导致计数不足。</p>
<p>　　实际中，读磁盘中的文件不会出现计数不足，除非EOF，写磁盘不会出现计数不足。但是对于可靠的网络应用程序，必须重复调用函数<code>read()</code>和<code>write()</code>直到满足需求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (Read(STDIN_FILENO, &amp;c, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Write(STDOUT_FILENO, &amp;c, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会每次从标准输入复制1B到标准输出。</p>
<h3 id="通过rio包读和写">10.4 通过RIO包读和写</h3>
<p>　　这里将实现能自动处理计数不足的RIO包。RIO包提供<span
style="background-color: yellow">无缓冲的输入和输出函数</span>以及<span
style="background-color: yellow">有缓冲的输入函数</span>。前者不会使用应用级缓冲，直接在内存和文件之间传输数据，对于通过网络传输二进制数据尤其有效。后者是线程安全的，可以高效地从已缓存在应用级缓冲区的文件中读取文本行和二进制数据，还可以在同一描述符任意交错，例如，可以先从某个描述符中读取一些文本行，然后读取一些二进制数据，最后读取一些文本行。</p>
<p>　　RIO包以W. Richard
Stevens的经典网络编程作品中描述的函数<code>readline()</code>、<code>readn()</code>和<code>writen()</code>为灵感。RIO包中的无缓冲的输入和输出函数与函数<code>readn()</code>和<code>writen()</code>完全相同，RIO包中的有缓冲的输入函数纠正了函数<code>readline()</code>的部分缺点。首先，函数<code>readline()</code>会缓冲，而函数<code>readn()</code>不缓冲，所以这2个函数不能对同一描述符一起调用。其次，函数<code>readline()</code>使用的是静态缓冲区
(线程不安全)，所以Stevens后来提出了其线程安全的版本<code>readline_r</code>。这里纠正了以上2个缺点，函数<code>readn()</code>和<code>readline()</code>在RIO包中的对应的使用缓冲的版本是兼容且线程安全的。</p>
<h4 id="无缓冲的输入和输出函数">10.4.1 无缓冲的输入和输出函数</h4>
<p>　　应用程序可以调用函数<code>rio_readn()</code>和<code>rio_writen()</code>来直接在内存和文件之间传输数据。对同一描述符可以任意交错地调用函数<code>rio_readn()</code>和<code>rio_writen()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* csapp.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 成功时返回传输的字节数，遇到EOF时返回0，出错时返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param usrbuf 内存位置</span></span><br><span class="line"><span class="comment"> * @param n 字节数</span></span><br><span class="line"><span class="comment"> * @return ssize_t</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                nread = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nleft);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 成功时返回传输的字节数，出错时返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> * @param usrbuf 内存位置</span></span><br><span class="line"><span class="comment"> * @param n 字节数</span></span><br><span class="line"><span class="comment"> * @return ssize_t</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                nwritten = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>rio_readn()</code>会从文件描述符<code>fd</code>的当前文件位置复制最多<code>n</code>字节到内存位置<code>usrbuf</code>。同样，函数<code>rio_writen()</code>会从内存位置<code>usrbuf</code>复制最多<code>n</code>字节到文件描述符<code>fd</code>的当前文件位置。前者可能会遇到EOF，而后者不会。为了尽可能地保证可移植性，这里允许被系统调用中断并在必要时重启。这2个函数在被信号处理函数的返回中断时，会重新调用函数<code>read()</code>或<code>write()</code>。</p>
<h4 id="有缓冲的输入函数">10.4.2 有缓冲的输入函数</h4>
<p>　　若需要计算文本文件中的行数，可以调用函数<code>read()</code>从文本文件每次传输1B到内存并检查换行符，这种方法的效率不高。更好的方法是使用包装函数<code>rio_readlineb()</code>，该函数会复制从内部缓冲区复制文本行，当内部缓冲区为空，会自动调用函数<code>read()</code>填充。对于HTTP响应等包括文本行和二进制数据的文件，可以使用函数<code>rio_readnb()</code>，类似函数<code>rio_readlineb()</code>，该函数会从相同的读缓冲区中传输原始数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* csapp.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIO_BUFSIZE 8192</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rio_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;                <span class="comment">/* 内部缓冲区的描述符 */</span></span><br><span class="line">    <span class="type">int</span> rio_cnt;               <span class="comment">/* 内部缓冲区的未读的字节数 */</span></span><br><span class="line">    <span class="type">char</span> *rio_bufptr;          <span class="comment">/* 内部缓冲区的下一个未读的字节 */</span></span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE]; <span class="comment">/* 内部缓冲区 */</span></span><br><span class="line">&#125; <span class="type">rio_t</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* csapp.c */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化读缓冲区</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rp 读缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    rp-&gt;rio_fd = fd;</span><br><span class="line">    rp-&gt;rio_cnt = <span class="number">0</span>;</span><br><span class="line">    rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief (私有) 读</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rp 读缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param usrbuf 内存位置</span></span><br><span class="line"><span class="comment"> * @param n 字节数</span></span><br><span class="line"><span class="comment"> * @return ssize_t</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">rio_read</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">char</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>) <span class="comment">/* 若为空则填充 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, <span class="keyword">sizeof</span>(rp-&gt;rio_buf));</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>) <span class="comment">/* EOF */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf; <span class="comment">/* 重置缓冲区指针 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从内部缓冲区复制min(n, rp-&gt;rio_cnt)字节到内存位置 */</span></span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = rp-&gt;rio_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    rp-&gt;rio_cnt -= cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 成功时返回读取的字节数，遇到EOF时返回0，出错时返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rp 读缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param usrbuf 内存位置</span></span><br><span class="line"><span class="comment"> * @param maxlen 最大长度</span></span><br><span class="line"><span class="comment"> * @return ssize_t</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, rc;</span><br><span class="line">    <span class="type">char</span> c, *bufp = usrbuf;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; maxlen; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *bufp++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* EOF (没有读到数据) */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* EOF (读取了一些数据) */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* 出错 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *bufp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 成功时返回读取的字节数，遇到EOF时返回0，出错时返回-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param rp 读缓冲区指针</span></span><br><span class="line"><span class="comment"> * @param usrbuf 内存位置</span></span><br><span class="line"><span class="comment"> * @param n 字节数</span></span><br><span class="line"><span class="comment"> * @return ssize_t</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span> *rp, <span class="type">void</span> *usrbuf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span> *bufp = usrbuf;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = rio_read(rp, bufp, nleft)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　结构体<code>rio_t</code>是读缓冲区的格式。函数<code>rio_readinitb()</code>会将设置空的读缓冲区并将其和已打开的文件描述符关联来初始化读缓冲区，即将描述符<code>fd</code>与地址<code>rp</code>处的<code>rio_t</code>类型的读缓冲区关联。每个打开的文件都会调用函数<code>rio_readinitb()</code>。</p>
<p>　　函数<code>rio_read()</code>与函数<code>read()</code>的语义相同，前者在后者的基础上使用了缓冲区。当调用函数<code>rio_read()</code>读取<code>n</code>字节时，读缓冲区中有<code>rp-&gt;rio_cnt</code>未读的字节。若读缓冲区为空，则会调用函数<code>read()</code>来重新填充。填充后，函数<code>rio_read()</code>会从读缓冲区复制<code>n</code>和<code>rp-&gt;rio_cnt</code>的最小值个字节到内存并返回复制的字节数。对于函数<code>rio_read()</code>，若出错，则返回-1并设置合适的<code>errno</code>；若EOF，则返回0；若请求的字节数大于读缓冲区中的未读字节数，则出现计数不足。</p>
<p>　　函数<code>rio_readlineb()</code>会从文件<code>rp</code>中读取下一行
(包括换行符)
并复制到内存位置<code>usrbuf</code>，然后以<code>NULL</code>字符结束文本行。该函数最多读取<code>maxlen - 1</code>字节
(为结尾的<code>NULL</code>保留空间)。超过<code>maxlen - 1</code>字节的文本行会被截断并以<code>NULL</code>字符结束。</p>
<p>　　函数<code>rio_readnb()</code>会从文件<code>rp</code>中读取最多<code>n</code>字节到内存位置<code>usrbuf</code>。</p>
<p>　　对同一描述符可以任意交错地调用函数<code>rio_readlineb()</code>和<code>rio_readnb()</code>。但是，对这2个函数的调用不能与对无缓冲的函数<code>rio_readn()</code>交错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* cpfile.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, STDIN_FILENO);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Rio_writen(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会使用RIO函数从标准输入复制文本文件到标准输出，每次1行。</p>
<h3 id="读取文件元数据">10.5 读取文件元数据</h3>
<p>　　应用程序可以调用函数<code>stat()</code>和<code>fstat()</code>来检索文件的相关信息
(也称为<strong>元数据</strong>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="keyword">struct</span> stat *buf)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> st_dev;             <span class="comment">/* 设备 */</span></span><br><span class="line">    <span class="type">ino_t</span> st_ino;             <span class="comment">/* 索引节点 */</span></span><br><span class="line">    <span class="type">mode_t</span> st_mode;           <span class="comment">/* 保护和文件类型 */</span></span><br><span class="line">    <span class="type">nlink_t</span> st_nlink;         <span class="comment">/* 硬链接数 */</span></span><br><span class="line">    <span class="type">uid_t</span> st_uid;             <span class="comment">/* 所有者的用户ID */</span></span><br><span class="line">    <span class="type">gid_t</span> st_gid;             <span class="comment">/* 所有者的组ID */</span></span><br><span class="line">    <span class="type">dev_t</span> st_rdev;            <span class="comment">/* 设备类型 (若是索引节点设备) */</span></span><br><span class="line">    <span class="type">off_t</span> st_size;            <span class="comment">/* 总大小 (单位是字节) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blksize; <span class="comment">/* 文件系统I/O的块大小 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blocks;  <span class="comment">/* 已分配的块数 */</span></span><br><span class="line">    <span class="type">time_t</span> st_atime;          <span class="comment">/* 最后访问时间 */</span></span><br><span class="line">    <span class="type">time_t</span> st_mtime;          <span class="comment">/* 最后修改时间 */</span></span><br><span class="line">    <span class="type">time_t</span> st_ctime;          <span class="comment">/* 最后更改时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>stat()</code>会将文件名作为输入并填充结构体<code>stat()</code>的成员，函数<code>fstat()</code>与之类似，区别是后者会将文件描述符作为输入。</p>
<p>　　结构体<code>stat()</code>定义在头文件<code>sys/stat.h</code>。成员<code>st_size</code>是文件大小
(单位是B)。成员<code>st_mode</code>会编码文件的权限位和文件类型。Linux在头文件<code>sys/stat.h</code>中定义了宏谓词来确定成员<code>st_mode</code>的文件类型：</p>
<p>　　● <code>S_ISREG(m)</code>会判断是否为常规文件。</p>
<p>　　● <code>S_ISDIR(m)</code>会判断是否为目录文件。</p>
<p>　　● <code>S_ISSOCK(m)</code>会判断是否为套接字。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* statcheck.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">char</span> *type, *readok;</span><br><span class="line">    Stat(argv[<span class="number">1</span>], &amp;stat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断文件类型 */</span></span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        type = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        type = <span class="string">&quot;directory&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        type = <span class="string">&quot;other&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查文件的读权限 */</span></span><br><span class="line">    <span class="keyword">if</span> (stat.st_mode &amp;&amp; S_IRUSR)</span><br><span class="line">    &#123;</span><br><span class="line">        readok = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        readok = <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;type: %s, read: %s\n&quot;</span>, type, readok);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过函数<code>stat()</code>来读取并解释文件的<code>st_mode</code>位。</p>
<h3 id="读取目录内容">10.6 读取目录内容</h3>
<p>　　应用程序可以调用<code>readdir()</code>系列函数来读取目录内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>; <span class="comment">/* 成功时返回句柄指针，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>opendir()</code>会输入路径名并输出指向<span
style="background-color: yellow">目录流</span>的指针。流就是项的有序列表的抽象，所以目录流就是目录条目列表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>; <span class="comment">/* 成功时返回指向下一个目录条目的指针，没有条目或出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">ino_t</span> d_ino;      <span class="comment">/* 索引节点号 */</span></span><br><span class="line">    <span class="type">char</span> d_name[<span class="number">256</span>]; <span class="comment">/* 文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>readdir()</code>会返回指向流<code>dirp</code>中的下一个目录条目的指针。若没有条目，则返回<code>NULL</code>；若出错，则会返回<code>NULL</code>并设置<code>errno</code>。因此，需要检查<code>errno</code>在调用函数<code>readdir()</code>后是否被修改过，才能判断返回<code>NULL</code>的原因。</p>
<p>　　结构体<code>dirent</code>就是目录条目，不过有些Linux版本还包括其他成员，这里的2个成员是所有系统都有的标准成员。成员<code>d_ino</code>是文件位置，成员<code>d_name</code>是文件名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>closedir()</code>会关闭流并释放其资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* readdir.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *streamp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dep</span>;</span></span><br><span class="line"></span><br><span class="line">    streamp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((dep = readdir(streamp)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found file: %s\n&quot;</span>, dep-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;readdir error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(streamp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会调用函数<code>readdir()</code>读取目录内容。</p>
<h3 id="文件共享">10.7 文件共享</h3>
<p>　　内核用<strong>描述符表</strong>、<strong>文件表</strong>和<strong>v-node表</strong>来表示打开的文件。</p>
<p>　　●
每个进程都有单独的描述符表，其中的条目通过进程打开的文件描述符来索引。每个打开的描述符条目都指向文件表中的1个条目。</p>
<p>　　●
打开的文件集合由所有文件共享的文件表来表示。每个文件表条目包括当前文件位置、当前指向它的描述符的引用次数和指向v-node表中的1个条目的指针。关闭描述符会减少对应的文件表条目的引用次数。只有当引用次数为0时，内核才会删除文件表条目。</p>
<p>　　●
所有文件共享v-node表。v-node表的条目包含结构体<code>stat()</code>中的大部分信息，包括成员<code>st_mode</code>和<code>st_size</code>。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_10/typical_kernel_data_structures_for_open_files.svg" class="">
<p>　　在这个示例中，描述符1和4通过不同的打开文件表条目来引用不同的文件，这是文件不共享且每个描述符对应不同的文件时的典型情况。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_10/file_sharing.svg" class="">
<p>　　多个描述符可以通过不同的文件表条目引用相同的文件，例如，对同一文件名调用2次函数<code>open()</code>。关键思想是每个描述符有自己的文件位置，所以对不同描述符的读可以从同一文件的不同位置获取数据。</p>
<p><img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_10/how_a_child_process_inherits_the_parent's_open_files.svg" class=""></p>
<p>　　假设在调用函数<code>fork()</code>时，父进程已经打开了一些文件。当父进程调用函数<code>fork()</code>时，子进程会得到父进程描述符表的副本。父子进程共享打开文件表，所以它们也会共享文件位置。因此，在内核删除文件表条目前，<span
style="background-color: yellow">父子进程都必须关闭</span>对应的描述符。</p>
<h3 id="io重定向">10.8 I/O重定向</h3>
<p>　　shell提供了<strong>I/O重定向</strong>操作符来允许用户将标准输入和输出与磁盘文件关联。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> &gt; foo.txt</span></span><br></pre></td></tr></table></figure>
<p>　　这条命令会让shell加载并执行<code>ls</code>程序，并且带有重定向到磁盘文件<code>foo.txt</code>的标准输出。实现I/O重定向的方法之一就是函数<code>dup2()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>; <span class="comment">/* 成功时返回非负描述符，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>dup2()</code>会复制描述符表条目<code>oldfd</code>到描述符表条目<code>newfd</code>，这里会覆盖描述符表条目<code>newfd</code>的内容。若述符表条目<code>newfd</code>已打开，则函数<code>dup2()</code>在复制前会关闭它。</p>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_10/kernel_data_structures_after_redirecting_standard_output_by_calling_dup2.svg" class="">
<p>　　在这个示例中，调用<code>dup2(4, 1)</code>后，2个描述表条目都指向文件B，文件A会被关闭且它的文件表和v-node表条目会被删除。此时，所有对标准输出的写都会重定向到文件B。</p>
<h3 id="io函数之选">10.9 I/O函数之选</h3>
<img src="/misc/computer_systems_a_programmer's_perspective_3e_chpt_10/relationship_between_unix_io,standard_io,and_rio.svg" class="">
<p>　　UNIX
I/O实现在操作系统内核中，可以通过系统级函数访问。较高级的RIO和标准I/O通过UNIX
I/O实现，RIO是10.4中实现的可靠包装函数，它可以自动处理计数不足的情况并提供用于文本行的高效缓冲区。相比UNIX
I/O，标准I/O提供更完整的使用缓冲的代替方案，包括<code>printf()</code>和<code>scantf()</code>等格式化函数。</p>
<p>　　●
尽量使用标准I/O函数。对于磁盘和终端设备上的I/O，标准I/O函数是首选方案。除了函数<code>stat()</code>，UNIX
I/O中的函数在标准I/O都有对应的更好的代替函数。</p>
<p>　　●
不要使用函数<code>scanf()</code>或<code>rio_readlineb()</code>读二进制文件。类似函数<code>scanf()</code>或<code>rio_readlineb()</code>的函数是专门用于读取文本行。二进制文件中可能有很多与终止文本行无关的<code>0xa</code>。</p>
<p>　　●
对套接字使用RIO函数。当使用标准I/O函数来处理套接字上的I/O时，会出现一些问题。</p>
<p>　　标准I/O是<span
style="background-color: yellow">全双工</span>的，因为可以在同一流上进行输入和输出。然而，有时对流的限制和对套接字的限制会冲突，而只有极少的文档描述这些问题：</p>
<p>　　●
若不在中间穿插调用函数<code>fflush()</code>、<code>fseek()</code>、<code>fsetpos()</code>或<code>rewind()</code>，输入函数的调用不能紧接着输出函数的调用。</p>
<p>　　●
若不在中间穿插调用函数<code>fseek()</code>、<code>fsetpos()</code>或<code>rewind()</code>，输出函数的调用不能紧接着输入函数的调用，除非输入函数遇到EOF。</p>
<p>　　函数<code>fflush()</code>会清空流关联的缓冲区，函数<code>fseek()</code>、<code>fsetpos()</code>和<code>rewind()</code>会调用UNIX
I/O的函数<code>lseek()</code>来重置当前文件位置。但是，对套接字调用函数<code>lseek()</code>是非法的。第1个问题可以通过每次输入前清空缓冲区来解决，第2个问题只能通过对同一套接字描述符打开1个用于读的流和1个用于写的流来解决。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fpin, *fpout;</span><br><span class="line"></span><br><span class="line">fpin = fdopen(sockfd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">fpout = fdopen(sockfd, <span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　这个解决方法也有问题，它需要应用程序对这2个流都调用函数<code>fclose()</code>来清空每个流关联的内存资源，避免内存泄漏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fclose(fpin);</span><br><span class="line">fclose(fpout);</span><br></pre></td></tr></table></figure>
<p>　　这2个操作会关闭同一套接字描述符，所以第2个操作会失败，这对顺序程序并不是问题，但线程化的程序中关闭已关闭的描述符会导致严重的问题。</p>
<p>　　综上所述，建议在套接字上使用RIO函数。若需要格式化输出，可以先调用函数<code>sprintf()</code>格式化内存中的字符，然后通过函数<code>rio_writen()</code>将其发送到套接字；若需要格式化输入，可以先调用函数<code>rio_readlineb()</code>来读取整个文本行，然后调用函数<code>sscanf()</code>来提取其中的字段。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第12章 系统和进程信息</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_12/</url>
    <content><![CDATA[<p>　　对于早期UNIX实现，没有简单的方法获取系统和进程信息。部分早期UNIX实现通过允许特权进程访问内核内存中的数据结构来解决这个问题，但这个方法也有很多问题
(该方法需要内核数据结构的专业知识，并且这些数据结构可能因为内核版本而异)。</p>
<p>　　为了提供更简单的访问内核信息的方法，很多现代UNIX实现都提供了<code>/proc</code>虚拟文件系统
(SUSv3没有说明该文件系统)。<code>/proc</code>文件系统位于目录<code>/proc</code>下，其中包含各种公开内核信息的文件，在某些情况下，进程可以通过常规文件I/O系统调用来修改这些文件。</p>
<p>　　<code>/proc</code>文件系统中的文件和目录并非位于磁盘，而是在进程访问它们时内核动态创建。因此，<code>/proc</code>文件系统被称为虚拟文件系统。</p>
<h3 id="proc文件系统">12.1 <code>/proc</code>文件系统</h3>
<h4 id="proc下的进程信息">12.1.1 <code>/proc</code>下的进程信息</h4>
<p>　　对于系统中的每个进程，内核都提供了对应的名为<code>/proc/PID</code>的目录，其中<code>PID</code>就是进程的进程ID。该目录下是包含进程相关信息的各种文件和子目录。</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr>
<th>文件</th>
<th>描述 (进程属性)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cmdline</code></td>
<td>以字符<code>\0</code>分隔的命令行参数</td>
</tr>
<tr>
<td><code>cwd</code></td>
<td>指向当前工作目录的符号链接</td>
</tr>
<tr>
<td><code>environ</code></td>
<td>以字符<code>\0</code>分隔的形如<code>NAME=value</code>的环境变量</td>
</tr>
<tr>
<td><code>exe</code></td>
<td>指向正在执行的文件的符号链接</td>
</tr>
<tr>
<td><code>fd</code></td>
<td>包含指向该进程打开的文件的符号链接的目录</td>
</tr>
<tr>
<td><code>maps</code></td>
<td>内存映射</td>
</tr>
<tr>
<td><code>mem</code></td>
<td>进程虚拟内存
(在执行I/O前必须先通过<code>lseek()</code>来将文件偏移量修改为有效值)</td>
</tr>
<tr>
<td><code>mounts</code></td>
<td>该进程的挂载点</td>
</tr>
<tr>
<td><code>root</code></td>
<td>指向根目录的符号链接</td>
</tr>
<tr>
<td><code>status</code></td>
<td>各种信息 (例如，进程ID、凭证、内存使用情况和信号)</td>
</tr>
<tr>
<td><code>task</code></td>
<td>对于进程的每个线程，该目录下都有1个对应的子目录 (Linux
2.6及以上版本)</td>
</tr>
</tbody>
</table>
<p>　　上表列出了部分所有<code>/proc/PID</code>目录都包含的文件。</p>
<p>　　●
对于进程打开的每个文件描述符，目录<code>/proc/PID/fd</code>下都有1个指向该文件描述符的符号链接。这些符号链接都有1个与描述符号对应的名称
(例如，<code>/proc/1968/1</code>是指向进程1968的标准输出的符号链接)。此外，每个进程都可以通过符号链接<code>/proc/self</code>来访问自己的<code>/proc/PID</code>目录。</p>
<p>　　● Linux
2.4添加了线程组的概念以支持POSIX线程模型。线程组中的线程的某些属性是不同的，所以Linux
2.4在<code>/proc/PID</code>目录下添加了子目录<code>task</code>。内核为进程的每个线程都提供了名为<code>/proc/PID/task/TID</code>的子目录
(其中<code>TID</code>就是线程的线程ID)，该子目录下的文件和子目录与<code>/proc/PID</code>下的相同。对于同一进程的线程，该目录下的文件中的很多信息是相同的，因为这些线程共享很多属性。</p>
<span id="more"></span>
<h4 id="proc下的系统信息">12.1.2 <code>/proc</code>下的系统信息</h4>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_12/some_files_and_subdirectories_under_proc.svg" class="">
<p>　　<code>/proc</code>下的文件和子目录提供了对系统信息的访问。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>该目录下的文件公开的信息</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/proc</code></td>
<td>各种系统信息</td>
</tr>
<tr>
<td><code>/proc/net</code></td>
<td>关于网络和套接字的状态信息</td>
</tr>
<tr>
<td><code>/proc/sys/fs</code></td>
<td>文件系统的相关设置</td>
</tr>
<tr>
<td><code>/proc/sys/kernel</code></td>
<td>各种通用内核设置</td>
</tr>
<tr>
<td><code>/proc/sys/net</code></td>
<td>网络和套接字设置</td>
</tr>
<tr>
<td><code>/proc/sys/vm</code></td>
<td>内存管理设置</td>
</tr>
<tr>
<td><code>/proc/sysvipc</code></td>
<td>关于System V IPC对象的信息</td>
</tr>
</tbody>
</table>
<p>　　上表总结了<code>/proc</code>下的子目录的通用目的。</p>
<h4 id="访问proc文件">12.1.3 访问<code>/proc</code>文件</h4>
<p>　　<code>/proc</code>下的文件经常通过shell脚本访问
(大多数包含多个值的<code>/proc</code>文件都可以使用Python或Perl等脚本语言轻松解析)。</p>
<p>　　<code>/proc</code>文件也能通过使用常规文件I/O系统调用的程序访问，访问这些文件时存在以下限制：</p>
<p>　　● 有些<code>/proc</code>文件
(例如，<code>/proc/PID</code>目录下的大部分文件)
是只读的，所以这些文件只能用于显示内核信息。</p>
<p>　　● 有些<code>/proc</code>文件
(例如，<code>/proc/PID</code>下的部分文件)
只能由文件所有者或特权进程读取。</p>
<p>　　●
除了<code>/proc/PID</code>目录下的文件之外，大部分其他<code>/proc</code>文件的所有者都是root，其中可修改的文件只能由root修改。</p>
<p>　　<code>/proc/PID</code>目录是不稳定的，这些目录只会在对应的进程创建时出现，对应的进程终止时消失。因此，当访问<code>/proc/PID</code>目录下的内容时，需要先确定<span
style="background-color: yellow">对应的进程是否已终止</span>以及<span
style="background-color: yellow">该目录是否已被删除</span>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* procfs_pidmax.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LINE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> line[MAX_LINE];</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/sys/kernel/pid_max&quot;</span>, (argc &gt; <span class="number">1</span>) ? O_RDWR : O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = read(fd, line, MAX_LINE);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Old value: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.*s&quot;</span>, (<span class="type">int</span>)n, line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(fd, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>])) != <span class="built_in">strlen</span>(argv[<span class="number">1</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;write() failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">&quot;echo /proc/sys/kernel/pid_max now contains `cat /proc/sys/kernel/pid_max`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何读取和修改<code>/proc</code>文件。该程序会打印<code>/proc/sys/kernel/pid_max</code>
(仅限于Linux 2.6及以上版本，指定了进程ID的最大值)
中的内容。若提供了命令行参数，则该程序会根据命令行参数修改该文件。</p>
<h3 id="系统id">12.2 系统ID</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">uname</span><span class="params">(<span class="keyword">struct</span> utsname *utsbuf)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _UTSNAME_LENGTH 65</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> sysname[_UTSNAME_LENGTH];  <span class="comment">/* 实现名称 */</span></span><br><span class="line">    <span class="type">char</span> nodename[_UTSNAME_LENGTH]; <span class="comment">/* 主机名 */</span></span><br><span class="line">    <span class="type">char</span> release[_UTSNAME_LENGTH];  <span class="comment">/* 实现发行版本 */</span></span><br><span class="line">    <span class="type">char</span> version[_UTSNAME_LENGTH];  <span class="comment">/* 发行版本级别 */</span></span><br><span class="line">    <span class="type">char</span> machine[_UTSNAME_LENGTH];  <span class="comment">/* 运行系统的硬件 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 特定于Linux */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _GNU_SOURCE</span></span><br><span class="line">    <span class="type">char</span> domainname[_UTSNAME_LENGTH]; <span class="comment">/* 主机的NIS域名 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>uname()</code>用于获取关于运行应用程序的主机系统的标识信息，结果存储在参数<code>utsbuf</code>指向的结构体中。</p>
<p>　　结构体<code>utsname</code>中的成员<code>sysname</code>、<code>release</code>、<code>version</code>和<code>machine</code>由内核自动设置。成员<code>nodename</code>返回通过系统调用<code>sethostname()</code>设置的值，该值有时与系统DNS域名中的前缀名相似。成员<code>domainname</code>返回通过系统调用<code>setdomainname()</code>设置的值，这是主机的<strong>网络信息服务</strong>域名
(与主机的DNS域名无关)。</p>
<p>　　系统调用<code>sethostname()</code>和<code>setdomainname()</code>很少用于应用程序。通常，主机名和NIS域名在引导时由启动脚本设置。</p>
<p>　　系统调用<code>gethostname()</code>与<code>sethostname()</code>相反，用于检索系统主机名。系统主机名也可以通过命令<code>hostname</code>和特定Linux的文件<code>/proc/hostname</code>来查看和修改。</p>
<p>　　系统调用<code>getdomainname()</code>与<code>setdomainname()</code>相反，用于检索NIS域名。NIS域名也可以通过命令<code>domainname</code>和特定Linux的文件<code>/proc/domainname</code>来查看和修改。</p>
<p>　　对于Linux，目录<code>/proc/sys/kernel</code>下的只读文件<code>ostype</code>、<code>osrelease</code>和<code>version</code>提供的信息与通过成员<code>sysname</code>、<code>release</code>和<code>version</code>返回的信息相同。文件<code>/proc/version</code>也包含这些信息，并且还包含关于内核编译步骤的信息
(即执行编译的用户和主机的名称以及使用的gcc版本)。</p>
<p>　　SUSv3详细说明了<code>uname()</code>，但没有说明结构体<code>utsname</code>中的成员的长度，仅要求它们以字符<code>\0</code>结尾。对于Linux，这些成员的长度都是65字节
(包括结尾的字符<code>\0</code>)。其他UNIX实现则不尽相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_uname.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">uts</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uname(&amp;uts) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Node name: %s\n&quot;</span>, uts.nodename);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;System name: %s\n&quot;</span>, uts.sysname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Release: %s\n&quot;</span>, uts.release);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Version: %s\n&quot;</span>, uts.version);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Machine: %s\n&quot;</span>, uts.machine);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _GNU_SOURCE</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Domain name: %s\n&quot;</span>, uts.domainname);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会打印通过<code>uname()</code>获取的信息。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第5章 文件I/O：更多细节</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_05/</url>
    <content><![CDATA[<p>　　所有系统调用都是<strong>原子</strong>执行的，即内核会保证系统调用在执行时不会被中断，这避免了<strong>竞争</strong>。竞争是2个进程或线程产生的操作共享资源的结果取决于无法预期的情况
(进程或线程访问CPU的相对顺序)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span>; <span class="comment">/* 成功时返回cmd对应的值；出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>fcntl()</code>能够对打开的文件描述符执行多种控制操作。参数<code>cmd</code>用于指定操作。由省略号表示的第3个参数可以是任何类型，或者被忽略，内核根据参数<code>cmd</code>来确定该参数的期望类型
(若存在)。</p>
<p>　　内核维护了<strong>打开文件表</strong>
(系统范围)，其中的条目称为<strong>打开的文件句柄</strong>，包括<span
style="background-color: yellow">当前文件偏移量</span>、<span
style="background-color: yellow">打开文件时指定的状态标志</span>、<span
style="background-color: yellow">文件访问模式</span>、<span
style="background-color: yellow">信号驱动I/O的相关设置</span>和<span
style="background-color: yellow">指向i-node表条目的指针</span>。</p>
<p>　　对于每个进程，内核都为其维护了<strong>打开的文件描述符表</strong>，简称<strong>文件描述符表</strong>。该表中的每个条目都记录了1个文件描述符的信息，包括<span
style="background-color: yellow">1组用于控制对应文件描述符的操作的标志位</span>和<span
style="background-color: yellow">1个指向打开的文件句柄的指针</span>。</p>
<p>　　每个文件系统都有i-node表，为该文件系统中驻留的所有文件所用，其条目包括<span
style="background-color: yellow">文件类型和权限</span>、<span
style="background-color: yellow">指向该文件持有的锁列表的指针</span>和<span
style="background-color: yellow">文件的各种属性</span>
(例如，文件大小和不同类型的文件操作的相关时间戳)。</p>
<p>　　i-node在磁盘上的表示和内存中的表示不同。磁盘上的i-node记录了文件的永久属性
(例如，文件类型、权限和时间戳)。当访问文件时，会创建内存中的i-node副本，该版本的i-node记录了引用i-node的打开的文件句柄的数量以及从中复制i-node的设备的主要ID和次要ID。此外，内存中的i-node还记录了文件打开时与文件关联的临时属性
(例如，文件锁)。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_05/relationship_between_file_descriptors,open_file_handles_and_i-nodes.svg" class="">
<p>　　如图所示，进程A和B有大量的打开的文件描述符。进程A的描述符1和20引用的打开的文件句柄相同，这种情况可能是因为调用了<code>dup()</code>、<code>dup2()</code>或<code>fcntl()</code>。进程A的描述符2和进程B的描述符2引用的打开的文件句柄相同，这种情况是因为调用了<code>fork()</code>或进程通过UNIX域套接字传递文件描述符给其他进程。</p>
<p>　　进程A的描述符0和进程B的描述符3引用的打开的文件句柄不同，但这2个句柄引用的是同一i-node表条目
(即同一文件)。这种情况是因为2个进程都对该文件调用了<code>open()</code>。当同一进程多次打开同一文件时，会出现类似的情况。</p>
<p>　　综上所述，引用同一打开的文件句柄的不同文件描述符共享文件偏移量，类似的规则也适用于打开文件状态标志。相反，文件描述符标志仅限于进程和文件描述符，对这些标志的修改不会影响同一进程的其他描述符或其他进程。</p>
<span id="more"></span>
<h3 id="原子和竞争">5.1 原子和竞争</h3>
<p>　　在4.1.1中提到过，标志<code>O_EXCL</code>与<code>O_CREAT</code>一起使用时，若文件已存在，则返回-1，并设置<code>errno</code>。其中对文件存在的检测和文件的创建都是原子执行的。为了体现这一点的重要性，考虑以下代码
(未使用标志<code>O_EXCL</code>)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line"><span class="keyword">if</span> (fd != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[PID %ld] File \&quot;%s\&quot; already exists\n&quot;</span>, (<span class="type">long</span>)getpid(), argv[<span class="number">1</span>]);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != ENOENT)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(argv[<span class="number">1</span>], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[PID %ld] Created file \&quot;%s\&quot; exclusively\n&quot;</span>, (<span class="type">long</span>)getpid(), argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码会打印系统调用<code>getpid()</code>返回的进程ID。假设有多个运行这段代码的进程，当内核调度程序决定某个进程的时间片已经结束，并将控制权交给其他进程时，可能会出现情况：该进程第1次调用<code>open()</code>时，文件不存在；第2次调用<code>open()</code>时，其他进程创建了文件。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_05/failing_to_exclusively_create_a_file.svg" class="">
<p>　　进程A错误地认为它创建了文件，因为第2次调用<code>open()</code>成功。这种竞争情况是否出现完全取决于进程的调度顺序。</p>
<p>　　第2个关于原子性的示例就是多个进程都向同一文件的末尾写数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lseek(fd, <span class="number">0</span>, SEEK_END) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (write(fd, buf, len) != len)</span><br><span class="line">&#123;</span><br><span class="line">    fatal(<span class="string">&quot;Partial/failed write&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码的问题和前一示例的相同。若执行这段代码的进程在调用<code>lseek()</code>和调用<code>write()</code>之间被执行相同操作的其他进程中断，则会导致2个进程都向同一偏移量处写数据。标志<code>O_APPEND</code>可以解决这个问题
(NFS等文件系统不支持该标志)。</p>
<h3 id="打开文件状态标志">5.2 打开文件状态标志</h3>
<p>　　系统调用<code>fcntl()</code>的用途之一是<span
style="background-color: yellow">检索或修改文件访问模式和打开文件状态标志</span>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags, accessMode;</span><br><span class="line"></span><br><span class="line">flags = fcntl(fd, F_GETFL); <span class="comment">/* 第3个参数不是必需的 */</span></span><br><span class="line"><span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; O_SYNC)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;writes are synchronized\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">accessMode = flags &amp; O_ACCMODE;</span><br><span class="line"><span class="keyword">if</span> (accessMode == O_WRONLY || accessMode == O_RDWR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file is writable\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　为了检索这些设置，需要将<code>fcntl()</code>的参数<code>cmd</code>指定为<code>F_GETFL</code>。在这段代码中，第8~11行会判断打开的文件是否写入同步。访问模式的判断稍微复杂一些，因为打开文件状态标志<code>O_RDONLY</code>
(0)、<code>O_WRONLY</code> (1) 和 <code>O_RDWR</code> (2)
并不对应单个位，所以需要对<code>flags</code>进行掩码操作
(使用<code>O_ACCMODE</code>)，如第13~17行所示。</p>
<p>　　标志<code>O_APPEND</code>、<code>O_NONBLOCK</code>、<code>O_NOATIME</code>、<code>O_ASYNC</code>和<code>O_DIRECT</code>可以通过<code>fcntl()</code>的操作<code>F_SETFL</code>进行修改
(部分UNIX实现允许修改的标志更多)，对其他标志的修改将会被忽略
。这在以下场景很有用：</p>
<p>　　● 当前进程并非调用<code>open()</code>打开文件的进程
(即文件描述符可能是3个标准描述符之一，在程序启动前就已被打开)，所以无法控制调用<code>open()</code>时使用的标志。</p>
<p>　　●
文件描述符是通过除<code>open()</code>之外的其他系统调用获取。例如，系统调用<code>pipe()</code>会创建管道，并返回分别引用管道两端的2个文件描述符。系统调用<code>socket()</code>会创建套接字，并返回引用该套接字的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">flags = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flags |= O_APPEND;</span><br><span class="line"><span class="keyword">if</span> (fcntl(fd, F_SETFL, flags) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码会启用标志<code>O_APPEND</code>。为了修改打开文件状态标志，需要先调用<code>fcntl()</code>获取当前标志的副本，然后进行修改，最后再次调用<code>fcntl()</code>来更新标志。</p>
<p>　　SUSv3要求通过调用<code>open()</code>或之后的<code>fcntl()</code>的操作<code>F_SETFL</code>设置的状态标志仅适用于打开的文件。但是，Linux在偏离了这一点：若应用程序的编译方式是5.8中描述的用于打开文件的技术之一，则<code>fcntl()</code>的操作<code>F_GETFL</code>检索的标志中将总是包含<code>O_LARGEFILE</code>。</p>
<h3 id="复制文件描述符">5.3 复制文件描述符</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>; <span class="comment">/* 成功时返回新文件描述符，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>; <span class="comment">/* 成功时返回新文件描述符，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>dup()</code>返回的新文件描述符
(未使用的最小的文件描述符)
引用的打开的文件句柄与参数<code>oldfd</code>的相同。</p>
<p>　　系统调用<code>dup2()</code>与<code>dup()</code>类似，但返回的文件描述符由参数<code>newfd</code>指定。若<code>newfd</code>指定的文件描述符已经打开，则会先关闭它并忽略关闭时出现的错误。因此，应该在调用<code>dup2()</code>前显式关闭<code>newfd</code>指定的文件描述符。若<code>oldfd</code>是无效的文件描述符，则<code>dup2()</code>会出错
(将<code>errno</code>设置为<code>EBADF</code>)，并且不会关闭<code>newfd</code>。若<code>oldfd</code>是有效的文件描述符，并且<code>oldfd</code>和<code>newfd</code>相同，则<code>dup2()</code>什么也不会做
(不会关闭<code>newfd</code>)。</p>
<p>　　对于复制文件描述符，系统调用<code>fcntl()</code>的操作<code>F_DUPFD</code>可以提供更多的灵活性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">newfd = fcntl(oldfd, F_DUPFD, startfd);</span><br></pre></td></tr></table></figure>
<p>　　这种调用方式会使用编号不小于<code>startfd</code>的未使用的文件描述符来复制<code>oldfd</code>。对<code>dup()</code>和<code>dup2()</code>的调用都可以替换为对<code>close()</code>和<code>fcntl()</code>的调用
(有时，<code>dup2()</code>设置<code>errno</code>的错误码和<code>fcntl()</code>的不同)。</p>
<p>　　在5.3中提到过，复制文件描述符后，新文件描述符与原文件描述符共享文件偏移量和打开文件状态标志。但是，新文件描述符有自己的文件描述符标识
(集)，并且close-on-exec标志是关闭的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup3</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd, <span class="type">int</span> flags)</span>; <span class="comment">/* 成功时返回新文件描述符，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>dup3()</code>与<code>dup2()</code>执行的任务相同，但添加了参数<code>flags</code>。参数<code>flags</code>是位掩码，用于修改该系统调用的行为。此外，<code>dup3()</code>还支持标志<code>O_CLOEXEC</code>。<code>dup3()</code>是Linux
2.6.27新增的系统调用，并且仅限于Linux。</p>
<p>　　从Linux
2.6.24开始，Linux还支持符系统调用<code>fcntl()</code>的操作<code>F_DUPFD_CLOEXEC</code>。该操作与<code>F_DUPFD</code>的功能相同
(复制文件描述符)，但该操作会为新文件描述符设置close-on-exec标志。SUSv4详细说明了该操作，但SUSv3没有说明该操作。</p>
<h3 id="指定偏移量处的文件io">5.4 指定偏移量处的文件I/O</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span>; <span class="comment">/* 成功时返回实际读取的字节数，遇到EOF时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span>; <span class="comment">/* 成功时返回实际写入的字节数，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　除了能够指定执行文件I/O的位置之外，系统调用<code>pread()</code>和<code>pwrite()</code>与<code>read()</code>和<code>write()</code>的功能相同。此外，<code>pread()</code>和<code>pwrite()</code>不会修改文件偏移量。</p>
<p>　　系统调用<code>pread()</code>和<code>pwrite()</code>在多线程应用程序中很有用，因为进程的所有线程共享文件描述符表
(所以它们也共享文件偏移量)。</p>
<h3 id="分散-聚集io">5.5 分散-聚集I/O</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>; <span class="comment">/* 成功时返回实际读取的字节数，遇到EOF时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>; <span class="comment">/* 成功时返回实际写入的字节数，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>readv()</code>和<code>writev()</code>会执行<strong>分散-聚集I/O</strong>，即每次传输多个缓冲区的数据，这些缓冲区由参数<code>iov</code>指定。参数<code>iovcnt</code>表示<code>iov</code>中的元素数。<code>iov</code>中的元素是结构体，其形式如下：</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_05/example_of_an_iovec_array_and_associated_buffers.svg" class="">
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> *iov_base; <span class="comment">/* 缓冲区起始地址 */</span></span><br><span class="line">    <span class="type">size_t</span> iov_len; <span class="comment">/* 缓冲区中写入/读取的字节数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　SUSv3允许实现对<code>iov</code>中的元素数量施加限制，该限制可以通过头文件<code>limits.h</code>中的<code>IOV_MAX</code>或在运行时调用<code>sysconf(_SC_IOV_MAX)</code>查看
(如果有)。SUSv3要求这些限制的最小值是16。Linux的<code>IOV_MAX</code>定义为1024，对应内核对该向量的大小限制
(由内核常量<code>UIO_MAXIOV</code>定义)。</p>
<p>　　但是，<code>readv()</code>和<code>writev()</code>的glibc包装函数会隐式地执行了一些额外的任务。若这些系统调用因<code>iovcnt</code>过大而出错，则包装函数会临时分配1个足以存储<code>iov</code>所有元素的缓冲区，并调用<code>read()</code>或<code>write()</code>。</p>
<h4 id="分散输入和聚集输出">5.5.1 分散输入和聚集输出</h4>
<p>　　系统调用<code>readv()</code>会执行分散输入，即从参数<code>fd</code>引用的文件中读连续的字节序列，然后将这些字节存储到参数<code>iov</code>指定的缓冲区中。<code>iov</code>指定的缓冲区以<code>iov[0]</code>开头。</p>
<p>　　<code>readv()</code>的重要属性之一是<span
style="background-color: yellow">以原子方式完成</span>。从调用进程的角度，内核只会在<code>fd</code>引用的文件和用户内存之间进行1次数据传输。因此，当<code>readv()</code>读文件时，读取的字节必定是连续的，即使共享同一文件偏移量的其他进程
(或线程) 试图在此过程中修改偏移量。</p>
<p>　　若<code>readv()</code>成功，则返回实际读取的字节数；若遇到EOF，则返回0。调用者需要根据返回值来确定是否读取了所有请求的数据。若有效数据不足以填充所有缓冲区，则仅会填充部分缓冲区，并且最后1个缓冲区可能只会被填充一部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_readv.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">myStruct</span>;</span> <span class="comment">/* 第1个缓冲区 */</span></span><br><span class="line">    <span class="type">int</span> x;                <span class="comment">/* 第2个缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_SIZE 100</span></span><br><span class="line">    <span class="type">char</span> str[STR_SIZE]; <span class="comment">/* 第3个缓冲区 */</span></span><br><span class="line">    <span class="type">ssize_t</span> numRead, totRequired;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s file\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totRequired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = &amp;myStruct;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stat);</span><br><span class="line">    totRequired += iov[<span class="number">0</span>].iov_len;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">1</span>].iov_base = &amp;x;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(x);</span><br><span class="line">    totRequired += iov[<span class="number">1</span>].iov_len;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">2</span>].iov_base = str;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = STR_SIZE;</span><br><span class="line">    totRequired += iov[<span class="number">2</span>].iov_len;</span><br><span class="line"></span><br><span class="line">    numRead = readv(fd, iov, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;readv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numRead &lt; totRequired)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read fewer bytes than requested\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total bytes requested: %ld; bytes read: %ld\n&quot;</span>, (<span class="type">long</span>)totRequired, (<span class="type">long</span>)numRead);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是<code>readv()</code>的用法示例。对于这种主要展示1个系统调用或库函数的用法的示例程序，这里会使用前缀<code>t_</code>加上函数名来作为名称。</p>
<p>　　系统调用<code>writev()</code>会执行聚集输出，即将参数<code>iov</code>指定的缓冲区中所有数据连接起来
(按数组顺序)，然后将它们作为连续的字节序列写入参数<code>fd</code>引用的文件描述符中。同样，<code>iov</code>指定的缓冲区也以<code>iov[0]</code>开始。</p>
<p>　　与<code>readv()</code>一样，<code>writev()</code>也是<span
style="background-color: yellow">以原子方式完成</span>。在用户内存和<code>fd</code>引用的文件描述符之间的数据传输仅会作为1个操作执行，因此，当<code>writev()</code>写数据时，所有请求的数据都会连续写入到文件，不会被其他进程
(或线程) 中断。</p>
<p>　　<code>writev()</code>可能出现不完全写的情况，所以需要检查返回值来确定所有请求的数据是否已写入。</p>
<h4 id="在指定偏移量处执行分散-聚集io">5.5.2
在指定偏移量处执行分散-聚集I/O</h4>
<p>　　Linux
2.6.30新增了系统调用<code>preadv()</code>和<code>pwritev()</code>，用于在指定偏移量处执行分散-聚集I/O。这2个系统调用并非标准，但现代BSD中都包含它们。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">preadv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt, <span class="type">off_t</span> offset)</span>; <span class="comment">/* 成功时返回实际读取的字节数，遇到EOF时返回0；出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwritev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt, <span class="type">off_t</span> offset)</span>; <span class="comment">/* 成功时返回实际写入的字节数；出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>preadv()</code>和<code>pwritev()</code>执行的任务与<code>readv()</code>和<code>writev()</code>相同，但会在参数<code>offset</code>指定的位置处。</p>
<h3 id="截断文件">5.6 截断文件</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>truncate()</code>和<code>ftruncate()</code>会将文件截断到参数<code>length</code>指定的值。若文件大小大于<code>length</code>，则丢弃多余的数据；若文件大小小于<code>lenght</code>，则补上空字节序列或空洞。</p>
<p>　　这2个系统调用的区别在于指定文件的方式。对于<code>truncate()</code>，参数<code>pathname</code>指定的文件必须是可访问和可写的
(若是符号链接，则会解引用)。对于<code>ftruncate()</code>，参数<code>fd</code>是
(至少以只读模式) 打开的文件描述符，该系统调用不会改变文件偏移量。</p>
<p>　　当<code>length</code>大于文件大小时，SUSv3给出了2个选择：扩展文件
(对于Linux)
或返回错误。对于<code>truncate()</code>，SUSv3要求扩展文件。此外，XSI也要求扩展文件。</p>
<p>　　系统调用<code>truncate()</code>是<span
style="background-color: yellow">仅有的可以直接修改文件内容</span>
(无需先通过<code>open()</code>或其他方法来获取文件描述符)
的系统调用。</p>
<h3 id="非阻塞io">5.7 非阻塞I/O</h3>
<p>　　在打开文件时指定标志<code>O_NONBLOCK</code>有2个目的：</p>
<p>　　● 若文件不能立即打开，则<code>open()</code>会返回错误
(而非阻塞中)。与有名管道一起使用时，<code>open()</code>可以阻塞。</p>
<p>　　●
当成功调用<code>open()</code>后，后续的I/O操作也是非阻塞的。若系统调用不能立即完成，则只会传输部分数据或出错
(将<code>errno</code>设置为<code>EAGAIN</code>或<code>EWOULDBLOCK</code>)。系统调用出错时设置的<code>errno</code>值取决于系统调用本身。对于Linux和很多UNIX实现，<code>EAGAIN</code>等同于<code>EWOULDBLOCK</code>。</p>
<p>　　非阻塞模式可以用于设备
(即终端和伪终端)、无名管道、有名管道和套接字。因为无名管道和套接字的文件描述符不是通过<code>open()</code>获得，所以必须通过<code>fcntl()</code>的操作<code>F_SETFL</code>来启用该标志。</p>
<p>　　常规文件会忽略标志<code>O_NONBLOCK</code>，因为内核缓冲区会确保对常规文件的I/O不会阻塞。但是，当使用强制文件锁定时，该标志也会对常规文件生效。</p>
<p>　　从历史角度，System
V衍生实现提供了与标志<code>O_NONBLOCK</code>类似的标志<code>O_NDELAY</code>。主要区别在于，当<code>write()</code>无法完成或没有足够的输入来满足<code>read()</code>时，非阻塞的<code>write()</code>会返回0。但是，这种情况不适用于<code>read()</code>，因为无法区分这种情况与EOF。因此，POSIX.1添加了标志<code>O_NONBLOCK</code>。有些UNIX实现仍然提供具有旧语义的标志<code>O_NDELAY</code>。Linux定义了标志<code>O_NDELAY</code>，但它与标志<code>O_NONBLOCK</code>是同义词。</p>
<h3 id="大文件的io">5.8 大文件的I/O</h3>
<p>　　用于表示文件偏移量的数据类型<code>off_t</code>通常被实现为有符号长整型数
(被实现为有符号数是因为值-1表示错误情况)。对于32位架构，这会将文件大小限制为2<sup>31</sup>-1字节
(即2GB)。但是，磁盘驱动程序的容量早就超过了该限制，所以需要32位UNIX实现来处理大于该限制的文件。由于这个问题在很多实现中都很常见，UNIX供应商联盟在<span
style="background-color: yellow">大型文件峰会</span> (LFS)
中进行了合作，来让SUSv2支持大文件的访问
(完整的LFS规范于1996年定稿)。</p>
<p>　　从内核2.4开始 (还需要glic
2.2及以上版本)，Linux提供了32位系统的LFS支持。此外，对应的文件系统也必须支持大文件。大多数原生Linux文件系统都支持大文件，有些非原生文件系统不支持大文件
(Microsoft的VFAT和NSFv2严格限制文件大小为2G，无论是否使用了LFS扩展)。</p>
<p>　　64位架构的长整型数被实现为64位，文件大小的理论上限是2<sup>63</sup>-1字节，在大多数情况下，该大小远大于磁盘大小。因此，64位架构通常不需要对文件大小施加限制。</p>
<p>　　可以通过以下2种方式之一来开发需要LFS功能的应用程序：</p>
<p>　　● 使用支持大文件的替代API。LFS将该API设计为SUS的
"过渡扩展"。因此，符合SUSv2或SUSv3的系统并不需要提供此API，但很多符合SUSv2或SUSv3的系统还是提供了此API。这种方法现已过时。</p>
<p>　　●
编译程序时将宏<code>_FILE_OFFSET_BITS</code>定义为值64。这是首选方法，因为它允许符合规范的应用程序在不修改源码的情况下获取LFS功能。</p>
<p>　　若通过32位函数来访问大文件
(不使用LFS功能)，则可能会遇到错误<code>EOVERFLOW</code>。例如，当使用函数<code>stat()</code>的32位版本来获取大于2GB的文件的信息时，就会出现该错误。</p>
<h4 id="过渡lfs-api">5.8.1 过渡LFS API</h4>
<p>　　为了使用过渡LFS
API，需要定义特性测试宏<code>_LARGEFILE64_SOURCE</code>。该API提供的函数足以处理64位的文件大小和偏移量，其名称与对应的32位函数类似
(使用了后缀<code>64</code>)，包括<code>fopen64()</code>、<code>open64()</code>、<code>lseek64()</code>、<code>truncate64()</code>、<code>stat64()</code>、<code>mmap64()</code>、<code>setrlimit64()</code>。</p>
<p>　　为了打开大文件，可以直接使用这些函数的64位版本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open64(name, O_CREAT | O_RDWR, mode);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　调用<code>open64()</code>等同于调用<code>open()</code>时指定标志<code>O_LARGEFILE</code>。若通过<code>open()</code>打开大于2GB的文件时不指定标志<code>O_LARGEFILE</code>，则会出错。</p>
<p>　　除了上述函数，过渡LFS
API还提供了一些新数据类型，包括<code>struct stat64</code>和<code>off64_t</code>。前者类似于结构体<code>stat</code>，但支持大文件。后者是表示偏移量的64位数据类型，用于函数<code>lseek64()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* large_file.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LARGEFILE64_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">off64_t</span> off;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pathname offset\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open64(argv[<span class="number">1</span>], O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open64&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off = atoll(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (lseek64(fd, off, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;lseek64&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(fd, <span class="string">&quot;test&quot;</span>, <span class="number">4</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例程序的命令行参数有2个：待打开文件的名称和表示文件偏移量的整数值。该程序会打开指定的文件，并在指定文件偏移量处写字符串。以下命令是通过该程序来在大文件的指定文件偏移量处写数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./large_file x 10111222333</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l x</span></span><br><span class="line">-rw------- 1 mtk users 10111222337 Mar 4 13:34 x</span><br></pre></td></tr></table></figure>
<h4 id="宏_file_offset_bits">5.8.2 宏<code>_FILE_OFFSET_BITS</code></h4>
<p>　　定义宏<code>_FILE_OFFSET_BITS</code>的方式有2种：在C源码中定义<code>#define _FILE_OFFSET_BITS 64</code>
(引用头文件之前)
或对C编译器使用命令行选项<code>-D_FILE_OFFSET_BITS=64</code>。</p>
<p>　　宏<code>_FILE_OFFSET_BITS</code>会将所有相关的32位函数和数据类型转换为对应的64位版本。例如，对<code>open()</code>的调用会转换为对<code>open64()</code>的调用，数据类型<code>off_t</code>会定义为64位。因此，若程序<span
style="background-color: yellow">仅使用</span>数据类型为<code>off_t</code>的变量来表示文件偏移量，则只需要重新编译程序就可以支持大文件。</p>
<p>　　宏<code>_FILE_OFFSET_BITS</code>并非LFS规范的要求
(仅提及该宏可作为指定数据类型<code>off_t</code>的长度的备选方法)。有些UNIX实现通过其他特性测试宏来获取同样的功能。</p>
<h4 id="打印off_t值">5.8.3 打印<code>off_t</code>值</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _LARGEFILE64_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> offset;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;offset=%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>) offset);</span><br></pre></td></tr></table></figure>
<p>　　数据类型<code>off_t</code>有时会定义为<code>long long</code>。因此，为了保证可移植性，在打印<code>off_t</code>值时，需要将其转换为<code>long long</code>，并使用格式说明符<code>%lld</code>。当需要在不同的编译模块之间传递<code>off_t</code>值时，需要确保编译模块的设置统一，即都
(不) 使用宏<code>_FILE_OFFSET_BITS</code>。</p>
<p>　　同样的情况也适用于结构体<code>stat</code>中使用的数据类型<code>blcnt_t</code>。</p>
<h3 id="目录devfd">5.9 目录<code>/dev/fd</code></h3>
<p>　　对于每个进程，内核都提供了特殊的虚拟目录<code>/dev/fd</code>。该目录下包含名称形如<code>/dev/fd/n</code>的文件，其中<code>n</code>是数字，对应进程的打开的文件描述符之一。例如，<code>/dev/fd/0</code>是进程的标准输入。</p>
<p>　　<code>/dev/stdin</code>、<code>/dev/stdout</code>和<code>/dev/stderr</code>分别是指向<code>/dev/fd/0</code>、<code>/dev/fd/1</code>和<code>/dev/fd/2</code>的符号链接。</p>
<p>　　<code>/dev/fd</code>实际上是指向特定于Linux的目录<code>/proc/self/fd</code>的符号链接。目录<code>/proc/self/fd</code>是特定于Linux的目录<code>/proc/PID/fd</code>的特例
(每个目录都包含与进程打开的所有文件相对应的符号链接)。</p>
<p>　　SUSv3并未说明目录<code>/dev/fd</code>，但多个UNIX实现都提供了该功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dev/fd/1&quot;</span>, O_WRONLY);</span><br><span class="line">fd = dup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>　　打开目录<code>/dev/fd</code>下的文件等同于复制对应的文件描述符，所以这2行代码是等效的。当对目录<code>/dev/fd</code>下的文件调用<code>open()</code>时，参数<code>flags</code>也会生效，所以需要保证复制的文件描述符的访问模式与原文件描述符的访问模式相同
(<code>O_CREAT</code>等标志将会被忽略)。</p>
<p>　　目录<code>/dev/fd</code>下的文件通常用于shell。很多用户级命令都会使用文件名参数，有时会将这些命令用于管道，并且其中1个参数是标准输入或输出。出于这个目的，部分程序
(例如，<code>diff</code>、<code>ed</code>、<code>tar</code>和<code>comm</code>)
已经开始使用仅包含1个连字符<code>-</code>的参数，以表示该参数是标准输入或输出
(如果适用)。因此，可以通过如下命令来对<code>ls</code>返回的文件列表和之前的构建的文件列表对比：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> | diff - oldfilelist</span></span><br></pre></td></tr></table></figure>
<p>　　这种方法会产生很多问题。首先，需要所有相关程序都支持连字符的解析，但很多程序并不支持。其次，有些程序会将单个连字符解析为命令行选项结尾的标识符。解决方法之一是使用<code>/dev/fd</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> | diff /dev/fd/0 oldfilelist</span></span><br></pre></td></tr></table></figure>
<h3 id="创建临时文件">5.10 创建临时文件</h3>
<p>　　在某些情况下，程序可能需要创建一些仅在程序运行时才会使用的临时文件，并且这些临时文件会在程序终止时删除。通常，临时文件在打开不久后就会取消链接/删除
(通过系统调用<code>unlink()</code>)。</p>
<p>　　glibc提供了大量用于此目的的函数，这里仅介绍函数<code>mkstemp()</code>和<code>tmpfile()</code>。函数<code>tmpnam()</code>、<code>tempnam()</code>和<code>mktemp()</code>也能用于创建临时文件，但这些函数会<span
style="background-color: yellow">产生安全漏洞</span>，所以应该避免使用它们。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemp</span><span class="params">(<span class="type">char</span> *template)</span>; <span class="comment">/* 成功时返回文件描述符；出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>mkstemp()</code>会根据参数<code>template</code>指定的模板生成唯一文件名，并打开文件
(使用标志<code>O_EXCL</code>)。然后，返回文件描述符。对于生成的文件，所有者有读写权限，其他用户没有任何权限。</p>
<p>　　参数<code>template</code>的形式是路径名，并且最后6个字符必须是<code>XXXXXX</code>。这6个字符会被替换为唯一的文件名，并且修改后的字符串会存储在参数<code>template</code>中。因此，<code>template</code>必须是字符数组，而非字符串常量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span> template[] = <span class="string">&quot;/tmp/somestringXXXXXX&quot;</span>;</span><br><span class="line"></span><br><span class="line">fd = mkstemp(template);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;mkstemp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Generated filename was: %s\n&quot;</span>, template);</span><br><span class="line">unlink(template); <span class="comment">/* 文件名会立即消失，但文件只会在调用close()后删除 */</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">if</span> (close(fd) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是函数<code>mkstemp()</code>的用法示例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 成功时返回文件指针，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>tempfile()</code>会创建名称唯一的临时文件。临时文件使用标志<code>O_EXCL</code>打开，以防止其他进程已经创建了名称相同的文件。函数<code>tempfile()</code>的内部<span
style="background-color: yellow">已经调用</span>了<code>unlink()</code>。</p>
<p>　　当函数<code>tempfile()</code>成功时，会返回可与stdio库函数一起使用的文件流。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第13章 文件I/O缓存</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_13/</url>
    <content><![CDATA[<p>　　为了速度和效率，I/O系统调用 (即内核) 和标准C库的I/O函数
(即stdio函数) 在操作磁盘文件时会缓存数据。</p>
<p>　　当对磁盘文件调用系统调用<code>read()</code>和<code>write()</code>时，这2个系统调用不会立即开始访问磁盘文件。相反，它们只会在用户空间缓冲区和内核<strong>缓冲区缓存</strong>中的某个缓冲区之间复制信息。</p>
<p>　　●
<code>write(fd, "abc", 3)</code>会从用户空间缓冲区传输3字节的数据到内核空间缓冲区。在该调用返回后的某个时间点，内核会将其缓冲区刷新
(写入)
到磁盘。在<code>write()</code>返回之后和内核刷新缓冲区之前，若其他进程试图访问通过<code>write()</code>写入的数据，则内核会自动从缓冲区缓存提供数据，而非从对应的文件提供数据。</p>
<p>　　●
对于输入，内核会从磁盘读数据到在某个内核缓冲区。调用<code>read()</code>会从该缓冲区提取数据，直到该缓冲区为空，此时，内核继续读数据到缓冲区缓存
(这里进行了一些简化，对于顺序文件访问，内核通常会在缓冲区为空前提前读数据)。</p>
<p>　　这种设计提高了<code>read()</code>和<code>write()</code>的速度，因为它们不需要等待磁盘操作。这种设计也是高效的，因为减少了内核必须执行的磁盘数据传输。</p>
<p>　　从内核2.4开始，Linux不再维护单独的缓冲区缓存。相反，文件I/O缓冲区包含在页缓存
(其中也包含内存映射文件的页等页)。尽管如此，在之后的内容，还是会使用术语缓冲区缓存，因为该术语在UNIX实现中历来常见。</p>
<p>　　强制刷新输出文件的内核缓冲区是可能的。若应用程序 (数据库日志进程)
必须确保输出确实已写入到磁盘 (至少写入到磁盘的硬件缓存)
才能继续，则这是必要的。</p>
<p>　　SUSv3定义了术语<strong>同步I/O完成</strong>来表示
"已经传输到磁盘或确定为失败的I/O操作"。SUSv3定义了2种类型的同步I/O完成，两者之间的差距涉及到<span
style="background-color: yellow">文件元数据</span>
(其中包含文件所有者和所属组、文件权限、文件大小、指向文件的 (硬)
链接数、最近1次访问文件的时间戳、最近1次修改文件的时间戳、最近1次修改文件元数据的时间戳以及文件数据块指针)。</p>
<p>　　SUSv3定义的第1种同步I/O完成是<strong>同步I/O数据完整性完成</strong>。对于读操作，这表示请求的文件数据已经被传输到进程
(若存在会影响请求数据的待执行的写操作，则这些写操作会先于读操作执行)。对于写操作，这表示请求的写操作指定的数据已经被传输到磁盘，并且检索该数据所需的所有文件元数据也已经传输到磁盘
(例如，若写操作扩大了文件，则必须传输的文件元数据包括文件大小)。值得注意的是检索文件数据并不需要所有修改后的文件元数据属性都传输完成
(例如，最近1次修改文件的时间戳)。</p>
<p>　　SUSv3定义的第2种同步I/O完成是<strong>同步I/O文件完整性完成</strong>，它是同步I/O数据完整性完成的超集。不同于同步I/O数据完整性完成的是，更新文件时，所有更新后的文件元数据都必须传输到磁盘，即使后续的文件数据的读操作不是必要的。</p>
<span id="more"></span>
<h3 id="文件io中的内核缓冲">13.1 文件I/O中的内核缓冲</h3>
<p>　　Linux内核没有对缓冲区缓存的上限设置固定值。内核会按需分配指定数量的缓冲区缓存页，这个过程仅受可用物理内存和用于其他目的物理内存需求的限制。若可用内存不足，则内核会将部分修改后的缓存区缓存页刷新到磁盘，以重新利用这些页。</p>
<p>　　无论是以每次写1字节的形式执行1000次，还是以每次写1000字节的形式执行1次，内核都执行相同数量的磁盘访问。但是，后者是首选方式，因为后者只需要1次系统调用，而前者需要1000次系统调用
(尽管系统调用比磁盘操作更快，但还仍然需要不少时间)。</p>
<p>　　不同大小的缓冲区对文件I/O的影响可以通过将<code>copy.c</code>
(见第4章)
的<code>BUF_SIZE</code>设置为不同的值来查看。以下是在该程序使用不同的<code>BUF_SIZE</code>值在使用vanilla
2.6.30内核 (vanilla内核是<span
style="background-color: yellow">未应用补丁的主线内核</span>，这不同于大多数发行商提供的版本，后者通常包含修复漏洞和添加特性的补丁)
和块大小是4096字节的ext2文件系统的Linux上复制1亿字节的文件所需的时间：</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 16%" />
<col style="width: 20%" />
<col style="width: 23%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;"><code>BUF_SIZE</code></th>
<th>总耗时 (秒)</th>
<th>总CPU时间 (秒)</th>
<th>用户CPU时间 (秒)</th>
<th>系统CPU时间 (秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">1</td>
<td>107.43</td>
<td>107.32</td>
<td>8.20</td>
<td>99.12</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td>54.16</td>
<td>53.89</td>
<td>4.13</td>
<td>49.76</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td>31.72</td>
<td>30.96</td>
<td>2.30</td>
<td>28.66</td>
</tr>
<tr>
<td style="text-align: left;">8</td>
<td>15.59</td>
<td>14.34</td>
<td>1.08</td>
<td>13.26</td>
</tr>
<tr>
<td style="text-align: left;">16</td>
<td>7.50</td>
<td>7.14</td>
<td>0.51</td>
<td>6.63</td>
</tr>
<tr>
<td style="text-align: left;">32</td>
<td>3.76</td>
<td>3.68</td>
<td>0.26</td>
<td>3.41</td>
</tr>
<tr>
<td style="text-align: left;">64</td>
<td>2.19</td>
<td>2.04</td>
<td>0.13</td>
<td>1.91</td>
</tr>
<tr>
<td style="text-align: left;">128</td>
<td>2.16</td>
<td>1.59</td>
<td>0.11</td>
<td>1.48</td>
</tr>
<tr>
<td style="text-align: left;">256</td>
<td>2.06</td>
<td>1.75</td>
<td>0.10</td>
<td>1.65</td>
</tr>
<tr>
<td style="text-align: left;">512</td>
<td>2.06</td>
<td>1.03</td>
<td>0.05</td>
<td>0.98</td>
</tr>
<tr>
<td style="text-align: left;">1024</td>
<td>2.05</td>
<td>0.65</td>
<td>0.02</td>
<td>0.63</td>
</tr>
<tr>
<td style="text-align: left;">4096</td>
<td>2.05</td>
<td>0.38</td>
<td>0.01</td>
<td>0.38</td>
</tr>
<tr>
<td style="text-align: left;">16384</td>
<td>2.05</td>
<td>0.34</td>
<td>0.00</td>
<td>0.33</td>
</tr>
<tr>
<td style="text-align: left;">65536</td>
<td>2.06</td>
<td>0.32</td>
<td>0.00</td>
<td>0.32</td>
</tr>
</tbody>
</table>
<p>　　上表的数据是运行20次的平均值
(对于以上测试和本章的其他测试，每次运行程序之间都会卸载和重新挂载文件系统来确保文件系统的缓冲区为空)。计时使用的是命令<code>time</code>。因为通过各种大小的缓冲区传输的数据量是相同的，所以上表也展示了<code>read()</code>和<code>write()</code>的开销。对于1字节的缓冲区，需要调用1亿次<code>read()</code>和<code>write()</code>。对于4096字节的缓冲区，大约需要调用24000次<code>read()</code>和<code>write()</code>，并且达到了最佳性能。继续增大缓冲区不会有明显的性能提升，因为与在用户空间和内核空间之间传输数据以及执行实际的磁盘I/O所用的时间相比，调用<code>read()</code>和<code>write()</code>所用的时间可以忽略不记。</p>
<p>　　最后几行大致给出了在用户空间和内核空间之间传输数据所用的时间和执行文件I/O所用的时间。因为系统调用的所用时间相比总耗时和CPU时间可以忽略不记，所以系统CPU时间可以视为在用户空间和内核空间之间传输数据所用的时间，总耗时可以视为数据传入和传出磁盘所用的时间。</p>
<p>　　从上表可以得出，<code>write()</code>在数据从用户空间传输到内核缓冲区缓存后就立即返回，因为测试系统的RAM
(4GB) 远大于目标文件 (100MB)
的大小，所以可以假设程序运行完成时，目标文件并没有实际写入到磁盘。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* write_bytes.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s file num-bytes buf-size\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> numBytes = getLong(argv[<span class="number">2</span>], GN_GT_0, <span class="string">&quot;num-bytes&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> bufSize = getLong(argv[<span class="number">3</span>], GN_GT_0, <span class="string">&quot;buf-size&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(bufSize);</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> openFlags = O_CREAT | O_WRONLY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_O_SYNC) &amp;&amp; defined(O_SYNC)</span></span><br><span class="line">    <span class="comment">/* 若编译时使用了选项-DUSE_O_SYNC，则以标志O_SYNC打开文件 */</span></span><br><span class="line">    openFlags |= O_SYNC;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">1</span>], openFlags, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> thisWrite, totWritten;</span><br><span class="line">    <span class="keyword">for</span> (totWritten = <span class="number">0</span>; totWritten &lt; numBytes; totWritten += thisWrite)</span><br><span class="line">    &#123;</span><br><span class="line">        thisWrite = min(bufSize, numBytes - totWritten);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(fd, buf, thisWrite) != thisWrite)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;partial/failed write&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_FSYNC</span></span><br><span class="line">        <span class="comment">/* 若编译时使用了选项-DUSE_FSYNC，则在每次写入后都调用fsync() */</span></span><br><span class="line">        <span class="keyword">if</span> (fsync(fd))</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fsync&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_FDATASYNC</span></span><br><span class="line">        <span class="comment">/* 若编译时使用了选项-DUSE_FSYNC，则在每次写入后都调用fdatasync() */</span></span><br><span class="line">        <span class="keyword">if</span> (fdatasync(fd))</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fdatasync&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　为了验证假设，这里会使用这个示例来进行测试
(该程序会写任意数据到指定文件)。以下是该程序使用不同大小的写缓冲区在使用vanilla
2.6.30内核和块大小是4096字节的ext2文件系统的Linux上写1亿字节到文件所需的时间
(运行20次的平均值)：</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 16%" />
<col style="width: 20%" />
<col style="width: 23%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;"><code>BUF_SIZE</code></th>
<th>总耗时 (秒)</th>
<th>总CPU时间 (秒)</th>
<th>用户CPU时间 (秒)</th>
<th>系统CPU时间 (秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">1</td>
<td>72.13</td>
<td>72.11</td>
<td>5.00</td>
<td>67.11</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td>36.19</td>
<td>36.17</td>
<td>2.47</td>
<td>33.70</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td>20.01</td>
<td>19.99</td>
<td>1.26</td>
<td>18.73</td>
</tr>
<tr>
<td style="text-align: left;">8</td>
<td>9.35</td>
<td>9.32</td>
<td>0.62</td>
<td>8.70</td>
</tr>
<tr>
<td style="text-align: left;">16</td>
<td>4.70</td>
<td>4.68</td>
<td>0.31</td>
<td>4.47</td>
</tr>
<tr>
<td style="text-align: left;">32</td>
<td>2.39</td>
<td>2.39</td>
<td>0.16</td>
<td>2.23</td>
</tr>
<tr>
<td style="text-align: left;">64</td>
<td>1.24</td>
<td>1.24</td>
<td>0.07</td>
<td>1.16</td>
</tr>
<tr>
<td style="text-align: left;">128</td>
<td>0.67</td>
<td>0.67</td>
<td>0.04</td>
<td>0.63</td>
</tr>
<tr>
<td style="text-align: left;">256</td>
<td>0.38</td>
<td>0.38</td>
<td>0.02</td>
<td>0.36</td>
</tr>
<tr>
<td style="text-align: left;">512</td>
<td>0.24</td>
<td>0.24</td>
<td>0.01</td>
<td>0.23</td>
</tr>
<tr>
<td style="text-align: left;">1024</td>
<td>0.17</td>
<td>0.17</td>
<td>0.01</td>
<td>0.16</td>
</tr>
<tr>
<td style="text-align: left;">4096</td>
<td>0.11</td>
<td>0.11</td>
<td>0.00</td>
<td>0.11</td>
</tr>
<tr>
<td style="text-align: left;">16384</td>
<td>0.10</td>
<td>0.10</td>
<td>0.00</td>
<td>0.10</td>
</tr>
<tr>
<td style="text-align: left;">65536</td>
<td>0.09</td>
<td>0.09</td>
<td>0.00</td>
<td>0.09</td>
</tr>
</tbody>
</table>
<p>　　上表仅展示了调用<code>write()</code>和将数据从用户空间传输到内核缓冲区缓存所用的时间。当缓冲区大小达到65536字节时，上一个测试总耗时2.06秒，而这里的总耗时仅有0.09秒。因为上一个测试并没有进行实际的磁盘I/O，即上一个测试的大部分时间用于读取磁盘。</p>
<p>　　上表的信息只代表文件系统的1种 (简单)
基准测试机制。此外，结果可能会显示不同系统之间的一些差异。文件系统可以通过各种其他标志来衡量
(例如，在繁重的多用户负载下的性能、文件创建和删除的速度、在大型目录中搜索文件所需的时间、存储小文件所需的空间以及在系统崩溃时保证文件的完整性)。若I/O或其他文件系统操作的系统至关重要，则在目标平台上执行的特定于应用程序的基准测试是无可替代的。</p>
<h3 id="stdio库中的缓冲">13.2 stdio库中的缓冲</h3>
<p>　　在操作磁盘文件时，C库I/O函数会将数据缓冲到较大的内存块来减少系统调用。因此，使用stdio库会减轻<code>write()</code>输出数据和<code>read()</code>输入数据时的缓冲任务。</p>
<p>　　主线Linux内核没有实现System
V的功能STREAMS，所以stdio库使用的流不会与该功能混淆。</p>
<h4 id="设置stdio流的缓冲模式">13.2.1 设置stdio流的缓冲模式</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>; <span class="comment">/* 成功时返回0，出错时返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>; <span class="comment">/* setvbuf()的包装函数 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>setvbuf()</code>用于控制stdio库使用的缓冲模式。</p>
<p>　　参数<code>stream</code>标识待设置的缓冲模式所属的文件流。当该文件流被打开后，应该保证<code>setvbuf()</code>先于其他基于该文件流的stdio函数调用，因为<code>setvbuf()</code>对缓冲模式的设置会影响后续的基于该文件流的所有stdio操作。</p>
<p>　　参数<code>buf</code>和<code>size</code>指定<code>stream</code>使用的缓冲区。这些参数可能通过以下2种方式指定：</p>
<p>　　●
若<code>buff</code>非<code>NULL</code>，则它指向供<code>stream</code>使用的<code>size</code>字节的内存块。因为<code>buf</code>指向的内存块随后供stdio库使用，所以该内存块应该是在堆上静态分配或动态分配的。</p>
<p>　　●
若<code>buff</code>是<code>NULL</code>，则stdio库会自动分配1个缓冲区供<code>stream</code>使用
(除非指定了不缓冲的I/O)。SUSv3允许但不要求实现使用<code>size</code>来决定该缓冲区的大小。对于这种情况，glibc实现中的<code>size</code>会被忽略。</p>
<p>　　参数<code>mode</code>指定缓冲模式，其值只能是<code>_IONBF</code>、<code>IOLBF</code>或<code>_IOFBF</code>。</p>
<p>　　●
<code>_IONBF</code>表示不缓冲的I/O。所有stdio库调用都会导致执行系统调用<code>write()</code>或<code>read()</code>。此时，<code>buf</code>和<code>size</code>会被忽略，并且可以分别指定为<code>NULL</code>和0。这是<code>stderr</code>的默认缓冲模式，所以错误输出会立即出现。</p>
<p>　　●
<code>_IOLBF</code>表示使用行缓冲的I/O。这是引用终端设备的流的默认缓冲模式。对于输出流，会缓冲数据，直到换行符输出
(除非缓冲区已满)。对于输入流，1次读取1行数据。</p>
<p>　　●
<code>_IOFBF</code>表示使用完全缓冲的I/O。读写数据时以缓冲区的大小为单元。这是引用磁盘文件的流的默认缓冲模式。</p>
<p>　　函数<code>setbuf</code>是<code>setvbuf()</code>的包装函数，执行相似的任务。<code>setbuf(fp, buf)</code>等同于<code>setvbuf(fp, buf, (buf != NULL) ? _IOFBF : _IONBF, BUFSIZ)</code>。参数<code>buf</code>可以指定为<code>NULL</code>，表示不缓冲的I/O。<code>buf</code>也可以指定为调用者分配的大小为<code>BUFSIZ</code>字节的缓冲区
(<code>BUFSIZ</code>定义在<code>stdio.h</code>中)。对于glibc实现，<code>BUFSIZ</code>通常定义为8192。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>setbuffer</code>与<code>setbuf()</code>类似，但允许通过参数<code>size</code>来指定<code>buf</code>的大小。<code>setbuffer(fp, buf, size)</code>等同于<code>setvbuf(fp, buf, (buf != NULL) ? _IOFBF : _IONBF, size)</code>。</p>
<p>　　SUSv3没有说明<code>setbuffer()</code>，但大多数UNIX实现都提供了该函数。</p>
<h4 id="刷新stdio缓冲区">13.2.2 刷新stdio缓冲区</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>; <span class="comment">/* 成功是返回0，出错时返回EOF */</span></span><br></pre></td></tr></table></figure>
<p>　　无论当前的缓冲模式如何，都可以通过库函数<code>fflush()</code>来强制写入stdio输出流中的数据
(即通过<code>write()</code>来刷新内核缓冲区)。该函数会刷新参数<code>stream</code>指定的输出缓冲区。若<code>stream</code>为<code>NULL</code>，则刷新所有stdio缓冲区。</p>
<p>　　<code>fflush()</code>也可以用于输入流，这会导致已缓冲的输入无效
(当程序下一次读取该流时，对应的缓冲区才会再次填充)。</p>
<p>　　当关闭流后，对应的stdio缓冲区也会自动刷新。</p>
<p>　　对于glibc等C库实现，若<code>stdin</code>和<code>stderr</code>引用的都是终端，则读取<code>stdin</code>时会隐式调用<code>fflush(stdout)</code>，这会刷新已写入<code>stdout</code>的所有不以换行符结尾的提示信息
(例如，<code>printf("Data: ")</code>)。SUSv3和C99没有说明该行为，而且并非所有C库都实现了该行为。对于可移植应用程序，应该显式地调用<code>fflush(stdout)</code>来保证这类提示信息会显示。</p>
<p>　　C99对同时用于输入和输出的流提出了2个要求。首先，输出操作之后不能是输入操作，两者之间必须要调用<code>fflush()</code>和文件定位函数
(<code>fseek()</code>、<code>fsetpos()</code>和<code>rewind()</code>)。其次，输入操作之后不能是输出操作，两者之间必须要调用文件定位函数，除非输出操作遇到了EOF。</p>
<h3 id="控制文件io的内核缓冲">13.3 控制文件I/O的内核缓冲</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>fsync()</code>会导致缓冲的数据和与参数<code>fd</code>指定的文件描述符关联的所有元数据都刷新到磁盘。调用该系统调用会强制文件进入同步I/O文件完整性完成状态。此外，该系统调用只会在数据和元数据都传输到磁盘
(至少传输到磁盘缓存) 后才会返回。</p>
<p>　　系统调用<code>fdatasync()</code>与<code>fsync()</code>类似，但只强制文件进入同步I/O数据完整性完成状态。</p>
<p>　　调用<code>fdatasync()</code>可能会将磁盘操作从<code>fsync()</code>所需的2个减少到1个
(例如，若仅修改了文件数据，而没有修改文件大小，则调用<code>fdatasync()</code>只会强制更新数据。相比之下，调用<code>fsync()</code>还会强制更新元数据)。对于侧重性能
(不侧重某些元数据的准确性)
的应用程序，这很有用。此外，对于更新多个文件的应用程序，这会可能会显著提升性能，因为文件数据和元数据通常存储在磁盘的不同部分
(更新它们需要重复地来回寻道)。对于Linux
2.2及以下版本，<code>fdatasync()</code>被实现为对<code>fsync()</code>的调用，所以没有性能提升。</p>
<p>　　从内核2.6.17开始，Linux提供了非标准系统调用<code>sync_file_range()</code>。相比<code>fdatasync()</code>，该系统调用在刷新文件数据可以进行更精确的控制，并且还能指定标志来控制是否允许该系统调用阻塞在对磁盘的写操作上。</p>
<p>　　系统调用<code>sync()</code>会导致所有包含更新后的文件信息的内核缓冲区
(例如，数据块、指针块和元数据)
刷新到磁盘。对于Linux实现，<code>sync()</code>只会在所有数据都传输到磁盘
(至少传输到磁盘缓存)
后才会返回。但是，SUSv3允许<code>sync()</code>实现简单地调度I/O传输，然后在其完成之前返回。</p>
<p>　　若修改后的内核缓冲区在30秒内没有显式同步，则1个永久运行的内核线程
(对于Linux 2.4，它是<code>kupdated</code>；对于Linux
2.6，它是<code>pdflush</code>)
会保证修改后的内核缓冲区刷新到磁盘。这是为了保证缓冲区不会长期未与对应的磁盘文件同步
(导致系统崩溃时更容易丢失该缓冲区)。</p>
<p>　　文件<code>/proc/sys/vm/dirty_expire_centisecs</code>指定了脏缓冲区在被<code>pdflush</code>刷新之前的最短存在时间
(以百分之一秒为单位)。同一目录下的其他文件控制着<code>pdflush</code>的其他方面。</p>
<h4 id="标志o_sync">13.3.1 标志<code>O_SYNC</code></h4>
<p>　　若调用<code>open()</code>时指定了打开文件状态标志<code>O_SYNC</code>，则会<span
style="background-color: yellow">同步</span>后续的所有输出，即后续的所有对<code>write()</code>的调用会自动将文件数据和元数据刷新到磁盘
(按照同步I/O文件完整性完成的要求)。</p>
<p>　　早期BSD系统使用标志<code>O_FSYNC</code>来提供<code>O_SYNC</code>的功能。对于glibc，<code>O_FSYNC</code>等同于<code>O_SYNC</code>。</p>
<p>　　以下是在<code>write_bytes.c</code>使用不同的<code>BUF_SIZE</code>值在使用vanilla
2.6.30内核和块大小是4096字节的ext2文件系统的Linux上写1亿字节到新创建的文件所需的时间
(运行20次的平均值)：</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 22%" />
<col style="width: 25%" />
<col style="width: 20%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr>
<th><code>BUF_SIZE</code></th>
<th>不指定<code>O_SYNC</code>的总耗时 (秒)</th>
<th>不指定<code>O_SYNC</code>的总CPU时间 (秒)</th>
<th>指定<code>O_SYNC</code>的总耗时 (秒)</th>
<th>指定<code>O_SYNC</code>的总CPU时间 (秒)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0.73</td>
<td>0.73</td>
<td>1030</td>
<td>98.8</td>
</tr>
<tr>
<td>16</td>
<td>0.05</td>
<td>0.05</td>
<td>65.0</td>
<td>0.40</td>
</tr>
<tr>
<td>256</td>
<td>0.02</td>
<td>0.02</td>
<td>4.07</td>
<td>0.03</td>
</tr>
<tr>
<td>4096</td>
<td>0.01</td>
<td>0.01</td>
<td>0.34</td>
<td>0.03</td>
</tr>
</tbody>
</table>
<p>　　当指定标志<code>O_SYNC</code>后，总耗时会显著增加。当<code>BUF_SIZE</code>为1时，总耗时大于1000秒。此外，总耗时和总CPU时间存在很大差异，因为程序阻塞在缓冲区传输数据到磁盘。这个测试忽略了1个影响程序性能的重要因素——磁盘缓存。现代磁盘驱动都拥有较大的外部缓存，在默认情况下，<code>O_SYNC</code>只会导致数据传输到缓存。</p>
<p>　　因此，为了强制刷新内核缓冲区，应考虑使用较大的<code>write()</code>缓冲区或谨慎地使用<code>fsync()</code>或<code>fdatasnyc()</code>，而非使用标志<code>O_SYNC</code>。</p>
<h4 id="标志o_dsync和o_rsync">13.3.2
标志<code>O_DSYNC</code>和<code>O_RSYNC</code></h4>
<p>　　SUSv3还提供了2个与同步I/O相关的打开文件状态标志：<code>O_DSYNC</code>和<code>O_RSYNC</code>。</p>
<p>　　●
<code>O_DSYNC</code>会导致写操作按照同步I/O数据完整性完成的要求执行
(类似<code>fdatasync()</code>)。</p>
<p>　　●
<code>O_RSYNC</code>与<code>O_SYNC</code>或<code>O_DSYNC</code>一起使用，会将这些标志的写操作的行为扩展到读操作。因此，当同时使用这些标志时，读操作也会按照同步I/O文件完整性完成或同步I/O数据完整性完成的要求执行
(在执行读操作之前，所有待处理的写操作都会按照同步I/O文件完整性完成或同步I/O数据完整性完成的要求执行)。</p>
<p>　　在内核2.6.33之前，Linux没有实现这2个标志，并且glibc将这2个标志定义为标志<code>O_SYNC</code>的值。此外，Linux没有完全实现标志<code>O_SYNC</code>的语义，相反，标志<code>O_SYNC</code>被实现为标志<code>O_DSYNC</code>。为了兼容较旧的内核版本，应用程序应该链接旧版本的glibc。从内核2.6.33开始，Linux实现了标志<code>O_DSYNC</code>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第10章 时间</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_10/</url>
    <content><![CDATA[<p>　　在程序中，有2种重要的时间：<strong>实际时间</strong>和<strong>进程时间</strong>。</p>
<p>　　● 实际时间基于某个标准时间点 (即<strong>日历时间</strong>)
或进程的生命周期中的某个固定时间点
(即<strong>运行时间</strong>或<strong>挂钟时间</strong>)
测量。日历时间用于为数据库记录和文件添加时间戳的程序。运行时间用于执行定期操作或通过外部输入设备进行定期采样的程序。</p>
<p>　　●
进程时间是进程所用的CPU时间。进程时间用于检测或优化程序和算法的性能。</p>
<p>　　大多数计算机架构都有1个内部硬件时钟，使内核能够测量实际时间和进程时间。</p>
<p>　　进程时间是自进程创建以来所用的CPU时间。为了便于记录，内核将CPU时间分为<strong>用户CPU时间</strong>
(也称为<strong>虚拟时间</strong>)
和<strong>系统CPU时间</strong>。当通过shell运行程序时，可以使用命令<code>time</code>来查看程序所用的各种进程时间。</p>
<p>　　● 用户CPU时间是在用户模式下执行所用的时间。</p>
<p>　　●
系统CPU时间是在内核模式下执行所用的时间，即内核执行系统调用或代表程序执行其他任务
(例如，处理缺页) 所用的时间。</p>
<p>　　有时，进程时间也称为程序所用的<span
style="background-color: yellow">总CPU时间</span>。</p>
<p>　　UNIX系统将内部时间表示自UTC (或GMT) 时间1970年1月1日凌晨
(即<strong>纪元</strong>)
以来的秒数，这大约是UNIX的诞生之日。日历时间存储为整型数据类型<code>time_t</code>。</p>
<p>　　对于32位Linux系统，<code>time_t</code>被实现为有符号整数，只能表示1901年12月13日
20:45:52到2038年1月19日 03:14:07内的时间
(SUSv3没有说明<code>time_t</code>的负值的含义)。因此，很多32位UNIX系统都面临<span
style="background-color: yellow">2038年危机</span>。到2038年，可能所有UNIX实现早已变为64位及以上，这一事实大大缓解了该问题。但是，32位嵌入式系统
(其使用寿命通常比对应的桌面系统的更长)
可能会受到该问题的影响。此外，对于以32位<code>time_t</code>维护时间的遗留数据和应用程序，该问题仍然存在。</p>
<span id="more"></span>
<p>　　不同的国家 (甚至同一国家的不同地区) 通常使用不同的时区和夏令时
(DST)。时区信息通常繁多，所以通常不会将其编码为程序或库，而是将其以标准格式保存在文件中。</p>
<p>　　时区信息通常维护在目录<code>/usr/share/zoneinfo</code>下，该目录下的所有文件都包含特定国家或地区的时区信息。这些文件的名称与其内容相关，例如，<code>EST</code>
(美国西部标准时间)、<code>CET</code>
(欧洲中部标准时间)、<code>UTC</code>、<code>Turkey</code>和<code>Iran</code>。此外，可能会使用子目录来将相关时区组织为层次结构，例如，子目录<code>Pacific</code>可能会有文件<code>Auckland</code>、<code>Port_Moresby</code>和<code>Galapagos</code>。当指定程序使用的时区时，指定的就是该目录下的时区文件的相对路径名。</p>
<p>　　时区文件的格式记录在<code>tzfile</code>的手册中。时区文件通过<span
style="background-color: yellow">时区信息编译器</span><code>zic</code>构建。命令<code>zdump</code>可用于根据指定时区文件中的时区显式时间。</p>
<p>　　系统的本地时间定义在时区文件<code>/etc/localtime</code>中，该文件通常链接到<code>/usr/share/zoneinfo</code>下的某个文件。</p>
<p>　　SUSv3将<strong>区域设置</strong>定义为取决于语言和文化习俗的用户环境子集。与时区信息类似，区域设置也是以标准格式保存在文件中。</p>
<p>　　术语<strong>国际化</strong>经常缩写为<span
style="background-color: yellow">I18N</span>。除了写得更快，该缩写还避免了英式英语和美式英语中术语本身拼写的差距。</p>
<p>　　本书中描述的与时间相关的系统调用都受到系统<strong>软件时钟</strong>的精度的影响。软件时钟测量时间的单位称为<span
style="background-color: yellow">jiffy</span>。jiffy的大小由内核源代码中常量<code>HZ</code>定义。这是内核将CPU分配给循环分时算法下的进程的单元。</p>
<p>　　对于Linux/x86-32，内核2.4及以下版本的软件时钟的频率是100赫兹
(jiffy是10毫秒)，内核
2.6的软件时钟是1000赫兹。随着时钟频率的增加，定时器操作的精度会变得更高，时间测量也会变得更精准。但是，软件时钟并非越高越好，因为每次时钟中断都会消耗少量CPU时间，在此期间，CPU不能服务进程。</p>
<p>　　内核开发者之间的争论最终导致软件时钟频率成为了1个可配置的内核选项。从内核
2.6.13开始，软件时钟频率可以设置100250或1000赫兹。从内核
2.6.20开始，软件时钟频率可以设置100250、1000或300赫兹，300赫兹的频率是25帧每秒的PAL制和30帧每秒的NTSC制的帧数的整数倍。</p>
<h3 id="日历时间">10.1 日历时间</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;       <span class="comment">/* 自纪元以来的秒数 */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec; <span class="comment">/* 附加的微秒 (long int) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> tz_minuteswest; <span class="comment">/* UTC减去本地时区得到的分钟数 (对于UTC+1时区，该成员为-60) */</span></span><br><span class="line">    <span class="type">int</span> tz_dsttime;     <span class="comment">/* 表示本地时区中生效的DST制度的常数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>gettimeofday()</code>用于获取日历时间，结果存储在参数<code>tv</code>指向的结构体中。</p>
<p>　　尽管结构体<code>timeval</code>中的成员<code>tv_usec</code>用于表示精确微秒，但该成员的精度取决于依赖于架构的实现。该成员的名称中的<code>u</code>源于该成员与公制中用于表示百万分之一的希腊字母μ的相似之处。对于现代x86-32系统
(即时间戳计数器寄存器在每个CPU时钟周期都递增的Pentium系统)，<code>gettimeofday()</code>确实提供了微秒级精度。</p>
<p>　　参数<code>tz</code>是历史产物。对于早期UNIX实现，该参数用于检索系统的时区信息。该参数现已过时，并且应该指定为<code>NULL</code>。若<code>tz</code>不是<code>NULL</code>，则它指向的结构体的值会变为最近1次调用<code>settimeofday()</code>
(其参数与<code>gettimeofday()</code>的相同)
时指定给<code>tz</code>的值。因为DST制度无法用简单的算法实现，所以<code>tz</code>会过时
(Linux从未支持该成员)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *timep)</span>; <span class="comment">/* 成功时返回自纪元以来的秒数，出错时返回(time_t)-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>time()</code>会返回自纪元以来的秒数。若参数<code>timep</code>不是<code>NULL</code>，则返回值也会存储在该参数指向的内存中。</p>
<p>　　因为<code>time()</code>会以2种方式返回相同的值，并且只有在<code>timep</code>是无效地址时才会出错
(<code>EFAULT</code>)，所以可以直接以<code>t = time(NULL)</code>的方式调用。</p>
<p>　　由于历史原因，<code>gettimeofday()</code>与<code>time()</code>得以共存。早期UNIX实现提供了<code>time()</code>。4.3BSD添加了更精准的<code>gettimeofday()</code>。</p>
<h3 id="时间转换函数">10.2 时间转换函数</h3>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_10/functions_for_retrieving_and_working_with_calendar_time.svg" class="">
<p>　　如图所示，这里展示了各种用于在日历时间和其他时间格式之间转换的函数。</p>
<h4 id="将日历时间转换为字符串">10.2.1 将日历时间转换为字符串</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>; <span class="comment">/* 成功时返回静态分配的以\n\0结尾的字符串，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>ctime()</code>会将日历时间转换为26位的固定格式字符串
(形如<code>Wed Jun 8 14:22:34 2011\n\0</code>) 并返回。</p>
<p>　　<code>ctime()</code>在执行转换时，会应用时区和DST设置。该函数返回的字符串是静态分配的，所以后续对该函数的失败调用会将其覆盖。</p>
<p>　　<code>ctime()</code>的可重入版本是<code>ctime_r()</code>。调用<code>ctime_r()</code>时可以指定额外的指针参数，该参数指向用于存储转换结果字符串的缓冲区。</p>
<p>　　SUSv3规定，对<code>ctime()</code>、<code>gmtime()</code>、<code>localtime()</code>或<code>asctime()</code>的调用可能会覆盖其他函数返回的静态分配的结构体。换句话说，这些函数可能共享相同的返回字符串和结构体<code>tm</code>。</p>
<h4 id="在日历时间和分解时间之间转换">10.2.2
在日历时间和分解时间之间转换</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回静态分配的分解时间结构体，出错时返回NULL */</span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">/* 秒 (0-60) */</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">/* 分 (0-59) */</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">/* 时 (0-23) */</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">/* 日 (1-31) */</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">/* 月 (0-11) */</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">/* 年 (自1900年以来) */</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">/* 周 (0表示周日)*/</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">/* 1年中的某天 (0-365，0表示1月1日)*/</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">/* DST标志 (大于0表示DST生效，等于0表示DST不生效，小于0表示DST视情况而定) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>gmtime()</code> (名称中的<code>gm</code>源于GMT)
会将日历时间转换为对应UTC的<strong>分解时间</strong>，分解时间存储在静态分配的结构体<code>tm</code>中，然后返回该结构体的地址。相比之下，函数<code>localtime()</code>会将日历时间转换为系统本地时间。</p>
<p>　　结构体<code>tm</code>的成员<code>tm_sec</code>的最大值是60，因为其中包括了用于保证人类日历接近回归年的<span
style="background-color: yellow">闰秒</span>。</p>
<p>　　若定义了特性测试宏<code>_BSD_SOURCE</code>，glibc版本的结构体<code>tm</code>会包含2个额外成员。第1个额外成员是<code>long int tm_gmtoff</code>，其值为本地时区减去UTC得到的秒数。第2个额外成员是<code>char *tm_zone</code>，表示时区名的缩写形式
(例如，CEST表示欧洲中部DST)。SUSv3没有说明这2个额外成员，并且只有少数UNIX实现
(主要是BSD衍生实现) 提供了这2个额外成员。</p>
<p>　　<code>gmtime()</code>和<code>localtime()</code>的可重入版本是<code>gmtime_r()</code>和<code>localtime_r()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *timeptr)</span>; <span class="comment">/* 成功时返回timeptr对应的自纪元以来的秒数，出错时返回(time_t)-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>mktime()</code>会将本地时间对应的分解时间
(参数<code>timeptr</code>)
转换为日历时间并返回。转换时会忽略结构体<code>tm</code>中的成员<code>tm_wday</code>和<code>tm_yday</code>。</p>
<p>　　<code>mktime()</code>可能会修改<code>timeptr</code>指向的结构体。至少，它会保证成员<code>tm_wday</code>和<code>tm_yday</code>与其他成员匹配。此外，<code>mktime()</code>允许其他成员的值超出范围。对于每个超出范围的成员，<code>mktime()</code>会将其值调整为范围内的值，并且对其他成员进行适当的调整。这些调整会在<code>mktime()</code>更新成员<code>tm_wday</code>和<code>tm_yday</code>和计算返回值之前进行。</p>
<p>　　例如，若输入时成员<code>tm_sec</code>是123，则返回时该成员会变为3，并且成员<code>tm_min</code>会加2
(若成员<code>tm_min</code>加2后溢出，则会将<code>tm_hour</code>加1，依此类推)。若输入时<code>tm_sec</code>是-1，则返回时该成员会变为59，并且成员<code>tm_min</code>会减1。</p>
<p>　　<code>mktime()</code>进行转换时会应用时区设置。此外，也可能会应用DST，取决于成员<code>tm_isdst</code>。若该成员等于0，则会忽略DST；若该成员大于0，则会直接应用DST
(无论给定时间是否受到DST影响)；若该成员小于0，则会先判断给定时间是否受到DST影响，再根据结果来决定是否应用DST。</p>
<p>　　转换完成后，成员<code>tm_isdst</code>会被设置为正值
(给定时间受到DST影响) 或0 (DST不生效)。</p>
<h4 id="在分解时间与字符串之间转换">10.2.3
在分解时间与字符串之间转换</h4>
<h5 id="将分解时间转换为字符串">10.2.3.1 将分解时间转换为字符串</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span>; <span class="comment">/* 成功时返回静态分配的以\n\0结尾的字符串，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>asctime()</code>会将分解时间 (参数<code>timeptr</code>)
转换为26位的固定格式字符串
(形如<code>Wed Jun 8 14:22:34 2011\n\0</code>) 并返回。</p>
<p>　　与<code>ctime()</code>相比，<code>asctime()</code>不会应用时区设置，因为该函数转换的时间通常是通过<code>localtime()</code>本地化后的时间或<code>gmtime()</code>返回的时间。</p>
<p>　　<code>asctime()</code>的可重入版本是<code>asctime_r()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* calendar_time.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDS_IN_TROPICAL_YEAR (365.24219 * 24 * 60 * 60)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">gmp</span>, *<span class="title">locp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">gm</span>, <span class="title">loc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    t = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Seconds since the Epoch (1 Jan 1970): %ld&quot;</span>, (<span class="type">long</span>)t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; (about %6.3f years)\n&quot;</span>, t / SECONDS_IN_TROPICAL_YEAR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gettimeofday(&amp;tv, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;gettimeofday&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; gettimeofday() returned %ld secs, %ld microsecs\n&quot;</span>,</span><br><span class="line">           (<span class="type">long</span>)tv.tv_sec, (<span class="type">long</span>)tv.tv_usec);</span><br><span class="line"></span><br><span class="line">    gmp = gmtime(&amp;t);</span><br><span class="line">    <span class="keyword">if</span> (gmp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;gmtime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gm = *gmp; <span class="comment">/* 保存副本，因为*gmp可能会被后续对asctime()和gmtime()的调用覆盖 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Broken down by gmtime():\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; year=%d mon=%d mday=%d hour=%d min=%d sec=%d &quot;</span>, gm.tm_year,</span><br><span class="line">           gm.tm_mon, gm.tm_mday, gm.tm_hour, gm.tm_min, gm.tm_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wday=%d yday=%d isdst=%d\n&quot;</span>, gm.tm_wday, gm.tm_yday, gm.tm_isdst);</span><br><span class="line"></span><br><span class="line">    locp = localtime(&amp;t);</span><br><span class="line">    <span class="keyword">if</span> (locp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;localtime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loc = *locp; <span class="comment">/* 保存副本 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Broken down by localtime():\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; year=%d mon=%d mday=%d hour=%d min=%d sec=%d &quot;</span>, loc.tm_year,</span><br><span class="line">           loc.tm_mon, loc.tm_mday, loc.tm_hour, loc.tm_min, loc.tm_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wday=%d yday=%d isdst=%d\n\n&quot;</span>, loc.tm_wday, loc.tm_yday, loc.tm_isdst);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;asctime() formats the gmtime() value as: %s&quot;</span>, asctime(&amp;gm));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ctime() formats the time() value as: %s&quot;</span>, ctime(&amp;t));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mktime() of gmtime() value: %ld secs\n&quot;</span>, (<span class="type">long</span>)mktime(&amp;gm));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mktime() of localtime() value: %ld secs\n&quot;</span>, (<span class="type">long</span>)mktime(&amp;loc));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了上述函数的用法。该程序会检索当前日历时间，然后通过各种时间转换函数来转换时间，最后打印转换结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *outstr, <span class="type">size_t</span> maxsize, <span class="type">const</span> <span class="type">char</span> *format,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span>; <span class="comment">/* 成功时返回outstr的长度减1 (不包括结尾的字符\0)，出错时返回0 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>strftime()</code>会将分解时间
(参数<code>timeptr</code>)
转换为以字符<code>\0</code>字符结尾的指定格式字符串
(参数<code>outstr</code>)。</p>
<p>　　字符串<code>outstr</code>的格式取决于参数<code>format</code>。参数<code>maxsize</code>指定<code>outstr</code>的长度。此外，<code>outstr</code>不包括换行符<code>\n</code>
(除非<code>format</code>要求如此)。</p>
<p>　　若<code>strftime()</code>成功，则返回<code>outstr</code>的长度减1
(不包括结尾的字符<code>\0</code>字符)。若转换结果的长度超过了<code>maxsize</code>，则返回0，并且<code>outstr</code>是不确定的。</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 49%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">格式说明符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>%%</code></td>
<td><code>%</code>字符</td>
<td>%</td>
</tr>
<tr>
<td style="text-align: left;"><code>%a</code></td>
<td>每周7天的名称的缩写</td>
<td>Tue</td>
</tr>
<tr>
<td style="text-align: left;"><code>%A</code></td>
<td>每周7天的全名</td>
<td>Tuesday</td>
</tr>
<tr>
<td style="text-align: left;"><code>%b, %h</code></td>
<td>月名的缩写</td>
<td>Feb</td>
</tr>
<tr>
<td style="text-align: left;"><code>%B</code></td>
<td>月名的全称</td>
<td>February</td>
</tr>
<tr>
<td style="text-align: left;"><code>%c</code></td>
<td>日期和时间</td>
<td>Tue Feb 1 21:39:46 2011</td>
</tr>
<tr>
<td style="text-align: left;"><code>%d</code></td>
<td>月份中的某天 (01~31，2位数)</td>
<td>01</td>
</tr>
<tr>
<td style="text-align: left;"><code>%D</code></td>
<td>美国时间格式 (等同于<code>%m/%d/%y</code>)</td>
<td>02/01/11</td>
</tr>
<tr>
<td style="text-align: left;"><code>%e</code></td>
<td>字符形式的月份中的某天 (2个字符)</td>
<td>1</td>
</tr>
<tr>
<td style="text-align: left;"><code>%F</code></td>
<td>ISO时间格式 (等同于<code>%Y-%m-%d</code>)</td>
<td>2011-02-01</td>
</tr>
<tr>
<td style="text-align: left;"><code>%H</code></td>
<td>小时 (24小时制，2位数)</td>
<td>21</td>
</tr>
<tr>
<td style="text-align: left;"><code>%I</code></td>
<td>小时 (12小时制，2位数)</td>
<td>09</td>
</tr>
<tr>
<td style="text-align: left;"><code>%j</code></td>
<td>1年中的某天 (001~365，3位数)</td>
<td>032</td>
</tr>
<tr>
<td style="text-align: left;"><code>%m</code></td>
<td>十进制形式的月份 (01~12，2位数)</td>
<td>02</td>
</tr>
<tr>
<td style="text-align: left;"><code>%M</code></td>
<td>分钟 (2位数)</td>
<td>39</td>
</tr>
<tr>
<td style="text-align: left;"><code>%p</code></td>
<td>AM/PM</td>
<td>PM</td>
</tr>
<tr>
<td style="text-align: left;"><code>%P</code></td>
<td>am/pm (GNU扩展)</td>
<td>pm</td>
</tr>
<tr>
<td style="text-align: left;"><code>%R</code></td>
<td>23小时制的时间 (等同于<code>%H:%M</code>)</td>
<td>21:39</td>
</tr>
<tr>
<td style="text-align: left;"><code>%S</code></td>
<td>秒钟 (00~60)</td>
<td>46</td>
</tr>
<tr>
<td style="text-align: left;"><code>%T</code></td>
<td>时间 (等同于<code>%H:%M:%S</code>)</td>
<td>21:39:46</td>
</tr>
<tr>
<td style="text-align: left;"><code>%u</code></td>
<td>1周中的某天 (1~7，1表示周一)</td>
<td>2</td>
</tr>
<tr>
<td style="text-align: left;"><code>%U</code></td>
<td>1年中的第几个周日 (00~53)</td>
<td>05</td>
</tr>
<tr>
<td style="text-align: left;"><code>%w</code></td>
<td>1周中的某天 (0~6，0表示周日)</td>
<td>2</td>
</tr>
<tr>
<td style="text-align: left;"><code>%W</code></td>
<td>1年中的第几个周一 (00~53)</td>
<td>05</td>
</tr>
<tr>
<td style="text-align: left;"><code>%x</code></td>
<td>本地日期</td>
<td>02/01/11</td>
</tr>
<tr>
<td style="text-align: left;"><code>%X</code></td>
<td>本地时间</td>
<td>21:39:46</td>
</tr>
<tr>
<td style="text-align: left;"><code>%y</code></td>
<td>年份 (2位数)</td>
<td>11</td>
</tr>
<tr>
<td style="text-align: left;"><code>%Y</code></td>
<td>年份 (4位数)</td>
<td>2011</td>
</tr>
<tr>
<td style="text-align: left;"><code>%Z</code></td>
<td>时区名</td>
<td>CET</td>
</tr>
</tbody>
</table>
<p>　　<code>format</code>与提供给<code>printf()</code>的格式说明符类似，以百分号<code>%</code>开头
(按照规范)，之后是表示日期或时间的字符串。除非另有说明，否则，这些转换格式说明符默认是SUSv3的一部分。</p>
<p>　　格式说明符<code>%U</code>和<code>%W</code>都可用于表示1年中的第几周。<code>%U</code>会将1年中第1个包含周日的周记为第1周，第1周前的周记为第0周。若周日正好是1年的第1天，则不会有第0周，并且同年的最后1天会记为第53周。<code>%W</code>与之类似，但以周一为基准来计算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* curr_time.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span> <span class="comment">/* 函数原型在该头文件中 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将当前时间转换为以字符\0结尾的指定格式字符串 (出错时返回NULL)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param format 若为NULL，则默认使用格式说明符%c</span></span><br><span class="line"><span class="comment"> * @return char* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">currTime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[BUF_SIZE]; <span class="comment">/* 不可重入 */</span></span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    <span class="type">size_t</span> s;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tm</span>;</span></span><br><span class="line"></span><br><span class="line">    t = time(<span class="literal">NULL</span>);</span><br><span class="line">    tm = localtime(&amp;t);</span><br><span class="line">    <span class="keyword">if</span> (tm == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = strftime(buf, BUF_SIZE, (format != <span class="literal">NULL</span>) ? format : <span class="string">&quot;%c&quot;</span>, tm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (s == <span class="number">0</span>) ? <span class="literal">NULL</span> : buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在之后的示例程序中，会经常需要打印当前时间。因此，这里实现了函数<code>currTime()</code>，该函数会返回当前时间对应的指定格式字符串
(参数<code>format</code>)。</p>
<h5 id="将字符串转换为分解时间">10.2.3.2 将字符串转换为分解时间</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strptime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, <span class="keyword">struct</span> tm *timeptr)</span>; <span class="comment">/* 成功时返回指向str中下一个未被处理字符的指针，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>strptime()</code>会根据参数<code>format</code>指定的格式说明符来将参数<code>str</code>解析为分解时间，然后将结果存储在参数<code>timeptr</code>指向的结构体中。</p>
<p>　　若<code>strptime()</code>成功，则会返回指向<code>str</code>中下一个未被处理字符的指针
(当<code>str</code>中包含需要调用进程进一步处理的字符时，这很有用)。</p>
<p>　　<code>format</code>与提供给<code>strftime()</code>的格式说明符类似，主要区别是<code>strptime()</code>的格式说明符更通用。例如，<code>%a</code>和<code>%A</code>都可用于读取每周7天的名称
(无论全称还是缩写)，<code>%d</code>和<code>%e</code>都可用于读取月份中的某天
(无论<code>1</code>还是<code>01</code>)。此外，转换时会忽略<code>str</code>中字符的大小写
(例如，<code>May</code>等同于<code>MAY</code>)。<code>format</code>中的<code>%%</code>用于匹配<code>str</code>中的百分号。若<code>format</code>不符合规范，则<code>strptime()</code>会返回<code>NULL</code>。</p>
<p>　　glibc版本的<code>strptime()</code>不会修改结构体<code>tm</code>中的没有对应格式说明符的成员。因此，可以通过多次调用<code>strptime()</code>来解析多个字符串，以构建单个结构体
(SUSv3没有说明这种行为)。在大多数情况下，通过<code>memset()</code>将整个结构体初始化为0就足够了。但是，对于glibc等大多数实现，成员<code>tm_mday</code>为0时表示上一个月的最后1天。此外，<code>strptime()</code>不会修改成员<code>tm_isdst</code>。</p>
<p>　　<code>glic</code>提供了2个与<code>strptime()</code>类似的函数：<code>getdate()</code>和对应的可重入版本<code>getdate_r()</code>。这2个函数需要使用外部文件
(由环境变量<code>DATEMSK</code>标识)
来指定转换格式，外部文件使得这些函数难以使用，并且会在set-user-ID程序中产生安全漏洞。SUSv3详细说明了<code>getdate()</code>，并且大部分UNIX实现都提供了该函数。SUSv3没有说明<code>getdate_r()</code>，并且只有少部分UNIX实现提供了该函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* strtime.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUF_SIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line">    <span class="type">char</span> sbuf[SBUF_SIZE];</span><br><span class="line">    <span class="type">char</span> *ofmt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s input-date-time in-format [out-format]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setlocale(LC_ALL, <span class="string">&quot;&quot;</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setlocale&quot;</span>); <span class="comment">/* 转换时应用区域设置 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tm, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tm)); <span class="comment">/* 初始化tm */</span></span><br><span class="line">    <span class="keyword">if</span> (strptime(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;tm) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;strptime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tm.tm_isdst = <span class="number">-1</span>; <span class="comment">/* 告诉mktime()检测DST是否生效 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;calendar time (seconds since Epoch): %ld\n&quot;</span>, (<span class="type">long</span>)mktime(&amp;tm));</span><br><span class="line"></span><br><span class="line">    ofmt = (argc &gt; <span class="number">3</span>) ? argv[<span class="number">3</span>] : <span class="string">&quot;%H:%M:%S %A, %d %B %Y %Z&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (strftime(sbuf, SBUF_SIZE, ofmt, &amp;tm) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;strftime returned 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strftime() yields: %s\n&quot;</span>, sbuf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>strptime()</code>和<code>strftime()</code>的用法。该程序会通过<code>strptime()</code>来将包含日期和时间的命令行参数转换为分解时间，然后通过<code>strftime()</code>来将分解时间转换为日历时间，最后打印结果。该程序最多接收3个命令行参数，但只有前2个命令行参数是必需的。第1个命令行参数是包含日期和时间的字符串，第2个命令行参数是通过<code>strptime()</code>解析第1个命令行参数时所用的格式说明符。第3个命令行参数是通过<code>strftime()</code>将分解时间转换为日历时间时所用的格式说明符。若第3个命令行参数未指定，则使用默认的格式说明符。</p>
<h3 id="时区">10.3 时区</h3>
<p>　　为了在运行程序时指定时区，需要将环境变量<code>TZ</code>设置为由冒号<code>:</code>加上<code>/usr/share/zoneinfo</code>中的时区名组成的字符串。函数<code>ctime()</code>、<code>localtime()</code>、<code>mktime()</code>和<code>strftime()</code>都会受到时区设置的影响。为了获取当前时区设置，这些函数会使用函数<code>tzset()</code>，<code>tzset()</code>会初始化以下3个全局变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *tzname[<span class="number">2</span>]; <span class="comment">/* 时区和备用 (DST) 时区的名称 */</span></span><br><span class="line"><span class="type">int</span> daylight;    <span class="comment">/* 使用了备选 (DST) 时区时非0 */</span></span><br><span class="line"><span class="type">long</span> timezone;   <span class="comment">/* UTC和本地时区相差的秒数 */</span></span><br></pre></td></tr></table></figure>
<p>　　<code>tzset()</code>会先检查环境变量<code>TZ</code>。若该环境变量未设置，则使用时区文件<code>/etc/localtime</code>中的定义来将时区初始化为默认设置；若该环境变量是空字符串或没有匹配的时区文件，则将时区设置为UTC。环境变量<code>TZDIR</code>
(非标准的GNU扩展) 可以设置为时区对应的文件的目录名
(而非默认的<code>/usr/share/zoneinfo</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* show_time.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 200</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">loc</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setlocale(LC_ALL, <span class="string">&quot;&quot;</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setlocale&quot;</span>); <span class="comment">/* 转换时应用区域设置 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ctime() of time() value is: %s&quot;</span>, ctime(&amp;t));</span><br><span class="line"></span><br><span class="line">    loc = localtime(&amp;t);</span><br><span class="line">    <span class="keyword">if</span> (loc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;localtime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;asctime() of local time is: %s&quot;</span>, asctime(loc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strftime(buf, BUF_SIZE, <span class="string">&quot;%A, %d %B %Y, %H:%M:%S %Z&quot;</span>, loc) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;strftime returned 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strftime() of local time is: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了时区设置和区域设置的影响。</p>
<p>　　SUSv3定义了设置环境变量<code>TZ</code>的2种常用方法。第1方法是设置为由冒号<code>:</code>加上<code>/usr/share/zoneinfo</code>中的时区名组成的字符串
(Linux和部分UNIX实现允许省略冒号，但SUSv3不允许这样)。第2种方法是SUSv3详细说明的方法，将环境变量<code>TZ</code>设置为以下格式的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std offset [ dst [ offset ][ , start-date [ /time ] , end-date [ /time ]]]</span><br></pre></td></tr></table></figure>
<p>　　为了进行区分，这里使用了<span
style="background-color: yellow">实际上不存在的空格</span>。括号<code>([])</code>中的字段是可选项。</p>
<p>　　字段<code>std</code>和<code>dst</code>用于标识标准时区和DST时区。字段<code>offset</code>是本地时区减去UTC得到的值。最后4个字段表示何时从标准时间更改为DST时间。日期字段能以多种形式指定，例如，<code>Mm.n.d</code>表示<code>m</code>月
(1~12) 的第<code>n</code>周 (1~5，5表示最后<code>d</code>天)
的第<code>d</code>天
(0表示周日，6表示周六)。若字段<code>time</code>未指定，则默认为<code>02:00:00</code>。</p>
<p>　　<code>TZ="CET-1:00:00CEST-2:00:00,M3.5.0,M10.5.0"</code>会将环境变量<code>TZ</code>设置为欧洲中部
(标准时区是UTC-1，DST时区是UTC-2
，从3月的最后1个周日到10月最后1个周日)。这里省略了DST转换的规范，因为它发生在默认的<code>02:00:00</code>。对于Linux，这等同于<code>TZ=":Europe/Berlin"</code>。</p>
<h3 id="区域设置">10.4 区域设置</h3>
<p>　　区域设置控制着GNU/Linux工具以及很多glibc函数
(例如，<code>strftime()</code>和<code>strptime()</code>)
的多种行为。</p>
<p>　　区域设置信息维护在目录<code>/usr/share/locale</code>下的层次结构中
(某些发行版是<code>/usr/lib/locale</code>)。该目录下的每个子目录都包含1个特定的区域设置。这些子目录按照以下格式命名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">language[_territory[.codeset]][@modifier]</span><br></pre></td></tr></table></figure>
<p>　　字段<code>language</code>是2个字母的ISO语言代码。字段<code>territory</code>是2个字母的ISO国家代码。字段<code>codeset</code>是字符编码集。字段<code>modifier</code>用于区分其它3个字段都相同的不同区域设置。例如，<code>de_DE.utf-8@euro</code>表示区域设置的语言是德语，地区是德国，字符编码集是UTF-8，货币单位是欧元。</p>
<p>　　括号中的字段是可选项。通常，子目录的名称仅包含字段<code>language</code>和<code>territory</code>。因此，<code>en_US</code>是
(英语) 美国的区域设置，<code>fr_CH</code>
(<code>CH</code>表示瑞士的拉丁语名Confoederatio Helvetica)
是瑞士法语区的区域设置子目录。</p>
<p>　　SUSv3对区域设置唯一的要求是<span
style="background-color: yellow">定义1个名为POSIX的标准区域设置</span>，该区域设置反映了UNIX系统的历史行为。因此，该区域设置基于ASCII字符集，并使用英语表示日期和月份的名称以及肯定/否定响应。此外，该区域设置的货币和数字部分是未定义的。</p>
<p>　　每个区域设置子目录下都是1组标准文件，这些文件指定了区域设置的规范，如下表所示：</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr>
<th>文件名</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LC_TYPE</code></td>
<td>包含字符分类 (见函数<code>isalpha()</code>)
和大小写转换规则的文件</td>
</tr>
<tr>
<td><code>LC_COLLATE</code></td>
<td>包含字符集的排序规则的文件</td>
</tr>
<tr>
<td><code>LC_MONETARY</code></td>
<td>包含货币值格式规则的文件
(见函数<code>localeconv()</code>和头文件<code>locale.h</code>)</td>
</tr>
<tr>
<td><code>LC_NUMERIC</code></td>
<td>包含除货币值之外的数字的格式规则的文件</td>
</tr>
<tr>
<td><code>LC_TIME</code></td>
<td>包含日期和时间的格式规则的文件</td>
</tr>
<tr>
<td><code>LC_MESSAGES</code></td>
<td>包含指定用于肯定和否定响应的格式和值的文件</td>
</tr>
</tbody>
</table>
<p>　　● 文件<code>LC_COLLATE</code>定义了1组描述字符集的排序规则
(按字母顺序排序)
的规则。这些规则决定函数<code>strcoll()</code>和<code>strxfrm</code>的行为。即使基于拉丁语脚本的语言也不遵循相同的排序规则。例如，部分欧洲语言有额外的字母，在某些情况下，这些字母排在字母Z之后。其他特殊情况包括西班牙语双字母序列ll
(作为单个字母，排在字母l之后) 和德语元音变音符
(例如，ä对应ae，并且按照这2个字母排序)。</p>
<p>　　●
目录<code>LC_MESSAGES</code>用于将程序显示的信息国际化。通过使用消息目录
(见函数<code>catopen()</code>和<code>catgets()</code>的手册)
或GNU的API<code>gettext</code> 可以完成更全面的程序信息国际化。</p>
<p>　　glibc
2.2.2添加了大量非标准的区域设置目录。<code>LC_ADDRESS</code>定义了用于表示邮寄地址的区域设置专属规则。<code>LC_IDENTIFICATION</code>指定区域设置的标识信息。<code>LC_MEASUREMENT</code>定义区域设置的度量系统
(例如，公制与英制)。<code>LC_NAME</code>定义了用于表示人的姓名和头衔的区域设置专属规则。<code>LC_PAPER</code>定义了区域设置的标准纸张大小
(例如，美国等大多数国家/地区使用A4格式)。<code>LC_TELEPHONE</code>定义了用于表示国内和国际电话号码以及国际国家/地区前缀和国际拨出前缀的区域设置专属规则。</p>
<p>　　函数<code>setlocale()</code>可用于设置和查询程序的当前区域设置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">setlocale</span><span class="params">(<span class="type">int</span> category, <span class="type">const</span> <span class="type">char</span> *locale)</span>; <span class="comment">/* 成功时返回标识当前区域设置或新区域设置的字符串 (通常静态分配)，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　参数<code>category</code>表示待设置或查询的区域设置的部分。该参数可以指定为1组常量之一，这些常量的名称与区域设置子目录下的文件名相同。因此，可以将区域设置的时间设置为德国，而货币设置为美元。大多数情况下，该参数都是指定为<code>LC_ALL</code>，表示设置或查询区域设置的所有方面。</p>
<p>　　有2种通过<code>setlocale()</code>设置区域设置的方法。参数<code>locale</code>可以指定为<code>/usr/lib/locale</code>下的子目录名，例如，<code>de_DE</code>或<code>en_US</code>。此外，<code>locale</code>也可以指定为空字符串，表示应该从环境变量中读取区域设置。</p>
<p>　　当在程序中调用<code>setlocale(LC_ALL, "")</code>时，可以通过一组名称为<code>LC_*</code>
(与区域设置子目录下的文件名相同)
的环境变量来控制区域设置的各个方面。或者，使用环境变量<code>LC_ALL</code>或<code>LANG</code>来指定区域设置的各个方面。若设置了多个上述环境变量，则环境变量<code>LC_ALL</code>的优先级最高，<code>LANG</code>的优先级最低。因此，可以使用环境变量<code>LANG</code>来设置区域设置的默认值，然后通过环境变量<code>LC_*</code>来设置区域设置的某些方面。</p>
<p>　　当<code>setlocale()</code>成功时，会返回标识区域设置的指定方面的
(通常静态分配)
字符串。若只需要查询区域设置，则可以将<code>locale</code>指定为<code>NULL</code>。</p>
<p>　　当指定程序使用的区域设置时，指定的就是<code>/usr/share/locale</code>下的子目录名。当程序的区域设置没有对应的区域设置子目录时，<code>setlocale()</code>会去除区域设置中的<span
style="background-color: yellow">字符编码集</span>部分，然后再进行匹配。若依然没有匹配项目，则依次去除<span
style="background-color: yellow">规格化的字符编码集</span>部分、<span
style="background-color: yellow">地区</span>部分和<span
style="background-color: yellow">修饰符</span>部分后再匹配。规格化的字符编码集是经过处理后的字符编码集名称，处理过程包括删除所有字母和数字以外的字符和将所有字母都转换为小写，并且生成的字符串都有前缀<code>iso</code>。</p>
<p>　　假设程序将区域设置指定为<code>fr_CH.utf-8</code>，但没有对应的区域设置子目录，则会先判断区域设置子目录<code>fr_CH</code>是否存在。若<code>fr_CH</code>不存在，则判断区域设置子目录<code>fr</code>是否存在。若<code>fr</code>也不存在，则函数<code>setlocale()</code>会报告错误。</p>
<p>　　文件<code>/usr/share/locale/locale.alias</code>定义了为程序指定区域设置的替代方式，具体详情查看<code>locale.alias</code>的手册。</p>
<p>　　命令<code>locale</code>会显示shell的当前区域设置的相关信息。命令<code>locale -a</code>会列出系统中定义的所有区域设置。</p>
<h3 id="更新系统时钟">10.5 更新系统时钟</h3>
<p>　　系统调用<code>settimeofday()</code>和库函数<code>adjtime()</code>可以更新系统时钟，但它们很少用于应用程序，因为系统时钟通常由<span
style="background-color: yellow">网络时间协议</span> (NTP)
守护进程等工具维护，并且调用它们需要调用者拥有能力<code>CAP_SYS_TIME</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">settimeofday</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timeval *tv, <span class="type">const</span> <span class="keyword">struct</span> timezone *tz)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">adjtime</span><span class="params">(<span class="keyword">struct</span> timeval *delta, <span class="keyword">struct</span> timeval *olddelta)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>settimeofday()</code>的功能与<code>gettimeofday()</code>的相反，它会将系统日历时间设置为参数<code>tv</code>指定的结构体<code>timeval</code>。与<code>gettimeofday()</code>相同，参数<code>tz</code>已过时，应该指定为<code>NULL</code>。</p>
<p>　　结构体<code>timeval</code>的成员<code>tv_usec</code>的精度不代表通过<code>settimeofday()</code>设置的系统时钟拥有同样的精度，因为系统时钟的精度可能没有达到微妙级。</p>
<p>　　由于调用<code>settimeofday()</code>而导致的系统时钟的突然变化可能会对依赖于单调增加的系统时钟的应用程序
(例如，<code>make</code>和使用时间戳或日志使用时间戳的数据库)
产生有害影响。因此，当仅需要对系统时钟进行小幅更改时
(大约几秒)，尽量使用库函数<code>adjtime()</code>，该函数会让系统时间逐渐调整到所需的值。</p>
<p>　　参数<code>delta</code>指向的结构体指定需要将系统时钟修改多少秒和微妙。若<code>delta</code>指向的结构体中的成员是正值，则表示每秒向系统时钟增加少量额外时间，直到达到成员指定的值；若<code>delta</code>指向的结构体中的成员是负值，则以类似的方式减少。对于Linux/x86-32，增加/减少速率是每2000秒增加/减少1秒。</p>
<p>　　当调用<code>adjtime()</code>时最近1次调用<code>adjtime()</code>设置的时间调整未完成，最近1次调用<code>adjtime()</code>设置的时间调整的剩余时间会存储在参数<code>olddelta</code>。若不需要该值，则可以将<code>olddelta</code>指定为<code>NULL</code>。相反，若只需要该值，则可以将<code>delta</code>指定为<code>NULL</code>。</p>
<p>　　SUSv3没有说明<code>settimeofday()</code>和<code>adjtime()</code>，但大部分UNIX实现都提供了它们。</p>
<p>　　Linux还提供了用于更新系统时钟的系统调用<code>stime()</code>。<code>stime()</code>与<code>settimeofday()</code>的区别是<code>stime()</code>的精度只能达到秒级。这2个系统调用得以共存原因是4.3BSD添加了<code>stime()</code>。</p>
<p>　　对于Linux，<code>adjtime()</code>基于更常用的特定于Linux的系统调用<code>adjtimex()</code>，并且NTP守护进程使用了该系统调用。</p>
<h3 id="进程时间">10.6 进程时间</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">times</span><span class="params">(<span class="keyword">struct</span> tms *buf)</span>; <span class="comment">/* 成功时返回自过去 &quot;任意&quot; 时间以来的时钟节拍数，出错时返回(clock_t)-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">clock_t</span> tms_utime;  <span class="comment">/* 调用进程所用的用户CPU时间 */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_stime;  <span class="comment">/* 调用进程所用的系统CPU时间 */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_cutime; <span class="comment">/* 调用进程等待子进程所用的用户CPU时间 (包括tms_utime) */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_cstime; <span class="comment">/* 调用进程等待子进程所用的系统CPU时间 (包括tms_stime) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>times()</code>用于检索进程时间信息，结果存储在参数<code>buf</code>指向的结构体中。</p>
<p>　　参数<code>buf</code>指向的结构体<code>tms</code>的前2个成员是调用进程所用的用户CPU时间和系统CPU时间。第3个成员是调用进程调用<code>wait()</code>等待子进程所用的用户CPU时间
(包括<code>tms_utime</code>)。第4个成员是调用进程调用<code>wait()</code>等待子进程所用的系统CPU时间
(包括<code>tms_stime</code>)。</p>
<p>　　结构体<code>tms</code>的成员的数据类型<code>clock_t</code>是整数类型，它以称为<strong>时钟节拍</strong>的单位测量时间。可以通过调用<code>sysconf(_SC_CLK_TCK)</code>来获取每秒的时钟节拍数，然后用<code>clock_t</code>值除以这个数来获取秒数。</p>
<p>　　若<code>times()</code>成功，则会返回自过去某个时间点以来的时钟节拍数。SUSv3故意没有说明该时间点是什么时候，仅提及该时间点在调用进程的生命周期内是不变的，所以该返回值的唯一可移植的用法是计算2次调用<code>times()</code>得到的返回值的差值。就算如此，<code>times()</code>的返回值仍然是不可靠的，因为返回值值可能会溢出，然后重置到0。测试所用时间的可靠方式是使用<code>gettimeofday()</code>。</p>
<p>　　对于Linux，<code>buf</code>可以指定为<code>NULL</code>。在这种情况下，<code>times()</code>还是会返回时钟节拍数。但是，SUSv3没有说明这种用法，并且很多其他UNIX实现要求<code>buf</code>不能为<code>NULL</code>。</p>
<p>　　对于大多数Linux硬件架构，<code>sysconf(_SC_CLK_TCK)</code>会返回100，与内核常量<code>USER_HZ</code>对应。但是，对于Alpha和IA-64等少部分架构，常量<code>USER_HZ</code>可以定义为100以外的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">clock</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 成功时返回调用进程所用的总CPU时间 (CLOCKS_PER_SEC为单位)，出错时返回(clock_t)-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>clock()</code>会返回调用进程所用的总CPU时间，其单位是<code>CLOCKS_PER_SEC</code>。因此，需要将返回值除以该单位才能得到对应的秒钟。对于POSIX.1，无论软件时钟是多少，<code>CLOCKS_PER_SEC</code>固定为100万。但是，<code>clock()</code>的精度还是受到软件时钟的影响。</p>
<p>　　尽管<code>CLOCKS_PER_SEC</code>固定为100万，但SUSv3规定，该常量在不符合XSI的系统上可以被实现为整数常量
(即<code>1000000L</code>)，而非宏。因此，从可移植性角度，<code>CLOCKS_PER_SEC</code>不是编译时常量
(不能使用条件编译语句<code>ifdef</code>)，并且对其调用<code>printf()</code>前应先将其转换为<code>long</code>。</p>
<p>　　SUSv3规定，<code>clock()</code>应该返回
"进程所用的CPU时间"，这有不同的解释。对于部分UNIX实现，<code>clock()</code>的返回值包括等待子进程所用的CPU时间。对于Linux，<code>clock()</code>的返回值不包括等待子进程所用的CPU时间。</p>
<p>　　<code>clock()</code>和<code>times()</code>的返回值类型都是<code>clock_t</code>，但两者的测量单位不同。这是POSIX.1和C标准对<code>clock_t</code>定义不同而导致的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* process_time.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印msg和进程时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">displayProcessTimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">t</span>;</span></span><br><span class="line">    <span class="type">clock_t</span> clockTime;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> clockTicks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clockTicks == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 第1次调用时记录时钟节拍 */</span></span><br><span class="line">        clockTicks = sysconf(_SC_CLK_TCK);</span><br><span class="line">        <span class="keyword">if</span> (clockTicks == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sysconf&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clockTime = clock();</span><br><span class="line">    <span class="keyword">if</span> (clockTime == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;clock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; clock() returns: %ld clocks-per-sec (%.2f secs)\n&quot;</span>,</span><br><span class="line">           (<span class="type">long</span>)clockTime, (<span class="type">double</span>)clockTime / CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (times(&amp;t) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;times&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; times() yields: user CPU=%.2f; system CPU: %.2f\n&quot;</span>,</span><br><span class="line">           (<span class="type">double</span>)t.tms_utime / clockTicks, (<span class="type">double</span>)t.tms_stime / clockTicks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numCalls, j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CLOCKS_PER_SEC=%ld sysconf(_SC_CLK_TCK)=%ld\n\n&quot;</span>,</span><br><span class="line">           (<span class="type">long</span>)CLOCKS_PER_SEC, sysconf(_SC_CLK_TCK));</span><br><span class="line"></span><br><span class="line">    displayProcessTimes(<span class="string">&quot;At program start:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    numCalls = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;num-calls&quot;</span>) : <span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numCalls; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        (<span class="type">void</span>)getppid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    displayProcessTimes(<span class="string">&quot;After getppid() loop:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了上述函数的用法。函数<code>displayProcessTimes()</code>会打印参数<code>msg</code>并通过<code>clock()</code>和<code>times()</code>获取的进程时间。主函数在开始时会调用1次<code>displayProcessTimes()</code>，在循环完成后会再次调用该函数。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第17章 访问控制列表</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_17/</url>
    <content><![CDATA[<p>　　有时，应用程序需要将权限授予特定的用户或组。为此，很多UNIX系统都实现了<strong>访问控制列表</strong>
(ACL)，作为传统文件权限体系的扩展
(见15.4)。ACL允许为单个用户或组指定权限。Linux从内核2.6开始支持ACL。</p>
<p>　　所有文件系统的ACL都是可选项，由文件系统菜单下的内核配置选项控制。Reiserfs对ACL的支持需要内核2.6.7及以上版本。为了在ext2、ext3、ext4和Reiserfs中创建ACL，通过命令<code>mount</code>挂载这些文件系统时需要使用选项<code>-o acl</code>。</p>
<p>　　每个ACL都包含一系列ACL条目，每个条目都定义了1个用户或1个组的文件权限。每个ACL条目都包含<span
style="background-color: yellow">标签类型</span>、(可选的) <span
style="background-color: yellow">标签限定符</span>和<span
style="background-color: yellow">权限集</span>。</p>
<p>　　● 标签类型表示该条目是应用于用户、组还是其他权限类别。</p>
<p>　　● 标签限定符是用户ID或组ID。</p>
<p>　　● 权限集指定授予该条目的权限 (读、写和执行权限)。</p>
<table>
<thead>
<tr>
<th>标签类型</th>
<th>标签限定符</th>
<th>权限</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ACL_USER_OBJ</code></td>
<td></td>
<td><code>rwx</code></td>
</tr>
<tr>
<td><code>ACL_USER</code></td>
<td><code>1007</code></td>
<td><code>r--</code></td>
</tr>
<tr>
<td><code>ACL_USER</code></td>
<td><code>1010</code></td>
<td><code>rwx</code></td>
</tr>
<tr>
<td><code>ACL_GROUP_OBJ</code></td>
<td></td>
<td><code>rwx</code></td>
</tr>
<tr>
<td><code>ACL_GROUP</code></td>
<td><code>102</code></td>
<td><code>r--</code></td>
</tr>
<tr>
<td><code>ACL_GROUP</code></td>
<td><code>103</code></td>
<td><code>-w-</code></td>
</tr>
<tr>
<td><code>ACL_GROUP</code></td>
<td><code>109</code></td>
<td><code>--x</code></td>
</tr>
<tr>
<td><code>ACL_MASK</code></td>
<td></td>
<td><code>rw-</code></td>
</tr>
<tr>
<td><code>ACL_OTHER</code></td>
<td></td>
<td><code>r--</code></td>
</tr>
</tbody>
</table>
<p>　　标签类型的值只能是<code>ACL_USER_OBJ</code>、<code>ACL_USER</code>、<code>ACL_GROUP_OBJ</code>、<code>ACL_GROUP</code>、<code>ACL_MASK</code>或<code>ACL_OTHER</code>。<strong>组类</strong>是ACL中的所有<code>ACL_USER</code>、<code>ACL_GROUP</code>和<code>ACL_GROUP_OBJ</code>条目的集合。</p>
<p>　　●
<code>ACL_USER_OBJ</code>表示权限授予文件所有者的权限。1个ACL只有1个<code>ACL_USER_OBJ</code>条目。该条目对应传统文件权限体系中的的用户类别权限。</p>
<p>　　●
<code>ACL_USER</code>表示授予标签限定符指定的用户的权限。1个ACL可以有任意个<code>ACL_USER</code>条目，但每个用户最多只能有1个对应的<code>ACL_USER</code>条目。</p>
<p>　　●
<code>ACL_GROUP_OBJ</code>表示授予文件所属组的权限。1个ACL只有1个<code>ACL_GROUP_OBJ</code>条目。该条目对应传统文件权限体系中的的组类别权限，除非ACL也包含<code>ACL_MASK</code>条目。</p>
<p>　　●
<code>ACL_GROUP</code>表示授予标签限定符指定的组的权限。1个ACL可以有任意个<code>ACL_GROUP</code>条目，但每个组最多只能有1个对应的<code>ACL_GROUP</code>条目。</p>
<p>　　●
<code>ACL_MASK</code>表示授予组类的权限的上限。1个ACL最多只能有1个<code>ACL_MASK</code>条目。若ACL中包含<code>ACL_USER</code>或<code>ACL_GROUP</code>条目，则该ACL中必须有<code>ACL_MASK</code>条目；否则，<code>ACL_MASK</code>条目是可选的。</p>
<p>　　●
<code>ACL_OTHER</code>表示授予其他用户的权限。1个ACL只有1个<code>ACL_OTHER</code>条目。该条目对应传统文件权限体系中的的其他类别权限。</p>
<p>　　标签限定符仅适用于<code>ACL_USER</code>和<code>ACL_GROUP</code>条目。</p>
<span id="more"></span>
<p>　　ACL分为<span
style="background-color: yellow">访问ACL</span>和<span
style="background-color: yellow">默认ACL</span>。当进程访问有ACL的文件时，访问ACL决定进程的权限。默认ACL仅适用于目录，目录的默认ACL是否存在决定在该目录下创建的文件和子目录的ACL和权限。Linux将ACL实现为系统扩展属性，访问和默认ACL分别存储为扩展属性<code>system.posix_acl_access</code>和<code>system.posix_acl_default</code>。</p>
<p>　　<span
style="background-color: yellow">最小ACL</span>是等同于传统文件权限集的ACL
(仅包含<code>ACL_USER_OBJ</code>、<code>ACL_GROUP_OBJ</code>和<code>ACL_OTHER</code>条目)。<span
style="background-color: yellow">扩展ACL</span>是包含<code>ACL_USER</code>、<code>ACL_GROUP</code>和<code>ACL_MASK</code>条目的ACL。最小ACL存储为传统文件权限位。</p>
<p>　　ACL从未正式成为UNIX标准的一部分。POSIX.1e草案旨在详细说明ACL
API，POSIX.2c草案旨在详细说明ACL shell命令
(以及能力等其他特性)，但都失败了，并且这些草案被撤回了。尽管如此，很多UNIX实现
(和Linux) 基于这些草案实现了ACL (通常是基于最终版Draft
17)。但是，由于各个ACL实现不同
(部分原因是草案不完整)，开发使用ACL的可移植应用程序有些困难。</p>
<h3 id="acl权限检查算法">17.1 ACL权限检查算法</h3>
<p>　　对有ACL的文件执行的权限检查与传统文件权限模型类似
(见15.4.3)。检查按照如下顺序进行，并且遇到匹配的规则就立即停止：</p>
<p>　　1)
若进程是特权进程，则授予所有权限。但是，存在1个例外，即当执行文件时，需要至少有1个ACL条目授予执行权限，特权进程才会拥有执行权限。</p>
<p>　　2)
若进程的有效用户ID与文件的用户ID匹配，则授予进程<code>ACL_USER_OBJ</code>条目指定的权限
。</p>
<p>　　3)
若进程的有效用户ID与某个<code>ACL_USER</code>条目的标签限定符匹配，则授予进程该<code>ACL_USER</code>条目与<code>ACL_MASK</code>条目进行与操作<code>&amp;</code>得到的权限。</p>
<p>　　4) 若进程的组ID (即有效组ID和辅助组ID)
与文件的组ID匹配，则授予进程<code>ACL_GROUP_OBJ</code>条目指定的权限
(ACL包含<code>ACL_MASK</code>条目时还要与<code>ACL_MASK</code>条目进行与操作<code>&amp;</code>)。</p>
<p>　　5)
若进程的组ID与某个<code>ACL_GROUP</code>条目的标签限定符匹配，则授予进程该<code>ACL_GROUP</code>条目与<code>ACL_MASK</code>条目进行与操作<code>&amp;</code>得到的权限。</p>
<p>　　6) 否则，授予进程<code>ACL_OTHER</code>条目指定的权限。</p>
<h3 id="acl的文本形式">17.2 ACL的文本形式</h3>
<p>　　当通过命令<code>setfacl</code>和<code>getfacl</code>以及相关库函数来控制ACL时，需要指定ACL条目的文本表示。允许的文本表示包括<span
style="background-color: yellow">长文本形式</span>和<span
style="background-color: yellow">短文本形式</span>。</p>
<p>　　● 对于长文本形式的ACL，1行包含1个ACL条目
(和以<code>#</code>开头的注释)。命令<code>getfacl</code>会以长文本形式显示ACL。命令<code>setfacl –M acl-file</code>会从文件中获取长文本形式的ACL规范。</p>
<p>　　● 对于短文本形式的ACL，ACL条目由逗号<code>,</code>分隔。</p>
<p>　　这2种形式的ACL条目都包含3个部分，这3个部分由冒号<code>:</code>分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tag-type:[tag-qualifier]:permissions</span><br></pre></td></tr></table></figure>
<p>　　<code>tag-type</code>部分对应标签类型。<code>tag-qualifier</code>部分是可选的，对应标签限定符，仅适用于<code>ACL_USER</code>和<code>ACL_GROUP</code>条目。<code>permissions</code>部分对应权限集。</p>
<table>
<thead>
<tr>
<th>标签文本形式</th>
<th>标签限定符</th>
<th>对应的标签类型</th>
<th>条目对象</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>u</code>或<code>user</code></td>
<td>✕</td>
<td><code>ACL_USER_OBJ</code></td>
<td>文件所有者</td>
</tr>
<tr>
<td><code>u</code>或<code>user</code></td>
<td>✓</td>
<td><code>ACL_USER</code></td>
<td>指定用户</td>
</tr>
<tr>
<td><code>g</code>或<code>group</code></td>
<td>✕</td>
<td><code>ACL_GROUP_OBJ</code></td>
<td>文件所属组</td>
</tr>
<tr>
<td><code>g</code>或<code>group</code></td>
<td>✓</td>
<td><code>ACL_GROUP</code></td>
<td>指定组</td>
</tr>
<tr>
<td><code>m</code>或<code>mask</code></td>
<td>✕</td>
<td><code>ACL_MASK</code></td>
<td>组类的掩码</td>
</tr>
<tr>
<td><code>o</code>或<code>other</code></td>
<td>✕</td>
<td><code>ACL_OTHER</code></td>
<td>其他用户</td>
</tr>
</tbody>
</table>
<h3 id="acl_mask条目">17.3 <code>ACL_MASK</code>条目</h3>
<p>　　<code>ACL_MASK</code>条目的目的是在运行无法识别ACL的应用程序提供一致的行为。</p>
<p>　　假设某个文件的ACL包含以下条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user::rwx       # ACL_USER_OBJ</span><br><span class="line">user:paulh:r-x  # ACL_USER</span><br><span class="line">group::r-x      # ACL_GROUP_OBJ</span><br><span class="line">group:teach:--x # ACL_GROUP</span><br><span class="line">other::--x      # ACL_OTHER</span><br></pre></td></tr></table></figure>
<p>　　当某个程序对该文件执行命令<code>chmod(pathname, 0700)</code>时
(只有用户类别有该文件的权限)，在没有<code>ACL_MASK</code>条目的情况下，该命令的行为可以通过多种方式实现，但所有实现方式都有问题。</p>
<p>　　●
可以直接修改<code>ACL_GROUP_OBJ</code>和<code>ACL_USER_OBJ</code>条目，但用户<code>paulh</code>和组<code>teach</code>仍然拥有该文件的权限。</p>
<p>　　●
其他实现方式会将新的组类别权限设置和其他权限设置应用到ACL中的所有<code>ACL_USER</code>、<code>ACL_GROUP</code>、<code>ACL_GROUP_OBJ</code>和<code>ACL_OTHER</code>条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user::rwx       # ACL_USER_OBJ</span><br><span class="line">user:paulh:---  # ACL_USER</span><br><span class="line">group::---      # ACL_GROUP_OBJ</span><br><span class="line">group:teach:--- # ACL_GROUP</span><br><span class="line">other::---      # ACL_OTHER</span><br></pre></td></tr></table></figure>
<p>　　这样会导致无法识别ACL的应用程序无意中破坏了由能够识别ACL的应用程序创建的文件权限的语义，因为命令<code>chmod(pathname, 751)</code>不会将ACL的<code>ACL_USER</code>和<code>ACL_GROUP</code>条目恢复到旧值。</p>
<p>　　●
为了避免以上问题，可以通过<code>ACL_GROUP_OBJ</code>条目来限制所有<code>ACL_USER</code>和<code>ACL_GROUP</code>条目
(<code>ACL_GROUP_OBJ</code>条目是所有<code>ACL_USER</code>和<code>ACL_GROUP</code>条目的权限集的父集)
。但是，这与<code>ACL_GROUP_OBJ</code>条目的目的冲突。</p>
<p>　　<code>ACL_MASK</code>条目正是为了解决以上问题。虽然<code>ACL_MASK</code>条目提供了1种在运行无法识别ACL的应用程序时保留ACL信息的方法，但不能保证相反的情况。ACL的存在覆盖了传统操作对组类别权限的影响。例如，若某个文件的ACL的<code>ACL_MASK</code>条目是<code>---</code>，则对该文件执行命令<code>chmod g+rw</code>后，组类别权限不会改变。</p>
<h3 id="命令getfacl和setfacl">17.4
命令<code>getfacl</code>和<code>setfacl</code></h3>
<p>　　对于shell，可以通过命令<code>getfacl</code>来查看文件的ACL。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">umask</span> 022</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> tfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getfacl tfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: tfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: mtk</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: <span class="built_in">users</span></span></span><br><span class="line">user::rw-</span><br><span class="line">group::r--</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure>
<p>　　在命令<code>getfacl</code>的输出中，新创建的文件的ACL是最小ACL。此外，第4~6行显示了文件名和所有权，可以通过选项<code>––omit–header</code>来不显示这些信息。</p>
<p>　　命令<code>setfacl</code>可以修改文件的ACL。</p>
<p>　　● 选项<code>-m</code>会创建新条目或修改已存在的条目。</p>
<p>　　● 选项<code>-R</code>会将特定ACL应用到目录下的所有文件。</p>
<p>　　● 选项<code>-x</code>会删除指定条目。</p>
<p>　　●
选项<code>-b</code>会删除所有扩展ACL条目，仅保留最小ACL条目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">setfacl -m u:paulh:rx,g:teach:x tfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getfacl --omit-header tfile</span></span><br><span class="line">user::rwx</span><br><span class="line">user:paulh:r-x</span><br><span class="line">group::r-x</span><br><span class="line">group:teach:--x</span><br><span class="line">mask::r-x</span><br><span class="line">other::--x</span><br></pre></td></tr></table></figure>
<p>　　根据命令<code>getfacl</code>的输出，可以看出命令<code>setfacl</code>会自动创建<code>ACL_MASK</code>条目。</p>
<p>　　创建了<code>ACL_USER</code>和<code>ACL_GROUP</code>条目后，ACL就变成了扩展ACL。命令<code>ls -l</code>会在传统文件权限掩码后添加1个加号<code>+</code>来表示这种情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">setfacl -m m::x tfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getfacl --omit-header tfile</span></span><br><span class="line">user::rwx</span><br><span class="line">user:paulh:r-x      #effective:--x</span><br><span class="line">group::r-x          #effective:--x</span><br><span class="line">group:teach:--x</span><br><span class="line">mask::--x</span><br><span class="line">other::--x</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l tfile</span></span><br><span class="line">-rwx--x--x+ 1 mtk users 0 Dec 3 15:42 tfile</span><br></pre></td></tr></table></figure>
<p>　　命令<code>ls -l</code>输出的是组类权限与<code>ACL_MASK</code>条目进行与操作<code>&amp;</code>后得到的结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">setfacl -x u:paulh,g:teach tfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getfacl --omit-header tfile</span></span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">mask::r-x</span><br><span class="line">other::--x</span><br></pre></td></tr></table></figure>
<p>　　删除了指定条目后，命令<code>setfacl</code>还会自动将<code>ACL_MASK</code>条目修改为所有组类条目的并集。</p>
<p>　　为了查看和设置目录的默认ACL，可以在使用命令<code>getfacl</code>和<code>setfacl</code>时带有选项<code>-d</code>。目录的默认ACL可以通过命令<code>setfacl –k</code>删除。</p>
<h3 id="默认acl和文件创建">17.5 默认ACL和文件创建</h3>
<p>　　若目录有默认ACL，则会出现以下情况：</p>
<p>　　●
该目录下新创建的子目录会继承该目录的默认ACL，作为自己的默认ACL。</p>
<p>　　●
该目录下新创建的子目录和文件会继承该目录的默认ACL，作为自己的访问ACL。与传统文件权限位对应的ACL条目会受限于创建子目录或文件的系统调用
(例如，<code>open()</code>和<code>mkdir</code>)
的参数<code>mode</code>，这些ACL条目包括<code>ACL_USER_OBJ</code>、<code>ACL_MASK</code>
(若没有<code>ACL_MASK</code>，则包括<code>ACL_GROUP_OBJ</code>)
和<code>ACL_OTHER</code>。</p>
<p>　　当目录有默认ACL后，进程的umask (见15.4.6)
将不会参与决定该目录下新创建的文件的访问ACL条目的权限。</p>
<p>　　若目录没有默认ACL，则会出现以下情况：</p>
<p>　　● 该目录下新创建的子目录不会有默认ACL。</p>
<p>　　●
该目录下新创建的子目录和文件遵循传统规则，即文件权限设置为<code>open()</code>和<code>mkdir()</code>等系统调用的参数<code>mode</code>的指定的权限减去umask指定的权限得到的结果，这会导致新文件的ACL是最小ACL。</p>
<h3 id="acl实现限制">17.6 ACL实现限制</h3>
<p>　　各种文件系统实现对ACL中的条目数施加了限制：</p>
<p>　　●
对于ext2、ext3和ext4，因为与文件关联的所有扩展属性的名称和值的总字节数不大于单个逻辑磁盘块的大小，并且每个ACL条目需要8字节，所以ACL中的条目数小于块大小的<span
class="math inline">\(\frac{1}{8}\)</span>
(ACL对应的扩展属性名占用了部分空间)，4096字节的块最多可以容纳大约500个ACL条目
(2.6.11之前的内核要求ext2和ext3的ACL的条目数上限是32)。</p>
<p>　　● 对于XFS，ACL的条目数上限是25。</p>
<p>　　●
对于Reiserfs和JFS，ACL最多可以容纳8191个条目，因为VFS要求扩展属性的值不大于64KB。</p>
<p>　　尽管以上文件系统允许ACL容纳更多的条目，但应该尽量避免这样，原因如下：</p>
<p>　　● 维护条目过多的ACL是1项复杂且容易出错的系统管理任务。</p>
<p>　　● 扫描ACL来匹配条目所需的时间随着ACL条目的增加而线性增加。</p>
<p>　　通常，可以通过在系统组文件中定义合适的组并在ACL中使用这些组来将文件的ACL条目维持在合理的数量。</p>
<h3 id="acl-api">17.7 ACL API</h3>
<p>　　POSIX.1e草案定义了大量用于控制ACL的函数和数据结构。由于它们数量巨大，这里只会介绍部分函数。</p>
<p>　　使用ACL
API的程序需要引用头文件<code>sys/acl.h</code>。若程序使用了基于POSIX.1e草案的Linux扩展，则可能还需要引用头文件<code>acl/libacl.h</code>，并且在编译时需要带有选项<code>-lacl</code>
(链接库libacl)。</p>
<p>　　对于Linux，ACL API被实现为控制用户空间数据结构的1组库函数
(必要时会调用<code>getxattr()</code>和<code>setxattr()</code>来检索和修改位于磁盘的存储ACL表示的系统扩展属性)。有时，应用程序会通过<code>getxattr()</code>和<code>setxattr()</code>来直接控制ACL。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_17/relationship_between_acl_library_functions_and_data_structures.svg" class="">
<p>　　在大多数情况下，返回值是整数 (状态)
的函数会在成功时返回0，出错时返回-1。返回值是句柄 (指针)
的函数会在出错时返回<code>NULL</code>。错误可以通过<code>errno</code>诊断。</p>
<p>　　<span
style="background-color: yellow">句柄</span>是用于引用对象或数据结构的某种技术的抽象术语。句柄的表示对API实现私有的
(例如，它可能是数组索引或散列值)。</p>
<h4 id="将文件的acl提取到内存和更新文件的acl">17.7.1
将文件的ACL提取到内存和更新文件的ACL</h4>
<p>　　函数<code>acl_get_file()</code>会检索参数<code>pathname</code>指定的文件的ACL副本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">acl_t</span> acl;</span><br><span class="line">acl = acl_get_file(pathname, type);</span><br></pre></td></tr></table></figure>
<p>　　该函数可以检索访问或默认ACL，取决于参数<code>type</code>是<code>ACL_TYPE_ACCESS</code>还是<code>ACL_TYPE_DEFAULT</code>。作为结果，<code>acl_get_file()</code>会返回可用于其他ACL函数的句柄
(或<code>acl_t</code>)。</p>
<p>　　函数<code>acl_set_file()</code>与<code>acl_get_file()</code>相反，它会用参数<code>acl</code>指定的位于内存的ACL的内容来更新位于磁盘的ACL。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> status;</span><br><span class="line">status = acl_set_file(pathname, type, acl);</span><br></pre></td></tr></table></figure>
<p>　　参数<code>type</code>可以是<code>ACL_TYPE_ACCESS</code>
(更新访问ACL) 或<code>ACL_TYPE_DEFAULT</code> (更新目录的默认ACL)。</p>
<h4 id="检索内存中的acl条目">17.7.2 检索内存中的ACL条目</h4>
<p>　　函数<code>acl_get_entry()</code>会检索单个位于内存的ACL条目，结果是句柄。该句柄引用参数<code>acl</code>指定的位于内存的ACL条目，并且存储在最后1个参数指向的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">acl_entry_t</span> entry;</span><br><span class="line">status = acl_get_entry(acl, entry_id, &amp;entry);</span><br></pre></td></tr></table></figure>
<p>　　参数<code>entry_id</code>表示目标条目。若将<code>entry_id</code>指定为<code>ACL_FIRST_ENTRY</code>，则会检索第1个条目；若将<code>entry_id</code>指定为<code>ACL_NEXT_ENTRY</code>，则会检索上一次检索的条目的下一个条目。因此，可以在第1次调用<code>acl_get_entry()</code>时将<code>entry_id</code>指定为<code>ACL_FIRST_ENTRY</code>，后续调用时将<code>entry_id</code>指定为<code>ACL_NEXT_ENTRY</code>，以遍历ACL的所有条目。</p>
<p>　　若<code>acl_get_entry()</code>成功检索1个ACL条目，则返回0；若没有检索到ACL条目或出错，则返回-1。</p>
<h4 id="检索和修改acl条目的属性">17.7.3 检索和修改ACL条目的属性</h4>
<p>　　函数<code>acl_get_tag_type()</code>和<code>acl_set_tag_type()</code>会检索和修改参数<code>entry</code>指定的ALC条目的标签类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">acl_tag_t</span> tag_type;</span><br><span class="line">status = acl_get_tag_type(entry, &amp;tag_type);</span><br><span class="line">status = acl_set_tag_type(entry, tag_type);</span><br></pre></td></tr></table></figure>
<p>　　参数<code>tag_type</code>的数据类型<code>acl_type_t</code>是整数类型，其值只能是<code>ACL_USER_OBJ</code>、<code>ACL_USER</code>、<code>ACL_GROUP_OBJ</code>、<code>ACL_GROUP</code>、<code>ACL_OTHER</code>或<code>ACL_MASK</code>。</p>
<p>　　函数<code>acl_get_qualifier()</code>和<code>acl_set_qualifier()</code>会检索和修改参数<code>entry</code>指定的ALC条目的标签限定符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uid_t</span> *qualp;</span><br><span class="line">qualp = acl_get_qualifier(entry);</span><br><span class="line">status = acl_set_qualifier(entry, qualp);</span><br></pre></td></tr></table></figure>
<p>　　只有条目是<code>ACL_USER</code>或<code>ACL_GROUP</code>条目时，标签限定符才有效。对于<code>ACL_USER</code>条目，参数<code>qualp</code>是指向用户ID的指针
(即<code>uid_t *</code>)。对于<code>ACL_GROUP</code>条目，参数<code>qualp</code>是指向组ID的指针
(即<code>gid_t *</code>)。</p>
<p>　　函数<code>acl_get_permset()</code>和<code>acl_set_permset()</code>会检索和修改参数<code>entry</code>指定的ALC条目的权限集。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">acl_permset_t</span> permset;</span><br><span class="line">status = acl_get_permset(entry, &amp;permset);</span><br><span class="line">status = acl_set_permset(entry, permset);</span><br></pre></td></tr></table></figure>
<p>　　数据类型<code>acl_permset_t</code>是引用权限集的句柄。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> is_set;</span><br><span class="line">is_set = acl_get_perm(permset, perm);</span><br><span class="line">status = acl_add_perm(permset, perm);</span><br><span class="line">status = acl_delete_perm(permset, perm);</span><br><span class="line">status = acl_clear_perms(permset);</span><br></pre></td></tr></table></figure>
<p>　　函数<code>acl_get_perm()</code>、<code>acl_add_perm()</code>、<code>acl_delete_perm()</code>和<code>acl_clear_perms()</code>可用于检索和控制权限集。参数<code>perm</code>只能指定为<code>ACL_READ</code>、<code>ACL_WRITE</code>或<code>ACL_EXECUTE</code>。</p>
<p>　　●
对于函数<code>acl_get_perm()</code>，若<code>permset</code>指定的权限集包含<code>perm</code>指定的权限，则返回1；否则，返回0。该函数是基于POSIX.1e草案的Linux扩展。</p>
<p>　　●
函数<code>acl_add_perm()</code>会将<code>perm</code>指定的权限添加到<code>permset</code>指定的权限集。</p>
<p>　　●
函数<code>acl_delete_perm()</code>会从<code>permset</code>指定的权限集中删除<code>perm</code>指定的权限
(权限集中没有待删除的权限不会导致错误)。</p>
<p>　　●
函数<code>acl_clear_perms()</code>会清空<code>permset</code>指定的权限集。</p>
<h4 id="创建和删除acl条目">17.7.4 创建和删除ACL条目</h4>
<p>　　函数<code>acl_create_entry()</code>会在ALC中创建1个新条目。引用新条目的句柄会存储在第2个参数指向的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">acl_entry_t</span> entry;</span><br><span class="line">status = acl_create_entry(&amp;acl, &amp;entry);</span><br></pre></td></tr></table></figure>
<p>　　函数<code>acl_delete_entry()</code>会从ACL中删除1个条目。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">status = acl_delete_entry(acl, entry);</span><br></pre></td></tr></table></figure>
<h4 id="内存中的acl与文本形式acl之间的转换">17.7.5
内存中的ACL与文本形式ACL之间的转换</h4>
<p>　　函数<code>acl_from_text()</code>会将长文本形式或短文本形式的ACL转换为内存中的ACL，并且返回可用于其他ACL函数的句柄。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acl = acl_from_text(acl_string);</span><br></pre></td></tr></table></figure>
<p>　　函数<code>acl_to_text()</code>与<code>acl_from_text()</code>相反，返回与参数<code>acl</code>指定的ACL对应的长文本形式字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str;</span><br><span class="line"><span class="type">ssize_t</span> len;</span><br><span class="line">str = acl_to_text(acl, &amp;len);</span><br></pre></td></tr></table></figure>
<p>　　若参数<code>len</code>是0，则该参数会存储结果字符串的长度。</p>
<h4 id="acl-api中的其他函数">17.7.6 ACL API中的其他函数</h4>
<p>　　函数<code>acl_calc_mask(&amp;acl)</code>会计算和设置参数指向的位于内存的ACL的<code>ACL_MASK</code>条目的权限，通常会在创建或修改ACL时使用该函数。<code>ACL_MASK</code>条目的权限计算为所有<code>ACL_USER</code>、<code>ACL_GROUP</code>和<code>ACL_GROUP_OBJ</code>条目的权限的并集。此外，该函数会在<code>ACL_MASK</code>条目不存在时创建。</p>
<p>　　对于函数<code>acl_valid(acl)</code>，若参数指定的ACL有效，则返回0；否则，返回-1。有效的ACL需要满足以下条件：</p>
<p>　　●
<code>ACL_USER_OBJ</code>、<code>ACL_GROUP_OBJ</code>和<code>ACL_OTHER</code>条目都只有1个。</p>
<p>　　●
若存在<code>ACL_USER</code>或<code>ACL_GROUP</code>条目，则有1个<code>ACL_MASK</code>条目；否则，没有<code>ACL_MASK</code>条目。</p>
<p>　　● 所有<code>ACL_USER</code>条目都对应唯一的用户ID。</p>
<p>　　● 所有<code>ACL_GROUP</code>条目都对应唯一的组ID。</p>
<p>　　函数<code>acl_check()</code>和<code>acl_error()</code>
(后者是Linux扩展)
是<code>acl_valid()</code>的替代函数，这2个函数的可移植性更差，但对ACL的无效原因提供了更详细的描述。</p>
<p>　　函数<code>acl_delete_def_file(pathname)</code>会删除参数<code>pathname</code>指定的目录的默认ACL。</p>
<p>　　函数<code>acl_init(count)</code>会创建1个至少可以容纳<code>count</code>个ACL条目的空ACL结构体
(参数<code>count</code>只是向系统提供相关预期用途的提示，并非限制)，并且返回新ACL的句柄。</p>
<p>　　函数<code>acl_dup(acl)</code>会复制参数<code>acl</code>指定的ACL，并且返回复制的ACL的句柄。</p>
<p>　　函数<code>acl_free(obj_p)</code>会释放参数<code>obj_p</code>指向的ACL数据结构的任何可释放的内存
(通常会使用该函数来释放<code>acl_from_text()</code>、<code>acl_to_text()</code>、<code>acl_get_file()</code>、<code>acl_init()</code>和<code>acl_dup()</code>分配的内存)。</p>
<h4 id="示例程序">17.7.7 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* acl_view.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;acl/libacl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/acl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usageError</span><span class="params">(<span class="type">char</span> *progName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [-d] filename\n&quot;</span>, progName);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">acl_t</span> acl;</span><br><span class="line">    <span class="type">acl_type_t</span> type;</span><br><span class="line">    <span class="type">acl_entry_t</span> entry;</span><br><span class="line">    <span class="type">acl_tag_t</span> tag;</span><br><span class="line">    <span class="type">uid_t</span> *uidp;</span><br><span class="line">    <span class="type">gid_t</span> *gidp;</span><br><span class="line">    <span class="type">acl_permset_t</span> permset;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> entryId, permVal, opt;</span><br><span class="line"></span><br><span class="line">    type = ACL_TYPE_ACCESS;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;d&quot;</span>)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            type = ACL_TYPE_DEFAULT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            usageError(argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optind + <span class="number">1</span> != argc)</span><br><span class="line">    &#123;</span><br><span class="line">        usageError(argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    acl = acl_get_file(argv[optind], type);</span><br><span class="line">    <span class="keyword">if</span> (acl == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;acl_get_file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历ACL的所有条目 */</span></span><br><span class="line">    <span class="keyword">for</span> (entryId = ACL_FIRST_ENTRY;; entryId = ACL_NEXT_ENTRY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (acl_get_entry(acl, entryId, &amp;entry) != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 没有ACL条目或出错时退出 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 检索和打印标签类型 */</span></span><br><span class="line">        <span class="keyword">if</span> (acl_get_tag_type(entry, &amp;tag) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;acl_get_tag_type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-12s&quot;</span>, (tag == ACL_USER_OBJ)    ? <span class="string">&quot;user_obj&quot;</span></span><br><span class="line">                        : (tag == ACL_USER)      ? <span class="string">&quot;user&quot;</span></span><br><span class="line">                        : (tag == ACL_GROUP_OBJ) ? <span class="string">&quot;group_obj&quot;</span></span><br><span class="line">                        : (tag == ACL_GROUP)     ? <span class="string">&quot;group&quot;</span></span><br><span class="line">                        : (tag == ACL_MASK)      ? <span class="string">&quot;mask&quot;</span></span><br><span class="line">                        : (tag == ACL_OTHER)     ? <span class="string">&quot;other&quot;</span></span><br><span class="line">                                                 : <span class="string">&quot;???&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 检索和打印标签限定符 */</span></span><br><span class="line">        <span class="keyword">if</span> (tag == ACL_USER)</span><br><span class="line">        &#123;</span><br><span class="line">            uidp = acl_get_qualifier(entry);</span><br><span class="line">            <span class="keyword">if</span> (uidp == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;acl_get_qualifier&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            name = groupNameFromId(*uidp);</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%-8d &quot;</span>, *uidp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%-8s &quot;</span>, name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (acl_free(uidp) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;acl_free&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tag == ACL_GROUP)</span><br><span class="line">        &#123;</span><br><span class="line">            gidp = acl_get_qualifier(entry);</span><br><span class="line">            <span class="keyword">if</span> (gidp == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;acl_get_qualifier&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            name = groupNameFromId(*gidp);</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%-8d &quot;</span>, *gidp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%-8s &quot;</span>, name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (acl_free(gidp) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;acl_free&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 检索和打印权限集 */</span></span><br><span class="line">        <span class="keyword">if</span> (acl_get_permset(entry, &amp;permset) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;acl_get_permset&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        permVal = acl_get_perm(permset, ACL_READ);</span><br><span class="line">        <span class="keyword">if</span> (permVal == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;acl_get_perm - ACL_READ&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (permVal == <span class="number">1</span>) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        permVal = acl_get_perm(permset, ACL_WRITE);</span><br><span class="line">        <span class="keyword">if</span> (permVal == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;acl_get_perm - ACL_WRITE&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (permVal == <span class="number">1</span>) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        permVal = acl_get_perm(permset, ACL_EXECUTE);</span><br><span class="line">        <span class="keyword">if</span> (permVal == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;acl_get_perm - ACL_EXECUTE&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (permVal == <span class="number">1</span>) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acl_free(acl) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;acl_free&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了部分ACL库函数的用法。该程序会检索和打印文件的ACL
(提供了命令<code>getfacl</code>的功能的子集)。若指定了选项<code>-d</code>，则会打印默认ACL，而非访问ACL。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第16章 扩展属性</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_16/</url>
    <content><![CDATA[<p>　　<strong>扩展属性</strong> (EA)
允许以名称-值对的形式将任意元数据与文件i-node关联。1个i-node可以关联多个EA。EA于版本2.6添加到Linux。</p>
<p>　　EA用于实现访问控制列表和文件能力。但是，EA的设计很通用，足以用于其他目的。例如，EA可用于记录文件版本号
(关于文件的MIME类型或字符集的信息) 和指向图标的指针。</p>
<p>　　SUSv3没有说明EA，但有些UNIX实现提供了类似的特性
(特别是现代BSD和Solaris 9及以上版本)。</p>
<p>　　EA需要底层文件系统的支持，Btrfs、ext2、ext3、ext4、JFS、Reiserfs和XFS支持EA。但是，这些文件系统对EA的支持都是可选的，由文件系统菜单下的内核配置选项控制。Reiserfs对EA的支持需要Linux
2.6.7及以上版本。</p>
<p>　　EA的名称格式为<code>namespace.name</code>。命名空间部分用于将EA划分为功能不同的类，名称部分用于区分属于相同命名空间的EA。命名空间的值只能是<code>user</code>、<code>trusted</code>、<code>system</code>或<code>security</code>，分别对应<span
style="background-color: yellow">用户EA</span>、<span
style="background-color: yellow">受信任的EA</span>、<span
style="background-color: yellow">系统EA</span>和<span
style="background-color: yellow">安全EA</span>。</p>
<p>　　● 用户EA可以由非特权进程控制，受限于文件权限检查
(检索用户EA的值需要文件的读权限，修改用户EA的值需要写权限，没有所需的权限会导致错误<code>EACCES</code>)。为了将用户EA与文件系统ext2、ext3、ext4或Reiserfs中的文件关联，底层文件系统通过命令<code>mount</code>挂载时必须带有选项<code>user_xattr</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount -o user_xattr device directory</span></span><br></pre></td></tr></table></figure>
<p>　　● 受信任的EA只能由特权进程 (能力<code>CAP_SYS_ADMIN</code>)
控制。</p>
<p>　　●
系统EA由内核控制，用于将系统对象与文件关联。目前，只有访问控制列表支持该操作。</p>
<p>　　●
安全EA用于为操作系统安全模块存储文件安全标签和将能力与可执行文件关联。安全EA最初旨在支持安全增强型Linux
(SELinux)。</p>
<p>　　对于<code>user</code>和<code>trusted</code>命名空间，EA名称可以是任意字符串。对于<code>system</code>命名空间，EA名称只能是内核显式允许的名称
(例如，用于访问控制列表的名称)。</p>
<p>　　JFS支持命名空间<code>os2</code>，其他文件系统都不支持该命名空间。提供<code>os2</code>命名空间是为了支持遗留的OS/2文件系统的EA。创建<code>os2</code>命名空间的EA无需特权。</p>
<span id="more"></span>
<p>　　可以通过命令<code>setfattr</code>和<code>getfattr</code>来设置和查看与文件关联的EA。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> tfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">setfattr -n user.x -v <span class="string">&quot;The past is not dead.&quot;</span> tfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">setfattr -n user.y -v <span class="string">&quot;In fact, it&#x27;s not past.&quot;</span> tfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getfattr -n user.x tfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file:tile</span></span><br><span class="line">user.x=&quot;The past is not dead.&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getfattr -d tfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file:tile</span></span><br><span class="line">user.x=&quot;The past is not dead.&quot;</span><br><span class="line">user.y=&quot;In fact, it&#x27;s not even past.&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">setfattr -n user.x tfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getfattr -d tfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: tfile</span></span><br><span class="line">user.x</span><br><span class="line">user.y=&quot;In fact, it&#x27;s not even past.&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">setfattr -x user.y tfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getfattr -d tfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: tfile</span></span><br><span class="line">user.x</span><br></pre></td></tr></table></figure>
<p>　　第2行的命令会创建单个EA。第4行的命令会检索单个EA的值。第8行的命令会列出与文件关联的所有用户EA。第13行的命令会将指定EA的值修改为空字符串。第19行的命令会删除指定EA。</p>
<p>　　命令<code>getfattr</code>默认只会列出与文件关联的用户EA的值。选项<code>-m</code>可用于指定待显示的EA名称的正则表达式
(<code>pattern</code>的默认值是<code>^user\.</code>)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getfattr -m <span class="string">&#x27;pattern&#x27;</span> file</span></span><br></pre></td></tr></table></figure>
<p>　　可以使用以下命令来列出与文件关联的所有EA：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getfattr -m - file</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展属性实现细节">16.1 扩展属性实现细节</h3>
<p>　　用户EA只能与文件或目录关联，无法与其他类型的文件的关联，原因如下：</p>
<p>　　● 对于符号链接，所有用户都拥有所有权限，并且无法修改
(对于Linux，符号链接的权限没有任何意义)。这表示这些权限不能防止用户将用户EA与符号链接关联，这个问题的解决方法就是禁止所有用户将用户EA与符号链接关联。</p>
<p>　　●
对于设备文件、套接字和有名管道，权限用于对底层对象执行I/O，通过控制权限来控制用户EA的创建与该目的冲突。</p>
<p>　　此外，非特权进程无法将用户EA与其他用户所有的启用了粘滞位的目录关联，这是为了防止用户将用户EA与<code>/tmp</code>等公共可写且启用了粘滞位的目录关联。</p>
<p>　　Linux VFS对所有文件系统的EA做出了以下限制：</p>
<p>　　● EA名最多包含255个字符。</p>
<p>　　● EA值最大为64KB。</p>
<p>　　此外，有些文件系统对与文件关联的EA的大小和数量做出了更严格的限制：</p>
<p>　　●
对于ext2、ext3和ext4，与文件关联的所有EA的名称和值的总字节数不大于单个逻辑磁盘块的大小
(1024、2048和4096字节)。</p>
<p>　　●
对于JFS，与文件关联的所有EA的名称和值的总字节数上限是128KB。</p>
<h3 id="控制扩展属性的系统调用">16.2 控制扩展属性的系统调用</h3>
<h4 id="创建和修改ea">16.2.1 创建和修改EA</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setxattr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> size, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lsetxattr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> size, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetxattr</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">void</span> *value, <span class="type">size_t</span> size, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>setxattr()</code>、<code>lsetxattr()</code>和<code>fsetxattr()</code>都会将指定EA设置为指定值，这3个系统调用的区别是指定文件的方式。</p>
<p>　　● <code>setxattr()</code>通过路径名 (参数<code>pathname</code>)
指定文件，并且当路径名是符号链接时，会解引用。</p>
<p>　　●
<code>lsetxattr()</code>与<code>setxattr()</code>类似，但不会对符号链接解引用。</p>
<p>　　● <code>fsetxattr()</code>通过打开的文件描述符
(参数<code>fd</code>) 指定文件。</p>
<p>　　参数<code>name</code>是EA名称字符串
(以字符<code>\0</code>结尾)。EA的新值存储在参数<code>value</code>指向的缓冲区中，该缓冲区的大小由参数<code>size</code>指定。</p>
<p>　　在默认情况下，若<code>name</code>指定的EA不存在，则这3个系统调用会创建；若存在，则会将其值修改为<code>value</code>指定的值。参数<code>flags</code>可以控制这些行为，其值可以为0
(默认行为)、<code>XATTR_CREATE</code>
(若<code>name</code>指定的EA存在，则会导致错误<code>EEXIST</code>)
或<code>XATTR_REPLACE</code>
(若<code>name</code>指定的EA不存在，则会导致错误<code>ENODATA</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *value = <span class="string">&quot;The past is not dead.&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (setxattr(pathname, <span class="string">&quot;user.x&quot;</span>, value, <span class="built_in">strlen</span>(value), <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;setxattr&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>setxattr()</code>的用法。</p>
<h4 id="检索ea的值">16.2.2 检索EA的值</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回EA值的长度 (非负)，出错时返回-1 */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">getxattr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *value, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">lgetxattr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *value, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">fgetxattr</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *value, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getxattr()</code>、<code>lgetxattr()</code>和<code>fgetxattr()</code>会检索EA的值。这3个系统调用的区别与<code>setxattr()</code>、<code>lsetxattr()</code>和<code>fsetxattr()</code>的区别相同。</p>
<p>　　参数<code>name</code>是待检索的EA的名称字符串
(以字符<code>\0</code>结尾)。检索结果存储在参数<code>value</code>指向的缓冲区中，该缓冲区必须由调用者分配，并且大小由参数<code>size</code>指定。</p>
<p>　　这3个系统调用成功时都会将检索结果的长度复制给<code>size</code>。</p>
<p>　　若与文件的关联EA中没有名为<code>name</code>的EA，则会导致错误<code>ENODATA</code>；若<code>size</code>太小，则会导致错误<code>ERANGE</code>。</p>
<p>　　<code>size</code>可以指定为0。此时，检索结果不会存储在<code>value</code>指向的缓冲区中，但<code>size</code>还是会包含检索结果的长度。</p>
<h4 id="删除ea">16.2.3 删除EA</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removexattr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lremovexattr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fremovexattr</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>removexattr()</code>、<code>lremovexattr()</code>和<code>fremovexattr()</code>会删除指定EA。这3个系统调用的区别与<code>setxattr()</code>、<code>lsetxattr()</code>和<code>fsetxattr()</code>的区别相同。</p>
<p>　　参数<code>name</code>是待删除的EA的名称字符串
(以字符<code>\0</code>结尾)。</p>
<p>　　若指定的EA不存在，则会导致错误<code>ENODATA</code>。</p>
<h4 id="检索与文件关联的所有ea的名称">16.2.4
检索与文件关联的所有EA的名称</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回复制到list的字节数，出错时返回-1 */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">listxattr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="built_in">list</span>, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">llistxattr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="built_in">list</span>, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">flistxattr</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *<span class="built_in">list</span>, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>listxattr()</code>、<code>llistxattr()</code>和<code>flistxattr()</code>用于检索与文件关联的所有EA的名称。这3个系统调用的区别与<code>setxattr()</code>、<code>lsetxattr()</code>和<code>fsetxattr()</code>的区别相同。</p>
<p>　　检索结果作为一系列以字符<code>\0</code>结尾的字符串返回在参数<code>list</code>指向的缓冲区中，该缓冲区的大小由参数<code>size</code>指定。</p>
<p>　　与<code>getxattr()</code>等系统调用相同，这3个系统调用的<code>size</code>也能指定为0。此时，检索结果不会存储在<code>list</code>指向的缓冲区中，但<code>size</code>还是会包含检索结果的长度。</p>
<p>　　调用这3个系统调用仅需要能够访问文件
(<code>pathname</code>中的所有目录的执行权限)，不需要文件本身的任何权限。</p>
<p>　　出于安全原因，<code>list</code>返回的EA名<span
style="background-color: yellow">可能不包含</span>调用进程无权访问的EA。对于大多数文件系统，当非特权进程调用这3个系统调用时，<code>list</code>返回的EA名不会包含受信任的EA的名称，但并非所有文件系统都是如此。因此，当对<code>list</code>中的EA名调用<code>getxattr()</code>等系统调用时，可能会由于没有特权而出错
(另一种可能是在此期间其他进程删除了该EA)。</p>
<h4 id="示例程序">16.2.5 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* xattr_view.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XATTR_SIZE 10000</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usageError</span><span class="params">(<span class="type">char</span> *progName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [-x] file...\n&quot;</span>, progName);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">list</span>[XATTR_SIZE], value[XATTR_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> listLen, valueLen;</span><br><span class="line">    <span class="type">int</span> ns, j, k, opt;</span><br><span class="line">    Boolean hexDisplay;</span><br><span class="line"></span><br><span class="line">    hexDisplay = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;x&quot;</span>)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">            hexDisplay = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            usageError(argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optind &gt;= argc + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageError(argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = optind; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        listLen = listxattr(argv[j], <span class="built_in">list</span>, XATTR_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (listLen == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;listxattr&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, argv[j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 循环所有EA，打印名称和值 */</span></span><br><span class="line">        <span class="keyword">for</span> (ns = <span class="number">0</span>; ns &lt; listLen; ns += <span class="built_in">strlen</span>(&amp;<span class="built_in">list</span>[ns]) + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    name=%s; &quot;</span>, &amp;<span class="built_in">list</span>[ns]);</span><br><span class="line"></span><br><span class="line">            valueLen = getxattr(argv[j], &amp;<span class="built_in">list</span>[ns], value, XATTR_SIZE);</span><br><span class="line">            <span class="keyword">if</span> (valueLen == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;couldn&#x27;t get value&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!hexDisplay)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;value=%.*s&quot;</span>, (<span class="type">int</span>)valueLen, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;value=&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; valueLen; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)value[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会检索和显示与通过命令行参数指定的文件关联的所有EA的名称和值。对于每个文件，程序都会调用<code>listxattr()</code>来检索与该文件关联的EA的名称，然后循环遍历这些EA，每次循环都通过调用<code>getxattr()</code>来检索对应的值。在默认情况下，EA值以文本形式显示。若指定命令行选项<code>-x</code>，则EA值会以十六进制显示。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第14章 文件系统</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/</url>
    <content><![CDATA[<p>　　<strong>文件系统</strong>是常规文件和目录的有组织的集合。可以通过命令<code>mkfs</code>来创建文件系统。</p>
<p>　　支持多种文件系统是Linux的优势之一，包括传统的ext2文件系统、各种原生UNIX文件系统
(例如，Minix、System V和BSD文件系统)、Microsoft的文件系统
(FAT、FAT2和NTFS)、ISO 9660 CD-ROM文件系统、Apple
Macintosh的HFS、网络文件系统
(例如，Sun的NFS、IBM和Microsoft的SMB、Novell的NCP和卡内基梅隆大学开发的Coda文件系统)
以及日志文件系统 (包括ext3、ext4、Reiserfs、JFS、XFS和Btrfs)。</p>
<p>　　内核当前已知的文件系统可以通过特定于Linux的文件<code>/proc/filesystems</code>获取。</p>
<p>　　Linux 2.6.14添加了<span
style="background-color: yellow">用户空间文件系统</span>功能，该机制向内核添加了hook，允许文件系统完全通过用户空间程序实现
(无需为内核应用补丁或重新编译内核)。</p>
<p>　　多年来，Linux上使用最广泛的文件系统是ext2，它是原始Linux文件系统ext的后继者。ext2文件系统的开发者是Remy
Card。它的源码很短
(大约5000行C代码)，构成了其他几个文件系统实现的模型。近年来，ext2的使用率有所下降，取而代之的是各种日志文件系统。</p>
<h3 id="设备">14.1 设备</h3>
<p>　　<strong>设备特殊文件</strong>与系统上的设备对应。在内核中，每个设备类型都有1个对应的设备驱动程序，<strong>设备驱动程序</strong>是用于实现一组操作的内核代码单元，这些操作
(通常)
对应关联硬件上的输入和输出行为。设备驱动程序提供的API是固定的，并且其中包括与系统调用<code>open()</code>、<code>close()</code>、<code>read()</code>、<code>write()</code>、<code>mmap()</code>和<code>ioctl()</code>相对应的操作。所有设备驱动程序提供的接口都是一致的，隐藏了各个设备的操作之间的差异，从而实现I/O的通用性。</p>
<p>　　设备特殊文件分为<strong>字符设备</strong>和<strong>块设备</strong>。字符设备逐字符处理数据
(例如，终端和键盘)。块设备每次处理1个数据块
(例如，磁盘和磁带驱动器)，块大小取决于设备类型，通常是512字节的整数倍。</p>
<p>　　设备文件在文件系统中的形式与其他文件相似，通常位于目录<code>/dev</code>下。超级用户可以通过命令<code>mknod</code>来创建设备文件，特权程序
(能力<code>CAP_MKNOD</code>)
也可以通过系统调用<code>mknod()</code>来执行相同的任务。</p>
<p>　　系统调用<code>mknod()</code> (make file-system i-node)
的用法简单，并且现在只有在创建设备文件时才会使用该系统调用，所以这里不进行详细介绍。<code>mknod()</code>也能用于创建有名管道，但函数<code>mkfifo()</code>是这项任务的首选方法。从历史角度，有些UNIX实现也通过<code>mknod()</code>来创建目录，但如今这种用法已经被系统调用<code>mkdir()</code>所取代。尽管如此，部分UNIX实现还是保留了该特性来保证向后兼容性。</p>
<p>　　对于Linux早期版本，目录<code>/dev</code>包含系统中所有可能的设备的条目
(即使有些设备未连接到系统)，这表示该目录可能包含数千个未使用的条目，从而减慢了程序扫描该目录的速度，并且无法通过该目录下的条目来确定实际连接到系统的设备。Linux
2.6添加了程序<code>udev</code>来解决这些问题，该程序基于sysfs文件系统
(通过挂载在目录<code>/sys</code>下的伪文件系统来将设备相关信息和其他内核对象导出到用户空间)。</p>
<p>　　每个设备文件都有1个<strong>主ID号</strong>和1个<strong>次ID号</strong>。主ID表示设备的常规类，内核通过主ID来为设备寻找合适的驱动程序。属于相同常规类的设备通过次ID区分。设备文件的主ID和次ID可以通过命令<code>ls -l</code>查看。</p>
<p>　　设备的主ID和次ID记录在设备文件的i-node中。所有设备驱动器程序都会注册与特定设备主ID的关联，该关联会提供设备特殊文件和设备驱动程序之间的连接。当内核查找设备驱动程序时，设备文件的名称无关紧要。</p>
<p>　　对于Linux
2.4及以下版本，设备主ID和次ID都由8位表示，从而限制了系统上的设备总数。此外，主ID是固定的，次ID只能由Linux
Assigned Names and Numbers Authority (LANNA)
分配，这进一步加剧了该限制。Linux 2.6通过使用更多位来表示主ID (12位)
和次ID (20位) 来缓解该限制。</p>
<span id="more"></span>
<h3 id="磁盘和分区">14.2 磁盘和分区</h3>
<p>　　常规文件和目录通常位于磁盘设备
(也可能位于CD-ROM、闪存卡和虚拟磁盘等设备)。</p>
<p>　　磁盘驱动器是1种机械结构，由若干个高速旋转的盘片 (每分钟数千转)
组成。磁盘表面上的磁性编码信息由磁盘上径向移动的<strong>磁头</strong>检索或修改。从物理角度，盘面的信息位于一组称为<strong>磁道</strong>的同心圆。磁道分为多个<strong>扇区</strong>，每个扇区包含一组物理块。物理块通常是512字节
(或512字节的整数倍)，表示驱动器可以读写的最小信息单元。</p>
<p>　　尽管现代磁盘很快，但读写磁盘上的信息仍然需要大量时间。磁头移动到合适的磁道
(寻道时间)，然后驱动器必须等待扇区旋转到磁头下方
(旋转延迟)，最后传输所需的块
(传输时间)。执行1次这样的操作所需的时间通常是毫秒级，在此期间，现代CPU可以执行数百万条指令。</p>
<p>　　每个磁盘分为若干个<strong>分区</strong>。内核将每个分区都作为位于目录<code>/dev</code>下的独立设备。磁盘分区可能会包含任何类型的信息，但通常会包含<span
style="background-color: yellow">文件系统</span>
(存储常规文件和目录)、<span
style="background-color: yellow">数据区域</span>
(访问时视为原始模式设备) 或<span
style="background-color: yellow">交换区域</span>
(用于内核内存管理)。</p>
<p>　　系统管理员可以通过命令<code>fdisk</code>来获取磁盘分区的编号、类型和大小。命令<code>fdisk -l</code>会列出磁盘上的所有分区。特定与Linux的文件<code>/proc/partitions</code>列出了系统上的所有磁盘分区的编号、大小和名称。</p>
<p>　　可以通过命令<code>mkswap</code>来创建交换区域。特权进程
(能力<code>CAP_SYS_ADMIN</code>)
可以通过系统调用<code>swapon()</code>来通知内核将磁盘分区作为交换区域。系统调用<code>swapoff()</code>执行相反的功能，通知内核停止将磁盘分区作为交换区域。SUSv3没有说明<code>swapon()</code>和<code>swapoff()</code>，但很多UNIX实现都提供了这2个系统调用。特定于Linux的文件<code>/proc/swaps</code>可用于获取系统上当前已启用的交换区域的相关信息，这些信息包括每个交换区域的大小和已使用的区域量。</p>
<h3 id="文件系统">14.3 文件系统</h3>
<p>　　文件系统中分配空间的基本单元是<span
style="background-color: yellow">逻辑块</span>，这是文件系统所在的磁盘设备上的连续物理块的整数倍
(逻辑块大小指定为命令<code>mkfs</code>的参数)。例如，ext2的逻辑块的大小是1024、2048或4096字节。</p>
<p>　　特权程序 (能力<code>CAP_SYS_RAWIO</code>)
可以通过<code>ioctl()</code>的操作<code>FIBMAP</code>来获取文件中特定块的物理位置。该调用的第3个参数是整数结果值。在调用前，该参数应该设置为逻辑块号
(第1个逻辑块的编号是0)；在调用后，该参数会变为存储逻辑块的起始物理块的编号。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/layout_of_disk_partitions_and_a_file_system.svg" class="">
<p>　　文件系统由<span
style="background-color: yellow">引导块</span>、<span
style="background-color: yellow">超级块</span>、<span
style="background-color: yellow">i-node表</span>和<span
style="background-color: yellow">数据块</span>组成。</p>
<p>　　●
引导块总是文件系统的第1个块。文件系统不使用引导块，相反，引导块包含用于引导文件系统的信息。尽管操作系统只需要1个引导块，但所有文件系统都有引导块
(大部分未使用)。</p>
<p>　　●
超级块总是文件系统的第2个块，其中包含文件系统的参数信息：i-node表的大小、文件系统的逻辑块大小和文件系统的大小
(以逻辑块为单位)。位于相同物理设备的不同文件系统可以有不同的类型、大小和参数设置
(这也是将磁盘划分为多个分区的原因之一)。</p>
<p>　　●
文件系统中的所有文件或目录在i-node表中都有1个唯一的条目，该条目记录着文件的各种信息。i-node表有时也称为<span
style="background-color: yellow">i-list</span>。</p>
<p>　　● 文件系统中的大部分空间都是组成文件和目录的数据块。</p>
<p>　　对于ext2文件系统，情况略有不同。在引导块后，文件系统划分为1组固定大小的<span
style="background-color: yellow">块组</span>。每个块组的第1个块都是超级块，其中包含该块组的参数信息。超级块之后是i-node表，i-node表之后是数据块。通过尝试将1个文件的所有块都存储在1个块组，ext2文件系统旨在减少顺序访问文件时的寻道时间。</p>
<h3 id="i-node">14.4 i-node</h3>
<p>　　i-node节点通过其在i-node表中的顺序位置进行数字标识。文件的i-node号是命令<code>ls -li</code>显示的第1个字段。i-node维护的信息包括文件类型、文件所有者的用户ID、文件所属组的组ID、访问权限、时间戳
(最近1次访问文件的时间戳、最近1次修改文件的时间戳和最近1次修改i-node信息的时间戳)、指向文件的硬链接数、文件大小
(以字节为单位)、实际分配给文件的块数 (块大小是512字节)
和指向文件数据块的指针。</p>
<p>　　与其他UNIX文件系统一样，ext2文件系统不会连续存储文件数据块
(甚至不会顺序存储)。为了定位文件数据块，内核在i-node中维护了一组指针。</p>
<p>　　对于文件系统，以非连续的方式存储文件块可以提高磁盘空间使用率，尤其是降低产生空闲磁盘空间碎片的可能性
(存在大量不连续且小到无法使用的空闲空间)。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/structure_of_file_blocks_for_a_file_in_an_ext2_file_system.svg" class="">
<p>　　对于ext2，每个i-node包含15个指针。前12个指针指向文件的前12个块。第13个指针是指向指针块的指针，该指针块提供了文件的第13个块和后续数据块的位置。第13个指针指向的指针块中的指针数取决于文件系统的块大小
(当指针是4字节时，该指针块中可能有256~1024个指针)。对于较大的文件，第14个指针是<span
style="background-color: yellow">双重间接指针</span>，它指向的指针块也指向指针块，而后者指向文件的数据块。对于很大的文件，第15个指针是<span
style="background-color: yellow">三重间接指针</span>。</p>
<p>　　这个看似复杂的文件系统旨在满足多个请求。首先，它允许i-node结构体有固定大小，同时也允许文件有任意大小。其次，它允许文件系统以非连续的方式存储文件块，同时也允许通过<code>lseek()</code>随机访问数据
(内核只需要计算下一个指针)。最后，对于较小的文件，该文件系统允许通过i-node中的直接指针快速访问；对于很大的文件，当块是4096字节时，三重间接指针就能存储1024*1024*1024*4096字节
(4TB) 的文件。</p>
<p>　　这种设计的另一个优势是文件可以有空洞。文件系统可以直接将指针标记为0来表示对应的块没有引用磁盘块。</p>
<h3 id="虚拟文件系统">14.5 虚拟文件系统</h3>
<p>　　可用于Linux的文件系统的细节各不相同
(例如，分配文件块的方式和组织目录的方式)，这使得开发支持各种文件系统的应用程序几乎不可能。虚拟文件系统正是为了解决这一问题，<strong>虚拟文件系统</strong>是为文件系统操作创建抽象层的内核功能。</p>
<p>　　●
VFS给文件系统操作定义了1个通用接口。所有处理文件的程序可以通过该接口来指定文件系统操作。</p>
<p>　　● 每个文件系统为VFS接口提供实现。</p>
<p>　　VFS接口包括与用于处理文件系统和目录的常用系统调用
(例如，<code>open()</code>、<code>read()</code>、<code>write()</code>、<code>lseek()</code>、<code>close()</code>、<code>truncate()</code>、<code>stat()</code>、<code>mount()</code>、<code>umount()</code>、<code>mmap()</code>、<code>mkdir()</code>、<code>link()</code>、<code>unlink()</code>、<code>symlink()</code>和<code>rename()</code>)
相对应的操作。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/virtual_file_system.svg" class="">
<p>　　VFS抽象层以传统的UNIX文件系统模型为模型。当然，有些文件系统
(尤其是非原生UNIX文件系统)
不支持所有VFS操作。对于这种情况，底层文件系统会返回错误码给VFS来表示不支持指定操作，并且VFS会将该错误码返回给应用程序。</p>
<h3 id="日志文件系统">14.6 日志文件系统</h3>
<p>　　对于ext2等传统文件系统，系统崩溃后，必须在重启时执行<span
style="background-color: yellow">文件系统一致性检测</span>
(命令<code>fsck</code>)
来确保文件系统的完整性。系统崩溃时，文件更新可能只完成了一部分，并且文件系统元数据
(目录条目、i-node信息和文件块指针)
可能处于不一致的状态，所以文件系统可能由于不一致未修复而进一步损坏。文件系统一致性检测会确保文件系统元数据的一致性。当可能时，也会执行修复，无法修复的信息
(可能包含文件数据) 将被丢弃。</p>
<p>　　传统文件系统的问题在于一致性检测需要检查整个文件系统。对于较小的文件系统，这可能会花费数秒。对于较大的文件系统，这可能会花费数小时，这对于必须保持高可用性的系统
(例如，网络服务器) 是严重的问题。</p>
<p>　　日志文件系统解决了系统崩溃后进行冗长的一致性检测的问题，日志文件系统会在实际元数据更新前就将所有元数据更新记录在1个特殊的磁盘日志文件中。这些更新记录在相关元数据更新
(事务)
组中。若在执行事务的过程中系统崩溃，则系统重启时会撤销所有未完成的更新，并将文件还原到一致性状态
(按照数据库术语，日志文件系统会保证文件元数据事务始终作为完整的单元提交)。当系统崩溃后，很大的日志文件系统只需要数秒就能正常运行。</p>
<p>　　部分日志文件系统只确保文件元数据的一致性。因为他们不记录文件数据，所以系统崩溃时，文件数据还是可能会丢失。ext3、ext4和Reiserfs提供了记录文件数据更新的选项，但由于工作负载，这可能会降低I/O性能。</p>
<p>　　日志文件系统最大的劣势是更新文件需要更长的时间，尽管良好的设计已经在尽可能地缩短这一时间。</p>
<p>　　可用于Linux的日志文件系统包括Reiserfs、ext3、JFS和XFS。</p>
<p>　　● Reiserfs是第1个集成到内核 (版本2.4.1)
的日志文件系统。Reiserfs提供了称为<strong>尾部打包</strong>
(或<strong>尾部合并</strong>) 的特性，即将较小的文件
(和较大文件的最后1个片) 打包到文件元数据所属的磁盘块。很多系统都有
(和有些应用程序都会生成) 大量的较小的文件，这会节省很多磁盘空间。</p>
<p>　　●
ext3文件系统是以最小的影响将日志加入到ext2得到的结果。从ext2迁移到ext3非常简单
(无需备份和存储)，并且也可以从ext3迁移到ext2。ext3已集成到内核2.4.15中。</p>
<p>　　● JFS由IBM开发，它已集成到内核2.4.20中。</p>
<p>　　● XFS最初由Silicon Graphics (SCI)
于20世纪90年代早期为其专有的UNIX实现Irix开发。在2001年，XFS移植到了Linux，并且提供为免费软件。XFS已集成到内核2.4.24中。</p>
<p>　　在配置内核时，可以通过在文件系统菜单下设置内核选项来启用对各种文件系统的支持。</p>
<p>　　在撰写本书时，ext4和Btrfs (B-tree FS)
的工作正在进行中，这2个文件系统提供了日志和一系列其他高级特性：</p>
<p>　　●
ext4文件系统是ext3的后继者。实现的第1部分已集成到内核2.6.19中，在后来的版本中集成了各种特性。ext4的计划
(或已实现的) 特性包括扩展 (保留连续的存储块)
和其他旨在减少文件碎片的分配特性、在线文件系统碎片整理、更快的文件系统检索和对纳秒时间戳的支持。</p>
<p>　　●
Btrfs是从头开始设计的新文件系统，旨在提供了一系列现代特性，包括扩展、可写的快照
(提供等同于元数据和数据日志的功能)
、数据和元数据的校验和、在线文件系统检测、在线文件系统碎片整理、节省空间的小文件打包以及节省空间的索引目录。Btrfs已集成到内核2.6.29中。</p>
<h3 id="单一目录层次结构和挂载点">14.7 单一目录层次结构和挂载点</h3>
<p>　　对于Linux和大多数UNX实现，所有文件都位于单一目录树下。该树的根节点是根目录<code>/</code>。其他文件系统都是<strong>挂载</strong>在根目录下。超级用户可以通过以下命令来挂载1个文件系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount device directory</span></span><br></pre></td></tr></table></figure>
<p>　　该命令会将名为<code>device</code>的文件系统附加到<code>directory</code>指定的目录下，即<strong>挂载点</strong>。当文件系统已挂载时，无法修改其挂载点。文件系统可以通过命令<code>umount</code>来卸载。</p>
<p>　　对于Linux
2.4.19及以上版本，事情变得更加复杂，因为内核开始支持进程级<span
style="background-color: yellow">挂载命名空间</span>，即每个进程都可以有自己的文件系统挂载点集合。因此，可能会出现不同于其他进程的单一目录层次结构。</p>
<p>　　当需要列出当前已挂载的文件系统时，可以直接使用命令<code>mount</code>
(不带有任何参数)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount</span></span><br><span class="line">/dev/sda6 on / type ext4 (rw)</span><br><span class="line">proc on /proc type proc (rw)</span><br><span class="line">sysfs on /sys type sysfs (rw)</span><br><span class="line">devpts on /dev/pts type devpts (rw,mode=0620,gid=5)</span><br><span class="line">/dev/sda8 on /home type ext3 (rw,acl,user_xattr)</span><br><span class="line">/dev/sda1 on /windows/C type vfat (rw,noexec,nosuid,nodev)</span><br><span class="line">/dev/sda9 on /home/mtk/test type reiserfs (rw)</span><br></pre></td></tr></table></figure>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/example_directory_hierarchy_showing_file-system_mount_points.svg" class="">
<p>　　上图展示了执行上述挂载命令的系统的部分目录和文件结构，同时，这里也展示了挂载点如何映射到目录层次结构。</p>
<p>　　文件<code>/etc/mtab</code>、<code>/etc/fstab</code>以及特定于Linux的虚拟文件<code>/proc/mounts</code>包含当前已挂载和能挂载的文件系统的相关信息。</p>
<p>　　●
命令<code>mount</code>和<code>umount</code>会自动维护文件<code>/etc/mtab</code>，其中包含已挂载的文件系统的详细信息。该文件包含提供给命令<code>mount</code>的特定于文件系统的选项
(文件<code>/proc/mounts</code>中不包含这些信息)。但是，因为系统调用<code>mount()</code>和<code>umount()</code>不更新<code>/etc/mtab</code>，所以当挂载或卸载设备的应用程序更新该文件失败时，该文件中的信息可能不准确。</p>
<p>　　●
文件<code>/etc/fstab</code>由系统管理员手动维护，其中包含系统中所有可用的文件系统的描述。命令<code>mount</code>、<code>umount</code>和<code>fsck</code>会使用该文件。</p>
<p>　　●
可以通过文件<code>/proc/mounts</code>来获取当前已挂载的文件系统的列表，该文件是到内核数据结构的接口，所以它包含已挂载的文件系统的准确信息。由于进程级挂载命名空间，每个进程都有文件<code>/proc/PID/mounts</code>，其中列出了组成挂载命名空间的挂载点。此外，<code>/proc/mounts</code>只是指向<code>/proc/self/mounts</code>的符号链接。</p>
<p>　　这3个文件中的信息都使用如下所示的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dev/sda9 /boot ext3 rw 0 0</span><br></pre></td></tr></table></figure>
<p>　　每行信息包含6个字段。第1个和第2个字段是已挂载的设备的名称和挂载点。第3个字段是文件系统类型。第4个字段是挂载标志
(例如，<code>rw</code>表示挂载为可读可写)。第5个字段是用于通过命令<code>dump</code>控制文件系统备份操作的数字。第6个字段是用于控制命令<code>fsck</code>在系统引导时检测文件系统的顺序的数字。</p>
<p>　　库函数<code>getfsent()</code>和<code>getmntent()</code>的手册记录了可用于从这3个文件读记录的函数。</p>
<h3 id="挂载和卸载文件系统">14.8 挂载和卸载文件系统</h3>
<p>　　系统调用<code>mount()</code>和<code>umount()</code>允许特权进程
(能力<code>CAP_SYS_ADMIN</code>)
挂载和卸载文件系统。大多数UNIX实现提供了这2个系统调用。但是，SUSv3没有说明这2个系统调用，并且它们的行为因UNIX实现或文件系统而异。</p>
<h4 id="挂载文件系统">14.8.1 挂载文件系统</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *source, <span class="type">const</span> <span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *fstype,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> mountflags, <span class="type">const</span> <span class="type">void</span> *data)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>mount()</code>会将参数<code>source</code>指定的设备挂载到参数<code>target</code>指定的挂载点。</p>
<p>　　参数<code>fstype</code>是设备包含的文件系统类型的标识字符串
(例如，<code>ext4</code>或<code>btrfs</code>)。参数<code>mountflags</code>可以包含任意个挂载标志
(或运算<code>|</code>)。参数<code>data</code>是指向缓冲区的指针，该缓冲区中的信息的解析取决于文件系统。对于大多数文件系统类型，<code>data</code>是由逗号分隔的选项设置组成的字符串。</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr>
<th><code>mountflags</code>标志</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MS_BIND</code></td>
<td>创建绑定挂载 (Linux 2.4及以上版本)</td>
</tr>
<tr>
<td><code>MS_DIRSYNC</code></td>
<td>同步目录更新 (Linux 2.6及以上版本)</td>
</tr>
<tr>
<td><code>MS_MANDLOCK</code></td>
<td>允许强制锁定文件</td>
</tr>
<tr>
<td><code>MS_MOVE</code></td>
<td>以原子方式将挂载点移动到其他位置</td>
</tr>
<tr>
<td><code>MS_NOATIME</code></td>
<td>不更新文件 (包括目录) 的最后访问时间</td>
</tr>
<tr>
<td><code>MS_NODEV</code></td>
<td>不允许访问设备</td>
</tr>
<tr>
<td><code>MS_NODIRATIME</code></td>
<td>不更新目录的最后访问时间</td>
</tr>
<tr>
<td><code>MS_NOEXEC</code></td>
<td>不允许执行程序</td>
</tr>
<tr>
<td><code>MS_NOSUID</code></td>
<td>禁用set-user-ID和set-group-ID程序</td>
</tr>
<tr>
<td><code>MS_RDONLY</code></td>
<td>只读挂载点，文件无法创建或修改</td>
</tr>
<tr>
<td><code>MS_REC</code></td>
<td>递归挂载 (Linux 2.4.11及以上版本)</td>
</tr>
<tr>
<td><code>MS_RELATIME</code></td>
<td>当且仅当最后访问时间早于最后修改时间或最后状态修改时间时，才更新最后访问时间
(Linux 2.6.20及以上版本)</td>
</tr>
<tr>
<td><code>MS_REMOUNT</code></td>
<td>修改已挂载的文件系统的<code>mountflags</code>和<code>data</code></td>
</tr>
<tr>
<td><code>MS_STRICTATIME</code></td>
<td>总是更新最后访问时间 (Linux 2.6.30及以上版本)</td>
</tr>
<tr>
<td><code>MS_SYNCHRONOUS</code></td>
<td>同步所有文件和目录更新</td>
</tr>
</tbody>
</table>
<p>　　●
<code>MS_BIND</code>表示创建1个挂载点。若指定了该标志，则<code>fstype</code>、<code>mountflags</code>和<code>data</code>都会被忽略。</p>
<p>　　●
<code>MS_DIRSYNC</code>表示同步目录更新，类似于<code>open()</code>的打开状态标志<code>O_SYNC</code>，但只会应用于目录更新，并且不会产生同步所有文件的开销。标志<code>FS_DIRSYNC_FL</code>与<code>MS_DIRSYNC</code>类似，但<code>FS_DIRSYNC_FL</code>可应用于单个目录。此外，对于Linux，对引用目录的文件描述符调用<code>fsync()</code>也能用于同步单个目录
(SUSv3没有说明这种特定于Linux的行为)。</p>
<p>　　●
<code>MS_MANDLOCK</code>表示允许该文件系统中的文件进行强制记录锁定。</p>
<p>　　●
<code>MS_MOVE</code>表示以原子方式将<code>source</code>指定的已存在的挂载点移动到<code>target</code>指定的新位置，这与命令<code>mount</code>的选项<code>--move</code>对应。该标志等同于卸载子树，然后重新挂载到新位置，除了子树未卸载时没有挂载点。<code>source</code>应该是之前调用<code>mount()</code>时作为<code>target</code>的字符串。当指定该标志时，<code>fstype</code>、<code>mountflags</code>和<code>data</code>都会被忽略。</p>
<p>　　●
<code>MS_NOATIME</code>表示不更新该文件系统中的所有类型的文件的最后访问时间。该标志与<code>MS_NODIRATIME</code>用于节省每次访问文件时更新文件i-node所需的额外磁盘空间。对于不需要维护最后访问时间的应用程序，这会显著提升性能。<code>MS_NOATIME</code>与<code>FS_NOATIME_FL</code>类似，但是<code>FS_NOATIME_FL</code>可应用于单个文件。此外，对于Linux，打开单个文件时使用<code>open()</code>的打开状态标志<code>O_NOATIME</code>也能用于不更新单个文件的最后访问时间。</p>
<p>　　●
<code>MS_NODEV</code>表示不允许访问该文件系统中的块设备和字符设备。该标志是旨在防止用户执行部分行为
(例如，插入包含允许任意访问系统的设备特殊文件的可移动磁盘)
的安全特性。</p>
<p>　　●
<code>MS_NODIRATIME</code>表示不更新该文件系统中的目录的最后访问时间。该标志的功能是<code>MS_NOATIME</code>的功能的子集。</p>
<p>　　● <code>MS_NOEXEC</code>表示不允许执行该文件系统中的文件
(或脚本)。</p>
<p>　　●
<code>MS_NOSUID</code>表示禁用该文件系统中的set-user-ID程序和set-group-ID程序。该标志是旨在防止用户运行可移动磁盘中的set-user-ID程序和set-group-ID程序的安全特性。</p>
<p>　　●
<code>MS_RDONLY</code>表示将文件系统挂载为只读，所以无法创建和修改文件。</p>
<p>　　●
<code>MS_REC</code>与其他标志一起使用，表示以递归方式将挂载操作应用于子树中的所有挂载。</p>
<p>　　●
<code>MS_RELATIME</code>表示当且仅当最后访问时间戳早于最后修改时间戳或最后状态修改时间戳时，才会更新最后访问时间戳。该标志提供了<code>MS_NOATIME</code>的部分性能优势，并且对需要知道文件自上次更新以来是否被读取的程序很有用。对于Linux
2.6.30及以上版本，<code>MS_RELATIME</code>提供的功能成为了默认功能
(除非指定了<code>MS_NOATIME</code>)，并且需要指定<code>MS_STRICTATIME</code>才能获取经典行为。此外，若距最后访问时间戳的当前值已过去24小时，则总是会更新最后访问时间戳。</p>
<p>　　●
<code>MS_RMOUNT</code>表示修改已挂载的文件系统的<code>mountflags</code>和<code>data</code>
(例如，使只读的文件系统可写)。当使用该标志后，<code>source</code>和<code>target</code>需要与初始调用<code>mount()</code>时的相同，并且<code>fstype</code>会被忽略。该标志避免了卸载和重新挂载磁盘
(某些情况下，不可能卸载和重新挂载磁盘)。此外，并非所有的<code>mountflags</code>都可以修改。</p>
<p>　　●
<code>MS_STRICTATIME</code>表示总是更新该文件系统中的文件的最后访问时间戳
(这是Linux
2.6.30之前的版本的默认行为)。若指定了该标志，则<code>mountflags</code>中的<code>MS_NOATIME</code>和<code>MS_RELATIME</code>都会被忽略。</p>
<p>　　●
<code>MS_SYNCHRONOUS</code>表示同步该文件系统中的所有文件和目录更新
(对于文件，这等同于打开文件时使用<code>open()</code>的打开状态标志<code>O_SYNC</code>)。</p>
<p>　　从内核2.6.15开始，Linux提供了4个支持<span
style="background-color: yellow">共享子树</span>的新挂载标志：<code>MS_PRIVATE</code>、<code>MS_SHARED</code>、<code>MS_SLAVE</code>和<code>MS_UNBINDABLE</code>
(这些标志可以与<code>MS_REC</code>一起使用来将其效果传播到挂载子树下的所有子挂载)。共享子树设计为供进程级挂载命名空间和用户空间文件系统等特定的高级文件系统特性使用。共享子树允许以受控方式在挂载命名空间之间传播文件系统挂载。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_mount.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usageError</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *progName, <span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [options] source target\n\n&quot;</span>, progName);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Available options:\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fpe(str) fprintf(stderr, <span class="string">&quot;  &quot;</span> str)</span></span><br><span class="line">    fpe(<span class="string">&quot;-t fstype [e.g., &#x27;ext2&#x27; or &#x27;reiserfs&#x27;]\n&quot;</span>);</span><br><span class="line">    fpe(<span class="string">&quot;-o data [file system-dependent options,\n&quot;</span>);</span><br><span class="line">    fpe(<span class="string">&quot; e.g., &#x27;bsdgroups&#x27; for ext2]\n&quot;</span>);</span><br><span class="line">    fpe(<span class="string">&quot;-f mountflags can include any of:\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fpe2(str) fprintf(stderr, <span class="string">&quot;     &quot;</span> str)</span></span><br><span class="line">    fpe2(<span class="string">&quot;b - MS_BIND create a bind mount\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;d - MS_DIRSYNC synchronous directory updates\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;l - MS_MANDLOCK permit mandatory locking\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;m - MS_MOVE atomically move subtree\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;A - MS_NOATIME don&#x27;t update atime (last access time)\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;V - MS_NODEV don&#x27;t permit device access\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;D - MS_NODIRATIME don&#x27;t update atime on directories\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;E - MS_NOEXEC don&#x27;t allow executables\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;S - MS_NOSUID disable set-user/group-ID programs\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;r - MS_RDONLY read-only mount\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;c - MS_REC recursive mount\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;R - MS_REMOUNT remount\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;s - MS_SYNCHRONOUS make writes synchronous\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">char</span> *data, *fstype;</span><br><span class="line">    <span class="type">int</span> j, opt;</span><br><span class="line"></span><br><span class="line">    flags = <span class="number">0</span>;</span><br><span class="line">    data = <span class="literal">NULL</span>;</span><br><span class="line">    fstype = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;o:t:f:&quot;</span>)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">            data = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            fstype = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(optarg); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (optarg[j])</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                    flags |= MS_BIND;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                    flags |= MS_DIRSYNC;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">                    flags |= MS_MANDLOCK;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">                    flags |= MS_MOVE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                    flags |= MS_NOATIME;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">                    flags |= MS_NODEV;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                    flags |= MS_NODIRATIME;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                    flags |= MS_NOEXEC;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                    flags |= MS_NOSUID;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">                    flags |= MS_RDONLY;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                    flags |= MS_REC;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">                    flags |= MS_REMOUNT;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    flags |= MS_SYNCHRONOUS;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    usageError(argv[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            usageError(argv[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != optind + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageError(argv[<span class="number">0</span>], <span class="string">&quot;Wrong number of arguments\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mount(argv[optind], argv[optind + <span class="number">1</span>], fstype, flags, data) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;mount&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例提供了系统调用<code>mount()</code>的命令级接口。实际上，这是命令<code>mount</code>的简略版。</p>
<h4 id="卸载文件系统">14.8.2 卸载文件系统</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">umount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">umount2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>umount()</code>会卸载参数<code>target</code>指定的挂载点对应的文件系统。当文件系统<span
style="background-color: yellow">繁忙</span>时
(即该文件系统中有打开的文件或某个进程的当前工作目录位于该文件系统)，无法卸载该文件系统。对繁忙的文件系统调用<code>umount()</code>会导致错误<code>EBUSY</code>。</p>
<p>　　系统调用<code>umount2()</code>是<code>umount()</code>的扩展版，它允许通过参数<code>flags</code>来为挂载操作提供更好的控制。参数<code>flags</code>可以包含以下标志中的任意个标志
(或运算<code>|</code>)：</p>
<p>　　● <code>MNT_DETACH</code> (Linux 2.4.11及以上版本) 表示执行<span
style="background-color: yellow">懒</span>卸载。挂载点会被标记，以便进程无法对其进行新的访问，但已经在使用它的进程可以继续访问。当所有进程都不再使用该挂载时，文件系统才会卸载。</p>
<p>　　● <code>MNT_EXPIRE</code> (Linux 2.6.8及以上版本)
表示将挂载点标记为<span
style="background-color: yellow">过期</span>。若调用<code>umount2()</code>时指定了该标志，并且挂载点不忙，则本次调用会失败
(错误<code>EAGAIN</code>)，对应的挂载点会被标记为过期；若挂载点繁忙，则本次调用也会失败
(错误<code>EBUSY</code>)，并且挂载点不会被标记为过期。挂载点标记为过期后，只要后续没有进程使用该挂载点，它就一直保持过期。若对过期的挂载点调用<code>umount2()</code>，并且指定了该标志，则会卸载过期的挂载点。这提供了1种机制来卸载一段时间未使用的文件系统。此外，该标志无法与<code>MNT_DETACH</code>或<code>MNT_FORCE</code>一起使用。</p>
<p>　　● <code>MNT_FORCE</code>表示即使设备繁忙，也强制卸载
(仅限于NFS挂载)。</p>
<p>　　● <code>UMOUNT_NOFOLLOW</code> (Linux 2.6.34及以上版本)
表示若<code>target</code>是符号链接，则不对其解引用。该标准设计为供set-user-ID-root程序
(允许非特权用户执行卸载)
使用，以避免<code>target</code>是被修改为指向其他位置的符号链接而导致的安全问题。</p>
<h3 id="高级挂载特性">14.9 高级挂载特性</h3>
<h4 id="将1个文件系统挂载到多个挂载点">14.9.1
将1个文件系统挂载到多个挂载点</h4>
<p>　　对于内核2.4以下的版本，1个文件系统只能挂载在1个挂载点。对于内核2.4及以上版本，1个文件系统可以挂载到该文件系统内的多个挂载点，因为挂载着相同的文件系统的所有挂载点都对应相同的子树，所以通过1个挂载点所做的修改可以通过其他挂载点看到。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> /demo</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount /dev/sda12 /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount /dev/sda12 /demo</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount | grep sda12</span></span><br><span class="line">/dev/sda12 on /testfs type ext3 (rw)</span><br><span class="line">/dev/sda12 on /demo type ext3 (rw)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> /testfs/myfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> /demo</span></span><br><span class="line">lost+found myfile</span><br></pre></td></tr></table></figure>
<p>　　以上命令会先将文件系统<code>/dev/sda12</code>挂载到2个挂载点，然后修改1个挂载点的内容，最后通过另一个挂载点展示做出的修改。</p>
<p>　　因为设备可以挂载到多个挂载点，所以对于Linux
2.4及以上版本，系统调用<code>umount()</code>无法将设备作为其参数。</p>
<h4 id="将多个挂载堆叠在1个挂载点">14.9.2 将多个挂载堆叠在1个挂载点</h4>
<p>　　对于内核2.4以下的版本，1个挂载点只能挂载1次。对于内核2.4及以上版本，1个挂载点堆叠多个挂载。对于堆叠在相同挂载点的挂载，每个新挂载都会隐藏以前在该挂载点可见的目录子树。当位于顶端的挂载被卸载时，之前隐藏的挂载会再次可见。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount /dev/sda12 /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> /testfs/myfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount /dev/sda13 /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount | grep testfs</span></span><br><span class="line">/dev/sda12 on /testfs type ext3 (rw)</span><br><span class="line">/dev/sda13 on /testfs type reiserfs (rw)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> /testfs/newfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> /testfs</span></span><br><span class="line">newfile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">umount /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount | grep testfs</span></span><br><span class="line">/dev/sda12 on /testfs type ext3 (rw)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> /testfs</span></span><br><span class="line">lost+found myfile</span><br></pre></td></tr></table></figure>
<p>　　以上命令会先将文件系统<code>/dev/sda12</code>和<code>/dev/sda13</code>都挂载到1个挂载点并创建子树，然后卸载顶端的文件系统，最后显示挂载点的内容。</p>
<p>　　挂载堆叠的用途之一是将新挂载堆叠到当前繁忙的挂载点。保持文件描述符打开、<code>chroot</code>失败或在旧挂载点中有当前工作目录的进程可以继续在旧挂载下运行，但对挂载点进行新访问的进程会使用新挂载。与系统调用<code>umount2()</code>的标志<code>MNT_DETACH</code>一起使用，可以提供从文件系统平滑迁移的过程，而无需使系统进入单用户模式。</p>
<h4 id="作为每个挂载点选项的标志">14.9.3 作为每个挂载点选项的标志</h4>
<p>　　对于内核2.4以下的版本，文件系统和挂载点之间关系是1对1。对于内核2.4及以上版本，部分<code>mountflags</code>标志可以基于挂载设置，这些标志是<code>MS_NOATIME</code>
(Linux 2.6.16及以上版本)、<code>MS_NODEV</code>
、<code>MS_NODIRATIME</code> (Linux
2.6.16及以上版本)、<code>MS_NOEXEC</code>、<code>MS_NOSUID</code>、<code>MS_RDONLY</code>
(Linux 2.6.26及以上版本) 和<code>MS_RELATIME</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount /dev/sda12 /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -o noexec /dev/sda12 /demo</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/mounts | grep sda12</span></span><br><span class="line">/dev/sda12 /testfs ext3 rw 0 0</span><br><span class="line">/dev/sda12 /demo ext3 rw,noexec 0 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cp</span> /bin/echo /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/testfs/echo <span class="string">&quot;Art is something which is well done&quot;</span></span></span><br><span class="line">Art is something which is well done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/demo/echo <span class="string">&quot;Art is something which is well done&quot;</span></span></span><br><span class="line">bash: /demo/echo: Permission denied</span><br></pre></td></tr></table></figure>
<p>　　以上命令展示了标志<code>MS_NOEXEC</code>的用法。</p>
<h4 id="绑定挂载">14.9.4 绑定挂载</h4>
<p>　　对于内核2.4及以上版本，Linux允许创建绑定挂载
(通过系统调用<code>mount()</code>的标志<code>MS_BIND</code>)。<strong>绑定挂载</strong>允许目录或文件挂载到文件系统层次架构中的其他位置，该目录或文件的结果会在所有位置都可见。绑定挂载与硬链接类似，但在以下2个方面不同：</p>
<p>　　● 绑定挂载可以跨文件系统挂载点
(甚至<code>chroot</code>失败)。</p>
<p>　　● 可以对目录进行绑定挂载。</p>
<p>　　可以通过命令<code>mount</code>的选项<code>--bind</code>在shell中创建绑定挂载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> d1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> d1/x</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> d2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount --<span class="built_in">bind</span> d1 d2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> d2</span></span><br><span class="line">x</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> d2/y</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> d1</span></span><br><span class="line">x y</span><br></pre></td></tr></table></figure>
<p>　　以上命令会先将<code>d1</code>绑定到<code>d2</code>，然后在目录<code>d2</code>下从创建文件<code>y</code>，最后列出目录<code>d1</code>下的文件。</p>
<h4 id="递归绑定挂载">14.9.5 递归绑定挂载</h4>
<p>　　在默认情况下，当通过系统调用<code>mount()</code>的标志<code>MS_BIND</code>来对目录进行绑定时，只会将该目录挂载到新位置，若该目录下有子绑定，则不会在挂载目录下复制这些子绑定。Linux
2.4.11添加了标志<code>MS_REC</code>，该标志与<code>MS_BIND</code>进行或运算得到的结果可以指定给<code>mount()</code>的参数<code>flags</code>，以保证子绑定也会复制，这种情况称为<strong>递归绑定挂载</strong>。</p>
<p>　　可以通过命令<code>mount</code>的选项<code>--rbind</code>来在shell中创建递归绑定挂载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> top</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> src1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> src1/aaa</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount --<span class="built_in">bind</span> src1 top</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> top/sub</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> src2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> src2/bbb</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount --<span class="built_in">bind</span> src2 top/sub</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find top</span></span><br><span class="line">top</span><br><span class="line">top/aaa</span><br><span class="line">top/sub</span><br><span class="line">top/sub/bbb</span><br></pre></td></tr></table></figure>
<p>　　这里会先在<code>top</code>下创建1个挂载在<code>top</code>下的目录树<code>src1</code>，该树包括挂载在<code>top/sub</code>的子挂载<code>src2</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> dir1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount --<span class="built_in">bind</span> top dir1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find dir1</span></span><br><span class="line">dir1</span><br><span class="line">dir1/aaa</span><br><span class="line">dir1/sub</span><br></pre></td></tr></table></figure>
<p>　　然后，创建第3个绑定挂载<code>dir2</code>，因为该绑定挂载是非递归的，所以子挂载不会复制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> dir2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount --rbind top dir2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find dir2</span></span><br><span class="line">dir2</span><br><span class="line">dir2/aaa</span><br><span class="line">dir2/sub</span><br><span class="line">dir2/sub/bbb</span><br></pre></td></tr></table></figure>
<p>　　最后，创建递归绑定挂载<code>dir2</code>。</p>
<h3 id="虚拟内存文件系统">14.10 虚拟内存文件系统</h3>
<p>　　之前的介绍的文件系统都是位于磁盘。Linux也支持<span
style="background-color: yellow">位于内存的虚拟文件系统</span>。对于应用程序，这些文件系统系统与常规文件系统相似，对常规文件系统执行的操作
(例如，<code>open()</code>、<code>read()</code>、<code>write()</code>、<code>link()</code>和<code>mkdir()</code>)
也可以应用于这些文件系统，但这些操作会更快，因为不涉及磁盘访问。</p>
<p>　　迄今为止，最复杂的位于的虚拟文件系统是tmpfs文件系统，它首次出现在Linux
2.4。tmpfs与其他位于内存的虚拟文件系统不同之处在于它是<strong>虚拟内存文件系统</strong>，这表示tmpfs不仅会使用RAM，还会在RAM耗尽时使用交换空间。尽管tmpfs是特定于Linux的，但大多数UNIX实现也提供了某种形式的位于内存的虚拟文件系统。</p>
<p>　　tmpfs文件系统是可选的Linux内核组件，可以通过选项<code>CONFIG_TMPFS</code>配置。</p>
<p>　　可以使用如下格式的命令来创建tmpfs文件系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -t tmpfs <span class="built_in">source</span> target</span></span><br></pre></td></tr></table></figure>
<p>　　<code>source</code>可以是任何名称，其唯一的意义在于出现在<code>/proc/mounts</code>，并且由命令<code>mount</code>和<code>df</code>显示。<code>target</code>是文件系统的挂载点。这里并不需要先通过命令<code>mkfs</code>创建文件系统，因为命令<code>mount</code>会自动创建文件系统。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -t tmpfs newtmp /tmp</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/mounts | grep tmp</span></span><br></pre></td></tr></table></figure>
<p>　　以上命令 (或在文件<code>/etc/fstab</code>中的等效条目)
有时会用于提高频繁使用目录<code>/tmp</code>来创建临时文件的应用程序
(例如，编译器) 的性能。</p>
<p>　　在默认情况下，tmpfs文件系统被允许最多占用RAM的一半，但选项<code>size=nbytes</code>可用于为该文件系统的大小设置上限，无论是在创建文件系统时还是重新挂载时
(tmpfs文件系统占用的内存和交换空间的大小等于它保存的文件的大小)。</p>
<p>　　当卸载文件系统或系统崩溃时，tmpfs文件系统中的所有数据将会丢失，所以其名称是tmpfs。</p>
<p>　　除了供用户应用程序使用之外，tmpfs文件系统还有2个特殊目的：</p>
<p>　　● 由内核内部挂载的不可见的tmpfs文件系统会用于实现System
V共享内存和共享匿名内存映射。</p>
<p>　　●
挂载在<code>/dev/shm</code>的tmpfs文件系统会用于POSIX共享内存和POSIX信号量的glibc实现。</p>
<h3 id="获取文件系统的相关信息">14.11 获取文件系统的相关信息</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/statvfs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">statvfs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> statvfs *statvfsbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstatvfs</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> statvfs *statvfsbuf)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">statvfs</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_bsize;   <span class="comment">/* 文件系统块大小 (以字节为单位) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_frsize;  <span class="comment">/* 基本文件系统块大小 (以字节为单位) */</span></span><br><span class="line">    <span class="type">fsblkcnt_t</span> f_blocks;     <span class="comment">/* 文件系统中的块的数量 (以f_frsize为单位) */</span></span><br><span class="line">    <span class="type">fsblkcnt_t</span> f_bfree;      <span class="comment">/* 空闲块数 */</span></span><br><span class="line">    <span class="type">fsblkcnt_t</span> f_bavail;     <span class="comment">/* 非特权进程可用的空闲块数 */</span></span><br><span class="line">    <span class="type">fsfilcnt_t</span> f_files;      <span class="comment">/* i-node数 */</span></span><br><span class="line">    <span class="type">fsfilcnt_t</span> f_ffree;      <span class="comment">/* 空闲i-node数 */</span></span><br><span class="line">    <span class="type">fsfilcnt_t</span> f_favail;     <span class="comment">/* 非特权进程可用的i-node数 (对于Linux，其值与f_ffree相同) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_fsid;    <span class="comment">/* 文件系统ID */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_flag;    <span class="comment">/* 挂载标志 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_namemax; <span class="comment">/* 该文件系统中的文件名的最大长度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　库函数<code>statvfs()</code>和<code>fstatvfs()</code>都可用于获取已挂载的文件系统的相关信息，结果存储在参数<code>statvfsbuf</code>指向的结构体中。两者唯一的区别是指定文件系统的方式。前者指定的是目标文件系统中的文件的路径名
(参数<code>pathname</code>)，后者指定的是目标文件系统中的文件描述符
(参数<code>fd</code>)。</p>
<p>　　结构体<code>statvfs</code>的注释清楚地说明了大多数成员的用途，以下是部分成员的细节：</p>
<p>　　●
对于大多数Linux文件系统，成员<code>f_bsize</code>和<code>f_frsize</code>的值相同。但是，部分文件系统支持<span
style="background-color: yellow">块碎片</span>
(UNIX文件系统的块碎片概念最早于20世纪80年代早期出现在4.2BSD的快速文件系统)，该特性可用于在不需要完整块时在文件末尾分配较小的存储单元。对于这些文件系统，成员<code>f_frsize</code>的值是块碎片的大小，而成员<code>f_bsize</code>的值是完整块的大小。</p>
<p>　　●
很多原生UNIX和Linux文件系统都支持为超级用户保留文件系统中的块，所以即使文件系统已满，超级用户依旧能够登录到系统，并执行一些操作来解决该问题。若文件系统中存在保留块，则成员<code>f_bfree</code>和<code>f_bavail</code>的差值表示保留的块数。</p>
<p>　　●
成员<code>f_flag</code>是由用于挂载文件系统的标志组成的位掩码，即其中包含的信息与系统调用<code>mount()</code>的参数<code>mountflags</code>的相似，但该成员使用的标志带有前缀<code>ST_</code>，而非前缀<code>MS_</code>。SUSv3仅要求该成员使用的标志包括<code>ST_RDONLY</code>和<code>ST_NOSUID</code>，但glibc实现支持各种标志，其名称与<code>mount()</code>的<code>mountflags</code>标志的名称对应。</p>
<p>　　● 有些UNIX实现会通过成员<code>f_fsid</code>来返回文件系统的ID
(例如，基于文件系统所在的设备的ID的值)。对于大多数Linux文件系统，该成员的值是0。</p>
<p>　　SUSv3详细说明了<code>statvfs()</code>和<code>fstatvfs()</code>。对于Linux和部分UNIX实现，这2个函数是系统调用<code>statfs()</code>和<code>fstatfs()</code>的包装函数
(有些UNIX实现提供了<code>statfs()</code>，但未提供<code>statvfs()</code>)。它们的主要区别如下
(除了部分名称不同的字段之外)：</p>
<p>　　●
库函数<code>statvfs()</code>和<code>fstatvfs()</code>会通过结构体<code>statvfs</code>的成员<code>f_flag</code>来返回文件系统的挂载标志
(glibc实现通过扫描文件<code>/proc/mounts</code>或<code>/etc/mtab</code>来获取这些信息)。</p>
<p>　　●
系统调用<code>statfs()</code>和<code>fstatfs()</code>会通过结构体<code>statfs</code>的成员<code>f_type</code>来返回文件系统的类型
(例如，值<code>0xef53</code>表示ext2文件系统)。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第19章 监控文件事件</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_19/</url>
    <content><![CDATA[<p>　　有些应用程序需要能够监控文件或目录，以确定监控对象是否发生了事件。例如，图形文件管理器需要能够确定何时在当前显示的目录下新增或删除文件，或者守护进程可能需要监控其配置文件，以便了解该文件是否已被修改。</p>
<p>　　从内核2.6.13开始，Linux提供了<strong>inotify</strong>机制，该机制允许应用程序监控文件事件。inotify机制取代了较旧的<strong>dnotify</strong>机制，dnotify的功能是inotify的子集
(Linux从内核2.4开始支持dnotify)。这2个机制是特定于Linux的，少部分UNIX实现提供了类似的机制
(例如，BSD提供了kqueue
API)。少部分库提供了比这2个机制更抽象和更易于移植的API，其中的部分库在可能时会使用inotify和dnotify
(例如，FAM和Gamin)。</p>
<p>　　使用inotify API的关键步骤如下：</p>
<p>　　1) 应用程序通过系统调用<code>inotify_init()</code>来创建1个<span
style="background-color: yellow">inotify实例</span>，该系统调用会返回引用inotify实例的文件描述符。</p>
<p>　　2)
应用程序通过系统调用<code>inotify_add_watch()</code>来将监控项添加到第1步创建的inotify实例的监控列表。每个监控项都由1个路径名和1个关联的位掩码组成，位掩码指定对路径名的监控事件集。该系统调用会返回<strong>监控描述符</strong>。系统调用<code>inotify_rm_watch()</code>执行相反的任务，它会从监控列表中删除监控项。</p>
<p>　　3)
为了获取事件通知，应用程序可以对inotify文件描述符调用<code>read()</code>。每次成功调用<code>read()</code>都会返回若干个结构体<code>inotify_event</code>，该结构体包含通过inotify实例监控的路径名之一发生的事件的相关信息。</p>
<p>　　4)
当应用程序完成监控后，会关闭inotify文件描述符。这会自动删除与inotify实例关联的所有监控项。</p>
<p>　　inotify机制可用于监控文件或目录。当监控目录时，应用程序会收到目录本身和目录下的所有文件的事件通知。</p>
<p>　　inotify机制不是递归的。若应用程序需要监控整个目录树的事件，则必须将树中的所有目录都添加到inotify实例的监控列表
(<code>inotify_add_watch()</code>)。</p>
<p>　　inotify文件描述符可以通过<code>select()</code>、<code>poll()</code>、epoll和信号驱动I/O
(Linux 2.6.25及以上版本)
监控。若事件可供读取，则这些接口会指示inotify文件描述符可读。</p>
<p>　　inotify机制是Linux内核的可选组件，由选项<code>CONFIG_INOTIFY</code>和<code>CONFIG_INOTIFY_USER</code>配置。</p>
<span id="more"></span>
<h3 id="inotify-api">19.1 inotify API</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inotify_init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 成功时返回文件描述符，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inotify_add_watch</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uint32_t</span> mask)</span>; <span class="comment">/* 成功时返回监控描述符，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inotify_rm_watch</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> wd)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>inotify_init()</code>会返回文件描述符。该文件描述符是用于在后续操作中引用inotify实例的句柄。</p>
<p>　　从内核2.6.27开始，Linux支持新的非标准系统调用<code>inotify_init1()</code>。该系统调用与<code>inotify_init()</code>类似，但提供了参数<code>flags</code>。该参数可用于修改该系统调用的行为。<code>flags</code>支持标志<code>IN_CLOEXEC</code>和<code>IN_NONBLOCK</code>。前者会让内核为新文件描述符启用close-on-exec标志
(<code>FD_CLOEXEC</code>)，后者会内核为底层打开的文件描述符启用标志<code>O_NONBLOCK</code>
(以后的读取都是非阻塞的)。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_19/an_inotify_instance_and_associated_kernel_data_structures.svg" class="">
<p>　　系统调用<code>inotify_add_watch()</code>会在参数<code>fd</code>引用的inotify实例的监控列表中新增监控项或修改现有监控项。参数<code>pathname</code>标识监控项的目标文件，调用者需要拥有该文件的读权限
(文件权限检查只会在调用该系统调用时执行1次。只要监控项存在，即使随后调用者不再拥有该文件的读权限，调用者依然能够收到该文件的事件通知)。参数<code>mask</code>是指定监控事件的位掩码。</p>
<p>　　●
若<code>pathname</code>之前未添加到<code>fd</code>的监控列表，则<code>inotify_add_watch()</code>会创建监控项，然后返回非负监控描述符
(同一inotify实例的监控描述符不会重复)。</p>
<p>　　●
若<code>pathname</code>之前已添加到<code>fd</code>的监控列表，则<code>inotify_add_watch()</code>会将<code>pathname</code>对应的监控项的位掩码修改为<code>mask</code>，然后返回该监控项的监控描述符。</p>
<p>　　系统调用<code>inotify_rm_watch()</code>会从参数<code>fd</code>引用的inotify实例的监控列表中删除参数<code>wd</code>指定的监控项
(<code>wd</code>是之前调用<code>inotify_add_watch()</code>时返回的监控描述符)。</p>
<h3 id="inotify事件">19.2 inotify事件</h3>
<p>　　当调用<code>inotify_add_watch()</code>时，可以指定给参数<code>mask</code>的事件位如下：</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr>
<th>事件位</th>
<th>输入</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IN_ACCESS</code></td>
<td>✓</td>
<td>✓</td>
<td>文件被访问 (<code>read()</code>)</td>
</tr>
<tr>
<td><code>IN_ATTRIB</code></td>
<td>✓</td>
<td>✓</td>
<td>文件元数据被修改</td>
</tr>
<tr>
<td><code>IN_CLOSE_WRITE</code></td>
<td>✓</td>
<td>✓</td>
<td>打开的用于写入的文件被关闭</td>
</tr>
<tr>
<td><code>IN_CLOSE_NOWRITE</code></td>
<td>✓</td>
<td>✓</td>
<td>以只读方式打开的文件被关闭</td>
</tr>
<tr>
<td><code>IN_CREATE</code></td>
<td>✓</td>
<td>✓</td>
<td>在监控目录下创建文件或目录</td>
</tr>
<tr>
<td><code>IN_DELETE</code></td>
<td>✓</td>
<td>✓</td>
<td>在监控目录下删除文件或目录</td>
</tr>
<tr>
<td><code>IN_DELETE_SELF</code></td>
<td>✓</td>
<td>✓</td>
<td>监控目录或文件被删除</td>
</tr>
<tr>
<td><code>IN_MODIFY</code></td>
<td>✓</td>
<td>✓</td>
<td>文件被修改</td>
</tr>
<tr>
<td><code>IN_MOVE_SELF</code></td>
<td>✓</td>
<td>✓</td>
<td>监控目录或文件被移动</td>
</tr>
<tr>
<td><code>IN_MOVED_FROM</code></td>
<td>✓</td>
<td>✓</td>
<td>文件被移入监控目录</td>
</tr>
<tr>
<td><code>IN_MOVED_TO</code></td>
<td>✓</td>
<td>✓</td>
<td>文件被移出监控目录</td>
</tr>
<tr>
<td><code>IN_OPEN</code></td>
<td>✓</td>
<td>✓</td>
<td>文件被打开</td>
</tr>
<tr>
<td><code>IN_ALL_EVENTS</code></td>
<td>✓</td>
<td></td>
<td>以上所有输入事件的简写</td>
</tr>
<tr>
<td><code>IN_MOVE</code></td>
<td>✓</td>
<td></td>
<td><code>IN_MOVED_FROM | IN_MOVED_TO</code>的简写</td>
</tr>
<tr>
<td><code>IN_CLOSE</code></td>
<td>✓</td>
<td></td>
<td><code>IN_CLOSE_WRITE | IN_CLOSE_NOWRITE</code>的简写</td>
</tr>
<tr>
<td><code>IN_DONT_FOLLOW</code></td>
<td>✓</td>
<td></td>
<td>不要解引用符号链接 (Linux 2.6.15及以上版本)</td>
</tr>
<tr>
<td><code>IN_MASK_ADD</code></td>
<td>✓</td>
<td></td>
<td>将事件添加到<code>pathname</code>的监控位掩码</td>
</tr>
<tr>
<td><code>IN_ONESHOT</code></td>
<td>✓</td>
<td></td>
<td>仅监控1个事件的<code>pathname</code></td>
</tr>
<tr>
<td><code>IN_ONLYDIR</code></td>
<td>✓</td>
<td></td>
<td><code>pathname</code>不是目录时出错 (Linux 2.6.15及以上版本)</td>
</tr>
<tr>
<td><code>IN_IGNORED</code></td>
<td></td>
<td>✓</td>
<td>应用程序或内核取消监控</td>
</tr>
<tr>
<td><code>IN_ISDIR</code></td>
<td></td>
<td>✓</td>
<td><code>name</code>返回的文件名是目录</td>
</tr>
<tr>
<td><code>IN_Q_OVERFLOW</code></td>
<td></td>
<td>✓</td>
<td>事件队列溢出</td>
</tr>
<tr>
<td><code>IN_UNMOUNT</code></td>
<td></td>
<td>✓</td>
<td>对象所在的文件系统被卸载</td>
</tr>
</tbody>
</table>
<p>　　●
当权限、所有权、链接数、扩展属性、用户ID或组ID等文件元数据被修改时，将发生事件<code>IN_ATTRIB</code>。</p>
<p>　　● 当监控对象 (即文件或目录)
被删除时，将发生事件<code>IN_DELETE_SELF</code>。当监控目录下的文件被删除时，将发生事件<code>IN_DELETE</code>。</p>
<p>　　●
当监控对象被重命名时，将发生事件<code>IN_MOVE_SELF</code>。当监控目录下的文件被重命名时，将发生事件<code>IN_MOVED_FROM</code>和<code>IN_MOVED_TO</code>
(当目录下的文件名是旧文件名时，将发生前者；当目录下的文件名是新文件名时，将发生后者)。</p>
<p>　　●
<code>IN_DONT_FOLLOW</code>表示当<code>pathname</code>是符号链接时，不会解引用
(即监控对象是符号链接)。</p>
<p>　　●
当通过<code>inotify_add_watch()</code>修改监控项时，<code>mask</code>默认会替换当前位掩码。若指定了<code>IN_MASK_ADD</code>，则位掩码会修改为当前位掩码与<code>mask</code>进行或运算<code>|</code>得到的结果。</p>
<p>　　●
<code>IN_ONESHOT</code>允许应用程序监控单个事件的<code>pathname</code>。当发生该事件后，监控项会自动删除。</p>
<p>　　●
<code>IN_ONLYDIR</code>允许应用程序仅监控目录。若<code>pathname</code>不是目录，则<code>inotify_add_watch()</code>会出错
(<code>ENOTDIR</code>)。</p>
<h3 id="读取inotify事件">19.3 读取inotify事件</h3>
<p>　　在将监控项添加到监控列表后，应用程序可以通过<code>read()</code>从inotify文件描述符中读事件，以确定发生了哪些事件。若没有发生任何事件，则<code>read()</code>会阻塞，直到事件发生，除非文件描述符的状态标志<code>O_NONBLOCK</code>已启用
(在这种情况下，<code>read()</code>会导致错误<code>EAGAIN</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> wd;          <span class="comment">/* 发生事件的监控描述符 */</span></span><br><span class="line">    <span class="type">uint32_t</span> mask;   <span class="comment">/* 表示发生的事件的位 */</span></span><br><span class="line">    <span class="type">uint32_t</span> cookie; <span class="comment">/* 相关事件的cookie (用于rename()) */</span></span><br><span class="line">    <span class="type">uint32_t</span> len;    <span class="comment">/* 成员name的长度 */</span></span><br><span class="line">    <span class="type">char</span> name[];     <span class="comment">/* 可选的以字符\0结尾的文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　当事件发生后，每次调用<code>read()</code>都会将若干个结构体<code>inotify_event</code>存储在参数<code>buffer</code>指向的缓冲区中。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_19/an_input_buffer_containing_three_inotify_event_structures.svg" class="">
<p>　　成员<code>wd</code>表示发生事件的监控描述符，其值是之前调用<code>inotify_add_watch()</code>时返回的值。当通过1个inotify文件描述符监控多个文件或目录时，该成员很有用，它允许应用程序确定发生事件的文件或目录
(为此，应用程序需要维护用于关联监控描述符和路径名的数据结构)。</p>
<p>　　成员<code>mask</code>是表示发生的事件的位掩码，其取值范围与<code>inotify_add_watch()</code>的参数<code>mask</code>的相同，但含义有所不同：</p>
<p>　　● 当删除监控项时
(应用程序通过<code>inotify_rm_watch()</code>显式删除监控项，或者由于监控对象被删除或监控对象所在的文件系统被卸载而导致内核隐式删除监控项)，将会发生事件<code>IN_IGNORED</code>。当通过位<code>IN_ONESHOT</code>指定的事件自动删除时，<span
style="background-color: yellow">不会</span>发生事件<code>IN_IGNORED</code>。</p>
<p>　　●
若监控对象是目录，则<code>mask</code>会自动加上位<code>IN_ISDIR</code>。</p>
<p>　　●
当监控对象所在的文件系统被卸载时，会先发生事件<code>IN_UNMOUNT</code>，然后发生事件<code>IN_IGNORED</code>。</p>
<p>　　成员<code>cookie</code>用于将关联的事件绑定在一起。目前，只有重命名文件时，才会用到该成员。在这种情况下，文件的旧目录和新目录会分别发生事件<code>IN_MOVED_FROM</code>和<code>IN_MOVED_TO</code>
(若这2个目录是同一目录，则该目录会发生这2个事件)。这2个事件的成员<code>cookie</code>有相同的唯一值，以允许应用程序关联它们。</p>
<p>　　当监控目录下的文件发生事件时，成员<code>name</code>会包含该文件的以字符<code>\0</code>结尾的文件名。当监控对象发生事件时，不会使用成员<code>name</code>，并且成员<code>len</code>将会是0。</p>
<p>　　成员<code>len</code>表示实际为成员<code>name</code>分配的字节数。因为成员<code>name</code>和下一个结构体<code>inotify_event</code>之间会有填充字节，所以结构体<code>inotify_event</code>的长度是<code>sizeof(struct inotify_event) + len</code>。</p>
<p>　　若传递给<code>read()</code>的缓冲区不足以容纳1个结构体<code>inotify_event</code>，则<code>read()</code>会导致错误<code>EINVAL</code>
(在内核2.6.21之前，<code>read()</code>在这种情况下会返回0)。这可以通过为缓冲区分配<code>(sizeof(struct inotify_event) + NAME_MAX + 1)</code>字节解决。为缓冲区分配更大的空间允许应用程序通过单次调用<code>read()</code>来检索多个事件。</p>
<p>　　可以通过调用<code>ioctl(fd, FIONREAD, &amp;numbytes)</code>来获取当前可以从<code>fd</code>指定的inotify实例中读取的字节数。</p>
<p>　　从inotify文件描述符读出的事件会形成1个有序队列
(例如，当重命名文件后，事件<code>IN_MOVED_FROM</code>会先于<code>IN_MOVED_TO</code>读出)。该队列会占用内核内存，所以内核对inotify的操作施加了各种限制。超级用户可以通过目录<code>/proc/sys/fs/inotify</code>下的3个文件来配置这些限制：</p>
<p>　　●
<code>max_queued_events</code>表示通过<code>inotify_init()</code>创建的新inotify实例上的排队的事件数的上限。若达到该限制，则会发生事件<code>IN_Q_OVERFLOW</code>，并且溢出的事件会被丢弃。溢出的事件的成员<code>wd</code>是-1。该限制的默认值通常是16384。</p>
<p>　　●
<code>max_user_instances</code>表示每个实际用户ID可以创建的inotify实例数的限制。该限制的默认值通常是128。</p>
<p>　　●
<code>max_user_watches</code>表示每个实际用户ID可以创建的监控项数的限制。该限制的默认值通常是8192。</p>
<p>　　当在队列末尾添加新事件时，若新事件的成员<code>wd</code>、<code>mask</code>、<code>cookie</code>和<code>name</code>与队列末尾的事件的相同，则内核会合并这2个事件
(即新事件不会参与排队)。这是因为很多应用程序不需要知道同一事件的重复实例，并且这样做还可以减少事件队列占用的内核内存。但是，这表示无法通过inotify准确地获取复发事件的发生次数或频率。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* demo_inotify.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN (10 * (sizeof(struct inotify_event) + NAME_MAX + 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印结构体inotify_event的内容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">displayInotifyEvent</span><span class="params">(<span class="keyword">struct</span> inotify_event *i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    wd =%2d; &quot;</span>, i-&gt;wd);</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;cookie &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cookie =%4d; &quot;</span>, i-&gt;cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mask = &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_ACCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_ACCESS &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_ATTRIB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_ATTRIB &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_CLOSE_NOWRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_CLOSE_NOWRITE &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_CLOSE_WRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_CLOSE_WRITE &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_CREATE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_CREATE &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_DELETE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_DELETE &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_DELETE_SELF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_DELETE_SELF &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_IGNORED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_IGNORED &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_ISDIR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_ISDIR &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_MODIFY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_MODIFY &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_MOVE_SELF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_MOVE_SELF &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_MOVED_FROM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_MOVED_FROM &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_MOVED_TO)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_MOVED_TO &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_OPEN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_OPEN &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_Q_OVERFLOW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_Q_OVERFLOW &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_UNMOUNT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_UNMOUNT &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i-&gt;len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        name = %s\n&quot;</span>, i-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> inotifyFd, wd, j;</span><br><span class="line">    <span class="type">char</span> buf[BUF_LEN];</span><br><span class="line">    <span class="type">ssize_t</span> numRead;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> *<span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pathname... \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inotifyFd = inotify_init(); <span class="comment">/* 创建inotify实例 */</span></span><br><span class="line">    <span class="keyword">if</span> (inotifyFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;inotify_init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        wd = inotify_add_watch(inotifyFd, argv[j], IN_ALL_EVENTS);</span><br><span class="line">        <span class="keyword">if</span> (wd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;inotify_add_watch&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Watching %s using wd %d\n&quot;</span>, argv[j], wd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        numRead = read(inotifyFd, buf, BUF_LEN);</span><br><span class="line">        <span class="keyword">if</span> (numRead == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;read() from inotify fd returned 0!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %ld bytes from inotify fd\n&quot;</span>, (<span class="type">long</span>)numRead);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 处理read()通过缓冲区返回的所有事件 */</span></span><br><span class="line">        <span class="keyword">for</span> (p = buf; p &lt; buf + numRead;)</span><br><span class="line">        &#123;</span><br><span class="line">            event = (<span class="keyword">struct</span> inotify_event *)p;</span><br><span class="line">            displayInotifyEvent(event);</span><br><span class="line"></span><br><span class="line">            p += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inotify_event) + event-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了inotify的用法。首先，该程序会创建1个inotify文件描述符。然后，通过将命令行参数指定的文件添加到监控列表，每个监控项都会监控所有可能的事件。最后，进行无限循环，每次循环都会从inotify实例读1个缓冲区的事件，并且打印这些事件的相关信息。</p>
<h3 id="dnotify">19.4 dnotify</h3>
<p>　　相比inotify，dnotify存在很多限制。</p>
<p>　　●
dnotify将事件通知实现为信号，信号的使用让应用程序的设计更加复制。此外，调用程序可能会修改信号的处理，所以难以在库中使用dnotify。inotify机制没有使用信号。</p>
<p>　　●
dnotify的监控单元是目录。只要操作监控目录下的文件，应用程序就会收到事件通知。inotify允许监控目录或文件。</p>
<p>　　●
为了监控目录，dnotify需要应用程序打开监控目录的文件描述符，所以监控目录所在的文件系统无法卸载。此外，每个监控目录都需要1个文件描述符，所以应用程序会占用大量文件描述符。inotify没有使用引用监控对象的文件描述符，所以避免了这2个问题。</p>
<p>　　●
当监控目录下的文件被修改时，dnotify只会通知应用程序发生了事件，不会提供涉及该事件的文件的信息。此外，inotify提供的关于事件类型的信息比dnotify的更详细。</p>
<p>　　● 在某些情况下，dnotify不提供可靠的文件事件通知。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第15章 文件属性</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_15/</url>
    <content><![CDATA[<p>　　每个文件都有1个关联的用户ID和1个关联的组ID，这些ID决定文件的所有者和所属组。</p>
<p>　　当创建文件时，文件的用户ID取自进程的有效用户ID，组ID取自进程的有效组ID
(等同于System V的默认行为) 或父目录的组ID
(BSD行为)。新文件的组ID取决于多个因素，包括文件创建时的文件系统类型。</p>
<p>　　当通过命令<code>mount</code>挂载ext2文件系统时，可以指定选项<code>-o grpid</code>
(等同于<code>–o bsdgroups</code>) 或<code>-o nogrpid</code>
(等同于<code>–o sysvgroups</code>)。若没有指定这2个选项，则会默认指定<code>-o nogrpid</code>。当指定了<code>-o grpid</code>后，新文件会继承父目录的组ID。当指定了<code>-o nogrpid</code>后，若父目录启用了set-group-ID位
(通过命令<code>chmod g+s</code>)，则新文件会继承父目录的组ID；否则，新文件继承进程的有效组ID。因此，新文件的组ID可能与创建该文件的进程的所有组ID都不匹配。在撰写本书时，只有文件系统ext2、ext3、ext4和XFS
(Linux 2.6.14及以上版本)
支持挂载选项<code>grpid</code>和<code>nogrpid</code>。</p>
<p>　　当创建文件或目录时，内核会将<code>open()</code>
(或<code>creat()</code>)
或<code>mkdir()</code>的参数<code>mode</code>指定的权限授予新文件或目录。但是，这些设置可以通过<strong>文件模式创建掩码</strong>
(umask)
修改。umask是文件属性，它指定进程创建新文件或目录时应该始终禁用哪些权限位。</p>
<p>　　当创建符号链接时，所有用户都拥有该符号链接的所有权限，并且这些权限无法被禁用。</p>
<p>　　有些Linux文件系统允许为文件和目录设置各种i-node标志，该特性并非标准Linux扩展。</p>
<p>　　第1个支持i-node标志的Linux文件系统是ext2，所以i-node标志也称为<strong>ext2扩展文件属性</strong>。随后，其他文件系统也开始支持i-node标志，包括Btrfs、ext3、ext4、Reiserfs
(Linux 2.4.19及以上版本)、XFS (Linux 2.4.25及以上版本) 和JFS (Linux
2.6.17及以上版本)。此外，每个文件系统支持的i-node标志不同。</p>
<p>　　为了修改文件的i-node标志，进程的有效用户ID必须匹配文件的用户ID
(严格准确地说，对于Linux，应该是进程的文件系统用户ID必须匹配文件的用户ID，详情见9.3)，或者进程必须是特权进程
(能力<code>CAP_FOWNER</code>)。</p>
<p>　　现代BSD提供了与i-node标志类似的特性，即使用命令<code>chflags</code>或系统调用<code>chflags()</code>修改文件标志。</p>
<span id="more"></span>
<h3 id="检索文件信息">15.1 检索文件信息</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> st_dev;         <span class="comment">/* 文件所在设备的ID */</span></span><br><span class="line">    <span class="type">ino_t</span> st_ino;         <span class="comment">/* 文件的i-node号 */</span></span><br><span class="line">    <span class="type">mode_t</span> st_mode;       <span class="comment">/* 文件类型和权限 */</span></span><br><span class="line">    <span class="type">nlink_t</span> st_nlink;     <span class="comment">/* 指向文件的 (硬) 链接数 */</span></span><br><span class="line">    <span class="type">uid_t</span> st_uid;         <span class="comment">/* 文件所有者的用户ID */</span></span><br><span class="line">    <span class="type">gid_t</span> st_gid;         <span class="comment">/* 文件所属组的组ID */</span></span><br><span class="line">    <span class="type">dev_t</span> st_rdev;        <span class="comment">/* 设备特殊文件的ID */</span></span><br><span class="line">    <span class="type">off_t</span> st_size;        <span class="comment">/* 文件大小 (以字节为单位) */</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize; <span class="comment">/* I/O的最佳块大小 (以字节为单位) */</span></span><br><span class="line">    <span class="type">blkcnt_t</span> st_blocks;   <span class="comment">/* 已分配的块数 (块大小是512B) */</span></span><br><span class="line">    <span class="type">time_t</span> st_atime;      <span class="comment">/* 最后访问时间 */</span></span><br><span class="line">    <span class="type">time_t</span> st_mtime;      <span class="comment">/* 最后修改时间 */</span></span><br><span class="line">    <span class="type">time_t</span> st_ctime;      <span class="comment">/* 最后状态修改时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>stat()</code>、<code>lstat()</code>和<code>fstat()</code>可用于检索文件信息
(信息主要来自i-node)，结果存储在参数<code>statbuf</code>指向的结构体中。这3个系统调用唯一的区别是指定文件的方式：</p>
<p>　　●
<code>stat()</code>指定的是文件的路径名。当参数<code>pathanem</code>是符号链接时，会解引用。</p>
<p>　　●
<code>lstat()</code>指定文件的方式与<code>stat()</code>类似。但是，当参数<code>pathanem</code>是符号链接时，检索结果是符号链接的相关信息
(而非符号链接引用的文件的相关信息)。</p>
<p>　　● <code>fstat()</code>指定的是打开的文件描述符。</p>
<p>　　系统调用<code>stat()</code>和<code>lstat()</code>不需要文件的访问权限，但需要<code>pathname</code>中指定的所有父目录的执行
(搜索) 权限。</p>
<p>　　只要参数<code>fd</code>指定的文件描述符有效，系统调用<code>fstat()</code>就不会失败。</p>
<p>　　根据SUSv3，当对符号链接调用<code>lstat()</code>时，只需要在成员<code>st_mode</code>的文件类型部分和成员<code>st_size</code>中返回有效信息
(其他成员无需包含有效信息)。这让实现能够自由地维护这些成员，这可能是由于效率原因。早期UNIX标准的目的是允许将符号链接实现为i-node或目录中的条目。但是，若将符号链接实现为目录中的条目，则无法提供结构体<code>stat</code>中的所有成员
(同时代的所有主要UNIX实现都将符号链接实现为i-node)。对于Linux，对符号链接调用<code>lstat()</code>时，结构体<code>stat</code>中的所有成员都包含有效信息。</p>
<h4 id="设备idi-node号文件所有权和链接数">15.1.1
设备ID、i-node号、文件所有权和链接数</h4>
<p>　　成员<code>st_dev</code>是文件所在设备的ID
(主ID和次ID)。成员<code>st_ino</code>是文件的i-node号。这2个成员的组合可作为所有文件系统中的文件的唯一标识。</p>
<p>　　成员<code>st_dev</code>中的主ID和次ID可以通过接口<code>major()</code>和<code>minor()</code>来提取。对于早期glibc，这2个接口定义为宏。当定义了合适的宏后，这2个接口的定义会出现在头文件<code>sys/types.h</code>中。但是，这种行为在glibc
2.25中弃用，并且从glibc
2.28开始，<code>sys/types.h</code>不再提供这2个接口的定义。从glibc
2.3.3开始，这2个接口成为了特定于GNU的函数<code>gnu_dev_major()</code>和<code>gnu_dev_minor()</code>的别名。对于Linux，这2个接口定义在头文件<code>sys/sysmacros.h</code>中。</p>
<p>　　<code>major()</code>和<code>minor()</code>返回的整数值的长度因UNIX实现而异。</p>
<p>　　成员<code>st_uid</code>和<code>st_gid</code>分别是文件的所有者的用户ID和所属组的组ID。</p>
<p>　　成员<code>st_nlink</code>是指向文件的 (硬) 链接数。</p>
<h4 id="文件类型和权限">15.1.2 文件类型和权限</h4>
<p>　　成员<code>st_mode</code>是用于标识文件类型和指定文件权限的位掩码。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_15/layout_of_st_mode_bit_mask.svg" class="">
<p>　　文件类型部分可以通过与常量<code>S_IFMT</code>进行与运算<code>&amp;</code>来提取
(对于Linux，该部分由4位表示。但是，SUSv3没有指定如何表示该部分，所以细节因实现而异)。可以通过比较结果值来获取文件类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((statbuf.st_mode &amp; S_IFMT) == S_IFREG)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;regular file\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　因为这种操作很常见，所以出现了标准宏来简化这一操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (S_ISREG(statbuf.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;regular file\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　完整的文件类型常量和对应的宏如下
(定义在头文件<code>sys/stat.h</code>中)：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>判断宏</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_IFREG</code></td>
<td><code>S_ISREG()</code></td>
<td>常规文件</td>
</tr>
<tr>
<td><code>S_IFDIR</code></td>
<td><code>S_ISDIR()</code></td>
<td>目录</td>
</tr>
<tr>
<td><code>S_IFCHR</code></td>
<td><code>S_ISCHR()</code></td>
<td>字符设备</td>
</tr>
<tr>
<td><code>S_IFBLK</code></td>
<td><code>S_ISBLK()</code></td>
<td>块设备</td>
</tr>
<tr>
<td><code>S_IFIFO</code></td>
<td><code>S_ISFIFO()</code></td>
<td>有名管道或无名管道</td>
</tr>
<tr>
<td><code>S_IFSOCK</code></td>
<td><code>S_ISSOCK()</code></td>
<td>套接字</td>
</tr>
<tr>
<td><code>S_IFLNK</code></td>
<td><code>S_ISLNK()</code></td>
<td>符号链接</td>
</tr>
</tbody>
</table>
<p>　　SUSv3说明了以上所有文件类型宏，并且Linux也提供了这些宏。部分UNX实现定义了额外的文件类型
(例如，Solaris的门文件对应的常量是<code>S_IFDOOR</code>)。</p>
<p>　　最初的POSIX.1没有说明第1列展示的常量，但大多数UNIX实现都提供了这些常量。SUSv3要求提供这些常量。</p>
<p>　　为了在<code>sys/stat.h</code>中获取<code>S_IFSOCK</code>和<code>S_ISSOCK()</code>的定义，需要将定义宏<code>_BSD_SOURCE</code>或将<code>_XOPEN_SOURCE</code>定义为不小于500的值
(实际情况可能因glibc的版本而异，在某些情况下，<code>_XOPEN_SOURCE</code>必须定义为不小于600的值)。</p>
<p>　　成员<code>st_mode</code>的后12位定义了文件权限。用户类别、组类别和其他类别的读、写和执行权限占用后9位。</p>
<h4 id="文件大小已分配的块数和io的最佳块大小">15.1.3
文件大小、已分配的块数和I/O的最佳块大小</h4>
<p>　　对于常规文件，成员<code>st_size</code>是文件大小
(以字节为单位)。对于符号链接，该成员是符号链接指向的路径名的长度
(以字节为单元)。对于共享内存对象，该成员是对象的大小。</p>
<p>　　成员<code>st_blocks</code>表示分配给文件的块数
(块大小是512字节)，其中包括指针块
(见14.4)。将块的测量大小指定为512字节是由于历史原因，这是UNIX可用的所有文件系统的最小块大小。现代文件系统使用更大的逻辑块。例如，对于ext2，<code>st_blocks</code>的值总是2、4或8的整数倍，取决于逻辑块是1024、2048或4096字节。</p>
<p>　　SUSv3没有说明成员<code>st_blocks</code>的测量单元。大多数UNIX实现确实使用512字节的块，但HP-UX
11使用的是特定于文件系统的单元
(例如，在某些情况下，使用的是1024字节的块)。</p>
<p>　　若文件包含空洞，则成员<code>st_blocks</code>的值比成员<code>st_size</code>对应的块数更少。磁盘使用情况命令<code>du -k file</code>会显示实际分配给文件的空间
(以KB为单位)，即根据成员<code>st_blocks</code>计算而来的值
(而非<code>st_size</code>的值)。</p>
<p>　　成员<code>st_blksize</code>的名称存在一定的误导性，该成员的值并非底层文件系统的块大小，而是文件系统中的文件的I/O的最佳块大小
(以字节为单位)。执行I/O所用的块小于该成员的值时，I/O效率会更低
(见13.1)。该成员的值通常是4096。</p>
<h4 id="示例程序">15.1.4 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_stat.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysmacros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file_perms.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">displayStatInfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> stat *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File type: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (sb-&gt;st_mode &amp; S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> S_IFREG:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;regular file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;directory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;character device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;symbolic (soft) link\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFO or pipe\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unknown file type?\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Device containing i-node: major=%ld minor=%ld\n&quot;</span>,</span><br><span class="line">           (<span class="type">long</span>)major(sb-&gt;st_dev), (<span class="type">long</span>)minor(sb-&gt;st_dev));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I-node number: %ld\n&quot;</span>, (<span class="type">long</span>)sb-&gt;st_ino);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Mode: %lo (%s)\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)sb-&gt;st_mode, filePermStr(sb-&gt;st_mode, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sb-&gt;st_mode &amp; (S_ISUID | S_ISGID | S_ISVTX))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; special bits set: %s%s%s\n&quot;</span>,</span><br><span class="line">               (sb-&gt;st_mode &amp; S_ISUID) ? <span class="string">&quot;set-UID &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">               (sb-&gt;st_mode &amp; S_ISGID) ? <span class="string">&quot;set-GID &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">               (sb-&gt;st_mode &amp; S_ISVTX) ? <span class="string">&quot;sticky &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of (hard) links: %ld\n&quot;</span>, (<span class="type">long</span>)sb-&gt;st_nlink);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ownership: UID=%ld GID=%ld\n&quot;</span>, (<span class="type">long</span>)sb-&gt;st_uid, (<span class="type">long</span>)sb-&gt;st_gid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISCHR(sb-&gt;st_mode) || S_ISBLK(sb-&gt;st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Device number (st_rdev): major=%ld; minor=%ld\n&quot;</span>,</span><br><span class="line">               (<span class="type">long</span>)major(sb-&gt;st_rdev), (<span class="type">long</span>)minor(sb-&gt;st_rdev));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File size: %lld bytes\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)sb-&gt;st_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Optimal I/O block size: %ld bytes\n&quot;</span>, (<span class="type">long</span>)sb-&gt;st_blksize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;512B blocks allocated: %lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)sb-&gt;st_blocks);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Last file access: %s&quot;</span>, ctime(&amp;sb-&gt;st_atime));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Last file modification: %s&quot;</span>, ctime(&amp;sb-&gt;st_mtime));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Last status change: %s&quot;</span>, ctime(&amp;sb-&gt;st_ctime));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    Boolean statLink; <span class="comment">/* 若指定了&quot;-l&quot;，则为真 */</span></span><br><span class="line">    <span class="type">int</span> fname;        <span class="comment">/* argv[]中文件名参数的位置 */</span></span><br><span class="line"></span><br><span class="line">    statLink = (argc &gt; <span class="number">1</span>) &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-l&quot;</span>) == <span class="number">0</span>;</span><br><span class="line">    fname = statLink ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fname &gt;= argc || (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [-l] file\n&quot;</span></span><br><span class="line">                 <span class="string">&quot; -l = use lstat() instead of stat()\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (statLink)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lstat(argv[fname], &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;lstat&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (stat(argv[fname], &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    displayStatInfo(&amp;sb);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过<code>stat()</code>来检索命令行参数指定的文件的相关信息。若指定了命令行选项<code>-l</code>，则该程序会使用<code>lstat()</code>来检索符号链接的相关信息。</p>
<h3 id="文件时间戳">15.2 文件时间戳</h3>
<p>　　结构体<code>stat</code>的成员<code>st_atime</code>、<code>st_mtime</code>和<code>st_ctime</code>包含文件时间戳。这3个成员分别表示文件的最后访问时间、最后修改时间和最后状态修改时间
(即最后i-node修改时间)。</p>
<p>　　大多数原生Linux和UNIX文件系统都支持这些时间戳成员，但部分非UNIX文件系统不支持。</p>
<p>　　以下是本书中介绍的各种库函数和系统调用对文件时间戳所做的修改
(在某些情况下，也会修改父目录的时间戳)：</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 10%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>文件或目录的最后访问时间</th>
<th>文件或目录的最后修改时间</th>
<th>文件或目录的最后状态修改时间</th>
<th>父目录的最后访问时间</th>
<th>父目录的最后修改时间</th>
<th>父目录的最后状态修改时间</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>chmod()</code></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td><code>fchmod()</code>与之相同</td>
</tr>
<tr>
<td><code>chown()</code></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td><code>lchown()</code>和<code>fchown()</code>与之相同</td>
</tr>
<tr>
<td><code>exec()</code></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>link()</code></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>影响第2个参数的父目录</td>
</tr>
<tr>
<td><code>mkdir()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td><code>mkfifo()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td><code>mknod()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td><code>mmap()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td>最后修改时间和最后状态修改时间只会在更新MAP_SHARED映射时修改</td>
</tr>
<tr>
<td><code>msync()</code></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td>时间戳只会在修改文件时更新</td>
</tr>
<tr>
<td><code>open()</code>和<code>creat()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>创建文件</td>
</tr>
<tr>
<td><code>open()</code>和<code>creat()</code></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td>截断现有文件</td>
</tr>
<tr>
<td><code>pipe()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>read()</code></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>readv()</code>、<code>pread()</code>和<code>preadv()</code>与之相同</td>
</tr>
<tr>
<td><code>readdir()</code></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><code>readdir()</code>可能会缓冲目录条目；时间戳只会在读目录时更新</td>
</tr>
<tr>
<td><code>removexattr()</code></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td><code>fremovexattr()</code>和<code>lremovexattr()</code>与之相同</td>
</tr>
<tr>
<td><code>rename()</code></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>影响所有参数的父目录的时间戳；SUSv3没有说明文件的最后状态修改时间会更新，但部分UNIX实现依旧如此</td>
</tr>
<tr>
<td><code>rmdir()</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td><code>remove(directory)</code>与之相同</td>
</tr>
<tr>
<td><code>sendfile()</code></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>更新输入文件的时间戳</td>
</tr>
<tr>
<td><code>setxattr()</code></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td><code>fsetxattr()</code>和<code>lsetxattr()</code>与之相同</td>
</tr>
<tr>
<td><code>symlink()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>设置链接的时间戳 (而非目标文件)</td>
</tr>
<tr>
<td><code>truncate()</code></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td><code>ftruncate()</code>与之相同；时间戳只会在文件大小变更时更新</td>
</tr>
<tr>
<td><code>unlink()</code></td>
<td></td>
<td></td>
<td>✓</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td><code>remove(file)</code>与之相同；文件的最后状态修改时间只会在之前的链接数大于1时更新</td>
</tr>
<tr>
<td><code>utime()</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td><code>utimes()</code>、<code>futimes()</code>、<code>futimens()</code>、<code>lutimes()</code>和<code>utimensat()</code>与之相同</td>
</tr>
<tr>
<td><code>write()</code></td>
<td></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td><code>writev()</code>、<code>pwrite()</code>和<code>pwritev()</code>与之相同</td>
</tr>
</tbody>
</table>
<p>　　在大部分情况下，系统调用会将相关时间戳设置为当前时间。例外是<code>utime()</code>和类似的系统调用，这些系统调用会将最后访问时间和最后修改时间设置为指定时间。</p>
<p>　　大多数UNIX系统不会记录文件的创建时间。对于较新的BSD系统，文件创建时间会记录在结构体<code>stat</code>的成员<code>st_birthname</code>中。</p>
<p>　　对于Linux
2.6及以上版本，结构体<code>stat</code>中的3种时间戳的精度提高到了纳秒。对纳秒的支持提高了需要根据文件时间戳的相对顺序来做出决策的程序
(例如，<code>make</code>)
的准确性。SUSv3没有说明这3种时间戳对纳秒的支持，但SUSv4新增了该规定。</p>
<p>　　并非所有文件系统都支持纳秒时间戳。JFS、XFS、ext4和Btrfs支持，但ext2、ext3和Reiserfs不支持。</p>
<p>　　对于glibc API
(2.3及以上版本)，时间戳定义为结构体<code>timespec</code>，该结构体包含2个成员，分别表示秒和纳秒。定义了合适的宏后，结构体<code>stat</code>中的3个时间戳成员就会支持纳秒
(例如，成员<code>st_atim.tv_nsec</code>表示最后访问时间的纳秒部分)。</p>
<h4 id="utime和utimes">15.2.1
<code>utime()</code>和<code>utimes()</code></h4>
<p>　　存储在文件i-node中的最后访问时间和最后修改时间可以通过<code>utime()</code>或相关系统调用来显式修改。<code>tar</code>和<code>unzip</code>等使用这些系统调用的程序会在解压文件时重置文件时间戳。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *buf)</span>; <span class="comment">/* 成功时返回0，出错返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">time_t</span> actime;  <span class="comment">/* 访问时间 */</span></span><br><span class="line">    <span class="type">time_t</span> modtime; <span class="comment">/* 修改时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　参数<code>pathname</code>是文件路径名，若该参数是符号链接，则会解引用。参数<code>buf</code>是指向结构体<code>utimbuf</code>的指针或<code>NULL</code>，<code>utime()</code>也会依此做出相应的处理：</p>
<p>　　●
若<code>buf</code>是指向结构体<code>utimbuf</code>的指针，则最后访问时间和最后修改时间会修改为该结构体中的对应成员的值。对于这种情况，进程的有效用户ID必须匹配文件的用户ID，或者进程是特权进程
(能力<code>CAP_FOWNER</code>)。</p>
<p>　　●
若<code>buf</code>为<code>NULL</code>，则最后访问时间和最后修改时间都会设置为当前时间。对于这种情况，进程的有效用户ID必须匹配文件的用户ID，进程必须要有文件的写权限
(从逻辑角度，拥有文件的写权限的进程可能会使用副作用包括修改这些文件时间戳的系统调用)，或者进程是特权进程
(能力<code>CAP_FOWNER</code>或<code>CAP_DAC_OVERRIDE</code>)。</p>
<p>　　若需要修改最后访问时间或最后修改时间，则需要先通过<code>stat()</code>来检索这2个时间，用结果来初始化不需要修改的时间，然后将待修改的时间修改目标值
(若其他进程在这2步之间修改了时间戳，则可能导致竞争)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> <span class="title">utb</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stat(pathname, &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">utb.actime = sb.st_atime; <span class="comment">/* 不修改最后访问时间 */</span></span><br><span class="line">utb.modtime = sb.st_atime;</span><br><span class="line"><span class="keyword">if</span> (utime(pathname, &amp;utb) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;utime&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　若<code>utime()</code>成功，则会将最后状态修改时间修改为<span
style="background-color: yellow">当前时间</span>。</p>
<p>　　Linux也提供了系统调用<code>utimes()</code>
(源于BSD)、库函数<code>futimes()</code> (glibc 2.3及以上版本)
和<code>lutimes()</code> (glibc
2.6及以上版本)，这些函数与<code>utime()</code>类似。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">utimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> timeval tv[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">futimes</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> timeval tv[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lutimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> timeval tv[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
<p>　　不同于<code>utime()</code>，<code>utimes()</code>、<code>futimes()</code>和<code>lutimes()</code>允许指定的时间值达到微秒级别
(结构体<code>timeval</code>)。这提供了对Linux
2.6中提供的文件时间戳的纳秒精度的 (部分)
访问。新访问时间通过<code>tv[0]</code>指定，新修改时间通过<code>tv[1]</code>指定。</p>
<p>　　对于<code>utimes()</code>和<code>lutimes()</code>，指定文件的方式都是路径名
(参数<code>pathname</code>)。但是，当<code>pathname</code>是符号链接时，则前者会解引用，而后者不会，所以后者修改的是链接的时间戳
(而非指向的文件的时间戳)。</p>
<p>　　对于<code>futimes()</code>，指定文件的方式是文件描述符
(参数<code>fd</code>)。</p>
<h4 id="utimensat和futimens">15.2.2
<code>utimensat()</code>和<code>futimens()</code></h4>
<p>　　系统调用<code>utimensat()</code> (内核2.6.22及以上版本)
和库函数<code>futimens()</code> (glibc 2.6及以上版本)
为设置文件的最后访问时间和最后修改时间提供了扩展功能。这些函数具有以下优势：</p>
<p>　　● 允许指定的时间值达到纳秒级别。</p>
<p>　　● 允许独立设置时间戳 (即1次设置1个)。</p>
<p>　　● 允许独立地将任意时间戳设置为当前时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 700 <span class="comment">/* 或将_POSIX_C_SOURCE定义为不小于200809的值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">utimensat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line">    <span class="type">long</span> tv_nsec;  <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>utimensat()</code>会将参数<code>pathname</code>指定的文件的时间戳修改为参数<code>times</code>指定的时间戳。若<code>times</code>为<code>NULL</code>，则最后访问时间和最后修改时间都会修改为当前时间；若<code>times</code>不为<code>NULL</code>，则最后访问时间会修改为<code>times[0]</code>，最后修改时间会修改为<code>times[1]</code>。</p>
<p>　　若需要将某个文件时间戳指定为当前时间，则只需要将对应的<code>tv_nsec</code>指定为<code>UTIME_NOW</code>；若不需要某个文件时间戳，则只需要将对应的<code>tv_nsec</code>指定为<code>UTIME_OMIT</code>。这2种情况都会忽略对应的<code>tv_sec</code>的值。</p>
<p>　　参数<code>dirfd</code>可以指定为<code>AT_FDCWD</code>
(若<code>pathname</code>是符号链接，则会解引用)
或引用目录的文件描述符。</p>
<p>　　参数<code>flags</code>可以指定为0或<code>AT_SYMLINK_NOFOLLOW</code>
(若<code>pathname</code>是符号链接，则不会解引用，所以修改的是链接的时间戳)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">times</span>[2];</span></span><br><span class="line"></span><br><span class="line">times[<span class="number">0</span>].tv_sec = <span class="number">0</span>;</span><br><span class="line">times[<span class="number">0</span>].tv_nsec = UTIME_NOW;</span><br><span class="line">times[<span class="number">1</span>].tv_sec = <span class="number">0</span>;</span><br><span class="line">times[<span class="number">1</span>].tv_nsec = UTIME_OMIT;</span><br><span class="line"><span class="keyword">if</span> (utimensat(AT_FDCWD, <span class="string">&quot;myfile&quot;</span>, times, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;utimensat&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会将最后访问时间设置为当前时间，并且不修改最后修改时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">futimens</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　库函数<code>futimens()</code>会将参数<code>fd</code>引用的文件的时间戳修改为参数<code>times</code>指定的时间戳。<code>times</code>的用法与<code>utimensat()</code>的相同。</p>
<p>　　SUSv3没有说明<code>utimensat()</code>和<code>futimens()</code>，但SUSv4说明了它们。</p>
<h3 id="文件所有权">15.3 文件所有权</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>chown()</code>会将参数<code>pathname</code>指定的文件的用户ID和组ID修改为参数<code>owner</code>指定的用户ID和参数<code>group</code>指定的组ID。若无需修改用户ID，则可以将<code>owner</code>指定为-1；若无需修改组ID，则可以将<code>group</code>指定为-1。</p>
<p>　　当<code>pathname</code>是符号链接时，对于Linux
2.2以下的版本，<code>chown()</code>不会解引用
(修改的是链接的用户ID和组ID)；对于Linux
2.2及以上版本，<code>chown()</code>会解引用，并且加入了新系统调用<code>lchown()</code>来替代<code>chown()</code>的旧行为。</p>
<p>　　只有特权进程 (能力<code>CAP_CHOWN</code>)
才能通过<code>chown()</code>来修改文件的用户ID。非特权进程可以通过<code>chown()</code>来将属于该进程的文件
(进程的有效用户ID匹配文件的用户ID)
的组ID修改为该进程所属的组的组ID。特权进程可以将文件的组ID修改为任意值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500 <span class="comment">/* 或#define _BSD_SOURCE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lchown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchown</span><span class="params">(<span class="type">int</span> fd, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>lchown()</code>和<code>fchown()</code>与<code>chown()</code>类似。<code>fchown()</code>指定文件的方式是文件描述符
(参数<code>fd</code>)。</p>
<p>　　当文件的用户ID或组ID被修改后，set-user-ID位和set-group-ID位都会被禁用。这是为了确保普通用户不会启用可执行文件的set-user-ID位
(和set-group-ID位)，然后将该可执行文件的用户ID (或组ID)
修改为特权用户的用户ID
(或特权组的组ID)，从而在执行该可执行文件时获取特权。</p>
<p>　　当修改文件的用户ID或组ID时，若group-execute位已被禁用或修改对象是目录，则set-group-ID位不会被禁用。无论是哪种情况，set-group-ID位会用于创建set-group-ID程序之外的目的：</p>
<p>　　●
若group-execute位已被禁用，则set-group-ID位可用于启用强制文件锁定。</p>
<p>　　●
若修改对象是目录，则set-group-ID位可用于控制该目录下创建的文件的所有权。</p>
<p>　　SUSv3没有说明特权用户修改文件的用户ID或组ID时是否禁用set-user-ID位和set-group-ID位。Linux
2.0在这种情况下会禁用这些位，但部分早期2.2内核 (直到2.2.12)
不会禁用这些位。后来的2.2内核在这种情况下又会禁用这些位，并且后续的内核版本一直如此
(但是，在登录root后，若先调用<code>chown()</code>，然后通过命令<code>chmod</code>修改文件的所有权，则命令<code>chmod</code>会通过<code>chown()</code>来重新启用set-user-ID位和set-group-ID位)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_chown.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uid_t</span> uid;</span><br><span class="line">    <span class="type">gid_t</span> gid;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    Boolean errFnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s owner group [file...]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  owner or group can be &#x27;-&#x27;, meaning leave unchanged\n&quot;</span>,</span><br><span class="line">                 argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        uid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        uid = userIdFromName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (uid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;No such user (%s)&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;-&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        gid = groupIdFromName(argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (gid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;No such group (%s)&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改剩余参数指定的文件的所有权 */</span></span><br><span class="line">    errFnd = FALSE;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (chown(argv[j], uid, gid) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errMsg(<span class="string">&quot;chown: %s&quot;</span>, argv[j]);</span><br><span class="line">            errFnd = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(errFnd ? EXIT_FAILURE : EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>chown()</code>的用法，它允许修改任意数量的文件的所有权
(通过命令行参数指定)。</p>
<h3 id="文件权限">15.4 文件权限</h3>
<p>　　在15.1.2中提到过，结构体<code>stat</code>的成员<code>st_mode</code>的后12位定义了文件权限，其中的前3位
(U、G和T) 分别是<span
style="background-color: yellow">set-user-ID位</span>、<span
style="background-color: yellow">set-groupr-ID位</span>和<span
style="background-color: yellow">粘滞位</span>，后9位定义了各种类别的用户对文件的访问权限。权限类别分为所有者类别
(也称为用户类别，<code>chmod</code>等命令中使用的<code>u</code>引用的就是该类别)、组类别和其他类别。</p>
<p>　　● 所有者类别包括文件的所有者。</p>
<p>　　● 组类别包括与文件属于相同组的用户。</p>
<p>　　● 其他类别包括其他用户。</p>
<p>　　所有权限类别都有读权限、写权限和执行权限。</p>
<p>　　● 读权限表示文件的内容可读。</p>
<p>　　● 写权限表示文件的内容可写。</p>
<p>　　● 执行权限表示文件的内容可执行
(即该文件是程序或脚本)。执行脚本需要同时拥有读和执行权限。</p>
<h4 id="常规文件的权限">15.4.1 常规文件的权限</h4>
<p>　　可以通过命令<code>ls -l</code>来显示文件的权限和所有权：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l myscript.sh</span></span><br><span class="line">-rwxr-x--- 1 mtk users 1667 Jan 15 09:22 myscript.sh</span><br></pre></td></tr></table></figure>
<p>　　<code>myscript.sh</code>的文件权限为<code>rwxr-x---</code>
(第1个连字符<code>-</code>表示文件类型是常规文件)。为了解析该字符串，可以将这9个字符平均分为3组，每组的3个字符分别代表读、写和执行权限
(若对应的字符不是连字符，则表示已启用)，这3个组分别表示用户类别、组类别和其他类别。因此，用户类别拥有该文件的所有访问权限，组类别拥有该文件的读权限和执行权限，其他类别没有访问权限。</p>
<p>　　头文件<code>sys/stat.h</code>中定义了用于与结构体<code>stat</code>中的成员<code>st_mode</code>进行与运算<code>&amp;</code>来检测是否启用对应的权限位的常量
(这些常量是通过引用头文件<code>fcntl.h</code>来定义的)，如下所示：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>八进制值</th>
<th>权限位</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_ISUID</code></td>
<td>04000</td>
<td>set-user-ID位</td>
</tr>
<tr>
<td><code>S_ISGID</code></td>
<td>02000</td>
<td>set-group-ID位</td>
</tr>
<tr>
<td><code>S_ISVTX</code></td>
<td>01000</td>
<td>粘滞位</td>
</tr>
<tr>
<td><code>S_IRWXU</code></td>
<td>0700</td>
<td>用户类别读、写和执行权限位</td>
</tr>
<tr>
<td><code>S_IRUSR</code></td>
<td>0400</td>
<td>用户类读位权限位</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td>0200</td>
<td>用户类别写权限位</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td>0100</td>
<td>用户类别执行权限位</td>
</tr>
<tr>
<td><code>S_IRWXG</code></td>
<td>070</td>
<td>组类别读、写和执行权限位</td>
</tr>
<tr>
<td><code>S_IRGRP</code></td>
<td>040</td>
<td>组类别读权限位</td>
</tr>
<tr>
<td><code>S_IWGRP</code></td>
<td>020</td>
<td>组类别写权限位</td>
</tr>
<tr>
<td><code>S_IXGRP</code></td>
<td>010</td>
<td>组类别执行权限位</td>
</tr>
<tr>
<td><code>S_IRWXO</code></td>
<td>07</td>
<td>其他类别读、写和执行权限位</td>
</tr>
<tr>
<td><code>S_IROTH</code></td>
<td>04</td>
<td>其他类别读权限位</td>
</tr>
<tr>
<td><code>S_IWOTH</code></td>
<td>02</td>
<td>其他类别写权限位</td>
</tr>
<tr>
<td><code>S_IXOTH</code></td>
<td>01</td>
<td>其他类别执行权限位</td>
</tr>
</tbody>
</table>
<p>　　常量<code>S_ISVTX</code>的名称来源于粘滞位的别名<span
style="background-color: yellow">保存的文本</span>位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file_perms.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FILE_PERMS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PERMS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FP_SPECIAL 1 <span class="comment">/* 表示返回字符串中包含set-user-ID、set-group-ID位和粘滞位 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">filePermStr</span><span class="params">(<span class="type">mode_t</span> perm, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file_perms.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file_perms.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_SIZE sizeof(<span class="string">&quot;rwxrwxrwx&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回ls -l风格的文件权限位掩码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param perm 文件权限位掩码</span></span><br><span class="line"><span class="comment"> * @param flags</span></span><br><span class="line"><span class="comment"> * @return char*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">filePermStr</span><span class="params">(<span class="type">mode_t</span> perm, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> str[STR_SIZE];</span><br><span class="line">    <span class="built_in">snprintf</span>(str, STR_SIZE, <span class="string">&quot;%c%c%c%c%c%c%c%c%c&quot;</span>,</span><br><span class="line">             (perm &amp; S_IRUSR) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, (perm &amp; S_IWUSR) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">             (perm &amp; S_IXUSR) ? (((perm &amp; S_ISUID) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;s&#x27;</span> : <span class="string">&#x27;x&#x27;</span>) : (((perm &amp; S_ISUID) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;S&#x27;</span> : <span class="string">&#x27;-&#x27;</span>),</span><br><span class="line">             (perm &amp; S_IRGRP) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, (perm &amp; S_IWGRP) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">             (perm &amp; S_IXGRP) ? (((perm &amp; S_ISGID) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;s&#x27;</span> : <span class="string">&#x27;x&#x27;</span>) : (((perm &amp; S_ISGID) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;S&#x27;</span> : <span class="string">&#x27;-&#x27;</span>),</span><br><span class="line">             (perm &amp; S_IROTH) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, (perm &amp; S_IWOTH) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">             (perm &amp; S_IXOTH) ? (((perm &amp; S_ISVTX) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;t&#x27;</span> : <span class="string">&#x27;x&#x27;</span>) : (((perm &amp; S_ISVTX) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;T&#x27;</span> : <span class="string">&#x27;-&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例声明了函数<code>filePermStr()</code>，该函数会根据参数<code>perm</code>指定的文件权限位掩码来返回对应的静态分配的字符串表示
(命令<code>ls</code>风格)。若在参数<code>flags</code>中指定了标志<code>FP_SPECIAL</code>，则返回字符串会包含set-user-ID位、set-group-ID位和粘滞位。</p>
<h4 id="目录的权限">15.4.2 目录的权限</h4>
<p>　　目录的权限体系与文件的相同，但3个权限位的含义不同：</p>
<p>　　● 读权限表示可以列出 (通过命令<code>ls</code>) 目录的内容
(即文件名)。</p>
<p>　　● 写权限表示可以在目录下创建和删除文件
(文件删除自己不需要任何权限)。</p>
<p>　　●
执行权限表示可以访问目录下的文件，所以该权限也称为搜索权限。</p>
<p>　　当执行验证目录的读权限的操作时，有些Linux发行版可能会将命令<code>ls</code>视为默认包含需要目录下的文件的i-node信息的访问权限的标志
(例如，<code>-F</code>)，但这需要目录的执行权限。为了防止这种情况，可以指定命令的路径名
(<code>/bin/ls</code>)。</p>
<p>　　当访问文件时，除了需要文件的读权限之外，还需要路径名中的<span
style="background-color: yellow">所有目录</span>的执行权限。例如，读文件<code>/home/mtk/x</code>需要<code>/</code>、<code>/mtk</code>和<code>/home/mtk</code>的执行权限。若当前工作目录是<code>/home/mtk/sub1</code>，并且需要访问相对路径名<code>../sub2/x</code>，则需要<code>/home/mtk</code>和<code>/home/mtk/sub2</code>的执行权限。</p>
<p>　　当在目录下创建和删除文件时，需要该目录的写和执行权限。</p>
<p>　　拥有能力<code>CAP_DAC_READ_SEARCH</code>的进程总是拥有文件的读权限和目录的执行权限。拥有能力<code>CAP_DAC_OVERRIDE</code>的进程总是拥有文件的读和写权限，并且当文件类型是目录或至少有1个权限类别拥有执行权限时，拥有该能力的进程也会拥有文件的执行权限。</p>
<h4 id="权限检查算法">15.4.3 权限检查算法</h4>
<p>　　当为访问文件或目录的系统调用指定路径名时，内核会检查文件权限。当指定的路径名包含目录前缀时，除了检查文件权限之外，还会检查前缀中的所有目录的执行权限。权限检查涉及进程的有效ID和辅助组ID。</p>
<p>　　当通过<code>open()</code>打开文件后，内核将不再对后续使用结果文件描述符的系统调用
(例如，<code>read()</code>、<code>write()</code>、<code>fstat()</code>、<code>fcntl()</code>和<code>mmap()</code>)
执行权限检查。</p>
<p>　　内核的权限检查遵循如下规则：</p>
<p>　　1)
若进程是特权进程，则授予所有访问权限。当文件不是目录，并且至少有1个权限类别拥有权限时，才会授予特权进程相同的权限
(对于有些UNIX实现，特权进程可以直接执行文件)。当文件是目录时，总是会授予特权进程执行权限。</p>
<p>　　2)
若进程的有效用户ID与文件的用户ID相同，则根据文件的用户类别的权限授予访问权限
(例如，若文件的用户类别的读权限已启用，则进程拥有读权限；否则，进程没有读权限)。</p>
<p>　　3)
若进程的有效组ID或辅助组ID与文件的组ID相同，则根据文件的组类别的权限授予访问权限。</p>
<p>　　4) 否则， 根据文件的其他类别的权限授予访问权限。</p>
<p>　　对用户类别、组类别和其他类别的判断依次进行，并且找到符合的规则后就立即停止检查。</p>
<p>　　这些文件权限和所有权信息维护在文件i-node中，所有引用相同i-node的链接共享这些信息。</p>
<p>　　Linux
2.6提供了<strong>访问控制列表</strong>，这使得可以基于每个用户和每个组设置文件权限。若文件有访问控制列表，则会使用以上权限检查算法的修改版本。</p>
<h4 id="检查文件可访问性">15.4.4 检查文件可访问性</h4>
<p>　　除了根据有效ID和辅助组ID决定进程的文件访问权限之外，有些程序
(例如，set-user-ID程序和set-group-ID程序)
也会根据实际ID来检查文件可访问性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>; <span class="comment">/* 拥有所有访问权限时返回0，否则返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>access()</code>会根据进程的实际ID (和辅助组ID)
检查参数<code>pathname</code>指定的文件的可访问性
(若<code>pathname</code>是符号链接，则会解引用)。</p>
<p>　　参数<code>mode</code>是若干个常量进行或运算<code>|</code>得到的结果，这些常量如下：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>F_OK</code></td>
<td>文件是否存在</td>
</tr>
<tr>
<td><code>R_OK</code></td>
<td>文件是否可读</td>
</tr>
<tr>
<td><code>W_OK</code></td>
<td>文件是否可写</td>
</tr>
<tr>
<td><code>X_OK</code></td>
<td>文件是否可执行</td>
</tr>
</tbody>
</table>
<p>　　若<code>pathname</code>指定的文件拥有<code>mode</code>指定的所有权限，则<code>access()</code>返回0；若缺少权限或出错，则<code>access()</code>返回-1。</p>
<p>　　对<code>access()</code>的调用与后续操作之间的时间间隔表示无法保证<code>access()</code>返回的信息在后续操作时依旧有效
(无论该间隔多短)，这可能会导致应用程序设计出现安全漏洞。</p>
<p>　　假设set-user-ID-root程序先通过<code>access()</code>检查文件可访问性，然后操作文件
(例如，<code>open()</code>或<code>exec()</code>)。若<code>pathname</code>是符号链接，并且恶意用户修改了该链接，使其在执行操作前引用其他文件，则set-user-ID-root程序可能会对没有权限的文件执行操作。因此，尽量避免使用<code>access()</code>。对于这里描述的情况，可以通过临时修改set-user-ID-root程序的有效用户ID来执行预期的操作，然后检查返回值和<code>errno</code>来确定操作是否由于权限问题而失败。</p>
<p>　　glibc提供了与<code>access()</code>类似的非标准函数<code>euidaccess()</code>
(等同于<code>eaccess()</code>)，该函数会根据进程的有效用户ID来检查文件可访问性。</p>
<h4 id="set-user-id位set-group-id位和粘滞位">15.4.5
set-user-ID位、set-group-ID位和粘滞位</h4>
<p>　　除了用于创建特权程序，set-user-ID位 (位<code>04000</code>)
和set-group-ID位 (位<code>02000</code>)
还可用于控制在带有选项<code>nogrpid</code>挂载的目录下创建的文件的所属组和启用文件强制锁定。</p>
<p>　　对于较旧的UNIX实现，粘滞位 (位<code>01000</code>)
通常用于提高程序运行速度。若启用了程序的粘滞位，则程序第1次运行时会在交换空间中保留1份副本，所以后续运行该程序时加载会更快。现代UNIX实现的内存管理系统更复杂，所以这种用法已经过时。</p>
<p>　　对于Linux和现代UNIX实现，粘滞位的用法大不相同。对于目录，粘滞位相当于<span
style="background-color: yellow">限制性删除</span>位。对目录设置粘滞位后，当且仅当非特权进程拥有该目录的写权限和拥有文件或目录时，才能取消链接
(<code>unlink()</code>和<code>rmdir()</code>) 或重命名
(<code>rename()</code>) 该目录下的文件
(拥有能力<code>CAP_FOWNER</code>的进程无需拥有文件或目录)。这使得多个用户共享相同的目录成为可能
(每个用户只能创建和删除自己的文件)。因此，通常会启用目录<code>/tmp</code>的粘滞位。</p>
<p>　　可以通过命令<code>chmod +t file</code>或系统调用<code>chomd()</code>来启用文件的粘滞位。当文件的粘滞位启用后，命令<code>ls -l</code>显示的结果中会在其他类别的执行权限位显示大写或小写的t
(若其他类别的执行权限位已启用，则显示为t；否则，显示为T)。</p>
<h4 id="umask">15.4.6 umask</h4>
<p>　　进程通常会继承父shell的umask，所以shell内置命令<code>umask</code>
(修改shell的umask) 可用于控制shell执行的程序的umask。</p>
<p>　　大多数shell的初始文件会将默认umask设置为八进制值022
(----w--w-)，该值表示组类别和其他类别的写权限应该被禁用。因此，若<code>open()</code>的参数<code>mode</code>指定为0666
(启用所有用户的读写权限)，则文件所有者拥有新创建的文件的读写权限，其他用户仅用于读权限
(rw-r--r--)。若<code>mkdir()</code>的参数<code>mode</code>指定为0777
(启用所有用户的所有权限)，文件所有者拥有新创建的文件的所有权限，其他用户拥有读和执行权限
(rwxr-xr-x)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>; <span class="comment">/* 返回umask的旧值 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>umask()</code>会将进程的umask修改为参数<code>mask</code>指定的值。<code>mask</code>可以指定为15.4.1的表中列出的常量进行或运算<code>|</code>得到的结果。</p>
<p>　　<code>umask()</code>不会失败，总是会返回umask的旧值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_umask.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file_perms.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYFILE <span class="string">&quot;myfile&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYDIR <span class="string">&quot;mydir&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PERMS (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIR_PERMS (S_IRWXU | S_IRWXG | S_IRWXO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UMASK_SETTING (S_IWGRP | S_IXGRP | S_IWOTH | S_IXOTH)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="type">mode_t</span> u;</span><br><span class="line"></span><br><span class="line">    umask(UMASK_SETTING);</span><br><span class="line"></span><br><span class="line">    fd = open(MYFILE, O_RDWR | O_CREAT | O_EXCL, FILE_PERMS);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open-%s&quot;</span>, MYFILE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mkdir(MYDIR, DIR_PERMS) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;mkdir-%s&quot;</span>, MYDIR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u = umask(<span class="number">0</span>); <span class="comment">/* 检索 (和清除) umask值 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stat(MYFILE, &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;stat-%s&quot;</span>, MYFILE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Requested file perms: %s\n&quot;</span>, filePermStr(FILE_PERMS, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process umask: %s\n&quot;</span>, filePermStr(u, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Actual file perms: %s\n\n&quot;</span>, filePermStr(sb.st_mode, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stat(MYDIR, &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;stat-%s&quot;</span>, MYDIR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Requested dir. perms: %s\n&quot;</span>, filePermStr(DIR_PERMS, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process umask: %s\n&quot;</span>, filePermStr(u, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Actual dir. perms: %s\n&quot;</span>, filePermStr(sb.st_mode, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlink(MYFILE) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errMsg(<span class="string">&quot;unlink-%s&quot;</span>, MYFILE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rmdir(MYDIR) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errMsg(<span class="string">&quot;rmdir-%s&quot;</span>, MYDIR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>umask()</code>如何与<code>open()</code>和<code>makdir()</code>一起使用。</p>
<h4 id="修改文件权限">15.4.7 修改文件权限</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>chmod()</code>会将参数<code>pathname</code>指定的文件的权限修改为参数<code>mode</code>指定的权限
(若<code>pathname</code>是符号链接，则会解引用)。</p>
<p>　　参数<code>mode</code>可以是八进制值或15.4.1的表中列出的常量进行或运算<code>|</code>得到的结果。为了修改文件的权限，需要进程是特权进程
(能力<code>CAP_FOWNER</code>) 或进程的有效用户ID匹配文件的用户ID。</p>
<p>　　为了修改文件权限的特定位，必须先通过<code>stat()</code>检索现有权限和修改位，然后通过<code>chmod()</code>更新权限：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="type">mode_t</span> mode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stat(<span class="string">&quot;myfile&quot;</span>, &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">mode = (sb.st_mode | S_IWUSR) &amp; ~S_IROTH;</span><br><span class="line"><span class="keyword">if</span> (chmod(<span class="string">&quot;myfile&quot;</span>, mode) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例等同于命令<code>chmod u+w,o-r myfile</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500 <span class="comment">/* 或#define _BSD_SOURCE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fchmod</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>fchmod()</code>与<code>chmod()</code>相似，除了指定文件的方式是文件描述符
(参数<code>fd</code>)。</p>
<p>　　如前所述，新文件的组ID可能不同于创建该文件的进程的所有组ID，所以非特权进程
(没有能力<code>CAP_FSETID</code>)
对此类文件调用<code>chmod()</code>或<code>fchmod()</code>时内核会清除set-group-ID位
(防止用户为不属于自己的组创建set-group-ID程序)。</p>
<h3 id="i-node标志">15.5 i-node标志</h3>
<p>　　对于shell，i-node标志可以通过命令<code>chattr</code>和<code>lsattr</code>设置和查看。对于程序，i-node标志可以通过系统调用<code>ioctl()</code>
(见4.5) 检索和修改。</p>
<p>　　大部分i-node标志设计为供常规文件使用，但其中的部分i-node标志也对目录生效。以下列出了各种可用的i-node标志对应的用于<code>ioctl()</code>的标志
(定义在头文件<code>linux/fs.h</code>中)
和用于命令<code>chattr</code>的选项：</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 16%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr>
<th>标志</th>
<th><code>chattr</code>选项</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FS_APPEND_FL</code></td>
<td><code>a</code></td>
<td>仅限于文件末尾 (需要特权)</td>
</tr>
<tr>
<td><code>FS_COMPR_FL</code></td>
<td><code>c</code></td>
<td>启用文件压缩 (未实现)</td>
</tr>
<tr>
<td><code>FS_DIRSYNC_FL</code></td>
<td><code>D</code></td>
<td>同步目录更新 (Linux 2.6及以上版本)</td>
</tr>
<tr>
<td><code>FS_IMMUTABLE_FL</code></td>
<td><code>i</code></td>
<td>禁用文件修改 (需要特权)</td>
</tr>
<tr>
<td><code>FS_JOURNAL_DATA_FL</code></td>
<td><code>j</code></td>
<td>启用数据日志 (需要特权)</td>
</tr>
<tr>
<td><code>FS_NOATIME_FL</code></td>
<td><code>A</code></td>
<td>不更新文件最后访问时间</td>
</tr>
<tr>
<td><code>FS_NODUMP_FL</code></td>
<td><code>d</code></td>
<td>在使用dump备份文件系统时跳过该文件</td>
</tr>
<tr>
<td><code>FS_NOTAIL_FL</code></td>
<td><code>t</code></td>
<td>禁用尾部打包</td>
</tr>
<tr>
<td><code>FS_SECRM_FL</code></td>
<td><code>s</code></td>
<td>安全删除 (未实现)</td>
</tr>
<tr>
<td><code>FS_SYNC_FL</code></td>
<td><code>S</code></td>
<td>同步文件 (包括目录) 更新</td>
</tr>
<tr>
<td><code>FS_TOPDIR_FL</code></td>
<td><code>T</code></td>
<td>以Orlov处理顶层目录 (Linux 2.6及以上版本)</td>
</tr>
<tr>
<td><code>FS_UNRM_FL</code></td>
<td><code>u</code></td>
<td>文件无法删除 (未实现)</td>
</tr>
</tbody>
</table>
<p>　　●
<code>FS_APPEND_FL</code>表示只有指定了标志<code>O_APPEND</code>后，才能打开文件来进行写入
(强制所有文件更新添加到文件末尾)。只有特权进程
(能力<code>CAP_LINUX_IMMUTABLE</code>) 才能设置该标志。</p>
<p>　　●
<code>FS_COMPR_FL</code>表示以压缩格式将文件存储在磁盘上，所有主要原生Linux文件系统都没有将该特性作为标准特性
(有些软件包为ext2和ext3实现了该特性)。虽然压缩的成本较低，但由于压缩和解压所用的CPU开销以及压缩文件带来的负面影响
(通过<code>lseek()</code>随机访问文件内容将不再简单)，文件压缩对于很多应用程序都是不可取的。</p>
<p>　　● <code>FS_DIRSYNC_FL</code>表示同步目录更新
(例如，<code>open(pathname, O_CREAT)</code>、<code>link()</code>、<code>unlink()</code>和<code>mkdir()</code>)，这与13.3中介绍的文件更新同步机制类似。与同步文件更新一样，同步目录更新也会带来性能影响。</p>
<p>　　● <code>FS_IMMUTABLE_FL</code>表示禁用文件修改，即文件的数据
(<code>write()</code>和<code>truncate()</code>) 和元数据
(例如，<code>chmod()</code>、<code>chown()</code>、<code>unlink()</code>、<code>link()</code>、<code>rename()</code>、<code>rmdir()</code>、<code>utime()</code>、<code>setxattr()</code>和<code>removexattr()</code>)
都无法被修改。只有特权进程 (能力<code>CAP_LINUX_IMMUTABLE</code>)
才能设置该标志。当该标志启用后，特权进程也无法修改文件的数据和元数据。</p>
<p>　　●
<code>FS_JOURNAL_DATA_FL</code>表示启用数据日志。支持该标志的文件系统只有ext3和ext4，这2个文件系统提供了3种级别的日志：journal、ordered和writeback。这3种模式的日志都会记录文件元数据，但只有journal模式才会记录文件数据。对于ordered或writeback模式的文件系统，特权进程
(能力<code>CAP_SYS_RESOURCE</code>)
能够通过设置该标志来启用文件级别的数据更新日志。</p>
<p>　　●
<code>FS_NOATIME_FL</code>表示不更新文件最后访问时间。这样就无需在访问文件时更新文件的i-node，从而提高I/O性能。</p>
<p>　　●
<code>FS_NODUMP_FL</code>表示使用dump备份文件系统时跳过该文件。</p>
<p>　　●
<code>FS_NOTAIL_FL</code>表示禁用尾部打包，支持该标志的文件系统只有Reiserfs
(见14.6)。也可以在通过命令<code>mount</code>挂载Reiserfs时指定选项<code>-notail</code>来禁用尾部打包。</p>
<p>　　●
<code>FS_SECRM_FL</code>表示安全删除文件，即删除前先覆盖，以防止磁盘扫描程序读取或重新创建该文件，但这是未实现的特性。实际上，安全删除的问题相当复杂，这可能需要对磁性介质进行多次写入才能安全地擦除以前记录的数据。</p>
<p>　　●
<code>FS_SYNC_FL</code>表示同步文件更新。当对文件启用该标志后，所有对文件的写操作都会同步
(如同调用<code>open()</code>时指定标志<code>O_SYNC</code>)。该标志对目录的效果等同于<code>FS_DIRSYNC_FL</code>。</p>
<p>　　● <code>FS_TOPDIR_FL</code>表示以<span
style="background-color: yellow">Orlov块分配策略</span>处理该目录。Orlov策略是受到BSD启发的ext2块分配策略的修改版，该策略会试图提高将相关文件
(例如，单个目录中的文件)
放置在磁盘上彼此靠近的位置的几率，进而缩短磁盘寻道时间。该标志仅对ext2、ext3和ext4生效。</p>
<p>　　●
<code>FS_UNRM_FL</code>表示允许恢复已删除的文件，但这是未实现的特性，因为可以在内核外实现文件恢复机制。</p>
<p>　　对于Linux
2.6.19以下的版本，这些标志并非定义在头文件<code>linux/fs.h</code>中。相反，这些标志定义在一组特定于文件系统的头文件中，带有特定于文件系统的前缀，但值相同
(例如，ext2的标志<code>EXT2_APPEND_FL</code>定义在头文件<code>linux/ext2_fs.h</code>中，Reiserfs的标志<code>REISERFS_APPEND_FL</code>定义在头文件<code>linux/reiser_fs.h</code>)。因此，对于不提供头文件<code>linux/fs.h</code>的旧系统，可以引用这些头文件，然后使用特定于文件系统的名称。</p>
<p>　　当对目录设置i-node标志后，在该目录下创建的文件和子目录通常会继承i-node标志。该规则存在以下例外：</p>
<p>　　● 标志<code>FS_DIRSYNC_FL</code> (命令<code>chattr +D</code>)
仅适用于目录，所以只有子目录才会继承该标志。</p>
<p>　　● 当标志<code>FS_IMMUTABLE_FL</code> (命令<code>chattr +i</code>)
应用于目录后，文件和子目录都不会继承该标志，因为该标志会禁止在目录下创建新文件或目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, FS_IOC_GETFLAGS, &amp;attr) == <span class="number">-1</span>) <span class="comment">/* 获取当前i-node标志 */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">attr |= FS_NOATIME_FL;</span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, FS_IOC_SETFLAGS, &amp;attr) == <span class="number">-1</span>) <span class="comment">/* 更新i-node标志 */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于程序，i-node标志可以通过<code>ioctl()</code>的操作<code>FS_IOC_GETFLAGS</code>和<code>FS_IOC_SETFLAGS</code>
(这些常量定义在头文件<code>linux/fs.h</code>) 来检索和修改。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第18章 目录和链接</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_18/</url>
    <content><![CDATA[<p>　　<strong>目录</strong>以与常规文件类似的方式存储在文件系统中，但在以下2个方面不同：</p>
<p>　　● 目录的i-node条目的文件类型与常规文件的不同。</p>
<p>　　●
目录是带有特殊组织结构的文件。从本质角度，目录是1个由文件名和i-node号组成的表。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_18/relationship_between_i-node_and_directory_structures_for_the_password_file.svg" class="">
<p>　　如图所示，这里展示了文件系统i-node表的部分内容以及为密码文件维护的相关目录文件。</p>
<p>　　i-node表的<span
style="background-color: yellow">起始编号是1</span>，因为i-node字段为0的目录条目是未使用的条目。i-node
1用于记录文件系统中的坏块。文件系统的根目录 (<code>/</code>)
总是存储在i-node 2中，所以内核知道从哪里开始解析路径名。</p>
<p>　　文件的i-node条目中不包含文件名，文件名只是目录列表中定义文件名称的映射。因此，可以在不同或相同的目录下创建多个引用同一i-node的文件名，这些名称称为<strong>链接</strong>或<strong>硬链接</strong>。所有原生Linux和UNIX文件系统都支持硬链接，但很多非原生UNIX文件系统不支持硬链接
(例如，Microsoft的VFAT和NTFS)。</p>
<p>　　对于shell，
可以通过命令<code>ln</code>来为已存在的文件创建硬链接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -n <span class="string">&#x27;It is good to collect things,&#x27;</span> &gt; abc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -li abc</span></span><br><span class="line">122232 -rw-r--r-- 1 mtk users 29 Jun 15 17:07 abc</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> abc xyz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27; but it is better to go on walks.&#x27;</span> &gt;&gt; xyz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> abc</span></span><br><span class="line">It is good to collect things, but it is better to go on walks.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -li abc xyz</span></span><br><span class="line">122232 -rw-r--r-- 2 mtk users 63 Jun 15 17:07 abc</span><br><span class="line">122232 -rw-r--r-- 2 mtk users 63 Jun 15 17:07 xyz</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> abc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -li xyz</span></span><br><span class="line">122232 -rw-r--r-- 1 mtk users 63 Jun 15 17:07 xyz</span><br></pre></td></tr></table></figure>
<p>　　在第8行的命令<code>ls -li</code>的输出中，文件名<code>abc</code>和<code>xyz</code>引用的是相同的i-node
(相同的文件)，所以引用该i-node的链接数是2。当删除文件名<code>abc</code>后，文件本身和另一个文件名<code>xyz</code>依然存在。</p>
<span id="more"></span>
<p>　　当且仅当引用i-node的链接数为0时，i-node条目和数据块才会删除。文件的所有文件名
(硬链接)
都是等效的，不存在优先级。此外，无法为链接数为0的i-node创建硬链接。</p>
<p>　　除了维护引用i-node的链接数，内核还会计算文件的打开描述符数。若引用文件的所有硬链接都已删除，但有些进程仍然持有引用该文件的文件描述符，则该文件的删除会推迟到所有引用该文件的文件描述符都关闭。</p>
<p>　　硬链接有2个限制，但这2个限制都可以通过使用符号链接来规避：</p>
<p>　　● 因为目录条目 (硬链接)
仅通过i-node号引用文件，并且同一文件系统内的i-node号不会重复，所以硬链接和引用的文件必须位于同一文件系统。</p>
<p>　　● 无法为目录创建硬链接，这是为了防止循环链接
(可能会导致系统程序出错)。</p>
<p>　　早期UNIX实现允许超级用户为目录创建硬链接，因为这些实现没有提供系统调用<code>mkdir()</code>。相反，目录通过系统调用<code>mknod()</code>创建，然后引用条目<code>.</code>和<code>..</code>的硬链接也会被创建。尽管如今不再需要该特性，但有些现代UNIX实现保留了该特性来实现向后兼容。此外，可以通过绑定挂载来实现类似引用目录的硬链接的效果。</p>
<p>　　每个进程都有1个<strong>根目录</strong>，即解析绝对路径名的起点
(<code>/</code>)。进程的根目录默认是文件系统的实际根目录。新进程会继承父进程的根目录。可以通过特定于Linux的符号链接<code>/proc/PID/root</code>来获取所有进程的根目录。</p>
<h3 id="符号链接">18.1 符号链接</h3>
<p>　　<strong>符号链接</strong> (或<strong>软链接</strong>)
是特殊文件类型，其内容是其他文件的路径名。符号链接引用的路径名可以是绝对路径名或相对路径名
(相对路径名的解析基于符号链接本身的位置)。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_18/representation_of_hard_and_symbolic_links.svg" class="">
<p>　　如图所示，这里有2个引用同一文件的硬链接
(<code>/home/erena/this</code>和<code>/home/allyn/that</code>)
和1个符号链接
(<code>/home/kiran/other</code>)，符号链接的内容是<code>/home/erena/this</code>。</p>
<p>　　对于shell，可以通过命令<code>ln -s</code>来创建符号链接。在命令<code>ls -F</code>的输出中，符号链接的末尾会带有字符<code>@</code>。</p>
<p>　　不同于硬链接，符号链接不会计入引用i-node的链接数 (所以i-node
61的链接数是2)。当符号链接引用的文件被删除后，符号链接依然会存在，但无法对其解引用，这种符号链接称为<strong>死链接</strong>
(对死链接解引用会导致错误<code>ENOENT</code>)。此外，可以为不存在的文件创建符号链接。</p>
<p>　　符号链接引用的是路径名，所以符号链接可以引用其他文件系统的文件。此外，符号链接可以引用目录。<code>find</code>和<code>tar</code>等工具可以区分硬链接和符号链接，并且默认不会解引用
(避免陷入通过符号链接创建的循环引用)。</p>
<p>　　符号链接可以连锁
(例如，<code>a</code>是引用<code>b</code>的符号链接，而<code>b</code>是引用<code>c</code>的符号链接)。当在文件相关的系统调用中指定符号链接链时，内核会多次解引用以达到最终文件。</p>
<p>　　很多系统调用会对符号链接解引用，所以这些系统调用会对符号链接引用的文件执行操作。有些系统调用不会对符号链接解引用，所以这些系统调用会直接对符号链接执行操作。</p>
<p>　　路径名的目录部分中的所有符号链接总是会被解引用。对于路径名<code>/somedir/somesubdir/file</code>，若<code>somedir</code>、<code>somesudir</code>和<code>file</code>是符号链接，则<code>somedir</code>和<code>somesudir</code>总是会被解引用，而<code>file</code>是否会被解引用取决于系统调用。</p>
<p>　　大多数操作都会忽略符号链接的所有权和权限
(符号链接的所有权限始终启用)。当对启用粘滞位的目录下的符号链接进行重命名或删除操作时，符号链接的所有权才有意义。</p>
<p>　　符号链接最早出现在4.2BSD。尽管POSIX.1-1990没有说明符号链接，但SUSv1详细说明了符号链接，所以SUSv3也详细说明了符号链接。SUSv3要求实现对路径名中的每个符号链接都进行至少<code>_POSIX_SYMLOOP_MAX</code>次解引用，<code>_POSIX_SYMLOOP_MAX</code>的值是8。但是，在内核2.6.18之前，Linux要求对符号链接链中的每个符号链接的解引用次数不超过5次。从内核2.8.18开始，Linux实现了SUSv3要求的至少8次解引用。Linux还要求对路径名中的所有符号链接的解引用次数之和不超快40次，这是为防止符号链接循环和很长的符号链接链导致解引用时内核代码栈溢出。</p>
<p>　　ext2、ext3和ext4等UNIX文件系统会优化符号链接的存储。当符号链接的内容字符串足够短时，i-node中存储数据块指针的位置会直接用于存储符号链接的内容，这可以节省磁盘空间和加快符号链接内容的访问。</p>
<h3 id="创建和删除硬链接">18.2 创建和删除硬链接</h3>
<p>　　系统调用<code>link()</code>和<code>unlink()</code>会创建和删除硬链接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>link()</code>会为参数<code>oldpath</code>指定的文件创建硬链接，硬链接的路径名由参数<code>newpath</code>指定。若<code>newpath</code>已存在，则会导致错误<code>EEXIST</code>。</p>
<p>　　对于Linux，<code>link()</code>不会解引用。若<code>oldpath</code>是符号链接，则<code>newpath</code>会是引用该符号链接的硬链接
(变为与<code>oldpath</code>引用同一文件的符号链接)。这种行为不符合SUSv3，因为SUSv3要求所有解析路径名的函数都应该解引用，除非另有指定。大多数UNIX实现都以SUSv3指定的行为实现该函数。Solaris是例外，它提供的<code>link()</code>的默认行为与Linux的相同，但可以通过合适的编译选项来将其行为修改为符合SUSv3的行为。因此，在开发可移植应用程序时应避免将<code>oldpath</code>指定为符号链接。</p>
<p>　　SUSv4认识到了现有实现之间的不一致，并且说明<code>link()</code>是否解引用是由实现定义的。SUSv4还添加了系统调用<code>linkat()</code>的规范，<code>linkat()</code>与<code>link()</code>类似，但可以通过额外的参数<code>flags</code>来控制是否解引用。</p>
<p>　　系统调用<code>unlink()</code>会删除参数<code>pathname</code>指定的硬链接。当<code>pathname</code>指定的该链接是引用文件的最后1个硬链接时，<code>unlink()</code>会删除文件。若<code>pathname</code>不存在，则会导致错误<code>ENOENT</code>。</p>
<p>　　<code>unlink()</code>不会解引用。若<code>pathname</code>是符号链接，则会删除符号链接
(而非符号链接引用的文件)。</p>
<p>　　SUSv3规定，若<code>pathname</code>指定的是目录，则会导致<code>EPERM</code>。但是，对于Linux，这种情况会导致错误<code>EISDIR</code>
(LSB明确允许这种行为)。可移植应用程序在面对这种情况时应该准备好处理这2种错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_unlink.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_SIZE 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, j, numBlocks;</span><br><span class="line">    <span class="type">char</span> shellCmd[CMD_SIZE]; <span class="comment">/* 传递给system()的命令 */</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];      <span class="comment">/* 写入文件的随机字节 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s temp-file [num-1kB-blocks] \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numBlocks = (argc &gt; <span class="number">2</span>) ? getInt(argv[<span class="number">2</span>], GN_GT_0, <span class="string">&quot;num-1kB-blocks&quot;</span>) : <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_WRONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlink(argv[<span class="number">1</span>]) == <span class="number">-1</span>) <span class="comment">/* 删除硬链接 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numBlocks; j++) <span class="comment">/* 写入数据 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(fd, buf, BUF_SIZE) != BUF_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;partial/failed write&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(shellCmd, CMD_SIZE, <span class="string">&quot;df -k `dirname %s`&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    system(shellCmd); <span class="comment">/* 查看文件系统的空间使用情况 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(fd) == <span class="number">-1</span>) <span class="comment">/* 删除文件 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;********** Closed file descriptor\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(shellCmd); <span class="comment">/* 查看文件系统的空间使用情况 */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>link()</code>和<code>unlink()</code>的用法。该程序有2个命令行参数。第1个命令行参数是文件名，程序会创建并打开该文件，再立即取消链接文件名。尽管文件名已消失，但文件依旧存在。然后，程序会向文件中写入随机数据，写入的数据量可以通过可选的第2个命令行参数指定。此时，程序会通过命令<code>df</code>来打印文件系统的空间使用情况。最后，程序会关闭文件描述符并再次打印文件系统的空间使用情况。</p>
<h3 id="修改文件名">18.3 修改文件名</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>rename()</code>会将参数<code>pathname</code>指定的已存在的路径名重命名为参数<code>newpath</code>指定的路径名。该函数只会控制目录条目，不会移动文件数据。此外，该函数不会影响引用文件的其他硬链接和文件描述符。</p>
<p>　　<code>rename()</code>的行为遵循以下规则：</p>
<p>　　● 若<code>newpath</code>存在，则进行覆盖。</p>
<p>　　●
若<code>newpath</code>和<code>oldpath</code>引用的文件相同，则不会有任何效果
(调用会成功)。该规则源于原始BSD实现，可能是为了简化内核必须执行的检查，以保证<code>rename("x", "x")</code>、<code>rename("x", "./x")</code>和<code>rename("x", "somedir/../x")</code>等调用不会删除文件。</p>
<p>　　●
<code>rename()</code>不会对其参数解引用。若<code>oldpath</code>是符号链接，则符号链接会被重命名。若<code>newpath</code>是符号链接，重命名<code>oldpath</code>时会将其视为常规路径名
(即删除现有的<code>newpath</code>)。</p>
<p>　　●
若<code>oldpath</code>指定的是除目录之外的文件，则<code>newpath</code>不能指定为目录的路径名
(否则，会导致错误<code>EISDIR</code>)。为了将文件重命名为其他目录下的位置
(即移动到其他目录下)，<code>newpath</code>必须包含新文件名
(即<code>rename("sub1/x", "sub2/y")</code>)。</p>
<p>　　●
可以通过将<code>oldpath</code>指定为目录的路径名来重命名目录。在这种情况下，<code>newpath</code>必须不存在或是空目录
(否则，会分别导致错误<code>ENOTDIR</code>和<code>ENOTEMPTY</code>)。</p>
<p>　　●
若<code>oldpath</code>是目录，则<code>newpath</code>的目录部分不能与<code>oldpath</code>的目录部分存在重叠。例如，无法将目录<code>/home/mtk</code>重命名为<code>/home/mtk/bin</code>
(错误<code>EINVAL</code>)。</p>
<p>　　●
<code>oldpath</code>和<code>newpath</code>引用的文件必须位于同一文件系统
(否则，会导致错误<code>EXDEV</code>)，因为目录是引用与该目录位于同一文件系统的i-node的硬链接列表，而<code>rename()</code>只是控制目录条目。</p>
<h3 id="创建符号链接和读取符号链接的内容">18.4
创建符号链接和读取符号链接的内容</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filepath, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *buffer, <span class="type">size_t</span> bufsiz)</span>; <span class="comment">/* 成功时返回放入buffer的字节数，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>symlink()</code>会为参数<code>filepath</code>指定的文件创建符号链接，其路径名由参数<code>linkpath</code>指定。<code>filepath</code>可以是绝对路径名或相对路径名。若<code>linkpath</code>已存在，则会出错
(并将<code>errno</code>设置为<code>EEXIST</code>)。</p>
<p>　　系统调用<code>readlink()</code>会将参数<code>pathname</code>指定的符号链接的内容的副本放置在参数<code>buffer</code>指定的缓冲区中，该缓冲区的大小由参数<code>bufsiz</code>指定。</p>
<p>　　若<code>readlink()</code>成功，则会返回实际放入缓冲区的字节数。若内容字符串的长度大于<code>bufsiz</code>，则会被截断
(并返回<code>bufsiz</code>的值)。</p>
<p>　　放入<code>buffer</code>的字符串没有结尾的字符<code>\0</code>，所以无法直接区分<code>buffer</code>中存储的字符串是截断后的内容字符串还是内容字符串刚好填充<code>buffer</code>。这可以通过重新分配更大的<code>buffer</code>并再次调用<code>readlink()</code>来区分。或者，也可以通过常量<code>PATH_MAX</code>来调整<code>pathname</code>来调整路径名的长度上限。</p>
<p>　　SUSv3定义了限制<code>SYMLINK_MAX</code>，该限制定义了符号链接的内容字符串的最大长度，其值至少是255字节。但是，在撰写本书时，Linux没有实现该限制。</p>
<p>　　SUSv2要求<code>readlink()</code>的返回值类型是<code>int</code>，很多现代实现
(和Linux上的较旧的glibc版本)
仍然遵循该规范。SUSv3将其返回值类型修改为<code>ssize_t</code>。</p>
<h3 id="创建和删除目录">18.5 创建和删除目录</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>mkdir()</code>会创建新目录，其路径名由参数<code>pathname</code>指定
(绝对路径名或相对路径名)，权限由<code>mode</code>指定。若<code>pathname</code>存在，则会导致错误<code>EEXIST</code>。</p>
<p>　　<code>mode</code>的值是15.4.1的表格中的常量进行或运算<code>|</code>得到的结果。与<code>open()</code>的参数<code>mode</code>相同，这里的<code>mode</code>可以指定为八进制值，并且也会受限于umask。此外，set-user-ID位
(<code>S_ISUID</code>) 始终关闭，因为该权限位对目录无效。</p>
<p>　　若<code>mode</code>中指定了粘滞位
(<code>S_ISVTX</code>)，则新目录的该权限位会启用。</p>
<p>　　<code>mode</code>中的set-group-ID位 (<code>S_ISGID</code>)
会被忽略。相反，若父目录的set-group-ID位已启用，则新创建的子目录的该权限位也会启用。</p>
<p>　　SUSv3明确说明<code>mkdir()</code>如何处理set-user-ID位、set-group-ID位和粘滞位由实现决定。对于有些UNIX实现，新目录的这3个权限位始终关闭。</p>
<p>　　新目录仅包含引用目录本身的硬链接<code>.</code>和引用父目录的硬链接<code>..</code>
(SUSv3没有说明这种行为，但要求实现能够正确解析<code>.</code>和<code>..</code>)。</p>
<p>　　<code>mkdir()</code>只会创建<code>pathname</code>的基础部分，所以<code>mkdir("aaa/bbb/ccc", mode)</code>只会在目录<code>aaa</code>和<code>aaa/bbb</code>都存在时才会成功。这对应命令<code>mkdir</code>的默认行为，但命令<code>mkdir</code>提供了选项<code>-p</code>来创建所有中间目录
(若不存在)。</p>
<p>　　glibc提供了与<code>mkstemp()</code>相似的函数<code>mkdtemp(template)</code>，该函数会创建1个名称唯一的目录，所有者拥有该目录的所有权限，其他用户没有权限。<code>mkdtemp()</code>会将<code>template</code>更新为实际的目录名。SUSv3没有说明该函数，而且并非所有UNIX实现都提供了该函数，但SUSv4详细说明了该函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>rmdir()</code>会删除参数<code>pathname</code>指定的空目录
(绝对路径名或相对路径名)。若<code>pathname</code>的基础部分是符号链接，则会导致错误<code>ENOTDIR</code>。</p>
<h3 id="删除文件或目录">18.6 删除文件或目录</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　库函数<code>remove()</code>会删除<code>pathname</code>指定的文件或空目录。</p>
<p>　　若<code>pathname</code>是文件，则<code>remove()</code>会调用<code>unlink()</code>；若<code>pathname</code>是空目录，则<code>remove()</code>会调用<code>rmdir()</code>。</p>
<p>　　与<code>unlink()</code>和<code>rmdir()</code>相同，<code>remove()</code>不会解引用。因此，若<code>pathname</code>是符号链接，则<code>remove()</code>会删除符号链接本身。</p>
<p>　　<code>remove()</code>是为标准C库函数开发的，而UNIX系统和非UNIX系统都实现了标准C库。大多数非UNIX系统都不支持硬链接，所以无法通过<code>unlink()</code>删除文件。</p>
<h3 id="读取目录">18.7 读取目录</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dirpath)</span>; <span class="comment">/* 成功时返回目录流句柄，出错时返回NULL */</span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">fdopendir</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 成功时返回目录流句柄，出错时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>; <span class="comment">/* 成功时返回描述下一个目录条目的静态分配的结构体，遇到EOF或出错时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewinddir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dirfd</span><span class="params">(DIR *dirp)</span>; <span class="comment">/* 成功时返回文件描述符，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">ino_t</span> d_ino;   <span class="comment">/* 文件i-node号 */</span></span><br><span class="line">    <span class="type">char</span> d_name[]; <span class="comment">/* 以字符\0结尾的文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　库函数<code>opendir()</code>会打开参数<code>dirpath</code>指定的目录，然后返回指向结构体<code>DIR</code>的指针。该结构体称为<strong>目录流</strong>，每个目录流都有<span
style="background-color: yellow">1个关联的文件描述符</span>。</p>
<p>　　<code>opendir()</code>会自动启用与目录流关联的文件描述符的close-on-exec标志
(<code>FD_CLOEXEC</code>)，以保证调用<code>exec()</code>时该文件描述符会自动关闭
(SUSv3要求如此)。</p>
<p>　　当从<code>opendir()</code>返回后，目录流会重新定位到目录列表的第1个条目。</p>
<p>　　库函数<code>fdopendir()</code>与<code>opendir()</code>类似，不同之处在于指定目录的方式是文件描述符
(参数<code>fd</code>)。若该函数成功，则<code>fd</code>指定的文件描述符将由系统控制，所以程序不应该再访问该文件描述符。SUSv4详细说明了该函数
(SUSv3没有说明该函数)。</p>
<p>　　库函数<code>readdir()</code>会从参数<code>dirp</code>指定的目录流中读取下一个条目，然后返回指向静态分配的结构体<code>dirent</code>的指针
(每次调用该函数都会覆盖该结构体)。</p>
<p>　　这里展示的结构体<code>dirent</code>忽略了非标准成员。这些非标准成员中最有趣的成员是<code>d_type</code>，BSD衍生系统仍然提供该成员
(其他UNIX实现不提供该成员)，该成员的值表示成员<code>d_name</code>对应的文件的类型，例如，<code>DT_REG</code>表示常规文件，<code>DT_DIR</code>表示目录，<code>DT_LNK</code>表示符号链接，<code>DT_FIFO</code>表示有名管道
(这些名称与15.4.1的表格中的常量名类似)。使用该成员可以节约通过调用<code>lstat()</code>来检索文件类型的成本。在撰写本书时，只有ext2、ext3、ext4和Btrfs完全支持该成员。</p>
<p>　　可以通过调用<code>stat()</code>并将其参数<code>pathname</code>指定为<code>opendir()</code>的参数<code>dirpath</code>加上斜杠<code>/</code>和成员<code>d_name</code>的值来获取成员<code>d_name</code>的更多信息。</p>
<p>　　<code>readdir()</code>返回的文件名按照它们出现在目录的顺序排序，这取决于文件系统将文件添加到目录的顺序和删除文件后如何填充目录列表的空白
(命令<code>ls -f</code>列出文件的顺序与<code>readdir()</code>检索文件的顺序相同)。</p>
<p>　　可以通过函数<code>scandir()</code>来检索与程序员定义的条件匹配的排序后的文件列表。SUSv3没有说明该函数，但大部分UNIX实现都提供了该函数。</p>
<p>　　若遇到EOF或出错，则<code>readdir()</code>会返回<code>NULL</code>，但后者会设置<code>errno</code>。</p>
<p>　　若通过<code>readdir()</code>扫描目录期间目录内容发生变化，则程序可能不会看到这些变化。SUSv3明确规定，若上一次调用<code>readdir()</code>后该目录下新增或删除了文件，则本次调用<code>readdir()</code>的返回值是否包含这些变化是不确定的，但除此之外的其他文件一定会返回。</p>
<p>　　库函数<code>rewinddir()</code>会将参数<code>dirp</code>指定的目录流重新定位到目录列表的第1个条目。</p>
<p>　　库函数<code>closedir()</code>会关闭参数<code>dirp</code>指定的目录流，并且释放相关资源。</p>
<p>　　库函数<code>dirfd()</code>会返回与参数<code>dirp</code>指定的目录流关联的文件描述符。BSD等少部分UNIX实现提供了该函数。SUSv3没有说明该函数，但SUSv4详细说明了该函数。</p>
<p>　　SUSv3还详细说明了库函数<code>telldir()</code>和<code>seekdir()</code>，这2个库函数允许随机访问目录流。</p>
<h4 id="示例程序">18.7.1 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* list_files.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 列出dirpath下的所有文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param dirpath</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">listFiles</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dirpath)</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *dirp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dp</span>;</span></span><br><span class="line">    Boolean isCurrent; <span class="comment">/* 若dirpaht是&quot;.&quot;，则为真 */</span></span><br><span class="line"></span><br><span class="line">    isCurrent = <span class="built_in">strcmp</span>(dirpath, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dirp = opendir(dirpath);</span><br><span class="line">    <span class="keyword">if</span> (dirp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errMsg(<span class="string">&quot;opendir failed on &#x27;%s&#x27;&quot;</span>, dirpath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历目录下的所有条目，打印目录和文件名 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = <span class="number">0</span>; <span class="comment">/* 区分出错和遇到EOF */</span></span><br><span class="line">        dp = readdir(dirp);</span><br><span class="line">        <span class="keyword">if</span> (dp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 跳过.和.. */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isCurrent)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s/&quot;</span>, dirpath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dp-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;readdir&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (closedir(dirp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errMsg(<span class="string">&quot;closedir&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [dir...]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) <span class="comment">/* 若没有指定参数，则使用当前目录 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        listFiles(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (argv++; *argv; argv++)</span><br><span class="line">        &#123;</span><br><span class="line">            listFiles(*argv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过库函数<code>opendir()</code>、<code>readdir()</code>和<code>closedir()</code>来列出命令行参数指定的目录下的所有文件
(若未指定命令行参数，则使用当前目录)。</p>
<h4 id="readdir_r">18.7.2 <code>readdir_r()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readdir_r</span><span class="params">(DIR *dirp, <span class="keyword">struct</span> dirent *entry, <span class="keyword">struct</span> dirent **result)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>readdir_r()</code>是<code>readdir()</code>的可重入版本
(现已弃用)。该函数会将参数<code>dirp</code>指定的目录流的下一个条目存储在参数<code>entry</code>指向的结构体中
(由调用者分配)，参数<code>result</code>是指向<code>entry</code>的指针。</p>
<p>　　若遇到EOF，则<code>readdir_r()</code>会返回0，并将<code>*result</code>设置为<code>NULL</code>。若出错，则<code>readdir_r()</code>会返回与某个<code>errno</code>值对应的正错误号。</p>
<p>　　对于Linux，结构体<code>dirent</code>的成员<code>d_name</code>是256字节的数组
(足以容纳最长的文件名)。有些UNIX实现也将该成员定义为256字节的数组，但SUSv3没有说明这一点。此外，有些UNIX将该成员定义为1字节的数组，让调用者来分配结构体<code>dirent</code>的大小。当这样做时，应该将该成员调整为比常量<code>NAME_MAX</code>大1的值
(为了结尾的字符<code>\0</code>)。可移植应用程序应该使用如下方式分配结构体<code>dirent</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entryp</span>;</span></span><br><span class="line"><span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">len = offsetof(<span class="keyword">struct</span> dirent, d_name) + NAME_MAX + <span class="number">1</span>;</span><br><span class="line">entryp = <span class="built_in">malloc</span>(len);</span><br><span class="line"><span class="keyword">if</span> (entryp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　通过宏<code>offsetof()</code>
(定义在头文件<code>stddef.h</code>中)
来避免成员<code>d_name</code>之前的成员的数量和大小的所有特定于实现的依赖关系
(成员<code>d_name</code>始终是结构体<code>dirent</code>的最后1个成员)。宏<code>offsetof()</code>有2个参数，第1个参数是结构体类型，第2个参数该结构体的成员名，返回值是该成员相对于结构体起始处的的偏移量
(类型是<code>size_t</code>)。这里必须要使用该宏，因为编译器可能会为了满足数据类型的对齐要求，在结构体中插入填充字节。</p>
<h3 id="文件树遍历">18.8 文件树遍历</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ftw.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nftw</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dirpath,</span></span><br><span class="line"><span class="params">         <span class="type">int</span> (*func)(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> stat *statbuf,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> typeflag, <span class="keyword">struct</span> FTW *ftwbuf),</span></span><br><span class="line"><span class="params">         <span class="type">int</span> nopenfd, <span class="type">int</span> flags)</span>; <span class="comment">/* 成功遍历整个目录树时返回0，出错时返回-1，func返回非0值时返回func返回的第1个非0值 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FTW</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> base;  <span class="comment">/* 相对于pathname的基础部分的偏移量 */</span></span><br><span class="line">    <span class="type">int</span> level; <span class="comment">/* 树遍历中的文件深度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>nftw()</code>会遍历参数<code>dirpath</code>指定的目录树，并且对该目录树下的所有文件都调用1次参数<code>func</code>指向的函数。</p>
<p>　　在默认情况下，<code>nftw()</code>会对目录树执行未排序的先跟次序遍历，即先处理目录，再处理该目录下的文件和子目录。</p>
<p>　　当遍历目录树时，<code>nftw()</code>会为树的每层打开最多1个文件描述符。参数<code>nopenfd</code>用于指定该函数使用的文件描述符的最大数量，若目录树的深度大于该值，则会进行记录，然后按序关闭和重新打开文件描述符，以避免同时打开的文件描述符的数量大于该值
(所以运行速度也会更慢)。</p>
<p>　　参数<code>flags</code>包含标志<code>FTW_CHDIR</code>、<code>FTW_DEPTH</code>、<code>FTW_MOUNT</code>和<code>FTW_PHYS</code>中的任意个标志
(或运算<code>|</code>)。</p>
<p>　　●
<code>FTW_CHDIR</code>表示在处理目录内容前先对目录调用<code>chdir()</code>。当<code>func</code>指向的函数设计为在其参数<code>pathname</code>指定的文件所在的目录下执行某些任务时，这会很有用。</p>
<p>　　●
<code>FTW_DEPTH</code>表示对目录树执行后根次序遍历，即先处理目录下的所有内容，再处理目录
(该常量的名称可能存在一定的误导性，因为<code>nftw()</code>总是执行深度优先遍历，该常量只是将先跟次序变为后根次序)。</p>
<p>　　●
<code>FTW_MOUNT</code>表示不要跨文件系统。若目录的某个子目录是挂载点，则不会遍历该子目录。</p>
<p>　　●
<code>FTW_PHYS</code>表示<code>nftw()</code>不会解引用。在默认情况下，<code>nftw()</code>会解引用。</p>
<p>　　<code>nftw()</code>调用<code>func</code>指向的函数时会传递4个参数。参数<code>pathname</code>是文件路径名。若<code>dirpath</code>是绝对路径名，则<code>pathname</code>可以是绝对路径名；若<code>dirpath</code>是相对路径名，则<code>pathname</code>可以是相对于调用<code>nftw()</code>时调用进程的当前工作目录的相对路径名。参数<code>statbuf</code>是指向结构体<code>stat</code>的指针，其中包含文件的相关信息。参数<code>typeflag</code>提供文件的更多信息，其值只能是<code>FTW_D</code>、<code>FTW_DNR</code>、<code>FTW_DP</code>、<code>FTW_F</code>、<code>FTW_NS</code>、<code>FTW_SL</code>或<code>FTW_SLN</code>。</p>
<p>　　● <code>FTW_D</code>表示该文件是目录。</p>
<p>　　● <code>FTW_DNR</code>表示该文件是无法读取的目录
(所以<code>nftw()</code>无法遍历该目录的内容)。</p>
<p>　　●
<code>FTW_DP</code>表示正在对目录执行后根次序遍历，当前文件是目录内容已经全部处理的目录。</p>
<p>　　● <code>FTW_F</code>表示该文件不是目录和符号链接。</p>
<p>　　●
<code>FTW_NS</code>表示对该文件调用<code>stat()</code>失败，可能是由于权限限制。<code>statbuf</code>的值将是未定义的。</p>
<p>　　●
<code>FTW_SL</code>表示该文件是符号链接。只有调用<code>nftw()</code>时指定了标志<code>FTW_PHYS</code>，才会返回该值。</p>
<p>　　●
<code>FTW_SLN</code>表示该文件是死链接。只有调用<code>nftw()</code>时未指定标志<code>FTW_PHYS</code>，才会出现该值。</p>
<p>　　<code>func</code>指向的函数的第4个参数<code>ftwbuf</code>是指向结构体<code>FTW</code>的指针。该结构体的成员<code>base</code>是参数<code>pathname</code>的基础部分的整数偏移量。成员<code>level</code>是文件相对于遍历的起点的深度
(起点的深度是0) 。</p>
<p>　　<code>func</code>指向的函数会返回整数值，该值由<code>nftw()</code>解析。返回0表示<code>nftw()</code>应该继续遍历，若所有对<code>func</code>指向的函数的调用都会返回0，则<code>nftw()</code>会返回0。返回非0值表示<code>nftw()</code>应该立即停止遍历，此时，<code>nftw()</code>会将该值作为自己的返回值返回。</p>
<p>　　因为<code>nftw()</code>使用的是动态分配的结构体，所以提前终止遍历的唯一途径是<code>func</code>指向的函数返回非0值。通过非本地跳转退出<code>func</code>指向的函数可能会导致无法预测的结果
(至少是内存泄漏)。</p>
<p>　　<code>nftw()</code> (new ftw)
是较旧的函数<code>ftw()</code>的增强版，函数<code>ftw()</code>与<code>nftw()</code>类似。新应用程序应该使用<code>nftw()</code>，因为该函数提供了更多功能，并且该函数对符号链接的处理是可预测的
(SUSv3允许<code>ftw()</code>对符号链接解引用或不解引用)。SUSv3详细说明了<code>ftw()</code>和<code>nftw()</code>，SUSv4将<code>ftw()</code>标记为过时。</p>
<p>　　glibc提供了BSD衍生的fts API
(<code>fts_open()</code>、<code>fts_read()</code>、<code>fts_children()</code>、<code>fts_set()</code>和<code>fts_close()</code>)。这些函数执行与<code>ftw()</code>和<code>nftw()</code>相似的任务，但为遍历目录树的应用程序提供了更多的灵活性。但是，这些函数没有标准化，并且除了BSD衍生的实现之外，只有少数UNIX实现提供了这些函数。</p>
<h4 id="示例程序-1">18.8.1 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* nftw_dir_tree.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ftw.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usageError</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *progName, <span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [-d] [-m] [-p] [directory-path]\n&quot;</span>, progName);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\t-d Use FTW_DEPTH flag\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\t-m Use FTW_MOUNT flag\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\t-p Use FTW_PHYS flag\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dirTree</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> stat *sbuf, <span class="type">int</span> type, <span class="keyword">struct</span> FTW *ftwb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 打印文件类型 */</span></span><br><span class="line">    <span class="keyword">switch</span> (sbuf-&gt;st_mode &amp; S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> S_IFREG:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;l&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %s &quot;</span>,</span><br><span class="line">           (type == FTW_D) ? <span class="string">&quot;D  &quot;</span> : (type == FTW_DNR) ? <span class="string">&quot;DNR&quot;</span></span><br><span class="line">                                 : (type == FTW_DP)    ? <span class="string">&quot;DP &quot;</span></span><br><span class="line">                                 : (type == FTW_F)     ? <span class="string">&quot;F  &quot;</span></span><br><span class="line">                                 : (type == FTW_SL)    ? <span class="string">&quot;SL &quot;</span></span><br><span class="line">                                 : (type == FTW_SLN)   ? <span class="string">&quot;SLN&quot;</span></span><br><span class="line">                                 : (type == FTW_NS)    ? <span class="string">&quot;NS &quot;</span></span><br><span class="line">                                                       : <span class="string">&quot;   &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type != FTW_NS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%7ld &quot;</span>, (<span class="type">long</span>)sbuf-&gt;st_ino);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %*s&quot;</span>, <span class="number">4</span> * ftwb-&gt;level, <span class="string">&quot;&quot;</span>);   <span class="comment">/* 适当缩进 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, &amp;pathname[ftwb-&gt;base]); <span class="comment">/* 打印目录的基础部分 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flags, opt;</span><br><span class="line"></span><br><span class="line">    flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;dmp&quot;</span>)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            flags |= FTW_DEPTH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">            flags |= FTW_MOUNT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            flags |= FTW_PHYS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            usageError(argv[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; optind + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageError(argv[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nftw((argc &gt; optind) ? argv[optind] : <span class="string">&quot;.&quot;</span>, dirTree, <span class="number">10</span>, flags) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;nftw&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>nftw()</code>的用法。该程序会打印目录树的缩进层次结构，每行都包含文件名、文件类型和i-node号。命令行参数可用于指定<code>ntfs()</code>的参数<code>flags</code>。</p>
<h4 id="nftw的标志ftw_actionretval">18.8.2
<code>nftw()</code>的标志<code>FTW_ACTIONRETVAL</code></h4>
<p>　　从版本2.3.3开始，glibc为<code>nftw()</code>的参数<code>flags</code>提供了额外的非标准标志<code>FTW_ACTIONRETVAL</code>。当指定了该标志后，<code>func</code>指向的函数会返回<code>FTW_CONTINUE</code>、<code>FTW_SKIP_SIBLINGS</code>、<code>FTW_SKIP_SUBTREE</code>或<code>FTW_STOP</code>。</p>
<p>　　● <code>FTW_CONTINUE</code>表示继续处理目录树的条目
(与返回0相同)。</p>
<p>　　●
<code>FTW_SKIP_SIBLINGS</code>表示跳过当前目录下的其他条目，在父目录下继续处理。</p>
<p>　　● <code>FTW_SKIP_SUBTREE</code>表示若<code>pathname</code>是目录
(即参数<code>typeflag</code>是<code>FTW_D</code>)，则跳过该目录下的条目，在下一个同级目录下继续处理。</p>
<p>　　● <code>FTW_STOP</code>表示立即停止处理
(与返回非0值相同)。在这种情况下，<code>nftw()</code>也会返回<code>FTW_STOP</code>。</p>
<p>　　当定义了特性测试宏<code>_GNU_SOURCE</code>后，标志<code>FTW_ACTIONRETVAL</code>的定义会出现在头文件<code>ftw.h</code>中。</p>
<h3 id="进程的当前工作目录">18.9 进程的当前工作目录</h3>
<p>　　进程的当前工作目录作为进程引用的相对路径名的起点。新创建的进程会继承父进程的当前工作目录。</p>
<p>　　可以通过特定于Linux的符号链接<code>/proc/PID/cwd</code>来获取所有进程的当前工作目录
(需要拥有该进程或能力<code>CAP_SYS_PTRACE</code>)。</p>
<h4 id="检索当前工作目录">18.9.1 检索当前工作目录</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *cwdbuf, <span class="type">size_t</span> size)</span>; <span class="comment">/* 成功时返回cwdbuf，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getcwd()</code>会将以字符<code>\0</code>结尾的包含当前工作目录的绝对路径名字符串存储在参数<code>cwdbuf</code>指向的缓冲区中，该缓冲区的长度至少是<code>size</code>字节
(通常，通过常量<code>PATH_MAX</code>来调整<code>cwdbuf</code>的大小)。</p>
<p>　　若<code>getcwd()</code>成功，则会返回<code>cwdbuf</code>。若当前工作目录的路径名超过了<code>size</code>字节，则<code>getcwd()</code>会返回<code>NULL</code>，并将<code>errno</code>设置为<code>ERANGE</code>。</p>
<p>　　对于Linux，<code>getcwd()</code>会为返回字符串分配1个虚拟内存页。若当前工作目录的绝对路径名的长度大于虚拟内存页的页大小，则路径名会被隐式截断
(删除路径名的目录部分)。</p>
<p>　　若<code>cwdbuf</code>是<code>NULL</code>或<code>size</code>是0，则<code>getcwd()</code>的glibc包装函数会根据需求分配大小与需求相等的缓冲区，并且返回指向该缓冲区的指针。为了避免内存泄漏，调用者必须通过<code>free()</code>来释放该缓冲区。大部分其他实现都提供了SUSv3规范的更简单的扩展，即若<code>cwdbuf</code>是<code>NULL</code>，则<code>getcwd()</code>会分配<code>size</code>字节的缓冲区，然后返回指向该缓冲区的指针，glibc的<code>getcwd()</code>也提供了该特性。</p>
<p>　　glibc还提供了2个用于获取当前工作目录的函数。BSD衍生的函数<code>getwd(path)</code>容易受到缓冲区溢出的影响，因为该函数没有提供用于指定返回的路径名的长度上限的方法。函数<code>get_current_dir_name()</code>会返回当前工作目录，该函数易于使用，但无法移植。从安全和可移植性角度，<code>getcwd()</code>优于这2个函数。</p>
<h4 id="修改当前工作目录">18.9.2 修改当前工作目录</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>; <span class="comment">/* 成功时饭返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>chdir()</code>会将调用进程的当前工作目录修改为参数<code>pathname</code>指定的路径
(可以是相对路径名或绝对路径名)。若<code>pathname</code>是符号链接，则会解引用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500 <span class="comment">/* 或#define _BSD_SOURCE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fchdir</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 成功时饭返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>fchdir()</code>与<code>chdir()</code>类似，但指定路径的方式是文件描述符
(参数<code>fd</code>)。</p>
<h3 id="与目录文件描述符相关的系统调用">18.10
与目录文件描述符相关的系统调用</h3>
<p>　　从内核2.6.16开始，Linux提供了大量与传统系统调用类似的新系统调用，这些新系统调用都是通过目录文件描述符来解析相对路径名，并且提供了对有些应用程序有用的功能：</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 20%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr>
<th>新系统调用</th>
<th>对应的传统系统调用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>faccessat()</code></td>
<td><code>access()</code></td>
<td>支持标志<code>AT_EACCESS</code>和<code>AT_SYMLINK_NOFOLLOW</code></td>
</tr>
<tr>
<td><code>fchmodat()</code></td>
<td><code>chmod()</code></td>
<td></td>
</tr>
<tr>
<td><code>fchownat()</code></td>
<td><code>chown()</code></td>
<td>支持标志<code>AT_SYMLINK_NOFOLLOW</code></td>
</tr>
<tr>
<td><code>fstatat()</code></td>
<td><code>stat()</code></td>
<td>支持标志<code>AT_SYMLINK_NOFOLLOW</code></td>
</tr>
<tr>
<td><code>linkat()</code></td>
<td><code>link()</code></td>
<td>支持标志<code>AT_SYMLINK_NOFOLLOW</code> (Linux
2.6.18及以上版本)</td>
</tr>
<tr>
<td><code>mkdirat()</code></td>
<td><code>mkdir()</code></td>
<td></td>
</tr>
<tr>
<td><code>mkfifoat()</code></td>
<td><code>mkfifo()</code></td>
<td><code>mknodat()</code>的包装系统调用</td>
</tr>
<tr>
<td><code>mknodat()</code></td>
<td><code>mknod()</code></td>
<td></td>
</tr>
<tr>
<td><code>openat()</code></td>
<td><code>open()</code></td>
<td></td>
</tr>
<tr>
<td><code>readlinkat()</code></td>
<td><code>readlink()</code></td>
<td></td>
</tr>
<tr>
<td><code>renameat()</code></td>
<td><code>rename()</code></td>
<td></td>
</tr>
<tr>
<td><code>symlinkat()</code></td>
<td><code>symlink()</code></td>
<td></td>
</tr>
<tr>
<td><code>unlinkat()</code></td>
<td><code>unlink()</code></td>
<td>支持标志<code>AT_REMOVEDIR</code></td>
</tr>
<tr>
<td><code>utimensat()</code></td>
<td><code>utimes()</code></td>
<td>支持标志<code>AT_SYMLINK_NOFOLLOW</code></td>
</tr>
</tbody>
</table>
<p>　　这里以<code>openat()</code>为例来介绍这些系统调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 700 <span class="comment">/* 或define _POSIX_C_SOURCE &gt;= 200809 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, ... <span class="comment">/* mode_t mode */</span>)</span>; <span class="comment">/* 成功时返回文件描述符，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>openat()</code>与<code>open()</code>类似，但添加了参数<code>dirfd</code>。</p>
<p>　　●
若参数<code>pathname</code>是相对路径名，则将<code>pathname</code>解析为相对于<code>dirfd</code>引用的目录的路径名。</p>
<p>　　●
若参数<code>pathname</code>是相对路径名，并且<code>dirfd</code>为特殊值<code>AT_FDCWD</code>，则将<code>pathname</code>解析为相对于进程的当前工作目录的路径名
(即与<code>open()</code>相同)。</p>
<p>　　●
若参数<code>pathname</code>是绝对路径名，则忽略<code>dirfd</code>。</p>
<p>　　<code>openat()</code>的参数<code>flags</code>与<code>open()</code>的相同。但是，上表中的部分系统调用支持对应的传统系统调用不支持的参数<code>flags</code>，该参数用于控制系统调用的语义。最常提供给该参数的标志是<code>AT_SYMLINK_NOFOLLOW</code>，表示若<code>pathname</code>是符号链接，则不解引用
(即操作对象是符号链接)。但是，系统调用<code>linkat()</code>的<code>AT_SYMLINK_FOLLOW</code>与此相反，表示对<code>oldpath</code>解引用
(默认行为是不解引用)。</p>
<p>　　支持上表的系统调用有2个原因
(还是以<code>openat()</code>为例)：</p>
<p>　　●
<code>openat()</code>允许程序避免通过<code>open()</code>打开当前工作目录之外的位置的文件而导致的竞争，因为调用<code>open()</code>时<code>pathname</code>的目录部分的部分目录可能会发生变化。通过引用目标目录的文件描述符，可以避免这种竞争。</p>
<p>　　●
当前工作目录是进程的所有线程共享的进程属性。对于有些应用程序，可能会需要让不同的线程有不同的
"虚拟"
当前工作目录，这可以通过<code>openat()</code>和应用程序维护的目录文件描述符一起使用来模拟。</p>
<p>　　SUSv3没有说明这些系统调用，但SUSv4说明了这些系统调用。为了使用这些系统调用，需要在引用合适的头文件之前将特性测试宏<code>_XOPEN_SOURCE</code>定义为不小于700的值。或者，将宏<code>_POSIX_C_SOURCE</code>定义为不小于200809的值
(对于glibc
2.10之前的版本，还需要定义宏<code>_ATFILE_SOURCE</code>)。</p>
<p>　　Solaris 9及以上版本提供了上表的部分系统调用，但语义略有不同。</p>
<h3 id="修改进程的根目录">18.11 修改进程的根目录</h3>
<p>　　特权进程 (能力<code>CAP_SYS_CHROOT</code>)
可以通过系统调用<code>chroot()</code>来修改自己的根目录，命令<code>chroot</code>使用了该系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chroot</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>chroot()</code>会将调用进程的根目录修改为参数<code>pathname</code>指定的目录
(若<code>pathname</code>是符号链接，则会解引用)。此后，所有绝对路径名的解析都会从该位置开始，这种情况称为<span
style="background-color: yellow">chroot
jail</span>，因为程序随后会被限制在文件系统的特定区域。</p>
<p>　　SUSv2包含<code>chroot()</code>的规范
(标记为LEGACY)，但SUSv3删除了该规范。尽管如此，大多数UNIX实现还是提供了该系统调用。</p>
<p>　　<code>chroot()</code>经常用于<code>ftp</code>程序。出于安全原因，当用户在FTP下匿名登录时，<code>ftp</code>程序会通过<code>chroot()</code>来将新进程的根目录设置为专为匿名登录保留的目录。在调用<code>chroot()</code>后，该用户会限制在新根目录下的文件系统子树
(根目录也有父目录<code>/..</code>，它是引用<code>/</code>的硬链接，所以匿名登录的用户在根目录下使用命令<code>cd ..</code>无效)。</p>
<p>　　有些UNIX实现允许多个硬链接引用同一目录，所以可以在子目录下创建引用父目录的硬链接。对于这些UNIX实现，引用jail目录树之外的目录的硬链接会导致jail无效。引用目录的符号链接不会产生问题，因为符号链接的解析基于进程的新根目录，所以无法到达chroot
jail之外。</p>
<p>　　通常，无法在chroot
jail中执行任意程序，因为大多数程序都需要动态链接共享库。因此，要么仅执行静态链接的程序，要么将包含共享库的目录复制到jail中
(此时，绑定挂载功能会很有用)。</p>
<p>　　<code>chroot()</code>并非完全安全的jail机制。首先，特权程序随后可以通过多种方式再次调用<code>chroot()</code>来逃出jail。例如，特权程序
(能力<code>CAP_MKNOD</code>)
可以通过<code>mknod()</code>来创建1个内存设备文件
(与<code>/dev/mem</code>类似)
来授予RAM中的内容权限，然后一切皆有可能。通常，chroot
jail文件系统中尽量不要包含set-user-ID-root程序。其次，非特权进程也能通过以下方式逃出chroot
jail：</p>
<p>　　●
调用<code>chroot()</code>不会修改进程的当前工作目录，所以调用<code>chroot()</code>后通常会调用<code>chdir("/")</code>。若没有这样做，则进程可以通过相对路径名来访问jail外的文件或目录。有些BSD衍生系统阻止了这种可能性，当当前工作目录在新根目录树之外时，则<code>chroot()</code>也会修改当前工作目录
(同根目录相同)。</p>
<p>　　●
若进程持有引用jail之外的目录的文件描述符，则通过<code>fchdir()</code>和<code>chroot()</code>一起使用来逃出jail
(有些UNIX实现提供了系统调用<code>fchroot()</code>，该系统调用会将调用进程的根目录修改为文件描述符引用的目录)。为了防止这种可能性，必须关闭所有引用jail之外的目录的文件描述符。</p>
<p>　　●
处于jail中的进程可以通过UNIX域套接字来获取引用jail之外的目录的文件描述符
(来自其他进程)。</p>
<p>　　有些BSD衍生系统提供了系统调用<code>jail()</code>，该系统调用解决了以上问题，可以创建特权进程也无法逃出的jail。</p>
<h3 id="解析路径名">18.12 解析路径名</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">realpath</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *resolved_path)</span>; <span class="comment">/* 成功时返回解析后的路径名字符串，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　库函数<code>realpath()</code>会解析参数<code>pathname</code>
(以字符<code>\0</code>结尾的字符串)
来生成对应的以字符<code>\0</code>结尾的绝对路径名字符串
(解析过程包括解引用所有符号链接，删除多余的<code>/</code>以及将<code>.</code>和<code>..</code>解析为对应的目录)，解析结果存储在参数<code>resolved_path</code>指向的缓冲区中，该缓冲区的大小至少是<code>PATH_MAX</code>字节。</p>
<p>　　若<code>realpath()</code>成功，则会返回解析后的绝对路径名字符串。</p>
<p>　　glibc的<code>realpath()</code>允许调用者将<code>resolved_path</code>指定为<code>NULL</code>。在这种情况下，<code>realpath()</code>会为解析后的绝对路径名字符串分配最多<code>PATH_MAX</code>字节的缓冲区，然后返回指向该缓冲区的指针
(调用者必须通过<code>free()</code>来释放该缓冲区)。SUSv3没有说明此扩展，但SUSv4详细说明了此扩展。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* view_symlink.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE PATH_MAX</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> numBytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pathname\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lstat(argv[<span class="number">1</span>], &amp;statbuf) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;lstat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!S_ISLNK(statbuf.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;%s is not a symbolic link&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numBytes = readlink(argv[<span class="number">1</span>], buf, BUF_SIZE - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (numBytes == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;readlink&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf[numBytes] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 添加结尾的字符\0 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;readlink: %s --&gt; %s\n&quot;</span>, argv[<span class="number">1</span>], buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (realpath(argv[<span class="number">1</span>], buf) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;realpath&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;realpath: %s --&gt; %s\n&quot;</span>, argv[<span class="number">1</span>], buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过<code>readlink()</code>和<code>realpath()</code>来读取符号链接的内容，然后将其解析为绝对路径名。</p>
<h3 id="解析路径名字符串">18.13 解析路径名字符串</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回以字符\0结尾的字符串 (可能是静态分配的) */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">dirname</span><span class="params">(<span class="type">char</span> *pathname)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">basename</span><span class="params">(<span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>dirname()</code>和<code>basename()</code>会将参数<code>pathname</code>指定的路径名分解为目录部分和基础部分
(命令<code>dirname</code>和<code>basename</code>执行的任务与这2个函数的类似)。这2个函数返回的字符串可能是静态分配的。</p>
<p>　　● <code>pathname</code>结尾的斜杠会被忽略。</p>
<p>　　●
若<code>pathname</code>不包含斜杠，则<code>dirname()</code>会返回<code>.</code>，<code>basename()</code>会返回<code>pathname</code>。</p>
<p>　　● 若<code>pathname</code>仅包含斜杠
(无论多少个斜杠)，则<code>dirname()</code>和<code>basename()</code>都会返回<code>/</code>。</p>
<p>　　●
若<code>pathname</code>是<code>NULL</code>或空字符串，则<code>dirname()</code>和<code>basename()</code>都会返回<code>.</code>。</p>
<table>
<thead>
<tr>
<th>参数<code>pathname</code></th>
<th><code>dirname()</code>的返回值</th>
<th><code>basename()</code>的返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/</code></td>
<td><code>/</code></td>
<td><code>/</code></td>
</tr>
<tr>
<td><code>.</code></td>
<td><code>.</code></td>
<td><code>.</code></td>
</tr>
<tr>
<td><code>..</code></td>
<td><code>..</code></td>
<td><code>..</code></td>
</tr>
<tr>
<td><code>/usr/bin/zip</code></td>
<td><code>/usr/bin</code></td>
<td><code>zip</code></td>
</tr>
<tr>
<td><code>/etc/passwd////</code></td>
<td><code>/etc</code></td>
<td><code>passwd</code></td>
</tr>
<tr>
<td><code>/etc////passwd</code></td>
<td><code>/etc</code></td>
<td><code>passwd</code></td>
</tr>
<tr>
<td><code>etc/passwd</code></td>
<td><code>etc</code></td>
<td><code>passwd</code></td>
</tr>
<tr>
<td><code>passwd</code></td>
<td><code>.</code></td>
<td><code>passwd</code></td>
</tr>
</tbody>
</table>
<p>　　<code>dirname()</code>和<code>basename()</code>都可能会修改<code>pathname</code>。因此，在必要时，可以将其副本传递给这2个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_dirbasename.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *t1, *t2;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        t1 = strdup(argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;strdup&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        t2 = strdup(argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;strdup&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s ==&gt; %s + %s\n&quot;</span>, argv[j], dirname(t1), basename(t2));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(t1);</span><br><span class="line">        <span class="built_in">free</span>(t2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>dirname()</code>和<code>basename()</code>的用法。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第21章 信号：信号处理函数</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_21/</url>
    <content><![CDATA[<p>　　通常，信号处理函数应该设计得尽可能简单
(重要原因之一是降低出现竞争的可能性)。信号处理函数的2种常见设计如下：</p>
<p>　　●
信号处理函数设置全局标志并退出。主函数会周期性地检查标志，若标志已设置，则采取合适的行动。若主函数因为需要监控文件描述符来判断I/O是否可用，而无法周期性地检查标志，则信号处理函数也可以向专用管道写1个字节，该管道的读取端包含在主函数监控的文件描述符中。</p>
<p>　　●
信号处理函数执行一些清理，然后终止进程或通过非本地跳转来展开栈和将控制权转移给主函数中的特定位置。</p>
<p>　　当调用信号处理函数时，内核通常会在进程的栈中为处理函数创建栈帧。当进程的栈容量达到上限时，继续在栈中分配空间会导致内核为进程生成信号<code>SIGSEGV</code>。但是，因为栈容量达到上限，所以无法为<code>SIGSEGV</code>处理函数分配栈帧，导致该处理函数不会调用，并且进程会被终止
(信号<code>SIGSEGV</code>的默认处理方式)。为此，可以使用以下方法来保证信号<code>SIGSEGV</code>会被处理：</p>
<p>　　1)
分配称为<strong>备用信号栈</strong>的内存区域，用于信号处理函数的栈帧。</p>
<p>　　2)
使用系统调用<code>sigaltstack()</code>来通知内核备用信号栈的存在。</p>
<p>　　3) 在注册信号处理函数时指定标志<code>SA_ONSTACK</code>
(告诉内核应该在备用信号栈中为该处理函数分配栈帧)。</p>
<p>　　有时，从信号处理函数返回是不可取的
(甚至是无用的)。可以通过以下方法来终止信号处理函数：</p>
<p>　　●
通过<code>_exit()</code>来终止进程。在此之前，信号处理函数可能需要执行清理操作。</p>
<p>　　●
通过<code>kill()</code>或<code>raise()</code>发送信号来终止进程。</p>
<p>　　● 在信号处理函数中执行非本地跳转。</p>
<p>　　● 通过<code>abort()</code>来让进程生成核心转储文件并终止。</p>
<p>　　当阻塞系统调用被信号处理函数中断时，系统调用默认会出错
(<code>EINTR</code>)。为了继续执行被中断的系统调用，可以使用以下方式来重启系统调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((cnt = read(fd, buf, BUF_SIZE)) == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码可以通过宏简化为以下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NO_EINTR(stmt)                     \</span></span><br><span class="line"><span class="meta">    while ((stmt) == -1 &amp;&amp; errno == EINTR) \</span></span><br><span class="line"><span class="meta">        ;</span></span><br><span class="line"></span><br><span class="line">NO_EINTR(cnt = read(fd, buf, BUF_SIZE));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在定义了特性测试宏<code>_GNU_SOURCE</code>后，glibc会在头文件<code>unistd.h</code>中提供与宏<code>NO_EINTR()</code>类似的非标准宏<code>TEMP_FAILURE_RETRY()</code>。</p>
<p>　　即使使用了<code>NO_EINTR</code>等宏，重启被信号处理函数中断的系统调用依然比较麻烦。因此，通过<code>sigaction()</code>注册信号处理函数时应该指定标志<code>SA_RESTART</code>。</p>
<span id="more"></span>
<p>　　对于Linux，有些阻塞系统调用会在没有注册处理函数的信号到达时出错
(<code>EINTR</code>)，包括<code>epoll_pwait()</code>、<code>epoll_wait()</code>、<code>semop()</code>、<code>semtimedop()</code>、<code>sigtimedwait()</code>、<code>sigwaitinfo()</code>、对inotify文件描述符调用的<code>read()</code>、2.6.9之前的内核中的<code>msgrcv()</code>和<code>msgsnd()</code>、2.6.22之前的内核中的<code>sem_wait()</code>、<code>sem_timedwait()</code>和<code>futex(FUTEX_WAIT)</code>、2.6.24之前的内核中的<code>poll()</code>以及Linux
2.4及以下版本中的<code>nanosleep()</code>。当这些系统调用阻塞时进程被信号
(<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>或<code>SIGTTOU</code>)
停止，然后被信号<code>SIGCONT</code>恢复时，就会出现这种情况。对于Linux
2.4及以下版本，<code>sleep()</code>也会出现类似的情况，但返回的是剩余未睡眠的秒数，而非出错。</p>
<p>　　因此，当程序可能被信号停止和恢复时，可能需要额外代码来重启这些系统调用，即使没有为停止信号注册处理函数。</p>
<h3 id="设计信号处理函数">21.1 设计信号处理函数</h3>
<p>　　并非所有系统调用和库函数都可以在信号处理函数中安全调用。要理解原因需要先介绍2个概念：可重入函数和异步信号安全函数。</p>
<h4 id="可重入和不可重入函数">21.1.1 可重入和不可重入函数</h4>
<p>　　传统UNIX程序只有1个<span
style="background-color: yellow">执行线程</span>，CPU处理为程序的单个逻辑执行流处理指令。多线程程序有多个独立的并发逻辑执行流。</p>
<p>　　若函数可以安全地由同一进程的多个线程同时执行 ("安全"
表示函数可以达到预期结果，无论其他执行线程的执行状态)，则该函数是<strong>可重入函数</strong>。SUSv3对可重入函数的定义是：当多个线程调用可重入函数时，即使实际执行是交错进行的，也能保证其效果按照未定义的顺序执行该函数一样。</p>
<p>　　更新全局或静态变量 (或数据结构)
的函数可能是不可重入的，仅使用局部变量 (或数据结构)
的函数一定是可重入的。若同一进程的多个线程同时调用同一函数来更新同一全局变量
(或数据结构)，则这些更新可能会互相干扰，进而导致错误的结果。</p>
<p>　　实际上，这种可能性充斥着标准C库。例如，<code>malloc()</code>和<code>free()</code>维护着用于在堆中分配内存的空闲内存块链接。若主程序中的<code>malloc()</code>调用被信号处理函数中断，并且信号处理函数也会调用该系统调用，则空闲内存块链表会损坏。其他不可重入的库函数会返回存储在静态分配的内存的数据或使用静态数据结构来进行内部存储。</p>
<p>　　即使不使用不可重入的库函数，可重入问题可能依旧存在。若主函数和信号处理函数都会更新程序员定义的全局数据结构，则该信号处理函数是不可重入的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* nonreentrant.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *str2;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> handled = <span class="number">0</span>; <span class="comment">/* 信号处理函数的调用次数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    crypt(str2, <span class="string">&quot;xx&quot;</span>);</span><br><span class="line">    handled++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *cr1;</span><br><span class="line">    <span class="type">int</span> callNum, mismatch;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s str1 str2\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str2 = argv[<span class="number">2</span>]; <span class="comment">/* 便于信号处理函数使用argv[2] */</span></span><br><span class="line">    cr1 = strdup(crypt(argv[<span class="number">1</span>], <span class="string">&quot;xx&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cr1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;strdup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 反复使用argv[1]调用crypt()。若被信号处理函数中断，则该函数返回的静态分配的字符串会被覆盖 */</span></span><br><span class="line">    <span class="keyword">for</span> (callNum = <span class="number">1</span>, mismatch = <span class="number">0</span>;; callNum++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(crypt(argv[<span class="number">1</span>], <span class="string">&quot;xx&quot;</span>), cr1) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mismatch++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mismatch on call %d (mismatch=%d handled=%d)\n&quot;</span>,</span><br><span class="line">                   callNum, mismatch, handled);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了函数<code>crypt()</code>的不可重入性。该程序的执行步骤如下：</p>
<p>　　1)
调用<code>crypt()</code>来加密第1个命令行参数指定的字符串，然后通过<code>strdup()</code>将结果复制到独立的缓冲区。</p>
<p>　　2)
为信号<code>SIGINT</code>注册处理函数，该处理函数会调用<code>crypt()</code>来加密第2个命令行参数指定的字符串。</p>
<p>　　3)
进行无限循环。每次循环都会加密第1个命令行参数指定的字符串，并判断结果是否匹配第1步得到的结果。</p>
<h4 id="异步信号安全函数">21.1.2 异步信号安全函数</h4>
<p>　　<strong>异步信号安全函数</strong>是可以在信号处理函数中安全调用的函数
(可重入或不能被信号处理函数中断)。</p>
<p>　　当编写信号处理函数时，有2个选择：</p>
<p>　　● 确保信号处理函数是可重入的，并且仅调用异步信号安全函数。</p>
<p>　　●
对于主函数，调用不安全函数或操作信号处理函数也会操作的全局数据结构时阻塞信号。</p>
<p>　　第2个选择的问题在于，在复杂的程序中，难以保证调用不安全函数时不会被信号处理函数中断。因此，这2个选择通常会简化为<span
style="background-color: yellow">不能在信号处理函数中调用不安全的函数</span>。</p>
<p>　　当通过同一信号处理函数捕获多个信号或使用<code>sigaction()</code>的标志<code>SA_NODEFER</code>时，信号处理函数可能会被自己中断，所以使用全局
(或静态) 变量的信号处理函数可能是不可重入的
(即使主函数不使用这些变量)。</p>
<p>　　若信号处理函数调用了可能会更新<code>errno</code>的函数，则该信号处理函数可能是不可重入的，因为这可能会覆盖主函数调用的函数设置的<code>errno</code>值。解决方法是在信号处理函数的开头保存<code>errno</code>的值，并在信号处理函数的末尾恢复<code>errno</code>的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> savedErrno;</span><br><span class="line">    savedErrno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    errno = savedErrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全局变量和数据类型sig_atomic_t">21.1.3
全局变量和数据类型<code>sig_atomic_t</code></h4>
<p>　　尽管存在可重入性问题，但在主函数和信号处理函数之间共享全局变量还是很有用的。只有主函数可以正确地处理信号处理函数可能随时修改全局变量的可能性，这就可以是安全的。例如，将信号处理函数设计为仅操作全局标志，然后主函数周期性地检查该标志，并在标志被设置时采取合适的行动
(然后清除标志)。当以这种方式使用全局变量时，应该在声明该全局变量时使用关键字<code>volatile</code>，以防止编译器优化导致该全局变量存储在寄存器中。</p>
<p>　　读写全局变量可能涉及多个机器语言指令，主函数执行这些指令时可能会被信号处理函数中断
(所以对该变量的访问是<strong>非原子</strong>的)。因此，C语言标准和SUSv3详细说明了整数数据类型<code>sig_atomic_t</code>，对该数据类型的读写是<strong>原子</strong>的。主函数和信号处理函数都使用的全局标志变量应该声明为<code>volatile sig_atomic_t flag</code>。</p>
<p>　　C语言的自增操作符 (<code>++</code>) 和自减操作符
(<code>--</code>)
不会受到<code>sig_atomic_t</code>的影响。对于有些硬件架构，这些操作可能是非原子的。</p>
<p>　　C99和SUSv3要求实现在头文件<code>stdint.h</code>中定义2个常量：<code>SIG_ATOMIC_MIN</code>和<code>SIG_ATOMIC_MAX</code>，这2个变量表示<code>sig_atomic_t</code>的取值范围。若<code>sig_atomic_t</code>是有符号数，则取值范围至少是-127~127；若<code>sig_atomic_t</code>是无符号数，则取值范围至少是0~255。对于Linux，该范围与有符号32位整数的取值范围相同。</p>
<h3 id="sigsetjmp和siglongjmp">21.2
<code>sigsetjmp()</code>和<code>siglongjmp()</code></h3>
<p>　　在6.6中介绍了如何通过<code>setjmp()</code>和<code>longjmp()</code>执行从被调函数到调用函数的非本地跳转。由于内核会自动在进入信号处理函数时将对应的信号和通过<code>act.sa_mask</code>指定的信号添加到信号掩码，并且在信号处理函数返回时从信号掩码删除这些信号，所以通过<code>longjmp()</code>退出信号处理函数<span
style="background-color: yellow">可能</span>会跳过从信号掩码删除信号的步骤，这取决于UNIX实现。对于System
V，<code>longjmp()</code>不会执行该步骤。Linux在这一点上与System
V相同。对于BSD衍生实现，<code>setjmp()</code>会将信号掩码保存在参数<code>env</code>中，并且<code>longjmp()</code>会恢复保存的信号掩码
(BSD衍生实现还提供了<code>_setjmp()</code>和<code>_longjmp()</code>，这2个函数遵循System
V语义)。</p>
<p>　　若编译程序时使用特性测试宏<code>_BSD_SOURCE</code>，则glibc的<code>setjmp()</code>会遵循BSD语义。</p>
<p>　　由于这2个主要UNIX变体之间的差异，POSIX.1-1990选择不规定<code>setjmp()</code>和<code>longjmp()</code>如何处理信号掩码，相反，该标准详细说明了2个新函数：<code>sigsetjmp()</code>和<code>siglongjmp()</code>，它们会在执行非本地跳转时会显式地控制信号掩码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>; <span class="comment">/* 第1次调用时返回0，siglongjmp()导致的返回返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>sigsetjmp()</code>和<code>siglongjmp()</code>的功能与<code>setjmp()</code>和<code>longjmp()</code>的类似。唯一的区别是参数<code>env</code>的数据类型和<code>sigsetjmp()</code>的额外参数<code>savesigs</code>。若<code>savesigs</code>不是0，则调用<code>sigsetjmp()</code>时进程的信号掩码会保存在<code>env</code>中，并且随后可以通过为<code>siglongjmp()</code>指定相同的<code>env</code>来恢复信号掩码。若<code>savesigs</code>是0，则不会保存和恢复信号掩码。</p>
<p>　　<code>longjmp()</code>和<code>siglongjmp()</code>是非异步信号安全函数，因为在执行非本地跳转后调用非异步信号安全函数的风险与在信号处理函数中调用非异步信号安全函数的风险相同。此外，若主函数在更新数据结构时被信号处理函数中断，然后信号处理函数执行非本地跳转，则未完成的更新可能会导致数据结构处于不一致状态。因此，在更新关键数据时可以使用<code>sigprocmask()</code>临时阻塞信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sigmask_longjmp.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;signal_functions.h&quot;</span> <span class="comment">/* printSigMask()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> canJump = <span class="number">0</span>; <span class="comment">/* setjmp()或sigsetjmp()初始化env时会设置为1 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_SIGSETJMP</span></span><br><span class="line"><span class="type">static</span> sigjmp_buf senv;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> jmp_buf env;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数使用了非异步信号安全函数 (printf()、strsignal()和printSigMask())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d (%s), signal mask is:\n&quot;</span>, sig, strsignal(sig));</span><br><span class="line">    printSigMask(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canJump)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&#x27;env&#x27; buffer not yet set, doing a simple return\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_SIGSETJMP</span></span><br><span class="line">    siglongjmp(senv, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    longjmp(env, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    printSigMask(<span class="built_in">stdout</span>, <span class="string">&quot;Signal mask at startup:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_SIGSETJMP</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling sigsetjmp()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sigsetjmp(senv, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling setjmp()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (setjmp(env) == <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        canJump = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printSigMask(<span class="built_in">stdout</span>, <span class="string">&quot;After jump from handler, signal mask is:\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了2种非本地跳转之间的区别。该程序会为信号<code>SIGINT</code>注册处理函数，然后执行非本地跳转来退出处理函数
(使用哪种非本地跳转取决于编译时是否使用了选项<code>-DUSE_SIGSETJMP</code>)，最后打印进入处理函数时的信号掩码和退出处理函数后的信号掩码。</p>
<p>　　此外，该程序也展示了如何在信号处理函数中进行非本地跳转。信号可以在任何时刻生成，所以信号可能在调用<code>sigsetjmp()</code>或<code>setjmp()</code>之前到达。为了防止这种可能性
(使用未初始化的<code>env</code>来执行非本地跳转)，这里使用了标志<code>canJump</code>，该标志决定是否执行非本地跳转。只有调用<code>sigsetjmp()</code>或<code>setjmp()</code>后，才会设置该标志。另一种方法是在注册信号处理函数之前调用<code>sigsetjmp()</code>或<code>setjmp()</code>。但是，在复杂的程序中，可能无法保证第2种方法指定的顺序，而且第1种方法相对更简单。</p>
<p>　　这里使用<code>#ifdef</code>是最简单的符合规范的方法。若将其替换为<code>if</code>语句，则会进行运行时检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (useSiglongjmp)</span><br><span class="line">&#123;</span><br><span class="line">    s = sigsetjmp(senv, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    s = setjmp(env);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　因为SUSv3不允许将<code>sigsetjmp()</code>和<code>setjmp()</code>用于赋值语句，所以这里无法使用<code>if</code>语句。</p>
<h3 id="abort">21.3 <code>abort()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>　　库函数<code>abort()</code>会让调用进程生成核心转储文件并终止
(通过信号<code>SIGABRT</code>)。</p>
<p>　　SUSv3要求<code>abort()</code>覆盖阻塞或忽略信号<code>SIGABRT</code>的效果。此外，SUSv3规定，<code>abort()</code>必须终止进程，除非进程使用不会返回的处理函数捕获信号。若处理函数中使用了非本地跳转，则该函数的效果会无效；否则，该函数总是会终止进程。对于大多数实现，若<code>abort()</code>通过信号<code>SIGABRT</code>终止进程失败
(例如，进程使用了信号处理函数捕获信号<code>SIGABRT</code>)，则<code>abort()</code>会将信号<code>SIGABRT</code>的处理方式设置为<code>SIG_DFL</code>，并再次通过该信号终止进程。</p>
<p>　　当<code>abort()</code>成功终止进程时，也会刷新和关闭stdio流。</p>
<h3 id="sigaltstack">21.4 <code>sigaltstack()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaltstack</span><span class="params">(<span class="type">const</span> <span class="type">stack_t</span> *sigstack, <span class="type">stack_t</span> *old_sigstack)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> *ss_sp;    <span class="comment">/* 备用信号栈的起始地址 */</span></span><br><span class="line">    <span class="type">int</span> ss_flags;   <span class="comment">/* 标志 (SS_ONSTACK或SS_DISABLE) */</span></span><br><span class="line">    <span class="type">size_t</span> ss_size; <span class="comment">/* 备用信号栈的大小 */</span></span><br><span class="line">&#125; <span class="type">stack_t</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sigaltstack()</code>可用于定义备用信号栈或检索关于现有备用信号栈的信息。</p>
<p>　　参数<code>sigstack</code>指向的结构体用于指定新备用信号栈的地址和属性。参数<code>sigstack</code>指向的结构体用于存储现有备用信号栈的信息
(若存在)。此外，这2个参数都可以指定为<code>NULL</code>。</p>
<p>　　结构体<code>stack_t</code>的成员<code>ss_sp</code>和<code>ss_size</code>表示备用信号栈的地址和大小。当实际使用备用信号栈时，内核会进行对齐。</p>
<p>　　通常，备用信号栈是在堆上静态或动态分配的。SUSv3详细说明了常量<code>SIGSTKSZ</code>和<code>MINSIGSTKSZ</code>，前者作为调整备用信号栈的大小时的典型值，后者表示调用信号处理函数所需的最小空间。对于Linux/x86-32，这2个常量分别定义为8192和2048。</p>
<p>　　内核不会调整备用信号栈的大小。若备用信号栈溢出，则会导致无法预测的结果
(例如，覆盖与备用信号栈相邻的变量)。实际上，这通常不会是问题，因为使用备用信号栈是为了防止标准栈溢出，所以备用信号栈中的栈帧通常很少。<code>SIGSEGV</code>处理函数的任务是执行清理并终止进程或通过非本地跳转来展开标准栈。</p>
<p>　　成员<code>ss_flags</code>的值是<code>SS_ONSTACK</code>或<code>SS_DISABLE</code>。</p>
<p>　　●
<code>SS_ONSTACK</code>会在检索现有备用信号栈的信息时设置，表示进程运当前运行在备用信号栈中。试图为运行在备用信号栈中的进程定义备用信号栈会导致错误<code>EPERM</code>。</p>
<p>　　●
<code>SS_DISABLE</code>会出现在<code>old_sigstack</code>中，表示当前没有备用信号栈。当在<code>sigstack</code>中指定该标志时，会禁用1个现有备用信号栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数使用了非异步信号安全函数 (printf()、strsignal()fflush())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigsegvHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal %d (%s)\n&quot;</span>, sig, strsignal(sig));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top of handler stack near %10p\n&quot;</span>, (<span class="type">void</span> *)&amp;x);</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    _exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用于溢出栈的递归函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param callNum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">overflowStack</span><span class="params">(<span class="type">int</span> callNum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">100000</span>]; <span class="comment">/* 让栈帧较大 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Call %4d - top of stack near %10p\n&quot;</span>, callNum, &amp;a[<span class="number">0</span>]);</span><br><span class="line">    overflowStack(callNum + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">stack_t</span> sigstack;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top of standard stack is near %10p\n&quot;</span>, (<span class="type">void</span> *)&amp;j);</span><br><span class="line"></span><br><span class="line">    sigstack.ss_sp = <span class="built_in">malloc</span>(SIGSTKSZ);</span><br><span class="line">    <span class="keyword">if</span> (sigstack.ss_sp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigstack.ss_size = SIGSTKSZ;</span><br><span class="line">    sigstack.ss_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sigaltstack(&amp;sigstack, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaltstack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alternate stack is at %10p-%p\n&quot;</span>,</span><br><span class="line">           sigstack.ss_sp, (<span class="type">char</span> *)sbrk(<span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sa.sa_handler = sigsegvHandler; <span class="comment">/* 为信号SIGSEGV注册处理函数 */</span></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_ONSTACK; <span class="comment">/* 处理函数将使用备用信号栈 */</span></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGSEGV, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    overflowStack(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个程序会定义和使用备用信号栈。在定义了备用信号栈和注册了信号处理函数后，该程序会调用无限递归的函数，所以栈会溢出，并且程序会收到信号<code>SIGSEGV</code>。</p>
<h3 id="标志sa_siginfo">21.5 标志<code>SA_SIGINFO</code></h3>
<p>　　若在通过<code>sigaction()</code>注册信号处理函数时指定了标志<code>SA_SIGINFO</code>，则信号到达时信号处理函数会得到关于信号的额外信号。为此，需要将处理函数声明为以下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *siginfo, <span class="type">void</span> *ucontext)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> si_signo;          <span class="comment">/* 信号编号 */</span></span><br><span class="line">    <span class="type">int</span> si_code;           <span class="comment">/* 信号代码 */</span></span><br><span class="line">    <span class="type">int</span> si_trapno;         <span class="comment">/* 导致硬件生成的信号生成的陷阱号 (大部分架构都不会使用) */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">si_value</span>;</span> <span class="comment">/* 来自sigqueue()的随附数据 */</span></span><br><span class="line">    <span class="type">pid_t</span> si_pid;          <span class="comment">/* 发送进程的进程ID */</span></span><br><span class="line">    <span class="type">uid_t</span> si_uid;          <span class="comment">/* 发送进程的实际用户ID */</span></span><br><span class="line">    <span class="type">int</span> si_errno;          <span class="comment">/* 错误号 (通常不会使用) */</span></span><br><span class="line">    <span class="type">void</span> *si_addr;         <span class="comment">/* 生成信号的地址 (仅限于硬件生成的信号) */</span></span><br><span class="line">    <span class="type">int</span> si_overrun;        <span class="comment">/* 超限计数 (POSIX定时器) */</span></span><br><span class="line">    <span class="type">int</span> si_timerid;        <span class="comment">/* 内核内部的定时器ID (POSIX定时器) */</span></span><br><span class="line">    <span class="type">long</span> si_band;          <span class="comment">/* band event (仅限于信号SIGIO/SIGPOLL) */</span></span><br><span class="line">    <span class="type">int</span> si_fd;             <span class="comment">/* 文件描述符 (仅限于信号SIGIO/SIGPOLL) */</span></span><br><span class="line">    <span class="type">int</span> si_status;         <span class="comment">/* 退出状态或信号 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">clock_t</span> si_utime;      <span class="comment">/* 用户CPU时间 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">clock_t</span> si_stime;      <span class="comment">/* 系统CPU时间 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">short</span> si_addr_lsb;     <span class="comment">/* 地址的最低有效位 (Linux 2.6.32及以上版本) */</span></span><br><span class="line">    <span class="type">void</span> *si_lower;        <span class="comment">/* 发生地址冲突时的下限 (Linux 3.19及以上版本) */</span></span><br><span class="line">    <span class="type">void</span> *si_upper;        <span class="comment">/* 发生地址冲突时的下限 (Linux 3.19及以上版本) */</span></span><br><span class="line">    <span class="type">int</span> si_pkey;           <span class="comment">/* 导致故障的PTE的保护键值 (Linux 4.6及以上版本) */</span></span><br><span class="line">    <span class="type">void</span> *si_call_addr;    <span class="comment">/* 系统调用指令的地址 (Linux 3.5及以上版本) */</span></span><br><span class="line">    <span class="type">int</span> si_syscall;        <span class="comment">/* 尝试系统调用的次数 (Linux 3.5及以上版本) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> si_arch;  <span class="comment">/* 尝试系统调用的架构 (Linux 3.5及以上版本) */</span></span><br><span class="line">&#125; <span class="type">siginfo_t</span>;</span><br></pre></td></tr></table></figure>
<p>　　参数<code>sig</code>是目标信号。参数<code>siginfo</code>指向的结构体提供关于信号的额外信息。参数<code>ucontext</code>指向定义在头文件<code>ucontext.h</code>中的结构体<code>ucontext_t</code>。</p>
<p>　　因为此类信号处理函数的原型不同于标准信号处理函数，所以调用<code>sigaction()</code>需要指定结构体<code>sigaction</code>的成员<code>sa_sigaction</code>。</p>
<p>　　将特性测试宏<code>_POSIX_C_SOURCE</code>定义为大于199309的值后，结构体<code>siginfo_t</code>会被声明在头文件<code>signal.h</code>中。对于Linux和大多数UNIX实现，该结构体中的很多成员都合并为共用体，因为并非每个信号都需要这些成员
(详情见头文件<code>bits/siginfo.h</code>)。</p>
<p>　　●
成员<code>si_signo</code>适用于所有信号，其值与<code>sigaction()</code>的参数<code>sig</code>相同。</p>
<p>　　●
成员<code>si_code</code>适用于所有信号，包含关于信号源的更多信息的代码
(这里没有列出所有UNIX实现和硬件架构都提供的特定于信号的<code>si_code</code>值，尤其是信号<code>SIGBUS</code>、<code>SIGSEGV</code>、<code>SIGILL</code>和<code>SIGFPE</code>。但是，Linux定义了这里列出的所有值，并且SUSv3详细说明了其中的大部分值。值<code>SI_KERNEL</code>和<code>SI_SIGIO</code>是特定于Linux的，SUSv3没有说明这2个值，并且没有UNIX实现提供这2个值。值<code>SI_SIGIO</code>仅用于Linux
2.2。从内核2.4开始，Linux开始使用值<code>POLL_*</code>来代替<code>SI_SIGIO</code>)：</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr>
<th><code>si_code</code>值</th>
<th>适用的信号</th>
<th>信号源</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SI_ASYNCIO</code></td>
<td>所有信号</td>
<td>异步I/O操作完成</td>
</tr>
<tr>
<td><code>SI_KERNEL</code></td>
<td>所有信号</td>
<td>由内核发送 (例如，来自终端驱动程序)</td>
</tr>
<tr>
<td><code>SI_MESGQ</code></td>
<td>所有信号</td>
<td>POSIX消息队列有消息到达 (Linux 2.6.6及以上版本)</td>
</tr>
<tr>
<td><code>SI_QUEUE</code></td>
<td>所有信号</td>
<td>用户进程通过<code>sigqueue()</code>发送实时信号</td>
</tr>
<tr>
<td><code>SI_SIGIO</code></td>
<td>所有信号</td>
<td><code>SIGIO</code>信号 (Linux 2.2)</td>
</tr>
<tr>
<td><code>SI_TIMER</code></td>
<td>所有信号</td>
<td>POSIX实时定时器过期</td>
</tr>
<tr>
<td><code>SI_TKILL</code></td>
<td>所有信号</td>
<td>由用户进程通过<code>tkill()</code>或<code>tgkill()</code>发送 (Linux
2.4.19及以上版本)</td>
</tr>
<tr>
<td><code>SI_USER</code></td>
<td>所有信号</td>
<td>由用户进程通过<code>kill()</code>或<code>raise()</code>发送</td>
</tr>
<tr>
<td><code>BUS_ADRALN</code></td>
<td><code>SIGBUS</code></td>
<td>无效地址对齐</td>
</tr>
<tr>
<td><code>BUS_ADRERR</code></td>
<td><code>SIGBUS</code></td>
<td>不存在的物理地址</td>
</tr>
<tr>
<td><code>BUS_MCEERR_AO</code></td>
<td><code>SIGBUS</code></td>
<td>硬件内存错误，是否采取行动可选 (Linux 2.6.32及以上版本)</td>
</tr>
<tr>
<td><code>BUS_MCEERR_AR</code></td>
<td><code>SIGBUS</code></td>
<td>硬件内存错误，必须采取行动 (Linux 2.6.32及以上版本)</td>
</tr>
<tr>
<td><code>BUS_OBJERR</code></td>
<td><code>SIGBUS</code></td>
<td>特定于对象的硬件错误</td>
</tr>
<tr>
<td><code>CLD_CONTINUED</code></td>
<td><code>SIGCHLD</code></td>
<td>子进程由于信号<code>SIGCONT</code>恢复执行 (Linux
2.6.9及以上版本)</td>
</tr>
<tr>
<td><code>CLD_DUMPED</code></td>
<td><code>SIGCHLD</code></td>
<td>子进程异常终止，并且生成了核心转储文件</td>
</tr>
<tr>
<td><code>CLD_EXITED</code></td>
<td><code>SIGCHLD</code></td>
<td>子进程退出</td>
</tr>
<tr>
<td><code>CLD_KILLED</code></td>
<td><code>SIGCHLD</code></td>
<td>子进程异常终止，并且没有生成核心转储文件</td>
</tr>
<tr>
<td><code>CLD_STOPPED</code></td>
<td><code>SIGCHLD</code></td>
<td>子进程停止</td>
</tr>
<tr>
<td><code>CLD_TRAPPED</code></td>
<td><code>SIGCHLD</code></td>
<td>追踪的子进程停止</td>
</tr>
<tr>
<td><code>FPE_FLTDIV</code></td>
<td><code>SIGFPE</code></td>
<td>浮点数除以0</td>
</tr>
<tr>
<td><code>FPE_FLTINV</code></td>
<td><code>SIGFPE</code></td>
<td>无效浮点数操作</td>
</tr>
<tr>
<td><code>FPE_FLTOVF</code></td>
<td><code>SIGFPE</code></td>
<td>浮点数向上溢出</td>
</tr>
<tr>
<td><code>FPE_FLTRES</code></td>
<td><code>SIGFPE</code></td>
<td>不精确的浮点数结果</td>
</tr>
<tr>
<td><code>FPE_FLTUND</code></td>
<td><code>SIGFPE</code></td>
<td>浮点数向下溢出</td>
</tr>
<tr>
<td><code>FPE_INTDIV</code></td>
<td><code>SIGFPE</code></td>
<td>整数除以0</td>
</tr>
<tr>
<td><code>FPE_INTOVF</code></td>
<td><code>SIGFPE</code></td>
<td>整数溢出</td>
</tr>
<tr>
<td><code>FPE_SUB</code></td>
<td><code>SIGFPE</code></td>
<td>下标超出范围</td>
</tr>
<tr>
<td><code>ILL_BADSTK</code></td>
<td><code>SIGILL</code></td>
<td>内核栈错误</td>
</tr>
<tr>
<td><code>ILL_COPROC</code></td>
<td><code>SIGILL</code></td>
<td>协处理器错误</td>
</tr>
<tr>
<td><code>ILL_ILLADR</code></td>
<td><code>SIGILL</code></td>
<td>非法寻址模式</td>
</tr>
<tr>
<td><code>ILL_ILLOPC</code></td>
<td><code>SIGILL</code></td>
<td>非法操作码</td>
</tr>
<tr>
<td><code>ILL_ILLOPN</code></td>
<td><code>SIGILL</code></td>
<td>非法操作数</td>
</tr>
<tr>
<td><code>ILL_ILLTRP</code></td>
<td><code>SIGILL</code></td>
<td>非法陷阱</td>
</tr>
<tr>
<td><code>ILL_PRVOPC</code></td>
<td><code>SIGILL</code></td>
<td>特权操作码</td>
</tr>
<tr>
<td><code>ILL_PRVREG</code></td>
<td><code>SIGILL</code></td>
<td>特权寄存器</td>
</tr>
<tr>
<td><code>POLL_ERR</code></td>
<td><code>SIGIO</code>/<code>SIGPOLL</code></td>
<td>I/O错误</td>
</tr>
<tr>
<td><code>POLL_HUP</code></td>
<td><code>SIGIO</code>/<code>SIGPOLL</code></td>
<td>设备断开连接</td>
</tr>
<tr>
<td><code>POLL_IN</code></td>
<td><code>SIGIO</code>/<code>SIGPOLL</code></td>
<td>输入数据可用</td>
</tr>
<tr>
<td><code>POLL_MSG</code></td>
<td><code>SIGIO</code>/<code>SIGPOLL</code></td>
<td>输入消息可用</td>
</tr>
<tr>
<td><code>POLL_OUT</code></td>
<td><code>SIGIO</code>/<code>SIGPOLL</code></td>
<td>输出缓冲区可用</td>
</tr>
<tr>
<td><code>POLL_PRI</code></td>
<td><code>SIGIO</code>/<code>SIGPOLL</code></td>
<td>高优先级输入可用</td>
</tr>
<tr>
<td><code>SEGV_ACCERR</code></td>
<td><code>SIGSEGV</code></td>
<td>映射对象的权限无效</td>
</tr>
<tr>
<td><code>SEGV_MAPERR</code></td>
<td><code>SIGSEGV</code></td>
<td>地址未映射到对象</td>
</tr>
<tr>
<td><code>TRAP_BRANCH</code></td>
<td><code>SIGTRAP</code></td>
<td>进程分支陷阱</td>
</tr>
<tr>
<td><code>TRAP_BRKPT</code></td>
<td><code>SIGTRAP</code></td>
<td>进程断点</td>
</tr>
<tr>
<td><code>TRAP_HWBKPT</code></td>
<td><code>SIGTRAP</code></td>
<td>硬件断点/观察点</td>
</tr>
<tr>
<td><code>TRAP_TRACE</code></td>
<td><code>SIGTRAP</code></td>
<td>进程追踪陷阱</td>
</tr>
</tbody>
</table>
<p>　　●
成员<code>si_value</code>包含通过<code>sigqueue()</code>发送的信号的随附数据。</p>
<p>　　●
成员<code>si_pid</code>是通过<code>kill()</code>或<code>sigqueue()</code>发送信号的进程的进程ID。</p>
<p>　　●
成员<code>si_uid</code>是通过<code>kill()</code>或<code>sigqueue()</code>发送信号的进程的实际用户ID。这里提供发送进程的实际用户ID是因为实际用户ID提供的信息比有效用户ID提供的信息更多。当发送进程的实际用户ID与有效用户ID不同时，让接收进程知道发送进程的实际用户ID可能很有用。</p>
<p>　　● 成员<code>si_errno</code>设置为非0值时表示标识信号源的错误号
(与<code>errno</code>类似)。对于Linux，该成员通常不会使用。</p>
<p>　　●
成员<code>si_addr</code>仅适用于信号<code>SIGBUS</code>、<code>SIGSEGV</code>、<code>SIGILL</code>和<code>SIGFPE</code>。对于信号<code>SIGBUS</code>和<code>SIGSEGV</code>，该成员包含导致无效内存引用的地址。对于信号<code>SIGILL</code>和<code>SIGFPE</code>，该成员包含导致信号的程序指令的地址。</p>
<p>　　●
成员<code>si_overrun</code>和<code>si_timerid</code>是非标准Linux扩展，仅会在POSIX定时器过期时生成的信号到达时设置。前者表示定时器的超限计数，后者包含内核内部使用的用于标识定时器的ID。</p>
<p>　　●
成员<code>si_band</code>和<code>si_fd</code>只会在信号<code>SIGIO</code>/<code>SIGPOLL</code>到达时设置。前者包含与I/O事件关联的band
event值 (对于glibc
2.3.2及以下版本，该成员的数据类型为<code>int</code>)，后者包含与I/O事件关联的文件描述符
(SUSv3没有说明该成员，但很多UNIX实现都提供了该成员)。</p>
<p>　　●
成员<code>si_status</code>、<code>si_utime</code>和<code>si_stime</code>只会在信号<code>SIGCHLD</code>到达时设置。成员<code>si_status</code>包含子进程的退出状态
(若成员<code>si_code</code>是<code>CLD_EXITED</code>)
或发送给子进程的信号的编号
(即终止或停止子进程的信号的编号)。成员<code>si_utime</code>是子进程所用的用户CPU时间。对于内核2.6之前的版本和2.6.27及之后的版本，该成员的计量单位是系统时钟周期
(除以<code>sysconf(_SC_CLK_TCK)</code>)。对内核2.6.27之前的2.6版本，漏洞的存在导致该成员的计量单位是jiffy。成员<code>si_stime</code>是子进程所用的系统CPU时间。SUSv3没有说明成员<code>si_utime</code>和<code>si_stime</code>，但很多UNIX实现都提供了这2个成员。</p>
<p>　　SUSv3没有说明结构体<code>ucontext_t</code>的任何成员
(所以参数<code>ucontext</code>的类型是<code>void *</code>)。该结构体提供用户上下文信息，用于描述调用信号处理函数之前的进程状态，其中包括信号掩码的旧值和保存的寄存器值
(例如，程序计数器和栈指针)。信号处理函数几乎不会使用这些信息，所以这里不介绍细节。</p>
<p>　　函数<code>getcontext()</code>、<code>makecontext()</code>、<code>setcontext()</code>和<code>swapcontext()</code>也会使用结构体<code>ucontext_t</code>，这些函数允许进程检索、创建、修改和切换执行上下文
(这些操作与<code>setjmp()</code>和<code>longjmp()</code>类似，但更通用)。这些函数可用于实现协程
(进程的执行线程在多个函数之间交替)。SUSv3说明了这些函数，但将它们标记为过时。SUSv4删除了相关规范，并建议应用程序使用POSIX线程代替它们。</p>
<p>　　SUSv4详细说明了与<code>psignal()</code>类似的函数<code>psiginfo()</code>。该函数有2个参数：指向结构体<code>siginfo_t</code>的指针和消息字符串。该函数会在标准错误中打印消息字符串加上关于结构体<code>siginfo_t</code>的信息。glibc从2.10开始提供该函数。glibc实现会打印信号描述和信号源
(如成员<code>si_code</code>所示)，并且对于某些信号，还会打印结构体<code>siginfo_t</code>的其他成员。<code>psiginfo()</code>是SUSv4新增的规范，但并非所有系统都提供了该函数。</p>
<h3 id="中断和重启系统调用">21.6 中断和重启系统调用</h3>
<p>　　并非所有被信号处理函数中断的阻塞系统调用都可以通过标志<code>SA_RESTART</code>重启，部分原因是历史造成的：</p>
<p>　　●
重启系统调用最早出现在4.2BSD，包含<code>wait()</code>、<code>waitpid()</code>、<code>read()</code>、<code>readv()</code>、<code>write()</code>、<code>writev()</code>和<code>ioctl()</code>的阻塞操作。I/O系统调用是可中断的，所以只有在操作
"慢设备"
时，才会被标志<code>SA_RESTART</code>重启。这些慢设备包括终端、有名管道、无名管道和套接字。对于其他类型的文件，各种I/O操作可能会阻塞。相比之下，磁盘不属于慢设备，因为磁盘I/O操作通常会通过缓冲区缓存立即完成。当需要进行实际的磁盘I/O时，内核会让进程睡眠，直到I/O完成。</p>
<p>　　● 很多其他阻塞系统调用都源于System V，System
V最初不支持重启系统调用。</p>
<p>　　对于Linux，在指定了标志<code>SA_RESTART</code>后，以下阻塞系统调用
(包括基于它们的包装库函数) 在被信号处理函数中断后会自动重启：</p>
<p>　　●
用于等待子进程的系统调用，包括<code>wait()</code>、<code>waitpid()</code>、<code>wait3()</code>、<code>wait4()</code>和<code>waitid()</code>。</p>
<p>　　●
操作慢设备的I/O系统调用，包括<code>read()</code>、<code>readv()</code>、<code>write()</code>、<code>writev()</code>和<code>ioctl()</code>。若数据传输过程中信号到达，则输入和输出系统调用都会被中断，但会返回成功状态
(表示实际传输的字节数的整数)。</p>
<p>　　●
以可阻塞的方式调用的<code>open()</code>(例如，打开有名管道)。</p>
<p>　　●
与套接字一起使用的各种系统调用，包括<code>accept()</code>、<code>accept4()</code>、<code>connect()</code>、<code>send()</code>、<code>sendmsg()</code>、<code>sendto()</code>、<code>recv()</code>、<code>recvfrom()</code>和<code>recvmsg()</code>。对于Linux，若通过<code>setsockopt()</code>为套接字设置了超时时间，则这些系统调用不会自动重启。</p>
<p>　　●
用于POSIX消息队列上的I/O的系统调用，包括<code>mq_receive()</code>、<code>mq_timedreceive()</code>、<code>mq_send()</code>和<code>mq_timedsend()</code>。</p>
<p>　　●
用于对文件上锁的系统调用和库函数，包括<code>flock()</code>、<code>fcntl()</code>和<code>lockf()</code>。</p>
<p>　　●
特定于Linux的系统调用<code>futex()</code>的操作<code>FUTEX_WAIT</code>。</p>
<p>　　●
用于减少POSIX信号量的函数，包括<code>sem_wait()</code>和<code>sem_timedwait()</code>
(对于部分UNIX实现，在指定了标志<code>SA_RESTART</code>后，<code>sem_wait()</code>会自动重启)。</p>
<p>　　●
用于同步POSIX线程的函数，包括<code>pthread_mutex_lock()</code>、<code>pthread_mutex_trylock()</code>、<code>pthread_mutex_timedlock()</code>、<code>pthread_cond_wait()</code>和<code>pthread_cond_timedwait()</code>。</p>
<p>　　在2.6.22之前的内核中，<code>futex()</code>、<code>sem_wait()</code>和<code>sem_timedwait()</code>总是会在被中断时出错
(<code>EINTR</code>)，无论是否指定了标志<code>SA_RESTART</code>。</p>
<p>　　以下阻塞系统调用 (包括基于它们的包装库函数) 永远不会自动重启
(即使指定了标志<code>SA_RESTART</code>)：</p>
<p>　　●
用于I/O多路复用的系统调用，包括<code>poll()</code>、<code>select()</code>和<code>pselect()</code>。SUSv3明确规定，当被信号处理函数中断后，<code>select()</code>和<code>pselect()</code>的行为将是不确定的。</p>
<p>　　●
特定于Linux的系统调用<code>epoll_wait()</code>和<code>epoll_pwait()</code>。</p>
<p>　　● 特定于Linux的系统调用<code>io_getevents()</code>。</p>
<p>　　● 与System
V消息队列和信号量一起使用的阻塞系统调用，包括<code>semop()</code>、<code>semtimedop()</code>、<code>msgrcv()</code>和<code>msgsnd()</code>
(尽管System
V原生不支持重启系统调用，但对于有些UNIX实现，在指定了标志<code>SA_RESTART</code>后，这些系统调用会自动重启)。</p>
<p>　　● 对inotify文件描述符调用的<code>read()</code>。</p>
<p>　　●
用于将程序挂起指定时间的系统调用和库函数，包括<code>sleep()</code>、<code>nanosleep()</code>和<code>clock_nanosleep()</code>。</p>
<p>　　●
用于挂起进程来等待信号的系统调用，包括<code>pause()</code>、<code>sigsuspend()</code>、<code>sigtimedwait()</code>和<code>sigwaitinfo()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">siginterrupt</span><span class="params">(<span class="type">int</span> sig, <span class="type">int</span> flag)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>siginterrupt()</code>会修改参数<code>sig</code>指定的信号关联的<code>SA_RESTART</code>设置。若<code>flag</code>是1，则<code>sig</code>对应的处理函数会中断阻塞系统调用。若<code>flag</code>是0，则阻塞系统调用会在<code>sig</code>对应的处理函数执行完成后重启。</p>
<p>　　该函数通过<code>sigaction()</code>获取信号的当前处理方式，并调整参数<code>oldact</code>中的标志<code>SA_RESTART</code>，然后再次调用<code>sigaction()</code>来更新信号的处理方式。</p>
<p>　　SUSv4将该函数标记为过时，并推荐使用<code>sigaction()</code>来代替该函数。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第24章 进程创建</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_24/</url>
    <content><![CDATA[<p>　　对于很多应用程序，创建多个进程是划分任务的有效方式之一。例如，网络服务器进程可能会监听客户端请求，然后创建子进程来处理器每个请求。同时，服务器进程继续监听。</p>
<h3 id="fork">24.1 <code>fork()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 对于父进程，成功时返回子进程的进程ID，出错时返回-1；对于成功创建的子进程，总是会返回0 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>fork()</code>会创建1个子进程，子进程与父进程
(调用进程)
大致相同。这2个进程都会从<code>fork()</code>返回的位置继续执行。该系统调用的名称源于事实：可以将父进程视为分裂为2个自己的副本。</p>
<p>　　父进程和子进程执行相同的程序，但它们有独立的栈、堆和数据段副本。子进程的栈、堆和数据段最初与父进程内存中的对应部分相同。在<code>fork()</code>返回后，父进程和子进程可以修改自己的栈、堆和数据段中的变量
(不会相互影响)。</p>
<p>　　对于父进程，<code>fork()</code>会返回子进程的进程ID。对于子进程，<code>fork()</code>会返回0。若无法创建子进程，则<code>fork()</code>会返回-1，这可能因为超过该实际用户ID允许的进程数量资源限制
(<code>RLIMIT_NPROC</code>) 或达到可以创建的进程数量的系统级上限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_fork.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> idata = <span class="number">111</span>; <span class="comment">/* 分配在数据段中 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> istack = <span class="number">222</span>; <span class="comment">/* 分配在栈中 */</span></span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        idata *= <span class="number">3</span>;</span><br><span class="line">        istack *= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        sleep(<span class="number">3</span>); <span class="comment">/* 等待子进程执行 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程和子进程都会执行以下代码 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld %s idata=%d istack=%d\n&quot;</span>, (<span class="type">long</span>)getpid(),</span><br><span class="line">           (childPid == <span class="number">0</span>) ? <span class="string">&quot;(child) &quot;</span> : <span class="string">&quot;(parent)&quot;</span>, idata, istack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>fork()</code>的用法。</p>
<span id="more"></span>
<h4 id="父进程和子进程之间的文件共享">24.1.1
父进程和子进程之间的文件共享</h4>
<p>　　当<code>fork()</code>成功时，子进程会继承父进程的所有文件描述符。继承文件描述符的方式如同<code>dup()</code>
(见5.3)，这表示父进程和子进程的文件描述符引用的是同一打开的文件句柄。因为打开的文件句柄包含文件偏移量、打开文件状态标志，所以父进程和子进程共享打开的文件的这些属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* fork_file_sharing.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, flags;</span><br><span class="line">    <span class="type">char</span> template[] = <span class="string">&quot;/tmp/testXXXXXX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    fd = mkstemp(template);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;mkstemp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File offset before fork(): %lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)lseek(fd, <span class="number">0</span>, SEEK_CUR));</span><br><span class="line"></span><br><span class="line">    flags = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;fcntl - F_GETFL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;O_APPEND flag before fork() is: %s\n&quot;</span>, (flags &amp; O_APPEND) ? <span class="string">&quot;on&quot;</span> : <span class="string">&quot;off&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程: 修改文件偏移量和状态标志 */</span></span><br><span class="line">        <span class="keyword">if</span> (lseek(fd, <span class="number">1000</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flags = fcntl(fd, F_GETFL); <span class="comment">/* 获取当前状态标志 */</span></span><br><span class="line">        <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fcntl - F_GETFL&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flags |= O_APPEND; <span class="comment">/* 启用标志O_APPEND */</span></span><br><span class="line">        <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fcntl - F_SETFL&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程: 获取子进程修改后的文件偏移量和状态标志 */</span></span><br><span class="line">        <span class="keyword">if</span> (wait(<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child has exited\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;File offset in parent: %lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)lseek(fd, <span class="number">0</span>, SEEK_CUR));</span><br><span class="line"></span><br><span class="line">        flags = fcntl(fd, F_GETFL);</span><br><span class="line">        <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fcntl - F_GETFL&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;O_APPEND flag in parent is: %s\n&quot;</span>, (flags &amp; O_APPEND) ? <span class="string">&quot;on&quot;</span> : <span class="string">&quot;off&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过<code>mkstemp()</code>打开1个临时文件，然后调用<code>fork()</code>创建子进程。子进程会修改临时文件的文件偏移量和打开文件状态标志。最后，父进程会检索文件偏移量和打开文件状态标志。</p>
<h4 id="fork的内存语义">24.1.2 <code>fork()</code>的内存语义</h4>
<p>　　从概念角度，<code>fork()</code>可是视为创建父进程的栈、堆、文本段和数据段的副本
(对于某些早期UNIX实现，确实如此)。但是，直接将父进程的虚拟内存页复制给子进程很浪费。<code>fork()</code>后紧接的通常是<code>exec()</code>，这会将进程的文本段替换为新程序并重新初始化进程的栈、堆和数据段。Linux和大多数现代UNIX实现使用了2种技术来避免这种浪费：</p>
<p>　　●
内核将父进程和子进程的文本段标记为只读，这表示父进程和子进程共享同一文本段。<code>fork()</code>通过为子进程构建一些页表条目来为创建子进程的文本段，这些页表条目引用父进程使用的虚拟内存页。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_24/page_tables_before_and_after_modification_of_a_shared_copy-on-write_page.svg" class="">
<p>　　● 对于父进程的栈、堆和数据段，内核会使用<span
style="background-color: yellow">写时复制</span>技术。内核先设置子进程的这些段的页表条目，以便它们与父进程的对应页表条目引用同一物理内存页
(这些物理页为只读)。在调用<code>fork()</code>后，父进程或子进程试图修改这些页时会触发故障，内核会复制待修改的页，将其分配给导致故障的进程并适当地修改相应的页表条目。从此以后，父进程和子进程可以各自修改这些页的私有副本
(做出的修改对彼此不可见)。</p>
<h4 id="控制进程的内存占用">24.1.3 控制进程的内存占用</h4>
<p>　　可以通过结合<code>fork()</code>和<code>wait()</code>来控制进程的内存占用。进程的内存占用受到栈和堆的伸缩等因素的影响。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> childPid;</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">childPid = fork();</span><br><span class="line"><span class="keyword">if</span> (childPid == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (childPid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>(func(arg)); <span class="comment">/* 子进程调用func()并将其返回值作为自己的返回状态 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wait(&amp;status) == <span class="number">-1</span>) <span class="comment">/* 父进程等待子进程终止 (可以通过status获取func()的返回值) */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何在保证父进程的内存占用不变的前提下调用函数。</p>
<p>　　●
当<code>func()</code>会导致内存泄漏或堆溢出，并且无法访问该函数的源码的来解决这些问题时，这种方法很有用。</p>
<p>　　● 假设需要使用一些算法在执行树分析时分配内存
(例如，游戏程序可能会分析大量可能的操作及其响应)。可以直接调用<code>free()</code>来释放分配的内存。但是，在某些情况下，直接使用这种方法可能更简单。</p>
<p>　　这里展示的方法仅适用于<code>func()</code>的返回值是8位的情况。当<code>func()</code>返回的结果更大时，可以使用文件、管道或其他IPC方式。</p>
<h4 id="竞争条件">21.1.4 竞争条件</h4>
<p>　　在调用<code>fork()</code>后，父进程和子进程的调度顺序是不确定的
(对于多处理器系统，父进程和子进程可能同时调度)。对于 (显式或隐式)
依赖执行顺序的应用程序，可能由于竞争条件而导致意料之外的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* fork_whos_on_first.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numChildren, j;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [num-children]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numChildren = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;num-children&quot;</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numChildren; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (childPid = fork())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d child\n&quot;</span>, j);</span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d parent\n&quot;</span>, j);</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了这种不确定性。这个程序会循环调用<code>fork()</code>来创建子进程，然后打印包含循环次数和指示进程是父进程还是子进程的字符串。</p>
<p>　　对于Linux
2.6.32及以上版本，默认情况是<code>fork()</code>后父进程先于子进程被调度。这可以通过将特定于Linux的文件<code>/proc/sys/kernel/sched_child_runs_first</code>赋值为非0值来修改。</p>
<p>　　因此，在开发程序时不应该假设<code>fork()</code>后父进程和子进程的调度顺序。为了确保父进程和子进程的调度顺序，需要使用同步机制
(例如，信号、信号量、文件锁以及消息传递)。</p>
<h4 id="通过信号同步避免竞争条件">24.1.5 通过信号同步避免竞争条件</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* fork_sig_sync.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span> <span class="comment">/* 函数currTime()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYNC_SIG SIGUSR1 <span class="comment">/* 同步信号 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line">    <span class="type">sigset_t</span> blockMask, origMask, emptyMask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;blockMask);</span><br><span class="line">    sigaddset(&amp;blockMask, SYNC_SIG);</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;blockMask, &amp;origMask) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SYNC_SIG, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s %ld] Child started - doing some work\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), (<span class="type">long</span>)getpid());</span><br><span class="line">        sleep(<span class="number">2</span>); <span class="comment">/* 模拟执行一些操作 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 发送信号 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s %ld] Child about to signal parent\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), (<span class="type">long</span>)getpid());</span><br><span class="line">        <span class="keyword">if</span> (kill(getppid(), SYNC_SIG) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s %ld] Parent about to wait for signal\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), (<span class="type">long</span>)getpid());</span><br><span class="line">        sigemptyset(&amp;emptyMask);</span><br><span class="line">        <span class="keyword">if</span> (sigsuspend(&amp;emptyMask) == <span class="number">-1</span> &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigsuspend&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s %ld] Parent got signal\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), (<span class="type">long</span>)getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 恢复信号掩码 */</span></span><br><span class="line">        <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;origMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何通过信号同步避免竞争条件。这里假设父进程必须等待子进程执行某些操作
(若子进程必须等待父进程执行某些操作，则可以将信号相关的函数调用互换。有时，父进程和子进程会相互发送多次信号来协调行为，但这种协调通常都是通过信号量、文件锁或消息传递来完成)。在调用<code>fork()</code>前需要先阻塞同步信号。当父进程在调用<code>fork()</code>后需要再次阻塞同步信号时，它还是容易受到竞争条件的影响
(这里假设子进程的信号掩码无关紧要，若有必要，则可以像父进程一样可以恢复信号掩码)。</p>
<h3 id="vfork">24.2 <code>vfork()</code></h3>
<p>　　早期BSD实现的<code>fork()</code>会直接复制父进程的栈、堆和数据段，但这种行为很浪费。因此，后续版本的BSD添加了系统调用<code>vfork()</code>。<code>vfork()</code>比<code>fork()</code>更高效，但行为有所不同。</p>
<p>　　现代UNIX实现使用写时复制技术实现<code>fork()</code>，这大幅提升了其效率，所以在很大程度上不再需要<code>vfork()</code>。尽管如此，Linux和很多UNIX实现还是提供了BSD语义的<code>vfork()</code>。但是，<code>vfork()</code>不同寻常的语义可能会导致细微的程序漏洞，所以通常不会使用该系统调用
(除非极其需要<code>vfork()</code>带来的性能提升)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">vfork</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 对于父进程，成功时返回子进程的进程ID，出错时返回-1；对于成功创建的子进程，总是会返回0 */</span></span><br></pre></td></tr></table></figure>
<p>　　与<code>fork()</code>类似，<code>vfork()</code>也会创建1个子进程。但是，<code>vfork()</code>旨在用于那些子进程立即调用<code>exec()</code>的程序中。</p>
<p>　　<code>vfork()</code>与<code>fork()</code>的2个不同之处使<code>vfork()</code>更高效：</p>
<p>　　●
<code>vfork()</code>不会为子进程复制虚拟内存页或页表。相反，子进程会使用父进程的内存，直到子进程成功调用<code>exec()</code>或通过<code>_exit()</code>终止。</p>
<p>　　●
<code>vfork()</code>会导致父进程的执行会被挂起，直到子进程成功调用<code>exec()</code>或通过<code>_exit()</code>终止。</p>
<p>　　这2个不同之处会产生一些影响。由于子进程会使用父进程的内存，一旦父进程恢复，子进程对栈、堆和数据段的修改都会被父进程看到。此外，当子进程在<code>vfork()</code>和后续的<code>exec()</code>或<code>_exit()</code>之间执行函数返回时，也会影响父进程。这与6.6.3中的通过<code>longjmp()</code>非本地跳转到已经返回的函数类似，并且通常会导致段故障
(<code>SIGSEGV</code>)。</p>
<p>　　子进程在<code>vfork()</code>与<code>exec()</code>之间能执行的不影响父进程的操作很少，其中包括对打开的文件描述符的操作
(但不包括<code>stdio</code>文件流)，因为每个进程的文件描述符表维护在内核空间，并且在执行<code>fork()</code>时会被复制。</p>
<p>　　<code>vfork()</code>的语义会保证子进程先于父进程调度，并且父进程会一直阻塞，直到子进程成功调用<code>exec()</code>或通过<code>_exit()</code>终止。</p>
<p>　　当使用<code>vfork()</code>时，尽量保证子进程立即调用<code>exec()</code>。若<code>exec()</code>出错，则子进程应该调用<code>_exit()</code>终止。</p>
<p>　　SUSv3规定，以下3种情况会导致程序的行为是未定义的：</p>
<p>　　● 修改用于存储<code>vfork()</code>的返回值的变量以外的数据。</p>
<p>　　● 从调用<code>vfork()</code>的函数中返回。</p>
<p>　　●
在成功调用<code>exec()</code>或通过<code>_exit()</code>终止之前调用其他函数。</p>
<p>　　SUSv3将<code>vfork()</code>标记为过时，SUSv4删除了<code>vfork()</code>的规范。SUSv3没有详细说明<code>vfork()</code>的很多细节，并且允许将其实现为调用<code>fork()</code>。当<code>vfork()</code>以这种方式实现时，BSD语义将不再生效
(内核2.0及以下版本的Linux和有些UNIX实现就是如此)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_vfork.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> istack = <span class="number">222</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (vfork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;vfork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程会先于父进程执行 (在父进程的内存空间) */</span></span><br><span class="line">        sleep(<span class="number">3</span>); <span class="comment">/* 即使睡眠一段时间，父进程也不会被调度 */</span></span><br><span class="line"></span><br><span class="line">        write(STDOUT_FILENO, <span class="string">&quot;Child executing\n&quot;</span>, <span class="number">16</span>);</span><br><span class="line">        istack *= <span class="number">3</span>;</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 在子进程终止前，父进程都会一直阻塞 */</span></span><br><span class="line">        write(STDOUT_FILENO, <span class="string">&quot;Parent executing\n&quot;</span>, <span class="number">17</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;istack=%d\n&quot;</span>, istack);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>vfork()</code>的BSD语义。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第25章 进程终止</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_25/</url>
    <content><![CDATA[<p>　　进程可以通过2种方式终止。第1种方式是<strong>正常终止</strong>
(通过系统调用<code>_exit()</code>或从主函数返回)。第2种方式是<strong>异常终止</strong>，因为收到默认处理方式是终止进程的信号
(无论是否生成核心转储文件)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure>
<p>　　对于系统调用<code>_exit()</code>，参数<code>status</code>用于指定进程的<strong>终止状态</strong>。父进程可以调用<code>wait()</code>来获取子进程的终止状态。尽管该参数的数据类型为<code>int</code>，但父进程只能访问低8位。该系统调用总是会终止进程
(即不会返回)。</p>
<p>　　按照惯例，终止状态为0时表示进程成功终止，终止状态不为0时表示进程没有成功终止。如何解释终止状态不为0的情况因应用程序而异。SUSv3详细说明了2个常量：<code>EXIT_SUCCESS</code>
(0) 和<code>EXIT_FAILURE</code> (1)。</p>
<p>　　程序通常不会直接调用<code>_exit()</code>，而是调用库函数<code>exit()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>
<p>　　库函数<code>exit()</code>会执行以下操作：</p>
<p>　　● 按照退出处理函数注册顺序的逆序调用退出处理函数。</p>
<p>　　● 刷新stdio流缓冲区。</p>
<p>　　● 以参数<code>status</code>指定的值调用<code>_exit()</code>。</p>
<p>　　不同于特定于UNIX的<code>_exit()</code>，<code>exit()</code>是C标准库的一部分，所有C实现都提供了该函数。</p>
<p>　　在主函数中调用<code>return n</code>通常等同于调用<code>exit(n)</code>，因为调用主函数的运行时函数在调用<code>exit()</code>时使用的是主函数的返回值。</p>
<p>　　若退出处理过程包括访问主函数中的局部变量
(例如，调用<code>setvbuf()</code>和<code>setbuf()</code>时指定了主函数中的局部变量)，则从主函数返回将会导致未定义的结果。在这种情况下，调用<code>exit()</code>不等同于从主函数返回。</p>
<p>　　从主函数返回时不指定返回值或在主函数的末尾退出也会导致调用的主函数的函数调用<code>exit()</code>，但具体结果取决于使用的C标准版本和编译选项：</p>
<p>　　●
对于C89，这些情况下的行为是未定义的，程序可能以任意<code>status</code>值返回。这也是Linux上的gcc的默认行为，程序的终止状态将会是栈中的某个随机值或取自特定CPU寄存器，所以应该避免通过这种方式终止程序。</p>
<p>　　●
对于C99，在主函数的末尾退出等同于调用<code>exit(0)</code>。这也是在Linux上使用<code>gcc –std=c99</code>编译程序时的行为。</p>
<span id="more"></span>
<h3 id="进程终止细节">25.1 进程终止细节</h3>
<p>　　当进程终止时，会执行以下操作：</p>
<p>　　●
打开的文件描述符、目录流、消息目录描述符和转换描述符都会被关闭。</p>
<p>　　● 因为关闭了文件描述符，所以进程持有的所有文件锁都会被释放。</p>
<p>　　● 相关的System
V共享内存段会被分离，并且这些内存段对应的<code>shm_nattch</code>计数器会减1。</p>
<p>　　● 对于所有<code>semadj</code>值由进程设置的System
V信号量，其值会增加<code>semadj</code>。</p>
<p>　　●
若进程是控制终端的控制进程，则控制终端的前台进程组的所有进程都会收到信号<code>SIGHUP</code>，然后终端会与会话取消关联。</p>
<p>　　● 打开的POSIX命名信号量会被关闭
(如同调用<code>sem_close()</code>)。</p>
<p>　　● 打开的POSIX消息队列会被关闭
(如同调用<code>mq_close()</code>)。</p>
<p>　　●
进程的终止会导致某个进程组变成孤儿进程组。若该进程组中存在停止的进程，则该进程组的所有进程都会先收到信号<code>SIGHUP</code>，再收到信号<code>SIGCONT</code>。</p>
<p>　　●
进程通过<code>mlock()</code>或<code>mlockall()</code>设置的内存锁会被删除。</p>
<p>　　● 进程通过<code>mmap()</code>设置的内存映射会被解除映射。</p>
<h3 id="退出处理函数">25.2 退出处理函数</h3>
<p>　　有时，应用程序在进程终止时会自动执行一些操作。以应用程序库为例，应用程序库会在进程的生命周期内使用，并且在进程退出时需要自动执行一些清理操作。应用程序库不能控制进程的生命周期，并且无法强制主函数在退出前调用特定的清理函数，所以清理操作可能不会执行。解决方法之一是使用<strong>退出处理函数</strong>
(较旧的System V手册使用的是术语<span
style="background-color: yellow">程序终止例程</span>)。</p>
<p>　　退出处理函数是程序员提供的函数，该函数会在进程的生命周期的某个时间点注册。当进程通过<code>exit()</code>正常终止时，会自动调用退出处理函数。若程序直接调用<code>_exit()</code>或者进程被信号终止，则不会自动调用退出处理函数。</p>
<p>　　在某种程度上，进程因信号终止时不自动调用退出处理函数限制了退出处理函数的实用性。对于这种情况，最好的处理方法是注册信号处理函数，并在信号处理函数中设置会导致主函数调用<code>exit()</code>的全局标志
(因为<code>exit()</code>是非异步信号安全函数，所以不能直接在信号处理函数中直接调用<code>exit()</code>)。但是，这也无法处理信号<code>SIGKILL</code>，因为该信号的处理方式无法被修改，这也是避免使用该信号来终止进程的理由之一。</p>
<h4 id="注册退出处理函数">25.2.1 注册退出处理函数</h4>
<p>　　glibc提供了2种注册退出处理函数的方法。第1种方法是使用函数<code>atexit()</code>，SUSv3详细说明了这种方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span>; <span class="comment">/* 成功时返回0，出错时返回非0值 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>atexit()</code>会将参数<code>func</code>指向的函数添加1个函数列表，调用进程在终止会调用该函数列表中的所有函数。<code>func</code>指向的函数应该声明为没有参数和返回值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<code>atexit()</code>在出错时返回的是非0值，而非-1。</p>
<p>　　退出处理函数可以注册多个
(同一退出处理函数甚至可以注册多次)。当程序调用<code>exit()</code>时，这些退出处理函数会按照注册顺序的逆序被调用。</p>
<p>　　从理论角度，退出处理函数中可以执行任意操作
(包括注册退出处理函数)。但是，若某个退出处理函数因调用<code>_exit()</code>或进程被信号终止
(例如，退出处理函数调用<code>raise()</code>)
而无法返回，则剩余的退出处理函数不会被调用。此外，<code>exit()</code>通常会执行的其他操作
(即刷新stdio缓冲区) 也不会被执行。</p>
<p>　　SUSv3规定，若退出处理函数调用<code>exit()</code>，则结果将是未定义的。对于Linux，剩余的退出处理函数会正常被调用。但是，对于有些系统，这会导致再次调用所有退出处理函数，进而导致无限递归
(直到栈溢出终止进程)。</p>
<p>　　SUSv3要求实现允许单个进程能够注册至少32个退出处理函数。可以通过调用<code>sysconf(_SC_ATEXIT_MAX)</code>来获取实现定义的可以注册的退出处理函数的数量上限
(但是，无法获取已注册的退出处理函数的数量)。通过将已注册的退出处理器函数链接在动态分配的链表中，glibc允许注册几乎无限数量的退出处理函数。对于Linux，可以注册的退出处理函数的数量上限是2147482647
(即32位有符号整数的最大值)。</p>
<p>　　通过<code>fork()</code>创建的子进程会继承父进程注册的退出处理函数。当进程调用<code>exec()</code>时，所有注册的退出处理函数会被删除
(因为<code>exec()</code>会替换退出处理函数的代码和现有程序的剩余代码)。</p>
<p>　　通过<code>atexit()</code>注册的退出处理函数存在很多限制。第1个限制是调用退出处理函数时退出处理函数无法得知传递给<code>exit()</code>的终止状态。第2个限制是退出处理函数没有参数。为此，glibc提供了<span
style="background-color: yellow">非标准</span>函数<code>on_exit()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE <span class="comment">/* 或#define _SVID_SOURCE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">on_exit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">int</span>, <span class="type">void</span> *), <span class="type">void</span> *arg)</span>; <span class="comment">/* 成功时返回0，出错时返回非0值 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>on_exit()</code>与<code>atexit()</code>类似，但参数<code>func</code>指向的函数有2个参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> status, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　参数<code>status</code>是传递给<code>exit()</code>的终止状态。参数<code>arg</code>可以是指向结构体的指针或标量类型。</p>
<p>　　与<code>atexit()</code>相同，<code>on_exit()</code>在出错时会返回非0值。同一进程可以通过<code>on_exit()</code>注册多个退出处理函数，并且通过<code>atexit()</code>和<code>on_exit()</code>注册的退出处理函数位于同一函数列表
(若程序中同时使用了这2个函数，则退出处理函数会按照通过这2个函数注册的顺序的逆序被调用)。</p>
<h4 id="示例程序">25.2.2 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* exit_handlers.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">atexitFunc1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atexit function 1 called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">atexitFunc2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atexit function 2 called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">onexitFunc</span><span class="params">(<span class="type">int</span> exitStatus, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;on_exit function called: status=%d, arg=%ld\n&quot;</span>, exitStatus, (<span class="type">long</span>)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (on_exit(onexitFunc, (<span class="type">void</span> *)<span class="number">10</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;on_exit 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (atexit(atexitFunc1) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;atexit 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (atexit(atexitFunc2) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;atexit 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (on_exit(onexitFunc, (<span class="type">void</span> *)<span class="number">20</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;on_exit 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何通过<code>atexit()</code>和<code>on_exit()</code>注册退出处理函数。</p>
<h3 id="forkstdio缓冲区和_exit之间的相互作用">25.3
<code>fork()</code>、stdio缓冲区和<code>_exit</code>之间的相互作用</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* fork_stdio_buf.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Ciao\n&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　当在终端运行这个程序时，可以得到预期结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fork_stdio_buf</span></span><br><span class="line">Hello world</span><br><span class="line">Ciao</span><br></pre></td></tr></table></figure>
<p>　　但是，将标准输出重定向到文件后，得到的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fork_stdio_buf &gt; a</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> a</span></span><br><span class="line">Ciao</span><br><span class="line">Hello world</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>　　stdio缓冲区维护在进程的用户空间内存
(见13.2)，所以子进程会继承父进程的stdio缓冲区。将标准输出重定向到终端时默认使用的是行缓冲，所以通过<code>printf()</code>写入的以换行符结尾的字符串会立即出现在终端。但是，将标准输出重定向到文件时默认使用的是块缓冲，所以调用<code>fork()</code>时通过<code>printf()</code>写入的字符串仍然位于父进程的stdio缓冲区中，子进程会继承该缓冲区。当随后调用<code>exit()</code>时，会刷新父进程和子进程的stdio缓冲区，导致通过<code>printf()</code>写入的字符串重复出现。</p>
<p>　　可以通过以下方法之一避免这种情况：</p>
<p>　　●
对于stdio缓冲区，可以在调用<code>fork()</code>之前先通过<code>fflush()</code>来刷新stdio缓冲区，也可以通过<code>setvbuf()</code>或<code>setbuf()</code>来禁用stdio流的缓冲。</p>
<p>　　●
在子进程中调用<code>_exit()</code>来防止刷新stdio缓冲区。这种方法体现了1个更通用的原则：对于多进程应用程序，通常只有1个进程
(大多数情况下是父进程)
使用<code>exit()</code>终止，其他进程使用<code>_exit()</code>终止。这会保证只有1个进程会调用退出处理函数和刷新stdio缓冲区。</p>
<p>　　这个示例中通过<code>write()</code>写入的字符串不会重复出现，因为<code>write()</code>会直接将数据传输到内核缓冲区，并且内核缓冲区不会被<code>fork()</code>复制。stdio缓冲区中的数据只会在stdio缓冲区被刷新时才会被传输，所以通过<code>write()</code>写入的字符串出现在通过<code>printf()</code>写入的字符串之前。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第20章 信号：基本概念</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_20/</url>
    <content><![CDATA[<p>　　<strong>信号</strong>是事件发生时进程收到的通知。信号有时也称为<strong>软件中断</strong>。与硬件中断类似，信号也会中断程序的正常执行流程。在大多数情况下，信号何时达到是无法预测的。</p>
<p>　　进程 (需要合适的权限)
可以发送信号给其他进程，所以信号可以作为同步技术或进程间通信的原始形式。此外，进程也可以发送信号给自己。但是，在大多数情况下，信号都是由内核发送。以下事件会导致内核发送信号给进程：</p>
<p>　　● 发生<span style="background-color: yellow">硬件异常</span>
(例如，执行格式错误的机器语言指令、除以0或引用无法访问的内存区域)，这表示硬件检测到故障，并通知内核，然后内核发送对应的信号给相关进程。</p>
<p>　　● 用户在终端输入<span
style="background-color: yellow">中断字符</span> (通常是Control-C)
和<span style="background-color: yellow">挂起字符</span>
(通常是Control-Z)。</p>
<p>　　● 发生<span style="background-color: yellow">软件事件</span>
(例如，文件描述符的输入可用、终端窗口的大小被调整、定时器过期、超过进程的CPU时间限制或子进程终止)。</p>
<p>　　每个信号都有1个唯一的整数编号
(从1开始)。这些编号定义在头文件<code>signal.h</code>中，其符号名为<code>SIGxxxx</code>。信号的编号因实现而异，所以程序中使用的都是对应的符号名。</p>
<p>　　信号分为2个大类。第1个大类由<span
style="background-color: yellow">传统信号</span>或<span
style="background-color: yellow">标准信号</span>组成，内核使用这些信号来通知进程事件的发生。对于Linux，标准信号的编号是1~31。第2个大类由<span
style="background-color: yellow">实时信号</span>组成。</p>
<p>　　信号由某些事件生成。随后，信号会传递给进程，进程会采取对应的处理方式来响应。<strong>待处理信号</strong>是已生成但未传递的信号。若目标进程被挂起，则待处理信号会在进程下次调度运行时尽快传递；若目标进程正在运行，则待处理信号会立即传递。</p>
<p>　　有时，可能需要保证代码块不会被某些信号中断。为此，需要将这些信号添加带进程的<strong>信号掩码</strong>
(即当前被阻塞的信号的集合)。若信号生成时已被阻塞，则该信号会一直位于待处理状态，直达目标进程解除阻塞
(将其从信号掩码中删除)。</p>
<p>　　当信号到达后，进程会根据信号来采取以下默认处理方式之一：</p>
<p>　　● 忽略信号，即内核会丢弃信号，并且信号对进程没有任何影响
(进程甚至不会知道信号的到达)。</p>
<p>　　● 终止进程，这种情况也称为<strong>异常进程终止</strong>
(与进程通过<code>exit()</code>正常终止相反)。</p>
<p>　　●
生成核心转储文件，然后终止进程。核心转储文件包含进程的虚拟内存映像，该映像可以加载调试器中，以便检查进程终止时的状态。</p>
<p>　　● 停止进程，即进程的执行被挂起。</p>
<p>　　● 进程从停止中恢复执行。</p>
<p>　　程序可以更改信号到达后的处理方式
(而非以上默认处理方式)，即信号的处理方式。程序可以将信号的处理方式设置为默认处理方式、忽略信号或执行<strong>信号处理函数</strong>。信号处理函数是程序员编写的函数，用于执行合适的任务来响应信号。通知内核调用信号处理函数称为<span
style="background-color: yellow">安装</span>或<span
style="background-color: yellow">注册</span>信号处理函数。若信号处理函数被调用来响应信号，则表示信号已被<span
style="background-color: yellow">处理</span>或<span
style="background-color: yellow">捕获</span>。</p>
<span id="more"></span>
<p>　　UNIX系统提供了2种注册信号处理函数的方法，系统调用<code>signal()</code>和<code>sigaction()</code>。前者是注册信号处理函数的原生API，其接口比后者更简单，但后者提供的功能更多。此外，前者的行为可能因UNIX实现而异。考虑到可移植问题，后者是注册信号处理函数的首选API。</p>
<p>　　无法将信号的处理方式设置为终止进程或生成核心转储文件
(除非是信号的默认处理方式)，只能通过注册调用<code>exit()</code>或<code>abort()</code>
(生成信号<code>SIGABRT</code>) 的信号处理函数来模拟这些处理方式。</p>
<p>　　可以通过特定于Linux的文件<code>/proc/PID/status</code>中的位掩码字段来获取进程如何处理信号。这些位掩码字段显示为十六进制数，最低有效位表示信号1，其左边的第1个位表示信号2，依此类推。这些字段是<code>SigPnd</code>
(线程的待处理信号)、<code>ShdPnd</code> (进程的待处理信号，Linux
2.6及以上版本)、<code>SigBlk</code> (阻塞的信号)、<code>SigIgn</code>
(忽略的信号) 和<code>SigCgt</code>
(捕获的信号)。同样的信息也可以通过命令<code>ps</code>获取。</p>
<p>　　信号出现在非常早期的UNIX实现中，但自诞生以来已经经历了很多重大变化。在早期实现中，信号在某些情况下可以丢弃
(即不传递给目标进程)。此外，尽管提供了用于在执行关键代码时阻塞信号传递的机制，但阻塞在某些情况下不会生效。这个问题在4.2BSD得到修复，它提供了<span
style="background-color: yellow">可靠信号</span>
(BSD的另一项创新是添加了额外的信号来支持shell作业控制)。</p>
<p>　　System
V也为信号添加了可靠的语义，但使用的模型与BSD不兼容。POSIX.1-1990解决了这些不兼容问题，因为POSIX.1-1990采用了主要基于BSD模型的可靠信号规范。</p>
<h3 id="信号类型和默认处理方式">20.1 信号类型和默认处理方式</h3>
<p>　　Linux标准信号的编号是1~31，但Linux的信号手册列出的信号名不止31个，多余的信号名功能不尽相同。有些信号名等同于其他信号名，这些信号名是为了保证与其他UNIX实现的源代码级兼容而定义。其他信号名没有实际使用。</p>
<p>　　●
信号<code>SIGABRT</code>是进程调用<code>abort()</code>时收到的信号。在默认情况下，该信号导致进程生成核心转储文件，然后终止，这正是调用<code>abort()</code>的目的。</p>
<p>　　●
信号<code>SIGALRM</code>是调用<code>alarm()</code>或<code>settimer()</code>设置的<span
style="background-color: yellow">实时定时器</span> (基于挂钟时间)
过期时内核生成的信号。</p>
<p>　　● 信号<code>SIGBUS</code> (意为 "总线错误")
表示特定类型的内存访问错误。</p>
<p>　　● 信号<code>SIGCHLD</code>是进程的子进程终止时收到的信号
(由内核生成)。当进程的子进程被信号停止或恢复时，进程也会收到该信号。</p>
<p>　　● 信号<code>SIGCLD</code>等同于<code>SIGCHLD</code>。</p>
<p>　　●
信号<code>SIGCONT</code>用于恢复停止的进程。若进程收到该信号时不处于停止状态，则该信号默认会被忽略。进程可以捕获该信号，以便在恢复时执行某些操作。</p>
<p>　　● 信号<code>SIGEMT</code>在UNIX系统中通常表示依赖于实现的硬件错误
(后缀<code>EMT</code>源于Digital PDP-11中的汇编助记符emulator
trap)。对于Linux，该信号仅用于Sun SPARC实现。</p>
<p>　　● 信号<code>SIGFPE</code>表示除以0等算术错误
(后缀<code>FPE</code>是floating-point
exception的缩写，尽管整数算术错误也会生成该信号)。该信号的具体生成时间取决于硬件架构和CPU控制寄存器的设置。例如，对于x86-32，整数除以0会生成该信号，但浮点数除以0是否生成该信号取决于异常<code>FE_DIVBYZERO</code>是否启用。若通过<code>feenableexcept()</code>启用了该异常，则生成信号<code>SIGFPE</code>；否则，生成IEEE标准的结果
(浮点数形式的无穷大)。</p>
<p>　　● 信号<code>SIGHUP</code>是终端断开连接时终端的控制进程收到的信号
(后缀<code>HUP</code>是hang up的缩写)。该信号的第2个用途是与守护进程
(例如，<code>init</code>、<code>httpd</code>和<code>inetd</code>)
一起使用，很多守护进程被设计为收到该信号后重新初始化，然后重新读取配置文件。系统管理员可以通过手动发送该信号给守护进程
(命令<code>kill</code>) 来触发这些行为。</p>
<p>　　●
信号<code>SIGILL</code>是进程试图执行格式错误的机器语言指令时收到的信号。</p>
<p>　　●
信号<code>SIGINFO</code>在Linux中等同于<code>SIGPWR</code>。对于BSD系统，该信号是用户在终端输入Control-T
(获取前台进程组的状态信息) 时生成的信号。</p>
<p>　　●
信号<code>SIGINT</code>是用户在终端输入中断字符时终端驱动程序发送给前台进程组的信号。该信号的默认处理方式是终止进程。</p>
<p>　　●
信号<code>SIGIO</code>是调用<code>fcntl()</code>对特定类型的打开的文件描述符
(例如，用于终端和套接字的打开的文件描述符)
执行某些操作后，文件描述符的I/O事件 (例如，输入可用) 生成的信号。</p>
<p>　　●
信号<code>SIGIOT</code>在Linux中等同于<code>SIGABRT</code>。对于部分UNIX实现，该信号表示实现定义的硬件故障。</p>
<p>　　●
信号<code>SIGKILL</code>会终止进程，并且无法被阻塞、忽略或捕获。</p>
<p>　　●
信号<code>SIGLOST</code>在Linux中未使用。对于有些UNIX实现，若NFS客户端在恢复崩溃的远程NFS服务器时无法重新获取本地进程持有的锁，则NFS客户端会发送该信号给这些本地进程
(该特性没有被NFS规范标准化)。</p>
<p>　　●
信号<code>SIGPIPE</code>是发送进程试图写没有接收进程的有名管道、无名管道或套接字时生成的信号。这通常是因为接收进程关闭了其IPC通道的文件描述符。</p>
<p>　　● 信号<code>SIGPOLL</code>在Linux中等同于<code>SIGIO</code>
(源于System V)。</p>
<p>　　●
信号<code>SIGPROF</code>是调用<code>settimer()</code>设置的<span
style="background-color: yellow">剖析定时器</span>
(基于进程使用的CPU时间)
过期时内核生成的信号。与虚拟定时器不同，剖析定时器计算进程在用户模式和内核模式下所用的CPU时间。</p>
<p>　　● 信号<code>SIGPWR</code>是<span
style="background-color: yellow">电源故障</span>信号。对于带有不间断电源
(UPS)
的系统，可以设置1个用于在发生电源故障事件时监控备用电池的守护进程。若电池电量即将耗尽
(长时间停电)，则监控进程会发送该信号给进程<code>init</code>，进程<code>init</code>会将该信号视为以快速有序的方式关闭系统的请求。</p>
<p>　　● 信号<code>SIGQUIT</code>是用户在终端输入<span
style="background-color: yellow">退出字符</span> (通常是Control-\)
时前台进程组收到的信号。在默认情况下，该信号会让进程生成核心转储文件，然后终止。当进程陷入无限循环或无响应时，通过这种方式使用该信号很有用。通过输入Control-\生成核心转储文件，并使用gdb加载核心转储文件，然后通过命令<code>backtrace</code>来获取栈追踪，就可以获取程序代码的哪一部分正在执行。</p>
<p>　　● 信号<code>SIGSEGV</code>是程序引用无效地址时生成的信号
(后缀<code>EGV</code>源于术语segmentation
violation)。程序引用的地址无效可能是因为引用的页不存在
(例如，该页位于堆与栈之间某个未映射的区域)、进程试图更新只读内存的数据
(例如，程序文本段或映射为只读的内存区域)
或进程试图在用户模式下访问内核内存。在C中，这些事件通常是由于解引用包含错误地址的指针
(例如，未初始化的指针) 或在函数调用中传递无效参数。</p>
<p>　　● 信号<code>SIGSTKFLT</code>在Linux中未使用 (手册中记录为
"协处理器的栈故障")。</p>
<p>　　●
信号<code>SIGSTOP</code>会停止进程，并且无法被阻塞、忽略或捕获。</p>
<p>　　●
信号<code>SIGSYS</code>是进程调用无效系统调用时生成的信号。这表示进程执行的指令会被解释为系统调用陷阱，但关联的系统调用号无效。</p>
<p>　　●
信号<code>SIGTERM</code>是用于终止进程的标准信号，默认由命令<code>kill</code>和<code>killall</code>发送。用户可以通过命令<code>kill -9</code>或<code>kill -KILL</code>显式发送信号<code>SIGKILL</code>来终止进程。但是，这种行为通常是<span
style="background-color: yellow">错误</span>的，因为精心设计的应用程序会包含<code>SIGTERM</code>处理函数，该处理函数会让应用程序正常退出，清理临时文件并提前释放其他资源。通过信号<code>SIGKILL</code>终止进程会绕过<code>SIGTERM</code>处理函数。因此，终止进程的首选信号是<code>SIGTERM</code>。</p>
<p>　　● 信号<code>SIGTRAP</code>用于实现调试器断点和系统调用追踪。</p>
<p>　　● 信号<code>SIGTSTP</code>是作业控制停止信号
(后缀<code>TSTP</code>源于术语terminal
stop)，当用户在终端输入挂起字符时，前台进程组会收到该信号。</p>
<p>　　●
信号<code>SIGTTIN</code>是作业控制shell下运行的后台进程组中的进程试图对终端调用<code>read()</code>时终端驱动程序发送给该后台进程组的信号。该信号默认会停止进程。</p>
<p>　　●
信号<code>SIGTTOU</code>与<code>SIGTTIN</code>类似，但用于后台作业的终端输出。对于在作业控制shell下运行的后台进程组，若终端启用了选项<code>TOSTOP</code>
(终端输出停止)，则该后台进程组的进程试图对终端调用<code>write()</code>时终端驱动程序会发送该信号给该后台进程组。该信号默认会停止进程。</p>
<p>　　● 信号<code>SIGUNUSED</code>未使用。对于Linux
2.4及以上版本，该信号在很多架构上等同于<code>SIGSYS</code>。换句话说，该信号不再未使用，尽管保留该信号是为了向后兼容性。</p>
<p>　　● 信号<code>SIGURG</code>表示套接字中存在紧急数据。</p>
<p>　　●
信号<code>SIGUSR1</code>和<code>SIGUSR2</code>可用于程序员定义的用途。内核永远不会为进程生成这2个信号。进程可以通过这2个信号来通知彼此事件或相互同步。对于早期UNIX实现，这2个信号是仅有的可以在应用程序中随意使用的信号
(实际上，进程发送任意信号给其他进程，但这可能会与内核发送给该进程相同的信号混淆)。现代UNIX实现提供了大量可用于程序员定义的用途的实时信号。</p>
<p>　　●
信号<code>SIGVTALRM</code>是调用<code>setitimer()</code>设置的<span
style="background-color: yellow">虚拟定时器</span>
(基于进程使用的用户模式CPU时间) 过期时内核生成的信号。</p>
<p>　　●
信号<code>SIGWINCH</code>是窗口环境下的终端窗口大小改变时发送给前台进程组的信号。通过注册处理函数，<code>vi</code>和<code>less</code>等程序可以知道在窗口大小改变后刷新输出。</p>
<p>　　●
信号<code>SIGXCPU</code>是进程超过其CPU时间资源限制时收到的信号。</p>
<p>　　●
信号<code>SIGXFSZ</code>是进程试图将文件大小增加到大于其文件大小资源限制的值时收到的信号。</p>
<p>　　下表是对各种Linux信号的总结 (信号编号行中的S表示Sun
SPARC和SPARC64，A表示HP/Compaq/Digital Alpha，M表示MIPS，P表示HP
PA-RISC。默认处理方式行中的core表示进程会生成核心转储文件并终止，term表示终止进程，ignore表示忽略信号，stop表示停止进程，cont表示恢复停止的进程)：</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 34%" />
<col style="width: 24%" />
<col style="width: 6%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr>
<th>信号名</th>
<th>信号编号</th>
<th>描述</th>
<th>SUSv3</th>
<th>默认处理方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIGABRT</code></td>
<td>6</td>
<td>中止进程</td>
<td>✓</td>
<td>core</td>
</tr>
<tr>
<td><code>SIGALRM</code></td>
<td>14</td>
<td>实时定时器过期</td>
<td>✓</td>
<td>term</td>
</tr>
<tr>
<td><code>SIGBUS</code></td>
<td>7 (SAMP = 10)</td>
<td>内存访问错误</td>
<td>✓</td>
<td>core</td>
</tr>
<tr>
<td><code>SIGCHLD</code></td>
<td>17 (SA = 20，MP = 18)</td>
<td>子进程终止或停止</td>
<td>✓</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGCONT</code></td>
<td>18 (SA = 19，MP = 25，P = 26)</td>
<td>恢复停止的进程</td>
<td>✓</td>
<td>cont</td>
</tr>
<tr>
<td><code>SIGEMT</code></td>
<td>未定义 (SAMP = 7)</td>
<td>硬件故障</td>
<td></td>
<td>term</td>
</tr>
<tr>
<td><code>SIGFPE</code></td>
<td>8</td>
<td>算术异常</td>
<td>✓</td>
<td>core</td>
</tr>
<tr>
<td><code>SIGHUP</code></td>
<td>1</td>
<td>终端断开链接</td>
<td>✓</td>
<td>term</td>
</tr>
<tr>
<td><code>SIGILL</code></td>
<td>4</td>
<td>格式错误的指令</td>
<td>✓</td>
<td>core</td>
</tr>
<tr>
<td><code>SIGINT</code></td>
<td>2</td>
<td>终端中断</td>
<td>✓</td>
<td>term</td>
</tr>
<tr>
<td><code>SIGIO</code>/<code>SIGPOLL</code></td>
<td>29 (SA = 23，MP = 22)</td>
<td>I/O可用</td>
<td>✓</td>
<td>term</td>
</tr>
<tr>
<td><code>SIGKILL</code></td>
<td>9</td>
<td>终止进程</td>
<td>✓</td>
<td>term</td>
</tr>
<tr>
<td><code>SIGPIPE</code></td>
<td>13</td>
<td>不完整的管道</td>
<td>✓</td>
<td>term</td>
</tr>
<tr>
<td><code>SIGPROF</code></td>
<td>27 (M = 29，P = 21)</td>
<td>剖析定时器过期</td>
<td>✓</td>
<td>term</td>
</tr>
<tr>
<td><code>SIGPWR</code></td>
<td>30 (SA = 29，MP = 19)</td>
<td>电源即将耗尽</td>
<td></td>
<td>term</td>
</tr>
<tr>
<td><code>SIGQUIT</code></td>
<td>3</td>
<td>终端退出</td>
<td>✓</td>
<td>core</td>
</tr>
<tr>
<td><code>SIGSEGV</code></td>
<td>11</td>
<td>无效内存引用</td>
<td>✓</td>
<td>core</td>
</tr>
<tr>
<td><code>SIGSTKFLT</code></td>
<td>16 (SAM = 未定义，P = 36)</td>
<td>协处理器的栈故障</td>
<td></td>
<td>term</td>
</tr>
<tr>
<td><code>SIGSTOP</code></td>
<td>19 (SA = 17，M = 23，P = 24)</td>
<td>停止进程</td>
<td>✓</td>
<td>stop</td>
</tr>
<tr>
<td><code>SIGSYS</code></td>
<td>31 (SAMP = 12)</td>
<td>无效系统调用</td>
<td>✓</td>
<td>core</td>
</tr>
<tr>
<td><code>SIGTERM</code></td>
<td>15</td>
<td>终止进程</td>
<td>✓</td>
<td>term</td>
</tr>
<tr>
<td><code>SIGTRAP</code></td>
<td>5</td>
<td>追踪/断点陷阱</td>
<td>✓</td>
<td>core</td>
</tr>
<tr>
<td><code>SIGTSTP</code></td>
<td>20 (SA = 18，M = 24，P = 25)</td>
<td>终端停止</td>
<td>✓</td>
<td>stop</td>
</tr>
<tr>
<td><code>SIGTTIN</code></td>
<td>21 (M = 26，P = 27)</td>
<td>后台进程组读终端</td>
<td>✓</td>
<td>stop</td>
</tr>
<tr>
<td><code>SIGTTOU</code></td>
<td>22 (M = 27，P = 28)</td>
<td>后台进程组写终端</td>
<td>✓</td>
<td>stop</td>
</tr>
<tr>
<td><code>SIGURG</code></td>
<td>23 (SA = 16，M = 21，P = 29)</td>
<td>套接字中存在紧急数据</td>
<td>✓</td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGUSR1</code></td>
<td>10 (SA = 30，MP = 16)</td>
<td>用户定义的信号1</td>
<td>✓</td>
<td>term</td>
</tr>
<tr>
<td><code>SIGUSR2</code></td>
<td>12 (SA = 31，MP = 17)</td>
<td>用户定义的信号2</td>
<td>✓</td>
<td>term</td>
</tr>
<tr>
<td><code>SIGVTALRM</code></td>
<td>26 (M = 28，P = 20)</td>
<td>虚拟定时器过期</td>
<td>✓</td>
<td>term</td>
</tr>
<tr>
<td><code>SIGWINCH</code></td>
<td>28 (M = 20，P = 23)</td>
<td>终端窗口大小改变</td>
<td></td>
<td>ignore</td>
</tr>
<tr>
<td><code>SIGXCPU</code></td>
<td>24 (M = 30，P = 33)</td>
<td>超过CPU时间限制</td>
<td>✓</td>
<td>core</td>
</tr>
<tr>
<td><code>SIGXFSZ</code></td>
<td>25 (M = 31，P = 34)</td>
<td>超过文件大小限制</td>
<td>✓</td>
<td>core</td>
</tr>
</tbody>
</table>
<p>　　● 对于Linux
2.2，信号<code>SIGBUS</code>、<code>SIGSYS</code>、<code>SIGXCPU</code>和<code>SIGXFSZ</code>的默认处理方式是终止进程
(不生成核心转储文件)。Linux从2.4开始遵循SUSv3，这些信号会导致进程生成核心转储文件并终止。对于有些UNIX实现，信号<code>SIGXCPU</code>和<code>SIGXFSZ</code>的默认处理方式是终止进程
(不生成核心转储文件)。</p>
<p>　　● 对于有些UNIX实现，信号<code>SIGPWR</code>默认会被忽略。</p>
<p>　　● 对于有些UNIX实现
(尤其是BSD衍生实现)，信号<code>SIGIO</code>默认会被忽略。</p>
<p>　　●
尽管没有任何标准说明信号<code>SIGEMT</code>，但大多数UNIX实现都提供了该信号。对于部分UNIX实现，该信号会导致进程生成核心转储文件并终止。</p>
<p>　　●
对于SUSv1，信号<code>SIGURG</code>的默认处理方式是终止进程，并且有些较旧的UNIX实现也是如此。SUSv2将该信号的默认处理方式修改为忽略信号。</p>
<h3 id="signal">20.2 <code>signal()</code></h3>
<p>　　对于Linux，<code>signal()</code>在glibc中被实现为基于系统调用<code>sigaction()</code>的库函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> sig, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>); <span class="comment">/* 成功时返回目标信号的旧处理方式，出错时返回SIG_ERR */</span></span><br></pre></td></tr></table></figure>
<p>　　参数<code>sig</code>是目标信号。参数<code>handler</code>是<code>SIG_DFL</code>、<code>SIG_IGN</code>或信号处理函数的地址。<code>SIG_DFL</code>表示将信号的处理方式恢复到默认处理方式，<code>SIG_IGN</code>表示将信号的处理方式修改为忽略信号。</p>
<p>　　<code>signal()</code>的函数原型等同于如下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> sig, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>
<p>　　若定义了特性测试宏<code>_GNU_SOURCE</code>，则非标准数据类型<code>sighandler_t</code>会出现在头文件<code>signal.h</code>中。</p>
<p>　　若<code>signal()</code>成功，则会返回目标信号的旧处理方式；否则，返回<code>SIG_ERR</code>
(即-1)。因此，可以临时修改信号的处理方式，然后恢复：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*oldHandler)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">oldHandler = signal(SIGINT, newHandler);</span><br><span class="line"><span class="keyword">if</span> (oldHandler == SIG_ERR)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal(SIGINT, oldHandler) == SIG_ERR)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<strong>信号处理函数</strong>
(也称为<strong>信号捕获函数</strong>)
是在进程收到特定信号时调用的函数。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_20/signal_delivery_and_handler_execution.svg" class="">
<p>　　信号处理函数的调用可能随时中断主程序流。内核会代表进程调用处理函数，并且当处理函数返回时，程序会在处理函数中断的位置恢复执行。</p>
<p>　　尽管信号处理函数几乎可以做任何事情，但一般而言，它们应该设计得尽可能简单。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* intquit.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数 (printf()和exit())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Caught SIGINT (%d)\n&quot;</span>, count);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* 返回到中断点 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught SIGQUIT - that&#x27;s all folks!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 为信号SIGINT和SIGQUIT注册相同的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sigHandler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGQUIT, sigHandler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) <span class="comment">/* 无限循环 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        pause(); <span class="comment">/* 阻塞，直到捕获信号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个程序会为信号<code>SIGINT</code>和<code>SIGQUIT</code>注册相同的处理函数。但是，在实际应用程序中，应避免在处理函数中调用stdio函数，因为它们不是异步信号安全的。</p>
<p>　　<code>signal()</code>无法在不修改当前信号的处理方式的前提下检索当前信号的处理方式，但<code>sigaction()</code>可以做到这一点。</p>
<h3 id="kill和pause">20.3 <code>kill()</code>和<code>pause()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　进程可以通过系统调用<code>kill()</code>来发送信号给其他进程
(等同于命令<code>kill</code>)。选择kill作为名称是因为早期UNIX实现上大多数可用的信号的默认处理方式都是终止进程。</p>
<p>　　参数<code>pid</code>用于标识目标进程。参数<code>sig</code>是发送给目标进程的信号。</p>
<p>　　●
若<code>pid</code>大于0，则信号会发送给进程ID为<code>pid</code>的进程。</p>
<p>　　●
若<code>pid</code>等于0，则信号会发送给调用进程所属的进程组的所有进程，包括调用进程。SUSv3要求信号的目标进程是整个进程组时应该排除
"未指定的系统进程集"，并且也对剩余情况施加了同样的限制。</p>
<p>　　●
若<code>pid</code>等于-1，则信号会发送给调用进程有权发送信号的所有进程，除了进程<code>init</code>
(进程ID为1)
和调用进程自己。因此，这种发送信号的方式也称为<strong>广播信号</strong>。若特权进程以这种方式调用<code>kill()</code>，则会发送信号给除特权进程自己和<code>init</code>之外的所有进程。SUSv3不要求在这种情况下排除调用进程，但Linux在这方面遵从BSD语义。</p>
<p>　　●
若<code>pid</code>小于-1，则信号会发送给进程组ID为<code>pid</code>的绝对值的进程组的所有进程。</p>
<p>　　若没有符号条件的进程，则<code>kill</code>会失败，并将<code>errno</code>设置为<code>ESRCH</code>。</p>
<p>　　进程需要合适的权限才能发送信号给其他进程，权限规则如下：</p>
<p>　　● 特权进程 (能力<code>CAP_KILL</code>)
可以发送信号给任意进程。</p>
<p>　　●
进程<code>init</code>是特例，唯一可以发送给进程<code>init</code>的信号是那些进程<code>init</code>已显式注册处理函数的信号。这是为了防止系统管理员意外地终止该进程。</p>
<p>　　● 对于非特权进程，需要其<span
style="background-color: yellow">实际用户ID或有效用户ID匹配接收进程的实际用户ID或保存的set-user-ID</span>。此规则允许用户发送信号给自己启动的set-user-ID程序。匹配时排除接收进程的有效用户ID是为了防止用户A发送信号给用户B的正在运行用户A的set-user-ID程序的进程。SUSv3的要求也是如此，但Linux
2.0及以下版本的行为略有不同。</p>
<p>　　●
信号<code>SIGCONT</code>是特例。非特权进程可以发送该信号给同一会话中的其他进程。此规则允许作业控制shell恢复停止的任务
(进程组)，即使作业的进程已经修改了其用户ID。</p>
<p>　　若调用进程没有发送信号给<code>pid</code>指定的进程的权限，则<code>kill()</code>会失败，并将<code>error</code>设置为<code>EPERM</code>。若<code>pid</code>指定的是多个进程
(即负值)，则只要进程能够发送信号给其中的1个进程，<code>kill()</code>就会成功。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 总是会返回-1，并将errno设置为EINTR */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pause()</code>会挂起调用进程，直到被信号处理函数中断或进程被信号终止。对于前者，该函数会返回-1，并将<code>errno</code>设置为<code>EINTR</code>。</p>
<h3 id="判断进程是否存在">20.4 判断进程是否存在</h3>
<p>　　系统调用<code>kill()</code>还可以用于其他目的。若将参数<code>sig</code>指定为0，则不会发送信号。相反，<code>kill()</code>只会执行错误检查，以判断是否可以向目标进程发送信号。因此，可以通过这种方式判断进程是否存在，若<code>kill()</code>将<code>error</code>设置为<code>ESRCH</code>，则目标进程不存在；否则，目标进程存在。</p>
<p>　　特定进程ID的存在并不保证特定的程序正在运行。因为随着进程的创建和终止，内核会回收进程ID，这表示进程ID一段时间后可能引用不同的进程。此外，即使进程ID存在，对应的进程还可能是僵尸进程
(进程已终止，但父进程还没有通过系统调用<code>wait()</code>来获取其终止状态)。</p>
<p>　　还可以通过系统调用<code>wait()</code>、信号量和文件锁、IPC通道以及<code>/proc/PID</code>接口来判断特定进程是否正在运行：</p>
<p>　　● 系统调用<code>wait()</code>可以用于判断子进程是否存在。</p>
<p>　　●
若目标进程持有信号量或文件锁，则只有在该进程终止后才能获取信号量或文件锁。</p>
<p>　　●
将目标进程设置为持有IPC通道的写描述符，若持有读描述符的进程读到EOF，则表示目标进程已终止。</p>
<p>　　●
目录<code>/proc/PID</code>只有在对应的进程存在时才会存在，所以可以通过合适的调用
(例如，<code>stat()</code>) 来判断进程是否存在。</p>
<p>　　除了最后1个方法之外，其他方法都不受到进程ID回收的影响。</p>
<h3 id="raise和killpg">20.5
<code>raise()</code>和<code>killpg()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>; <span class="comment">/* 成功时返回0，出错时返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">killpg</span><span class="params">(<span class="type">pid_t</span> pgrp, <span class="type">int</span> sig)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>raise()</code>会发送参数<code>sig</code>指定的信号给调用进程。该函数只会在<code>sig</code>无效时才会出错
(<code>EINVAL</code>)，并返回非0值。</p>
<p>　　当进程发送信号给自己时
(通过<code>kill()</code>或<code>raise()</code>)，信号会立即传递
(在从<code>raise</code>返回之前)。</p>
<p>　　对于单线程程序，<code>raise(sig)</code>等同于<code>kill(gitpid(), sig)</code>。对于支持多线程的系统，<code>raise(sig)</code>等同于<code>pthread_kill(pthread_self(), sig)</code>。</p>
<p>　　<code>raise()</code>源于C89。C标准不涵盖进程ID等操作系统细节，但C标准说明了<code>raise()</code>，因为该函数不需要指定进程ID。</p>
<p>　　函数<code>killpg()</code>会发送参数<code>sig</code>指定的信号给参数<code>pgrp</code>指定的进程组的所有进程。<code>killpg(pgrp, sig)</code>等同于<code>kill(-pgrp, sig)</code>。</p>
<p>　　若<code>pgrp</code>为0，则信号会发送给调用进程所属的进程组的所有进程。SUSv3没有说明这一点，但大多数UNIX实现在这一点上与Linux相同。</p>
<h3 id="打印信号描述">20.6 打印信号描述</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> sys_siglist[];</span><br></pre></td></tr></table></figure>
<p>　　每个信号都有1个关联的可打印描述，这些描述存储在数组<code>sys_siglist</code>
(例如，<code>sys_siglist[SIGPIPE]</code>是信号<code>SIGPIPE</code>的描述)。但是，函数<code>strsignal()</code>是打印信号描述的首选。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strsignal</span><span class="params">(<span class="type">int</span> sig)</span>; <span class="comment">/* 返回信号描述字符串 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>strsignal()</code>会对参数<code>sig</code>边界检查，然后返回信号描述字符串。若<code>sig</code>无效，则返回错误字符串
(有些UNIX实现在这种情况下会返回<code>NULL</code>)。</p>
<p>　　除了边界检查之外，<code>strsignal()</code>返回的字符串会受到区域设置的影响。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">psignal</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="type">char</span> *msg)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>psignal()</code>会在标准错误中打印参数<code>msg</code>指定的字符串加上冒号和参数<code>sig</code>对应的信号描述字符串。与<code>strsignal()</code>相同，该函数也会受到区域设置的影响。</p>
<p>　　尽管<code>sys_siglist</code>、<code>strsignal()</code>和<code>psignal()</code>没有被SUSv3标准化，但很多UNIX实现都提供了这个数组和这2个函数
(SUSv4添加了<code>strsignal()</code>和<code>psignal()</code>的规范)。</p>
<h3 id="信号集">20.7 信号集</h3>
<p>　　多个信号可以用称为<strong>信号集</strong>的数据结构表示，对应的数据类型是<code>sigset_t</code>。对于Linux和大多数UNIX实现，<code>sigset_t</code>被实现为位掩码，但SUSv3没有说明这一点，只要求该数据类型是可赋值的。因此，该数据类型只能被实现为标量类型
(例如，整数类型) 或结构体。</p>
<p>　　SUSv3详细说明了以下控制信号集的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> sig)</span>; <span class="comment">/* sig属于set时返回1，否则返回0 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sigemptyset()</code>会将参数<code>set</code>指向的信号集初始化为空信号集。函数<code>sigfillset()</code>会将参数<code>set</code>指向的信号集初始化为包含所有信号的信号集。</p>
<p>　　C不会初始化自动变量，并且静态变量的自动初始化为0也不能保证新信号集是空集合
(因为信号集可能被实现为结构体。同样，使用<code>memset()</code>将信号集设置为0也是不正确的)，所以使用信号集前<span
style="background-color: yellow">必须</span>先通过<code>sigemptyset()</code>或<code>sigfillset()</code>初始化它。</p>
<p>　　在初始化信号集后，可以通过函数<code>sigaddset()</code>和<code>sigdelset()</code>来添加和删除信号
(参数<code>sig</code>)。</p>
<p>　　若参数<code>sig</code>指定的信号属于参数<code>set</code>指向的信号集，则<code>sigismember()</code>返回1；否则，返回0。</p>
<p>　　glibc实现了3个非标准函数，这些函数执行与以上函数互补的任务：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigandset</span><span class="params">(<span class="type">sigset_t</span> *dset, <span class="type">sigset_t</span> *left, <span class="type">sigset_t</span> *right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigorset</span><span class="params">(<span class="type">sigset_t</span> *dest, <span class="type">sigset_t</span> *left, <span class="type">sigset_t</span> *right)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigisemptyset</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">/* set为空时返回1，否则返回0 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sigandset()</code>会将参数<code>left</code>指向的信号集和参数<code>right</code>指向的信号集的交集放置在参数<code>dset</code>指向的信号集中。</p>
<p>　　函数<code>sigandset()</code>会将参数<code>left</code>指向的信号集和参数<code>right</code>指向的信号集的并集放置在参数<code>dest</code>指向的信号集中。</p>
<p>　　函数<code>sigisemptyset()</code>会判断参数<code>set</code>指向的信号集是否为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* signal_functions.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;signal_functions.h&quot;</span> <span class="comment">/* 函数声明在该头文件中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下函数调用了非异步信号安全函数fprintf()，所以这些函数也不是异步信号安全的 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印信号集中的所有信号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param of</span></span><br><span class="line"><span class="comment"> * @param prefix</span></span><br><span class="line"><span class="comment"> * @param sigset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printSigset</span><span class="params">(FILE *of, <span class="type">const</span> <span class="type">char</span> *prefix, <span class="type">const</span> <span class="type">sigset_t</span> *sigset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sig, cnt;</span><br><span class="line"></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (sig = <span class="number">1</span>; sig &lt; NSIG; sig++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sigismember(sigset, sig))</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">fprintf</span>(of, <span class="string">&quot;%s%d (%s)\n&quot;</span>, prefix, sig, strsignal(sig));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(of, <span class="string">&quot;%s&lt;empty signal set&gt;\n&quot;</span>, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印进程的信号掩码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param of</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printSigMask</span><span class="params">(FILE *of, <span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> currMask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(of, <span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, <span class="literal">NULL</span>, &amp;currMask) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printSigset(of, <span class="string">&quot;\t\t&quot;</span>, &amp;currMask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印进程的当前待处理信号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param of</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printPendingSigs</span><span class="params">(FILE *of, <span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> pendingSigs;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(of, <span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigpending(&amp;pendingSigs) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printSigset(of, <span class="string">&quot;\t\t&quot;</span>, &amp;pendingSigs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了上述函数的用法。函数<code>printSigset()</code>会打印指定信号集中的所有信号，该函数使用了常量<code>NSIG</code>作为循环的上限，该常量定义在头文件<code>signal.h</code>中，其值比最大信号编号大1。</p>
<p>　　函数<code>printSigMask()</code>和<code>printPendingSigs()</code>会调用<code>printSigset()</code>来分别打印进程的信号掩码和当前待处理信号集。</p>
<p>　　SUSv3没有说明常量<code>NSIG</code>，但大多数UNIX实现都提供了该常量。此外，可能需要使用特定于实现的编译器选项来让该常量可见。例如，对于Linux，需要定义特性测试宏<code>_BSD_SOURCE</code>、<code>_SVID_SOURCE</code>或<code>_GNU_SOURCE</code>。</p>
<h3 id="信号掩码">20.8 信号掩码</h3>
<p>　　内核会为每个进程都维护1个信号掩码
(信号掩码实际上是线程级属性，线程可以通过函数<code>pthread_sigmask()</code>来查看和修改其信号掩码)。</p>
<p>　　信号可以通过以下方式添加到信号掩码：</p>
<p>　　● 当调用信号处理函数时，对应的信号会自动添加到信号掩码。</p>
<p>　　●
当通过<code>sigaction()</code>注册信号处理函数时，可以指定调用该信号处理函数时额外阻塞的信号。</p>
<p>　　●
系统调用<code>sigprocmask()</code>可用于显式地在信号掩码中添加和删除信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sigprocmask()</code>可用于修改或/和检索进程的信号掩码。参数<code>how</code>决定如何修改信号掩码，只能指定为<code>SIG_BLOCK</code>、<code>SIG_UNBLOCK</code>或<code>SIG_SETMASK</code>。</p>
<p>　　●
<code>SIG_BLOCK</code>表示将参数<code>set</code>指向的信号集添加到信号掩码，即信号掩码会设置为当前信号掩码与<code>set</code>指向的信号集的并集。</p>
<p>　　●
<code>SIG_UNBLOCK</code>表示从信号掩码中删除参数<code>set</code>指向的信号集。<code>set</code>指向的信号集中包含未阻塞的信号不会导致错误。</p>
<p>　　●
<code>SIG_SETMASK</code>表示将参数<code>set</code>指向的信号集赋值给信号掩码。</p>
<p>　　若参数<code>oldset</code>不是<code>NULL</code>，则它指向的信号集会用于存储信号掩码的旧值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sigset_t</span> blockSet, prevMask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化信号集，并将信号SIGINT添加到该信号集 */</span></span><br><span class="line">sigemptyset(&amp;blockSet);</span><br><span class="line">sigaddset(&amp;blockSet, SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阻塞信号SIGINT */</span></span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;blockSet, &amp;prevMask) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigprocmask1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 解除阻塞信号SIGINT */</span></span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;prevMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigprocmask2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会临时阻塞信号<code>SIGINT</code>。</p>
<p>　　SUSv3规定，若通过<code>sigprocmask()</code>解除阻塞待处理信号，则待处理信号会立即传递给进程。</p>
<p>　　通过<code>sigprocmask()</code>阻塞信号<code>SIGKILL</code>和<code>SIGSTOP</code>不会生效，并且不会导致错误。因此，可以通过以下方式来阻塞除这2个信号之外的所有信号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigfillset(&amp;blockSet);</span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;blockSet, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="待处理信号">20.9 待处理信号</h3>
<p>　　若接收信号的进程阻塞了信号，则信号会被添加到接收进程的待处理信号集。当信号稍后被解除阻塞时，信号会传递给进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sigpending()</code>会将调用进程的待处理信号集存储在参数<code>set</code>指向的信号集中。</p>
<p>　　若被阻塞的信号的处理方式是被忽略，则该信号生成后<span
style="background-color: yellow">不会</span>添加到待处理信号集，所以也不会传递。</p>
<p>　　待处理信号集只是1个掩码。即使被阻塞的信号多次生成，该信号也只会在待处理信号集中记录1次，并且后续只会传递1次
(这仅适用于标准信号，实时信号依旧会排队)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sig_sender.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numSigs, sig, j;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pid num-sigs sig-num [sig-num-2]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = getLong(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;PID&quot;</span>);</span><br><span class="line">    numSigs = getInt(argv[<span class="number">2</span>], GN_GT_0, <span class="string">&quot;num-sigs&quot;</span>);</span><br><span class="line">    sig = getInt(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="string">&quot;sig-num&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送信号到目标进程 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: sending signal %d to process %ld %d times\n&quot;</span>,</span><br><span class="line">           argv[<span class="number">0</span>], sig, (<span class="type">long</span>)pid, numSigs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numSigs; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (kill(pid, sig) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若指定了第4个命令行参数，则发送对应的信号 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (kill(pid, getInt(argv[<span class="number">4</span>], <span class="number">0</span>, <span class="string">&quot;sig-num-2&quot;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: exiting\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个程序有4个命令行参数。第1个命令行参数表示目标进程的进程ID。第2个命令行参数表示发送给目标进程的信号数。第3个命令行参数表示发送给目标进程的信号。若指定了第4个命令行参数，则在发送完第3个命令行参数指定的信号后会发送1次该命令行参数指定的信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sig_receiver.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;signal_functions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sigCnt[NSIG];                    <span class="comment">/* 记录接收到的信号数 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> gotSigint = <span class="number">0</span>; <span class="comment">/* 收到SIGINT时设置为非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT)</span><br><span class="line">    &#123;</span><br><span class="line">        gotSigint = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sigCnt[sig]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, numSecs;</span><br><span class="line">    <span class="type">sigset_t</span> pendingMask, blockingMask, emptyMask;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: PID is %ld\n&quot;</span>, argv[<span class="number">0</span>], (<span class="type">long</span>)getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; NSIG; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 所有信号都注册相同的处理函数 */</span></span><br><span class="line">        (<span class="type">void</span>)signal(n, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若指定了睡眠时间，则临时阻塞所有信号并睡眠，然后打印待处理信号的掩码和解除阻塞所有信号 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        numSecs = getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        sigfillset(&amp;blockingMask);</span><br><span class="line">        <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;blockingMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: sleeping for %d seconds\n&quot;</span>, argv[<span class="number">0</span>], numSecs);</span><br><span class="line">        sleep(numSecs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sigpending(&amp;pendingMask) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigpending&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: pending signals are: \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        printSigset(<span class="built_in">stdout</span>, <span class="string">&quot;\t\t&quot;</span>, &amp;pendingMask);</span><br><span class="line"></span><br><span class="line">        sigemptyset(&amp;emptyMask); <span class="comment">/* 解除阻塞所有信号 */</span></span><br><span class="line">        <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;emptyMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!gotSigint) <span class="comment">/* 循环，直到收到信号SIGINT */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; NSIG; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 打印收到的信号数 */</span></span><br><span class="line">        <span class="keyword">if</span> (sigCnt[n] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: signal %d caught %d time%s\n&quot;</span>, argv[<span class="number">0</span>], n,</span><br><span class="line">                   sigCnt[n], (sigCnt[n] == <span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;s&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个程序会捕获<code>sig_sender.c</code>发送的信号，并打印相关数据。这个程序会执行如下步骤：</p>
<p>　　● 在第29~33行，程序会对所有信号都注册相同的处理函数
(信号<code>SIGKILL</code>和<code>SIGSTOP</code>无法捕获，但这里忽略了注册信号处理函数时可能出现的错误)。对于大多数信号，信号处理函数只会通过数组对其计数。若捕获的信号是<code>SIGINT</code>，则会设置让程序退出主循环的标志<code>gotSigint</code>。</p>
<p>　　●
在第35~62行，若提供了命令行参数，则程序会在命令行参数指定的秒数内阻塞所有信号，然后解除阻塞这些信号，并打印待处理信号集。</p>
<p>　　●
在第64~67行，程序会一直进行<code>while</code>循环，直到标志<code>gotSigint</code>为1。</p>
<p>　　●
在第69~77行，当<code>while</code>循环完成后，程序会打印收到的所有信号的数量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./sig_receiver 15 &amp;</span></span><br><span class="line">[1] 5368</span><br><span class="line">./sig_receiver: PID is 5368</span><br><span class="line">./sig_receiver: sleeping for 15 seconds</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./sig_sender 5368 1000000 10 2</span></span><br><span class="line">./sig_sender: sending signal 10 to process 5368 1000000 times</span><br><span class="line">./sig_sender: exiting</span><br><span class="line">./sig_receiver: pending signals are:</span><br><span class="line">                2 (Interrupt)</span><br><span class="line">                10 (User defined signal 1)</span><br><span class="line">./sig_receiver: signal 10 caught 1 time</span><br><span class="line">[1]  + done       ./sig_receiver 15</span><br></pre></td></tr></table></figure>
<p>　　这个示例中会先运行信号接收程序，并将命令行参数指定为15
(睡眠15秒)。然后，运行信号发送程序，发送1000000次信号10，再发送1次信号2。从结果可以看出，信号接收程序仅收到了1次信号10。</p>
<h3 id="sigaction">20.10 <code>sigaction()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">        <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    &#125; __sigaction_handler; <span class="comment">/* 处理函数的地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_handler __sigaction_handler.sa_handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_sigaction __sigaction_handler.sa_sigaction</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;          <span class="comment">/* 调用处理函数期间阻塞的信号 */</span></span><br><span class="line">    <span class="type">int</span> sa_flags;              <span class="comment">/* 控制信号处理函数行为的标志 */</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>); <span class="comment">/* 不供应用程序使用 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sigaction()</code>会为参数<code>sig</code>指定的信号
(除了信号<code>SIGKILL</code>和<code>SIGSTOP</code>)
注册参数<code>act</code>指定的信号处理函数，信号的旧处理方式会存储在参数<code>oldact</code>指向的结构体中。若仅需要获取信号的当前处理方式，则可以将<code>act</code>指定为<code>NULL</code>。若仅需要修改信号的处理方式，则可以将<code>oldact</code>指定为<code>NULL</code>。</p>
<p>　　结构体<code>sigaction</code>使用共用体<code>__sigaction_handler</code>来合并成员<code>sa_handler</code>和<code>sa_sigaction</code>，因为在调用该系统调用时只会指定其中之一
(大多数UNIX实现也是如此)。成员<code>sa_handler</code>与<code>signal()</code>的参数<code>handler</code>相同
(可以是<code>SIG_DFL</code>、<code>SIG_IGN</code>或信号处理函数的地址)。成员<code>sa_mask</code>是信号集，指定调用处理函数期间阻塞的信号。当调用信号处理函数时，属于该信号集但不属于信号掩码的信号会自动添加到信号掩码，这些信号会在信号处理函数返回时自动从信号掩码中删除。成员<code>sa_flags</code>用于控制信号处理函数的行为。成员<code>sa_restorer</code>仅供内部使用，以保证信号处理函数顺利完成
(调用特殊用途的系统调用<code>sigreturn()</code>，这将恢复进程的上下文，以便进程可以在被信号处理函数中断的位置继续执行)，SUSv3也没有说明该成员。</p>
<p>　　成员<code>sa_flags</code>是用于控制信号处理函数的行为的位掩码，可以包含以下标志中的任意个标志
(SUSv3详细说明了这些标志)：</p>
<p>　　●
<code>SA_NOCLDSTOP</code>表示若<code>sig</code>是<code>SIGCHLD</code>，则子进程停止或恢复时不生成该信号。</p>
<p>　　●
<code>SA_NOCLDWAIT</code>表示若<code>sig</code>是<code>SIGCHLD</code>，则子进程终止时不会转换为僵尸进程
(Linux 2.6及以上版本)。</p>
<p>　　●
<code>SA_NODEFER</code>表示捕获信号时不自动将其添加到信号掩码。该标志还有1个历史别名——<code>SA_NOMASK</code>。但是，因为SUSv3标准化了<code>SA_NODEFER</code>，所以<code>SA_NODEFER</code>是首选。</p>
<p>　　●
<code>SA_ONSTACK</code>表示使用通过<code>sigaltstack()</code>定义的备用信号栈调用信号处理函数。</p>
<p>　　●
<code>SA_RESETHAND</code>表示当捕获信号后，先将处理方式恢复到默认，再调用处理函数
(信号处理函数默认会一直处于已注册状态，直到显式调用<code>sigaction()</code>来注销)。该标志还有1个历史别名——<code>SA_ONESHOT</code>。但是，SUSv3标准化了<code>SA_RESETHAND</code>，所以<code>SA_RESETHAND</code>是首选。</p>
<p>　　●
<code>SA_RESTART</code>表示自动重启被信号处理函数中断的系统调用。</p>
<p>　　●
<code>SA_SIGINFO</code>表示使用额外参数调用信号处理函数，以提供有关信号的更多信息，与成员<code>sa_sigaction</code>一起使用。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第23章 定时器和睡眠</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_23/</url>
    <content><![CDATA[<p>　　定时器允许进程将通知安排在未来的某个时刻。睡眠允许进程 (或线程)
在一段时间内挂起执行。</p>
<p>　　由于系统负载和进程调度，进程在定时器过期或睡眠完成后可能需要等待一小段时间
(通常是几分之一秒) 才能被调度。但是，周期性定时器<span
style="background-color: yellow">不会</span>受到影响。</p>
<p>　　通过结构体<code>timeval</code>设置定时器的实际精度受限于系统时钟。若定时器的值不是系统时钟的整数倍，则定时器的值会向上取整
(保证其值是系统时钟的整数倍)。例如，定时器设置为19100微秒后过期
(即略长于19毫秒)，而jiffy为4毫秒，则定时器的实际过期时间是20毫秒后。但是，Linux从内核2.6.21开始提供可选的高精度定时器
(通过内核配置选项<code>CONFIG_HIGH_RES_TIMERS</code>)。当启用了该功能后，各种定时器和睡眠接口不再受限于jiffy，其精度可以达到硬件支持的精度
(对于现代硬件，精度通常可以达到微秒)。</p>
<h3 id="间隔定时器">23.1 间隔定时器</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getitimer</span><span class="params">(<span class="type">int</span> which, <span class="keyword">struct</span> itimerval *curr_value)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* 周期性定时器的间隔 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* 第1次过期时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>setitimer()</code>会为调用进程设置<strong>间隔定时器</strong>，间隔定时器会在未来的某个时刻过期，并且可以设置为在此之后定期过期。</p>
<p>　　参数<code>which</code>表示创建的间隔定时器的类型，可以指定为<code>ITIMER_REAL</code>、<code>ITIMER_VIRTUAL</code>或<code>ITIMER_PROF</code>，分别对应3种不同类型的间隔定时器：</p>
<p>　　● <code>ITIMER_REAL</code>表示实时间隔定时器
(基于挂钟时间)。当该定时器过期时，会为进程生成信号<code>SIGALRM</code>。</p>
<p>　　●
<code>ITIMER_VIRTUAL</code>表示基于用户CPU时间的间隔定时器。当该定时器过期时，会为进程生成信号<code>SIGVTALRM</code>。</p>
<p>　　● <code>ITIMER_PROF</code>表示基于进程时间
(即用户CPU时间和系统CPU时间之和)
的剖析定时器。当该定时器过期时，会为进程生成信号<code>SIGPROF</code>。</p>
<p>　　这些间隔定过期时生成的信号的默认处理方式都是终止进程。</p>
<span id="more"></span>
<p>　　参数<code>new_value</code>和<code>old_value</code>是指向结构体<code>itimerval</code>的指针。</p>
<p>　　●
<code>new_value</code>指向的结构体<code>itimerval</code>的成员<code>it_value</code>和<code>it_interval</code>分别用于指定间隔定时器的第1次过期时间以及是否为周期性定时器。若<code>new_value.it_interval</code>的所有成员都指定为0，则间隔定时器只会过期1次
(即<code>new_value.it_value</code>指定的时间)。若<code>new_value.it_interval</code>的所有成员都指定为非0值，则每次间隔定时器过期后，间隔定时器都会重置
(以便于在指定间隔后再次过期)。</p>
<p>　　●
若<code>old_value</code>不为<code>NULL</code>，则它指向的结构体<code>itimerval</code>会包含间隔定时器的旧值。若<code>old_value.it_value</code>的所有成员都为0，则表示间隔定时器之前处于关闭状态。若<code>old_value.it_interval</code>的所有成员都为0，则表示间隔定时器之前只会过期1次
(即<code>old_value.it_value</code>指定的时间)。</p>
<p>　　进程只能设置这3种间隔定时器之一。若再次调用<code>setitimer()</code>，则会将现有间隔定时器修改为<code>which</code>对应的间隔定时器。若第2次调用<code>setitimer()</code>时将<code>new_value.it_value</code>指定为0，则会关闭现有间隔定时器。</p>
<p>　　间隔定时器会从初始值 (即<code>it_value</code>)
向下计数到0。当间隔定时器计数到0时，对应的信号会发送给进程。若间隔
(即<code>it_interval</code>) 不为0，则间隔定时器的值
(<code>it_value</code>) 会重新装载为间隔值，并再次向下计数。</p>
<p>　　系统调用<code>getitimer()</code>可用于检索间隔定时器的当前状态，以便于获取距离下一次过期的时间。该系统调用会将参数<code>which</code>指定的间隔定时器的当前状态
(即<code>setitimer()</code>的参数<code>old_value</code>包含的信息)
存储在参数<code>curr_value</code>指向的结构体<code>itimerval</code>中。</p>
<p>　　SUSv4将<code>setitimer()</code>和<code>getitimer()</code>标记为过时，并且建议使用POSIX间隔定时器API。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* real_timer.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> gotAlarm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigalrmHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    gotAlarm = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 检索和打印挂钟时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @param includeTimer 若该参数为TRUE，则还会打印实时间隔定时器的当前值和间隔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">displayTimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, Boolean includeTimer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">itv</span>;</span></span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">curr</span>;</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> callNum = <span class="number">0</span>; <span class="comment">/* 本函数的被调用次数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callNum == <span class="number">0</span>) <span class="comment">/* 初始化已用时计时器 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gettimeofday(&amp;start, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;gettimeofday&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callNum % <span class="number">20</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       Elapsed  Value Interval\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gettimeofday(&amp;curr, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;gettimeofday&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-7s %6.2f&quot;</span>, msg, curr.tv_sec - start.tv_sec + (curr.tv_usec - start.tv_usec) / <span class="number">1000000.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (includeTimer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (getitimer(ITIMER_REAL, &amp;itv) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;getitimer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %6.2f %6.2f&quot;</span>, itv.it_value.tv_sec + itv.it_value.tv_usec / <span class="number">1000000.0</span>,</span><br><span class="line">               itv.it_interval.tv_sec + itv.it_interval.tv_usec / <span class="number">1000000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    callNum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">itv</span>;</span></span><br><span class="line">    <span class="type">clock_t</span> prevClock;</span><br><span class="line">    <span class="type">int</span> maxSigs; <span class="comment">/* 退出前捕获的信号的数量 */</span></span><br><span class="line">    <span class="type">int</span> sigCnt;  <span class="comment">/* 当前捕获的信号的数量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [secs [usecs [int-secs [int-usecs]]]]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = sigalrmHandler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 捕获3个信号或1个信号 (it_interval为0时) 后退出 */</span></span><br><span class="line">    maxSigs = (itv.it_interval.tv_sec == <span class="number">0</span> &amp;&amp; itv.it_interval.tv_usec == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">3</span>;</span><br><span class="line">    displayTimes(<span class="string">&quot;START:&quot;</span>, FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据命令行参数设置间隔定时器 */</span></span><br><span class="line">    itv.it_value.tv_sec = (argc &gt; <span class="number">1</span>) ? getLong(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;secs&quot;</span>) : <span class="number">2</span>;</span><br><span class="line">    itv.it_value.tv_usec = (argc &gt; <span class="number">2</span>) ? getLong(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;usecs&quot;</span>) : <span class="number">0</span>;</span><br><span class="line">    itv.it_interval.tv_sec = (argc &gt; <span class="number">3</span>) ? getLong(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="string">&quot;int-secs&quot;</span>) : <span class="number">0</span>;</span><br><span class="line">    itv.it_interval.tv_usec = (argc &gt; <span class="number">4</span>) ? getLong(argv[<span class="number">4</span>], <span class="number">0</span>, <span class="string">&quot;int-usecs&quot;</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setitimer(ITIMER_REAL, &amp;itv, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevClock = clock();</span><br><span class="line">    sigCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 内部循环至少使用0.5秒的CPU时间 */</span></span><br><span class="line">        <span class="keyword">while</span> (((clock() - prevClock) * <span class="number">10</span> / CLOCKS_PER_SEC) &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (gotAlarm)</span><br><span class="line">            &#123;</span><br><span class="line">                gotAlarm = <span class="number">0</span>;</span><br><span class="line">                displayTimes(<span class="string">&quot;ALARM:&quot;</span>, TRUE);</span><br><span class="line"></span><br><span class="line">                sigCnt++;</span><br><span class="line">                <span class="keyword">if</span> (sigCnt &gt;= maxSigs)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s all folks\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prevClock = clock();</span><br><span class="line">        displayTimes(<span class="string">&quot;Main: &quot;</span>, TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>setitimer()</code>和<code>getitimer()</code>的用法。该程序会执行以下步骤：</p>
<p>　　1) 为信号<code>SIGALRM</code>注册处理函数
(第75~81行)，该处理函数会设置全局标志<code>gotAlarm</code>。</p>
<p>　　2)
通过命令行参数设置实时间隔定时器，若没有提供这些命令行参数，则定时器只会在2秒后过期1次
(第88~96行)。</p>
<p>　　3)
进行循环，直到捕获的信号的数量达到上限。每次循环会适当延时，然后根据全局标志<code>gotAlarm</code>来判断是否设置变量<code>sigCnt</code>并打印相关时间
(第101~122行)。</p>
<h3 id="alarm">23.2 <code>alarm()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>; <span class="comment">/* 总是会成功，存在之前设置的定时器时返回该定时器的剩余秒数，没有之前设置的定时器时返回0 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>alarm()</code>会为调用进程设置只会过期1次的实时定时器，该定时器会在参数<code>seconds</code>指定的秒数后过期，过期时会为调用进程生成信号<code>SIGALRM</code>。</p>
<p>　　若存在之前设置的定时器，则<code>alarm()</code>会返回该定时器的剩余秒数；否则，<code>alarm()</code>会返回0。</p>
<p>　　通过<code>alarm()</code>设置的定时器会覆盖之前设置的定时器，所以可以通过调用<code>alarm(0)</code>来关闭现有定时器。</p>
<p>　　通过<code>setitimer()</code>和<code>alarm()</code>设置的定时器可以在<code>exec()</code>期间保留，并且不会被通过<code>fork()</code>创建的子进程继承。</p>
<p>　　从历史角度，<code>alarm()</code>原本是用于设置定时器的UNIX
API。</p>
<p>　　对于Linux，<code>alarm()</code>和<code>setitimer()</code>会共享进程级的实时定时器，这表示通过其中1个系统调用设置的定时器会覆盖之前由这2个系统调用之一设置的任意定时器。这种情况并不适用于所有UNIX实现，并且SUSv3故意没有说明这2个系统调用之间的相互作用。</p>
<p>　　在之后的某些示例中，会通过调用<code>alarm()</code>和不注册<code>SIGALRM</code>处理函数的组合来保证程序在一段时间后自动终止。</p>
<h3 id="为阻塞操作设置超时时间">23.3 为阻塞操作设置超时时间</h3>
<p>　　实时定时器的用法之一就是为阻塞系统调用的阻塞时间设置上限。例如，可以通过以下步骤来为保证用户在一段时间内没有输入时自动取消对终端的<code>read()</code>：</p>
<p>　　1)
通过<code>sigaction()</code>为信号<code>SIGALRM</code>注册处理函数，并且不指定标志<code>SA_RESTART</code>
(保证阻塞系统调用不会重启)。</p>
<p>　　2)
通过<code>alarm()</code>或<code>setitimer()</code>设置实时定时器，该定时器为阻塞系统调用设置超时时间。</p>
<p>　　3) 调用阻塞系统调用。</p>
<p>　　4)
在阻塞系统调用返回后，再次调用<code>alarm()</code>或<code>setitimer()</code>来关闭实时定时器
(在这种情况下，阻塞系统调用会在预期时间内完成)。</p>
<p>　　5)
检查阻塞系统调用是否将<code>errno</code>设置为<code>EINTR</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* timed_read.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数printf()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> numRead;</span><br><span class="line">    <span class="type">int</span> savedErrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [num-secs [restart-flag]]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为SIGALRM注册处理函数。默认允许系统调用被中断，除非提供了第2个命令行参数 */</span></span><br><span class="line">    sa.sa_flags = (argc &gt; <span class="number">2</span>) ? SA_RESTART : <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm((argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_NONNEG, <span class="string">&quot;num-secs&quot;</span>) : <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    numRead = read(STDIN_FILENO, buf, BUF_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    savedErrno = errno; <span class="comment">/* 防止alarm()修改errno */</span></span><br><span class="line">    alarm(<span class="number">0</span>);           <span class="comment">/* 关闭定时器 */</span></span><br><span class="line">    errno = savedErrno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断read()的结果 */</span></span><br><span class="line">    <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Read timed out\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            errMsg(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Successful read (%ld bytes): %.*s&quot;</span>, (<span class="type">long</span>)numRead, (<span class="type">int</span>)numRead, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过<code>alarm()</code>设置实时定时器来实现上述步骤。这里存在1个理论上的竞争条件：若通过<code>alarm()</code>设置的定时器在调用<code>read()</code>之前过期，则<code>read()</code>不会被信号处理函数中断。但是，实际中设置的超时时间相对较长
(至少几秒)，所以该竞争条件基本上不会出现。</p>
<h3 id="睡眠">23.4 睡眠</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>; <span class="comment">/* 正常结束时返回0，提前结束时返回剩余秒数 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sleep()</code>会将调用进程的执行挂起参数<code>seconds</code>指定的秒数，或者被信号中断。</p>
<p>　　若睡眠完成，则<code>sleep()</code>返回0。若睡眠被信号中断，则<code>sleep()</code>返回剩余
(未睡眠) 秒数。</p>
<p>　　SUSv3故意没有说明<code>sleep()</code>与<code>alarm()</code>和<code>setitimer()</code>之间的相互作用。对于Linux，<code>sleep()</code>被实现为调用<code>nanosleep()</code>，所以<code>sleep()</code>和这2个系统调用之间没有相互作用。但是，对于部分UNIX实现
(尤其是较旧的UNIX实现)，<code>sleep()</code>被实现为<code>alarm()</code>和<code>SIGALRM</code>处理函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nanosleep</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timespec *request, <span class="keyword">struct</span> timespec *remain)</span>; <span class="comment">/* 完成睡眠时返回0，睡眠被中断或出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>nanosleep()</code>与<code>sleep()</code>类似，但提供了更高的精度。</p>
<p>　　参数<code>request</code>指向的结构体<code>timespec</code>指定睡眠时间，其成员<code>tv_nsec</code>只能指定为0到999999999之间的数。</p>
<p>　　SUSv3明确说明<code>nanosleep()</code>不应该通过信号实现，所以<code>nanosleep()</code>与<code>alarm()</code>和<code>setitimer()</code>之间没有相互作用。</p>
<p>　　尽管不会通过信号实现，<code>nanosleep()</code>还是会被信号中断。在这种情况下，<code>nanosleep()</code>会返回-1，并将<code>errno</code>设置为<code>EINTR</code>。若参数<code>remain</code>不为<code>NULL</code>，则该参数指向的结构体<code>timespec</code>还会包含剩余时间。</p>
<p>　　与通过结构体<code>timeval</code>设置定时器相同，<code>nanosleep()</code>的睡眠时间受限于系统时钟。若指定的睡眠时间不是系统时钟的整数倍，则会向上取整
(保证其值是系统时钟频率的整数倍)。对于支持高精度定时器的系统，睡眠时间的精度可以比系统时钟的精度更高。</p>
<p>　　对于Linux
2.4及以下版本，<code>nanosleep()</code>实现还存在1个偏差：假设进程执行该函数时被信号停止，当进程随后被信号<code>SIGCONT</code>恢复时，<code>nanosleep()</code>会返回-1，并将<code>errno</code>设置为<code>EINTR</code>。但是，当程序随重启该函数时，停止期间所用的时间不会计入睡眠时间，所以进程睡眠的实际时间可能比预期时间更长。这个偏差在Linux
2.6得到了修复，信号<code>SIGCONT</code>恢复进程时会自动恢复该函数，并且停止期间所用的时间会计入睡眠时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_nanosleep.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigintHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">finish</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">request</span>, <span class="title">remain</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s secs nanosecs\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request.tv_sec = getLong(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;secs&quot;</span>);</span><br><span class="line">    request.tv_nsec = getLong(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;nanosecs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = sigintHandler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gettimeofday(&amp;start, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;gettimeofday&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        s = nanosleep(&amp;request, &amp;remain);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">-1</span> &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;nanosleep&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gettimeofday(&amp;finish, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;gettimeofday&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Slept for: %9.6f secs\n&quot;</span>, finish.tv_sec - start.tv_sec +</span><br><span class="line">                                              (finish.tv_usec - start.tv_usec) / <span class="number">1000000.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* nanosleep()完成 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Remaining: %2ld.%09ld\n&quot;</span>, (<span class="type">long</span>)remain.tv_sec, remain.tv_nsec);</span><br><span class="line">        request = remain; <span class="comment">/* 下一次睡眠时间是剩余时间 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sleep complete\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>nanosleep()</code>的用法。该程序会根据命令行参数来设置<code>nanosleep()</code>的睡眠时间，然后循环调用<code>nanosleep()</code>，直到睡眠完成。若<code>nanosleep()</code>被<code>SIGINT</code>处理函数中断，则会用<code>remain</code>再次调用该函数。</p>
<h3 id="posix时钟">23.5 POSIX时钟</h3>
<p>　　POSIX时钟 (最初由POSIX.1b定义)
提供了1个用于访问以纳秒精度测量时间的时钟的API。纳秒时间通过结构体<code>timespec</code>表示
(见15.2.2)。对于glibc
2.17之前的版本，使用该API的程序在编译时必须带有选项<code>-lrt</code>，以链接实时库librt。</p>
<p>　　POSIX时钟API中的主要系统调用是<code>clock_gettime()</code>、<code>clock_getres()</code>和<code>clock_settime()</code>。</p>
<h4 id="clock_gettime">23.5.1 <code>clock_gettime()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">(<span class="type">clockid_t</span> clockid, <span class="keyword">struct</span> timespec *tp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_getres</span><span class="params">(<span class="type">clockid_t</span> clockid, <span class="keyword">struct</span> timespec *res)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>clock_gettime()</code>会将参数<code>clockid</code>指定的时钟的时间值存储在参数<code>tp</code>指向的结构体<code>timespec</code>中
(尽管该结构体的精度可以达到纳秒，但这里存储在该结构体中的时间的精度可能更低)。系统调用<code>clock_getres()</code>会将参数<code>clockid</code>指定的时钟的精度存储在参数<code>res</code>指向的结构体<code>timespec</code>中。</p>
<p>　　SUSv3详细说明了数据类型<code>clockid_t</code>，该数据类型用于表示时钟标识符。</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr>
<th>时钟ID</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CLOCK_REALTIME</code></td>
<td>可设置的系统级实时时钟</td>
</tr>
<tr>
<td><code>CLOCK_MONOTONIC</code></td>
<td>不可设置的单调时钟</td>
</tr>
<tr>
<td><code>CLOCK_PROCESS_CPUTIME_ID</code></td>
<td>进程级CPU时间时钟 (Linux 2.6.12及以上版本)</td>
</tr>
<tr>
<td><code>CLOCK_THREAD_CPUTIME_ID</code></td>
<td>线程级CPU时间时钟 (Linux 2.6.12及以上版本)</td>
</tr>
</tbody>
</table>
<p>　　<code>CLOCK_REALTIME</code>时钟是测量挂钟时间的系统级时钟。与<code>CLOCK_MONOTONIC</code>时钟相比，该时钟的设置可以修改。</p>
<p>　　SUSv3规定，<code>CLOCK_MONOTONIC</code>时钟测量自过去某个时间点以来的时间，该时间点在系统启动后就不会改变。对于不能受到系统时钟的不连续修改
(例如，手动修改系统时间)
的影响的应用程序，该时钟很有用。对于Linux，该时钟测量自系统启动以来的时间。</p>
<p>　　<code>CLOCK_PROCESS_CPUTIME_ID</code>时钟测量调用进程所用的用户和系统CPU时间。<code>CLOCK_THREAD_CPUTIME_ID</code>为线程执行类似的任务。</p>
<p>　　SUSv3详细说明了这4个时钟，但只有<code>CLOCK_REALTIME</code>时钟是必须提供的，并且在UNIX实现中得到了广泛的支持。</p>
<p>　　Linux 2.6.28添加了时钟类型<code>CLOCK_MONOTONIC_RAW</code>
(用于特殊的时钟同步应用程序)。该时钟不可设置，但可以访问不受NTP调整影响的仅基于硬件的时间。</p>
<p>　　Linux
2.6.32添加了时钟类型<code>CLOCK_REALTIME_COARSE</code>和<code>CLOCK_MONOTIC_COARSE</code>
(用于以最小代价获取低精度时间戳的应用程序)。这2种时钟与<code>CLOCK_REALTIME</code>和<code>CLOCK_MONOTONIC</code>时钟类似，但时间精度更低。这2种非标准时钟无法访问硬件时钟
(某些硬件时钟源的访问成本较高)，并且返回值的精度是jiffy。</p>
<h4 id="clock_settime">23.5.2 <code>clock_settime()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_settime</span><span class="params">(<span class="type">clockid_t</span> clockid, <span class="type">const</span> <span class="keyword">struct</span> timespec *tp)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>clock_settime()</code>会通过参数<code>tp</code>指向的结构体<code>timespec</code>中的时间设置参数<code>clockid</code>指定的时钟。</p>
<p>　　若<code>tp</code>指向的结构体<code>timespec</code>中的时间不是<code>clock_getres()</code>返回的时间精度的整数倍，则该时间会向下取整。</p>
<p>　　特权进程 (能力<code>CAP_SYS_TIME</code>)
可以设置<code>CLOCK_REALTIME</code>时钟。该时钟的初始值通常是自纪元以来的时间。23.5.1的表格中的其他时钟类型不可修改。</p>
<p>　　SUSv3允许设置<code>CLOCK_PROCESS_CPUTIME_ID</code>和<code>CLOCK_THREAD_CPUTIME_ID</code>时钟。在撰写本书时，这2个时钟在Linux上是不可设置的。</p>
<h4 id="clock_getcpuclockid和pthread_getcpuclockid">23.5.3
<code>clock_getcpuclockid()</code>和<code>pthread_getcpuclockid()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_getcpuclockid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">clockid_t</span> *clockid)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>clock_getcpuclockid()</code>会将进程ID为<code>pid</code>的进程的CPU时间时钟标识符存储在参数<code>clockid</code>指向的缓冲区中。若<code>pid</code>为0，则将调用进程的CPU时间时钟标识符存储在缓冲区中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_getcpuclockid</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">clockid_t</span> *clockid)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_getcpuclockid()</code>是<code>clock_getcpuclockid()</code>的POSIX线程版本。</p>
<h4 id="clock_nanosleep">23.5.4 <code>clock_nanosleep()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_nanosleep</span><span class="params">(<span class="type">clockid_t</span> clockid, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="keyword">struct</span> timespec *request, <span class="keyword">struct</span> timespec *remain)</span>; <span class="comment">/* 完成睡眠时返回0，睡眠被中断或出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　与<code>nanosleep()</code>类似，特定于Linux的系统调用<code>clock_nanosleep()</code>会将调用进程的执行挂起指定时间，或者被信号中断。参数<code>request</code>和<code>remain</code>与对应的<code>nanosleep()</code>参数类似。</p>
<p>　　在默认情况下
(即<code>flags</code>为0)，<code>request</code>指定的睡眠时间是相对的。但是，若指定了标志<code>TIMER_ABSTIME</code>，则<code>request</code>指定的时间是由<code>clockid</code>标识的时钟测量的绝对时间。</p>
<p>　　对于23.4中介绍的 "睡过头" 问题
(尤其是进程通过循环来重启被信号中断的睡眠)，若信号以较高的频率到达，则相对时间
(通过<code>nanosleep()</code>睡眠)
会让睡眠时间更不准确。这个问题可以通过使用绝对时间避免
(先通过<code>clock_gettime()</code>获取当前时间，然后加上预期睡眠时间得到目标时间，最后调用<code>clock_nanosleep()</code>时指定标志<code>TIMER_ABSTIME</code>)。</p>
<p>　　若指定了标志<code>TIMER_ABSTIME</code>，则参数<code>remain</code>不会生效。当<code>clock_nanosleep()</code>被信号中断时，可以以相同参数再次调用该函数来重启睡眠。</p>
<p>　　区分<code>clock_nanosleep()</code>和<code>nanosleep</code>的另一个特性是<code>clock_nanosleep()</code>可以指定测量睡眠时间的时钟
(例如，<code>CLOCK_REALTIME</code>、<code>CLOCK_MONOTONIC</code>或<code>CLOCK_PROCESS_CPUTIME_ID</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">request</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检索CLOCK_REALTIME时钟的当前值 */</span></span><br><span class="line"><span class="keyword">if</span> (clock_gettime(CLOCK_REALTIME, &amp;request) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;clock_gettime&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.tv_sec += <span class="number">20</span>; <span class="comment">/* 睡眠20秒 */</span></span><br><span class="line"></span><br><span class="line">s = clock_nanosleep(CLOCK_REALTIME, TIMER_ABSTIME, &amp;request, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Interrupted by signal handler\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;clock_nanosleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过<code>clock_nanosleep()</code>以<code>CLOCK_REALTIME</code>时钟的绝对时间来睡眠20秒。</p>
<h3 id="posix间隔定时器">23.6 POSIX间隔定时器</h3>
<p>　　通过<code>setitimer()</code>设置的经典间隔定时器存在很多限制：</p>
<p>　　●
只能设置3种间隔定时器：<code>ITIMER_REAL</code>、<code>ITIMER_VIRTUAL</code>和<code>ITIMER_PROF</code>。</p>
<p>　　●
只能通过信号来通知进程间隔定时器过期。此外，无法修改间隔定时器过期时生成的信号。</p>
<p>　　●
在间隔定时器对应的信号被阻塞期间，即使间隔定时器多次过期，信号处理函数也只会被调用1次，所以无法得知是否出现了这种情况。</p>
<p>　　● 间隔定时器的精度只能达到微妙。</p>
<p>　　POSIX.1b定义的POSIX定时器API没有这些限制。Linux从2.6开始支持该API。对于glibc
2.17之前的版本，使用该API的程序在编译时必须带有选项<code>-lrt</code>，以链接实时库librt。</p>
<p>　　POSIX定时器API将定时器的生命周期划分为以下阶段：</p>
<p>　　●
系统调用<code>timer_create()</code>会创建定时器，并定义该定时器过期时通知进程的方法。</p>
<p>　　● 系统调用<code>timer_settime()</code>会启动或停止定时器。</p>
<p>　　●
系统调用<code>timer_delete()</code>会删除定时器。所有POSIX定时器都会占用系统资源，所以当不再需要POSIX定时器时，应该通过该系统调用来释放相关系统资源。</p>
<p>　　对于较旧的Linux版本，glibc的基于线程的实现仅提供了该API的部分功能。但是，该用户空间实现并未提供这里介绍的所有功能。</p>
<p>　　POSIX定时器不会被通过<code>fork()</code>创建的子进程继承。此外，POSIX定时器会在<code>exec()</code>期间或进程终止时停止并删除。</p>
<h4 id="timer_create">23.6.1 <code>timer_create()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_create</span><span class="params">(<span class="type">clockid_t</span> clockid, <span class="keyword">struct</span> sigevent *evp, <span class="type">timer_t</span> *timerid)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sigev_notify;         <span class="comment">/* 通知方法 */</span></span><br><span class="line">    <span class="type">int</span> sigev_signo;          <span class="comment">/* 定时器过期信号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">sigev_value</span>;</span> <span class="comment">/* 作为信号随附数据或传递给线程函数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">pid_t</span> _tid; <span class="comment">/* 接收信号的线程的线程ID */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="type">void</span> (*_function)(<span class="keyword">union</span> sigval); <span class="comment">/* 线程通知函数 */</span></span><br><span class="line">            <span class="type">void</span> *_attribute;                <span class="comment">/* 通知属性 */</span></span><br><span class="line">        &#125; _sigev_thread;</span><br><span class="line">    &#125; _sigev_un;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sigev_notify_function _sigev_un._sigev_thread._function</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sigev_notify_attributes _sigev_un._sigev_thread._attribute</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sigev_notify_thread_id _sigev_un._tid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>timer_create()</code>会创建1个使用参数<code>clockid</code>指定的时钟测量时间的定时器。<code>clockid</code>可以指定为23.5.1的表格中的值，或者通过<code>clock_getcpuclockid()</code>或<code>pthread_getcpuclockid()</code>返回的<code>clockid</code>值。</p>
<p>　　参数<code>timerid</code>指向的缓冲区会包含1个句柄，该句柄用于在POSIX定时器API的其他系统调用中引用定时器。SUSv3详细说明了数据类型<code>clockid_t</code>，该数据类型用于表示定时器标识符。</p>
<p>　　参数<code>evp</code>是指向结构体<code>sigevent</code>的指针，用于指定定时器过期时程序如何收到通知。</p>
<p>　　结构体<code>sigevent</code>的成员<code>sigev_notify</code>可以指定为以下标志之一：</p>
<p>　　●
<code>SIGEV_NONE</code>表示定时器过期时不进行通知。进程依然可以通过<code>timer_gettime()</code>来监控程序的定时器。</p>
<p>　　●
<code>SIGEV_SIGNAL</code>表示定时器过期时为进程生成成员<code>sigev_signo</code>指定的信号。若成员<code>sigev_signo</code>是实时信号，则成员<code>sigev_value</code>将作为其随附数据
(见22.4)。</p>
<p>　　●
<code>SIGEV_THREAD</code>表示定时器过期时调用成员<code>sigev_notify_function</code>指定的函数，该函数将在新线程中作为启动函数被调用
(SUSv3要求如此，并且允许实现以将每个通知传递到1个新的独立线程或将通知按序传递给新线程的方式为周期性定时器生成通知)。成员<code>sigev_notify_attributes</code>可以指定为<code>NULL</code>或指向结构体<code>pthread_attr_t</code>的指针。成员<code>sigev_value</code>将作为传递给该函数的唯一参数。</p>
<p>　　●
<code>SIGEV_THREAD_ID</code>与<code>SIGEV_SIGNAL</code>类似，但是信号会传递给线程ID为<code>sigev_notify_thread_id</code>的线程，该线程的进程ID必须匹配调用进程的进程ID
(当使用<code>SIGEV_SIGNAL</code>通知时，信号会排队到进程。若进程有多个线程，则信号会传递给该进程的任意线程)。成员<code>sigev_notify_thread_id</code>可以设置为<code>clone()</code>或<code>gettid()</code>的返回值。该标志旨在供线程库使用
(需要线程实现使用选项<code>CLONE_THREAD</code>)。</p>
<p>　　SUSv3详细说明了前3个标志，第4个标志是特定于Linux。</p>
<p>　　参数<code>evp</code>可以指定为<code>NULL</code>，这等同于将成员<code>sigev_notify</code>指定为<code>SIGEV_SIGNAL</code>，成员<code>sigev_signo</code>指定为<code>SIGALRM</code>
(其他系统可能有所不同，因为SUSv3仅要求指定为默认信号编号)
以及成员<code>sigev_value.sival_int</code>指定为定时器ID。</p>
<p>　　在当前的实现中，内核会为每个通过<code>timer_create()</code>创建的POSIX定时器预分配1个排队实时信号结构体，以保证至少有1个这样的结构体可用于定时器过期时排队信号。这表示可创建的POSIX定时器的数量受限于可以排队的实时信号的数量限制。</p>
<h4 id="timer_settime">23.6.2 <code>timer_settime()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_settime</span><span class="params">(<span class="type">timer_t</span> timerid, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> itimerspec *value,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> itimerspec *old_value)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">it_interval</span>;</span> <span class="comment">/* 周期性定时器的间隔 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">it_value</span>;</span>    <span class="comment">/* 第1次过期时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>timer_settime()</code>会启动或停止参数<code>timerid</code>指定的定时器
(之前通过<code>timer_create()</code>创建)。</p>
<p>　　参数<code>value</code>和<code>old_value</code>都是指向结构体<code>itimerspec</code>的指针，前者用于指定定时器的新设置，后者用于存储定时器的旧设置。</p>
<p>　　结构体<code>itimerspec</code>的成员<code>it_value</code>表示定时器的第1次过期时间。若成员<code>it_interval</code>的所有成员都是非0值，则定时器会周期性过期
(当第1次过期后，会按照该成员的值定期过期)。若成员<code>it_interval</code>的所有成员都是0，则定时器只会过期1次。</p>
<p>　　若参数<code>flags</code>指定为0，则<code>value.it_value</code>会被解释为相对于调用<code>timer_settime()</code>的时间的相对时间。若该参数指定为<code>TIMER_ABSTIME</code>，则<code>value.it_value</code>会被解释为绝对时间。若指定的绝对时间已经过去，则定时器会立即过期。</p>
<p>　　为了启动定时器，调用<code>timer_settime()</code>时需要将<code>value.it_value</code>的所有成员都指定为非0值。若该定时器已启动，则会覆盖设置。</p>
<p>　　若结构体<code>itimerspec</code>的成员值不是对应时钟精度的整数倍，则这些值会向上取整。</p>
<p>　　每次定时器过期时，进程会以通过<code>timer_create()</code>指定的方式收到通知。若成员<code>it_interval</code>包含非0值，则这些值会重新装载给成员<code>it_value</code>。</p>
<p>　　为了停止定时器，调用<code>timer_settime()</code>时需要将<code>value.it_value</code>的所有成员都指定为0。</p>
<h4 id="timer_gettime">23.6.3 <code>timer_gettime()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_gettime</span><span class="params">(<span class="type">timer_t</span> timerid, <span class="keyword">struct</span> itimerspec *curr_value)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>timer_settime()</code>会将参数<code>timerid</code>指定的定时器
(之前通过<code>timer_create()</code>创建)
的间隔和距离下一次过期的时间存储在参数<code>curr_value</code>指向的结构体<code>itimerspec</code>中。</p>
<p>　　若<code>curr_value.it_value</code>的成员都是0，则表示定时器处于停止状态。若<code>curr_value.it_interval</code>的成员都是0，则表示定时器只会过期1次。</p>
<h4 id="timer_delete">23.6.4 <code>timer_delete()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_delete</span><span class="params">(<span class="type">timer_t</span> timerid)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>timer_delete()</code>会删除参数<code>timerid</code>指定的定时器
(之前通过<code>timer_create()</code>创建)。若该定时器已启动，则会在删除前停止该定时器。若存在来自该定时器过期的待处理信号，则信号会保持待处理状态
(SUSv3没有说明这一点，所以有些UNIX实现可能有所不同)。</p>
<p>　　当进程终止时，相关的POSIX定时器会自动删除。</p>
<h4 id="定时器超限">23.6.5 定时器超限</h4>
<p>　　当选择信号作为定时器过期的通知时，定时器在对应的信号被接收或捕获前多次过期的情况称为<strong>定时器超限</strong>
(因为进程在下一次被调度前需要等待一小段时间或信号被阻塞)。</p>
<p>　　即使将实时信号作为定时器过期的通知，定时器超限的问题也不能完全解决，因为排队的实时信号的数量存在上限。因此，POSIX.1b规定：当选择信号作为定时器过期的通知时，同一信号的多个实例<span
style="background-color: yellow">不会排队</span>
(即使使用的是实时信号)。在收到信号后
(通过信号处理函数或<code>sigwaitinfo()</code>)，可以获取<strong>定时器超限计数</strong>，即定时器在信号被生成到信号被接收期间<span
style="background-color: yellow">额外</span>过期的次数
(例如，若定时器在此期间过期了3次，则超限计数为2)。当信号被接收后，对应的定时器的超限计数会重置。</p>
<p>　　除了使用结构体<code>siginfo_t()</code>的成员<code>si_overrun</code>来获取超限计数之外，还可以使用SUSv3详细说明的系统调用<code>timer_getoverrun()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_getoverrun</span><span class="params">(<span class="type">timer_t</span> timerid)</span>; <span class="comment">/* 成功时返回定时器的超限计数，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>timer_getoverrun()</code>会返回参数<code>timerid</code>指定的定时器的超限计数。该系统调用是异步信号安全的，所以可以在信号处理函数中调用该系统调用。</p>
<h4 id="通过信号通知">23.6.6 通过信号通知</h4>
<p>　　当选择信号作为定时器过期的通知时，可以通过信号处理函数、<code>sigwaitinfo()</code>或<code>sigtimedwait()</code>来接收信号。当调用<code>sigwaitinfo()</code>或<code>sigtimedwait()</code>来接收信号时，结构体<code>siginfo_t</code>的以下成员会被设置：</p>
<p>　　● <code>si_signo</code>会被设置为定时器过期时生成的信号。</p>
<p>　　● <code>si_code</code>会被设置为<code>SI_TIMER</code>。</p>
<p>　　●
<code>si_value</code>会被设置为调用<code>timer_create()</code>时指定给<code>evp.sigev_value</code>的值
(可用于区分定时多个过期时生成同一信号的定时器)。</p>
<p>　　特定于Linux的结构体<code>siginfo_t</code>成员<code>si_timerid</code>会包含系统内部使用的定时器ID，但这个定时器ID不同于<code>timer_create()</code>返回的ID，所以该ID对应用程序没有用。</p>
<p>　　当调用<code>timer_create()</code>时，<code>evp.sigev_value.sival_ptr</code>通常赋值为指定给参数<code>timerid</code>的值
(或者包含该值的结构体) 的地址，以允许接收进程获取定时器的ID。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* itimerspec_from_str.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;itimerspec_from_str.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据字符串设置结构体itimerspec的成员</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param str 格式为it_value.tv_sec[/it_value.tv_nsec][:it_interval.tv_sec[/it_interval.tv_nsec]</span></span><br><span class="line"><span class="comment"> * @param tsp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">itimerspecFromStr</span><span class="params">(<span class="type">char</span> *str, <span class="keyword">struct</span> itimerspec *tsp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *cptr, *sptr;</span><br><span class="line"></span><br><span class="line">    cptr = <span class="built_in">strchr</span>(str, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *cptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sptr = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *sptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tsp-&gt;it_value.tv_sec = atoi(str);</span><br><span class="line">    tsp-&gt;it_value.tv_nsec = (sptr != <span class="literal">NULL</span>) ? atoi(sptr + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cptr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tsp-&gt;it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">        tsp-&gt;it_interval.tv_nsec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sptr = <span class="built_in">strchr</span>(cptr + <span class="number">1</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *sptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tsp-&gt;it_interval.tv_sec = atoi(cptr + <span class="number">1</span>);</span><br><span class="line">        tsp-&gt;it_interval.tv_nsec = (sptr != <span class="literal">NULL</span>) ? atoi(sptr + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ptmr_sigev_signal.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span>           <span class="comment">/* 函数currTime()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;itimerspec_from_str.h&quot;</span> <span class="comment">/* 函数itimerspecFromStr()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_SIG SIGRTMAX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数printf()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> * @param si</span></span><br><span class="line"><span class="comment"> * @param uc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *si, <span class="type">void</span> *uc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">timer_t</span> *tidptr;</span><br><span class="line"></span><br><span class="line">    tidptr = si-&gt;si_value.sival_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s] Got signal %d\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), sig);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    *sival_ptr = %ld\n&quot;</span>, (<span class="type">long</span>)*tidptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    timer_getoverrun() = %d\n&quot;</span>, timer_getoverrun(*tidptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sev</span>;</span></span><br><span class="line">    <span class="type">timer_t</span> *tidlist;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s secs[/nsecs][:int-secs[/int-nsecs]]...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tidlist = <span class="built_in">calloc</span>(argc - <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">timer_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (tidlist == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册信号处理函数 */</span></span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line">    sa.sa_sigaction = handler;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    <span class="keyword">if</span> (sigaction(TIMER_SIG, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为每个命令行参数创建POSIX定时器并启动 */</span></span><br><span class="line">    sev.sigev_notify = SIGEV_SIGNAL;</span><br><span class="line">    sev.sigev_signo = TIMER_SIG;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc - <span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        itimerspecFromStr(argv[j + <span class="number">1</span>], &amp;ts);</span><br><span class="line"></span><br><span class="line">        sev.sigev_value.sival_ptr = &amp;tidlist[j]; <span class="comment">/* 允许信号处理函数获取定时器ID */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer_create(CLOCK_REALTIME, &amp;sev, &amp;tidlist[j]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;timer_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Timer ID: %ld (%s)\n&quot;</span>, (<span class="type">long</span>)tidlist[j], argv[j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer_settime(tidlist[j], <span class="number">0</span>, &amp;ts, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;timer_settime&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待信号 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何将信号作为POSIX定时器过期的通知。该程序的命令行参数指定定时器的初始值和间隔。该程序会执行以下步骤：</p>
<p>　　1) 为作为定时器过期的通知的信号注册处理函数 (第49~55行)。</p>
<p>　　2) 为每个命令行参数创建POSIX定时器并启动 (第58~76行)。</p>
<p>　　3)
每次定时器过期时，<code>sev.sigev_signo</code>指定的信号会传递给进程。信号处理函数会打印对应的定时器的ID和超限计数值
(第18~27行)。</p>
<p>　　4) 循环调用<code>pause()</code>来等待定时器过期时生成的信号
(第79~82行)。</p>
<h4 id="通过线程通知">23.6.7 通过线程通知</h4>
<p>　　标志<code>SIGEV_THREAD</code>允许程序通过在1个单独的线程中调用函数的方式来接收定时器过期的通知。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ptmr_sigev_thread.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span>           <span class="comment">/* 函数currTime()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;itimerspec_from_str.h&quot;</span> <span class="comment">/* 函数itimerspecFromStr()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> expireCnt = <span class="number">0</span>; <span class="comment">/* 所有定时器的过期次数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线程通知函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">threadFunc</span><span class="params">(<span class="keyword">union</span> sigval sv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">timer_t</span> *tidptr;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    tidptr = sv.sival_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s] Thread notify\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    timer ID=%ld\n&quot;</span>, (<span class="type">long</span>)*tidptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    timer_getoverrun()=%d\n&quot;</span>, timer_getoverrun(*tidptr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 增加与主线程共享的计数器变量，并发送条件变量来通知主线程 */</span></span><br><span class="line">    s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    expireCnt += <span class="number">1</span> + timer_getoverrun(*tidptr);</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_cond_signal(&amp;cond);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_cond_signal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="type">timer_t</span> *tidlist;</span><br><span class="line">    <span class="type">int</span> s, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s secs[/nsecs][:int-secs[/int-nsecs]]...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tidlist = <span class="built_in">calloc</span>(argc - <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">timer_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (tidlist == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sev.sigev_notify = SIGEV_THREAD;</span><br><span class="line">    sev.sigev_notify_function = threadFunc;</span><br><span class="line">    sev.sigev_notify_attributes = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为每个命令行参数创建POSIX定时器并启动 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc - <span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        itimerspecFromStr(argv[j + <span class="number">1</span>], &amp;ts);</span><br><span class="line"></span><br><span class="line">        sev.sigev_value.sival_ptr = &amp;tidlist[j]; <span class="comment">/* 作为参数传递给threadFunc() */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer_create(CLOCK_REALTIME, &amp;sev, &amp;tidlist[j]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;timer_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Timer ID: %ld (%s)\n&quot;</span>, (<span class="type">long</span>)tidlist[j], argv[j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer_settime(tidlist[j], <span class="number">0</span>, &amp;ts, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;timer_settime&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主线程等待每次调用线程通知函数时都会发送的条件变量，并打印1条信息 */</span></span><br><span class="line">    s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pthread_cond_wait(&amp;cond, &amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_cond_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main(): expireCnt = %d\n&quot;</span>, expireCnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何将线程作为POSIX定时器过期的通知。该程序的命令行参数与<code>ptmr_sigev_signal</code>的相同。该程序会执行以下步骤：</p>
<p>　　1)
为每个命令行参数创建POSIX定时器并启动。每次定时器过期时，<code>sev.sigev_notify_function</code>指定的函数都会在1个单独的线程中被调用。当该函数被调用时，<code>sev.sigev_value.sival_ptr</code>指定的值会作为参数，这里将其赋值为定时器ID的地址
(第75~91行)。</p>
<p>　　2)
主线程通过循环来等待定时器过期，每次循环时会调用<code>pthread_cond_wait()</code>来等待由处理定时器通知的线程发送的条件变量<code>cond</code>
(第100~108行)。</p>
<p>　　3)
每次定时器过期时会调用函数<code>threadFunc()</code>。在打印信息后，该函数会增加全局变量<code>expireCnt</code>，并发送条件变量<code>cond</code>给主线程来作为定时器过期的通知
(第19~50行)。</p>
<h3 id="timerfd-api">23.7 timerfd API</h3>
<p>　　Linux从内核2.6.25开始提供特定于Linux的timerfd API。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timerfd_create</span><span class="params">(<span class="type">int</span> clockid, <span class="type">int</span> flags)</span>; <span class="comment">/* 成功时返回文件描述符，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timerfd_settime</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> itimerspec *new_value,</span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> itimerspec *old_value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">timerfd_gettime</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> itimerspec *curr_value)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>timerfd_create()</code>会创建1个定时器，并返回引用该定时器的文件描述符。参数<code>clockid</code>可以指定为<code>CLOCK_REALTIME</code>或<code>CLOCK_MONOTONIC</code>。</p>
<p>　　在<code>timerfd_create()</code>的最初实现中，参数<code>flags</code>只能指定0。直到Linux
2.6.27，该参数才支持以下2个标志：</p>
<p>　　● <code>TFD_CLOEXEC</code>表示启用新文件描述符的close-on-exec标志
(<code>FD_CLOEXEC</code>)。</p>
<p>　　●
<code>TFD_NONBLOCK</code>表示启用底层文件描述符的标志<code>O_NONBLOCK</code>。</p>
<p>　　当不再需要通过<code>timerfd_create()</code>创建的文件描述符时，应该通过<code>close()</code>来关闭该文件描述符，以释放该文件描述符引用的定时器的相关资源。</p>
<p>　　系统调用<code>timerfd_settime()</code>会启动或停止参数<code>fd</code>引用的定时器。参数<code>flags</code>、<code>new_value</code>和<code>old_value</code>的用法与对应的<code>timer_settime()</code>参数的相同。</p>
<p>　　与<code>timer_gettime()</code>类似，系统调用<code>timerfd_gettime()</code>会将参数<code>fd</code>引用的定时器的间隔和距离下一次过期的时间存储在参数<code>curr_value</code>指向的结构体<code>itimerspec</code>中。</p>
<p>　　通过<code>timerfd_create()</code>创建的文件描述符可以被通过<code>fork()</code>创建的子进程继承，并且这些文件描述符引用的是同一定时器，所以子进程也可以从该文件描述符中读取定时器过期的通知。</p>
<p>　　通过<code>timerfd_create()</code>创建的文件描述符在<code>exec()</code>期间会被保留
(除非启用了该文件描述符的close-on-exec标志)，并且已启动的定时器在此期间会正常过期。</p>
<p>　　当定时器启动后，可以对引用该定时器的文件描述符调用<code>read()</code>来获取定时器的过期信息。为此，提供给<code>read()</code>的缓冲区必须能够容纳至少1个无符号64位整数
(<code>uint64_t</code>)。若自上一次<code>timerfd_settime()</code>修改定时器或调用<code>read()</code>以来定时器过期了至少1次，则<code>read()</code>会立即返回，并且缓冲区会包含过期次数。若定时器不曾过期，则<code>read()</code>会阻塞，直到定时器过期。在这种情况下，若启用了该文件描述符的标志<code>O_NONBLOCK</code>，则<code>read()</code>不会阻塞，但会导致错误<code>EAGAIN</code>。</p>
<p>　　通过<code>timerfd_create()</code>创建的文件描述可以通过<code>select()</code>、<code>poll()</code>和epoll监控。当文件描述符引用的定时器过期时，文件描述符会变为可读。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* demo_timerfd.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;itimerspec_from_str.h&quot;</span> <span class="comment">/* 函数itimerspecFromStr()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">now</span>;</span></span><br><span class="line">    <span class="type">int</span> maxExp, fd, secs, nanosecs;</span><br><span class="line">    <span class="type">uint64_t</span> numExp, totalExp;</span><br><span class="line">    <span class="type">ssize_t</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s secs[/nsecs][:int-secs[/int-nsecs]] [max-exp]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    itimerspecFromStr(argv[<span class="number">1</span>], &amp;ts);</span><br><span class="line">    maxExp = (argc &gt; <span class="number">2</span>) ? getInt(argv[<span class="number">2</span>], GN_GT_0, <span class="string">&quot;max-exp&quot;</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    fd = timerfd_create(CLOCK_REALTIME, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;timerfd_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timerfd_settime(fd, <span class="number">0</span>, &amp;ts, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;timerfd_settime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clock_gettime(CLOCK_MONOTONIC, &amp;start) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;clock_gettime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (totalExp = <span class="number">0</span>; totalExp &lt; maxExp;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 读取定时器的过期次数，并打印自定时器启动以来的时间、读取的过期次数和总过期次数 */</span></span><br><span class="line">        s = read(fd, &amp;numExp, <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        totalExp += numExp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clock_gettime(CLOCK_MONOTONIC, &amp;now) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;clock_gettime&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        secs = now.tv_sec - start.tv_sec;</span><br><span class="line">        nanosecs = now.tv_nsec - start.tv_nsec;</span><br><span class="line">        <span class="keyword">if</span> (nanosecs &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            secs--;</span><br><span class="line">            nanosecs += <span class="number">1000000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d.%03d: expirations read: %llu; total=%llu\n&quot;</span>, secs, (nanosecs + <span class="number">500000</span>) / <span class="number">1000000</span>,</span><br><span class="line">               (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)numExp, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)totalExp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了timerfd API的用法。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第22章 信号：高级特性</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_22/</url>
    <content><![CDATA[<p>　　特定信号会导致进程生成核心转储文件并终止，核心转储文件是进程终止时的内存映像
(术语core源于早期内存技术)。在默认情况下，生成的核心转储文件位于进程的工作目录，并且名为<code>core</code>。</p>
<p>　　很多UNIX实现都提供了用于获取运行中的进程的核心转储文件的工具
(例如，FreeBSD和Solaris的<code>gcore</code>)，Linux也提供了类似的功能：将运行中的进程附加到gdb，然后使用命令<code>gcore</code>。</p>
<p>　　核心转储文件在以下情况不会生成：</p>
<p>　　●
进程没有权限写核心存储文件，这可能是因为进程没有要创建核心转储文件的目录的写权限，或者同名的文件已经存在，并且该文件不可写入或不是常规文件
(例如，目录或符号链接)。</p>
<p>　　● 同名的常规文件已存在，并且可写，但该文件至少有2个硬链接。</p>
<p>　　● 要创建核心转储文件的目录不存在。</p>
<p>　　● 进程的核心转储文件大小资源限制 (<code>RLIMIT_CORE</code>)
为0。</p>
<p>　　● 进程的文件大小资源限制 (<code>RLIMIT_FSIZE</code>) 为0。</p>
<p>　　● 进程正在执行的二进制可执行文件未启用读权限
(为了防止用户使用核心转储文件来获取没有读权限的程序的代码副本)。</p>
<p>　　●
当前工作目录所在的文件系统挂载为只读、已满或i-node已用完，或者用户已达到文件系统的配额限制。</p>
<p>　　● 由所有者 (或所属组) 之外的用户运行的set-user-ID程序
(或set-group-ID程序) 不会生成核心转储文件
(为了防止用户使用核心转储文件来获取安全程序的内存映像并提取密码等敏感信息)。</p>
<p>　　特定于Linux的系统调用<code>prctl()</code>的操作<code>PR_SET_DUMPABLE</code>可用于设置进程的标志<code>dumpable</code>，以便由所有者
(或所属组) 之外的用户运行的set-user-ID程序 (或set-group-ID程序)
也能生成核心转储文件。Linux
2.4及以上版本开始支持操作<code>PR_SET_DUMPABLE</code>。此外，从内核2.6.13开始，文件<code>/proc/sys/fs/suid_dumpable</code>提供了set-user-ID程序
(或set-group-ID程序) 是否生成核心转储文件的系统级控制。</p>
<p>　　有时，内核会让进程睡眠，睡眠状态包括<code>TASK_INTERRUPTIBLE</code>和<code>TASK_UNINTERRUPTIBLE</code>。</p>
<p>　　● <code>TASK_INTERRUPTIBLE</code>表示进程正在等待某些事件
(例如，终端输入、数据写入到当前为空的无名管道或System
V信号量的值增加)。进程处于此状态的时间是不固定的。若信号的目标进程处于此状态，则操作会被中断，并且目标进程会在信号到达时被唤醒。在命令<code>ps</code>打印的结果中，处于此状态的进程的STAT
(进程状态) 字段是S。</p>
<p>　　● <code>TASK_UNINTERRUPTIBLE</code>表示进程正在等待特定类型的事件
(例如，磁盘I/O的完成)。进程处于此状态的时间通常很短。若信号的目标进程处于此状态，则信号只会在目标进程<span
style="background-color: yellow">退出此状态</span>后传递。在命令<code>ps</code>打印的结果中，处于此状态的进程的STAT字段是D。</p>
<p>　　Linux和大部分UNIX实现都提供了这2个状态。Linux从内核2.6.25开始支持睡眠状态<code>TASK_KILLABLE</code>。此状态与<code>TASK_UNINTERRUPTIBLE</code>类似，但处于此状态的进程在收到能够终止进程的信号时会被唤醒。</p>
<span id="more"></span>
<p>　　<span
style="background-color: yellow">无法</span>修改信号<code>SIGKILL</code>和<code>SIGSTOP</code>的处理方式，试图通过<code>signal()</code>和<code>sigaction()</code>修改这2个信号的处理方式会导致错误。因此，这2个信号总是会终止和停止进程
(除非进程由于硬件故障、NFS问题或内核漏洞等情况而一直处于睡眠状态<code>TASK_UNINTERRUPTIBLE</code>)。</p>
<p>　　信号<code>SIGCONT</code>总是会恢复停止的进程，即使目标进程当前阻塞或忽略了该信号
(若目标进程阻塞了该信号，并且注册了信号处理函数来捕获该信号，则在目标进程恢复后，信号处理函数只会在解除阻塞该信号后调用)。若发送给停止进程的是其他信号，则信号的传递实际发生会在进程恢复后
(唯一的例外是信号<code>SIGKILL</code>，该信号甚至会终止已停止的进程)。</p>
<p>　　当进程收到信号<code>SIGCONT</code>时，该进程的所有待处理的停止信号都会被丢弃。相反，当进程收到停止信号时，该进程的所有待处理的<code>SIGCONT</code>都会被丢弃。这是为了防止进程被<code>SIGCONT</code>恢复后，再次被先于<code>SIGCONT</code>发送的停止信号停止
(以及相反的情况)。</p>
<p>　　若程序执行时发现终端生成的信号的处理方式已经被设置为<code>SIG_IGN</code>，则程序通常<span
style="background-color: yellow">不应该</span>修改该信号的处理方式。</p>
<p>　　如前所述，进程通常无法预测信号何时传递，这仅适用于<span
style="background-color: yellow">异步生成</span>的信号，即信号由内核或其他进程发送，用于通知目标进程发生了与目标进程的执行无关的事件
(例如，用户在终端输入中断字符或子进程终止)。在某些情况下，进程的执行流程包括生成信号
(例如，执行会导致硬件异常的指令或发送信号给自己)。此时，信号是<span
style="background-color: yellow">同步生成</span>的，并且信号会立即传递
(除非信号已被阻塞)。换句话说，对于同步生成的信号，信号的传递是可预测和可重现的。</p>
<p>　　同步生成的信号会立即传递。例如，当进程调用<code>raise()</code>时，信号的传递会先于<code>raise()</code>返回。对于异步生成的信号，信号可能会短时间内处于待处理状态
(即使信号未被阻塞)，因为内核只会在为了执行目标进程而从内核模式切换到用户模式时传递待处理信号，这表示信号实际是在目标进程再次被调度
(即时间片的开始) 或系统调用完成 (信号的传递可能导致阻塞系统调用提前完成)
时传递。</p>
<p>　　当通过<code>sigprocmask()</code>解除阻塞多个待处理信号时，这些信号都会立即传递给目标进程。在当前的实现中，Linux会按照信号编号的升序传递这些信号。例如，若待处理的<code>SIGINT</code>
(信号2) 和<code>SIGQUIT</code> (信号3)
同时被解除阻塞，则<code>SIGINT</code>会先于<code>SIGQUIT</code>传递，无论它们的生成顺序如何。但是，SUSv3规定，这种情况下的标准信号的传递顺序是实现定义的。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_22/delivery_of_multiple_unblocked_signals.svg" class="">
<p>　　当多个未阻塞的信号等待传递时，若在执行按序第1个信号的处理函数期间出现了内核模式与用户模式之间的切换，则该信号处理函数会被按序第2个信号的处理函数中断，依此类推。</p>
<p>　　POSIX.1b定义了实时信号来弥补标准信号的不足：</p>
<p>　　●
标准信号中可用于应用程序定义的目的信号只有2个：<code>SIGUSR1</code>和<code>SIGUSR2</code>，而实时信号中可用于此目的的信号较多。</p>
<p>　　● 标准信号不会排队，而实时信号会排队。</p>
<p>　　● 当发送实时信号时，可以指定信号的随附数据
(1个整数或指针值)，对应的处理函数可以获取该数据。</p>
<p>　　●
不同的实时信号会按序传递。不同的实时信号之间存在优先级，实时信号的编号越小，优先级越高。对于多个相同类型的实时信号，它们会按照发送顺序进行传递。</p>
<h3 id="核心转储文件">22.1 核心转储文件</h3>
<p>　　从内核2.6.23开始，特定于Linux的文件<code>/proc/PID/coredump_filter</code>提供了写到核心转储文件的内存映射的类型的进程级控制，对应的值是对应4种内存映射类型的4位掩码，这4种内存映射类型分别是<span
style="background-color: yellow">私有匿名映射</span>、<span
style="background-color: yellow">私有文件映射</span>、<span
style="background-color: yellow">共享匿名映射</span>和<span
style="background-color: yellow">共享文件映射</span>。该值的默认值表示传统Linux行为：仅使用私有匿名映射和共享匿名映射。</p>
<p>　　从内核2.6开始，核心转储文件的名称可以通过特定于Linux的文件<code>/proc/sys/kernel/core_pattern</code>中的格式字符串控制。在默认情况下，该字符串是<code>core</code>。特权用户可以将该字符串定义为包含以下格式说明符：</p>
<table>
<thead>
<tr>
<th>格式说明符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%c</code></td>
<td>核心转储文件大小的软资源限制 (Linux 2.6.24及以上版本)</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>可执行文件名 (没有路径前缀)</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>转储进程的实际组ID</td>
</tr>
<tr>
<td><code>%h</code></td>
<td>主机系统名</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>转储进程的进程ID</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>终止进程的信号的编号</td>
</tr>
<tr>
<td><code>%t</code></td>
<td>转储时间 (自纪元以来的秒数)</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>转储进程的实际用户ID</td>
</tr>
<tr>
<td><code>%%</code></td>
<td>字符<code>%</code></td>
</tr>
</tbody>
</table>
<p>　　此外，格式字符串可以包含斜杠<code>/</code>。因此，该字符串不仅可以控制核心转储文件的名称，还可以控制要创建核心转储文件的
(绝对或相对) 目录。</p>
<p>　　在所有格式说明符都转换后，结果路径名字符串会截断为最多128个字符
(Linux 2.6.19之前是64个字符)。</p>
<p>　　文件<code>core_pattern</code>从内核2.6.19开始支持额外语法：若该文件包含以管道符<code>|</code>开头的字符串，则剩余字符会解释为程序，并且可以带有命令行参数
(可能包含上表中的格式说明符)。该程序会在转储核心时执行，并且核心转储内容会写入到该程序的标准输入
(而非核心转储文件)。</p>
<p>　　有些UNIX实现提供了与<code>core_pattern</code>类似的机制。例如，对于BSD衍生实现，可以在文件名后加上程序名
(即<code>core.progname</code>)。Solaris提供了工具<code>coreadm</code>，以允许用户选择核心转储文件的文件名和目录。</p>
<h3 id="硬件生成的信号">22.2 硬件生成的信号</h3>
<p>　　信号<code>SIGBUS</code>、<code>SIGFPE</code>、<code>SIGILL</code>和<code>SIGSEGV</code>可以作为硬件异常的结果生成，或者由<code>kill()</code>发送。对于前者，SUSv3规定，当进程从信号处理函数返回以及进程忽略或阻塞了信号时，进程的行为将是未定义的。</p>
<p>　　●
假设机器语言指令生成这些信号之一，并且随后调用了信号处理函数。当从信号处理函数正常返回时，程序会试图在中断处继续执行。但是，中断处正是导致生成信号的指令，所以信号会再次生成。这种结果通常会导致程序进入无限循环，重复调用信号处理函数。</p>
<p>　　●
忽略硬件生成的信号几乎没有意义。对于因硬件异常而生成的信号，Linux会保证该信号的传递，即使目标进程忽略了该信号。</p>
<p>　　● 同样，阻塞硬件生成的信号几乎也没有意义。对于Linux
2.4及以下版本，内核会直接无视进程对硬件生成的信号的阻塞，所以信号会传递给进程，然后终止进程或被信号处理函数捕获。从Linux
2.6开始，若硬件生成的信号被阻塞，则进程会立即被信号终止，即使进程已经为信号注册了处理函数
(Linux 2.6修改硬件生成的信号的处理方式是因为Linux
2.4的处理方式会隐藏漏洞，并且可能导致线程程序出现死锁)。</p>
<p>　　处理硬件生成的信号的正确方法是不改变这些信号的默认处理方式
(终止进程)
或为这些信号注册不会正常返回的处理函数，即调用<code>_exit()</code>终止进程或调用<code>siglongjmp()</code>进行非本地跳转来保证控制权会转移给其他位置
(而非生成该信号的指令)。</p>
<h3 id="signal的实现和可移植性">22.3
<code>signal()</code>的实现和可移植性</h3>
<p>　　这里将介绍如何通过<code>sigaction()</code>实现<code>signal()</code>。实现方式很简单，但需要考虑到1个事实：从历史和不同的UNIX实现角度，<code>signal()</code>具有不同的语义。早期信号实现不可靠，所以会导致以下情况：</p>
<p>　　●
在进入信号处理函数时，信号的处理方式会被设置为<code>SIG_DFL</code>
(对应20.10中的标志<code>SA_RESETHAND</code>)。为了在同一信号再次到达时能够调用该信号处理函数，需要调用<code>signal()</code>来再次注册该信号处理函数。这种情况的问题在于进入信号处理函数与重新注册信号处理函数之间存在空窗期。在此期间，若信号再次到达，则会根据默认处理方式处理。</p>
<p>　　● 信号处理函数执行时未阻塞对应的信号
(对应20.10中的标志<code>SA_NODEFER</code>)。因此，若信号处理函数执行时对应的信号再次到达，则会再次调用该信号处理函数。当信号短时间内多次到达时，反复调用信号处理函数可能会导致栈溢出。</p>
<p>　　除了信号不可靠之外，早期UNIX实现还没有提供自动重启系统调用的机制。</p>
<p>　　4.2BSD的可靠信号解决了这些问题，其他几个UNIX实现也纷纷效仿。但是，旧语义依旧存在于System
V实现的<code>signal()</code>中，并且SUSv3和C99等同时代的标准故意没有说明<code>signal()</code>的这些方面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* signal.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> sig, <span class="type">sighandler_t</span> handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newDisp</span>, <span class="title">prevDisp</span>;</span></span><br><span class="line"></span><br><span class="line">    newDisp.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;newDisp.sa_mask);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OLD_SIGNAL</span></span><br><span class="line">    newDisp.sa_flags = SA_RESETHAND | SA_NODEFER;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    newDisp.sa_flags = SA_RESTART;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(sig, &amp;newDisp, &amp;prevDisp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SIG_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> prevDisp.sa_handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是结合了以上信息得到的<code>signal()</code>实现。在默认情况下，该实现会使用现代信号语义。若编译时使用了选项<code>–DOLD_SIGNAL</code>，则会使用不可靠信号语义，并且不会自动重启系统调用。</p>
<p>　　Linux内核提供了<code>signal()</code>的不可靠信号语义的系统调用版本。但是，glibc通过提供基于<code>sigaction()</code>的<code>signal()</code>库函数来绕过该系统调用。glibc的<code>signal()</code>库函数实现随着时间的推移而变化。对于较新的glibc版本
(glibc
2及以上版本)，默认使用现代信号语义。对于较旧的版本，使用的是不可靠信号语义
(兼容System V)。</p>
<p>　　当需要使用不可靠信号语义的现代版本glibc时，可以使用非标准函数
<code>sysv_signal()</code>来代替<code>signal()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*sysv_signal(<span class="type">int</span> sig, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>); <span class="comment">/* 成功时返回目标信号的旧处理方式，出错时返回SIG_ERR */</span></span><br></pre></td></tr></table></figure>
<p>　　<code>sysv_signal()</code>的参数与<code>signal()</code>的相同。若编译时没有定义特性测试宏<code>_BSD_SOURCE</code>，则glibc会隐式地将所有对<code>signal()</code>的调用都替换为对该函数的调用
(所以<code>signal()</code>会使用不可靠信号语义)。在默认情况下，特性测试宏<code>_BSD_SOURCE</code>会被定义。但是，若编译时定义了<code>_SVID_SOURCE</code>或<code>_XOPEN_SOURCE</code>等其他特性测试宏，则该特性测试宏会被禁用
(除非显式定义了该特性测试宏)。</p>
<h3 id="实时信号">22.4 实时信号</h3>
<p>　　SUSv3要求实现提供的实时信号数至少为<code>_POSIX_RTSIG_MAX</code>
(定义为8)。Linux内核提供了32个实时信号，编号为32到63。头文件<code>signal.h</code>定义了常量<code>RTSIG_MAX</code>、<code>SIGRTMIN</code>和<code>SIGRTMAX</code>。第1个常量表示可用的实时信号的数量，后2个常量表示实时信号的编号的最小值和最大值。</p>
<p>　　对于使用LinuxThread线程实现的系统，<code>SIGRTMIN</code>定义为35
(而非32)，以允许LinuxThread内部使用前3个实时信号。对于使用NPTL线程实现的系统，<code>SIGRTMIN</code>定义为34，以允许NPTL内部使用前2个实时信号。</p>
<p>　　实时信号不像标准信号那样由不同的常量标识。但是，应用程序不应该通过编号来引用实时信号，因为实时信号的编号范围因UNIX实现而异。相反，应该以<code>SIGRTMIN + n</code>的形式来引用实时信号。</p>
<p>　　此外，SUSv3不要求<code>SIGRTMIN</code>和<code>SIGRTMAX</code>为简单的整数值，所以这2个常量可能定义为函数
(Linux就是如此)。</p>
<p>　　排队的实时信号 (和随附数据)
需要内核为所有进程都维护相关数据结构，这会占用内核内存，所以内核对排队的实时信号的数量施加了限制。</p>
<p>　　SUSv3允许实现对进程的排队的实时信号的数量设置上限，并要求该限制至少为<code>_POSIX_SIGQUEUE_MAX</code>
(定义为32)。实现可以定义常量<code>SIGQUEUE_MAX</code>来表示排队的实时信号的数量限制，其值可以通过以下调用获取：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lim = sysconf(_SC_SIGQUEUE_MAX);</span><br></pre></td></tr></table></figure>
<p>　　对于Linux，该调用会返回-1，因为Linux使用不同的模型来限制排队的实时信号的数量。</p>
<p>　　● 对于Linux
2.6.27及以下版本，内核使用系统级限制来限制所有进程的排队的实时信号的数量。该限制可以通过特定于Linux的文件<code>/proc/sys/kernel/rtsig-max</code>获取，并且可以修改
(需要特权)。该限制默认为1024。当前排队的实时信号的数量可以通过特定于Linux的文件<code>/proc/sys/kernel/rtsig-nr</code>获取。</p>
<p>　　● 对于Linux
2.6.28及以上版本，模型发生了改变，并且删除了之前的<code>/proc</code>接口。对于新模型，软资源限制<code>RLIMIT_SIGPENDING</code>定义了特定实际用户ID的所有进程的排队的实时信号的数量总和。</p>
<p>　　为了在2个进程之间传递实时信号，SUSv3做出了以下规定：</p>
<p>　　●
发送进程使用系统调用<code>sigqueue()</code>来发送实时信号和随附数据。<code>kill()</code>、<code>killpg()</code>和<code>raise()</code>也能用于发送实时信号，但SUSv3规定通过这些接口发送的实时信号是否会排队由实现定义。对于Linux，通过这些接口发送的实时信号会排队，但很多UNIX实现并非如此。</p>
<p>　　●
接收进程为实时信号注册处理函数时需要指定标志<code>SA_SIGINFO</code>
(见21.5)。对于Linux，即使为实时信号注册处理函数时未指定该标志，实时信号也会排队
(尽管无法获取实时信号的随附数据)。但是，SUSv3没有要求实现保证这一点。</p>
<h4 id="发送实时信号">22.4.1 发送实时信号</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sival_int;</span><br><span class="line">    <span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sigqueue()</code>会发送参数<code>sig</code>指定的实时信号和参数<code>value</code>指定的随附数据给参数<code>pid</code>指定的进程。通过该系统调用发送实时信号所需的权限与使用<code>kill()</code>所需的权限相同。<code>sig</code>可以指定为0，其含义与<code>kill()</code>的相同。但是，<code>sig</code>不能为负数。</p>
<p>　　Linux和部分UNIX实现定义了与<code>sigval</code>类似的数据类型<code>sigval_t</code>，但SUSv3没有说明该数据类型，并且有些UNIX没有提供该数据类型。</p>
<p>　　当排队的实时信号的数量达到上限时，对<code>sigqueue()</code>的调用可能会导致错误<code>EAGAIN</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_sigqueue.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sig, numSigs, j, sigData;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">sv</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pid sig-num data [num-sigs]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: PID is %ld, UID is %ld\n&quot;</span>, argv[<span class="number">0</span>], (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getuid());</span><br><span class="line"></span><br><span class="line">    sig = getInt(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;sig-num&quot;</span>);</span><br><span class="line">    sigData = getInt(argv[<span class="number">3</span>], GN_ANY_BASE, <span class="string">&quot;data&quot;</span>);</span><br><span class="line">    numSigs = (argc &gt; <span class="number">4</span>) ? getInt(argv[<span class="number">4</span>], GN_GT_0, <span class="string">&quot;num-sigs&quot;</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numSigs; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sv.sival_int = sigData + j;</span><br><span class="line">        <span class="keyword">if</span> (sigqueue(getLong(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>), sig, sv) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigqueue %d&quot;</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>sigqueue()</code>的用法。该程序有4个命令行参数：信号编号、目标进程ID、随附的整数数据和信号数，前3个命令行参数是必须提供的，第4个命令行参数是可选的。若指定了第4个命令行参数，则每次发送实时信号时都会将随附的整数数据加1。</p>
<h4 id="处理实时信号">22.4.2 处理实时信号</h4>
<p>　　可以像处理标准信号那样为实时信号注册常规处理函数
(只有1个参数)，也可以通过标志<code>SA_SIGINFO</code>注册包含3个参数的处理函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_sigaction = handler;</span><br><span class="line">act.sa_flags = SA_RESTART | SA_SIGINFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGRTMIN + <span class="number">5</span>, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过标志<code>SA_SIGINFO</code>为第6个实时信号注册处理函数。当指定了标志<code>SA_SIGINFO</code>后，第2个传递给信号处理函数的参数是结构体<code>siginfo_t</code>，其中包含关于实时信息的更多信息
(见21.5)。</p>
<p>　　对于实时信号，结构体<code>siginfo_t</code>的以下成员会被设置：</p>
<p>　　●
成员<code>si_signo</code>与传递给信号处理函数的第1个参数相同。</p>
<p>　　●
成员<code>si_code</code>表示信号源，包含21.5的表格中的值之一。对于通过<code>sigqueue()</code>发送的实时信号，该成员的值总是为<code>SI_QUEUE</code>。</p>
<p>　　●
成员<code>si_value</code>包含发送进程指定给<code>sigqueue()</code>的参数<code>value</code>的值。如前所述，该成员的值的解释由应用程序决定
(若信号是通过<code>kill()</code>发送，则该成员不会包含有效信息)。</p>
<p>　　●
成员<code>si_pid</code>和<code>si_uid</code>分别包含发送进程的进程ID和实际用户ID。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* catch_rtsigs.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> handlerSleepTime;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> sigCnt = <span class="number">0</span>; <span class="comment">/* 收到的信号的数量 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> allDone = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数printf()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> * @param si</span></span><br><span class="line"><span class="comment"> * @param ucontext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">siginfoHandler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *si, <span class="type">void</span> *ucontext)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT || sig == SIGTERM) <span class="comment">/* 信号SIGINT和SIGTERM会终止程序 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        allDone = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigCnt++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;caught signal %d\n&quot;</span>, sig);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; si_signo=%d, si_code=%d (%s), &quot;</span>, si-&gt;si_signo, si-&gt;si_code,</span><br><span class="line">           (si-&gt;si_code == SI_USER) ? <span class="string">&quot;SI_USER&quot;</span> : (si-&gt;si_code == SI_QUEUE) ? <span class="string">&quot;SI_QUEUE&quot;</span></span><br><span class="line">                                                                            : <span class="string">&quot;other&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;si_value=%d\n&quot;</span>, si-&gt;si_value.sival_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; si_pid=%ld, si_uid=%ld\n&quot;</span>, (<span class="type">long</span>)si-&gt;si_pid, (<span class="type">long</span>)si-&gt;si_uid);</span><br><span class="line"></span><br><span class="line">    sleep(handlerSleepTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    <span class="type">sigset_t</span> prevMask, blockMask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [block-time [handler-sleep-time]]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: PID is %ld\n&quot;</span>, argv[<span class="number">0</span>], (<span class="type">long</span>)getpid());</span><br><span class="line"></span><br><span class="line">    handlerSleepTime = (argc &gt; <span class="number">2</span>) ? getInt(argv[<span class="number">2</span>], GN_NONNEG, <span class="string">&quot;handler-sleep-time&quot;</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为大部分信号都注册处理函数。在处理函数执行期间，阻塞其他所有信号来防止处理函数重复中断 */</span></span><br><span class="line">    sa.sa_sigaction = siginfoHandler;</span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (sig = <span class="number">1</span>; sig &lt; NSIG; sig++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sig != SIGTSTP &amp;&amp; sig != SIGQUIT)</span><br><span class="line">        &#123;</span><br><span class="line">            sigaction(sig, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 可选择阻塞信号并睡眠 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigfillset(&amp;blockMask);</span><br><span class="line">        sigdelset(&amp;blockMask, SIGINT);</span><br><span class="line">        sigdelset(&amp;blockMask, SIGTERM);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;blockMask, &amp;prevMask) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: signals blocked - sleeping %s seconds\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        sleep(getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;block-time&quot;</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: sleep complete\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;prevMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!allDone) <span class="comment">/* 等待信号 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何处理实时信号。该程序会捕获信号，然后打印传递给信号处理函数的结构体<code>siginfo_t</code>中的部分成员。该程序有2个可选的命令行参数。若指定了第1个命令行参数，则主函数会阻塞所有信号，然后睡眠该命令行参数指定的秒数。若指定了第2个参数，则信号处理函数在返回前会睡眠该命令行参数指定的秒数；否则，信号处理函数在返回前只会睡眠1秒。</p>
<p>　　这里将通过22.4.1中的<code>t_sigqueue.c</code>和<code>catch_rtsigs.c</code>来展示实时信号的处理方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./catch_rtsigs 60 &amp;</span></span><br><span class="line">[1] 12842</span><br><span class="line">./catch_rtsigs: PID is 12842</span><br><span class="line">./catch_rtsigs: signals blocked - sleeping 60 seconds</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 12842 54 100 3</span></span><br><span class="line">./t_sigqueue: PID is 12843, UID is 1000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 12842 43 200</span></span><br><span class="line">./t_sigqueue: PID is 12844, UID is 1000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 12842 40 300</span></span><br><span class="line">./t_sigqueue: PID is 12845, UID is 1000</span><br></pre></td></tr></table></figure>
<p>　　当程序<code>catch_rtsigs</code>完成睡眠后，会打印信号处理函数捕获的信号。最先到达的信号的是编号最小的信号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./catch_rtsigs: <span class="built_in">sleep</span> complete</span></span><br><span class="line">caught signal 40</span><br><span class="line"> si_signo=40, si_code=-1 (SI_QUEUE), si_value=300</span><br><span class="line"> si_pid=12845, si_uid=1000</span><br><span class="line">caught signal 43</span><br><span class="line"> si_signo=43, si_code=-1 (SI_QUEUE), si_value=200</span><br><span class="line"> si_pid=12844, si_uid=1000</span><br></pre></td></tr></table></figure>
<p>　　剩余的输出是同一实时信号的3个实例
(成员<code>si_value</code>的值反映了发送这些实时信号的顺序)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">caught signal 54</span><br><span class="line"> si_signo=54, si_code=-1 (SI_QUEUE), si_value=100</span><br><span class="line"> si_pid=12843, si_uid=1000</span><br><span class="line">caught signal 54</span><br><span class="line"> si_signo=54, si_code=-1 (SI_QUEUE), si_value=101</span><br><span class="line"> si_pid=12843, si_uid=1000</span><br><span class="line">caught signal 54</span><br><span class="line"> si_signo=54, si_code=-1 (SI_QUEUE), si_value=102</span><br><span class="line"> si_pid=12843, si_uid=1000</span><br></pre></td></tr></table></figure>
<p>　　最后，通过命令<code>kill</code>来发送信号给程序<code>catch_rtsigs</code>
(命令<code>echo $$</code>会打印shell的进程ID)。在打印的信息中，成员<code>si_code</code>是0，表示实时信号由用户进程通过<code>kill()</code>或<code>raise</code>发送：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $$</span></span><br><span class="line">12780</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -40 12842</span></span><br><span class="line">caught signal 40</span><br><span class="line"> si_signo=40, si_code=0 (SI_USER), si_value=0</span><br><span class="line"> si_pid=15354, si_uid=1000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> 12842</span></span><br><span class="line">[1]  + done       ./catch_rtsigs 60</span><br></pre></td></tr></table></figure>
<h3 id="sigsuspend">22.5 <code>sigsuspend()</code></h3>
<p>　　假设需要在执行关键代码时临时阻塞信号<code>SIGINT</code>，然后挂起进程，直到信号<code>SIGINT</code>到达。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sigset_t</span> prevMask, intMask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;intMask);</span><br><span class="line">sigaddset(&amp;intMask, SIGINT);</span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">sa.sa_handler = handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;intMask, &amp;prevMask) == <span class="number">-1</span>) <span class="comment">/* 阻塞信号SIGINT */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigprocmask - SIG_BLOCK&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关键代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;prevMask, <span class="literal">NULL</span>) == <span class="number">-1</span>) <span class="comment">/* 解除阻塞信号SIGINT */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigprocmask - SIG_SETMASK&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若信号SIGINT此时到达，则会导致漏洞 */</span></span><br><span class="line"></span><br><span class="line">pause(); <span class="comment">/* 等待信号SIGINT */</span></span><br></pre></td></tr></table></figure>
<p>　　信号<code>SIGINT</code>完全可能在第2次调用<code>sigprocmask()</code>之后和调用<code>pause()</code>之前到达，这完全不符合程序的要求：解除阻塞信号<code>SIGINT</code>后，等待该信号的第1次到达。这种依赖于时间的漏洞是竞争条件的示例之一。通常，当多个进程或线程共享同一资源时，才会导致竞争条件。但是，对于这种情况，主函数会与信号处理函数竞争。</p>
<p>　　为了避免这个问题，需要能够以<span
style="background-color: yellow">原子</span>方式解除阻塞信号并挂起进程的方法，这正是系统调用<code>sigsuspend()</code>的目的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>; <span class="comment">/* 返回-1并将errno设置为EINTR或EFAULT */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sigsuspend()</code>会将调用进程的信号掩码替换为参数<code>mask</code>指向的信号集，然后挂起调用进程，直到信号被信号处理函数捕获并返回。一旦从信号处理函数返回，<code>sigsuspend()</code>就会将调用进程的信号掩码恢复到调用该系统调用之前的值。</p>
<p>　　调用<code>sigsuspend()</code>等同于以原子方式执行以下操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prevMask); <span class="comment">/* 设置信号掩码 */</span></span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prevMask, <span class="literal">NULL</span>); <span class="comment">/* 恢复信号掩码 */</span></span><br></pre></td></tr></table></figure>
<p>　　尽管<code>sigsuspend()</code>恢复信号掩码的行为可能看似不方便，但在需要反复等待信号时，该行为对避免竞争条件至关重要。在这种情况下，除了调用<code>sigsuspend()</code>期间之外，其他时间必须阻塞信号。</p>
<p>　　当<code>sigsuspend()</code>被信号中断或<code>mask</code>是无效地址时，会返回-1，前者会导致<code>errno</code>设置为<code>EINTR</code>，后者会导致<code>errno</code>设置为<code>EFAULT</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_sigsuspend.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;signal_functions.h&quot;</span> <span class="comment">/* printSigMask()和printPendingSigs()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> gotSigquit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数printf()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal %d (%s)\n&quot;</span>, sig, strsignal(sig));</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGQUIT)</span><br><span class="line">    &#123;</span><br><span class="line">        gotSigquit = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> loopNum;</span><br><span class="line">    <span class="type">time_t</span> startTime;</span><br><span class="line">    <span class="type">sigset_t</span> origMask, blockMask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    printSigMask(<span class="built_in">stdout</span>, <span class="string">&quot;Initial signal mask is:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;blockMask);</span><br><span class="line">    sigaddset(&amp;blockMask, SIGINT);</span><br><span class="line">    sigaddset(&amp;blockMask, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;blockMask, &amp;origMask) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask - SIG_BLOCK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGQUIT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (loopNum = <span class="number">1</span>; !gotSigquit; loopNum++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=== LOOP %d\n&quot;</span>, loopNum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过延时几秒来模拟执行关键代码 */</span></span><br><span class="line">        printSigMask(<span class="built_in">stdout</span>, <span class="string">&quot;Starting critical section, signal mask is:\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (startTime = time(<span class="literal">NULL</span>); time(<span class="literal">NULL</span>) &lt; startTime + <span class="number">4</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printPendingSigs(<span class="built_in">stdout</span>, <span class="string">&quot;Before sigsuspend() - pending signals:\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sigsuspend(&amp;origMask) == <span class="number">-1</span> &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigsuspend&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;origMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask - SIG_SETMASK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printSigMask(<span class="built_in">stdout</span>, <span class="string">&quot;=== Exited loop\nRestored signal mask to:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进行其他处理 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>sigsuspend()</code>的用法。该程序会执行以下步骤：</p>
<p>　　1) 打印信号掩码的当前值 (第32行)。</p>
<p>　　2)
阻塞信号<code>SIGINT</code>和<code>SIGQUIT</code>和保存信号掩码的当前值
(第34~40行)。</p>
<p>　　3)
为信号<code>SIGINT</code>和<code>SIGQUIT</code>注册处理函数。该处理函数会打印捕获的信号，若捕获的信号是<code>SIGQUIT</code>，则还会设置全局变量<code>gotSigquit</code>
(第42~52行)。</p>
<p>　　4)
进行循环，直到全局变量<code>gotSigquit</code>被设置。每次循环会打印信号掩码的当前值、模拟执行关键代码、打印待处理信号以及解除阻塞信号<code>SIGINT</code>和<code>SIGQUIT</code>并等待这2个信号
(第54~70行)。</p>
<p>　　5) 恢复信号掩码 (第72~75行)。</p>
<p>　　6) 打印恢复后的信号掩码 (第77行)。</p>
<h3 id="sigwaitinfo和sigtimedwait">22.6
<code>sigwaitinfo()</code>和<code>sigtimedwait()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigwaitinfo</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">siginfo_t</span> *info)</span>; <span class="comment">/* 成功时返回收到的信号的编号，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigtimedwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">siginfo_t</span> *info,</span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>; <span class="comment">/* 成功时返回收到的信号的编号，超时或出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sigwaitinfo()</code>会挂起调用进程，直到参数<code>set</code>指向的信号集中的信号之一到达。若<code>set</code>指向的信号集中的信号在调用该系统调用时已处于待处理状态，则<code>sigwaitinfo()</code>会立即返回，对应的信号会从进程的待处理信号集中删除，并且其编号会作为函数结果返回。若参数<code>info</code>不为<code>NULL</code>，则它指向的结构体<code>siginfo_t</code>会初始化为包含提供给信号处理函数的参数<code>siginfo</code>的信息
(见21.5)。</p>
<p>　　<code>sigwaitinfo()</code>的信号到达顺序和排队规则与信号处理函数的相同，即标准信号不会排队，实时信号会排队，并且编号最小的信号最先到达。除了可以省去编写信号处理函数之外，使用<code>sigwaitinfo()</code>等待信号也比信号处理函数加<code>sigsuspend()</code>的组合更快。</p>
<p>　　系统调用<code>sigtimedwait()</code>是<code>sigwaitinfo()</code>的变体，可以通过参数<code>timeout</code>指定等待时间。若<code>timeout</code>的所有成员都是0，则该系统调用会立即返回
(可用于检测是否存在待处理信号)。若等待超时，则该系统调用会返回-1，并将<code>error</code>设置为<code>EAGAIN</code>。</p>
<p>　　当将<code>timeout</code>指定为<code>NULL</code>时，<code>sigtimedwait()</code>等同于<code>sigwaitinfo()</code>。SUSv3没有说明将<code>timeout</code>指定为<code>NULL</code>时<code>sigtimedwait()</code>的行为，并且有些UNIX实现将这种情况视为将<code>timeout</code>的所有成员都指定为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_sigwaitinfo.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    <span class="type">siginfo_t</span> si;</span><br><span class="line">    <span class="type">sigset_t</span> allSigs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [delay-secs]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: PID is %ld\n&quot;</span>, argv[<span class="number">0</span>], (<span class="type">long</span>)getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 阻塞所有信号 (除了SIGKILL和SIGSTOP) */</span></span><br><span class="line">    sigfillset(&amp;allSigs);</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;allSigs, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: signals blocked\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 适当延时，以便接收信号 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: about to delay %s seconds\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        sleep(getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;delay-secs&quot;</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: finished delay\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        sig = sigwaitinfo(&amp;allSigs, &amp;si);</span><br><span class="line">        <span class="keyword">if</span> (sig == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigwaitinfo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sig == SIGINT || sig == SIGTERM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got signal: %d (%s)\n&quot;</span>, sig, strsignal(sig));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; si_signo=%d, si_code=%d (%s), si_value=%d\n&quot;</span>,</span><br><span class="line">               si.si_signo, si.si_code,</span><br><span class="line">               (si.si_code == SI_USER) ? <span class="string">&quot;SI_USER&quot;</span> : (si.si_code == SI_QUEUE) ? <span class="string">&quot;SI_QUEUE&quot;</span></span><br><span class="line">                                                                              : <span class="string">&quot;other&quot;</span>,</span><br><span class="line">               si.si_value.sival_int);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; si_pid=%ld, si_uid=%ld\n&quot;</span>, (<span class="type">long</span>)si.si_pid, (<span class="type">long</span>)si.si_uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>sigwaitinfo()</code>的用法。该程序会先阻塞所有信号，然后延时命令行参数指定的秒数。最后，进行循环，直到收到信号<code>SIGINT</code>或<code>SIGTERM</code>，每次循环都会通过<code>sigwaitinfo()</code>等待信号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigwaitinfo 60 &amp;</span></span><br><span class="line">./t_sigwaitinfo: PID is 3837</span><br><span class="line">./t_sigwaitinfo: signals blocked</span><br><span class="line">./t_sigwaitinfo: about to delay 60 seconds</span><br><span class="line">[1] 3837</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 3837 43 100</span></span><br><span class="line">./t_sigqueue: PID is 3839, UID is 1000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 3837 42 200</span> </span><br><span class="line">./t_sigqueue: PID is 3840, UID is 1000</span><br></pre></td></tr></table></figure>
<p>　　先在后台运行程序<code>t_sigwaitinfo</code>，并通过程序<code>t_sigqueue</code>发送实时信号42和43给该程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigwaitinfo: finished delay</span></span><br><span class="line">got signal: 42</span><br><span class="line"> si_signo=42, si_code=-1 (SI_QUEUE), si_value=200</span><br><span class="line"> si_pid=3840, si_uid=1000</span><br><span class="line">got signal: 43</span><br><span class="line"> si_signo=43, si_code=-1 (SI_QUEUE), si_value=100</span><br><span class="line"> si_pid=3839, si_uid=1000</span><br></pre></td></tr></table></figure>
<p>　　当程序<code>t_sigwaitinfo</code>完成睡眠后，会循环接收排队信号。与实时信号被处理函数捕获一样，可以看到输出结果中编号最小的实时信号最先到达，并且<code>si_pid</code>和<code>si_uid</code>也与发送进程匹配。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $$</span></span><br><span class="line">3744</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -USR1 3837</span></span><br><span class="line">got signal: 10</span><br><span class="line"> si_signo=10, si_code=0 (SI_USER), si_value=100</span><br><span class="line"> si_pid=3744, si_uid=1000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> %1</span> </span><br><span class="line">[1]  + done       ./t_sigwaitinfo 60</span><br></pre></td></tr></table></figure>
<p>　　继续通过命令<code>kill</code>发送信号给程序<code>t_sigwaitinfo</code>，可以看到输出结果中<code>si_code</code>是<code>SI_USER</code>，<code>si_value</code>是100
(该值是收到上一个信号时设置的值，所以该值是无效值)。</p>
<h3 id="signalfd">22.7 <code>signalfd()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">signalfd</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">sigset_t</span> *mask, <span class="type">int</span> flags)</span>; <span class="comment">/* 成功时返回文件描述符，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　Linux从内核2.6.22开始提供非标准系统调用<code>signalfd()</code>。该系统调用会将创建1个signalfd文件描述符，调用进程可以从该文件描述符中读取信号。参数<code>mask</code>指定希望能够从该文件描述符中读取的信号。与<code>sigwaitinfo()</code>一样，应该将<code>mask</code>中的所有信号阻塞，防止这些信号在被读取前按照默认处理方式处理。</p>
<p>　　若参数<code>fd</code>指定为-1，则<code>signalfd()</code>会创建signalfd文件描述符；否则，它会修改<code>fd</code>关联的掩码
(<code>fd</code>必须是之前通过<code>signalfd()</code>获取的文件描述符)。</p>
<p>　　在最初的实现中，参数<code>flags</code>只能指定为0。但是，该参数从Linux
2.6.27开始支持2个标志：<code>SFD_CLOEXEC</code>和<code>SFD_NONBLOCK</code>。前者表示设置新signalfd文件描述符的close-on-exec标志
(<code>FD_CLOEXEC</code>)，后者表示设置底层打开的signalfd文件描述符的标志<code>O_NONBLOCK</code>
(以后的读都是非阻塞的)。</p>
<p>　　当创建signalfd文件描述符后，可以通过对该文件描述符调用<code>read()</code>来读取信号，传递给<code>read()</code>的缓冲区必须足够大，以容纳至少1个结构体<code>signalfd_siginfo</code>
(定义在头文件<code>sys/signalfd.h</code>中)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signalfd_siginfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_signo;    <span class="comment">/* 信号编号 */</span></span><br><span class="line">    <span class="type">int32_t</span> ssi_errno;     <span class="comment">/* 错误号 (通常不会使用) */</span></span><br><span class="line">    <span class="type">int32_t</span> ssi_code;      <span class="comment">/* 信号代码 */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_pid;      <span class="comment">/* 发送进程的进程ID */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_uid;      <span class="comment">/* 发送进程的实际用户ID */</span></span><br><span class="line">    <span class="type">int32_t</span> ssi_fd;        <span class="comment">/* 文件描述符 (仅限于信号SIGPOLL/SIGIO) */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_tid;      <span class="comment">/* 内核定时器ID (POSIX定时器) */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_band;     <span class="comment">/* Band event (仅限于信号SIGPOLL/SIGIO) */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_overrun;  <span class="comment">/* 超限计数 (POSIX定时器) */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_trapno;   <span class="comment">/* 导致信号生成的陷阱号 */</span></span><br><span class="line">    <span class="type">int32_t</span> ssi_status;    <span class="comment">/* 退出状态或信号 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">int32_t</span> ssi_int;       <span class="comment">/* sigqueue()发送的整数 */</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_ptr;      <span class="comment">/* sigqueue()发送的指针 */</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_utime;    <span class="comment">/* 用户CPU时间 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_stime;    <span class="comment">/* 系统CPU时间 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_addr;     <span class="comment">/* 生成信号的地址 (仅限于硬件生成的信号) */</span></span><br><span class="line">    <span class="type">uint16_t</span> ssi_addr_lsb; <span class="comment">/* 地址的最低有效位 (仅限于信号SIGBUS和Linux 2.6.37及以上版本) */</span></span><br><span class="line">    <span class="type">uint8_t</span> pad[X];        <span class="comment">/* 填充到128字节 (允许以后添加新成员) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　结构体<code>signalfd_siginfo</code>的成员提供的信息与结构体<code>siginfo_t</code>中名称相似的成员相同
(见21.5)。</p>
<p>　　每次调用<code>read()</code>会返回与待处理信号的数量相同的结构体<code>signalfd_siginfo</code>，但不会超过缓冲区的容量。若调用<code>read()</code>时没有待处理信号，则<code>read()</code>会阻塞，直到信号到达。这里也可以通过<code>fcntl()</code>的操作<code>F_SETFL</code>来设置signalfd文件描述符的标志<code>O_NONBLOCK</code>，随后对该文件描述符的读不会阻塞，并且在没有待处理信号时会导致错误<code>EAGAIN</code>。</p>
<p>　　当从signalfd文件描述符读取信号后，该信号会消耗，并且不再是进程的待处理信号。</p>
<p>　　可以使用<code>select()</code>、<code>poll()</code>和epoll来同时监控signalfd文件描述符和其他文件描述符。当存在待处理信号时，signalfd文件描述符会变为可读。</p>
<p>　　当不再需要signalfd文件描述符时，应该关闭它，以释放关联的内核资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* signalfd_sigval.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    <span class="type">int</span> sfd, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signalfd_siginfo</span> <span class="title">fdsi</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s sig-num...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: PID = %ld\n&quot;</span>, argv[<span class="number">0</span>], (<span class="type">long</span>)getpid());</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sigaddset(&amp;mask, atoi(argv[j]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sfd = signalfd(<span class="number">-1</span>, &amp;mask, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;signalfd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        s = read(sfd, &amp;fdsi, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> signalfd_siginfo));</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> signalfd_siginfo))</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: got signal %d&quot;</span>, argv[<span class="number">0</span>], fdsi.ssi_signo);</span><br><span class="line">        <span class="keyword">if</span> (fdsi.ssi_code == SI_QUEUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;; ssi_pid = %d; &quot;</span>, fdsi.ssi_pid);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ssi_int = %d&quot;</span>, fdsi.ssi_int);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>signalfd()</code>的用法。该程序会创建1个信号集，该信号集由命令行参数指定的信号组成。然后，阻塞这些信号，并创建1个signalfd文件描述符来读取这些信号。最后，进行循环，从signalfd文件描述符中读取信号，并打印返回的结构体<code>signalfd_siginfo</code>中的某些成员的值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./signalfd_sigval 44 &amp;</span></span><br><span class="line">./signalfd_sigval: PID = 6267</span><br><span class="line">[1] 6267</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 6267 44 123</span></span><br><span class="line">./t_sigqueue: PID is 6269, UID is 1000</span><br><span class="line">./signalfd_sigval: got signal 44; ssi_pid=6269; ssi_int=123</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> %1</span></span><br></pre></td></tr></table></figure>
<p>　　这里会通过程序<code>t_sigqueue</code>发送信号44和随附数据123给运行在后台的程序<code>signalfd_sigval</code>。</p>
<h3 id="通过信号进行进程间通信">22.8 通过信号进行进程间通信</h3>
<p>　　从某种角度，信号可以认为是进程间通信的形式之一。但是，当将信号作为IPC机制时，会受到很多限制。首先，相比其他IPC机制，使用信号的程序会更繁琐，原因如下：</p>
<p>　　●
信号的异步性本质会导致很多问题，包括可重入要求、竞争条件和在信号处理函数中正确地处理全局变量
(当使用<code>sigwaitinfo()</code>或<code>signalfd()</code>来同步接收信号时，其中的大部分问题将不会出现)。</p>
<p>　　●
标准信号不会排队，而实时信号存在排队数量限制。为了防止丢失信息，接收进程必须通过某种方法来通知发送进程它已经准备好接收下一个信号，最直接的方法就是接收进程发送信号给发送进程。</p>
<p>　　其次，信号能够携带的信息相当有限：信息编号和实时信号的随附数据。</p>
<p>　　因此，信号很少作为IPC机制。</p>
<h3 id="早期信号api">22.9 早期信号API</h3>
<p>　　上述内容都是关于POSIX信号API。这里将简短地介绍System
V和BSD提供的信号API。Linux和很多UNIX实现都提供了兼容System
V和BSD的信号API。</p>
<h4 id="system-v信号api">22.9.1 System V信号API</h4>
<p>　　对于System
V，若信号处理函数是通过<code>signal()</code>注册的，则使用的是不可靠信号语义，即信号不会添加到信号掩码，并且当调用信号处理函数后，信号的处理方式会被设置为<code>SIG_DFL</code>，被中断的系统调用不会自动重启。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*sigset(<span class="type">int</span> sig, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>); <span class="comment">/* 成功时返回目标信号的旧处理方式，目标信号被阻塞时返回SIG_HOLD，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sighold</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigrelse</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigignore</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpause</span><span class="params">(<span class="type">int</span> sig)</span>; <span class="comment">/* 总是返回-1并将errno设置为EINTR */</span></span><br></pre></td></tr></table></figure>
<p>　　为了以可靠信号语义注册信号处理函数，System
V提供了函数<code>sigset()</code>
(函数原型与<code>signal()</code>的相似)。与<code>signal()</code>相同，<code>sigset()</code>的参数<code>handler</code>可以指定为<code>SIG_IGN</code>、<code>SIG_DFL</code>或信号处理函数的地址。此外，该参数还可以指定为<code>SIG_HOLD</code>，表示将目标信号添加到信号掩码，同时不改变目标信号的处理方式。若<code>handler</code>指定为<code>SIG_HOLD</code>之外的值，则会将目标信号从信号掩码中删除
(若目标信号已被阻塞，则解除阻塞)。</p>
<p>　　函数<code>sighold()</code>会将参数<code>sig</code>指定的信号添加到信号掩码。函数<code>sigrelse()</code>会从信号掩码中删除参数<code>sig</code>指定的信号。函数<code>sigignore()</code>会将参数<code>sig</code>指定的信号的处理方式设置为忽略。函数<code>sigpause()</code>与<code>sigsuspend()</code>类似，但会在挂起进程前从信号掩码中删除参数<code>sig</code>指定的信号。</p>
<p>　　SUSv3详细说明了这些函数，但指出对应的现代POSIX信号API是更好的选择。SUSv4将这些函数标记为过时。</p>
<h4 id="bsd信号api">22.9.2 BSD信号API</h4>
<p>　　POSIX信号API在很大程度上借鉴了4.2BSD的信号API，所以BSD信号API与对应的POSIX信号API相似。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigvec</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> sigvec *vec, <span class="keyword">struct</span> sigvec *ovec)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回信号掩码的旧值 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigblock</span><span class="params">(<span class="type">int</span> mask)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetmask</span><span class="params">(<span class="type">int</span> mask)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpause</span><span class="params">(<span class="type">int</span> sigmask)</span>; <span class="comment">/* 总是返回-1并将errno设置为EINTR */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigmask</span><span class="params">(<span class="type">int</span> signum)</span>; <span class="comment">/* 返回signum的信号掩码 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigvec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*sv_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> sv_mask;</span><br><span class="line">    <span class="type">int</span> sv_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>sigvec()</code>与<code>sigaction()</code>类似。参数<code>vec</code>和<code>ovec</code>都是指向结构体<code>sigvec</code>的指针。结构体<code>sigvec</code>的成员与对应的结构体<code>sigaction</code>成员类似。第1个区别是成员<code>sv_mask</code>的数据类型是<code>int</code>。第2个区别是成员<code>sv_flags</code>的标志<code>SV_INTERRUPT</code>的用法：因为4.2BSD会默认重启系统调用，所以该标志表示系统调用应该被信号处理函数中断。</p>
<p>　　函数<code>sigblock()</code>会将参数<code>mask</code>指定的信号添加到信号掩码
(与<code>sigprocmask()</code>的操作<code>SIG_BLOCK</code>类似)。函数<code>sigsetmask()</code>会将信号掩码设置为参数<code>mask</code>指定的值
(与<code>sigprocmask()</code>的操作<code>SIG_SETMASK</code>类似)。</p>
<p>　　函数<code>sigpause()</code>与<code>sigsuspend()</code>类似，该函数在System
V和BSD中使用不同的调用签名定义。glibc默认提供System
V版本，除非编译程序时定义了特性测试宏<code>_BSD_SOURCE</code>。</p>
<p>　　函数<code>sigmask()</code>会将参数<code>signum</code>指定的信号编号转换为对应的32位掩码，可以对这种位掩码进行与操作<code>|</code>来获取信号集
(例如，<code>sigblock(sigmask(SIGINT) | sigmask(SIGQUIT))</code>)。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第29章 线程：简介</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_29/</url>
    <content><![CDATA[<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_29/four_threads_executing_in_a_process.svg" class="">
<p>　　与进程类似，线程是允许应用程序同时执行多个任务的机制之一。1个进程可以包含多个线程，这些线程独立地执行同一程序，并且共享全局内存
(包括未初始化数据段、已初始化数据段和堆)。实际上，每个线程的栈可能会与共享内存区域混合，具体取决于创建线程、加载共享库和附加共享内存区域的顺序。此外，线程栈的位置可能因Linux发行版而异。</p>
<p>　　属于同一进程的所有线程的栈都位于同一虚拟地址空间内，这表示可以通过合适的指针值来与其他线程共享数据。这种方法有时很有用，但需要仔细处理依赖关系，因为局部变量的有效性仅限于其所在的栈帧的生命周期。</p>
<p>　　传统的UNIX进程只是多线程进程的特殊情况之一，它是仅包含1个线程的进程。</p>
<p>　　线程可以并发执行。对于多处理器系统，多个线程可以同时执行。当某个线程阻塞在I/O时，其他线程可以继续执行。</p>
<p>　　对于某些应用程序，线程比进程更具优势。假设使用传统UNIX方法
(创建多个进程)
来实现并发，并以实现网络服务器为例。父进程接收来自客户端的连接请求，然后通过<code>fork()</code>创建子进程来处理与每个客户端的连接。虽然这种设计在很多情况下都很有效，但在部分应用程序中存在以下问题：</p>
<p>　　● 难以在进程间共享信息。由于父进程和子进程不会共享内存
(除了只读的文本段)，所以必须使用IPC机制来在进程间交换信息。</p>
<p>　　●
使用<code>fork()</code>创建进程的成本相对较高。即使使用了写时复制技术
(见24.1.2)，仍然需要复制页表和文件描述符表等进程属性，这表示<code>fork()</code>仍然比较耗时。</p>
<p>　　线程刚好解决了这2个问题：</p>
<p>　　● 线程间共享信息是简单且快速的，只需要将数据复制到共享 (全局和堆)
变量。但是，为了避免多个线程同时更新同一数据，需要使用同步机制。</p>
<p>　　● 线程创建比进程创建更快——通常至少快10倍
(对于Linux，线程是通过系统调用<code>clone()</code>实现的)，因为通过<code>fork()</code>创建子进程时必须复制的很多进程属性对线程是共享的
(不需要使用内存页的写时复制副本，也不需要复制页表)。</p>
<span id="more"></span>
<p>　　除了全局内存之外，线程还会共享很多属性
(这些属性对进程是全局，而非特定于线程的)，包括进程ID、父进程ID、进程组ID、会话ID、控制终端、进程凭证
(用户和组ID)、打开的文件描述符、通过<code>fcntl()</code>创建的记录锁、信号处理方式、文件系统相关属性
(umask、当前工作目录和根目录)、间隔定时器
(<code>setitimer()</code>)、POSIX定时器
(<code>timer_create()</code>)、System V信号量撤销 (<code>semadj</code>)
值、资源限制、使用的CPU时间 (由<code>times()</code>返回)、使用的资源
(由<code>getrusage()</code>返回) 和nice值
(由<code>setpriority()</code>和<code>nice()</code>设置)。</p>
<p>　　每个线程特有的属性包括线程ID、信号掩码、特定于线程的数据、备用信号栈、变量<code>errno</code>、浮点环境、实时调度策略和优先级、CPU亲和性
(特定于Linux)、能力 (特定于Linux) 以及栈。</p>
<p>　　当启动程序后，结果进程仅会包含1个线程，称为<strong>初始线程</strong>或<strong>主线程</strong>。</p>
<p>　　线程的执行会通过以下方式终止：</p>
<p>　　● 线程启动函数通过<code>return</code>指定返回值返回。</p>
<p>　　● 线程调用<code>pthread_exit()</code>。</p>
<p>　　● 线程被<code>pthread_cancel()</code>取消。</p>
<p>　　● 任一线程调用<code>exit()</code>或主线程 (在主函数中)
返回，这会导致进程的所有线程立即终止。</p>
<h3 id="pthreads-api的背景">29.1 Pthreads API的背景</h3>
<p>　　在20世纪80年代晚期和20世纪90年代早期，出现了多种线程API。在1996年，POSIX.1c标准化了POSIX线程API，该标准随后被纳入了SUSv3。</p>
<h4 id="pthreads数据类型">29.1.1 Pthreads数据类型</h4>
<p>　　Pthreads API定义了大量数据类型，下表列出了其中的部分：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pthread_t</code></td>
<td>线程ID</td>
</tr>
<tr>
<td><code>pthread_mutex_t</code></td>
<td>互斥锁</td>
</tr>
<tr>
<td><code>pthread_mutexattr_t</code></td>
<td>互斥锁属性对象</td>
</tr>
<tr>
<td><code>pthread_cond_t</code></td>
<td>条件变量</td>
</tr>
<tr>
<td><code>pthread_condattr_t</code></td>
<td>条件变量属性对象</td>
</tr>
<tr>
<td><code>pthread_key_t</code></td>
<td>特定于线程的数据的键值</td>
</tr>
<tr>
<td><code>pthread_once_t</code></td>
<td>一次性初始化控制上下文</td>
</tr>
<tr>
<td><code>pthread_attr_t</code></td>
<td>线程属性对象</td>
</tr>
</tbody>
</table>
<p>　　SUSv3没有指定如何表示这些数据类型，可移植应用程序应该将其视为不透明数据。因此，程序应该避免依赖于这些数据类型的变量结构或内容
(即不能使用运算符<code>==</code>来比较这些数据类型的变量)。</p>
<h4 id="线程和errno">29.1.2 线程和<code>errno</code></h4>
<p>　　对于传统UNIX
API，<code>errno</code>是全局整数变量，但这对多线程程序还不够。若某个线程调用的函数会通过全局变量<code>errno</code>返回错误，则可能导致其他调用此类函数并检查<code>errno</code>的线程出错，即产生竞争条件。因此，对于多线程程序，每个线程有自己的<code>errno</code>值。Linux实现特定于线程的<code>errno</code>的方式与大多数UNIX实现类似：将<code>errno</code>定义为宏，它展开为1个函数调用，返回1个对每个线程都不同的可修改的左值
(由于左值是可修改的，所以在多线程程序中可以使用赋值语句<code>errno = value</code>)。</p>
<p>　　综上所述，<code>errno</code>机制已适应线程，并且报告错误的方式与传统UNIX
API相同。</p>
<p>　　最初的POSIX.1遵循K&amp;R的C用法，允许程序将<code>errno</code>声明为<code>extern int errno</code>。SUSv3不允许这种用法
(该变更实际发生在1995年的POSIX.1c中)。现在，程序需要通过引用<code>errno.h</code>来声明<code>errno</code>，这使得每个线程都有自己的<code>errno</code>。</p>
<h4 id="pthreads函数的返回值">29.1.3 Pthreads函数的返回值</h4>
<p>　　系统调用和部分库函数返回状态的传统方法是成功时返回0，出错时返回-1并设置<code>errno</code>。Pthreads
API中的函数返回状态的方法有所不同。所有Pthreads函数都是成功时返回0，出错时返回正值，该值与传统UNIX系统调用设置给<code>errno</code>的值相同。</p>
<p>　　因为多线程程序中对<code>errno</code>的每次引用都会带来函数调用的开销，所以之后的示例程序不会直接将Pthreads函数的返回值赋值给<code>errno</code>。相反，会使用中间变量和<code>errExitEN()</code>等诊断函数
(见3.4.1)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> *thread;</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">s = pthread_create(&amp;thread, <span class="literal">NULL</span>, func, &amp;arg);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译多线程程序">29.1.4 编译多线程程序</h4>
<p>　　对于Linux，使用Pthreads
API的程序在编译时必须带有选项<code>cc –pthread</code>，该选项具有以下作用：</p>
<p>　　●
定义预处理器宏<code>_REENTRANT</code>，这会公开一些可重入函数。</p>
<p>　　● 程序会与库libpthread一起链接
(等同于<code>-lpthread</code>)。</p>
<p>　　实际上，编译多线程程序的选项因UNIX实现 (和编译器)
而异。Tru64等UNIX实现与Linux相同，而Solaris和HP-UX使用的是<code>cc –mt</code>。</p>
<h3 id="线程创建">29.2 线程创建</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_create()</code>会创建1个新线程，新线程从调用参数<code>start</code>指向的函数开始，并且会带有参数<code>arg</code>。调用<code>pthread_create()</code>的线程会继续执行
(这与系统调用<code>clone()</code>的glibc包装函数的行为相同)。</p>
<p>　　参数<code>arg</code>声明为<code>void *</code>，这表示可以传递任何类型的对象。<code>arg</code>通常会指向全局或堆变量，有时也会被指定为<code>NULL</code>。若需要传递多个参数，则可以将<code>arg</code>指向结构体，该结构体的成员就是这些参数。通过类型转换，甚至可以将<code>arg</code>指定为<code>int</code>。<code>start</code>指向的函数的返回值也是<code>void *</code>，所以它可以像<code>arg</code>那样使用。</p>
<p>　　严格来说，C标准并未定义将<code>void *</code>转换为<code>int</code>以及将<code>int</code>转换为<code>void *</code>的结果。但是，大多数C编译器允许这些操作，并且会产生预期的结果。</p>
<p>　　参数<code>thread</code>指向<code>pthread_t</code>类型的缓冲区，在<code>pthread_create()</code>返回之前，会将该线程的ID复制到该缓冲区中
(该ID用于<span
style="background-color: yellow">区分属于同一进程的不同线程</span>，可以在后续的Pthreads调用中引用该线程)。SUSv3明确规定，在新线程开始执行之前，实现无需初始化<code>thread</code>指向的缓冲区，这表示新线程可能在<code>pthread_create()</code>返回之前开始执行。若新线程需要获取自己的ID，则必须调用<code>pthread_self()</code>。</p>
<p>　　参数<code>attr</code>指向<code>pthread_attr_t</code>对象，用于指定新线程的各种属性。若<code>attr</code>为<code>NULL</code>，则创建线程时将使用默认属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> thr;</span><br><span class="line"><span class="type">pthread_attr_t</span> attr;</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">s = pthread_attr_init(&amp;attr); <span class="comment">/* 初始化为默认值 */</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_attr_init&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_attr_setdetachstate&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = pthread_create(&amp;thr, &amp;attr, threadFunc, (<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = pthread_attr_destroy(&amp;attr); <span class="comment">/* 不再需要 */</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_attr_destroy&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了线程属性结构体的用法。首先，将线程属性结构体初始化为默认值
(第5~9行) 并设置分离状态 (第11~15行)。然后，使用该结构体创建线程
(第17~21行)。一旦线程创建完成，该结构体不再需要，所以将其销毁
(第23~27行)。</p>
<p>　　在调用<code>pthread_create()</code>后，程序无法保证下一个将被调度使用CPU的线程是哪一个
(对于多处理器系统，可以有多个线程同时在不同的CPU上执行)。</p>
<h3 id="线程终止">29.3 线程终止</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_exit()</code>会终止调用线程。参数<code>retval</code>用于指定返回值，其他线程可以通过<code>pthread_join()</code>来获取该返回值。</p>
<p>　　调用<code>pthread_exit()</code>等同于在线程启动函数中执行返回，不同的是<code>pthread_exit()</code>可以由线程启动函数调用的函数调用。</p>
<p>　　<code>retval</code>指向的值不应该位于栈中，因为线程终止后栈会被回收。同样，指定给线程启动函数的<code>return</code>语句的值也不应该位于栈中。</p>
<p>　　若主线程调用<code>pthread_exit()</code>
(而非<code>exit()</code>或<code>return</code>语句)，则其他线程会继续执行。</p>
<h3 id="线程id">29.4 线程ID</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用线程的线程ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>; <span class="comment">/* 若t1和t2相等，则返回非0值；否则，返回0 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_self()</code>会返回调用线程的线程ID。函数<code>pthread_equal()</code>会判断线程ID<code>t1</code>和<code>t2</code>是否相对。</p>
<p>　　<code>pthread_equal()</code>是必要的，因为<code>pthread_t</code>必须被视为不透明数据。SUSv3不要求<code>pthread_t</code>被实现为标量类型。对于Linux，该数据类型定义为<code>unsigned long</code>。但是，对于有些UNIX实现，该数据类型可能定义为指针或结构体
(对于NPTL，<code>pthread_t</code>实际上是已经转换为<code>unsigned long</code>的指针)。</p>
<p>　　对于Linux线程实现，线程ID在进程之间是唯一的，但有些UNIX实现并非如此。SUSv3明确规定，应用程序不应该使用同一线程ID来识别不同进程中的线程。SUSv3还规定，在终止的线程被<code>pthread_join()</code>合并或分离线程终止后，线程ID可以重用。</p>
<p>　　POSIX线程ID不同于特定于Linux的系统调用<code>gettid()</code>返回的线程ID。POSIX线程ID由线程实现分配和维护。<code>gettid()</code>返回的线程ID是由内核分配的整数
(与进程ID类似)。对于Linux
NPTL线程实现，尽管每个POSIX线程有唯一的内核线程ID，但应用程序通常不需要知道该ID
(若应用程序依赖于该ID，则会导致其无法被移植)。</p>
<h3 id="合并终止的线程">29.5 合并终止的线程</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_join()</code>会等待线程ID为<code>thread</code>的线程终止，该操作称为<strong>合并</strong>。若目标线程已终止，则该函数会立即返回。</p>
<p>　　若参数<code>retval</code>不为<code>NULL</code>，则它会收到终止的线程的返回值，即线程执行返回或调用<code>pthread_exit()</code>时指定的值。</p>
<p>　　调用<code>pthread_join()</code>时将<code>thread</code>指定为已合并的线程的线程ID会导致无法预测的行为
(例如，将随后创建的重用该ID的新线程合并)。</p>
<p>　　若线程未分离，则必须通过<code>pthread_join()</code>来合并它。若不这样做，则线程终止后会转换为僵尸线程。除了浪费系统资源之外，若积累了足够多的僵尸线程，则会导致无法创建新线程。</p>
<p>　　<code>pthread_join()</code>对线程执行的操作与<code>waitpid()</code>对进程执行的操作类似，但存在以下主要区别：</p>
<p>　　●
线程是相互对等的。任何线程都可以调用<code>pthread_join()</code>来合并进程中的其他线程
(例如，若线程A创建了线程B，线程B创建了线程C，则线程A可以合并线程C，反之亦然)。这不同于进程之间的层级关系。当父进程通过<code>fork()</code>创建子进程后，只有父进程能够通过<code>waitpid()</code>等待子进程。</p>
<p>　　● 必须明确指定待合并的线程
(对于进程，可以通过<code>waitpid(-1. &amp;status, options)</code>来等待任意进程)，并且也无法进行非阻塞合并
(对于进程，可以通过指定标志<code>WNOHANG</code>来进行非阻塞等待)。此外，也无法实现类似条件变量的功能。</p>
<p>　　<code>pthread_join()</code>只能与指定线程合并是故意的，其理念是线程应该仅与
"已知" 的线程合并。"与任意线程合并"
操作的问题在于线程之间没有层级，这表示该操作可以与任何线程合并，包括由库函数私自创建的线程。因此，库函数将无法合并线程来获取其状态，并且会错误地尝试合并已合并的线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* simple_thread.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = (<span class="type">char</span> *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1;</span><br><span class="line">    <span class="type">void</span> *res;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from main()\n&quot;</span>);</span><br><span class="line">    s = pthread_join(t1, &amp;res);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned %ld\n&quot;</span>, (<span class="type">long</span>)res);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何创建和合并线程。</p>
<h3 id="分离线程">29.6 分离线程</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　线程默认处于<span
style="background-color: yellow">可合并</span>状态，这表示当线程终止时，其他线程可以通过<code>pthread_join()</code>来获取其返回状态。有时，可能只需要系统在线程终止时自动清理并删除线程。为此，可以通过调用<code>pthread_detach()</code>并将参数<code>thread</code>指定为线程ID来将线程标记为<span
style="background-color: yellow">分离</span>状态。一旦如此，将无法通过<code>pthread_join()</code>来获取其返回状态，并且该线程无法再回到可合并状态。</p>
<p>　　线程可以调用<code>pthread_detach(pthread_self())</code>来分离自己。</p>
<p>　　分离线程依然会受到其他线程调用<code>exit()</code>或主线程返回的影响。对于这些情况，进程的所有线程都会立即终止，无论处于可合并状态还是分离状态。换句话说，<code>pthread_detach()</code>仅控制线程终止后的发生的事情，而非线程如何
(或何时) 终止。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第26章 监控子进程</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_26/</url>
    <content><![CDATA[<h3 id="等待子进程">26.1 等待子进程</h3>
<p>　　对于多进程应用程序，父进程可能需要知道子进程何时终止及其原因。<code>wait()</code>等系统调用提供了这个功能。</p>
<h4 id="wait">26.1.1 <code>wait()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>; <span class="comment">/* 返回终止的子进程的进程ID，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>wait()</code>会执行以下步骤：</p>
<p>　　1)
若调用<code>wait()</code>时调用进程没有之前未等待的终止的子进程，则调用进程会阻塞，直到某个子进程终止。若调用<code>wait()</code>时调用进程有之前未等待的终止的子进程，则会立即返回。</p>
<p>　　2)
若<code>status</code>不为<code>NULL</code>，则子进程如何终止的相关信息会存储在该参数指向的缓冲区中。</p>
<p>　　3)
内核将进程CPU时间和资源使用统计添加到调用进程的所有子进程的运行总计中。</p>
<p>　　4) <code>wait()</code>将终止的子进程的进程ID作为结果返回。</p>
<p>　　当出错时，<code>wait()</code>会返回-1。可能的错误之一是调用进程没有之前未等待的子进程，这会导致将<code>errno</code>设置为<code>ECHILD</code>。</p>
<p>　　SUSv3没有说明存在多个之前未等待的终止的子进程时<code>wait()</code>返回子进程的进程ID的顺序，该顺序因实现而异
(甚至可能因Linux内核版本而异)。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* multi_wait.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span> <span class="comment">/* 函数currTime()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numDead;    <span class="comment">/* 迄今为止已等待的子进程的数量 */</span></span><br><span class="line">    <span class="type">pid_t</span> childPid; <span class="comment">/* 等待的子进程的进程ID */</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s sleep-time...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为每个命令行参数创建1个子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (fork())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程睡眠一段时间并终止 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s] child %d started with PID %ld, sleeping %s seconds\n&quot;</span>,</span><br><span class="line">                   currTime(<span class="string">&quot;%T&quot;</span>), j, (<span class="type">long</span>)getpid(), argv[j]);</span><br><span class="line">            sleep(getInt(argv[j], GN_NONNEG, <span class="string">&quot;sleep-time&quot;</span>));</span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* 父进程持续循环 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numDead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        childPid = wait(<span class="literal">NULL</span>); <span class="comment">/* 等待所有子进程终止 */</span></span><br><span class="line">        <span class="keyword">if</span> (childPid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == ECHILD)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No more children - bye!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        numDead++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s] wait() returned child PID %ld (numDead=%d)\n&quot;</span>,</span><br><span class="line">               currTime(<span class="string">&quot;%T&quot;</span>), (<span class="type">long</span>)childPid, numDead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>wait()</code>的用法。该程序会为每个命令行参数创建1个子进程，每个子进程都睡眠对应的命令行参数指定的秒数并终止。当所有子进程都创建完成后，父进程会循环调用<code>wait()</code>来等待所有子进程终止。</p>
<h4 id="waitpid">26.1.2 <code>waitpid()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>; <span class="comment">/* 返回终止的子进程的进程ID或0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　对于系统调用<code>waitpid()</code>，参数<code>pid</code>用于指定等待的子进程。</p>
<p>　　●
若<code>pid</code>大于0，则等待进程ID为<code>pid</code>的子进程。</p>
<p>　　● 若<code>pid</code>等于0，则等待与调用进程 (父进程)
属于同一进程组的所有子进程。</p>
<p>　　●
若<code>pid</code>等于-1，则等待所有子进程。调用<code>waitpid(-1, &amp;status, 0)</code>等同于调用<code>wait(&amp;status)</code>。</p>
<p>　　●
若<code>pid</code>小于-1，则等待进程组ID为<code>pid</code>的绝对值的进程组中的所有子进程。</p>
<p>　　若调用进程没有匹配<code>pid</code>的子进程，则<code>waitpid()</code>会返回-1，并将<code>error</code>设置为<code>ECHILD</code>。</p>
<p>　　参数<code>status</code>与<code>wait()</code>的参数<code>status</code>相同。</p>
<p>　　参数<code>options</code>是位掩码，可以包含标志<code>WUNTRACED</code>、<code>WCONTINUED</code>和<code>WNOHANG</code>中的任意个标志
(或运算<code>|</code>)。</p>
<p>　　●
<code>WUNTRACED</code>表示除了返回子进程如何终止的相关信息之外，还会在子进程被信号停止返回信息。</p>
<p>　　●
<code>WCONTINUED</code>表示还返回被信号<code>SIGCONT</code>恢复的停止的子进程的相关信息
(Linux 2.6.10及以上版本) 。</p>
<p>　　●
<code>WNOHANG</code>表示当<code>pid</code>指定的子进程的状态未发生改变时，立即返回
(而非阻塞)。此时，<code>waitpid()</code>会返回0。</p>
<p>　　在SUSv3对<code>waitpid()</code>的描述中，标志<code>WUNTRACED</code>的名称是该标志源于BSD的历史产物。对于BSD，进程可以2种方式停止：作为被系统调用<code>ptrace()</code>跟踪的结果而停止或被信号停止
(即未被跟踪)。当子进程被<code>ptrace()</code>跟踪时，任何信号
(除了<code>SIGKILL</code>)
的到达都会导致子进程停止，所以父进程会收到信号<code>SIGCHLD</code>。无论子进程是否忽略信号，都不会影响这种行为。但是，当子进程阻塞信号时，它不会停止
(除非收到的信号是<code>SIGSTOP</code>，因为该信号的处理方式无法被修改)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* child_status.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_wait_status.h&quot;</span> <span class="comment">/* 函数printWaitStatus()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [exit-status]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程: 以指定的状态终止或循环等待信号 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child started with PID = %ld\n&quot;</span>, (<span class="type">long</span>)getpid());</span><br><span class="line">        <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(getInt(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;exit-status&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;)</span><br><span class="line">            &#123;</span><br><span class="line">                pause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程: 循环等待子进程，直到被信号中断或子进程终止 */</span></span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            childPid = waitpid(<span class="number">-1</span>, &amp;status, WUNTRACED</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WCONTINUED <span class="comment">/* 较旧的Linux版本未提供该标志 */</span></span></span><br><span class="line">                                                | WCONTINUED</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (childPid == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 以十六进制打印状态 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;waitpid() returned: PID=%ld; status=0x%04x (%d,%d)\n&quot;</span>,</span><br><span class="line">                   (<span class="type">long</span>)childPid, (<span class="type">unsigned</span> <span class="type">int</span>)status, status &gt;&gt; <span class="number">8</span>, status &amp; <span class="number">0xff</span>);</span><br><span class="line">            printWaitStatus(<span class="literal">NULL</span>, status);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status) || WIFSIGNALED(status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>waitpid()</code>的用法。</p>
<h4 id="等待状态值">26.1.3 等待状态值</h4>
<p>　　<code>wait()</code>和<code>waitpid()</code>通过参数<code>status</code>返回的信息用于区分子进程发生的事件：</p>
<p>　　● 子进程调用<code>_exit()</code> (或<code>exit()</code>)。</p>
<p>　　● 子进程被未被处理的信号终止。</p>
<p>　　●
子进程被信号停止，并且调用<code>waitpid()</code>时指定了标志<code>WUNTRACED</code>。</p>
<p>　　●
停止的子进程被信号<code>SIGCONT</code>恢复，并且调用<code>waitpid()</code>时指定了标志<code>WCONTINUED</code>。</p>
<p>　　这里使用术语<strong>等待状态</strong>来表示以上事件。术语<strong>终止状态</strong>表示前2个事件
(对于shell，可以通过变量<code>$?</code>来获取最后执行的命令的终止状态)。</p>
<p>　　尽管<code>status</code>定义为<code>int</code>，但只有低16位才是实际使用的位。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_26/value_returned_in_the_status_argument_of_wait_and_waitpid.svg" class="">
<p>　　上图展示了Linux/x86-32的等待状态值的布局。但是，SUSv3没有说明该值的布局，甚至没有要求低16位是实际使用的位。为此，头文件<code>sys/wait.h</code>中定义了一系列用于解析等待状态值的标准宏。当将以下宏应用于等待状态值时，只有1个宏会返回真
(这里的<code>status</code>是整数值，而非指向整数的指针)：</p>
<p>　　●
<code>WIFEXITED(status)</code>只会在子进程正常终止时返回真。在这种情况下，该宏会返回子进程的终止状态
(但父进程只能获取子进程的终止状态值的低8位)。</p>
<p>　　●
<code>WIFSIGNALED(status)</code>只会在子进程被信号终止时返回真。在这种情况下，该宏会返回导致子进程终止的信号的编号。此外，宏<code>WCOREDUMP(status)</code>可用于判断子进程是否会生成核心转储文件
(若会生成，则返回真)。SUSv3没有说明宏<code>WCOREDUMP(status)</code>，但大多数UNIX实现都提供了该宏。</p>
<p>　　●
<code>WIFSTOPPED(status)</code>只会在子进程被信号停止时返回真。在这种情况下，该宏会返回导致子进程停止的信号的编号。</p>
<p>　　●
<code>WIFCONTINUED(status)</code>只会在停止的子进程被信号<code>SIGCONT</code>恢复时返回真
(Linux 2.6.10及以上版本)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* print_wait_status.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明会在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_wait_status.h&quot;</span> <span class="comment">/* printWaitStatus()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解析等待状态值并打印相关信息 (该函数调用了非异步信号安全函数printf())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @param status 等待状态值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printWaitStatus</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child exited, status=%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child killed by signal %d (%s)&quot;</span>,</span><br><span class="line">               WTERMSIG(status), strsignal(WTERMSIG(status)));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WCOREDUMP <span class="comment">/* 有些系统未提供该宏 */</span></span></span><br><span class="line">        <span class="keyword">if</span> (WCOREDUMP(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; (core dumped)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child stopped by signal %d (%s)\n&quot;</span>,</span><br><span class="line">               WSTOPSIG(status), strsignal(WSTOPSIG(status)));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIFCONTINUED <span class="comment">/* 较旧的Linux版本和有些UNIX实现未提供该宏 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFCONTINUED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child continued\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;what happened to this child? (status=%x)\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>printWaitStatus()</code>会通过上述宏来解析等待状态值。</p>
<h4 id="在信号处理函数中处理进程终止">26.1.4
在信号处理函数中处理进程终止</h4>
<p>　　有些信号的默认处理方式是终止进程，而进程终止前可能需要执行特定的清理操作。为此，可以先注册信号处理函数来捕获信号，然后执行清理操作，最后终止进程。若子进程需要通知父进程自己因为信号而终止，则子进程的信号处理函数可以先将信号的处理方式恢复到默认，然后再次向自己发送同一信号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 执行清理操作 */</span></span><br><span class="line"></span><br><span class="line">    signal(sig, SIG_DFL); <span class="comment">/* 将信号的处理方式恢复到默认 */</span></span><br><span class="line">    raise(sig);           <span class="comment">/* 再次发送同一信号给自己 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="系统调用waitid">26.1.5 系统调用<code>waitid()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waitid</span><span class="params">(<span class="type">idtype_t</span> idtype, <span class="type">id_t</span> id, <span class="type">siginfo_t</span> *infop, <span class="type">int</span> options)</span>; <span class="comment">/* 成功或指定了WNOHANG但没有可等待的子进程时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　对于系统调用<code>waitid()</code>，参数<code>idtype</code>和<code>id</code>用于指定等待的子进程。</p>
<p>　　●
若<code>idtype</code>是<code>P_ALL</code>，则等待所有子进程。此时，<code>ìd</code>会被忽略。</p>
<p>　　●
若<code>idtype</code>是<code>P_PID</code>，则等待进程ID为<code>id</code>的子进程。</p>
<p>　　●
若<code>idtype</code>是<code>P_PGID</code>，则等待进程组ID为<code>id</code>的所有子进程。在这种情况下，<code>id</code><span
style="background-color: yellow">不能</span>为0。</p>
<p>　　若调用进程没有匹配<code>idtype</code>和<code>id</code>的子进程，则<code>waitid()</code>会返回-1，并将<code>error</code>设置为<code>ECHILD</code>。</p>
<p>　　参数<code>options</code><span
style="background-color: yellow">至少</span>包含标志<code>WEXITED</code>、<code>WSTOPPED</code>和<code>WCONTINUED</code>中的1个标志，可以包含标志<code>WNOHANG</code>和<code>WNOWAIT</code>中的任意个标志
(或运算<code>|</code>)。</p>
<p>　　● <code>WEXITED</code>表示等待子进程终止
(无论正常终止或异常终止)。</p>
<p>　　● <code>WSTOPPED</code>表示等待子进程被信号停止。</p>
<p>　　●
<code>WCONTINUED</code>表示等待停止的子进程被信号<code>SIGCONT</code>恢复。</p>
<p>　　●
<code>WNOHANG</code>表示若子进程的状态未发生改变或调用<code>waitid()</code>时子进程的状态已经发生改变，则会立即返回0。对于前者，Linux和有些UNIX实现会将<code>infop</code>指向的结构体<code>siginfo_t</code>的所有成员都设置为0，但SUSv3没有要求这种行为
(未来对SUSv4的修改可能会增加1个要求：在这种情况下，结构体<code>siginfo_t</code>的成员<code>si_pid</code>和<code>si_signo</code>会被设置为0)。对于后者，子进程的相关信息会通过<code>infop</code>指向的结构体<code>siginfo_t</code>返回。在保证可移植性的情况下，区分<code>infop</code>指向的结构体<code>siginfo_t</code>的所有成员是否会被设置为0的唯一方法是在调用<code>waitid()</code>前将这些成员都设置为0。</p>
<p>　　●
<code>WNOWAIT</code>表示当子进程的等待条件触发后，子进程将仍处于可等待状态
(在这种情况下，子进程通常会退出可等待状态)。</p>
<p>　　当<code>waitid()</code>成功时，会返回0，并且参数<code>infop</code>指向的结构体<code>siginfo_t</code>中会包含子进程终止的相关信息，该结构体的成员<code>si_code</code>、<code>si_pid</code>、<code>si_signo</code>、<code>si_status</code>和<code>si_uid</code>会被设置。</p>
<p>　　● 成员<code>si_code</code>会包含<code>CLD_EXITED</code>
(表示子进程通过调用<code>_exit()</code>终止)、<code>CLD_KILLED</code>
(表示子进程被信号终止)、<code>CLD_STOPPED</code> (表示子进程被信号停止)
或<code>CLD_CONTINUED</code>
(表示停止的子进程被信号<code>SIGCONT</code>恢复)。</p>
<p>　　● 成员<code>si_pid</code>会包含状态改变的子进程的进程ID。</p>
<p>　　● 成员<code>si_signo</code>总是会包含<code>SIGCHLD</code>。</p>
<p>　　●
成员<code>si_status</code>会包含子进程的终止状态或导致子进程停止、恢复或终止的信号的编号。</p>
<p>　　●
成员<code>si_uid</code>会包含子进程的实际用户ID。大多数UNIX实现不会设置该成员。</p>
<p>　　对于Solaris，还会将成员<code>si_stime</code>和<code>si_utime</code>分别设置为子进程的系统CPU时间和用户CPU时间。SUSv3不要求<code>waitid()</code>设置这2个成员。</p>
<h4 id="系统调用wait3和wait4">26.1.6
系统调用<code>wait3()</code>和<code>wait4()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE <span class="comment">/* 对于wait3()，也可以#define _XOPEN_SOURCE 500 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回子进程的进程ID，出错时返回-1 */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait3</span><span class="params">(<span class="type">int</span> *status, <span class="type">int</span> options, <span class="keyword">struct</span> rusage *rusage)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait4</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options, <span class="keyword">struct</span> rusage *rusage)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>wait3()</code>和<code>wait4()</code>与<code>waitpid()</code>类似。主要的语义区别在于<code>wait3()</code>和<code>wait4()</code>会通过参数<code>rusage</code>指向的结构体<code>rusage</code>返回终止的子进程的资源使用信息
(包括使用的CPU时间和内存管理统计)。这2个系统调用的名称中的数字表示参数的数量。</p>
<p>　　当不使用<code>rusage</code>时，调用<code>wait3()</code>等同于调用<code>waitpid(-1, &amp;status, options)</code>，调用<code>wait4()</code>等同于调用<code>waitpid(pid, &amp;status, options)</code>。</p>
<p>　　对于有些UNIX实现，这2个系统调用只会返回终止的子进程的资源使用信息。对于Linux，当参数<code>options</code>指定了标志<code>WUNTRACED</code>时，还可以返回停止的子进程的资源使用信息。</p>
<p>　　这2个系统调用都源于BSD，SUSv3没有标准化这2个系统调用
(SUSv2详细说明了<code>wait3()</code>，并将其标记为LEGACY)，但现在的大多数UNIX实现都提供了这2个系统调用。</p>
<h3 id="孤儿进程和僵尸进程">26.2 孤儿进程和僵尸进程</h3>
<p>　　父进程和子进程的生命周期通常不同。</p>
<p>　　●
若父进程先于子进程终止，则子进程会转换为<strong>孤儿进程</strong>。孤儿进程会被进程<code>init</code>收养。</p>
<p>　　●
若子进程在父进程调用<code>wait()</code>之前终止，则子进程会转换为<strong>僵尸进程</strong>，这表示子进程占用的大部分资源都已经被系统释放。僵尸进程唯一剩下的部分是内核的进程表中的1个条目，该条目记录着僵尸进程的进程ID、终止状态和资源使用统计等信息。</p>
<p>　　僵尸进程<span
style="background-color: yellow">不受任何信号的影响</span>，这保证了父进程最终可以调用<code>wait()</code>。</p>
<p>　　当父进程调用<code>wait()</code>时，内核会删除僵尸进程，因为关于僵尸进程的剩余信息将不再需要。若父进程直接终止而不调用<code>wait()</code>，则进程<code>init</code>会收养子进程和自动调用<code>wait()</code>
(删除僵尸进程)。</p>
<p>　　若父进程创建了子进程，但未能调用<code>wait()</code>，则内核的进程表中记录着僵尸进程的相关信息的条目会一直存在。当内核的进程表充斥着大量此类条目时，可能会导致无法创建新进程。由于僵尸进程不受信号的影响，所以删除这些僵尸进程唯一的方法是终止其父进程
(然后，进程<code>init</code>收养僵尸进程并调用<code>wait()</code>)。</p>
<p>　　这些语义对父进程长期存在的应用程序 (例如，网络服务器和shell)
很重要。对于这些应用程序，父进程需要调用<code>wait()</code>来确保终止的子进程会从系统中删除
(而非转换为长期存在的僵尸进程)。父进程可以在<code>SIGCHLD</code>处理函数中调用<code>wait()</code>。</p>
<h3 id="信号sigchld">26.3 信号<code>SIGCHLD</code></h3>
<p>　　当子进程终止时，父进程会收到信号<code>SIGCHLD</code>。该信号默认会被忽略，但可以为该信号注册处理函数，并在其中调用<code>wait()</code>
(或类似的系统调用) 来回收僵尸进程。</p>
<h4 id="注册sigchld处理函数">26.3.1
注册<code>SIGCHLD</code>处理函数</h4>
<p>　　由于信号<code>SIGCHLD</code>是标准信号，所以不会排队。此外，调用信号处理函数期间对应的信号默认会被阻塞
(除非通过<code>sigaction()</code>注册信号处理函数时指定了标志<code>SA_NODEFER</code>)。因此，假设在调用<code>SIGCHLD</code>处理函数期间其他多个子进程相继终止，尽管信号<code>SIGCHLD</code>会多次被生成，但只会到达1次，这可能会导致仅回收部分僵尸进程。</p>
<p>　　为了解决这个问题，可以在<code>SIGCHLD</code>处理函数中循环调用<code>waitpid()</code>并指定标志<code>WNOHANG</code>，直到没有可回收的僵尸进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* multi_sigchld.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_wait_status.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> numLiveChildren = <span class="number">0</span>; <span class="comment">/* 已创建但未被回收的子进程的数量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数printf()、printWaitStatus()和currTime()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigchldHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status, savedErrno;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    savedErrno = errno; <span class="comment">/* 防止errno被修改 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s handler: Caught SIGCHLD\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> ((childPid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s handler: Reaped child %ld - &quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), (<span class="type">long</span>)childPid);</span><br><span class="line">        printWaitStatus(<span class="literal">NULL</span>, status);</span><br><span class="line">        numLiveChildren--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childPid == <span class="number">-1</span> &amp;&amp; errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        errMsg(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>); <span class="comment">/* 故意延长处理函数的执行时间 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s handler: returning\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>));</span><br><span class="line"></span><br><span class="line">    errno = savedErrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j, sigCnt;</span><br><span class="line">    <span class="type">sigset_t</span> blockMask, emptyMask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s child-sleep-time...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    sigCnt = <span class="number">0</span>;</span><br><span class="line">    numLiveChildren = argc - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = sigchldHandler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 阻塞信号SIGCHLD，防止该信号在父进程开始sigsuspend()循环前到达 */</span></span><br><span class="line">    sigemptyset(&amp;blockMask);</span><br><span class="line">    sigaddset(&amp;blockMask, SIGCHLD);</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;blockMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (fork())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程：睡眠并终止 */</span></span><br><span class="line">            sleep(getInt(argv[j], GN_NONNEG, <span class="string">&quot;child-sleep-time&quot;</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s Child %d (PID=%ld) exiting\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), j, (<span class="type">long</span>)getpid());</span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* 父进程：循环创建子进程 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程：循环等待信号SIGCHLD，直到所有子进程都被回收 */</span></span><br><span class="line">    sigemptyset(&amp;emptyMask);</span><br><span class="line">    <span class="keyword">while</span> (numLiveChildren &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sigsuspend(&amp;emptyMask) == <span class="number">-1</span> &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigsuspend&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigCnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s All %d children have terminated; SIGCHLD was caught %d times\n&quot;</span>,</span><br><span class="line">           currTime(<span class="string">&quot;%T&quot;</span>), argc - <span class="number">1</span>, sigCnt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何通过<code>SIGCHLD</code>处理函数来回收僵尸进程。<code>SIGCHLD</code>处理函数会打印回收的子进程的进程ID和等待状态。为了展示调用<code>SIGCHLD</code>处理函数期间信号<code>SIGCHLD</code>不会排队，<code>SIGCHLD</code>处理函数会调用<code>sleep()</code>来延长执行时间
(第15~39行)。主函数会先注册<code>SIGCHLD</code>处理函数和阻塞信号<code>SIGCHLD</code>
(第57~71行)。然后，为每个命令行参数创建1个子进程，每个子进程都会睡眠对应的命令行参数指定的秒数并终止
(第73~88行)。最后，循环调用<code>sigsuspend()</code>来等待信号<code>SIGCHLD</code>
(第91~99行)。</p>
<h4 id="忽略信号sigchld">26.3.2 忽略信号<code>SIGCHLD</code></h4>
<p>　　显式地将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>会导致子进程后续终止时立即被删除
(而非转换为僵尸进程)。对于这种情况，由于内核的进程表中记录子进程的相关信息的条目已被删除，所以后续对该子进程调用<code>wait()</code>
(或类似的系统调用) 不会返回任何信息。</p>
<p>　　对于Linux和很多UNIX实现，将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>不会影响现有的僵尸进程
(所以这些僵尸经常还是需要通过常规方法回收)。对于某些其他UNIX实现
(例如，Solaris
8)，将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>会删除现有的僵尸进程。</p>
<p>　　信号<code>SIGCHLD</code>的<code>SIG_IGN</code>语义有悠久的历史
(源于System
V)。SUSv3详细说明了这里的行为，但POSIX.1没有说明这里的行为。因此，对于部分较旧的UNIX实现，忽略信号<code>SIGCHLD</code>不会影响僵尸进程的产生。防止僵尸进程产生的唯一完全可移植方法是调用<code>wait()</code>
(或类似的系统调用)。</p>
<p>　　SUSv3规定，若将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>，则子进程的资源使用信息会被丢弃，并且父进程调用<code>getrusage()</code>并指定标志<code>RUSAGE_CHILDREN</code>时返回的信息中不会包含这些信息。此外，<code>times()</code>返回的结构体<code>tms</code>也不会包含子进程使用的CPU时间。但是，对于内核2.6.9之前的Linux版本，子进程使用的CPU时间和资源会被记录
(<code>getrusage()</code>和<code>times()</code>返回的信息会包含这些信息)。</p>
<p>　　SUSv3规定，若将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>，并且父进程没有未回收的僵尸子进程，则调用<code>wait()</code>和<code>waitpid()</code>会阻塞，直到父进程的所有子进程都终止，然后这些调用会导致错误<code>ECHILD</code>。Linux
2.6遵守该规范。但是，对于Linux
2.4及以下版本，<code>wait()</code>只会阻塞到下一次子进程终止，然后返回子进程的进程ID和状态
(行为与未将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>相同)。</p>
<p>　　SUSv3详细说明了标志<code>SA_NOCLDWAIT</code>
(见20.10)，其功能与将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>相同。两者主要的区别在于当调用<code>sigaction()</code>并指定了标志<code>SA_NOCLDWAIT</code>时，SUSv3没有说明子进程终止时是否为父进程生成信号<code>SIGCHLD</code>。因此，在这种情况下，是否为父进程生成信号<code>SIGCHLD</code>因实现而异。对于Linux和有些UNIX实现，会生成该信号。对于其他UNIX，不会生成该信号。</p>
<p>　　Linux提供了等同于信号<code>SIGCHLD</code>的信号<code>SIGCLD</code>。两者同时存在是因为历史原因，信号<code>SIGCHLD</code>源于BSD，该名称随后被POSIX采用
(POSIX很大程度上标准化了BSD信号模型)。信号<code>SIGCLD</code>源于System
V，其语义略有不同。两者的主要区别在于将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>的后续处理。</p>
<p>　　● 对于历史上的BSD实现
(或一些同时代的实现)，系统会继续将未等待的终止的子进程转换为僵尸进程。</p>
<p>　　● 对于System V，通过<code>signal()</code>
(而非<code>sigaction()</code>)
来忽略信号<code>SIGCLD</code>会导致未等待的终止的子进程不会转换为僵尸进程。</p>
<p>　　最初的POSIX.1没有说明忽略<code>SIGCHLD</code>的结果，所以System
V的行为是允许的。如今，System V的行为已经成为了SUSv3的一部分
(但使用的信号名是<code>SIGCHLD</code>)。现代System
V衍生实现将<code>SIGCHLD</code>作为标准名，但仍然提供了<code>SIGCLD</code>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第27章 程序执行</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_27/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>; <span class="comment">/* 成功时不会返回，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　对于系统调用<code>execve()</code>，参数<code>pathname</code>是待加载到进程内存的新程序的路径名
(绝对路径名或相对于调用进程的当前工作目录的相对路径名)。</p>
<p>　　参数<code>argv</code>是传递给新程序的命令行参数
(对应C主函数的参数<code>argv</code>)，该参数指向1个字符串数组
(第1个元素是<code>pathname</code>的基础部分，最后1个元素是<code>NULL</code>)。</p>
<p>　　参数<code>envp</code>是传递给新程序的环境列表，该参数指向1个字符串数组
(数组元素的格式为<code>name=value</code>，最后1个元素是<code>NULL</code>)。</p>
<p>　　当调用<code>execve()</code>后，调用进程的进程ID (和少量进程属性)
保持不变，旧程序会被丢弃，并且进程的栈、堆和数据会被新程序的栈、堆和数据替换。在执行各种C库运行时启动代码和程序初始化代码后，新程序开始执行主函数。<code>execve()</code>通常用于通过<code>fork()</code>创建的子进程。</p>
<p>　　若<code>pathname</code>指定的文件的set-user-ID位
(或set-group-ID位) 已设置，则当文件被执行时进程的有效用户ID (或有效组ID)
会被修改为该文件的所有者的用户ID (或所属组的组ID)。</p>
<p>　　无论<code>pathname</code>指定的文件的set-user-ID位
(或set-group-ID位)
是否设置，<code>execve()</code>都会将进程的有效用户ID和有效组ID复制给保存的set-user-ID和set-group-ID。</p>
<p>　　若<code>execve()</code>成功，则会替换调用进程执行的程序
(不会返回)。若有返回值，则只能是-1，并且会将<code>errno</code>设置为<code>EACCES</code>、<code>ENOENT</code>、<code>ENOEXEC</code>、<code>ETXTBSY</code>或<code>E2BIG</code>。</p>
<p>　　●
<code>EACCES</code>表示<code>pathname</code>指定的文件不是常规文件、没有<code>pathname</code>指定的文件的执行权限、没有<code>pathname</code>的目录部分的某个目录的执行权限或<code>pathname</code>指定的文件所在的文件系统挂载时指定了标志<code>MS_NOEXEC</code>。</p>
<p>　　●
<code>ENOENT</code>表示<code>pathname</code>指定的文件不存在。</p>
<p>　　●
<code>ENOEXEC</code>表示<code>pathname</code>指定的文件被标记为可执行，但其格式不是可识别的可执行格式
(例如，不以<code>#!</code>开头的脚本)。</p>
<p>　　●
<code>ETXTBSY</code>表示<code>pathname</code>指定的文件已经被其他进程打开以进行写入。</p>
<p>　　●
<code>E2BIG</code>表示参数列表和环境列表的总大小超过了上限。</p>
<p>　　若为执行脚本而定义的解释器文件或用于执行程序的ELF解释器存在上述任何情况，则上述错误也会出现。</p>
<p>　　特定于Linux的文件<code>/proc/PID/exe</code>是包含对应进程正在执行的程序的绝对路径名的符号链接。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_execve.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *argVec[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> *envVec[] = &#123;<span class="string">&quot;GREET=salut&quot;</span>, <span class="string">&quot;BYE=adieu&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pathname\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取argv[1]的基础部分 */</span></span><br><span class="line">    argVec[<span class="number">0</span>] = <span class="built_in">strrchr</span>(argv[<span class="number">1</span>], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (argVec[<span class="number">0</span>] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        argVec[<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        argVec[<span class="number">0</span>] = argv[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    argVec[<span class="number">1</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    argVec[<span class="number">2</span>] = <span class="string">&quot;goodbye&quot;</span>;</span><br><span class="line">    argVec[<span class="number">3</span>] = <span class="literal">NULL</span>; <span class="comment">/* 参数列表必须以NULL结尾 */</span></span><br><span class="line"></span><br><span class="line">    execve(argv[<span class="number">1</span>], argVec, envVec);</span><br><span class="line">    errExit(<span class="string">&quot;execve&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>execve()</code>的用法。该程序会为新程序创建命令行参数列表和环境列表，然后将命令行参数作为<code>pathname</code>来调用<code>execve()</code>。</p>
<h3 id="exec库函数">27.1 <code>exec()</code>库函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时不会返回，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/* , (char *) NULL, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/* , (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">          <span class="comment">/* , (char *) NULL */</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>　　这些库函数都是基于<code>execve()</code>，它们之间的主要区别在于指定程序名以及新程序的参数列表和环境列表的方式。</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 30%" />
<col style="width: 28%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>指定程序名的方式 (-, p)</th>
<th>指定参数的方式 (v, l)</th>
<th>指定环境的方式 (e, -)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>execve()</code></td>
<td>路径名</td>
<td>数组</td>
<td>参数<code>envp</code></td>
</tr>
<tr>
<td><code>execle()</code></td>
<td>路径名</td>
<td>列表</td>
<td>参数<code>envp</code></td>
</tr>
<tr>
<td><code>execlp()</code></td>
<td>文件名 + 环境变量<code>PATH</code></td>
<td>列表</td>
<td>调用程序的环境列表</td>
</tr>
<tr>
<td><code>execvp()</code></td>
<td>文件名 + 环境变量<code>PATH</code></td>
<td>数组</td>
<td>调用程序的环境列表</td>
</tr>
<tr>
<td><code>execv()</code></td>
<td>路径名</td>
<td>数组</td>
<td>调用程序的环境列表</td>
</tr>
<tr>
<td><code>execl()</code></td>
<td>路径名</td>
<td>列表</td>
<td>调用程序的环境列表</td>
</tr>
</tbody>
</table>
<p>　　●
大多数<code>exec()</code>函数都是通过路径名来指定待加载的新程序。但是，<code>execlp()</code>和<code>execvp()</code>允许仅指定文件名
(参数<code>filename</code>)，该文件名在环境变量<code>PATH</code>指定的目录下查找
(这是执行shell命令时shell所执行的搜索类型)。为了表示这种操作上的差异，这些函数的名称会包含字母<code>p</code>
(对应环境变量<code>PATH</code>)。若<code>filename</code>包含斜杠<code>/</code>，则不会使用环境变量<code>PATH</code>，相反，该参数会被视为路径名
(绝对路径名或相对路径名)。</p>
<p>　　●
<code>execle()</code>、<code>execlp()</code>和<code>execl()</code>通过多个参数来指定新程序的参数列表，<code>const char *arg, ...</code>可以视为<code>const char *arg0, ..., const char *argn</code>，<code>argn</code>之后的参数必须是<code>(char *) NULL</code>
(表示参数列表的结尾)。对于以这种方式指定新程序的参数列表的<code>exec()</code>函数，其名称会包含字母<code>l</code>。对于通过数组指定新程序的参数列表的<code>exec()</code>函数，其名称会包含字母<code>v</code>。</p>
<p>　　●
<code>execve()</code>和<code>execle()</code>通过参数<code>envp</code>
(最后1个元素是<code>NULL</code>)
来指定新程序的环境列表。其他<code>exec()</code>函数会将调用程序的现有环境列表作为新程序的环境列表。</p>
<p>　　glibc
2.11添加了非标准函数<code>execvpe(file, argv, envp)</code>，该函数与<code>execvp()</code>类似，但该函数通过参数<code>envp</code>来指定新程序的环境列表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_execle.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *envVec[] = &#123;<span class="string">&quot;GREET=salut&quot;</span>, <span class="string">&quot;BYE=adieu&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *filename;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pathname\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取argv[1]的基础部分 */</span></span><br><span class="line">    filename = <span class="built_in">strrchr</span>(argv[<span class="number">1</span>], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (filename != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        filename++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        filename = argv[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execle(argv[<span class="number">1</span>], filename, <span class="string">&quot;hello world&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>, envVec);</span><br><span class="line">    errExit(<span class="string">&quot;execle&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>execle()</code>的用法。</p>
<h4 id="环境变量path">27.1.1 环境变量<code>PATH</code></h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$PATH</span></span></span><br><span class="line">/home/mtk/bin:/usr/local/bin:/usr/bin:/bin:.</span><br></pre></td></tr></table></figure>
<p>　　环境变量<code>PATH</code>的值是由冒号<code>:</code>分隔的目录名组成的字符串，这些目录名称为<strong>路径前缀</strong>。路径前缀的长度可以是0，这等同于<code>.</code>
(当前工作目录)，但SUSv3将这种行为标记为过时，所以当前工作目录应该指定为<code>.</code>。</p>
<p>　　登录shell的环境变量<code>PATH</code>的值由特定于用户的系统级shell启动脚本设置。由于子进程会继承父进程的环境列表，所以shell创建的用于执行命令的进程会继承shell的环境列表。</p>
<p>　　若未定义环境变量<code>PATH</code>，则<code>execvp()</code>和<code>execlp()</code>会默认使用<code>.:/usr/bin:/bin</code>。</p>
<p>　　出于安全原因，超级用户账户 (root)
通常会将环境变量<code>PATH</code>设置为不包含当前工作目录，这是为了防止root意外地执行当前工作目录下的文件
(可能由恶意用户故意放置在这里)。对于有些Linux发行版，环境变量<code>PATH</code>的默认值不会包含当前工作目录
(无论特权用户还是非特权用户)。</p>
<p>　　<code>execvp()</code>和<code>execlp()</code>会从环境变量<code>PATH</code>的值指定目录下搜索文件，搜索顺序为从左到右，直到找到匹配的文件。此外，应该尽量避免在set-user-ID或set-group-ID程序中使用<code>execvp()</code>和<code>execlp()</code>
(可能会意外地执行恶意程序)。在实际中，应用程序应该使用安全的目录列表来覆盖环境变量<code>PATH</code>的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_execlp.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pathname\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execlp(argv[<span class="number">1</span>], argv[<span class="number">1</span>], <span class="string">&quot;hello world&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">    errExit(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>execlp()</code>的用法。</p>
<h4 id="fexecve">27.1.2 <code>fexecve()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fexecve</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>; <span class="comment">/* 成功时不会返回，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　从版本2.3.2开始，glibc提供了库函数<code>fexecve()</code>。<code>fexecve()</code>与<code>execve()</code>类似，但通过打开的文件描述符<code>fd</code>来指定新程序
(而非路径名)。</p>
<p>　　<code>fexecve()</code>的理念是允许调用者在执行可执行文件之前验证
(校验和)
其内容。仅仅打开文件来校验内容，然后调用<code>execve()</code>是不够的。因为在这2个步骤之间，文件名或目录名的前缀可能会被替换
(例如，通过修改符号链接的目标)。但是，<code>fexecve()</code>并没有解决这个问题，所以确保文件的权限不会被恶意用户修改。</p>
<h3 id="解释器脚本">27.2 解释器脚本</h3>
<p>　　<strong>解释器</strong>是读取文本形式的命令并执行它们的程序
(例如，各种UNIX
shell以及<code>awk</code>、<code>sed</code>、<code>perl</code>、<code>python</code>和<code>ruby</code>等程序)。除了能够交互式地读取和执行命令之外，解释器通常会提供从文本文件
(称为脚本) 读取和执行命令的功能。</p>
<p>　　只要满足2个条件，UNIX内核就允许以二进制程序文件的执行方式来执行解释器脚本。第1个条件是脚本的执行权限必须已启用，第2个条件是脚本必须以特殊的初始化行开头，该行指定用于执行脚本的解释器的路径名，其格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! interpreter-path [ optional-arg ]</span><br></pre></td></tr></table></figure>
<p>　　解释器脚本必须以<code>#!</code>开头，<code>#!</code>与解释器路径名之间可以有1个空格。环境变量<code>PATH</code><span
style="background-color: yellow">不会</span>用于解析解释器路径名，所以解释器路径名可以是绝对路径名或相对于启动解释器的进程的当前工作目录的相对路径名。此外，还可以指定可选参数，可选参数在解释器路径名之后，并且解释器路径名和可选参数之间有空格。例如，UNIX
shell脚本的第1行通常如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br></pre></td></tr></table></figure>
<p>　　解释器脚本的第1行的可选参数不能包含空格，因为这里的空格处理因UNIX实现而异。对于Linux，可选参数中的空格不会被特殊处理，所以从开头到结尾的所有文本都被视为1个单词。有些UNIX实现处理可选参数中的空格的方式与Linux的相同，而其他UNIX实现则不然。对于版本6.0之前的FreeBSD，可选参数中的空格处理与shell的相同
(将空格视为单词之间的分隔符)；对于6.0及以上版本，FreeBSD的行为与Linux的相同。对于Solaris
8，空格被视为可选参数的结束符 (剩余文本将会被忽略)。</p>
<p>　　解释器脚本的第1行的长度限制因UNIX实现而异。Linux的限制是127个字符
(不包含结尾的换行符，超出的字符会被忽略)，OpenBSD
3.1的限制是64个字符，Tru64 5.1的限制是1024个字符，而有些早期UNIX实现
(例如，SunOS 4) 的限制是32个字符。</p>
<p>　　SUSv3没有要求解释器脚本以<code>#!</code>开头，但大多数UNIX实现都是如此。</p>
<h4 id="解释器脚本的执行">27.2.1 解释器脚本的执行</h4>
<p>　　当<code>execve()</code>检测到指定的文件以<code>#!</code>开头时，会提取剩余文本
(解释器路径名和可选参数) 并使用以下参数列表来执行解释器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interpreter-path [ optional-arg ] script-path arg...</span><br></pre></td></tr></table></figure>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_27/the_argument_list_supplied_to_an_execed_script.svg" class="">
<p>　　<code>interpreter-path</code>和<code>optional-arg</code>取自解释器脚本的第1行
(Linux内核2.2仅将<code>interpreter-path</code>的基础部分作为传递给解释器的第1个参数)，<code>script-path</code>是传递给<code>execve()</code>的路径名，<code>arg...</code>是指定给<code>execve()</code>的参数<code>argv</code>的值
(除了<code>argv[0]</code>)。</p>
<p>　　大多数UNIX
shell和解释器都将<code>#</code>视为注释的起始字符，所以这些解释器在执行脚本时会忽略第1行。</p>
<p>　　当调用<code>exec()</code>执行脚本时，脚本不以<code>#!</code>开头通常会导致出错。但是，<code>execlp()</code>和<code>execvp()</code>有所不同。这2个函数会使用环境变量<code>PATH</code>来获取目录，并在这些目录下搜索待执行的文件。若这2个函数找到了匹配的执行权限已启用的非二进制文件，并且不以<code>#!</code>开头，则会调用shell来解释该文件。对于Linux，这表示此类文件会被解释为以行<code>#!/bin/sh</code>开头。</p>
<h4 id="awk解释器">27.2.2 <code>awk</code>解释器</h4>
<p>　　解释器脚本的第1行中的可选参数可用于指定解释器的命令行参数，这对<code>awk</code>等解释器很有用。</p>
<p>　　<code>awk</code>解释器在20世纪70年代晚期成为了UNIX的一部分。awk是1种弱类型语言，其语法基于C，并且具有丰富的文本处理原语，它的名称取自其开发者的姓名的首字母。awk是JavaScript和PHP等现代脚本语言的祖先。</p>
<p>　　脚本可以通过2种方式提供给<code>awk</code>。第1种方式是将脚本作为<code>awk</code>的第1个命令行参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;script&#x27;</span> input-file...</span></span><br></pre></td></tr></table></figure>
<p>　　第2种方式是使用awk脚本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> longest_line.awk</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/awk</span></span><br><span class="line">length &gt; max &#123; max = length; &#125;</span><br><span class="line">END &#123; print max; &#125;</span><br></pre></td></tr></table></figure>
<p>　　这个awk脚本会打印输出行中最长行的长度。假设需要通过以下方式调用<code>execl()</code>来执行该脚本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execl(<span class="string">&quot;longest_line.awk&quot;</span>, <span class="string">&quot;longest_line.awk&quot;</span>, <span class="string">&quot;input.txt&quot;</span>, (<span class="type">char</span> *) <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>　　该调用会使用以下参数列表调用<code>execve()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/awk longest_line.awk input.txt</span><br></pre></td></tr></table></figure>
<p>　　但是，这种调用<code>execve()</code>的方式会出错，因为<code>awk</code>会将<code>longest_line.awk</code>解释为包含无效<code>awk</code>命令的脚本。为此，需要将awk脚本的第1行的末尾加上选项<code>-f</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/awk -f</span></span><br><span class="line">length &gt; max &#123; max = length; &#125;</span><br><span class="line">END &#123; print max; &#125;</span><br></pre></td></tr></table></figure>
<p>　　现在，<code>execl()</code>调用会使用以下参数列表调用<code>execve()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/awk -f longest_line.awk input.txt</span><br></pre></td></tr></table></figure>
<p>　　这会成功使用脚本<code>longest_line.awk</code>调用<code>awk</code>来处理文件<code>input.txt</code>。</p>
<h3 id="文件描述符和exec">27.3 文件描述符和<code>exec()</code></h3>
<p>　　在默认情况下，调用<code>exec()</code>的程序打开的所有文件描述符在<code>exec()</code>完成后仍然保存打开状态，并且新程序可以使用这些文件描述符。shell通过这个特性来处理它执行的程序的I/O重定向。</p>
<p>　　当用户在终端输入命名<code>ls /tmp &gt; dir.txt</code>后，shell会执行以下步骤：</p>
<p>　　1) 通过<code>fork()</code>创建子进程，子进程也在运行shell的副本
(所以也会有命令的副本)。</p>
<p>　　2) 子shell使用文件描述符1 (标准输出)
打开文件<code>dir.txt</code>以进行输出，这可以通过2种方法完成。第1种方法是子shell关闭文件描述符1并打开文件<code>dir.txt</code>
(<code>open()</code>总是使用可用的最小文件描述符，而文件描述符0处于打开状态，所以文件<code>dir.txt</code>会使用文件描述符1打开)。第2种方法是子shell直接打开<code>dir.txt</code>，然后通过<code>dup2()</code>来将新文件描述符复制给文件描述符1，最后关闭新文件描述符
(因为新文件描述符不再需要)。</p>
<p>　　3)
子shell执行程序<code>ls</code>。<code>ls</code>会将其输出写入到标准输出，即文件<code>dir.txt</code>。</p>
<p>　　这里介绍的步骤简化了一些内容，尤其是shell内置命令
(直接由shell执行的命令)。出于I/O重定向的目的，这些命令必须以不同的方式处理。</p>
<p>　　shell命令被实现为内置命令有2个原因：效率和在shell内获取额外的效果。<code>pwd</code>、<code>echo</code>和<code>test</code>等常用命令足够简单，这些命令被实现为内置命令可以带来可观的效率提升。其他命令被实现为内置命令是为了对shell产生额外的效果——修改shell存储的信息、shell的进程属性或shell进程的执行
(例如，命令<code>cd</code>会修改shell的当前工作目录，所以不能由其他进程执行)。</p>
<p>　　有时，可能需要在调用<code>exec()</code>前关闭特定的文件描述符。这可以通过<code>close()</code>实现，但这种方法存在以下限制：</p>
<p>　　●
文件描述符可能由库函数打开，而这些函数无法强制主函数在调用<code>exec()</code>前关闭文件描述符
(实际上，库函数通常会设置close-on-exec标志)。</p>
<p>　　●
当调用<code>exec()</code>出错时，可能需要保证文件描述符处于打开状态。但是，当文件描述符被关闭后，再次打开文件描述符并让文件描述符引用之前引用的文件非常困难
(甚至不可能)。</p>
<p>　　因此，内核为每个文件描述符提供了close-on-exec标志。若该标志已被设置，则文件描述符在<code>exec()</code>成功时会自动关闭，<code>exec()</code>出错时保持打开状态。文件描述符的close-on-exec标志可以通过系统调用<code>fcntl()</code>访问。<code>fcntl()</code>的操作<code>F_GETFD</code>可以获取文件描述符的标志的副本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">flags = fcntl(fd, F_GETFD);</span><br><span class="line"><span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　当获取了这些标志后，可以修改位<code>FD_CLOEXEC</code>，然后再次调用<code>fcntl()</code>的操作<code>F_SETFD</code>来更新标志：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flags |= FD_CLOEXEC;</span><br><span class="line"><span class="keyword">if</span> (fcntl(fd, F_SETFD, flags) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<code>FD_CLOEXEC</code>实际上是文件描述符的标志中唯一使用的位，对应值1，所以可以直接调用<code>fcntl(fd, F_SETFD, 1)</code>来设置文件描述符的close-on-exec标志。从理论角度，由于有些UNIX系统以后可能会使用其他标志位，所以应该避免使用这种方法。</p>
<p>　　Linux和很多UNIX实现允许通过非标准<code>ioctl()</code>调用来修改close-on-exec标志：<code>ioctl(fd, FIOCLEX)</code>
(设置close-on-exec标志) 和<code>ioctl(fd, FIOCLEX)</code>
(清除close-on-exec标志)。</p>
<p>　　当通过<code>dup()</code>、<code>dup2()</code>或<code>fcntl()</code>来复制文件描述符时，新文件描述符的close-on-exec标志总是处于关闭状态
(这种行为是历史性的，也是SUSv3的要求)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* closeonexec.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flags = fcntl(STDOUT_FILENO, F_GETFD);</span><br><span class="line">        <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fcntl - F_GETFD&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flags |= FD_CLOEXEC;</span><br><span class="line">        <span class="keyword">if</span> (fcntl(STDOUT_FILENO, F_SETFD, flags) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fcntl - F_SETFD&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, argv[<span class="number">0</span>], (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">    errExit(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何修改close-on-exec标志。</p>
<h3 id="信号和exec">27.4 信号和<code>exec()</code></h3>
<p>　　当<code>exec()</code>成功时，调用<code>exec()</code>的程序会被替换，该程序设置的信号处理函数也会被丢弃。由于信号处理函数消失，内核会将对应的信号的处理方式设置为<code>SIG_DFL</code>，其他信号
(处理方式是<code>SIG_IGN</code>或<code>SIG_DFL</code>)
的处理方式保持不变。这种行为是SUSv3的要求。</p>
<p>　　SUSv3没有说明处理方式是被忽略的信号<code>SIGCHLD</code>在<code>exec()</code>成功后处理方式保持不变还是被设置为<code>SIG_DFL</code>。Linux采用前者，而有些UNIX实现
(例如，Solaris)
采用后者。为了保证可移植性，对于会忽略信号<code>SIGCHLD</code>的程序，在调用<code>exec()</code>前应先将该信号的处理方式设置为<code>SIG_DFL</code>，并保证<code>exec()</code>调用的程序默认信号<code>SIGCHLD</code>的处理方式是<code>SIG_DFL</code>。</p>
<p>　　旧程序的数据、栈和堆被丢弃表示通过<code>sigaltstack()</code>定义的备用信号栈也会被丢弃，所以所有信号的标志<code>SA_ONSTACK</code>也会被清除。</p>
<p>　　<code>exec()</code>成功时进程的信号掩码和待处理信号集保持不变。该特性允许信号继续阻塞和排队。但是，SUSv3指出，很多现有应用程序错误地假设它们启动时特定信号的处理方式是<code>SIG_DFL</code>或这些信号未被阻塞。</p>
<h3 id="system">27.5 <code>system()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure>
<p>　　库函数<code>system()</code>会创建1个子进程，子进程会调用shell来执行<code>command</code>。</p>
<p>　　<code>system()</code>的主要优点是简单和便利：</p>
<p>　　●
无需处理调用<code>fork()</code>、<code>exec()</code>、<code>wait()</code>和<code>exit()</code>的细节。</p>
<p>　　● 错误和信号处理函数由<code>system()</code>代为执行。</p>
<p>　　●
由于<code>system()</code>使用shell执行<code>command</code>，所以执行前会对其进行常规的shell处理、替换和重定向。这使得在应用程序中添加
"执行shell命令" 的功能很简单
(很多交互式应用程序都以!命令的形式提供该功能)。</p>
<p>　　<code>system()</code>的主要缺点是效率低。通过该函数执行命令需要至少创建2个进程，1个进程用于shell，其他进程用于执行命令
(这些进程都会调用<code>exec()</code>)。若存在效率或速度要求，显式调用<code>fork()</code>和<code>exec()</code>是更好的选择。</p>
<p>　　<code>system()</code>的返回值如下：</p>
<p>　　●
若<code>command</code>为<code>NULL</code>，则<code>system()</code>在shell可用时返回非0值，shell不可用时返回0。这是C标准的要求，不依赖于任何操作系统，所以非UNIX系统调用<code>system()</code>时shell可能不可用。尽管所有UNIX实现都有shell，但如果程序在调用<code>system()</code>前调用<code>chroot()</code>，则shell也可能不可用。</p>
<p>　　●
若无法创建子进程或无法获取子进程的终止状态，则<code>system()</code>返回-1。</p>
<p>　　●
若子进程无法执行shell，则<code>system()</code>的返回值就像子进程调用<code>_exit(127)</code>终止一样。</p>
<p>　　●
若所有系统调用都成功，则<code>system()</code>返回执行命令的shell的终止状态
(shell的终止状态是它指向的最后1条命令的终止状态)。</p>
<p>　　对于最后2种情况，<code>system()</code>的返回值使用等待状态值的格式
(见26.1.3)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_system.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_wait_status.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CMD_LEN 200</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[MAX_CMD_LEN]; <span class="comment">/* system()执行的命令 */</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 读取并执行shell命令 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Command: &quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(str, MAX_CMD_LEN, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        status = system(str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;system() returned: status=0x%04x (%d,%d)\n&quot;</span>,</span><br><span class="line">               (<span class="type">unsigned</span> <span class="type">int</span>)status, status &gt;&gt; <span class="number">8</span>, status &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;system&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) == <span class="number">127</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(Probably) could not invoke shell\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">/* shell成功执行命令 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                printWaitStatus(<span class="literal">NULL</span>, status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>system()</code>的用法。</p>
<h4 id="避免在set-user-id和set-group-id程序中使用system">27.5.1
避免在set-user-ID和set-group-ID程序中使用<code>system()</code></h4>
<p>　　当set-user-ID程序和set-group-ID程序以特权用户ID运行时，<span
style="background-color: yellow">绝不能</span>使用<code>system()</code>。即使这些程序不允许用户指定待执行的命令，shell也会依赖各种环境变量来控制其行为，这表示<code>system()</code>的使用会不可避免地为安全漏洞打开大门。</p>
<p>　　例如，对于较旧的<code>bash</code>，环境变量<code>IFS</code>定义了用于将命令分隔为内部字段的分隔符，这成为了许多成功的系统入侵的源头。若将该环境变量的值设置为<code>a</code>，则字符串<code>shar</code>会被解释为<code>sh</code>及其参数<code>r</code>，这会导致调用另一个shell来执行当前工作目录下的脚本<code>r</code>，而非预期目的
(执行命令<code>shar</code>)。该漏洞是通过将该环境变量的值指定为仅由shell扩展产生的词来修复。此外，现代shell在启动时会将该环境变量重置为由空格、制表符和换行符这3个字符组成的字符串。为了进一步地保证安全，当<code>bash</code>被set-user-ID程序
(或set-group-ID程序) 调用时，它会还原为实际用户ID (或实际组ID)。</p>
<p>　　需要产生其他程序的安全程序应该直接调用<code>fork()</code>以及<code>execlp()</code>和<code>execvp()</code>之外的<code>exec()</code>函数。</p>
<h4 id="实现system">27.5.2 实现<code>system()</code></h4>
<p>　　命令<code>sh</code>的选项<code>-c</code>提供了1种简单的方法来执行任意shell命令。因此，为了实现<code>system()</code>，需要调用<code>fork()</code>来创建子进程，子进程调用<code>execl("/bin/sh", "sh", "-c", command, (char *) NULL)</code>。为了获取子进程的状态，还需要调用<code>waitpid()</code>。<code>system()</code>的简单但不完整实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* simple_system.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 */</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command, (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="keyword">if</span> (waitpid(childPid, &amp;status, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在system中正确处理信号">27.5.2.1
在<code>system()</code>中正确处理信号</h5>
<p>　　第1个考虑的信号是<code>SIGCHLD</code>。假设调用<code>system()</code>的程序也会创建子进程，并且注册了<code>SIGCHLD</code>处理函数。当<code>system()</code>创建的子进程终止时，也会生成信号<code>SIGCHLD</code>，这可能会导致<code>system()</code>调用<code>waitpid()</code>前被主函数注册的<code>SIGCHLD</code>处理函数中断
(这也属于竞争条件)，进而产生2个问题：</p>
<p>　　●
调用<code>system()</code>的程序错误地认为它创建的子进程已终止。</p>
<p>　　● <code>system()</code>无法获取它创建的子进程的终止状态。</p>
<p>　　因此，<code>system()</code>执行期间必须阻塞信号<code>SIGCHLD</code>。</p>
<p>　　还需要考虑由终端中断字符 (通常是Control-C)
生成的信号<code>SIGINT</code>和终端退出字符 (通常是Control-\)
生成的信号<code>SIGQUIT</code>。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_27/arrangement_of_processes_during_execution_of_system.svg" class="">
<p>　　在执行<code>system("sleep 20")</code>期间会存在3个运行中的进程：执行调用程序的进程、shell和<code>sleep</code>
(若传递给选项<code>-c</code>的命令是简单命令，则<code>bash</code>等shell会直接执行该命令，而非创建子shell来执行该命令。因此，另一种可能是只有2个运行中的进程：执行调用程序的进程和<code>sleep</code>)。</p>
<p>　　这3个进程都是终端前台进程组的一部分，所以当在终端输入中断字符或退出字符时，对应的信号会发送给这3个进程。shell在等待子进程时会忽略信号<code>SIGINT</code>和<code>SIGQUIT</code>。但是，调用进程和<code>sleep</code>进程默认会被这些信号终止。为此，SUSv3做出了以下规定：</p>
<p>　　●
当执行命令时，调用进程应该忽略信号<code>SIGINT</code>和<code>SIGQUIT</code>。</p>
<p>　　●
对于子进程，信号<code>SIGINT</code>和<code>SIGQUIT</code>应该像调用进程执行<code>fork()</code>和<code>exec()</code>时一样被处理，即将这2个信号的处理方式设置为<code>SIG_DFL</code>，其他信号的处理方式保持不变。</p>
<p>　　按照SUSv3规定的方式处理信号是最合理的方法，原因如下：</p>
<p>　　●
同时让调用进程和子进程都响应信号是不合理的，因为这可能导致应用程序用户的行为混乱。</p>
<p>　　●
同样，在执行命令时忽略这些信号，而在调用进程中按照默认处理方式处理这些信号，也是不合理的。这样用户就可以在执行命令时终止调用进程。这也与调用进程在执行传递给<code>system()</code>的命令时已放弃控制权
(即阻塞在调用<code>waitpid()</code>) 的事实不符。</p>
<p>　　●
<code>system()</code>执行的命令可能是交互式应用程序，所以它可能需要响应终端生成的信号。</p>
<p>　　此外，SUSv3指出上述行为可能会对隐式使用<code>system()</code>执行某些任务的程序产生副作用。当执行命令时，输入终端中断字符或退出字符只会终止<code>system()</code>的子进程，而应用程序继续运行
(出乎用户意料)
。以这种方式使用<code>system()</code>的程序应该检查<code>system()</code>返回的终止状态，并在检测到命令被信号终止时采取合适的行为。</p>
<h5 id="改进的system实现">27.5.2.2 改进的<code>system()</code>实现</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* system.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> blockMask, origMask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">saIgnore</span>, <span class="title">saOrigQuit</span>, <span class="title">saOrigInt</span>, <span class="title">saDefault</span>;</span></span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line">    <span class="type">int</span> status, savedErrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> system(<span class="string">&quot;:&quot;</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 阻塞信号SIGCHLD */</span></span><br><span class="line">    sigemptyset(&amp;blockMask);</span><br><span class="line">    sigaddset(&amp;blockMask, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;blockMask, &amp;origMask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略信号SIGINT和SIGQUIT */</span></span><br><span class="line">    saIgnore.sa_handler = SIG_IGN;</span><br><span class="line">    saIgnore.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;saIgnore.sa_mask);</span><br><span class="line">    sigaction(SIGINT, &amp;saIgnore, &amp;saOrigInt);</span><br><span class="line">    sigaction(SIGQUIT, &amp;saIgnore, &amp;saOrigQuit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        status = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程：执行命令 */</span></span><br><span class="line">        saDefault.sa_handler = SIG_DFL;</span><br><span class="line">        saDefault.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigemptyset(&amp;saDefault.sa_mask);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (saOrigInt.sa_handler != SIG_IGN)</span><br><span class="line">        &#123;</span><br><span class="line">            sigaction(SIGINT, &amp;saDefault, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (saOrigQuit.sa_handler != SIG_IGN)</span><br><span class="line">        &#123;</span><br><span class="line">            sigaction(SIGQUIT, &amp;saDefault, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;origMask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command, (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程：等待子进程终止 */</span></span><br><span class="line">        <span class="keyword">while</span> (waitpid(childPid, &amp;status, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                status = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解除对信号SIGCHLD的阻塞, 恢复信号SIGINT和SIGQUIT处理方式 */</span></span><br><span class="line">    savedErrno = errno;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;origMask, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGINT, &amp;saOrigInt, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGQUIT, &amp;saOrigQuit, <span class="literal">NULL</span>);</span><br><span class="line">    errno = savedErrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是符合上述规则的<code>system()</code>实现。</p>
<p>　　●
如前所述，若<code>command</code>为<code>NULL</code>，则<code>system()</code>在shell可用时返回非0值，shell不可用时返回0。要可靠地获取该信息，唯一的方法就是尝试执行shell。命令<code>:</code>是1个没有实际作用的shell内置命令，并且总是返回成功状态。因此，这里通过<code>system()</code>执行该命令来判断shell是否可用
(第15~18行)。仅通过<code>access()</code>来判断文件<code>/bin/sh</code>是否存在以及是否已启用执行权限是不够的。对于<code>chroot()</code>环境，即使shell文件存在，但如果它是动态链接的，则它可能因无法链接共享库而无法使用。</p>
<p>　　● 只有父进程 (调用<code>system()</code>的进程)
需要阻塞信号<code>SIGCHLD</code> (第21~23行)
以及忽略信号<code>SIGINT</code>和<code>SIGQUIT</code>
(第26~30行)。但是，为了防止产生竞争条件，阻塞和忽略操作必须先于<code>fork()</code>。因此，子进程必须取消这些操作
(第39~52行)。</p>
<p>　　●
对于父进程，这里选择忽略来自<code>sigaction()</code>和<code>sigprocmask()</code>的错误。这样做有2个原因。首先，这些调用几乎不会出错。实际上，唯一可能出错的地方就是参数指定错误，而这种错误在初步调试时就可以排除。其次，这里假设调用者更想知道<code>fork()</code>或<code>waitpid()</code>是否出错，而非这些信号操作调用是否出错。出于类似的原因，这里在<code>system()</code>的末尾进行保存和恢复<code>errno</code>的操作
(第70~74行)，这可以保证<code>fork()</code>或<code>waitpid()</code>出错时调用者可以确定原因。若由于信号操作调用出错而返回-1，则调用者可能错误地认为<code>system()</code>执行<code>command</code>出错
(SUSv3仅规定<code>system()</code>在无法创建子进程或无法获取子进程的状态时返回-1，没有提及由于信号操作调用出错而返回-1)。</p>
<p>　　● 对于子进程，没有对信号相关的系统调用进行错误检查
(第39~52行)，因为无法报告这些错误
(<code>_exit(127)</code>的目的是在执行shell时报告错误)，并且这些错误也不会影响<code>system()</code>的调用者。</p>
<p>　　●
子进程从<code>fork()</code>返回时信号<code>SIGINT</code>和<code>SIGQUIT</code>的处理方式设置是<code>SIG_IGN</code>。但是，对于子进程，这些信号应该被视为<code>system()</code>的调用者调用了<code>fork()</code>和<code>exec()</code>。<code>fork()</code>不会修改子进程的信号处理方式，<code>exec()</code>只会将这些信号的处理方式设置为<code>SIG_DFL</code>。因此，若调用进程未忽略信号<code>SIGINT</code>和<code>SIGQUIT</code>，则子进程会将这些信号的处理方式设置为<code>SIG_DFL</code>
(第43~50行)。有些<code>system()</code>实现会将信号<code>SIGINT</code>和<code>SIGQUIT</code>的处理方式设置为调用者的处理方式，因为后续的<code>exec()</code>会自动将已注册处理函数的信号的处理方式设置为<code>SIG_DFL</code>。但是，若调用者正在处理这些信号中的任意1个，则可能会导致隐患。在这种情况下，若信号在子进程调用<code>exec()</code>之前的短暂时间内被发送给子进程，则子进程通过<code>sigprocmask()</code>解除对信号的阻塞后会调用信号处理函数。</p>
<p>　　●
当子进程调用<code>exec()</code>出错时，这里使用<code>_exit()</code>终止子进程
(第55行)，以防止刷新子进程的stdio缓冲区中的任何未写入的数据。</p>
<p>　　●
对于父进程，必须使用<code>waitpid()</code>来专门等待用于执行shell的子进程
(第58~65行)。若使用<code>wait()</code>，则可能无意中获取其他子进程的状态。</p>
<p>　　●
尽管<code>system()</code>实现不需要使用信号处理函数，但调用程序可能已经注册了信号处理函数，这些信号处理函数可能会中断对<code>waitpid()</code>的阻塞调用。对于这种情况，SUSv3明确要求重新开始等待。因此，这里选择在循环中调用<code>waitpid()</code>，若<code>waitpid()</code>出现错误<code>EINTR</code>，则会重启；若<code>waitpid()</code>出现其他错误，则终止循环
(第58~65行)。</p>
<h5 id="关于system的更多细节">27.5.2.3
关于<code>system()</code>的更多细节</h5>
<p>　　可移植应用程序应该确保信号<code>SIGCHLD</code>的处理方式为<code>SIG_IGN</code>时不调用<code>system()</code>，因为这种情况下无法通过<code>waitpid()</code>获取子进程的状态
(忽略信号<code>SIGCHLD</code>会导致子进程的状态立即被丢弃)。但是，对于有些UNIX实现，<code>system()</code>在这种情况下会临时将<code>SIGCHLD</code>的处理方式修改为<code>SIG_DFL</code>。这是可行的，只要这些UNIX实现会在这种情况下回收僵尸子进程
(不同于Linux)。</p>
<p>　　对于<code>/bin/sh</code>不是标准POSIX shell的UNIX实现
(例如，Solaris)，若需要确保执行的是标准shell，则必须通过库函数<code>confstr()</code>来获取配置变量<code>_CS_PATH</code>的值，该值是目录列表
(使用环境变量<code>PATH</code>的值的格式)，其中包含标准系统工具。然后，可以将该值复制给环境变量<code>PATH</code>的值并通过<code>execlp()</code>来执行标准shell。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> path[PATH_MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (confstr(_CS_PATH, path, PATH_MAX) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _exit(<span class="number">127</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setenv(<span class="string">&quot;PATH&quot;</span>, path, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _exit(<span class="number">127</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execlp(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command, (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">_exit(<span class="number">127</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第28章 详述进程创建和程序执行</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_28/</url>
    <content><![CDATA[<p>　　当启用<strong>进程统计</strong>后，内核会在进程终止时将相关记录写入到系统级进程统计文件，该记录包含内核维护的关于该进程的各种信息
(例如，进程终止状态和使用的CPU时间)。统计文件可以通过标准工具
(<code>sa</code>会总结统计文件中的信息，<code>lastcomm</code>会列出最近执行的命令的相关信息)
或特定的应用程序分析。</p>
<p>　　对于2.6.10之前的内核版本，当通过NPTL线程实现创建线程时，会向进程统计文件中写入1条关于该线程的统计记录。从内核2.6.10开始，只有当进程的最后1个线程终止时，才会向进程统计文件中写入1条关于该进程的统计记录。当使用较旧的LinuxThreads线程实现时，总是会为线程写入统计记录。</p>
<p>　　从历史角度，进程统计的主要用途是在多用户UNIX系统上记录用户使用的系统资源。但是，进程统计也可用于获取进程的相关信息，这些信息是父进程没有监控和报告的。</p>
<p>　　大多数UNIX实现都提供了进程统计，但SUSv3没有说明它。统计记录的格式和统计文件的位置因UNIX实现而异。这里介绍的内容是基于Linux，也会说明与UNIX实现之间的差异。</p>
<p>　　对于Linux，进程统计是可选的内核组件，由选项<code>CONFIG_BSD_PROCESS_ACCT</code>配置。</p>
<h3 id="进程统计">28.1 进程统计</h3>
<p>　　特权进程 (能力<code>CAP_SYS_PACCT</code>)
可以通过系统调用<code>acct()</code>来启用和禁用进程统计。应用程序通常不会使用该系统调用。进程统计通常以在系统启动脚本中加入合适的命令的方式来启用
(保证每次系统重启时都会启用进程统计)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">acct</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *acctfile)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　为了启用进程统计，需要将<code>acct()</code>的参数<code>acctfile</code>指定为已存在的常规文件的路径名。统计文件的路径名通常是<code>/var/log/pacct</code>或<code>/usr/account/pacct</code>)。为了禁用进程统计，需要将<code>acctfile</code>指定为<code>NULL</code>。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* acct_on.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span> || (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [file]\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acct(argv[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;acct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process accounting %s\n&quot;</span>, (argv[<span class="number">1</span>] == <span class="literal">NULL</span>) ? <span class="string">&quot;disabled&quot;</span> : <span class="string">&quot;enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>acct()</code>的用法。</p>
<h4 id="进程统计记录">28.1.1 进程统计记录</h4>
<p>　　当启用进程统计后，进程终止时会向统计文件写入1条<code>acct</code>记录。结构体<code>acct</code>定义在头文件<code>sys/acct.h</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ACCT_COMM 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">u_int16_t</span> <span class="type">comp_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> ac_flag;                <span class="comment">/* 统计标志 */</span></span><br><span class="line">    <span class="type">u_int16_t</span> ac_uid;            <span class="comment">/* 进程的用户ID */</span></span><br><span class="line">    <span class="type">u_int16_t</span> ac_gid;            <span class="comment">/* 进程的组ID */</span></span><br><span class="line">    <span class="type">u_int16_t</span> ac_tty;            <span class="comment">/* 进程的控制终端 (0表示没有控制终端) */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_btime;          <span class="comment">/* 进程创建时间 (time_t，自纪元以来的秒数) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_utime;             <span class="comment">/* 用户CPU时间 (时钟节拍) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_stime;             <span class="comment">/* 系统CPU时间 (时钟节拍) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_etime;             <span class="comment">/* 已使用的 (实际) 时间 (时钟节拍) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_mem;               <span class="comment">/* 平均内存使用 (KB) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_io;                <span class="comment">/* read()和write()传输的字节数 (未使用) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_rw;                <span class="comment">/* 读取/写入的块数 (未使用) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_minflt;            <span class="comment">/* 次要页故障 (特定于Linux) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_majflt;            <span class="comment">/* 主要页故障 (特定于Linux) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_swaps;             <span class="comment">/* 交换次数 (未使用，特定于Linux) */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_exitcode;       <span class="comment">/* 进程终止状态 */</span></span><br><span class="line">    <span class="type">char</span> ac_comm[ACCT_COMM + <span class="number">1</span>]; <span class="comment">/* 命令名 (最近执行的命令的基础名称，以\0结尾) */</span></span><br><span class="line">    <span class="type">char</span> ac_pad[X];              <span class="comment">/* 填充字节 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　●
<code>u_int16_t</code>和<code>u_int32_t</code>是16位和32位无符号整数类型。</p>
<p>　　●
<code>comp_t</code>是浮点类型，该数据类型也称为<strong>压缩时钟节拍</strong>。<code>comp_t</code>的前3位是以8为底数的指数
(表示8<sup>0</sup>到8<sup>7</sup>)，后13位表示尾数。例如，当尾数和指数分别为125和1时，表示值1000。</p>
<p>　　●
成员<code>ac_flag</code>是位掩码，用于记录进程的各种事件。该成员可以指定的位如下
(并非所有UNIX实现都提供了这些位)：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AFORK</code></td>
<td>进程由<code>fork()</code>创建，但直到终止也没有调用<code>exec()</code></td>
</tr>
<tr>
<td><code>ASU</code></td>
<td>进程使用了超级用户特权</td>
</tr>
<tr>
<td><code>AXSIG</code></td>
<td>进程被信号终止 (有些UNIX实现未提供该位)</td>
</tr>
<tr>
<td><code>ACORE</code></td>
<td>进程生成了核心转储文件 (有些UNIX实现未提供该位)</td>
</tr>
</tbody>
</table>
<p>　　● 成员<code>ac_comm</code>用于记录进程最近执行的命令 (可执行文件)
的名称。每次调用<code>execve()</code>时内核会记录该值。对于有些UNIX实现，该成员的长度限制为8个字符。</p>
<p>　　●
3个<code>comp_t</code>类型的时间成员以系统时钟节拍表示时间，所以需要将这些时间除以<code>sysconf(_SC_CLK_TCK)</code>来获取秒数。</p>
<p>　　● 成员<code>ac_exitcode</code>用于记录进程的终止状态
(见26.1.3)。大多数UNIX实现未提供该成员，相反，提供的是单字节成员<code>ac_stat</code>，<code>ac_stat</code>仅记录终止进程的信号，并使用其中的1位来表示是否生成核心转储文件。BSD衍生实现未提供这2个成员。</p>
<p>　　由于统计记录在进程终止时写入，所以统计记录按照终止时间排序
(统计记录没有记录终止时间)
。此外，系统崩溃时不会为任何执行中的进程写入统计记录。</p>
<p>　　由于向统计文件写入统计记录会占用大量磁盘空间，所以Linux提供了虚拟文件<code>/proc/sys/kernel/acct</code>来控制进程统计的操作。该文件包含3个数字，依次定义了参数<code>high-water</code>、<code>low-water</code>和<code>frequency</code>。这3个参数的默认值分别是4、2和30。若启用了进程统计，并且空闲磁盘空间低于<code>low-water</code>指定的百分比，则挂起统计。若空闲磁盘空间高于<code>high-water</code>指定的百分比，则恢复统计。<code>frequency</code>指定检查空闲磁盘空间百分比的频率
(单位为秒)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* acct_view.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/acct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span> <span class="comment">/* userNameFromId()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将comp_t值转换为long long值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ct</span></span><br><span class="line"><span class="comment"> * @return long long</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">comptToLL</span><span class="params">(<span class="type">comp_t</span> ct)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> EXP_SIZE = <span class="number">3</span>;       <span class="comment">/* 指数 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MANTISSA_SIZE = <span class="number">13</span>; <span class="comment">/* 尾数 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MANTISSA_MASK = (<span class="number">1</span> &lt;&lt; MANTISSA_SIZE) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mantissa, <span class="built_in">exp</span>;</span><br><span class="line"></span><br><span class="line">    mantissa = ct &amp; MANTISSA_MASK;</span><br><span class="line">    <span class="built_in">exp</span> = (ct &gt;&gt; MANTISSA_SIZE) &amp; ((<span class="number">1</span> &lt;&lt; EXP_SIZE) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mantissa &lt;&lt; (<span class="built_in">exp</span> * <span class="number">3</span>); <span class="comment">/* 通过左移3位来获取8的幂 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> acctFile;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">acct</span> <span class="title">ac</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> numRead;</span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="type">char</span> timeBuf[TIME_BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">loc</span>;</span></span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s file\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    acctFile = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (acctFile == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;command  flags   term.  user     start time            CPU   elapsed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                status                                 time    time\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((numRead = read(acctFile, &amp;ac, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acct))) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numRead != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acct))</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;partial read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8.8s  &quot;</span>, ac.ac_comm);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (ac.ac_flag &amp; AFORK) ? <span class="string">&#x27;F&#x27;</span> : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (ac.ac_flag &amp; ASU) ? <span class="string">&#x27;S&#x27;</span> : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 并非所有UNIX实现都提供了AXSIG和ACORE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AXSIG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (ac.ac_flag &amp; AXSIG) ? <span class="string">&#x27;X&#x27;</span> : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ACORE</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (ac.ac_flag &amp; ACORE) ? <span class="string">&#x27;C&#x27;</span> : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __linux__</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %#6lx   &quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)ac.ac_exitcode);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* 很多UNIX实现提供的是成员ac_stat */</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %#6lx   &quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)ac.ac_stat);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        s = userNameFromId(ac.ac_uid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8.8s &quot;</span>, (s == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : s);</span><br><span class="line"></span><br><span class="line">        t = ac.ac_btime;</span><br><span class="line">        loc = localtime(&amp;t);</span><br><span class="line">        <span class="keyword">if</span> (loc == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;???Unknown time???  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            strftime(timeBuf, TIME_BUF_SIZE, <span class="string">&quot;%Y-%m-%d %T &quot;</span>, loc);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, timeBuf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5.2f %7.2f &quot;</span>,</span><br><span class="line">               (<span class="type">double</span>)(comptToLL(ac.ac_utime) + comptToLL(ac.ac_stime)) / sysconf(_SC_CLK_TCK),</span><br><span class="line">               (<span class="type">double</span>)comptToLL(ac.ac_etime) / sysconf(_SC_CLK_TCK));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会打印进程统计文件的统计记录的某些字段。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> pacct</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./acct_on pacct</span></span><br><span class="line">Process accounting enabled</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>
<p>　　首先，创建统计文件并启用进程统计。此时，自启用进程统计以来，已经有3个进程终止。这些进程执行了程序<code>acct_on</code>、<code>su</code>和<code>bash</code>。执行<code>bash</code>的进程由<code>su</code>启动，用于运行特权shell会话。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sleep</span> 15 &amp;</span></span><br><span class="line">[1] 18063</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -c unlimited</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span></span></span><br><span class="line">输入Control-\ (生成信号SIGQUIT) 来终止cat</span><br><span class="line">Quit (core dumped)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">按下回车键可以在下一个shell提示符前查看睡眠完成后的shell通知</span></span><br><span class="line">[1]  + done       sleep 15</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep xxx badfile</span></span><br><span class="line">grep: badfile: No such file or directory</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $?</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>　　这里将执行一系列命令来为统计文件添加记录
(第3行的命令会解除核心转储文件的大小限制)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_execve /bin/echo</span></span><br><span class="line">hello world goodbye</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_fork</span></span><br><span class="line">PID=18350 (child) idata=333 istack=666</span><br><span class="line">PID=18349 (parent) idata=111 istack=222</span><br></pre></td></tr></table></figure>
<p>　　然后，运行<code>t_execve</code>和<code>t_fork</code>。第1行的命令会执行文件<code>/bin/echo</code>，所以记录中显示的命令名是<code>echo</code>。第3行的命令会创建不调用<code>exec()</code>的子进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./acct_view pacct</span></span><br><span class="line">command  flags   term.  user     start time            CPU   elapsed</span><br><span class="line">                status                                 time    time</span><br><span class="line">acct_on  -S--       0   root     2010-07-23 17:19:05   0.00    0.00</span><br><span class="line">bash     ----       0   root     2010-07-23 17:18:55   0.02   21.10</span><br><span class="line">su       -S--       0   root     2010-07-23 17:18:51   0.01   24.94</span><br><span class="line">cat      --XC    0x83   mtk      2010-07-23 17:19:55   0.00    1.72</span><br><span class="line">sleep    ----       0   mtk      2010-07-23 17:19:42   0.00   15.01</span><br><span class="line">grep     ----   0x200   mtk      2010-07-23 17:20:12   0.00    0.00</span><br><span class="line">echo     ----       0   mtk      2010-07-23 17:21:15   0.01    0.01</span><br><span class="line">t_fork   F---       0   mtk      2010-07-23 17:21:36   0.00    0.00</span><br><span class="line">t_fork   ----       0   mtk      2010-07-23 17:21:36   0.00    3.01</span><br></pre></td></tr></table></figure>
<p>　　最后，通过<code>acct_view</code>来查看统计文件。</p>
<h4 id="统计文件格式版本3">28.1.2 统计文件格式版本3</h4>
<p>　　从内核2.6.8开始，Linux添加了可选的替代进程统计文件版本来解决传统统计文件的某些问题，该版本称为<span
style="background-color: yellow">版本3</span>。为了使用该版本，在构建内核前必须先启用内核选项<code>CONFIG_BSD_PROCESS_ACCT_V3</code>。</p>
<p>　　当使用版本3时，进程统计操作唯一的区别在于写入到统计文件的记录格式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ACCT_COMM 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acct_v3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> ac_flag;            <span class="comment">/* 统计标志 */</span></span><br><span class="line">    <span class="type">char</span> ac_version;         <span class="comment">/* 统计版本 (3) */</span></span><br><span class="line">    <span class="type">u_int16_t</span> ac_tty;        <span class="comment">/* 进程的控制终端 */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_exitcode;   <span class="comment">/* 进程终止状态 */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_uid;        <span class="comment">/* 进程的用户ID */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_gid;        <span class="comment">/* 进程的组ID */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_pid;        <span class="comment">/* 进程ID */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_ppid;       <span class="comment">/* 父进程ID */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_btime;      <span class="comment">/* 进程创建时间 (time_t，自纪元以来的秒数) */</span></span><br><span class="line">    <span class="type">float</span> ac_etime;          <span class="comment">/* 已使用的 (实际) 时间 */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_utime;         <span class="comment">/* 用户CPU时间 (时钟节拍)  */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_stime;         <span class="comment">/* 系统CPU时间 (时钟节拍) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_mem;           <span class="comment">/* 平均内存使用 (KB) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_io;            <span class="comment">/* 读取/写入的字节数 (未使用) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_rw;            <span class="comment">/* 读取/写入的块数 (未使用) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_minflt;        <span class="comment">/* 次要页故障 */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_majflt;        <span class="comment">/* 主要页故障 */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_swaps;         <span class="comment">/* 交换次数 (未使用，特定于Linux) */</span></span><br><span class="line">    <span class="type">char</span> ac_comm[ACCT_COMM]; <span class="comment">/* 命令名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　结构体<code>acct_v3</code>和<code>acct</code>的主要区别如下：</p>
<p>　　● 添加了成员<code>ac_version</code>，该成员包含对应记录的版本号
(总是为3)。</p>
<p>　　●
添加了成员<code>ac_pid</code>和<code>ac_ppid</code>，分别包含终止进程的进程ID和父进程ID。</p>
<p>　　●
成员<code>ac_uid</code>和<code>ac_gid</code>从16位扩展到32位，以容纳Linux
2.4中添加的32位用户ID和组ID (传递统计文件无法正确地表示这些ID)。</p>
<p>　　●
成员<code>ac_etime</code>的数据类型修改为<code>float</code>，以记录更长的时间。</p>
<h3 id="clone">28.2 <code>clone()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *func_arg, ...</span></span><br><span class="line"><span class="params">          <span class="comment">/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */</span>)</span>; <span class="comment">/* 成功时返回子进程的进程ID，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　与<code>fork()</code>和<code>vfork()</code>类似，特定于Linux的系统调用<code>clone()</code>也会创建1个新进程，但后者允许更精细地控制进程创建步骤。<code>clone()</code>主要用于线程库的实现中。由于该系统调用是不可移植的，所以应该尽量避免直接在应用程序中使用该系统调用。</p>
<p>　　<code>clone()</code>创建的子进程几乎是父进程的精确副本。但是，子进程不是从调用<code>clone()</code>
的位置继续执行，而是以调用参数<code>func</code>
指向的函数开始，该函数称为<strong>子函数</strong>。当子函数被调用时，参数<code>func_arg</code>指定的值会传递给子函数。通过合适的类型转换，子函数可以自由地解释该参数
(例如，作为<code>int</code>或指向结构体的指针。将其解释为指针是可能的，因为子进程要么获得父进程内存的副本，要么与父进程共享内存)。</p>
<p>　　克隆的子进程会在<code>func</code>指向的函数返回或调用<code>exit()</code>
(或<code>_exit()</code>)
时终止。父进程可以使用<code>wait()</code>等函数来以常规方式等待克隆的子进程。</p>
<p>　　由于克隆的子进程可能会与父进程共享内存
(与<code>vforK()</code>类似)，所以它不能使用父进程的栈。相反，调用者必须分配1个大小合适的内存块作为子进程的栈
(通过参数<code>child_stack</code>传递)。对于大多数硬件架构，栈向低地址增长，所以<code>child_stack</code>应该指向分配的内存块的最后1个字节。</p>
<p>　　<code>clone()</code>的参数<code>flags</code>分为2个部分。最低字节用于指定子进程的终止信号，即子进程终止时父进程收到的信号
(若克隆的子进程被信号停止，则父进程会收到信号<code>SIGCHLD</code>)。该字节可能为0，此时，表示不会生成信号
(可以通过Linux的文件<code>/proc/PID/stat</code>来获取任何进程的终止信号)。剩余字节作为控制<code>clone()</code>操作的位掩码，可以包含以下标志中的任意个标志
(或运算<code>|</code>)：</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CLONE_CHILD_CLEARTID</code></td>
<td>子进程调用<code>exec()</code>或<code>exit()</code>时清除<code>ctid</code>
(Linux 2.6及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_CHILD_SETTID</code></td>
<td>将子进程的线程ID写入到<code>ctid</code> (Linux 2.6及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_FILES</code></td>
<td>父进程和子进程共享打开的文件描述符表</td>
</tr>
<tr>
<td><code>CLONE_FS</code></td>
<td>父进程和子进程共享文件系统相关属性</td>
</tr>
<tr>
<td><code>CLONE_IO</code></td>
<td>父进程和子进程共享I/O上下文 (Linux 2.6.25及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_NEWIPC</code></td>
<td>子进程获得新的System V IPC命名空间 (Linux 2.6.19及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_NEWNET</code></td>
<td>子进程获得新的网络命名空间 (Linux 2.4.24及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_NEWNS</code></td>
<td>子进程获得父进程的挂载命名空间的副本 (Linux 2.4.19及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_NEWPID</code></td>
<td>子进程获得新的进程ID命名空间 (Linux 2.6.19及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_NEWUSER</code></td>
<td>子进程获得新的用户ID命名空间 (Linux 2.6.23及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_NEWUTS</code></td>
<td>子进程获得新的UTS (<code>utsname()</code>) 命名空间 (Linux
2.6.19及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_PARENT</code></td>
<td>让子进程的父进程与调用进程的父进程相同 (Linux 2.4及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_PARENT_SETTID</code></td>
<td>将子进程的线程ID写入到<code>ptid</code> (Linux 2.6及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_PID</code></td>
<td>仅用于系统引导进程的过期标志 (Linux 2.4及以下版本)</td>
</tr>
<tr>
<td><code>CLONE_PTRACE</code></td>
<td>若父进程正在被跟踪，则子进程也会被跟踪</td>
</tr>
<tr>
<td><code>CLONE_SETTLS</code></td>
<td><code>tls</code>会描述线子进程的线程本地存储 (Linux
2.6及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_SIGHAND</code></td>
<td>父进程和子进程共享信号处理方式</td>
</tr>
<tr>
<td><code>CLONE_SYSVSEM</code></td>
<td>父进程和子进程共享信号量撤销值 (Linux 2.6及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_THREAD</code></td>
<td>让子进程和父进程属于同一线程组 (Linux 2.4及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_UNTRACED</code></td>
<td>无法强制将<code>CLONE_PTRACE</code>应用于子进程 (Linux
2.6及以上版本)</td>
</tr>
<tr>
<td><code>CLONE_VFORK</code></td>
<td>挂起父进程，直到子进程调用<code>exec()</code>或<code>_exit()</code></td>
</tr>
<tr>
<td><code>CLONE_VM</code></td>
<td>父进程和子进程共享虚拟内存</td>
</tr>
</tbody>
</table>
<p>　　<code>clone()</code>的剩余参数是<code>ptid</code>、<code>tls</code>和<code>ctid</code>。这些参数与线程实现有关，尤其是线程ID和线程本地存储的使用。对于Linux
2.4及以下版本，这些参数是未提供的。这些参数添加到Linux
2.6专门是为了支持NPTL POSIX线程实现。</p>
<p>　　<code>clone()</code>的设计缺陷之一就是对栈增长方向的架构依赖。对于Intel
IA-64架构，还提供了<code>clone()</code>的改进版：<code>clone2()</code>。<code>clone2()</code>提供了栈的起始地址和大小，所以子进程的栈的范围定义不再依赖于栈的增长方向。</p>
<p>　　在内核中，<code>fork()</code>、<code>vfork()</code>和<code>clone()</code>最终都是通过同一函数
(<code>kernel/fork.c</code>中的<code>do_fork()</code>)
实现。在这个层级上，克隆更接近于fork：<code>sys_clone()</code>没有参数<code>func</code>和<code>func_arg</code>，并且被在调用后，<code>sys_clone()</code>会以与<code>fork()</code>相同的方式在子进程中返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_clone.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHILD_SIG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHILD_SIG SIGUSR1 <span class="comment">/* 克隆子进程终止时父进程收到的信号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 克隆子进程的启动函数 (关闭arg指向的文件描述符)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arg</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">childFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (close(*((<span class="type">int</span> *)arg)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 子进程终止 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> STACK_SIZE = <span class="number">65536</span>; <span class="comment">/* 克隆子进程的栈大小 */</span></span><br><span class="line">    <span class="type">char</span> *<span class="built_in">stack</span>;                  <span class="comment">/* 栈缓冲区的开头 */</span></span><br><span class="line">    <span class="type">char</span> *stackTop;               <span class="comment">/* 栈缓冲区的结尾 */</span></span><br><span class="line">    <span class="type">int</span> s, fd, flags;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR); <span class="comment">/* 子进程会关闭该描述符 */</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags = (argc &gt; <span class="number">1</span>) ? CLONE_FILES : <span class="number">0</span>; <span class="comment">/* 若argc大于1，则子进程会与父进程共享文件描述符表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = <span class="built_in">malloc</span>(STACK_SIZE); <span class="comment">/* 为子进程分配栈 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stackTop = <span class="built_in">stack</span> + STACK_SIZE; <span class="comment">/* 假设栈向低地址增长 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略CHILD_SIG (防止其处理方式是终止进程)，但不忽略SIGCHLD (忽略SIGCHLD会阻止僵尸进程的生成) */</span></span><br><span class="line">    <span class="keyword">if</span> (CHILD_SIG != <span class="number">0</span> &amp;&amp; CHILD_SIG != SIGCHLD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (signal(CHILD_SIG, SIG_IGN) == SIG_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建子进程 (子进程会从执行childFunc()开始 */</span></span><br><span class="line">    <span class="keyword">if</span> (clone(childFunc, stackTop, flags | CHILD_SIG, (<span class="type">void</span> *)&amp;fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;clone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程等待子进程 (__WCLONE表示仅等待克隆的子进程) */</span></span><br><span class="line">    <span class="keyword">if</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, (CHILD_SIG != SIGCHLD) ? __WCLONE : <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child has terminated\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断子进程关闭文件描述符是否影响父进程 */</span></span><br><span class="line">    s = write(fd, <span class="string">&quot;x&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span> &amp;&amp; errno == EBADF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file descriptor %d has been closed\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write() on file descriptor %d failed unexpectedly (%s)\n&quot;</span>, fd, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write() on file descriptor %d succeeded\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>clone()</code>的用法。父进程会执行以下步骤：</p>
<p>　　1) 打开1个文件描述符
(<code>/dev/null</code>)，子进程可能与父进程共享该文件描述符
(第36~40行)。</p>
<p>　　2)
将<code>CLONE_FILES</code>指定给<code>clone()</code>的参数<code>flags</code>。若提供了命令行参数，则父进程和子进程共享同一文件描述符表。若未提供命令行参数，则将<code>flags</code>设置为0
(第42行)。</p>
<p>　　3) 为子进程分配栈 (第44~49行)。</p>
<p>　　4)
若<code>CHILD_SIG</code>不等于0和<code>SIGCHLD</code>，则忽略该信号，以防止它会终止进程。这里不会忽略<code>SIGCHLD</code>，因为这样会导致无法等待子进程来获取其终止状态
(第52~58行)。</p>
<p>　　5) 调用<code>clone()</code>来创建子进程。第3个参数 (位掩码)
会包括终止信号。 第4个参数指定之前打开的文件描述符 (第61~64行)。</p>
<p>　　6) 等待子进程终止 (第67~71行)。</p>
<p>　　7)
通过向文件描述符写入来检查其是否仍然处于打开状态，然后根据结果打印提示信息
(第74~86行)。</p>
<p>　　子进程会从调用<code>childFunc()</code>开始，该函数会接收父进程打开的文件描述符并将其关闭，然后通过<code>return</code>终止
(第19~27行)。</p>
<h4 id="参数flags">28.2.1 参数<code>flags</code></h4>
<p>　　在某种程度上，试图区分术语线程和进程是在玩文字游戏。为此，这里将使用术语<span
style="background-color: yellow">内核调度实体</span>
(KES)，某些文档中使用该术语来表示内核调度程序的处理对象。实际上，线程和进程都是KSE，它们提供了与其他KSE不同程度的属性共享
(例如，虚拟内存、打开的文件描述符、信号处理方式和进程ID)。POSIX线程规范仅提供了线程之间应共享的属性的各种可能定义之一。</p>
<p>　　从内核2.6.16开始，Linux提供了系统调用<code>unshare()</code>，该系统调用允许通过<code>clone()</code>、<code>fork()</code>或<code>vfork()</code>创建的子进程撤销在它被创建时设置的部分属性共享
(即逆转部分在子进程创建时设置的<code>clone()</code>标志位的效果)。</p>
<p>　　在接下来的内容中，可能会提供到Linux上可用的2个主要POSIX线程实现：较旧的LinuxThreads实现和较新的NPTL实现。</p>
<h5 id="共享文件描述符表">28.2.1.1 共享文件描述符表</h5>
<p>　　若指定了标志<code>CLONE_FILES</code>，则父进程和子进程会共享同一打开的文件描述符表，这表示文件描述符的分配和释放
(例如，<code>open()</code>、<code>close()</code>、<code>dup()</code>、<code>pipe()</code>和<code>socket()</code>)
对这些进程都可见。若未指定该标志，则不会共享文件描述符表，子进程会获得父进程调用<code>clone()</code>时的文件描述符表的副本。这些复制的文件描述符与父进程的对应文件描述符引用同一文件
(与<code>fork()</code>和<code>vfork()</code>相同)。</p>
<p>　　POSIX线程要求进程的所有线程共享同一文件描述符表。</p>
<h5 id="共享文件系统相关信息">28.2.1.2 共享文件系统相关信息</h5>
<p>　　若指定了标志<code>CLONE_FS</code>，则父进程和子进程会共享文件系统相关信息——umask、根目录和当前工作目录，这表示这些进程中的任一进程调用<code>umask()</code>、<code>chdir()</code>和<code>chroot()</code>也会影响其他进程。若未指定该标志，则父进程和子进程不会共享这些信息
(与<code>fork()</code>和<code>vfork()</code>相同)。</p>
<p>　　<code>CLONE_FS</code>提供的属性共享是POSIX线程所要求的。</p>
<h5 id="共享信号处理方式">28.2.1.3 共享信号处理方式</h5>
<p>　　若指定了标志<code>CLONE_SIGHAND</code>，则父进程和子进程会共享信号处理方式，这表示这些进程中的任一进程通过<code>signal()</code>或<code>sigaction()</code>修改信号处理方式也会影响其他进程。若未指定该标志，则父进程和子进程不会共享信号处理方式，子进程会获得父进程调用<code>clone()</code>时的信号处理方式的副本
(与<code>fork()</code>和<code>vfork()</code>相同)。</p>
<p>　　<code>CLONE_SIGHAND</code>不会影响进程信号掩码和等待信号集，父进程和子进程的信号掩码和等待信号集始终是独立的。对于Linux
2.6及以上版本，若指定了<code>CLONE_SIGHAND</code>，则必须还指定<code>CLONE_VM</code>。</p>
<p>　　POSIX线程要求共享信号处理方式。</p>
<h5 id="共享虚拟内存">28.2.1.4 共享虚拟内存</h5>
<p>　　若指定了标志<code>CLONE_VM</code>，则父进程和子进程会共享虚拟内存页，这表示这些进程中的任一进程通过<code>mmap()</code>和<code>munmap()</code>更新内存映射也会影响其他进程
(与<code>vfork()</code>相同)。若未指定该标志，则父进程和子进程不会共享虚拟内存页，子进程会获得父进程调用<code>clone()</code>时的虚拟内存的副本
(与<code>fork()</code>相同)。</p>
<p>　　共享虚拟内存是线程的关键属性之一，也是POSIX线程所要求的。</p>
<h5 id="线程组">28.2.1.5 线程组</h5>
<p>　　若指定了标志<code>CLONE_THREAD</code>，则将子进程放置在父进程所在的进程组。若未指定该标志，则将子进程放置在自己的进程组。</p>
<p>　　Linux 2.4添加了<span
style="background-color: yellow">线程组</span>，以允许线程库支持POSIX线程要求——进程的所有线程共享同一进程ID。线程组是1组共享相同线程组ID的KSE。在<code>CLONE_THREAD</code>的后续内容中，会将这些KSE称为线程。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_28/a_thread_group_containing_four_threads.svg" class="">
<p>　　线程组中的线程通过系统范围内唯一的线程ID (TID) 区分。Linux
2.4添加了系统调用<code>gettid()</code>，该系统调用允许线程获取自己的线程ID。线程ID使用的数据类型与进程ID的相同，即<code>pid_t</code>。这里的线程ID不同于POSIX线程使用的线程ID
(数据类型为<code>pthread_t</code>)，后者由POSIX线程在内部 (用户空间)
生成和维护。</p>
<p>　　新线程组中的第1个线程是<span
style="background-color: yellow">线程组组长</span>，其线程ID与线程组ID相同。内核会保证没有线程ID会与系统中的任何进程ID相同
(除非线程是进程的线程组组长)。线程组中的所有线程的父进程ID相同
(即线程组组长的线程ID)。只有线程组中的所有线程都终止后，信号<code>SIGCHLD</code>
(或其他终止信号) 才会被发送给其父进程 (这是POSIX线程所要求的)。</p>
<p>　　<code>CLONE_THREAD</code>线程终止时调用<code>clone()</code>的线程不会收到任何信号，所以无法通过<code>wait()</code>
(或类似的函数) 来等待此类线程
(这是POSIX线程所要求的)。POSIX线程不同于进程，需要通过<code>pthread_join()</code>等待
(而非<code>wait()</code>)。为了获取<code>CLONE_THREAD</code>线程的终止状态，需要使用称为<span
style="background-color: yellow">futex</span>的特殊同步原语。</p>
<p>　　若线程组中的任一线程调用<code>exec()</code>，则该线程组中的除线程组组长之外的所有线程都会终止
(这是POSIX线程所要求的)，并且新程序将在线程组组长中执行。在<code>exec()</code>期间，
该进程终止时发送给父进程的终止信号会被重置为<code>SIGCHLD</code>。</p>
<p>　　若线程组中的任一线程调用<code>fork()</code>或<code>vfork()</code>，则该线程组中的所有线程都可以通过<code>wait()</code>
(或类似的函数) 来监控子进程。</p>
<p>　　对于Linux
2.2及以下版本，<code>clone()</code>实现未提供<code>CLONE_THREAD</code>。LinuxThreads将POSIX线程实现为共享虚拟内存等属性的进程
(进程ID不同)。为了保证兼容性，即使对于现代Linux内核，LinuxThreads实现也不会使用该标志，所以LinuxThreads实现中的线程的进程ID不同。</p>
<p>　　对于Linux
2.6及以上版本，若指定了<code>CLONE_THREAD</code>，则必须还指定<code>CLONE_SIGHAND</code>。这是POSIX线程所要求的
(内核对<code>CLONE_THREAD</code>线程组的信号的处理反映了POSIX对进程中的线程如何响应信号的要求)。</p>
<h5 id="线程库支持">28.2.1.6 线程库支持</h5>
<p>　　Linux
2.6添加了标志<code>CLONE_PARENT_SETTID</code>、<code>CLONE_CHILD_SETTID</code>和<code>CLONE_CHILD_CLEARTID</code>来支持POSIX线程实现。这些标志会影响<code>clone()</code>如何处理参数<code>ptid</code>和<code>ctid</code>。</p>
<p>　　标志<code>CLONE_PARENT_SETTID</code>和<code>CLONE_CHILD_CLEARTID</code>用于NPTL线程实现。</p>
<p>　　若指定了标志<code>CLONE_PARENT_SETTID</code>，则内核会将子线程的线程ID写入到<code>ptid</code>指向的位置。线程ID的复制先于父进程内存的复制，这表示即使未指定标志<code>CLONE_VM</code>，父线程和子线程都可以该位置看到子线程的线程ID。</p>
<p>　　标志<code>CLONE_PARENT_SETTID</code>的存在是为了给线程实现提供1种可靠的方法来获取新线程的线程ID，因为仅仅通过<code>clone()</code>的返回值来获取新线程的线程ID是不够的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tid = clone(...);</span><br></pre></td></tr></table></figure>
<p>　　这会导致竞争条件，因为赋值实际发生在<code>clone()</code>之后。假设新线程终止，并且其终止信号的处理函数在赋值之前被调用。此时，信号处理函数通常无法访问<code>tid</code>
(在线程库中，<code>tid</code>可能是全局记录结构中的1个条目，用于跟踪所有线程的状态)。直接调用<code>clone()</code>的程序通常设计为可以避免这个竞争条件，但线程库无法控制调用它的程序的行为。使用标志<code>CLONE_PARENT_SETTID</code>可以确保在<code>clone()</code>返回之前将新线程的线程ID放置<code>ptid</code>指向的位置，进而让线程库避免此类竞争条件。</p>
<p>　　若指定了标志<code>CLONE_CHILD_SETTID</code>，则<code>clone()</code>会将子线程的线程ID写入到<code>ctid</code>指向的位置。<code>ctid</code>的设置仅在子线程的内存中完成
(若指定了标志<code>CLONE_VM</code>，则也会影响父线程)。尽管NPTL不需要该标志，但提供该标志是为了给其他的可能实现库提供灵活性。</p>
<p>　　若指定了标志<code>CLONE_CHILD_CLEARTID</code>，则<code>clone()</code>会在子线程终止时将<code>ctid</code>指向的位置设置为0。</p>
<p>　　参数<code>ctid</code>是NPTL线程实现获取线程终止通知的机制，而这些通知是<code>pthread_join()</code>所需要的。</p>
<p>　　当通过<code>pthread_create()</code>创建子线程时，NPTL会调用<code>clone()</code>来让<code>ptid</code>和<code>ctid</code>指向同一位置
(这也是NPTL为什么不需要<code>CLONE_CHILD_SETTID</code>)。标志<code>CLONE_PARENT_SETTID</code>会导致该位置初始化为新线程的线程ID。当子线程终止时，<code>ctid</code>会被清除，而这些修改对进程的所有线程都是可见的
(因为指定了标志<code>CLONE_VM</code>)。</p>
<p>　　内核处理<code>ctid</code>指向的位置的方式如同futex。线程终止通知可以通过系统调用<code>futex()</code>来获取，该系统调用会阻塞在等待<code>ctid</code>指向的位置的值发生变化
(这就是<code>pthred_join()</code>所做的事情)。内核在清除<code>ctid</code>的同时还会唤醒任一在该地址上执行futex等待而被阻塞的线程
(在POSIX线程级别，这会导致<code>pthred_join()</code>调用解除阻塞)。</p>
<h5 id="线程本地存储">28.2.1.7 线程本地存储</h5>
<p>　　若指定了标志<code>CLONE_SETTLS</code>，则参数<code>tls</code>会指向结构体<code>user_desc</code>，该结构体描述了用于该线程的线程本地存储缓冲区。Linux
2.6添加了该标志来支持线程本地存储的NPTL实现。</p>
<h5 id="共享system-v信号量撤销值">28.2.1.8 共享System V信号量撤销值</h5>
<p>　　若指定了标志<code>CLONE_SYSVSEM</code>，则父进程和子进程会共享System
V信号量撤销值列表。若未指定该标志，则父进程和子进程的撤销列表独立，并且子进程的撤销列表初始为空。</p>
<p>　　Linux
2.6开始支持标志<code>CLONE_SYSVSEM</code>，并且提供了POSIX线程所需的共享语义。</p>
<h5 id="进程级挂载命名空间">28.2.1.9 进程级挂载命名空间</h5>
<p>　　父进程和子进程默认共享挂载命名空间
(见14.7)，这表示这些进程中的任一进程通过<code>mount()</code>和<code>umount()</code>对挂载命名空间的修改对其他进程是可见的
(与<code>fork()</code>和<code>vfork()</code>相同)。特权进程
(能力<code>CAP_SYS_ADMIN</code>)
可以指定标志<code>CLONE_NEWNS</code>来让子进程获得父进程的挂载命名空间的副本。此后，这些进程中的任一进程通过<code>mount()</code>和<code>umount()</code>对挂载命名空间的修改对其他进程不可见。</p>
<p>　　进程级挂载命名空间可用于创建与chroot
jail类似的环境列表。相比chroot jail，这种方式更安全和灵活
(例如，可以为jail中的进程提供1个对系统中的其他进程不可见的挂载点)。挂载命名空间在设置虚拟服务器环境时也很有用。</p>
<p>　　调用<code>clone()</code>时同时指定标志<code>CLONE_NEWNS</code>和<code>CLONE_FS</code>是没有意义的，也是不允许的。</p>
<h5 id="让子进程的父进程与调用进程的父进程相同">28.2.1.10
让子进程的父进程与调用进程的父进程相同</h5>
<p>　　当通过<code>clone()</code>创建新进程时，新进程的父进程默认是调用<code>clone()</code>的进程
(与<code>forK()</code>和<code>vforK()</code>相同)。若指定了标志<code>CLONE_PARENT</code>，则新进程的父进程将会是调用<code>clone()</code>的进程的父进程。当新进程终止时，信号会被发送给调用<code>clone()</code>的进程的父进程。</p>
<p>　　Linux
2.4开始支持标志<code>CLONE_PARENT</code>。该标志最初设计为供POSIX线程实现使用。但是，Linux
2.6使用了1种无需使用该标志的实现线程的方式，从而消除了对该标志的依赖。</p>
<h5 id="让子进程的进程id与父进程的进程id相同">28.2.1.11
让子进程的进程ID与父进程的进程ID相同</h5>
<p>　　若指定了标志<code>CLONE_PID</code>，则子进程的进程ID会与父进程的进程ID相同。若未指定该标志，则父进程的进程ID与子进程的进程ID不同
(与<code>forK()</code>和<code>vforK()</code>相同)。只有系统引导进程
(进程ID为0) 可以指定该标志 (初始化多处理器系统时)。</p>
<p>　　标志<code>CLONE_PID</code>不适用于用户应用程序。对于Linux
2.6，该标志被删除，并被标志<code>CLONE_IDLETASK</code>取代，后者会将新进程的进程ID设置为0。<code>CLONE_IDLETASK</code>仅供内核内部使用
(若调用<code>clone()</code>时指定了该标志，则会被忽略)。该标志用于创建不可见的CPU级空闲进程，在多处理器系统中，该进程可能存在多个实例。</p>
<h5 id="进程跟踪">28.2.1.12 进程跟踪</h5>
<p>　　若指定了标志<code>CLONE_PTRACE</code>，并且调用进程正在被跟踪，则子进程也会被跟踪
(进程跟踪详情见<code>ptrace()</code>的手册页)。对于Linux
2.6及以上版本，可以指定标志<code>CLONE_UNTRACED</code>，这会导致正在被跟踪的调用进程无法强制将<code>CLONE_PTRACE</code>应用于子进程。标志<code>CLONE_UNTRACED</code>在创建内核线程时供内核内部使用。</p>
<h5 id="挂起父进程直到子进程退出或调用exec">28.2.1.13
挂起父进程，直到子进程退出或调用<code>exec()</code></h5>
<p>　　若指定了标志<code>CLONE_VFORK</code>，则父进程会被挂起，直到子进程通过<code>exec()</code>或<code>_exit()</code>
(或<code>exit()</code>) 释放其虚拟内存资源
(与<code>vfork()</code>相同)。</p>
<h5 id="用于支持容器的新clone标志">28.2.1.14
用于支持容器的新<code>clone()</code>标志</h5>
<p>　　Linux
2.6.19及以上版本添加了<code>clone()</code>标志<code>CLONE_IO</code>、<code>CLONE_NEWIPC</code>、<code>CLONE_NEWNET</code>、<code>CLONE_NEWPID</code>、<code>CLONE_NEWUSER</code>和<code>CLONE_NEWUTS</code>。</p>
<p>　　这些标志大多是为了支持<span
style="background-color: yellow">容器</span>实现而提供的。容器是轻量级虚拟化的形式之一，通过这种形式，在同一内核上运行的进程组可以在看似独立机器的环境中彼此隔离。此外，容器还可以嵌套。容器与完全虚拟化形成对比，在完全虚拟化中，所有虚拟化环境都运行不同的内核。</p>
<p>　　为了实现容器，内核开发者必须在内核中为每个全局系统资源
(例如，进程ID、网络栈、<code>uname()</code>返回的ID、System V
IPC对象以及用户和组ID命名空间)
提供1个间接层，以便每个容器可以提供自己的这些资源实例。</p>
<p>　　容器有多种可能的用途，包括如下：</p>
<p>　　● 控制网络带宽和CPU时间等系统资源的分配
(例如，某个容器可能被授予75%的CPU时间，而另一个容器被授予25%的CPU时间)。</p>
<p>　　● 在单个主机上提供多个轻量级虚拟化服务器。</p>
<p>　　● 冻结容器，以便暂停容器中所有进程的执行，随后重新启动
(可能迁移到其他机器上)。</p>
<p>　　● 通过冻结容器来转储 (创建检查点) 应用程序的状态并在稍后恢复
(可能是在应用程序崩溃或系统关闭后)，以便从检查点的时间继续计算。</p>
<h5 id="clone标志的用法">28.2.1.15 <code>clone()</code>标志的用法</h5>
<p>　　
<code>forK()</code>大致可以视为仅指定了标志<code>SIGCHLD</code>的<code>clone()</code>，
而<code>vforK()</code>可以视为指定了以下标志的<code>clone()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CLONE_VM | CLONE_VFORK | SIGCHLD</span><br></pre></td></tr></table></figure>
<p>　　LinuxThreads线程实现使用<code>clone()</code> (仅使用前4个参数)
创建线程会指定以下标志：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND</span><br></pre></td></tr></table></figure>
<p>　　NPTL线程实现使用<code>clone()</code> (使用所有参数)
创建线程会指定以下标志：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD |</span><br><span class="line">CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</span><br></pre></td></tr></table></figure>
<p>　　从版本2.3.3开始，作为NPTL线程实现的一部分的glibc的<code>fork()</code>包装函数绕过了内核的系统调用<code>fork()</code>，直接调用<code>clone()</code>。这个包装函数会调用由调用者使用<code>pthread_atfork()</code>注册的任何fork处理函数。</p>
<h4 id="克隆子进程的waitpid扩展">28.2.2
克隆子进程的<code>waitpid()</code>扩展</h4>
<p>　　为了等待通过<code>clone()</code>创建的子进程，<code>waitpid()</code>、<code>wait3()</code>和<code>wait4()</code>的位掩码参数<code>options</code>可以包含特定于Linux的附加位<code>__WCLONE</code>、<code>__WALL</code>和<code>__WNOTHREAD</code>。</p>
<p>　　● 若指定了<code>__WCLONE</code>，则仅等待<span
style="background-color: yellow">克隆子进程</span>。若未指定该值，则等待非克隆子进程。这里的克隆子进程是指终止时发送给父进程的信号是<code>SIGCHLD</code>之外的信号的子进程。若还指定了<code>__WALL</code>，则<code>__WCLONE</code>会被忽略。</p>
<p>　　● 若指定了<code>__WALL</code> (Linux
2.4及以上版本)，则等待所有子进程 (无论是否为克隆子进程)。</p>
<p>　　● 若指定了<code>__WNOTHREAD</code> (Linux
2.4及以上版本)，则仅等待调用进程的子进程
(在默认情况下，等待调用会等待调用进程所属线程组中的所有进程的子进程)。</p>
<p>　　这些位不能与<code>waitid()</code>一起使用。</p>
<h3 id="进程创建速度">28.3 进程创建速度</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 29%" />
<col style="width: 29%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr>
<th>创建进程的使用方法</th>
<th>1.70M的进程内存</th>
<th>2.70M的进程内存</th>
<th>11.70M的进程内存</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fork()</code></td>
<td>用时22.27 (7.99) 秒，进程创建速度为4544个进程/秒</td>
<td>用时26.38 (8.98) 秒，进程创建速度为为4135个进程/秒</td>
<td>用时126.38 (52.55)秒，进程创建速度为为1276个进程/秒</td>
</tr>
<tr>
<td><code>vfork()</code></td>
<td>用时3.52 (2.49) 秒，进程创建速度为28955个进程/秒</td>
<td>用时3.55 (2.50) 秒，进程创建速度为为28621个进程/秒</td>
<td>用时3.53 (2.51) 秒，进程创建速度为为28810个进程/秒</td>
</tr>
<tr>
<td><code>clone()</code></td>
<td>用时2.97 (2.14) 秒，进程创建速度为34333个进程/秒</td>
<td>用时2.98 (2.13) 秒，进程创建速度为为34217个进程/秒</td>
<td>用时2.93 (2.10) 秒，进程创建速度为为34688个进程/秒</td>
</tr>
<tr>
<td><code>fork()</code> + <code>exec()</code></td>
<td>用时135.72 (12.39) 秒，进程创建速度为为764个进程/秒</td>
<td>用时146.15 (16.69) 秒，进程创建速度为为719个进程/秒</td>
<td>用时260.34 (61.68) 秒，进程创建速度为为435个进程/秒</td>
</tr>
<tr>
<td><code>vfork()</code> + <code>exec()</code></td>
<td>用时107.36 (6.27) 秒，进程创建速度为为969个进程/秒</td>
<td>用时107.81 (6.35) 秒，进程创建速度为为964个进程/秒</td>
<td>用时107.97 (6.38) 秒，进程创建速度为为960个进程/秒</td>
</tr>
</tbody>
</table>
<p>　　上表列出了不同进程创建方法的速度比较。测试程序会循环创建子进程并等待其终止。此外，上表还展示了不同进程内存大小对进程创建速度的影响。进程内存大小的差异通过在计时前让程序使用<code>malloc()</code>在堆上分配额外内存来模拟
(进程内存的值取自命令<code>ps –o "pid vsz cmd"</code>的结果的VSZ值)。</p>
<p>　　对于每个进程，上表提供展示了2种类型的统计数据：</p>
<p>　　● 第1个统计数据是时间。主要测量执行100000个进程创建操作所有的总
(实际)
时间。括号中的时间是父进程使用的CPU时间。因为这些测试是在没有负载的机器上进行，所以这2个时间值之间的差值表示测试期间创建的子进程所使用的总时间。</p>
<p>　　● 第2个统计数据是进程创建速度。</p>
<p>　　这些数据是每种情况运行20次的平均值，使用的是x86-32系统上运行的内核2.6.27。</p>
<p>　　前3行展示了简单进程创建 (子进程不会执行新程序)
的时间。对于每种情况，子进程在被创建后会立即终止，然后父进程在等待子进程终止后继续创建下一个子进程
(<code>vfork()</code>和<code>clone()</code>数据的细微变化是因为采样误差和调用差异)。</p>
<p>　　第1行展示了<code>fork()</code>的数据。随着进程内存的增加，<code>fork()</code>的用时更长。这些时间差体现了为子进程复制越来越大的页表并将所有数据、堆和栈段页标记为只读所需的额外时间
(这里实际上不会复制页，因为子进程不会修改其数据段或栈)。</p>
<p>　　第2行展示了<code>vfork()</code>的数据。随着进程内存的增加，<code>vfork()</code>的用时不变。因为<code>vfork()</code>不会复制页表或页，所以调用进程的虚拟内存大小对其没有影响。</p>
<p>　　第3行展示了<code>clone()</code>指定以下标志时的数据
(这里的时间是基于glibc的<code>clone()</code>包装函数，而非直接调用<code>sys_clone()</code>。这里未展示的其他测试表明，在子进程立即退出的情况下，两者之间的时间差异可以忽略不计)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CLONE_VM | CLONE_VFORK | CLONE_FS | CLONE_SIGHAND | CLONE_FILES</span><br></pre></td></tr></table></figure>
<p>　　前2个标志用于模拟<code>vfork()</code>，其他标志用于指定父进程和子进程应该共享其他文件系统属性
(umask、根目录和当前工作目录)、信号处理方式和打开的文件描述符表。<code>vfork()</code>和<code>clone()</code>的数据之间的差异表示<code>vfork()</code>执行的一些额外操作，这些操作用于将这些信息复制到子进程。复制文件系统属性和信号处理方式的时间是不变的。但是，复制打开的文件描述符表的时间会随着描述符的数量而变化。当进程内存为1.70MB时，若在父进程中打开100个文件描述符，则<code>vfork()</code>的总耗时会从3.52秒增加到5.04秒，但<code>clone()</code>不受影响。</p>
<p>　　<code>fork()</code>和<code>vfork()</code>之间的差异非常明显。但是，需要注意以下几点：</p>
<p>　　●
最后1列的数据表明，对于较大的进程，<code>vfork()</code>比<code>fork()</code>快30倍以上
(常规进程的数据大致位于前2列)。</p>
<p>　　●
由于创建进程所需的时间通常比<code>exec()</code>所需的时间短很多，所以当<code>fork()</code>或<code>vfork()</code>后立即调用<code>exec()</code>时，差距就不会那么明显。这在上表的最后2行得到了体现，在这些数据中，每个子进程都会调用<code>exec()</code>
(而非立即退出)。这里执行的程序是命令<code>true</code>
(即<code>/bin/true</code>，选择它是因为不会产生任何输出)。在这种情况下，<code>fork()</code>和<code>vfork()</code>的相对差异小很多。</p>
<p>　　实际上，上表的数据并未揭示<code>exec()</code>的全部成本，因为子进程在测试的每个循环中都执行同一程序。因此，将程序读取到内存的磁盘I/O成本基本上被消除了
(程序在第1次调用<code>exec()</code>时会被读取到内核缓冲区缓存，并一直留在那里)。若测试的每次循环都执行不同的程序
(例如，同一程序的不同命名副本)，则<code>exec()</code>的成本会更大。</p>
<h3 id="exec和fork对进程属性的影响">28.4
<code>exec()</code>和<code>fork()</code>对进程属性的影响</h3>
<p>　　下表列出了进程调用<code>exec()</code>对进程属性的影响和调用<code>fork()</code>后子进程继承的进程属性
(<code>exec()</code>列表示<code>exec()</code>期间哪些进程属性会被保留。<code>fork()</code>列表示<code>fork()</code>后子进程继承或共享的进程属性。除了标记为特定于Linux的进程属性之外，其他所有列出的进程属性均出现在标准UNIX实现中，并且它们在<code>exec()</code>和<code>fork()</code>期间的处理符合SUSv3的要求)：</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 6%" />
<col style="width: 4%" />
<col style="width: 30%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>进程属性</th>
<th><code>exec()</code></th>
<th><code>fork()</code></th>
<th>影响进程属性的接口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本段</td>
<td>✕</td>
<td>共享</td>
<td></td>
<td>子进程与父进程共享文本段</td>
</tr>
<tr>
<td>栈段</td>
<td>✕</td>
<td>✓</td>
<td><code>allloca()</code>、<code>longjmp()</code>和<code>siglongjmp()</code></td>
<td>函数入口/出口</td>
</tr>
<tr>
<td>数据和堆段</td>
<td>✕</td>
<td>✓</td>
<td><code>brk()</code>和<code>sbrk()</code></td>
<td></td>
</tr>
<tr>
<td>环境变量</td>
<td>✓</td>
<td>✓</td>
<td><code>putenv()</code>和<code>setenv()</code></td>
<td>直接修改环境列表
(环境变量会被<code>execle()</code>和<code>execve()</code>覆盖，其余的<code>exec()</code>调用会保留环境列表)</td>
</tr>
<tr>
<td>内存映射</td>
<td>✕</td>
<td>✓</td>
<td><code>mmap()</code>和<code>munmap()</code></td>
<td>被标记为<code>madvise(MADV_DONTFORK)</code>的映射在<code>forK()</code>后不会被继承。映射的标志<code>MAP_NORESERVE</code>在<code>fork()</code>后会被继承</td>
</tr>
<tr>
<td>内存锁</td>
<td>✕</td>
<td>✕</td>
<td><code>mlock()</code>和<code>munlock()</code></td>
<td></td>
</tr>
<tr>
<td>进程ID</td>
<td>✓</td>
<td>✕</td>
<td></td>
<td></td>
</tr>
<tr>
<td>父进程ID</td>
<td>✓</td>
<td>✕</td>
<td></td>
<td></td>
</tr>
<tr>
<td>进程组ID</td>
<td>✓</td>
<td>✓</td>
<td><code>setpgid()</code></td>
<td></td>
</tr>
<tr>
<td>会话ID</td>
<td>✓</td>
<td>✓</td>
<td><code>setsid()</code></td>
<td></td>
</tr>
<tr>
<td>实际ID</td>
<td>✓</td>
<td>✓</td>
<td><code>setuid()</code>、<code>setgid()</code>和相关调用</td>
<td></td>
</tr>
<tr>
<td>有效ID、保存的set-user-ID和保存的set-group-ID</td>
<td>✓</td>
<td>✓</td>
<td><code>setuid()</code>、<code>setgid()</code>和相关调用</td>
<td>见第9章</td>
</tr>
<tr>
<td>辅助组ID</td>
<td>✓</td>
<td>✓</td>
<td><code>setgroups()</code>和<code>initgroups()</code></td>
<td></td>
</tr>
<tr>
<td>打开的文件描述符</td>
<td>✓</td>
<td>✓</td>
<td><code>open()</code>、<code>close()</code>、<code>dup()</code>、<code>pipe()</code>、<code>socket()</code>等函数</td>
<td>文件描述符在<code>exec()</code>期间会被保留，除非启用了close-on-exec标志。子进程的文件描述符和父进程的对应文件描述符引用同一文件
(见第5章)</td>
</tr>
<tr>
<td>close-on-exec标志</td>
<td>✓ (若未启用)</td>
<td>✓</td>
<td><code>fcntl(F_SETFD)</code></td>
<td></td>
</tr>
<tr>
<td>文件偏移量</td>
<td>✓</td>
<td>共享</td>
<td><code>lseek()</code>、<code>read()</code>、<code>write()</code>、<code>readv()</code>和<code>writev()</code></td>
<td>子进程与父进程共享文件偏移量</td>
</tr>
<tr>
<td>打开文件状态标志</td>
<td>✓</td>
<td>共享</td>
<td><code>open()</code>和<code>fcntl(F_SETFL)</code></td>
<td>子进程与父进程共享打开文件状态标志</td>
</tr>
<tr>
<td>异步I/O操作</td>
<td>✓</td>
<td>✕</td>
<td><code>aio_read()</code>、<code>aio_write()</code>和相关调用</td>
<td>未完成的操作在<code>exec()</code>期间会被取消</td>
</tr>
<tr>
<td>目录流</td>
<td>✕</td>
<td>✓</td>
<td><code>opendir()</code>和<code>readdir()</code></td>
<td>SUSv3规定，子进程会获得父进程目录流的副本，但这些副本可能会共享
(或不共享) 目录流的位置。对于Linux，目录流的位置不会共享</td>
</tr>
<tr>
<td>当前工作目录</td>
<td>✓</td>
<td>✓</td>
<td><code>chdir()</code></td>
<td></td>
</tr>
<tr>
<td>根目录</td>
<td>✓</td>
<td>✓</td>
<td><code>chroot()</code></td>
<td></td>
</tr>
<tr>
<td>文件模式创建掩码</td>
<td>✓</td>
<td>✓</td>
<td><code>umask()</code></td>
<td></td>
</tr>
<tr>
<td>信号处理方式</td>
<td>✓</td>
<td>✓</td>
<td><code>signal()</code>和<code>sigaction()</code></td>
<td>在<code>exec()</code>期间，处理方式是默认或被忽略的信号的处理方式保持不变，其他信号的处理方式将会被设置为默认
(见27.4)</td>
</tr>
<tr>
<td>信号掩码</td>
<td>✓</td>
<td>✓</td>
<td><code>sigprocmask()</code>和<code>sigaction()</code></td>
<td></td>
</tr>
<tr>
<td>待处理信号集</td>
<td>✓</td>
<td>✕</td>
<td><code>raise()</code>、<code>kill()</code>和<code>sigqueue()</code></td>
<td></td>
</tr>
<tr>
<td>备用信号栈</td>
<td>✕</td>
<td>✓</td>
<td><code>sigaltstack()</code></td>
<td></td>
</tr>
<tr>
<td>间隔定时器</td>
<td>✓</td>
<td>✕</td>
<td><code>setitimer()</code></td>
<td></td>
</tr>
<tr>
<td>由<code>alarm()</code>设置的定时器</td>
<td>✓</td>
<td>✕</td>
<td><code>alarm()</code></td>
<td></td>
</tr>
<tr>
<td>POSIX定时器</td>
<td>✕</td>
<td>✕</td>
<td><code>timer_create()</code>和相关调用</td>
<td></td>
</tr>
<tr>
<td>线程</td>
<td>✕</td>
<td>✓</td>
<td></td>
<td>在<code>fork()</code>期间，只有调用线程会在子进程中复制</td>
</tr>
<tr>
<td>线程可取消状态和类型</td>
<td>✕</td>
<td>✓</td>
<td></td>
<td>在<code>exec()</code>后，可取消类型和状态会被分别重置为<code>PTHREAD_CANCEL_ENABLE</code>和<code>PTHREAD_CANCEL_DEFERRED</code></td>
</tr>
<tr>
<td>互斥锁和条件变量</td>
<td>✕</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>nice值</td>
<td>✓</td>
<td>✓</td>
<td><code>nice()</code>和<code>setpriority()</code></td>
<td></td>
</tr>
<tr>
<td>调度策略和优先级</td>
<td>✓</td>
<td>✓</td>
<td><code>sched_setscheduler()</code>和<code>sched_setparam()</code></td>
<td></td>
</tr>
<tr>
<td>资源限制</td>
<td>✓</td>
<td>✓</td>
<td><code>setrlimit()</code></td>
<td></td>
</tr>
<tr>
<td>进程和子进程CPU时间</td>
<td>✓</td>
<td>✕</td>
<td></td>
<td>由<code>times()</code>返回</td>
</tr>
<tr>
<td>资源使用情况</td>
<td>✓</td>
<td>✕</td>
<td></td>
<td>由<code>getrusage()</code>返回</td>
</tr>
<tr>
<td>System V共享内存段</td>
<td>✕</td>
<td>✓</td>
<td><code>shmat()</code>和<code>shmdt()</code></td>
<td></td>
</tr>
<tr>
<td>POSIX共享内存</td>
<td>✕</td>
<td>✓</td>
<td><code>shm_open()</code>和相关调用</td>
<td></td>
</tr>
<tr>
<td>POSIX消息队列</td>
<td>✕</td>
<td>✓</td>
<td><code>mq_open()</code>和相关调用</td>
<td>子进程的描述符与父进程的对应描述符引用同一打开消息队列描述。子进程不会继承父进程的消息通知注册</td>
</tr>
<tr>
<td>POSIX命名信号量</td>
<td>✕</td>
<td>共享</td>
<td><code>sem_open()</code>和相关调用</td>
<td>子进程与父进程共享相同信号量的引用</td>
</tr>
<tr>
<td>POSIX未命名信号量</td>
<td>✕</td>
<td>✓</td>
<td><code>sem_init()</code>和相关调用</td>
<td>若信号量位于共享内存区域，则子进程与父进程共享信号量；否则，子进程拥有自己的信号量副本</td>
</tr>
<tr>
<td>System V信号量调整</td>
<td>✓</td>
<td>✕</td>
<td><code>semop()</code></td>
<td></td>
</tr>
<tr>
<td>文件锁</td>
<td>✓</td>
<td>✓</td>
<td><code>flock()</code></td>
<td>子进程继承与父进程相同的锁的引用</td>
</tr>
<tr>
<td>记录锁</td>
<td>✓</td>
<td>✕</td>
<td><code>fcntl(F_SETLK)</code></td>
<td>在<code>exec()</code>期间，锁将被保留，除非引用文件的文件描述符被标记为close-on-exec</td>
</tr>
<tr>
<td>区域设置</td>
<td>✕</td>
<td>✓</td>
<td><code>setlocale()</code></td>
<td>作作为C运行时初始化的一部分，等同于<code>setlocale(LC_ALL, "C")</code>的命令会在执行新程序后被执行</td>
</tr>
<tr>
<td>浮点环境</td>
<td>✕</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>控制终端</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>当执行新程序时，浮点环境的状态会被重置为默认</td>
</tr>
<tr>
<td>退出处理函数</td>
<td>✕</td>
<td>✓</td>
<td><code>atexit()</code>和<code>on_exit()</code></td>
<td></td>
</tr>
<tr>
<td>文件系统ID</td>
<td>✓</td>
<td>✓</td>
<td><code>setfsuid()</code>和<code>setfsgid()</code></td>
<td>这些ID会在对应的有效ID更改时随之更改</td>
</tr>
<tr>
<td>timerfd定时器</td>
<td>✓</td>
<td>✓</td>
<td><code>timerfd_create()</code></td>
<td>子进程会继承引用与父进程相同定时器的文件描述符</td>
</tr>
<tr>
<td>能力</td>
<td>✓</td>
<td>✓</td>
<td><code>capset()</code></td>
<td></td>
</tr>
<tr>
<td>能力边界集</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能力securebits标志</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>在<code>exec()</code>期间，除<code>SECBIT_KEEP_CAPS</code>之外的所有securebits标志都会被保留
(<code>SECBIT_KEEP_CAPS</code>总是会被清除)</td>
</tr>
<tr>
<td>CPU亲和性</td>
<td>✓</td>
<td>✓</td>
<td><code>sched_setaffinity()</code></td>
<td></td>
</tr>
<tr>
<td><code>SCHED_RESET_ON_FORK</code></td>
<td>✓</td>
<td>✕</td>
<td></td>
<td></td>
</tr>
<tr>
<td>允许的CPU</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>见cpuset文件系统</td>
</tr>
<tr>
<td>允许的内存节点</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>见cpuset文件系统</td>
</tr>
<tr>
<td>内存策略</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>见<code>set_mempolicy()</code></td>
</tr>
<tr>
<td>文件租约</td>
<td>✓</td>
<td>✓</td>
<td><code>fcntl(F_SETLEASE)</code></td>
<td>子进程会继承与父进程相同的租约引用</td>
</tr>
<tr>
<td>目录修改通知</td>
<td>✓</td>
<td>✕</td>
<td>dnotify API</td>
<td></td>
</tr>
<tr>
<td><code>prctl(PR_SET_DUMPABLE)</code></td>
<td>✓</td>
<td>✕</td>
<td></td>
<td>在<code>exec()</code>期间，除了set-user-ID程序和set-group-ID程序之外的所有程序的标志<code>PR_SET_DUMPABLE</code>会被设置
(set-user-ID程序和set-group-ID程序程序的该标志会被清除)</td>
</tr>
<tr>
<td><code>prctl(PR_SET_PDEATHSIG)</code></td>
<td>✕</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>oom_adj</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>coredump_filter</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第31章 线程：线程安全和线程级存储</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_31/</url>
    <content><![CDATA[<p>　　若函数可以被多个线程同时调用，则该函数是<span
style="background-color: yellow">线程安全函数</span>；否则，该函数是非线程安全函数。SUSv3说明的大部分函数都是线程安全函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> glob = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">incr</span><span class="params">(<span class="type">int</span> loops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> loc, j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; loops; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        loc = glob;</span><br><span class="line">        loc++;</span><br><span class="line">        glob = loc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>incr()</code>是非线程安全函数。当多个线程同时调用该函数时，<code>glob</code>的最终值将是不确定的。这个函数说明了函数是非线程安全函数的典型原因：使用了由所有线程共享的全局变量或静态变量。</p>
<p>　　让函数成为线程安全函数的方法有多种。最简单的方法是直接将整个函数关联互斥锁，这表示同时只能有1个线程执行该函数，此时，对该函数的访问是<span
style="background-color: yellow">序列化</span>的。若线程需要花费大量时间来执行该函数，则这种序列化将导致并发性损失，因为程序的线程无法并行执行。更复杂的方法是将共享变量关联互斥锁，这需要确定临界区，并仅在执行临界区期间获取和释放互斥锁。这允许多个线程同时执行该函数和并行操作，除非多个线程都需要执行临界区。</p>
<p>　　尽管通过临界区来实现线程安全比将整个函数关联互斥锁更高效，但这种方法还是会带来性能影响，因为加锁和解锁是有成本的。<span
style="background-color: yellow">可重入函数</span>是在不使用互斥锁的情况下实现线程安全的函数，因为此类函数通过不使用全局变量和静态变量来实现线程安全。对于可重入函数，所有信息都会返回给调用者，或者函数调用之间维护的信息都存储在调用者分配的缓冲区中。但是，并非所有函数都能以这种方式方式实现，原因如下：</p>
<p>　　●
有些必须要使用全局数据结构。malloc库中的函数就是很好的示例，这些函数在堆上维护了1个空闲内存快的全局链表。这些函数只能通过互斥锁来实现线程安全。</p>
<p>　　● 有些函数 (在线程出现之前)
具有根据定义不可重入的接口，因为它们会返回由函数静态分配的指针或使用静态存储来维护对同一
(或相关) 函数的连续调用之间的信息。例如，函数<code>asctime()</code>
(见10.2.3.1) 会返回静态分配的日期时间字符串。</p>
<p>　　对于部分具有不可重入接口的函数，SUSv3要求对应的可重入版本以后缀<code>_r</code>结尾
(例如，<code>asctime_r()</code>)。这些函数要求调用者分配缓冲区，并将缓冲区的地址作为参数传递
(用于返回结果)。这允许调用线程将局部 (栈) 变量作为函数结果缓冲区。</p>
<p>　　有些实现也提供了其他传统不可重入函数的可重入版本
(例如，glibc的<code>crypt_r()</code>)。但是，可移植应用程序应该避免使用这些函数的可重入版本，因为其他实现可能没有提供这些函数的可重入版本。此外，在某些情况下，SUSv3没有说明某些传统函数的可重入版本，因为存在比这些函数更高效的可重入替代函数。</p>
<span id="more"></span>
<h3 id="一次性初始化">31.1 一次性初始化</h3>
<p>　　有时，多线程应用程序可能需要确保某些初始化行为只会发生1次，无论创建了多少个线程。当主线程创建线程时，这很容易实现——只需要在创建依赖于该初始化的线程之前执行初始化。但是，这不适用于库函数，因为主线程可能在调用库函数之前创建了线程。因此，库函数需要1种在任何线程第1次调用该函数时执行初始化的方法，这正是函数<code>pthread_once()</code>的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init)(<span class="type">void</span>))</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_once()</code>会使用参数<code>once_control</code>指定的状态来确保参数<code>init</code>指向的调用者定义的函数只会被调用1次，无论调用线程调用<code>pthread_once()</code>多少次或多少个不同的线程调用<code>pthread_once()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_once_t</span> once_var = PTHREAD_ONCE_INIT;</span><br></pre></td></tr></table></figure>
<p>　　<code>once_control</code>指向的变量必须使用值<code>PTHREAD_ONCE_INIT</code>静态初始化。当第1次调用<code>pthread_once()</code>时，若指定了指向特定<code>pthread_once_t</code>变量的指针，则会修改<code>once_control</code>指向的变量的值，以便后续调用该函数时不再调用<code>init</code>指向的函数。</p>
<p>　　<code>pthread_once()</code>存在的主要原因是，对于Pthreads早期版本，无法静态初始化互斥锁。相反，初始化互斥锁必须通过<code>pthread_mutex_init()</code>完成。鉴于后来添加了静态分配的互斥锁，库函数可以使用静态分配的互斥锁和静态Boolean变量来执行一次性初始化。尽管如此，<code>pthread_once()</code>仍然被保留为1种便利方法。</p>
<h3 id="线程特定数据">31.2 线程特定数据</h3>
<p>　　让函数线程安全的最高效的方式是使其可重入。所有新的库函数都应该以这种方式实现。但是，对于现有的不可重入库函数
(可能在线程普及之前设计的函数)，这种方式需要修改函数的接口，这表示需要修改所有使用了该函数的程序。</p>
<p>　　<strong>线程特定数据</strong> (TSD)
是1种无需修改现有函数接口即可使其线程安全的技术。这种技术的成本略高于让函数可重入，但可以保证调用该函数的程序不变。</p>
<p>　　线程特定数据允许函数为调用该函数的每个线程<span
style="background-color: yellow">维护1个变量的独立副本</span>。线程特定数据具有持久性，每个线程的变量在该线程多次调用该函数之间持续存在。这使得函数能够在函数调用之间维护每个线程的信息，并允许函数将不同的结果缓冲区传递给调用线程
(若有必要)。</p>
<p>　　为了理解线程特定数据API的用法，需要从使用线程特定数据的库函数的角度考虑问题：</p>
<p>　　●
函数必须为每个调用该函数的线程分配1个独立的存储块，该存储块只需要被分配1次，即线程第1次调用该函数时。</p>
<p>　　●
当线程后续调用该函数时，函数需要获取该线程第1次调用该函数时分配的存储块的地址。函数不能将指向存储块的指针维护为自动变量，因为函数返回时自动变量会被释放；函数也不能将指向存储块的指针维护为静态变量，因为静态变量在进程中只有1个实例。Pthreads
API提供了函数来执行该任务。</p>
<p>　　●
多个函数可能都需要线程特定数据。这些函数需要1种方法来识别其线程特定数据
(1个键)，以区别于其他函数使用的线程特定数据。</p>
<p>　　●
函数无法直接控制线程终止时发生的事情。当线程终止时，可能正在执行该函数之外的其他代码。尽管如此，必须存在某种机制来保证线程终止时会自动释放为该线程分配的存储块
(因为不这样做可能会导致内存泄漏)。</p>
<h4 id="线程特定数据概述">31.2.1 线程特定数据概述</h4>
<p>　　库函数使用线程特定数据的步骤通常如下：</p>
<p>　　1)
函数创建1个键，用于区分该函数使用的线程特定数据与其他函数使用的线程特定数据。该键通过调用函数<code>pthread_key_create()</code>生成。创建键只需要在线程第1次调用函数时完成
(通过<code>pthread_once()</code>)。创建键不会分配任何线程特定数据块。</p>
<p>　　2)
调用<code>pthread_key_create()</code>还有1个目的：允许调用者指定程序员定义的析构函数
(用于释放该键对应的存储块)
的地址。当使用了线程特定数据的线程终止时，Pthreads
API会自动调用析构函数，并传递1个指向该线程的数据块的指针。</p>
<p>　　3) 函数会为调用该函数的所有线程都分配1个线程特定数据块
(通过<code>malloc()</code>等函数)，这发生在线程第1次调用该函数时。</p>
<p>　　4)
通过函数<code>pthread_setspecific()</code>和<code>pthread_getspecific()</code>保存指向第3步分配的数据块的指针。前者会向Pthreads实现发送请求，要求它
"保存该指针，并记录它与特定键 (该函数的键) 和特定线程 (调用线程)
相关联的事实"。后者会执行与前者互补的任务，即返回之前与调用线程的给定键关联的指针。若没有指针与给定键和线程关联，则返回<code>NULL</code>。这样，函数就可以确定它是第1次被线程调用，所以必须为线程分配存储块。</p>
<h4 id="pthread_key_create">31.2.2
<code>pthread_key_create()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span> *))</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_key_create()</code>会创建1个线程特定数据键，并将其存储在参数<code>key</code>指向的缓冲区中。由于进程的所有线程都会使用该键，所以<code>key</code>应该指向全局变量。</p>
<p>　　参数<code>destructor</code>指向由程序员定义的析构函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dest</span><span class="params">(<span class="type">void</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 释放value指向的内存区域 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　当线程终止时，若存在与键关联的析构函数
(调用<code>pthread_key_create()</code>时<code>destructor</code>不为<code>NULL</code>)
和线程特定数据，则会以线程特定数据的地址作为参数调用析构函数。若不需要析构函数，则可以将<code>destructor</code>指定为<code>NULL</code>。</p>
<p>　　若线程有多个线程特定数据块，则析构函数的调用顺序是不确定的。析构函数应该被设计为彼此相互独立。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_31/implementation_of_thread-specific_data_keys.svg" class="">
<p>　　典型的线程特定数据实现 (即NPTL) 会涉及1个关于线程特定数据键的
(进程级)
全局信息数组和1组线程级数组，线程级数组包含指向为特定线程分配的所有线程特定数据块的指针
(通过调用<code>pthread_setspecific()</code>获取的指针)。对于该实现，<code>pthread_key_create()</code>返回的<code>pthread_key_t</code>值是全局数组的索引。该数组的元素是包含2个成员的结构体，第1个成员表示该元素是否正在使用
(即之前已通过<code>pthread_key_create()</code>分配)，第2个成员用于存储指向该键对应的线程特定数据块的析构函数的指针
(即<code>pthread_key_create()</code>的参数<code>destructor</code>的副本)。</p>
<h4 id="pthread_setspecific和pthread_getspecific">31.2.3
<code>pthread_setspecific()</code>和<code>pthread_getspecific()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>; <span class="comment">/* 存在与key关联的线程特定数据块时返回指向线程特定数据块的指针，不存在时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_setspecific()</code>会请求Pthreads
API将参数<code>value</code>的副本保存在与线程和参数<code>key</code>关联的数据结构中，<code>key</code>必须被指定为之前调用<code>pthread_key_create()</code>返回的键。函数<code>pthread_setspecific()</code>执行与之互补的操作，即返回指向之前与参数<code>key</code>关联的该线程的数据的指针。</p>
<p>　　<code>pthread_setspecific()</code>的参数<code>value</code>通常是指向之前由调用者分配的内存块的指针，该指针在线程终止时会作为参数传递给<code>key</code>对应的析构函数的指针。实际上，<code>value</code>也可以是赋值给<code>void *</code>的标量值
(强制类型转换)。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_31/data_structure_used_to_implement_thread-specific_data_pointers.svg" class="">
<p>　　上图展示了用于存储<code>value</code>的数据结构的典型实现。这里假设<code>pthread_keys[1]</code>被分配给函数<code>myfunc()</code>。对于每个线程，Pthreads
API维护了1个由指向线程特定数据块的指针组成的数组，其元素与31.2.2中的图所示的数组元素一一对应。函数<code>pthread_setspecific()</code>会为调用线程设置中与<code>key</code>对应的数组元素。</p>
<p>　　当第1次创建线程时，其所有线程特定数据指针都会被初始化为<code>NULL</code>。这表示当线程第1次调用库函数时，它必须通过<code>pthread_getspecific()</code>来检查线程是否已有与<code>key</code>关联的值。若没有，则函数应该分配内存块，并通过<code>pthread_setspecific()</code>来保存指向该内存块的指针。</p>
<h4 id="使用线程特定数据api">31.2.4 使用线程特定数据API</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* strerror.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，_sys_nerr和_sys_errlist会被声明在stdio.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">/* 获取strerror()的声明 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ERROR_LEN 256 <span class="comment">/* strerror()返回的字符串的最大长度 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[MAX_ERROR_LEN]; <span class="comment">/* 静态分配的返回缓冲区 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> || err &gt;= _sys_nerr || _sys_errlist[err] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, MAX_ERROR_LEN, <span class="string">&quot;Unknown error %d&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf, _sys_errlist[err], MAX_ERROR_LEN - <span class="number">1</span>);</span><br><span class="line">        buf[MAX_ERROR_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 确保以\0结尾 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例是<code>strerror()</code>的非线程安全实现。该函数会使用glibc定义的全局变量<code>_sys_nerr</code>
(由<code>errno</code>错误号对应的字符串组成的数组)
和全局数组<code>_sys_errlist</code>
(表示<code>_sys_errlist</code>的元素数量)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* strerror_test.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">/* 获取strerror()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Other thread about to call strerror()\n&quot;</span>);</span><br><span class="line">    str = strerror(EPERM);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Other thread: str (%p) = %s\n&quot;</span>, str, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">    str = strerror(EINVAL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread has called strerror()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;t, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_join(t, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread: str (%p) = %s\n&quot;</span>, str, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例是<code>strerror()</code>的测试程序。该程序会在2个线程中调用<code>strerror()</code>，并且仅在2个线程都完成调用后才打印结果。尽管2个线程使用了不同的错误号
(<code>EINVAL</code>和<code>EPERM</code>)
作为<code>strerror()</code>的参数，编译该测试程序并与<code>strerror.c</code>链接得到的可执行文件的运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./strerror_test</span></span><br><span class="line">Main thread has called strerror()</span><br><span class="line">Other thread about to call strerror()</span><br><span class="line">Other thread: str (0x804a7c0) = Operation not permitted</span><br><span class="line">Main thread: str (0x804a7c0) = Operation not permitted</span><br></pre></td></tr></table></figure>
<p>　　2个线程打印的都是<code>EPERM</code>对应的字符串，因为新线程调用<code>strerror()</code>会覆写主线程调用<code>strerror()</code>写入到缓冲区的内容。根据输出结果可知，2个线程中的局部变量<code>str</code>指向同一内存地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* strerror_tsd.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，_sys_nerr和_sys_errlist会被声明在stdio.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">/* 获取strerror()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ERROR_LEN 256 <span class="comment">/* strerror()返回的线程级缓冲区的字符串的最大长度 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> strerrorKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 析构函数 (释放buf指向的缓冲区)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param buf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">destructor</span><span class="params">(<span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建一次性键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">createKey</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配1个唯一的线程特定数据键，并保存线程特定数据缓冲区的析构函数的地址 */</span></span><br><span class="line">    s = pthread_key_create(&amp;strerrorKey, destructor);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_key_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 让第1个调用者为线程特定数据分配键 */</span></span><br><span class="line">    s = pthread_once(&amp;once, createKey);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若线程第1次调用该函数，则为线程分配缓冲区，并保存其地址 */</span></span><br><span class="line">    buf = pthread_getspecific(strerrorKey);</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf = <span class="built_in">malloc</span>(MAX_ERROR_LEN);</span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = pthread_setspecific(strerrorKey, buf);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_setspecific&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> || err &gt;= _sys_nerr || _sys_errlist[err] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, MAX_ERROR_LEN, <span class="string">&quot;Unknown error %d&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf, _sys_errlist[err], MAX_ERROR_LEN - <span class="number">1</span>);</span><br><span class="line">        buf[MAX_ERROR_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 确保以\0结尾 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例是的使用线程特定数据的<code>strerror()</code>实现。</p>
<p>　　首先，<code>strerror()</code>调用<code>pthread_once()</code>来确保线程第1次调用该函数时会调用函数<code>createKey()</code>
(第45~49行)。<code>createKey()</code>会调用<code>pthread_key_create()</code>来分配存储1个存储在全局变量<code>strerrorKey</code>中的线程特定数据键，调用<code>pthread_key_create()</code>也会记录用于释放与键对应的线程特定数据的析构函数的地址
(第27~37行)。</p>
<p>　　然后，<code>strerror()</code>调用<code>pthread_getspecific()</code>来检索与<code>strerrorKey</code>对应的线程的唯一缓冲区的地址。若该调用返回<code>NULL</code>，则表示线程是第1次调用<code>strerror()</code>，所以<code>strerror()</code>会通过<code>malloc()</code>来创建1个新的缓冲区，并通过<code>pthread_setspecific()</code>来将该缓冲区与<code>strerrorKey</code>关联。若该调用的返回值不是<code>NULL</code>，则表示返回值是指向线程之前调用<code>strerror()</code>时分配的缓冲区的指针
(第51~66行)。</p>
<p>　　最后，<code>strerror()</code>实现执行与之前的非线程安全实现相似的操作，区别在于这里的<code>buf</code>是线程特定数据缓冲区的地址
(而非静态变量)。</p>
<p>　　编译测试程序 (<code>strerror_test.c</code>)
并与<code>strerror_tsd.c</code>链接得到的可执行文件的运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./strerror_test_tsd</span></span><br><span class="line">Main thread has called strerror()</span><br><span class="line">Other thread about to call strerror()</span><br><span class="line">Other thread: str (0x804b158) = Operation not permitted</span><br><span class="line">Main thread: str (0x804b008) = Invalid argument</span><br></pre></td></tr></table></figure>
<p>　　根据输出结果可知，<code>strerror_tsd.c</code>是线程安全的
(2个线程中的局部变量<code>str</code>指向不同地址)。</p>
<h4 id="线程特定数据实现的限制">31.2.5 线程特定数据实现的限制</h4>
<p>　　正如对线程特定数据的典型实现方式的描述所暗示的那样，实现需要对其支持的线程特定数据键的数量施加限制。SUSv3要求实现支持至少128个键
(<code>_POSIX_THREAD_KEYS_MAX</code>)，而Linux支持最多1024个键。应用程序可以通过<code>PTHREAD_KEYS_MAX</code>的定义
(定义在头文件<code>limits.h</code>中)
或调用<code>sysconf(_SC_THREAD_KEYS_MAX)</code>来获取实现实际支持多少个键。</p>
<p>　　对于大多数应用程序，128个键也绰绰有余，因为库函数使用的键很少——通常只有1个。当函数需要多个线程特定数据值时，通常也是将这些值放在1个结构体中
(只需要1个与之关联的键)。</p>
<h3 id="线程本地存储">31.3 线程本地存储</h3>
<p>　　与线程特定数据类似，线程本地存储也提供了持久的线程级存储。该特性是非标准特性，Solaris和FreeBSD等很多UNIX实现都以相同或类似的形式提供该特性。</p>
<p>　　线程本地存储的主要优势是比线程特定数据简单很多。为了创建线程本地变量，只需要在全局或静态变量的声明中使用说明符<code>__thread</code>
(例如，<code>static __thread buf[MAX_ERROR_LEN]</code>)。</p>
<p>　　每个线程都有线程本地变量的副本。线程的线程本地存储中的变量会一直存在，直到线程终止，届时会自动释放线程本地存储。</p>
<p>　　线程本地存储需要内核 (Linux 2.6及以上版本)、Pthreads实现 (NPTL)
和C编译器 (gcc 3.3及以上版本) 的支持。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* strerror_tls.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，_sys_nerr和_sys_errlist会被声明在stdio.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">/* 获取strerror()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ERROR_LEN 256 <span class="comment">/* strerror()返回的线程级缓冲区的字符串的最大长度 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">char</span> buf[MAX_ERROR_LEN]; <span class="comment">/* 线程本地返回缓冲区 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> || err &gt;= _sys_nerr || _sys_errlist[err] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, MAX_ERROR_LEN, <span class="string">&quot;Unknown error %d&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf, _sys_errlist[err], MAX_ERROR_LEN - <span class="number">1</span>);</span><br><span class="line">        buf[MAX_ERROR_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 确保以\0结尾 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例是使用线程本地存储的<code>strerror()</code>实现。编译测试程序
(<code>strerror_test.c</code>)
并与该程序链接得到的可执行文件的运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./strerror_test_tls</span></span><br><span class="line">Main thread has called strerror()</span><br><span class="line">Other thread about to call strerror()</span><br><span class="line">Other thread: str (0x40376ab0) = Operation not permitted</span><br><span class="line">Main thread: str (0x40175080) = Invalid argument</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第32章 线程：线程取消</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_32/</url>
    <content><![CDATA[<p>　　<strong>取消</strong>线程是向线程发送请求，要求它立即终止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_cancel()</code>会发送取消请求给参数<code>thread</code>指定的线程。一旦请求发送完成，该函数会立即返回，即不会等待目标线程终止。目标线程如何处理取消请求取决于其取消状态和类型。</p>
<p>　　函数<code>pthread_setcancelstate()</code>会将调用线程的取消状态设置为参数<code>state</code>指定的状态，该参数可以被指定为<code>PTHREAD_CANCEL_DISABLE</code>和<code>PTHREAD_CANCEL_ENABLE</code>。</p>
<p>　　●
<code>PTHREAD_CANCEL_DISABLE</code>表示线程不可取消。若处于该状态的线程收到取消请求，取消请求将保持待处理状态，直到线程退出不取消状态。</p>
<p>　　●
<code>PTHREAD_CANCEL_ENABLE</code>表示线程可取消，这也是新线程的默认取消状态。</p>
<p>　　调用线程的旧取消状态会被存储在参数<code>oldstate</code>指向的缓冲区中。Linux和很多UNIX实现都允许将该参数指定为<code>NULL</code>。但是，SUSv3未说明该特性，所以可移植应用程序不应该将该参数指定为<code>NULL</code>。</p>
<p>　　函数<code>pthread_setcanceltype()</code>会将调用线程的取消类型设置为参数<code>type</code>指定的类型，该参数可以被指定为<code>PTHREAD_CANCEL_ASYNCHRONOUS</code>和<code>PTHREAD_CANCEL_DEFERRED</code>。</p>
<p>　　●
<code>PTHREAD_CANCEL_ASYNCHRONOUS</code>表示线程可能随时会被取消。</p>
<p>　　●
<code>PTHREAD_CANCEL_DEFERRED</code>表示取消实际会发生在取消点，这也是新线程的默认取消类型。</p>
<p>　　调用线程的旧取消类型会被存储在参数<code>oldtype</code>指向的缓冲区中。Linux和很多UNIX实现都允许将该参数指定为<code>NULL</code>。但是，SUSv3未说明该特性，所以可移植应用程序不应该将该参数指定为<code>NULL</code>。</p>
<p>　　当线程调用<code>fork()</code>后，子进程会继承调用线程的取消类型和状态。当线程调用<code>exec()</code>后，新程序的主线程的取消状态和类型会被分别设置为<code>PTHREAD_CANCEL_ENABLE</code>和<code>PTHREAD_CANCEL_DEFERRED</code>。</p>
<span id="more"></span>
<h3 id="取消点">32.1 取消点</h3>
<p>　　若线程的取消状态和类型分别为<code>PTHREAD_CANCEL_ENABLE</code>和<code>PTHREAD_CANCEL_DEFERRED</code>，则取消请求会在线程下一次到达<strong>取消点</strong>时被执行。若该线程不是分离线程，则进程中的其他线程必须合并该线程
(防止它转换为僵尸线程)。当合并被取消的线程时，<code>pthread_join()</code>的参数<code>retval</code>会返回特殊值<code>PTHREAD_CANCELED</code>。</p>
<p>　　取消点是对实现定义的诸多函数之一的调用。SUSv3要求，若实现提供了以下函数，则这些函数必须是取消点
(其中的大部分函数都能够无期限地阻塞线程)：</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_32/functions_required_to_be_cancellation_points_by_susv3.svg" class="">
<p>　　SUSv3还定义了大量<span
style="background-color: yellow">可以</span>是取消点的函数，包括stdio函数、dlopen
API、syslog
API、<code>nftw()</code>、<code>popen()</code>、<code>semop()</code>、<code>unlink()</code>以及从<code>utmp</code>等系统文件检索信息的各种函数。可移植应用程序必须正确地处理在调用这些函数时线程可能被取消的情况。</p>
<p>　　SUSv3要求，除了必须和可以作为取消点的函数之外，标准中的任何其他函数都不能作为取消点
(所以可移植应用程序不需要处理这些其他函数可能导致线程取消的情况)。</p>
<p>　　SUSv4将<code>openat()</code>添加到必须是取消点的函数列表，并从该列表中删除了<code>sigpause()</code>
(移动到了可以是取消点的函数列表) 和<code>usleep()</code>
(从标准中删除)。</p>
<p>　　实现可以随意地将标准未说明的函数标记为取消点，即任何可能会阻塞的非标准函数
(可能是因为它可能会访问文件)
都可能是取消点。因此，glibc中的很多非标准函数都被标记为取消点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* thread_cancel.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;New thread started\n&quot;</span>); <span class="comment">/* 可能是取消点 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>;; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Loop %d\n&quot;</span>, j); <span class="comment">/* 可能是取消点 */</span></span><br><span class="line">        sleep(<span class="number">1</span>);               <span class="comment">/* 取消点 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">void</span> *res;</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;thr, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>); <span class="comment">/* 允许新线程运行一段时间 */</span></span><br><span class="line">    s = pthread_cancel(thr);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_cancel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_join(thr, &amp;res);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == PTHREAD_CANCELED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread was canceled\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread was not canceled (should not happen!)\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>pthread_cancel()</code>的用法。主线程会创建1个执行无限循环的线程，新线程每次循环会睡眠1秒并打印循环计数器的值
(当向该线程发送取消请求或进程终止时，该线程才会终止)。同时，主线程会睡眠3秒，然后向新线程发送取消请求。</p>
<p>　　对于这个示例，新线程会接收取消请求，因为该线程执行的函数中有1个取消点
(<code>sleep()</code>)。但是，假设线程执行的循环没有取消点
(例如，计算密集型循环)。在这种情况下，线程永远不会接收取消请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_testcancel</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_testcancel()</code>的功能是充当取消点。当线程执行的代码中没有取消点时，可以定期调用该函数来确保该线程能够及时响应其他线程发送的取消请求。</p>
<h3 id="清除处理函数">32.2 清除处理函数</h3>
<p>　　当有待处理取消请求的线程到达取消点并直接终止时，共享变量和Pthreads对象
(例如，互斥锁)
可能会处于不一致状态，这可能会导致进程中的其他线程产生错误结果、死锁或崩溃。为了解决该问题，线程可以注册<strong>清除处理函数</strong>。清除处理函数在线程终止前可以执行修改全局变量和解锁互斥锁等任务。</p>
<p>　　线程可以有多个清除处理函数。当线程被取消时，清除处理函数会自动被调用，调用顺序与栈结构类似，即最近注册的清除处理函数最先被调用。当所有清除处理函数都被调用后，线程会终止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_cleanup_push()</code>会将参数<code>routine</code>指向的函数添加到调用线程的清除处理函数栈的栈顶，而参数<code>arg</code>将作为参数传递给该清除处理函数
(尽管该参数的数据类型是<code>void *</code>，但通过合适类型转，该参数也能传递标量数据)。</p>
<p>　　函数<code>pthread_cleanup_pop()</code>会删除调用线程的清除处理函数栈的栈顶清除处理函数。若参数<code>execute</code>不为0，则被删除的清除处理函数还是会被调用。</p>
<p>　　通常，只有在执行特点代码段期间取消线程时才需要执行清除操作。若线程到达该代码段末尾时未被取消，则不需要清理操作。因此，<code>pthread_cleanup_push()</code>调用应该与<code>pthread_cleanup_pop()</code>调用成对出现。</p>
<p>　　虽然这里将<code>pthread_cleanup_push()</code>和<code>pthread_cleanup_pop()</code>描述为函数，但SUSv3允许它们被实现为宏，分别扩展为包括左括号<code>&#123;</code>和右括号<code>&#125;</code>的语句序列。并非所有UNIX实现都这样做，但Linux和很多系统都这样做。这表示每个<code>pthread_cleanup_push()</code>调用都必须在<span
style="background-color: yellow">同一词法块</span>中有1个对应的<code>pthread_cleanup_pop()</code>调用
(对于这种实现方式，<code>pthread_cleanup_push()</code>和<code>pthread_cleanup_pop()</code>之间的声明的变量将被限制在该词法范围内)。</p>
<p>　　为了便利，若线程通过<code>pthread_exit()</code>终止，则任何尚未弹出的清除处理函数也会自动被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* thread_cleanup.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> glob = <span class="number">0</span>; <span class="comment">/* 谓词变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放arg指向的内存和解锁互斥锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cleanupHandler</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cleanup: freeing block at %p\n&quot;</span>, arg);</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cleanup: unlocking mutex\n&quot;</span>);</span><br><span class="line">    s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">void</span> *buf = <span class="literal">NULL</span>; <span class="comment">/* 线程分配的缓冲区 */</span></span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x10000</span>); <span class="comment">/* 不是取消点 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: allocated memory at %p\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_lock(&amp;mtx); <span class="comment">/* 不是取消点 */</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_push(cleanupHandler, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (glob == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pthread_cond_wait(&amp;cond, &amp;mtx); <span class="comment">/* 取消点 */</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_cond_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: condition wait loop completed\n&quot;</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>); <span class="comment">/* 执行清理处理函数 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="type">void</span> *res;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;thr, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">/* 等待新线程运行 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 取消新线程 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main: about to cancel thread\n&quot;</span>);</span><br><span class="line">        s = pthread_cancel(thr);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_cancel&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 执行唤醒操作 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main: about to signal condition variable\n&quot;</span>);</span><br><span class="line">        glob = <span class="number">1</span>;</span><br><span class="line">        s = pthread_cond_signal(&amp;cond);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_cond_signal&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_join(thr, &amp;res);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == PTHREAD_CANCELED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main: thread was canceled\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main: thread terminated normally\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了清除处理函数的用法。主线程会创建1个线程
(第64~68行)，新线程会先分配内存 (第33行)，再锁定互斥锁<code>mtx</code>
(第36~40行)。因为新线程可能会被取消，所以这里通过<code>pthread_cleanup_push()</code>注册清除处理函数，并将<code>buf</code>作为参数传递。当清除处理函数被调用时，会释放内存和解锁互斥锁
(第14~26行)。最后，新线程会循环等待条件变量<code>cond</code>
(第44~51行)。该循环会以2种方式之一终止，这取决于是否提供了命令行参数：</p>
<p>　　● 若未提供命令行参数，则新线程会被主线程取消
(第75~80行)。在这种情况下，新线程的取消实际发生在调用<code>pthread_cond_wait()</code>。作为取消的一部分，通过<code>pthread_cleanup_push()</code>注册的清除处理函数会自动被调用。</p>
<p>　　●
若提供了命令行参数，则主线程会将<code>glob</code>设置为1并执行唤醒操作
(第85~91行)。在这种情况下，新线程会一直执行到<code>pthread_cleanup_pop(1)</code>
(第54行)，这会调用清除处理函数。</p>
<p>　　最后，主线程会合并新线程，并打印新线程是被取消还是正常终止
(第94~106行)。</p>
<h3 id="异步取消">32.3 异步取消</h3>
<p>　　若线程的取消类型是<code>PTHREAD_CANCEL_ASYNCHRONOUS</code>，则该线程可能随时被取消，取消请求的传递不会被推迟到线程下一次到达取消点。</p>
<p>　　异步取消的问题在于，尽管清除处理函数仍然会被调用，但它无法获取线程的状态。对于32.2中的示例程序中的新线程，取消类型是<code>PTHREAD_CANCEL_DEFERRED</code>，取消点只有<code>pthread_cond_wait()</code>。到那时，<code>buf</code>已被初始化为指向已分配的内存块，互斥锁<code>mtx</code>已被锁定。但是，由于异步取消，线程可能随时被取消
(例如，调用<code>malloc()</code>之前，在调用<code>malloc()</code>和锁定互斥锁之间或锁定互斥锁之后)。清除处理函数无法得知取消发生在何处或究竟需要执行哪些清理步骤。此外，取消可能发生在<code>malloc()</code>调用期间，这很可能会导致混乱的情况。</p>
<p>　　通常，异步取消线程不能分配任何资源以及获取互斥锁、信号量或锁。这表示无法使用很多库函数，包括大多数Pthreads函数
(SUSv3对<code>pthread_cancel()</code>、<code>pthread_setcancelstate()</code>和<code>pthread_setcanceltype()</code>做出了例外，明确要求将它们实现为<span
style="background-color: yellow">异步取消安全</span>的，即能够在异步取消线程中安全被调用)。因此，异步取消有用的情况很少
(例如，取消处于计算密集型循环中的线程)。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第30章 线程：线程同步</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_30/</url>
    <content><![CDATA[<p>　　线程的主要优势之一就是能够通过全局变量共享信息。但是，这种共享信息的方式是有代价的：必须保证不能有多个线程同时修改同一变量，并且线程不能读取其他线程正在修改的变量。</p>
<p>　　术语<strong>临界区</strong>是指访问共享资源且应具有代码原子性的代码段
(其执行不应该被访问同一资源的其他线程干扰)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* thread_incr.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> glob = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 循环arg次，每次循环会将glob加1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arg</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> loops = *((<span class="type">int</span> *)arg);</span><br><span class="line">    <span class="type">int</span> loc, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; loops; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        loc = glob;</span><br><span class="line">        loc++;</span><br><span class="line">        glob = loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="type">int</span> loops, s;</span><br><span class="line"></span><br><span class="line">    loops = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;num-loops&quot;</span>) : <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = pthread_create(&amp;t2, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;glob = %d\n&quot;</span>, glob);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了不以原子方式访问共享资源时可能出现的问题。该程序会创建2个线程，这2个线程都会执行同一函数，该函数将全局变量<code>glob</code>复制给局部变量<code>loc</code>，然后将<code>loc</code>加1并复制回<code>glob</code>。</p>
<span id="more"></span>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_30/two_threads_incrementing_a_global_variable_without_synchronization.svg" class="">
<p>　　上图展示了程序<code>thread_incr</code>的问题。</p>
<p>　　1)
线程1将<code>glob</code>的当前值复制给<code>loc</code>，这里假设其值为2000。</p>
<p>　　2) 线程1的调度程序时间片到期，线程2开始执行。</p>
<p>　　3)
线程2会循环将<code>glob</code>的当前值复制给<code>loc</code>，假设第1次循环时<code>glob</code>的值是2000。当线程2的调度程序时间片到期后，<code>glob</code>增加到3000。</p>
<p>　　4)
线程2的调度程序时间片到期，线程1从停止的位置恢复执行。由于<code>loc</code>的值为2000，所以会将其加1
(得到2001) 并复制回<code>glob</code>，这无效化了线程2的增加操作。</p>
<p>　　这种不确定性行为是内核CPU调度决策变化的结果。</p>
<p>　　将函数<code>threadFunc()</code>的循环中的增加<code>glob</code>的3条语句替换为<code>glob++;</code>看似可以解决问题。但是，对于很多硬件架构
(例如，RISC架构)，编译器会将这条语句转换为等同于这3条语句的机器代码
(自增操作符可能不是原子的)。</p>
<p>　　为了避免这一问题，必须要使用<strong>互斥锁</strong>来保证同时只能有1个线程访问共享变量。实际上，互斥锁也能用于确保对任何共享资源的原子访问，但保护共享变量是最常见的用法。</p>
<p>　　互斥锁有2个状态：<strong>加锁</strong>和<strong>解锁</strong>。在任何时刻，最多只能有1个线程持有互斥锁。试图对已锁定的互斥锁加锁会导致阻塞或出错
(取决于加锁的方法)。</p>
<p>　　当线程锁定互斥锁时，它会成为互斥锁的所有者，互斥锁只能由其所有者解锁。该特性改善了使用互斥锁的代码结构，并且还允许在互斥锁的实现中使用一些优化。由于这个所有权特性，术语<span
style="background-color: yellow">获取</span>和<span
style="background-color: yellow">释放</span>有时等同于加锁和解锁。</p>
<p>　　通常，每个共享资源会使用不同的互斥锁，并且每个线程使用以下协议来访问资源：</p>
<p>　　● 对共享资源加锁。</p>
<p>　　● 访问资源。</p>
<p>　　● 解锁。</p>
<p>　　当多个线程试图执行临界区时，只能有1个线程持有互斥锁
(其他线程会被阻塞)，所以只能有1个线程进入临界区。</p>
<h3 id="互斥锁">30.1 互斥锁</h3>
<p>　　互斥锁可以被分配为静态变量，也可以在运行时被动态创建。</p>
<p>　　互斥锁是<code>pthread_mutex_t</code>类型的变量，在使用之前必须先将其初始化。对于静态分配的互斥锁，可以通过将其赋值为<code>PTHREAD_MUTEX_INITIALIZER</code>来初始化。</p>
<h4 id="锁定和解锁互斥锁">30.1.1 锁定和解锁互斥锁</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_mutex_lock()</code>会锁定参数<code>mutex</code>指定的互斥锁。若互斥锁当前未被锁定，则该调用会锁定互斥锁并立即返回。若互斥锁当前已被其他线程锁定，则该调用会阻塞，直到互斥锁被解锁，此时，它会立即锁定互斥锁并返回。</p>
<p>　　当调用线程已经持有指定给<code>pthread_mutex_lock()</code>的互斥锁时，对于默认类型的互斥锁，可能会导致线程阻塞在试图锁定已持有的互斥锁或调用失败并返回<code>EDEADLK</code>
(取决于实现)。对于Linux，这种情况会导致线程阻塞在锁定已持有的互斥锁。</p>
<p>　　函数<code>pthread_mutex_unlock()</code>会解锁参数<code>mutex</code>指定的互斥锁。若互斥锁当前未被锁定或互斥锁已由其他线程锁定，则会返回错误。</p>
<p>　　若多个线程正在等待获取<code>pthread_mutex_unlock()</code>解锁的互斥锁，则成功获取该互斥锁的线程是不确定的。</p>
<p>　　此外，Pthreads
API还提供了函数<code>pthread_mutex_trylock()</code>和<code>pthread_mutex_timedlock()</code>，这2个函数都是<code>pthread_mutex_lock()</code>的变体。</p>
<p>　　●
<code>pthread_mutex_trylock()</code>与<code>pthread_mutex_lock()</code>相似，不同之处在于当互斥锁当前已被锁定时，该函数会返回错误<code>EBUSY</code>。</p>
<p>　　●
<code>pthread_mutex_timedlock()</code>与<code>pthread_mutex_lock()</code>相似，不同之处在于该函数还提供了参数<code>abstime</code>，该参数对线程在等待获取互斥锁时睡眠的时间施加了限制。若该参数指定的时间内调用者仍未成为互斥锁的所有者，则该函数会返回错误<code>ETIMEDOUT</code>。</p>
<p>　　<code>pthread_mutex_trylock()</code>和<code>pthread_mutex_timedlock()</code>的使用频率较低。对于设计良好的应用程序，线程应该只会在短期内持有互斥锁，以便其他线程的并发执行不会受到影响。这保证了其他被互斥锁阻塞的线程可以很快地获取该互斥锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* thread_incr_mutex.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> glob = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 循环arg次，每次循环会将glob加1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arg</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> loops = *((<span class="type">int</span> *)arg);</span><br><span class="line">    <span class="type">int</span> loc, j, s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; loops; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        loc = glob;</span><br><span class="line">        loc++;</span><br><span class="line">        glob = loc;</span><br><span class="line"></span><br><span class="line">        s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="type">int</span> loops, s;</span><br><span class="line"></span><br><span class="line">    loops = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;num-loops&quot;</span>) : <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = pthread_create(&amp;t2, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;glob = %d\n&quot;</span>, glob);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例是<code>thread_incr.c</code>的修改版，这里使用了互斥锁来保护对全局变量<code>glob</code>的访问。</p>
<h4 id="互斥锁的性能">30.1.2 互斥锁的性能</h4>
<p>　　当在运行Linux (带有NPTL)
的x86-32系统上运行<code>thread_incr.c</code>和<code>thread_incr_mutex.c</code>时，前者在每个线程中执行1000万次循环共需要0.35秒
(并产生错误的结果)，后者则需要3.1秒。互斥锁看似成本很高，但对比两者的时间可以得出，在<code>threadFunc()</code>的<code>for</code>循环中，加锁和解锁的总耗时略低于其他操作的10倍，这样的成本相对较小。此外，线程通常会使用更多的时间来执行其他操作，并且执行相对较少的加锁和解锁操作。因此，对于大多数应用程序，使用互斥锁的性能影响并不显著。</p>
<p>　　为了进一步体现互斥锁的性能，在同一系统上运行一些简单的测试程序，结果表明，使用<code>fcntl()</code>对文件区域进行2000万次加锁和解锁的循环需要44秒，而对System
V信号量进行2000万次增减循环则需要28秒。文件锁和信号量的问题在于始终需要通过系统调用来执行加锁和解锁操作，虽然每次系统调用的成本虽然较小，但也不能忽略。相比之下，互斥锁是使用原子机器语言操作
(在所有线程可见的内存位置上执行)
实现的，并且仅在发生锁竞争时才需要系统调用。</p>
<p>　　对于Linux，互斥锁被实现为基于futex (fast user space
mutex的缩写)，锁竞争则通过系统调用<code>futex()</code>来处理。</p>
<h4 id="互斥锁死锁">30.1.3 互斥锁死锁</h4>
<p>　　有时，线程需要同时访问多个不同的共享资源，每个共享资源由不同的互斥锁控制。当多个线程同时锁定同一组互斥锁时，可能会导致<strong>死锁</strong>。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_30/a_deadlock_when_two_threads_lock_two_mutexes.svg" class="">
<p>　　如图所示，2个线程都成功地获取了1个互斥锁，并且都试图锁定已由对方锁定的互斥锁。最终，2个线程都会无限阻塞。</p>
<p>　　避免死锁最简单的方法就是定义互斥锁层次结构。当多个线程能够锁定同一组互斥锁时，它们应该应该以相同的顺序锁定互斥锁。</p>
<p>　　另一种不太常用的策略是
"尝试，然后退回"。对于这种策略，线程使用<code>pthread_mutex_lock()</code>获取第1个互斥锁，然后通过<code>pthread_mutex_trylock()</code>获取其他互斥锁，若任一<code>pthread_mutex_trylock()</code>调用返回错误<code>EBUSY</code>，则释放所有互斥锁，然后再次尝试
(可能会等待一段时间)。这种方法的效率低于互斥锁层次结构，但更灵活。</p>
<h4 id="动态初始化互斥锁">30.1.4 动态初始化互斥锁</h4>
<p>　　静态初始化值<code>PTHREAD_MUTEX_INITIALIZER</code>只能用于初始化具有默认属性的静态分配互斥锁。对于其他情况，必须通过<code>pthread_mutex_init()</code>来动态初始化互斥锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　参数<code>mutex</code>用于指定待初始化的互斥锁。参数<code>attr</code>指向<code>pthread_mutexattr_t</code>对象，用于定义互斥锁的属性
(之前以被初始化)。若<code>attr</code>为<code>NULL</code>，则将使用默认属性来初始化互斥锁。</p>
<p>　　SUSv3规定，初始化已初始化的互斥锁会导致未定义的行为。</p>
<p>　　以下情况必须使用<code>pthread_mutex_init()</code>来动态初始化互斥锁：</p>
<p>　　● 互斥锁被动态分配在堆中
(例如，动态分配的结构体链表，并且链表中的所有结构体都包含用于保护对结构体的访问的成员<code>pthread_mutex_t</code>)。</p>
<p>　　● 互斥锁是被分配在栈中的自动变量。</p>
<p>　　● 需要使用默认属性以外的属性来初始静态分配的互斥锁。</p>
<h4 id="销毁互斥锁">30.1.5 销毁互斥锁</h4>
<p>　　当自动或动态分配的互斥锁不再需要时，应该调用<code>pthread_mutex_destroy()</code>来将其销毁
(无需调用该函数来销毁通过<code>PTHREAD_MUTEX_INITIALIZER</code>静态初始化的互斥锁)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　只有互斥锁未被锁定，并且随后不会有线程试图锁定它时，销毁互斥锁才是安全的。若互斥锁位于动态分配的内存区域，则在销毁该互斥锁前应先释放该内存区域。自动分配的互斥锁应该在其所在的函数返回前被销毁。</p>
<p>　　当互斥锁被<code>pthread_mutex_destroy()</code>销毁后，可以通过<code>pthread_mutex_destroy()</code>将其重新初始化。</p>
<h4 id="互斥锁类型">30.1.6 互斥锁类型</h4>
<p>　　在之前的内容中，对互斥锁的行为做出了以下陈述：</p>
<p>　　● 1个线程不能多次锁定同一互斥锁。</p>
<p>　　● 线程不能解锁未持有的互斥锁 (即不是由它锁定的互斥锁)。</p>
<p>　　● 线程不能解锁未被锁定的互斥锁。</p>
<p>　　对于这些情况，具体行为取决于互斥锁的类型。SUSv3定义了以下互斥锁类型：</p>
<p>　　●
<code>PTHREAD_MUTEX_NORMAL</code>互斥锁不提供死锁检测。对于该类型的互斥锁，若线程试图锁定当前已被锁定的互斥锁，则会导致死锁。解锁未被锁定或未持有的互斥锁会导致未定义的结果
(对于Linux，对该类型的互斥锁执行这2种操作不会出错)。</p>
<p>　　●
<code>PTHREAD_MUTEX_ERRORCHECK</code>互斥锁会对所有操作进行错误检查。上述3种情况对都会导致Pthreads相关函数返回错误。该类型的互斥锁通常比普通互斥锁更慢，但可以作为调试工具来检查应用程序在哪里违反了互斥锁的使用规则。</p>
<p>　　●
<code>PTHREAD_MUTEX_RECURSIVE</code>互斥锁是递归互斥锁，它会维护锁计数的概念。同一线程可以多次锁定该类型的互斥锁。当线程第1次获取递归互斥锁时，锁计数会被设置为1，该线程的每次后续的锁定操都会增加锁计数。当且仅当锁计数为0时，才会释放对应的递归互斥锁
(即其他线程才能获取该递归互斥锁)。解锁未被锁定或未持有的递归互斥锁会返回错误。</p>
<p>　　Linux线程实现为这3种互斥锁类型提供了非标准的静态初始化值，所以无需使用<code>pthread_mutex_init()</code>来初始化静态分配的这些类型的互斥锁。但是，可移植应用程序应该避免使用这些静态初始化值。</p>
<p>　　除了这3种类型的互斥锁，SUSv3还定义了<code>PTHREAD_MUTEX_DEFAULT</code>互斥锁，即默认互斥锁。对于上述3种情况，该类型的互斥锁的行为都是故意未定义的，这为其实现提供了最大的灵活性。对于Linux，该类型的互斥锁的行为如同<code>PTHREAD_MUTEX_NORMAL</code>互斥锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mtx;</span><br><span class="line"><span class="type">pthread_mutexattr_t</span> mtxAttr;</span><br><span class="line"><span class="type">int</span> s, type;</span><br><span class="line"></span><br><span class="line">s = pthread_mutexattr_init(&amp;mtxAttr);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutexattr_init&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = pthread_mutexattr_settype(&amp;mtxAttr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutexattr_settype&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = pthread_mutex_init(mtx, &amp;mtxAttr);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_init&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = pthread_mutexattr_destroy(&amp;mtxAttr); <span class="comment">/* 不再需要mtxAttr */</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutexattr_destroy&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何将互斥锁的类型设置为<code>PTHREAD_MUTEX_ERRORCHECK</code>。</p>
<h3 id="条件变量">30.2 条件变量</h3>
<p>　　互斥锁可用于防止多个线程同时访问共享变量。条件变量允许线程通知其他线程共享变量状态变化的信息，并允许其他线程等待
(阻塞) 此类通知。</p>
<p>　　1个不使用条件变量的简单示例就可以说明条件变量为何有用。假设存在多个会产生供主线程消费的
"结果单元"
的生产者线程，并且会使用互斥锁保护的变量<code>avail</code>来表示待消费的单元的数量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> avail = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>　　生产者线程包含以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 产生1个单元的代码 */</span></span><br><span class="line"></span><br><span class="line">s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avail++; <span class="comment">/* 待消费的单元加1 */</span></span><br><span class="line"></span><br><span class="line">s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　主 (消费者) 线程包含以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">    s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 消耗所有待消耗的单元 */</span></span><br><span class="line">    <span class="keyword">while</span> (avail &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 执行一些操作 */</span></span><br><span class="line">        avail--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码可以正常运行，但它会浪费CPU时间，因为主线程会在无限循环中检查变量<code>avail</code>的状态。<strong>条件变量</strong>正好解决了这一问题，它允许线程睡眠
(等待)，直到其他线程通知该线程必须执行某些操作 (即出现了某个
"条件"，睡眠线程必须立即响应)。</p>
<p>　　条件变量总是会与互斥锁一起使用。互斥锁为访问共享变量提供了互斥，而条件变量用于指示变量状态的变化。</p>
<p>　　与互斥锁相同，条件变量可以被静态或动态分配。</p>
<p>　　条件变量的数据类型是<code>pthread_cond_t</code>。与互斥锁相同，使用条件变量前必须先将其初始化。对于静态分配的条件变量，可以通过将其赋值为<code>PTHREAD_COND_INITIALIZER</code>来初始化。</p>
<h4 id="等待和唤醒">30.2.1 等待和唤醒</h4>
<p>　　条件变量的主要操作是<strong>唤醒</strong>和<strong>等待</strong>。唤醒操作是向等待线程发送共享变量已发生变化的通知，等待操作是阻塞直到收到此类通知的方式。</p>
<p>　　条件变量不存储状态信息，它只是1种用于传递应用程序状态信息的机制。若执行唤醒操作时没有线程在等待对应的条件变量，则通知会被丢弃。随后等待条件变量的线程只会在下一次执行唤醒操作时解除阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_cond_signal()</code>和<code>pthread_cond_broadcast()</code>都会发送参数<code>cond</code>指定的条件变量的状态变化的通知
(即唤醒操作)。函数<code>pthread_cond_wait()</code>会阻塞线程，直到收到参数<code>cond</code>指定的条件变量的状态变化的通知
(即等待操作)。</p>
<p>　　函数<code>pthread_cond_timedwait()</code>与<code>pthread_cond_wait()</code>相似，但可以通过参数<code>abstime</code>来指定等待操作的时间上限。该参数指向结构体<code>abstime</code>
(见23.4)，指定自纪元以来以秒和纳秒表示的绝对时间。若该参数的指定的时间过期后线程未被唤醒，则<code>pthread_cond_timedwait()</code>会返回错误<code>ETIMEDOUT</code>。</p>
<p>　　当多个线程都阻塞在对同一条件变量调用<code>pthread_cond_wait()</code>时，<code>pthread_cond_signal()</code>会保证唤醒至少1个阻塞线程，而<code>pthread_cond_broadcast()</code>会唤醒所有阻塞线程。</p>
<p>　　使用<code>pthread_cond_broadcast()</code>总能得到正确的结果
(因为所有线程都应该被设计为处理冗余和虚假唤醒)，但<code>pthread_cond_signal()</code>可能更高效。但是，当仅需要唤醒任一等待线程来处理共享变量的状态变化，并且唤醒哪一个线程不重要时，才应该使用<code>pthread_cond_signal()</code>。这种场景通常适用于所有等待线程都被设计为执行同一任务。基于这些假设，<code>pthread_cond_signal()</code>可能比<code>pthread_cond_broadcast()</code>更高效，因为它避免了以下可能情况：</p>
<p>　　1) 唤醒所有等待线程。</p>
<p>　　2) 首先调度1个线程，该线程会检查共享变量的状态
(受到相关互斥锁的保护)，发现有工作待完成。该线程完成工作，更改共享变量的状态以指示工作已完成，并解锁相关互斥锁。</p>
<p>　　3)
剩余的每个线程轮流锁定互斥锁，并检查共享变量的状态。但是，由于第1个线程做出的修改，这些线程会发现没有工作可做，所以会解锁互斥锁并继续睡眠
(即再次调用<code>pthread_cond_wait()</code>)。</p>
<p>　　相比之下，<code>pthread_cond_broadcast()</code>适用于等待线程被设计为执行不同任务的情况
(在这种情况下，这些线程可能包含与条件变量相关的不同谓词)。</p>
<p>　　为了将条件变量应用于本小节开头的示例，可以将全局变量以及相关的互斥锁和条件变量声明为以下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> avail = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>　　生产者线程的代码将加入调用<code>pthread_cond_signal()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avail++; <span class="comment">/* 让消费者知道可供消耗的单元的数量加1 */</span></span><br><span class="line"></span><br><span class="line">s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = pthread_cond_signal(&amp;cond); <span class="comment">/* 唤醒睡眠的消费者 */</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_cond_signal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　实际上，这里可用先调用<code>pthread_cond_signal()</code>再调用<code>pthread_mutex_unlock()</code>。SUSv3允许以任意顺序调用这2个函数。</p>
<p>　　在考虑消费者线程的代码时，这里会先详细介绍<code>pthread_cond_wait()</code>的行为。条件变量总是有1个与之关联的互斥锁，这2个对象会作为参数传递给<code>pthread_cond_wait()</code>，该函数会执行以下步骤：</p>
<p>　　● 解锁<code>mutex</code>指定的互斥锁。</p>
<p>　　● 执行等待操作。</p>
<p>　　● 锁定<code>mutex</code>。</p>
<p>　　<code>pthread_cond_wait()</code>被设计为执行以上步骤是因为访问共享变量的方式通常如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/* 判断共享变量是否处于预期状态 */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;mtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 共享变量已处于预期状态，执行合适的操作 */</span></span><br><span class="line"></span><br><span class="line">s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于以上代码，对共享变量的访问必须由互斥锁保护，即条件变量与互斥锁之间有天然的联系：</p>
<p>　　1) 线程会在检查共享变量的状态之前锁定互斥锁。</p>
<p>　　2) 判断共享变量的状态。</p>
<p>　　3)
若共享变量不处于预期状态，则线程在进入等待操作前必须先解锁互斥锁
(以便其他线程可以访问共享变量)。</p>
<p>　　4)
当线程被唤醒后，互斥锁会再次被锁定，因为线程通常会立即访问共享变量。</p>
<p>　　<code>pthread_cond_wait()</code>会自动执行最后2步中的解锁和加锁操作。在第3步中，解锁互斥锁和阻塞在条件变量是以原子方式执行的，所以其他线程无法在调用<code>pthread_cond_wait()</code>的线程阻塞在条件变量前获取互斥锁和执行唤醒操作。</p>
<p>　　因此，所有同时等待条件变量的线程必须在<code>pthread_cond_wait()</code>或<code>pthread_cond_timedwait()</code>调用中指定同一互斥锁。实际上，在<code>pthread_cond_wait()</code>调用期间，条件变量会动态地绑定到唯一的互斥锁。SUSv3指出，若对同一条件变量同时进行多个<code>pthread_cond_wait()</code>调用，并且指定不同的互斥锁，则结果是未定义的。</p>
<p>　　根据以上细节，可以对主 (消费者) 线程进行适当的修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">    s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待生产者消除生产单元 */</span></span><br><span class="line">    <span class="keyword">while</span> (avail == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pthread_cond_wait(&amp;cond, &amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_cond_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 消费所有可用的单元 */</span></span><br><span class="line">    <span class="keyword">while</span> (avail &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 消费1个单元 */</span></span><br><span class="line">        avail--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行一些不需要互斥锁的操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　David Butenhof的《Programming with POSIX
Threads》指出，对于某些实现，生产者线程先解锁互斥锁再执行唤醒操作可能比以相反的顺序执行这些操作更具性能优势。若生产者线程先执行唤醒操作再解锁互斥锁，则在唤醒消费者线程后互斥锁仍然被锁定，消费者线程会立即再次执行等待操作，这会导致2次多余的上下文切换。有些实现通过wait
morphing技术来解决这个问题，该技术会在互斥锁被锁定且不进行上下文切换的情况下，将被唤醒的线程从条件变量等待队列移动到互斥锁等待队列。</p>
<h4 id="判断条件变量的谓词">30.2.2 判断条件变量的谓词</h4>
<p>　　每个条件变量都有1个关联的谓词，该谓词涉及若干个共享变量。在上一小节中的示例中，与<code>cond</code>关联的谓词是<code>(avail == 0)</code>。这段代码展示了1个通用设计原则：<code>pthread_cond_wait()</code>调用必须由<code>while</code>语句控制
(而非<code>if</code>语句)。这也是因为从<code>pthread_cond_wait()</code>返回时没有任何关于谓词状态的保证。因此，应该立即重新检查谓词，若它不处于预期状态，则继续睡眠。</p>
<p>　　不能对<code>pthread_cond_wait()</code>返回时的谓词状态做出假设的原因如下：</p>
<p>　　● <span
style="background-color: yellow">其他线程可能更早被唤醒</span>。可能存在多个线程等待获取与条件变量关联的互斥锁。即使执行唤醒操作的线程将谓词设置为预期状态，其他线程可能更早获取互斥锁并修改相关共享变量的状态，从而更改谓词的状态。</p>
<p>　　● <span style="background-color: yellow">"宽松"
谓词的设计可能更易于实现</span>。有时，将应用程序设计为与基于表示可能性
(而非确定性) 的条件变量更容易，即唤醒操作发送的通知表示
"可能需要做一些事情" (而非
"做一些事情")。通过这种方法，条件变量的唤醒操作可以基于预期谓词状态的疑似状态，被唤醒的线程可以通过重新检查谓词状态来确定是否真的有事情要做。</p>
<p>　　● <span
style="background-color: yellow">可能发生虚假唤醒</span>。对于某些实现，执行等待操作的线程可能在没有线程执行唤醒的操作的情况下被唤醒。这种虚假唤醒是某些多处理器系统高效实现所需技术的
(罕见) 结果，并被SUSv3明确允许。</p>
<h4 id="动态初始化条件变量">30.2.3 动态初始化条件变量</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_cond_init()</code>会动态初始化参数<code>cond</code>指定的条件变量。与互斥锁相同，可以通过参数<code>attr</code>
(之前已被初始化)
来在初始化时设置条件变量的属性。若<code>attr</code>为<code>NULL</code>，则会将使用默认属性来初始化条件变量。</p>
<p>　　SUSv3指出，初始化已初始化的条件变量的结果是未定义的。</p>
<h4 id="销毁条件变量">30.2.4 销毁条件变量</h4>
<p>　　当自动或动态分配的条件变量不再需要时，应该通过<code>pthread_cond_destroy()</code>将其销毁
(无需调用该函数来销毁通过<code>PTHREAD_COND_INITIALIZER</code>静态初始化的条件变量)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　当没有线程等待条件变量时，销毁该条件变量才是安全的。若条件变量位于动态分配的内存区域，则在销毁该条件变量前应先释放该内存区域。自动分配的条件变量应该在其所在的函数返回前被销毁。</p>
<p>　　当条件变量被<code>pthread_cond_destroy()</code>销毁后，可以通过<code>pthread_cond_init()</code>将其重新初始化。</p>
<h4 id="示例程序">30.2.5 示例程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* thread_multijoin.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> threadDied = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> threadMutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保护以下全局变量 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> totThreads = <span class="number">0</span>;  <span class="comment">/* 创建的线程的总数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numLive = <span class="number">0</span>;     <span class="comment">/* 未被合并的线程的总数 (无论是否终止) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numUnjoined = <span class="number">0</span>; <span class="comment">/* 未被合并的终止的线程的总数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程状态 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TS_ALIVE,      <span class="comment">/* 线程未终止 */</span></span><br><span class="line">    TS_TERMINATED, <span class="comment">/* 线程已终止，但未被合并 */</span></span><br><span class="line">    TS_JOINED      <span class="comment">/* 线程已终止，并且已被合并 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程的相关信息 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;     <span class="comment">/* 线程ID */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">tstate</span> <span class="title">state</span>;</span> <span class="comment">/* 线程状态 (TS_*常量) */</span></span><br><span class="line">    <span class="type">int</span> sleepTime;     <span class="comment">/* 线程在终止之前存活的秒数 */</span></span><br><span class="line">&#125; *thread;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx = *((<span class="type">int</span> *)arg);</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    sleep(thread[idx].sleepTime); <span class="comment">/* 模拟执行一些操作 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %d terminating\n&quot;</span>, idx);</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_lock(&amp;threadMutex);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numUnjoined++;</span><br><span class="line">    thread[idx].state = TS_TERMINATED;</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_unlock(&amp;threadMutex);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_cond_signal(&amp;threadDied);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_cond_signal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s, idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s nsecs...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread = <span class="built_in">calloc</span>(argc - <span class="number">1</span>, <span class="keyword">sizeof</span>(*thread));</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建线程 */</span></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; argc - <span class="number">1</span>; idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        thread[idx].sleepTime = getInt(argv[idx + <span class="number">1</span>], GN_NONNEG, <span class="literal">NULL</span>);</span><br><span class="line">        thread[idx].state = TS_ALIVE;</span><br><span class="line">        s = pthread_create(&amp;thread[idx].tid, <span class="literal">NULL</span>, threadFunc, &amp;idx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totThreads = argc - <span class="number">1</span>;</span><br><span class="line">    numLive = totThreads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 合并终止的线程 */</span></span><br><span class="line">    <span class="keyword">while</span> (numLive &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pthread_mutex_lock(&amp;threadMutex);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (numUnjoined == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = pthread_cond_wait(&amp;threadDied, &amp;threadMutex);</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExitEN(s, <span class="string">&quot;pthread_cond_wait&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; totThreads; idx++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (thread[idx].state == TS_TERMINATED)</span><br><span class="line">            &#123;</span><br><span class="line">                s = pthread_join(thread[idx].tid, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                thread[idx].state = TS_JOINED;</span><br><span class="line">                numLive--;</span><br><span class="line">                numUnjoined--;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Reaped thread %d (numLive=%d)\n&quot;</span>, idx, numLive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = pthread_mutex_unlock(&amp;threadMutex);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何合并任意终止的线程。该程序会为每个命令行参数创建1个线程，每个线程会睡眠对应的命令行参数指定的秒数并终止
(睡眠是为了模拟执行一些操作)。</p>
<p>　　该程序会维护1组全局变量来记录创建的线程的相关信息。对于每个线程，全局数组<code>thread</code>中会有1个对应的元素记录其线程ID
(成员<code>tid</code>) 和当前状态
(成员<code>state</code>)。成员<code>state</code>的值只能是<code>TS_ALIVE</code>
(表示线程未终止)、<code>TS_TERMINATED</code>
(表示线程已终止，但未被合并) 或<code>TS_JOINED</code>
(表示线程已终止，并且已被合并)。</p>
<p>　　对于新线程，在睡眠完成后，会将对应的<code>thread</code>元素的成员<code>state</code>赋值为<code>TS_TERMINATED</code>，然后将全局变量<code>numUnjoined</code>加1，最后执行唤醒操作。</p>
<p>　　对于主线程，在创建完线程后，会循环等待条件变量<code>threadDied</code>。当它被唤醒后，会寻找未被合并的终止的线程，然后对这些线程调用<code>pthread_join()</code>，最后将对应的<code>thread</code>元素的成员<code>state</code>赋值为<code>TS_JOINED</code>以及将全局变量<code>numLive</code>和<code>numUnjoined</code>减1。当创建的所有线程都被合并后，主线程会终止循环
(这里也可以让新线程成为分离线程，并从主线程中删除<code>pthread_join()</code>调用)。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第35章 进程优先级和调度</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_35/</url>
    <content><![CDATA[<p>　　对于Linux和大多数UNIX实现，调度进程使用CPU的默认模型是<strong>轮询分时</strong>，即每个进程依次被允许使用CPU一小段时间，这段时间称为<strong>时间片</strong>或<strong>量子</strong>。轮询分时满足交互式多任务系统所需的2个重要要求：</p>
<p>　　● <span
style="background-color: yellow">公平性</span>：每个进程都获得CPU的一部分。</p>
<p>　　● <span
style="background-color: yellow">响应性</span>：进程无需长时间等待就能使用CPU。</p>
<p>　　在轮询时分算法下，进程不能直接决定何时能够使用CPU以及使用时间。每个进程默认轮流使用CPU，直到时间片耗尽或主动放弃CPU
(例如，通过进入睡眠状态或执行磁盘读取)。若所有进程都试图尽可能多地使用CPU
(即没有进程在I/O操作上休眠或阻塞)，则它们将获得大致相当的CPU份额。</p>
<p>　　进程属性<span
style="background-color: yellow">nice值</span>允许进程间接地影响内核调度算法。每个进程都有nice值，其范围从-20
(高优先级) 到+19
(低优先级)，默认为0。但是，对于Linux，nice值是线程属性。对于传统UNIX实现，只有特权进程才能为任意进程分配负nice值
(高优先级)。非特权进程只能通过将自己的nice值设置为大于0的值来降低自己的优先级。通过降低自己的优先级，进程对其他进程很
"友好"，这一事实赋予了该属性名称。</p>
<p>　　通过<code>fork()</code>创建的子进程会继承父进程的nice值，并且nice值在<code>exec()</code>期间会被保留。</p>
<p>　　进程并非严格按照nice值进行调度。相反，nice值仅充当权重因子，使内核调度程序优先调度优先级较高的进程。为进程分配较大的nice值不会导致它完全无法获得CPU，但会使它获得相对较少的CPU时间。nice值对进程调度的影响程度因Linux内核版本或UNIX系统而异。</p>
<p>　　从内核2.6.23开始，新添加的<span
style="background-color: yellow">完全公平调度程序</span> (CFS)
导致nice值的差值对内核调度的影响比之前的内核大很多。因此，nice值较小的进程获得的CPU时间比以前更长，而nice值较大的进程获得的CPU时间比以前更短。</p>
<p>　　对于多处理器系统，需要对
"高优先级的可运行进程始终优先于低优先级进程"
这一说法进行修正，因为每个CPU都有单独的运行队列，并且能够仅根据CPU运行队列进行优先级排序。</p>
<span id="more"></span>
<h3 id="nice值">35.1 nice值</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who)</span>; <span class="comment">/* 成功时返回指定进程的nice值 (可能为负)，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who, <span class="type">int</span> prio)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getpriority()</code>和<code>setpriority()</code>允许进程检索和修改进程的nice值。</p>
<p>　　这2个系统调用都有参数<code>which</code>和<code>who</code>，用于标识目标进程。参数<code>which</code>决定如何解释参数<code>who</code>，该参数只能被指定为<code>PRIO_PROCESS</code>、<code>PRIO_PGRP</code>或<code>PRIO_USER</code>。</p>
<p>　　●
<code>PRIO_PROCESS</code>表示目标进程为进程ID等于<code>who</code>的进程。若<code>who</code>为0，则使用调用进程的进程ID。</p>
<p>　　●
<code>PRIO_PGRP</code>表示目标进程为进程组ID等于<code>who</code>的所有进程。若<code>who</code>为0，则使用调用进程的进程组ID。</p>
<p>　　●
<code>PRIO_USER</code>表示目标进程为实际用户ID等于<code>who</code>的所有进程。若<code>who</code>为0，则使用调用进程的实际用户ID。</p>
<p>　　参数<code>who</code>的数据类型<code>id_t</code>足以容纳进程ID或用户ID。</p>
<p>　　<code>getpriority()</code>会返回指定进程的nice值。若存在多个符合要求的进程，则返回最小的nice值。因为该系统调用在成功调用时可能会返回-1，所以在调用该系统调用前必须先将<code>errno</code>设置为0，然后在返回后检查返回值是否为-1以及<code>errno</code>是否为非0值。</p>
<p>　　<code>setpriority()</code>会将所有目标进程的nice值设置为参数<code>prio</code>指定的值。试图将nice值设置为范围
(+20到-19) 之外的值会自动被限制在该范围内。特权进程
(能力<code>CAP_SYS_NICE</code>)
可以修改任意进程的nice值。除了可以修改自己的nice值之外，当非特权进程的有效用户ID匹配其他进程的实际或有效用户ID时，非特权进程还可以修改该进程的nice值。<code>setpriority()</code>的Linux权限规则不同于SUSv3，SUSv3要求当非特权进程的实际或有效用户ID匹配其他进程的有效用户ID时，非特权进程才能修改该进程的nice值。不同的UNIX实现在这一点上有所不同。有些UNIX实现遵循SUSv3，而其他UNIX实现
(特别是BSD) 则与Linux相同。</p>
<p>　　在Linux内核2.6.12之前，<code>setpriority()</code>的非特权进程调用权限不同于之后的版本和SUSv3。当非特权进程的实际或有效用户ID匹配其他进程的实际用户ID时，非特权进程才能修改该进程的nice值。从Linux
2.6.12开始，权限规则修改为与Linux上的其他类似API
(例如，<code>sched_setscheduler()</code>和<code>sched_setaffinity()</code>)
一致。</p>
<p>　　在Linux内核2.6.12之前，非特权进程只能通过<code>setpriority()</code>
(不可逆地) 增加自己或其他进程的nice值。特权进程
(能力<code>CAP_SYS_NICE</code>) 可以通过该系统调用来减小nice值。</p>
<p>　　从内核2.6.12开始，Linux提供了资源限制<code>RLIMIT_NICE</code>，允许非特权进程增加nice值。非特权进程能够将自己的nice值最大增加至<code>20 - RLIMIT_NICE</code>。因为nice值的范围是-20到+19，所以<code>RLIMIT_NICE</code>的有效范围是1到40
(资源限制的负值有特殊含义，所以<code>RLIMIT_NICE</code>不使用范围-20到+19)。</p>
<p>　　从历史角度，nice值可通过调用<code>nice(incr)</code>修改，该调用会将调用进程的nice值增加<code>incr</code>。该函数仍然可用，但已被更通用的<code>setpriority()</code>取代。</p>
<p>　　与<code>setpriority()</code>类似的命令包括<code>nice</code>和<code>renice</code>。非特权进程可以通过命令<code>nice</code>来以更大的nice值运行程序，而特权进程可以通过该命令来以更小的nice值运行程序。超级用户可通过命令<code>renice</code>来修改现有进程的nice值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_setpriority.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> which, prio;</span><br><span class="line">    <span class="type">id_t</span> who;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span> || <span class="built_in">strchr</span>(<span class="string">&quot;pgu&quot;</span>, argv[<span class="number">1</span>][<span class="number">0</span>]) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(</span><br><span class="line">            <span class="string">&quot;%s &#123;p|g|u&#125; who priority\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  set priority of: p=process; g=process group; u=processes for user\n&quot;</span>,</span><br><span class="line">            argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据命令行参数设置nice值 */</span></span><br><span class="line">    which = (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>) ? PRIO_PROCESS : (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;g&#x27;</span>) ? PRIO_PGRP</span><br><span class="line">                                                                     : PRIO_USER;</span><br><span class="line">    who = getLong(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;who&quot;</span>);</span><br><span class="line">    prio = getInt(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="string">&quot;prio&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setpriority(which, who, prio) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;getpriority&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检索nice值 */</span></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    prio = getpriority(which, who);</span><br><span class="line">    <span class="keyword">if</span> (prio == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;getpriority&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nice value = %d\n&quot;</span>, prio);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>setpriority()</code>和<code>getpriority()</code>的用法。</p>
<h3 id="实时进程调度概述">35.2 实时进程调度概述</h3>
<p>　　标准内核调度算法通常为系统中运行的交互式进程和后台进程提供了足够的性能和响应能力。但是，实时应用程序对调度程序的要求更严格，包括以下要求：</p>
<p>　　●
实时应用程序为外部输入必须提供保证的最大响应时间。在很多情况下，这些保证的最大响应时间必须非常短
(例如，几分之一秒的数量级)。为了满足这一要求，内核必须提供高优先级进程及时获取CPU控制权的功能，从而抢占当前正在运行的任何进程。</p>
<p>　　●
高优先级进程应该能够保持对CPU的独占访问权，直到它完成或主动放弃CPU。</p>
<p>　　● 实时应用程序应该能够控制其组件进程的精确调度顺序。</p>
<p>　　SUSv3详细说明了能够部分满足这些要求的实时进程调度API
(最初在POSIX.1b中定义)。该API提供了2种实时调度策略：<code>SCHED_RR</code>
(轮询) 和<code>SCHED_FIFO</code>
(先到先服务)。在这2个调度策略下运行的进程始终优先于标准轮询分时调度的进程，实时调度API使用常量<code>SCHED_OTHER</code>来标识标准轮询分时调度。</p>
<p>　　满足这3个要求的应用程序称为<span
style="background-color: yellow">硬实时</span>应用程序。但是，POSIX进程调度API不满足这3个要求，尤其是它没有为应用程序提供保证处理输入的响应时间的方法。要实现这一点，需要一些不属于主线Linux内核的操作系统特性
(这些特性也不是大多数标准操作系统的特性)。POSIX API提供的是<span
style="background-color: yellow">软实时</span>，允许控制进程调度。</p>
<p>　　在不给系统带来额外开销的情况下，很难添加对硬实时应用程序的支持，而这种开销又会与典型的桌面和服务器系统中占大多数的分时应用程序的性能要求冲突
(这也是为什么大多数UNIX内核和较旧的Linux内核不提供实时应用程序的原生支持)。但是，从大约版本2.6.18开始，Linux内核添加了各种用于原生完全支持硬实时应用程序而不会对分时操作施加这些开销的特性。</p>
<p>　　Linux提供了99个实时优先级，编号从1到99，并且该范围适用于这2种调度策略。这2种策略的优先级是相同的。若存在2个优先级相同的进程，并且分别采用<code>SCHED_RR</code>和<code>SCHED_FIFO</code>，则根据他们的调度顺序，这2个进程都可能是下一个有资格执行的进程。实际上，每个优先级都有1个可运行进程队列，并且下一个运行的进程是从最高优先级的非空队列的前面选择。</p>
<h4 id="策略sched_rr">35.2.1 策略<code>SCHED_RR</code></h4>
<p>　　对于策略<code>SCHED_RR</code>，同一优先级的进程以轮询分时的方式执行。进程每次使用CPU时都会获得固定时长的时间片。一旦被调度，使用该策略的进程将保持对CPU的控制，直到出现以下情况下之一：</p>
<p>　　● 进程的时间片到期。</p>
<p>　　●
进程通过执行阻塞系统调用或调用系统调用<code>sched_yield()</code>主动放弃CPU。</p>
<p>　　● 进程终止。</p>
<p>　　● 进程被更高优先级的进程抢占。</p>
<p>　　对于前2种情况，进程会失去对CPU的访问，并且被放置在其优先级队列的末尾。对于最后1个情况，当更高优先级的进程停止执行时，被抢占的进程会继续执行，消耗剩余的时间片
(即被抢占的进程仍然处于其优先级队列的开头)。</p>
<p>　　对于策略<code>SCHED_RR</code>和<code>SCHED_FIFO</code>，运行中的进程可能因以下原因之一而被抢占：</p>
<p>　　● 更高优先级的进程退出阻塞状态 (例如，等待的I/O操作完成)。</p>
<p>　　● 其他进程的优先级被提高至高于运行中的进程的优先级的值。</p>
<p>　　●
运行中的进程的优先级被降低至低于其他某些可运行的进程的优先级的值。</p>
<p>　　策略<code>SCHED_RR</code>与标准轮询分时调度算法
(<code>SCHED_OTHER</code>)
类似，最大的区别是严格的优先级，高优先级进程始终优先于低优先级进程。相比之下，较低的nice值
(即较高的优先级)
并不会赋予进程独占CPU的权限，nice值只是充当权重因子。另一个重要的区别是该策略允许精确地控制进程的调度顺序。</p>
<h4 id="策略sched_fifo">35.2.2 策略<code>SCHED_FIFO</code></h4>
<p>　　策略<code>SCHED_FIFO</code>与<code>SCHED_RR</code>类似，最大的不同是没有时间片。一旦<code>SCHED_FIFO</code>进程获得CPU的访问权，它会一直执行，直到出现以下情况之一：</p>
<p>　　●
进程通过执行阻塞系统调用或调用系统调用<code>sched_yield()</code>主动放弃CPU。</p>
<p>　　● 进程终止。</p>
<p>　　● 进程被更高优先级的进程抢占。</p>
<p>　　对于第1种情况，进程会被放置在其优先级队列的末尾。对于最后1种情况，当更高优先级的进程
(因阻塞或终止) 停止执行时，被抢占的进程会继续执行
(即被抢占的进程仍然处于其优先级队列的开头)。</p>
<h4 id="策略sched_batch和sched_idle">35.2.3
策略<code>SCHED_BATCH</code>和<code>SCHED_IDLE</code></h4>
<p>　　Linux内核2.6系列添加了非标准调度策略<code>SCHED_BATCH</code>和<code>SCHED_IDLE</code>。尽管这2个策略需要通过POSIX实时调度API设置，但它们并不是实时策略。</p>
<p>　　策略<code>SCHED_BATCH</code>添加于内核2.6.16，与策略<code>SCHED_OTHER</code>类似。不同之处在于该策略会降低经常唤醒的作业的调度频率。该策略旨在用于进程的批量执行。</p>
<p>　　策略<code>SCHED_IDLE</code>添加于内核2.6.23，与策略<code>SCHED_OTHER</code>类似，但提供的功能等同于非常大的nice值
(即大于+19)。nice值对该策略没有意义。该策略旨在用于运行低优先级作业，只有当系统中没有其他作业需要CPU时，这些作业才会得到CPU的很大一部分。</p>
<h3 id="实时进程调度api">35.3 实时进程调度API</h3>
<p>　　尽管实时调度从内核2.0开始就成为了Linux的一部分，但实现过程中存在一些问题。2.2内核以及早期的2.4内核中的很多特性的实现仍然存在问题。大部分问题在内核2.4.20中得到了解决。</p>
<h4 id="实时优先级范围">35.3.1 实时优先级范围</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回非负的整数优先级，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_min</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_max</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sched_get_priority_min()</code>和<code>sched_get_priority_max()</code>分别会返回参数<code>policy</code>指定的调度策略的最小和最大优先级。<code>policy</code>可以被指定为<code>SCHED_RR</code>或<code>SCHED_FIFO</code>。对于Linux，这2个系统调用分别会返回1和99
(无论<code>SCHED_RR</code>还是<code>SCHED_FIFO</code>)。换句话说，这2个实时策略的优先级范围完全重合
(哪个进程先被调度取决于进程在优先级队列中的位置)。</p>
<p>　　实时优先级的范围因UNIX实现而异。因此，不应该将优先级编码到应用程序中，而应根据这2个系统调用的返回值来指定优先级
(例如，策略<code>SCHED_RR</code>的最小优先级应该被指定为<code>sched_get_priority_min(SCHED_RR)</code>)。</p>
<p>　　SUSv3并未要求策略<code>SCHED_RR</code>和<code>SCHED_FIFO</code>使用相同的优先级范围，但大多数UNIX实现都是如此。</p>
<h4 id="修改和检索策略和优先级">35.3.2 修改和检索策略和优先级</h4>
<h5 id="修改调度策略和优先级">35.3.2.1 修改调度策略和优先级</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setscheduler</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> policy, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setparam</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sched_priority; <span class="comment">/* 调度优先级 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sched_setscheduler()</code>会修改进程ID为<code>pid</code>的进程的调度策略和优先级。若<code>pid</code>为0，则修改调用进程的调度策略和优先级。系统调用<code>sched_setparam()</code>会修改进程ID为<code>pid</code>的进程的调度优先级。这2个系统调用的参数<code>pid</code>和<code>param</code>相同。</p>
<p>　　SUSv3将参数<code>param</code>定义为结构体，并且允许实现添加额外的特定于实现的成员。但是，Linux和大多数UNIX实现仅提供了成员<code>sched_priority</code>，用于指定调度优先级。对于策略<code>SCHED_RR</code>和<code>SCHED_FIFO</code>，该成员必须被指定为<code>sched_get_priority_min()</code>和<code>sched_get_priority_max()</code>之间的值。对于其他策略，该成员必须被指定为0。</p>
<p>　　参数<code>policy</code>用于指定进程的调度策略，只能被指定为以下策略之一：</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 76%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
<th>SUSv3</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SCHED_FIFO</code></td>
<td>实时先到先服务</td>
<td>✓</td>
</tr>
<tr>
<td><code>SCHED_RR</code></td>
<td>实时轮询</td>
<td>✓</td>
</tr>
<tr>
<td><code>SCHED_OTHER</code></td>
<td>标准轮询分时</td>
<td>✓</td>
</tr>
<tr>
<td><code>SCHED_BATCH</code></td>
<td>与<code>SCHED_OTHER</code>类似，但用于批量执行 (Linux
2.6.16及以上版本)</td>
<td></td>
</tr>
<tr>
<td><code>SCHED_IDLE</code></td>
<td>与<code>SCHED_OTHER</code>类似，但优先级低于nice值+19 (Linux
2.6.23及以上版本)</td>
<td></td>
</tr>
</tbody>
</table>
<p>　　成功的<code>sched_setscheduler()</code>和<code>sched_setparam()</code>调用会将<code>pid</code>指定的进程移动到优先级队列的末尾。</p>
<p>　　SUSv3要求，成功的<code>sched_setscheduler()</code>调用应该返回上一个调度策略。但是，Linux有所不同，该系统调用会在成功时返回0。可移植应用程序应该通过检查该系统调用的返回值不是-1来判断是否成功。</p>
<p>　　通过<code>fork()</code>创建的子进程会继承父进程的调度策略和优先级，并且调度策略和优先级在<code>exec()</code>期间会被保留。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sched_set.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j, pol;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">sp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strchr</span>(<span class="string">&quot;rfo&quot;</span>, argv[<span class="number">1</span>][<span class="number">0</span>]) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s policy priority [pid...]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  policy is &#x27;r&#x27; (RR), &#x27;f&#x27; (FIFO), &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH <span class="comment">/* 特定于Linux */</span></span></span><br><span class="line">                 <span class="string">&quot;&#x27;b&#x27; (BATCH), &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE <span class="comment">/* 特定于Linux */</span></span></span><br><span class="line">                 <span class="string">&quot;&#x27;i&#x27; (IDLE), &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                 <span class="string">&quot;or &#x27;o&#x27; (OTHER)\n&quot;</span>,</span><br><span class="line">                 argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pol = (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>) ? SCHED_RR : (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>) ? SCHED_FIFO</span><br><span class="line">                                       :</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH</span></span><br><span class="line">                                       (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;b&#x27;</span>) ? SCHED_BATCH</span><br><span class="line">                                       :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE</span></span><br><span class="line">                                       (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>) ? SCHED_IDLE</span><br><span class="line">                                                           :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                                           SCHED_OTHER;</span><br><span class="line">    sp.sched_priority = getInt(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;priority&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sched_setscheduler(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>), pol, &amp;sp) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sched_setscheduler&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>sched_setscheduler()</code>的用法。第1个命令行参数是1个字母，用于指定调度策略。第2个命令行参数是整数，用于指定优先级。剩余的命令行参数是目标进程的进程ID。</p>
<h5 id="影响调度参数修改的特权和资源限制">35.3.2.2
影响调度参数修改的特权和资源限制</h5>
<p>　　对于2.6.12之前的内核，通常只有特权进程
(能力<code>CAP_SYS_NICE</code>)
才能修改调度策略和优先级。但是，当非特权进程的有效用户ID匹配目标进程的实际或有效用户ID时，它可以将目标进程的调度策略修改为<code>SCHED_OTHER</code>。</p>
<p>　　从内核2.6.12开始，随着新的非标准资源限制<code>RLIMIT_RTPRIO</code>的添加，设置实时调度策略和优先级的规则发生了变化。与较旧的内核相同，特权进程
(能力<code>CAP_SYS_NICE</code>)
可以修改任意进程的调度策略和优先级。但是，非特权进程也可以根据以下规则修改调度策略和优先级：</p>
<p>　　●
若进程的<code>RLIMIT_RTPRIO</code>软限制不为0，则它可以任意修改自己的调度策略和优先级，但它可以设置的实时优先级上限不能超过其当前实时优先级
(若进程当前在实时策略下运行)
与其<code>RLIMIT_RTPRIO</code>软限制中的最大值。</p>
<p>　　●
若进程的<code>RLIMIT_RTPRIO</code>软限制为0，则它只能降低自己的实时优先级或从实时策略切换到非实时策略。</p>
<p>　　●
策略<code>SCHED_IDLE</code>比较特殊，运行在该策略下的进程无法修改自己的策略
(无论<code>RLIMIT_RTPRIO</code>软限制是多少)。</p>
<p>　　●
进程也可以修改其他非特权进程的调度策略和优先级，只要该进程的有效用户ID匹配目标进程的实际或有效用户ID。</p>
<p>　　●
进程的<code>RLIMIT_RTPRIO</code>软限制仅决定其他进程对该进程或该进程对自己的调度策略和优先级的修改。非0的限制不会赋予非特权进程修改其他进程的调度策略和优先级的能力。</p>
<p>　　从内核2.6.25开始，Linux添加了实时调度组的概念，由内核选项<code>CONFIG_RT_GROUP_SCHED</code>配置，它还会影响设置实时调度策略时可以做出的修改。</p>
<h5 id="检索调度策略和优先级">35.3.2.3 检索调度策略和优先级</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getscheduler</span><span class="params">(<span class="type">pid_t</span> pid)</span>; <span class="comment">/* 成功时返回调度策略，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getparam</span><span class="params">(<span class="type">pid_t</span> pid, <span class="keyword">struct</span> sched_param *param)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sched_getscheduler()</code>和<code>sched_getparam()</code>分别会检索进程ID为<code>pid</code>的进程的调度策略和优先级。若<code>pid</code>为0，则检索调用进程的信息。此外，非特权进程可以通过这2个系统调用来检索任意进程的信息。</p>
<p>　　<code>sched_getparam()</code>会通过参数<code>param</code>指向的结构体<code>sched_param</code>的成员<code>sched_priority</code>来返回指定进程的实时优先级。</p>
<p>　　若<code>sched_getscheduler()</code>调用成功，则返回35.3.2.1的表格所列出的策略之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sched_view.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j, pol;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">sp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        pol = sched_getscheduler(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (pol == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sched_getscheduler&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sched_getparam(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>), &amp;sp) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sched_getparam&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %-5s %2d\n&quot;</span>, argv[j],</span><br><span class="line">               (pol == SCHED_OTHER) ? <span class="string">&quot;OTHER&quot;</span> : (pol == SCHED_RR) ? <span class="string">&quot;RR&quot;</span></span><br><span class="line">                                            : (pol == SCHED_FIFO) ? <span class="string">&quot;FIFO&quot;</span></span><br><span class="line">                                            :</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH <span class="comment">/* 特定于Linux */</span></span></span><br><span class="line">                                            (pol == SCHED_BATCH) ? <span class="string">&quot;BATCH&quot;</span></span><br><span class="line">                                            :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE <span class="comment">/* 特定于Linux */</span></span></span><br><span class="line">                                            (pol == SCHED_IDLE) ? <span class="string">&quot;IDLE&quot;</span></span><br><span class="line">                                                                :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                                                <span class="string">&quot;???&quot;</span>,</span><br><span class="line">               sp.sched_priority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>sched_getscheduler()</code>和<code>sched_getparam()</code>的用法。以下shell会话展示了该程序的用法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">sleep</span> 100 &amp;</span></span><br><span class="line">[1] 2006</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./sched_view 2006</span></span><br><span class="line">2006: OTHER  0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./sched_set f 25 2006</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./sched_view 2006</span></span><br><span class="line">2006: FIFO  25</span><br></pre></td></tr></table></figure>
<h5 id="防止实时进程锁定系统">35.3.2.4 防止实时进程锁定系统</h5>
<p>　　<code>SCHED_RR</code>和<code>SCHED_FIFO</code>进程会抢占所有低优先级的进程，所以当开发使用这些策略的应用程序时，需要注意失控的实时应用程序可能因过度占用CPU而锁定系统。从编程角度，可以通过以下方法来避免这种可能性：</p>
<p>　　● 通过<code>setrlimit()</code>设置合适的较小的软CPU时间资源限制
(<code>RLIMIT_CPU</code>)。若进程消耗过多的CPU时间，则信号<code>SIGXCPU</code>会被发送给该进程
(默认处理方式是终止进程并生成核心转储文件)。</p>
<p>　　●
通过<code>alarm()</code>设置定时器。若进程持续运行的挂钟时间超过<code>alarm()</code>指定的秒数，则信号<code>SIGALRM</code>会被发送给该进程
(默认处理方式是终止进程)。</p>
<p>　　●
创建1个以高实时优先级运行的看门狗进程，该进程会反复循环，休眠指定时间，然后唤醒并监控其他进程的状态。这种监控可以包括每个进程的CPU时间时钟的值以及通过<code>sched_getscheduler()</code>和<code>sched_getparam()</code>检查每个进程的调度策略和优先级。若某个进程被认为行为异常，则看门狗线程可以降低其优先级，或者通过发送合适的信号来暂停或终止它。</p>
<p>　　●
从内核2.6.25开始，Linux提供了非标准资源限制<code>RLIMIT_RTTIME</code>
(单位为毫秒)，用于控制在实时调度策略下运行的进程在单次突发中可消耗的CPU时间量。该资源限制可以限制进程在不执行阻塞系统调用时可消耗的CPU时间量。当进程执行阻塞系统调用时，其已消耗的CPU时间会被重置为0。当进程被高优先级进程抢占、时间片到期
(对于<code>SCHED_RR</code>进程)
或调用<code>sched_yield()</code>时，其已消耗的CPU时间不会被重置。当进程达到其CPU时间限制时，信号<code>SIGXCPU</code>会被发送给该进程。此外。2.6.25中的修改还有助于防止失控的实时进程锁定系统。</p>
<h5 id="防止子进程继承特权调度策略">35.3.2.5
防止子进程继承特权调度策略</h5>
<p>　　Linux
2.6.32添加了<code>SCHED_RESET_ON_FORK</code>作为调用<code>sched_setscheduler()</code>时可以指定给<code>policy</code>的值。它是标志值，可以与35.3.2.1的表格中的策略进行或运算<code>|</code>。若设置了该标志，则通过<code>fork()</code>创建的子进程不会继承特权调度策略和优先级，具体规则如下：</p>
<p>　　● 若调用进程具有实时调度策略
(<code>SCHED_RR</code>或<code>SCHED_FIFO</code>)，则子进程的策略会被重置<code>SCHED_OTHER</code>。</p>
<p>　　● 若进程有负的nice值
(即较高的优先级)，则子进程的nice值会被重置为0。</p>
<p>　　标志<code>SCHED_RESET_ON_FORK</code>旨在用于媒体播放应用程序。它允许创建单个具有实时调度策略的进程，该策略不会被子进程继承。使用该标志可以防止fork炸弹
(通过创建多个在实时调度策略下运行的子进程来试图逃避资源限制<code>RLIMIT_RTTIME</code>设置的上限)。</p>
<p>　　一旦进程的标志<code>SCHED_RESET_ON_FORK</code>被启用，只有特权进程
(能力<code>CAP_SYS_NICE</code>)
才能禁用该标志。当创建子进程时，子进程的的该标志会被禁用。</p>
<h4 id="放弃cpu">35.3.3 放弃CPU</h4>
<p>　　实时进程可以通过以下2种方式放弃CPU：</p>
<p>　　● 调用会阻塞进程的系统调用
(例如，在终端中调用<code>read()</code>)。</p>
<p>　　● 调用<code>sched_yield()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_yield</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sched_yield()</code>的行为很简单。若调用进程的优先级队列中存在其他可运行的进程，则调用进程会被放置在队列的末尾，并且队列开头的进程会被调度使用CPU；否则，该系统调用不会进行任何操作
(调用进程继续使用CPU)。</p>
<p>　　SUSv3允许<code>sched_yield()</code>出错。但是，对于Linux和大部分UNIX实现，该系统调用总是会成功。可移植应用程序总是应该检查该系统调用的返回值。</p>
<p>　　非实时进程调度<code>sched_yield()</code>的行为是未定义的。</p>
<h4 id="sched_rr时间片">35.3.4 <code>SCHED_RR</code>时间片</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_rr_get_interval</span><span class="params">(<span class="type">pid_t</span> pid, <span class="keyword">struct</span> timespec *tp)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sched_rr_get_interval()</code>会将进程ID为<code>pid</code>的<code>SCHED_RR</code>进程的时间片存储在参数<code>tp</code>指向的缓冲区中
(见15.2.2)。若<code>pid</code>为0，则将调用进程作为目标进程。</p>
<h3 id="cpu亲和性">35.4 CPU亲和性</h3>
<p>　　对于多处理器系统，当进程被重新调度时，它不一定会在上一次运行的CPU上运行
(通常是因为该CPU可能很忙)。当进程切换CPU时，会有性能影响：假设进程的某行数据加载位于旧CPU的缓存中，为了该行数据加载到新CPU的缓存中，必须先使其无效，若数据未被修改，则将其丢弃；若数据已被修改，则将其刷新到内存
(为了防止缓存不一致，多处理器架构仅允许数据在同一时间存储在1个CPU的缓存中)。这会消耗执行时间。因此，Linux内核
(2.6) 会尽量确保进程的<span
style="background-color: yellow">软</span>CPU亲和性——进程尽可能地被重新调度到上一次运行的CPU上。</p>
<p>　　<span
style="background-color: yellow">缓存行</span>是缓存中类似于虚拟内存管理系统中页的概念。它是CPU缓存与内存之间的数据传输单位，其范围通常为32~128字节。</p>
<p>　　特定于Linux的文件<code>/proc/PID/stat</code>中的1个字段可用于获取进程当前正在运行或最后运行的CPU的编号。</p>
<p>　　有时，需要为进程设置<span
style="background-color: yellow">硬</span>CPU亲和性，以便于明确限制该进程始终在某个可用CPU或可用CPU的子集上运行。原因如下：</p>
<p>　　● 避免无效化缓存数据而导致的性能影响。</p>
<p>　　● 若多个线程 (或进程)
在访问同一数据，则可以将它们全部限制在同一CPU上，这样它们就不会争用数据而导致缓存未命中，从而获得性能优势。</p>
<p>　　●
对于时间关键型应用程序，可能需要将系统中的大多数进程限制在其他CPU上，同时为时间关键型应用程序保留CPU。</p>
<p>　　内核引导选项<code>isolcpus</code>可用于将多个CPU与正常的内核调度算法隔离。该引导选项是实现第3个场景的首选方法。Linux还提供了内核选项<code>cpuset</code>，可以在包含大量CPU的系统上使用，以实现对如何将CPU和内存分配给进程的更复杂的控制。</p>
<p>　　Linux
2.6提供了非标准系统调用<code>sched_setaffinity()</code>和<code>sched_getaffinity()</code>来修改和检索线程的硬CPU亲和性。这2个系统调用是特定于Linux的。</p>
<p>　　很多UNIX实现都提供了用于控制CPU亲和性的接口
(例如，HP-UX和Solaris提供了系统调用<code>pset_bind()</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> len, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> len, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_ZERO</span><span class="params">(<span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_SET</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_CLR</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">CPU_ISSET</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">/* cpu在set中时返回真(1)，cpu不在set中时返回假(0) */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>sched_setaffinity()</code>会设置线程ID
(通过<code>gettid()</code>返回)
为<code>pid</code>的线程的CPU亲和性。若<code>pid</code>为0，则设置调用线程的CPU亲和性。为线程设置的CPU亲和性通过参数<code>set</code>指向的结构体<code>cpu_set_t</code>指定。</p>
<p>　　系统调用<code>sched_getaffinity()</code>会检索线程ID为<code>pid</code>的线程的CPU亲和性掩码。若<code>pid</code>为0，则检索调用线程的CPU亲和性掩码。CPU亲和性掩码结果存储在参数<code>set</code>指向的结构体<code>cpu_set_t</code>中。参数<code>len</code>应该被指定为该结构体的字节数
(即<code>sizeof(cpu_set_t)</code>)。</p>
<p>　　尽管数据类型<code>cpu_set_t</code>被实现为位掩码，但应该将其视为不透明的结构体。对该结构体的所有操作应该通过宏<code>CPU_ZERO()</code>、<code>CPU_SET()</code>、<code>CPU_CLR()</code>和<code>CPU_ISSET()</code>进行。glibc还提供了很多其他用于处理该结构体的宏。</p>
<p>　　● <code>CPU_ZERO()</code>会将<code>set</code>初始化为空。</p>
<p>　　● <code>CPU_SET()</code>会将CPU
<code>cpu</code>添加到<code>set</code>。</p>
<p>　　● <code>CPU_CLR()</code>会从<code>set</code>中删除CPU
<code>cpu</code>。</p>
<p>　　● <code>CPU_ISSET()</code>会在CPU
<code>cpu</code>是<code>set</code>的成员时返回真。</p>
<p>　　以下代码展示了如何将<code>pid</code>指定的线程限制在4处理器系统的第1个CPU以外的CPU上运行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">cpu_set_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">CPU_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">CPU_SET(<span class="number">1</span>, &amp;<span class="built_in">set</span>);</span><br><span class="line">CPU_SET(<span class="number">2</span>, &amp;<span class="built_in">set</span>);</span><br><span class="line">CPU_SET(<span class="number">3</span>, &amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">sched_setaffinity(pid, CPU_SETSIZE, &amp;<span class="built_in">set</span>);</span><br></pre></td></tr></table></figure>
<p>　　对于<code>sched_getaffinity()</code>，若<code>set</code>指定的CPU不对应系统中的任何CPU，则会出错
(<code>EINVAL</code>)。若<code>set</code>中不包含调用线程正在运行的CPU，则该线程会被迁移到<code>set</code>中的某个CPU上。</p>
<p>　　当非特权线程的有效用户ID匹配目标线程的实际或有效用户ID时，非特权线程可以设置目标线程的CPU亲和性。特权线程
(能力<code>CAP_SYS_NICE</code>) 可以修改任何线程的CPU亲和性。</p>
<p>　　若目标线程的CPU亲和性掩码未被修改，则<code>sched_getaffinity()</code>会返回包含系统中的所有CPU的集合。非特权线程可以调用<code>sched_getaffinity()</code>来检索任意线程的CPU亲和性掩码。</p>
<p>　　通过<code>fork()</code>创建的子进程会继承父进程中调用<code>fork()</code>的线程的CPU亲和性掩码，并且该掩码在<code>exec()</code>期间会被保留。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第34章 进程组、会话和作业控制</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/</url>
    <content><![CDATA[<p>　　<strong>进程组</strong> (有时称为<strong>作业</strong>)
是由若干个共享同一<span
style="background-color: yellow">进程组标识符</span> (PGID)
的进程组成的集合。进程组ID是与进程ID数据类型 (<code>pid_t</code>)
相同的数字。进程组有1个<strong>进程组组长</strong>。进程组组长是创建进程组的进程，其进程ID会成为创建的进程组的进程组ID。子进程会继承父进程的进程组ID。</p>
<p>　　进程组的生命周期从进程组组长创建进程组开始，到最后1个进程离开进程组结束。进程可能因终止或合并其他进程而离开进程组。进程组组长无需是进程组的最后1个进程。</p>
<p>　　<strong>会话</strong>是进程组集合。进程所属的会话由<span
style="background-color: yellow">会话标识符</span> (SID)
决定。会话ID是与进程ID数据类型 (<code>pid_t</code>)
相同的数字。<strong>会话组长</strong>是创建会话的进程，其进程ID会成为创建的会话的会话ID。子进程会继承父进程的会话ID。</p>
<p>　　会话中的所有进程共享同一<strong>控制终端</strong>。当创建会话时，新会话没有控制终端。当会话组长第1次打开尚未成为会话的控制终端的终端时，将建立控制终端，除非在调用<code>open()</code>时指定了标志<code>O_NOCTTY</code>。作为与控制终端建立连接的结果，会话组长会成为控制终端的<strong>控制进程</strong>。若控制终端断开连接，则内核会发送信号<code>SIGHUP</code>给它的控制进程。1个终端最多只能成为1个会话的控制终端。</p>
<p>　　通过检查特定于Linux的文件<code>/proc/PID/stat</code>，可以获取任何进程的进程组ID和会话ID、进程的控制终端的设备ID
(包含主ID和次ID的十进制整数) 以及控制终端的控制进程的进程ID。</p>
<p>　　在任何时刻，会话中只能有1个进程组成为控制终端的<strong>前台进程组</strong>，其他进程组都是<strong>后台进程组</strong>。只有前台进程组中的进程才能自由地读写控制终端。当用户在控制终端输入信号生成终端字符时，对应的信号会被发送给前台进程组的所有进程。信号生成终端字符包括生成信号<code>SIGINT</code>的中断字符
(通常是Control-C)、生成信号<code>SIGQUIT</code>的退出字符
(通常是Control-\) 以及生成信号<code>SIGTSTP</code>的挂起字符
(通常是Control-Z)。</p>
<p>　　从理论角度，可能出现没有前台进程组的会话
(例如，前台进程组的所有进程都已终止，而其他进程没有注意这一点并将自己移动到前台进程组)。实际上，这种情况很罕见。通常，shell是监控前台进程组状态的进程，并且当它注意到
(通过<code>wait()</code>)
前台进程组的所有进程都已终止时，它会将自己移动到前台进程组。</p>
<p>　　进程组和会话主要用于shell作业控制。对于交互式登录，控制终端是用户登录的终端，登录shell会成为会话组长和该终端的控制进程。从shell启动的每个命令或管道都会导致进程创建，并且shell会将创建的进程放置在新进程组中
(这些进程是该进程组的初始进程，这些进程的子进程也属于该进程组)。若命令或管道以与号<code>&amp;</code>结尾，则会创建为后台进程组；否则，它将被创建为前台进程组。在登录会话期间创建的所有进程都属于同一会话。</p>
<p>　　进程组偶尔会用于作业控制以外的领域，因为它具有2个有用的属性：父进程可以等待特定进程组中的任何子进程
(见26.1.2)，并且可以向进程组的所有进程发送信号 (见20.3)。</p>
<p>　　对于窗口环境，控制终端是伪终端，每个终端窗口都有单独的会话，窗口的启动shell是该终端的会话组长和控制进程。</p>
<span id="more"></span>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/relationships_between_process_groups,sessions_and_the_controlling_terminal.svg" class="">
<p>　　上图展示了执行以下命令的结果进程之间的进程组和会话关系：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $$</span></span><br><span class="line">400</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find / 2&gt; /dev/null | <span class="built_in">wc</span> -l &amp;</span></span><br><span class="line">[1] 659</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> &lt; longlist | <span class="built_in">uniq</span> -c</span> </span><br></pre></td></tr></table></figure>
<p>　　作业控制是1980年左右第1次出现在BSD的<code>csh</code>的特性。作业控制允许shell用户同时执行多个命令
(作业)，其中的1个命令在前台执行，其他命令在后台执行。作业可以停止和恢复，并且可以在前台和后台之间切换。</p>
<p>　　对于最初的POSIX.1，作业控制的支持是可选的。后来的UNIX标准则强制要求支持该特性。</p>
<p>　　在基于字符的哑终端 (仅限于显示ASCII字符的物理终端设备)
时代，许多shell用户都知道如何使用shell作业控制命令。随着运行X
Window系统的位图显示器的出现，有关shell作业控制的知识已经不那么常见了。但是，作业控制仍然是有用的特性。使用作业控制来管理多个同时运行的命令比在窗口之间来回切换更便捷。</p>
<h3 id="进程组">34.1 进程组</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 总是返回调用进程的进程组ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getpgrp()</code>会返回调用进程的进程组ID。</p>
<p>　　系统调用<code>setpgid()</code>会将参数<code>pid</code>指定的进程的进程组ID修改为<code>pgid</code>。若<code>pid</code>为0，则会修改调用进程的进程组ID。若<code>pgid</code>为0，则会将参数<code>pid</code>指定的进程的进程组ID修改为它的进程ID。</p>
<p>　　若<code>pid</code>和<code>pgid</code>指定的是同一进程
(即<code>pgid</code>为0或匹配<code>pid</code>指定的进程的进程ID)，则会创建1个进程组，并让指定的进程成为进程组组长。若<code>pid</code>和<code>pgid</code>被指定为不同值
(即<code>pgid</code>不为0且不匹配<code>pid</code>指定的进程的进程ID)，则会将进程移动到指定进程组。</p>
<p>　　<code>setpgid()</code> (和<code>setsid()</code>)
通常用于shell或<code>login</code>等程序。</p>
<p>　　<code>setpgid()</code>受到以下规则的约束：</p>
<p>　　● <code>pid</code>只能被指定为调用进程或它的子进程
(违反该规则会导致错误<code>ESRCH</code>)。</p>
<p>　　●
当在进程组之间移动进程时，调用进程、<code>pid</code>指定的进程以及目标进程组必须属于同一会话
(违反该规则会导致错误<code>EPERM</code>)。</p>
<p>　　● <code>pid</code>指定的进程不能是会话组长
(违反该规则会导致错误<code>EPERM</code>)。</p>
<p>　　●
当子进程调用<code>exec()</code>后，父进程不能修改该子进程的进程组ID，因为程序启动后其进程组ID的改变可能会导致混乱
(违反该规则会导致错误<code>EACCES</code>)。</p>
<h4 id="在作业控制shell中使用setpgid">34.1.1
在作业控制shell中使用<code>setpgid()</code></h4>
<p>　　父进程不能在子进程调用<code>exec()</code>后修改该子进程的进程组ID的规则影响了作业控制shell的编程，这些shell存在以下要求：</p>
<p>　　● 作业 (即命令或管道)
中的所有进程必须属于同一进程组。该步骤允许shell使用<code>killpg()</code>
(或<code>kill()</code>)
来同时发送作业控制信号给进程组中的所有进程。当然，该操作必须在发送作业控制信号之前完成。</p>
<p>　　●
将子进程移动到其他进程组的操作必须在子进程在调用<code>exec()</code>之前完成，因为程序本身不知道进程组ID的操作。</p>
<p>　　作业中的父进程和子进程都可以使用<code>setpgid()</code>来修改子进程的进程组ID。但是，因为在<code>fork()</code>之后父进程和子进程的调度是不确定的，所以不能保证父进程在子进程执行<code>exec()</code>之前修改子进程的进程组ID，也不能保证子进程在父进程试图向其发送作业控制信号之前修改自己的进程组ID。因此，作业控制shell必须被设计为父进程和子进程都在<code>fork()</code>返回之后立即调用<code>setpgid()</code>，并且父进程忽略<code>setpgid()</code>出现错误<code>EACCES</code>的情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> childPid;</span><br><span class="line"><span class="type">pid_t</span> pipelinePgid; <span class="comment">/* 管道中的进程的PGID */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他代码 */</span></span><br><span class="line"></span><br><span class="line">childPid = fork();</span><br><span class="line"><span class="keyword">switch</span> (childPid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">/* fork()出错 */</span></span><br><span class="line">    <span class="comment">/* 错误处理 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (setpgid(<span class="number">0</span>, pipelinePgid) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 错误处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 调用exec() */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 父进程 (shell) */</span></span><br><span class="line">    <span class="keyword">if</span> (setpgid(childPid, pipelinePgid) == <span class="number">-1</span> &amp;&amp; errno != EACCES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 错误处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 执行其他操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　实际情况比这个示例略微复杂一些，因为当为管道创建进程时，父shell会记录管道中第1个进程的进程ID，并将其作为进程组ID
(<code>pipelinePgid</code>)。</p>
<h4 id="其他用于检索和修改进程组id的接口">34.1.2
其他用于检索和修改进程组ID的接口</h4>
<p>　　系统调用<code>getpgrp()</code>和<code>setpgid()</code>的名称中的不同后缀值得解释。</p>
<p>　　最初，4.2BSD提供了系统调用<code>getprgp(pid)</code>，该系统调用会返回<code>pid</code>指定的进程的进程组ID。实际上，<code>pid</code>总是用于指定调用进程。因此，POSIX委员会认为该调用过于复杂，所以采用了System
V的<code>getpgrp()</code>调用
(没有参数，并且总是返回调用进程的进程组ID)。</p>
<p>　　为了修改进程组ID，4.2BSD提供了<code>setpgrp(pid, pgid)</code>，其用法与<code>setpgid()</code>的类似。主要区别在于BSD的<code>setpgrp()</code>可用于将进程组ID设置为任意值
(<code>setpgid()</code>不能将进程移动到其他会话的进程组)。这会导致一些安全问题，并且也比实现作业控制所需的灵活性更高。因此，POSIX委员会采用了更具限制性的函数，并将其命名为<code>setpgid()</code>。</p>
<p>　　进一步复杂化问题的是，SUSv3详细说明了<code>getprgp(pid)</code>，使用的是旧版BSD的<code>getpgrp()</code>的语义，并且还说明了<code>setpgrp()</code>的替代函数
(源于System
V)，该替代函数没有参数，大致等同于<code>setpgid(0, 0)</code>。</p>
<p>　　尽管<code>getpgrp()</code>和<code>setpgid()</code>足以实现shell作业控制，但Linux和大多数UNIX实现仍然提供了<code>getpgid(pid)</code>和<code>setpgrp(void)</code>。此外，很多BSD衍生实现还提供了等同于<code>setpgid(pid, pgid)</code>的<code>setprgp(pid, pgid)</code>来保证向后兼容。</p>
<p>　　若编译程序时显式地定义了特性测试宏<code>_BSD_SOURCE</code>，则glibc提供的将是<code>getpgrp()</code>和<code>setpgrp()</code>的BSD衍生版本，而非默认版本。</p>
<h3 id="会话">34.2 会话</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>; <span class="comment">/* 返回指定进程的会话ID，出错时返回(pid_t)-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getsid()</code>会返回参数<code>pid</code>指定的进程的会话ID。若<code>pid</code>为0，则返回调用进程的会话ID。</p>
<p>　　对于少数UNIX实现 (例如，HP-UX
11)，<code>getsid()</code>只能用于检索与调用进程属于同一会话的进程的会话ID，并且SUSv3允许这种可能性。若<code>pid</code>指定的进程属于其他会话，则<code>getsid()</code>返回-1，并将<code>errno</code>设置为<code>EPERM</code>。该限制不适用于Linux和其他大多数UNIX实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回新会话的会话ID，出错时返回(pid_t)-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　若调用进程不是进程组组长，则系统调用<code>setsid()</code>会创建1个新会话，调用进程会成为新会话的组长以及新会话中的进程组的组长
(将调用进程的进程组ID和会话ID设置为其进程ID)。</p>
<p>　　若调用进程是进程组组长，则<code>setsid()</code>会出错
(<code>EPERM</code>)。防止这种情况发生的最简单的方法是调用<code>fork()</code>并让父进程退出，同时子进程调用<code>setsid()</code>。子进程会继承父进程的进程组ID，但会有自己的进程ID，所以子进程不会成为进程组组长。</p>
<p>　　阻止进程组组长调用<code>setsid()</code>的限制是有必要的。如果没有该限制，进程组组长可能会将自己移动其他
(新) 会话，而原进程组的其他进程仍然留在原会话
(这不会创建新进程组，因为根据定义，进程组组长的进程组ID已经与其进程ID相同)。这将违反会话和进程组的2级层次结构，即进程组的所有进程都必须属于同一会话。</p>
<p>　　当通过<code>fork()</code>创建新进程时，内核不仅会确保新进程有唯一的进程ID，还会确保其进程ID不会与所有现有进程的进程组ID和会话ID相同。因此，即使进程组或会话的组长已退出，新进程也不会重用组长的进程ID
(进而意外地成为现有进程组或会话的组长)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* t_setsid.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsid() == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld, PGID=%ld, SID=%ld\n&quot;</span>, (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getpgrp(), (<span class="type">long</span>)getsid(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDWR) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open /dev/tty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何通过<code>setsid()</code>创建新会话。该程序会试图打开特殊文件<code>/dev/tty</code>来检查自己是否不再拥有控制终端。当运行该程序后，得到以下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -p $$ -o <span class="string">&#x27;pid pgid sid command&#x27;</span></span></span><br><span class="line">    PID    PGID     SID COMMAND</span><br><span class="line">  12243   12243   12243 bash</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_setsid</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">PID=12352, PGID=12352, SID=12352</span></span><br><span class="line">ERROR [ENXIO Device not configured] open /dev/tty</span><br></pre></td></tr></table></figure>
<p>　　进程成功地将自己移动到新会话的新进程组。因为新会话没有控制终端，所以<code>open()</code>会出错
(在第5行，shell提示符已经与程序输出混合在一起，因为shell注意到父进程在<code>fork()</code>调用后已经退出，所以在子进程完成之前打印了下一个提示符)。</p>
<h3 id="控制终端和控制进程">34.3 控制终端和控制进程</h3>
<p>　　<code>fork()</code>创建的子进程会继承父进程的控制终端，并且<code>exec()</code>期间控制终端会被保留。</p>
<p>　　若进程有控制终端，则打开特殊文件<code>/dev/tty</code>会得到控制终端的文件描述符。当标准输入和输出被重定向，并且程序需要确保它与控制终端通信时，这很有用。若进程没有控制终端，则打开<code>/dev/tty</code>会出错
(<code>ENXIO</code>)。</p>
<p>　　SUSv3详细说明了函数<code>tcgetsid(int fd)</code>
(原型位于在头文件<code>termios.h</code>中)，它会返回<code>fd</code>指定的控制终端关联的会话的ID。该函数由glibc提供，glibc将其实现为基于<code>ioctl()</code>的操作<code>TIOCGSID</code>
(<code>ioctl(int fd, TIOCGSID, pid_t *argp)</code>)。</p>
<p>　　<code>ioctl()</code>的操作<code>TIOCNOTTY</code>
(<code>ioctl(int fd, TIOCNOTTY)</code>)
可用于删除进程与<code>fd</code>指定的控制终端的关联。尽管SUSv3没有说明该操作，但大多数UNIX实现都提供了该操作。若调用进程是终端的控制进程，则对于控制进程的终止，将发生以下步骤：</p>
<p>　　1) 会话的所有进程都会失去与控制终端的关联。</p>
<p>　　2)
控制终端失去与会话的关联，并且可以作为其他会话组长的控制终端。</p>
<p>　　3)
内核发送信号<code>SIGHUP</code>给前台进程组的所有进程来通知它们失去了控制终端。</p>
<p>　　SUSv3没有说明会话获取控制终端的行为，仅说明了通过<code>open()</code>打开终端时指定了标志<code>O_NOCTTY</code>会保证该终端不会成为会话的控制终端
(该Linux语义源于System V)。</p>
<p>　　对于BSD，会话组长打开终端绝不会使该终端成为它的控制终端。相反，会话组长需要显式地使用<code>ioctl()</code>的操作<code>TIOCSCTTY</code>
(<code>ioctl(fd, TIOCSCTTY, int arg)</code>)
来让<code>fd</code>引用的终端成为控制终端。Linux提供了该操作，但很多
(非BSD) UNIX实现未提供该操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">/* 定义常量L_ctermid */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctermid</span><span class="params">(<span class="type">char</span> *ttyname)</span>; <span class="comment">/* 返回控制终端的路径名字符串，无法获取控制终端的路径名时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>ctermid()</code>会返回调用进程的控制终端的路径名字符串。该函数会以2种方式返回控制终端的路径名字符串：返回值和参数<code>ttyname</code>。若<code>ttyname</code>不为<code>NULL</code>，则它应该指向不小于<code>L_ctermid</code>字节的缓冲区，并且会包含控制终端的路径名。在这种情况下，返回值也是指向该缓冲区的指针。若<code>ttyname</code>为<code>NULL</code>，则返回值是指向静态分配的缓冲区的指针。因此，当<code>ttyname</code>为<code>NULL</code>时，该函数是不可重入函数。</p>
<h3 id="前台和后台进程组">34.4 前台和后台进程组</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">tcgetpgrp</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 返回终端的前台进程组的进程组ID，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcsetpgrp</span><span class="params">(<span class="type">int</span> fd, <span class="type">pid_t</span> pgid)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>tcgetpgrp()</code>会返回参数<code>fd</code>指定的终端的前台进程组的进程组ID
(必须是调用进程的控制终端)。若指定的终端没有前台进程组，则返回大于1的值，并且该值不匹配任何现有进程组的进程组ID
(这是SUSv3所要求的)。</p>
<p>　　函数<code>tcsetpgrp()</code>会修改终端的前台进程组。若调用进程有控制终端，则参数<code>fd</code>需要被指定为引用该终端，然后该函数会将该终端的前台进程组修改为参数<code>pgid</code>指定的前台进程组
(该前台进程组必须与调用进程属于同一会话)。</p>
<p>　　SUSv3标准化了<code>tcgetpgrp()</code>和<code>tcsetpgrp()</code>。对于Linux和很多UNIX实现，它们被实现为基于<code>ioctl()</code>的非标准操作<code>TIOCGPGRP</code>和<code>TIOCSPGRP</code>。</p>
<h3 id="信号sighup">34.5 信号<code>SIGHUP</code></h3>
<p>　　当控制进程失去其终端连接时，内核会发送信号<code>SIGHUP</code>给该进程来通知它
(还会发送信号<code>SIGCONT</code>来确保该进程在被信号停止时恢复)。通常，这会在以下2种情况下发生：</p>
<p>　　● 终端驱动程序检测到 "断开连接"
(表示调制解调器或终端线路上的信号丢失)。</p>
<p>　　● 工作站上的终端窗口被关闭
(因为与终端窗口关联的伪终端主端的最后1个打开的文件描述符被关闭)。</p>
<p>　　信号<code>SIGHUP</code>的默认处理方式是终止进程。若控制进程注册了<code>SIGHUP</code>处理函数或忽略该信号，则随后读取终端时会返回EOF。</p>
<p>　　SUSv3规定，若终端断开连接，同时发生了导致<code>read()</code>出现错误<code>EIO</code>的条件之一，则<code>read()</code>会返回EOF还是出错
(<code>EIO</code>) 是不确定的。可移植程序必须允许这2种可能性。</p>
<p>　　信号<code>SIGHUP</code>被发送给控制进程会触发连锁反应，导致该信号被发送给很多其他进程。这会通过以下2种方式发生：</p>
<p>　　●
控制终端通常是shell。shell会注册<code>SIGHUP</code>处理函数，所以shell在终止前会发送信号<code>SIGHUP</code>给它创建的所有作业，该信号默认会终止这些作业。若这些作业选择捕获该信号，则它们会收到shell终止的信息。</p>
<p>　　●
当控制终端的控制进程终止时，内核会取消会话的所有进程与控制终端的关联，取消控制终端与会话的关联，并通过向前台进程组的所有进程发送信号<code>SIGHUP</code>来通知它们已失去控制终端。</p>
<p>　　有些作业控制shell会在正常退出时
(例如，用户显式注销或在shell窗口中输入Control-D)
发送信号<code>SIGHUP</code>来停止后台作业。<code>bash</code>和<code>ksh</code>都会这样做
(在第1次试图注销后打印1条信息)。</p>
<p>　　命令<code>nohup</code>可以让命令不受信号<code>SIGHUP</code>的影响：启动命令时将信号<code>SIGHUP</code>的处理方式设置为<code>SIG_IGN</code>。<code>bash</code>的内置命令<code>disown</code>具有类似的功能，它会从shell的作业列表中删除作业，防止shell终止时发送信号<code>SIGHUP</code>给该作业。</p>
<h4 id="shell对信号sighup的处理">34.5.1
shell对信号<code>SIGHUP</code>的处理</h4>
<p>　　对于登录会话，shell通常是终端的控制进程。大多数shell被设计为当以交互式运行时，会安装<code>SIGHUP</code>处理函数。该处理函数会终止进程，但在终止前会发送信号<code>SIGHUP</code>给它创建的所有进程组
(随后可能发送信号<code>SIGCONT</code>，取决于shell以及作业当前是否已停止)。这些进程组中的进程如何响应信号<code>SIGHUP</code>取决于应用程序
(默认是终止进程)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* catch_SIGHUP.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    childPid = fork();</span><br><span class="line">    <span class="keyword">if</span> (childPid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childPid == <span class="number">0</span> &amp;&amp; argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (setpgid(<span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>) <span class="comment">/* 移动到新进程组 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;setpgid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld; PPID=%ld; PGID=%ld; SID=%ld\n&quot;</span>, (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getppid(),</span><br><span class="line">           (<span class="type">long</span>)getpgrp(), (<span class="type">long</span>)getsid(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">60</span>); <span class="comment">/* 未被处理的信号SIGALRM会确保进程最终会终止 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待信号 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld: caught SIGHUP\n&quot;</span>, (<span class="type">long</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了shell收到信号<code>SIGHUP</code>时会向它创建的作业发送该信号。该程序会创建1个子进程，然后父进程和子进程都暂停来捕获信号<code>SIGHUP</code>并在收到该信号时打印1条信息。若指定了可选的命令行参数，则子进程会将自己移动到会话的其他进程组。这是为了展示shell不会发送信号<code>SIGHUP</code>给不是由它创建的进程组，即使该进程组和shell属于同一会话。因为<code>for</code>语句会无限循环，所以该程序会通过<code>alarm()</code>来设置定时器
(发送信号<code>SIGALRM</code>)，以确保进程最终会终止。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $$</span></span><br><span class="line">5533</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./catch_SIGHUP &gt; samegroup.log 2&gt;&amp;1 &amp;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./catch_SIGHUP x &gt; diffgroup.log 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure>
<p>　　第3行的命令创建的子进程与shell位于同一进程组，而第4行的命令创建的子进程与shell位于不同进程组。当关闭运行这些命令的终端窗口后，文件<code>samegroup.log</code>和<code>diffgroup.log</code>的内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> samegroup.log</span></span><br><span class="line">PID=5612; PPID=5611; PGID=5611; SID=5533</span><br><span class="line">PID=5611; PPID=5533; PGID=5611; SID=5533</span><br><span class="line">5611: caught SIGHUP</span><br><span class="line">5612: caught SIGHUP</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> diffgroup.log</span></span><br><span class="line">PID=5614; PPID=5613; PGID=5614; SID=5533</span><br><span class="line">PID=5613; PPID=5533; PGID=5613; SID=5533</span><br><span class="line">5613: caught SIGHUP</span><br></pre></td></tr></table></figure>
<p>　　文件<code>samegroup.log</code>的内容表示父进程和子进程都收到了来自shell的信号。文件<code>diffgroup.log</code>的内容表示只有父进收到了来自shell的信号。</p>
<h4 id="信号sighup与控制进程的终止">34.5.2
信号<code>SIGHUP</code>与控制进程的终止</h4>
<p>　　若因终端断开连接而发送给控制进程的信号<code>SIGHUP</code>导致控制进程终止，则该信号还会被发送给终端的前台进程组的所有进程。该行为是控制进程终止的结果，而非与信号<code>SIGHUP</code>特别相关的行为。当控制进程终止时，信号<code>SIGHUP</code>会被发送给前台进程组。对于Linux，信号<code>SIGHUP</code>后会跟着信号<code>SIGCONT</code>，以确保进程组能够恢复
(若之前已被信号停止)。但是，SUSv3没有说明这种行为，并且大多数UNIX实现在这种情况下不会发送信号<code>SIGCONT</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* disc_SIGHUP.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID %ld: caught signal %2d (%s)\n&quot;</span>, (<span class="type">long</span>)getpid(), sig, strsignal(sig));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> parentPid, childPid;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s &#123;d|s&#125;... [ &gt; sig.log 2&gt;&amp;1 ]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    parentPid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of parent process is: %ld\n&quot;</span>, (<span class="type">long</span>)parentPid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Foreground process group ID is: %ld\n&quot;</span>, (<span class="type">long</span>)tcgetpgrp(STDIN_FILENO));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        childPid = fork();</span><br><span class="line">        <span class="keyword">if</span> (childPid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (childPid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">&#x27;d&#x27;</span>) <span class="comment">/* d表示移动到不同的进程组 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (setpgid(<span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    errExit(<span class="string">&quot;setpgid&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">            sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">            sa.sa_handler = handler;</span><br><span class="line">            <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 子进程退出循环 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">60</span>); <span class="comment">/* 确保进程最终会终止 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld PGID=%ld\n&quot;</span>, (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getpgrp());</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause(); <span class="comment">/* 等待信号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了控制进程的终止会导致信号<code>SIGHUP</code>被发送给前台进程组的所有进程。该程序会为每个命令行参数创建1个子进程
(第31~35行)。若命令行参数以字母<code>d</code>结尾，则对应的子进程会被移动到新进程组
(第39~45行)；否则，子进程将与父进程位于同一进程组。所有子进程都会注册<code>SIGHUP</code>处理函数
(第47~53行)，该处理函数会打印进程的进程ID和信号编号
(第6~9行)。为了确保进程最终会终止，所有进程都会调用<code>alarm()</code>
(第58行)。最后，所有进程都打印自己的进程ID和进程组ID并循环等待信号到达
(第60~64行)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exec</span> ./disc_SIGHUP d s s &gt; sig.log 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure>
<p>　　shell内置命令<code>exec</code>会导致shell调用<code>exec()</code>，用指定的程序替换自己。因为shell是终端的控制进程，所以替换后的程序也是控制进程，并且终端窗口关闭时会收到信号<code>SIGHUP</code>。当关闭终端窗口后，文件<code>sig.log</code>的内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sig.log</span></span><br><span class="line">PID of parent process is: 12733</span><br><span class="line">Foreground process group ID is: 12733</span><br><span class="line">PID=12755 PGID=12755</span><br><span class="line">PID=12756 PGID=12733</span><br><span class="line">PID=12757 PGID=12733</span><br><span class="line">PID=12733 PGID=12733</span><br><span class="line">PID 12756: caught signal  1 (Hangup)</span><br><span class="line">PID 12757: caught signal  1 (Hangup)</span><br></pre></td></tr></table></figure>
<p>　　关闭终端窗口会导致信号<code>SIGHUP</code>被发送给控制进程
(父进程)，从而导致其终止。此外，与父进程位于同一进程组
(即终端的前台进程组) 的2个子进程也收到了该信号，而另一个 (后台)
进程组的子进程没有收到该信号。</p>
<h3 id="作业控制">34.6 作业控制</h3>
<p>　　当在终端输入以与号<code>&amp;</code>结尾的命令时，它会作为后台作业运行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -r SIGHUP /usr/src/linux &gt;x &amp;</span></span><br><span class="line">[1] 18932</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sleep</span> 60 &amp;</span></span><br><span class="line">[2] 18934</span><br></pre></td></tr></table></figure>
<p>　　shell会为每个后台作业分配1个唯一的作业号。当启动后台作业和通过各种作业控制命令控制或监控后台作业时，作业号会显示在方括号中。作业号后的数字是为了执行命令而创建的进程的进程ID或管道的最后1个进程的进程ID
(若是管道)。对于后续的命令，作业可以通过符号<code>%num</code>表示，其中<code>num</code>是作业号。</p>
<p>　　在很多情况下，参数<code>%num</code>会被省略，此时，默认使用<span
style="background-color: yellow">当前作业</span>。当前作业是最后1个在前台停止的作业或最后1个在后台启动的作业
(若没有符合要求的前台作业)。实际上，不同的shell在确定哪个后台作业被视为当前作业的细节上存在一些差异。此外，符号<code>%%</code>或<code>%+</code>表示当前作业，符号<code>%-</code>表示上一个的当前作业。</p>
<p>　　shell内置命令<code>jobs</code>会列出所有后台作业，当前作业和上一个的当前作业分别由加号<code>+</code>和减号<code>-</code>标记。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  - Running    grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br><span class="line">[2]  + Running    sleep 60 &amp;</span><br></pre></td></tr></table></figure>
<p>　　此时，shell是终端的前台进程。因为只有1个前台进程能够从控制终端读取输入和接收终端生成的信号，所以可能需要将某个后台作业移动到前台。这可以通过shell内置命令<code>fg</code>完成。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">fg</span> %1</span>     </span><br><span class="line">grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br></pre></td></tr></table></figure>
<p>　　当作业运行在前台时，可以通过终端挂起字符 (通常是Control-Z)
来挂起作业。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入Control-Z</span><br><span class="line">[1]  + Stopped    grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br></pre></td></tr></table></figure>
<p>　　当输入Control-Z后，shell会显示已在后台停止的命令。若有需要，可以使用命令<code>fg</code>来在前台恢复该作业，或者使用命令<code>bg</code>来在后台恢复该作业。对于这2种情况，shell都会通过发送信号<code>SIGCONT</code>来恢复停止的作业。</p>
<p>　　可以通过发送信号<code>SIGSTOP</code>给后台作业来停止该作业
(<code>ksh</code>和<code>csh</code>提供了命令<code>stop</code>作为命令<code>kill -STOP</code>的简写)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -STOP %1</span></span><br><span class="line">[1]  + Stopped    grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  + Stopped    grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br><span class="line">[2]  - Running    sleep 60 &amp;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">bg</span> %1</span></span><br><span class="line">[1]  + grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br></pre></td></tr></table></figure>
<p>　　当后台作业完成时，shell会在下一个提示符前打印1条信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输入回车键以显示额外的shell提示符</span><br><span class="line">[1]  - Done    grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br><span class="line">[2]  + Done    sleep 60 &amp;</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>　　当后台作业试图从终端读取时，信号<code>SIGTTIN</code>会被发送给该作业，其默认处理行为是停止作业。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt; x.txt &amp;</span></span><br><span class="line">[1] 18947</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">输入回车键，以便在下一个shell提示符之前显示作业状态变化</span></span><br><span class="line">[1]  + Stopped cat &gt; x.txt   </span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>　　此时，必须将该作业恢复到前台并提供必要的输入。若有需要，可以先暂停该作业，然后在后台恢复，从而继续在后台执行该作业
(当然，对于这个示例，<code>cat</code>会再次立即停止，因为它会再次从终端读取)。</p>
<p>　　在默认情况下，后台作业被允许输出到控制终端。但是，若为终端指定了标志<code>TOSTOP</code>，则后台作业试图输出到控制终端会导致信号<code>SIGTTOU</code>的生成。与信号<code>SIGTTIN</code>相同，信号<code>SIGTTOU</code>会停止作业。</p>
<p>　　对于这个示例和后续的一些示例，可能并不总是需要输入回车键来查看作业状态的变化。根据内核调度策略，shell可能会在下一个shell提示符之前收到关于后台作业状态变化的通知。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">stty</span> tostop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> &amp;</span></span><br><span class="line">[1] 19023</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">输入回车键，以便在下一个shell提示符之前显示作业状态变化</span></span><br><span class="line">[1]  + Stopped    date</span><br></pre></td></tr></table></figure>
<p>　　第1条命令会启用终端的标志<code>TOSTOP</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">fg</span></span></span><br><span class="line">date</span><br><span class="line">Tue Dec 28 16:20:51 CEST 2010</span><br></pre></td></tr></table></figure>
<p>　　这里需要将作业在前台恢复才能看到输出。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/job-control_states.svg" class="">
<p>　　上图展示了作业控制的各种状态以及用于在各种状态之间移动作业的shell命令和终端字符以及伴随的信号。</p>
<h4 id="实现作业控制">34.6.1 实现作业控制</h4>
<p>　　尽管在最初的POSIX.1中是可选的，但包括SUSv3在内的后续标准要求支持作业控制实现。该支持需要满足以下条件：</p>
<p>　　●
实现必须提供特定的作业控制信号：<code>SIGTSTP</code>、<code>SIGSTOP</code>、<code>SIGCONT</code>、<code>SIGTTOU</code>和<code>SIGTTIN</code>。此外，还需要提供信号<code>SIGCHLD</code>，因为它允许shell在子进程终止或停止时收到通知。</p>
<p>　　●
终端驱动程序必须支持作业控制信号的生成，以便输入特定字符以及后台作业执行终端I/O和其他特定终端操作时特定信号会被发送给相关进程组。为此，终端驱动程序必须记录会话ID
(控制进程) 和与终端关联的前台进程组ID。</p>
<p>　　● shell必须支持作业控制
(大多数现代shell都支持)。该支持以之前描述的命令的形式提供，用于在前台和后台之间移动作业以及监控作业状态，并且其中的某些命令会发生信号给作业。此外，当执行将作业从前台运行状态移动其他作业控制状态的操作时，shell会调用<code>tcsetpgrp()</code>来调整终端驱动程序的前台进程组记录。</p>
<p>　　通常，当发送进程的的实际或有效用户ID匹配接收进程的实际用户ID或保存的set-user-ID时，发送进程才能发送信号给接收进程。但是，信号<code>SIGCONT</code>是例外。内核允许进程发送该信号给同一会话的任意进程。这是必要的，以便当用户启动会修改其凭证的set-user-ID程序后，仍然可以在该程序停止时通过信号<code>SIGCONT</code>恢复它。</p>
<p>　　SUSv3详细说明了一些适用于后台作业生成信号<code>SIGTTIN</code>和<code>SIGTTOU</code>的特殊情况：</p>
<p>　　●
若进程当前阻塞或忽略了信号<code>SIGTTIN</code>，则该信号不会被发送给该进程。相反，对控制终端调用<code>read()</code>会出错
(<code>EIO</code>)；否则，进程将无法得知<code>read()</code>调用不被允许。</p>
<p>　　●
若进程当前阻塞或忽略了信号<code>SIGTTOU</code>，则该信号也不会被发送给进程。相反，对控制终端调用<code>write()</code>会被允许
(即标志<code>TOSTOP</code>会被忽略)。</p>
<p>　　●
若后台进程试图对其控制终端调用某些修改终端驱动程序的数据结构的函数，则会生成信号<code>SIGTTOU</code>。这些函数包括<code>tcsetpgrp()</code>、<code>tcsetattr()</code>、<code>tcflush()</code>、<code>tcflow()</code>、<code>tcsendbreak()</code>和<code>tcdrain()</code>。若信号<code>SIGTTOU</code>已被阻塞或忽略，则这些调用会成功。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* job_mon.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cmdNum; <span class="comment">/* 管道中的位置 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getpid() == getpgrp())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 进程组组长 */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Terminal FG process group: %ld\n&quot;</span>, (<span class="type">long</span>)tcgetpgrp(STDERR_FILENO));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Process %ld (%d) received signal %d (%s)\n&quot;</span>, (<span class="type">long</span>)getpid(),</span><br><span class="line">            cmdNum, sig, strsignal(sig));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当捕获的信号是SIGTSTP时，实际不会停止进程。因此，这里会通过raise()发送信号SIGSTOP来停止进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (sig == SIGTSTP)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSTOP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGTSTP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCONT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isatty(STDIN_FILENO))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 若stdin是终端，则表示这是管道中的第1个进程：打印标题并初始化待发送到管道的信息 */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Terminal FG process group: %ld\n&quot;</span>, (<span class="type">long</span>)tcgetpgrp(STDIN_FILENO));</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Command PID PPID PGRP SID\n&quot;</span>);</span><br><span class="line">        cmdNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 若不是管道中的第1个进程，则从管道中读取信息 */</span></span><br><span class="line">        <span class="keyword">if</span> (read(STDIN_FILENO, &amp;cmdNum, <span class="keyword">sizeof</span>(cmdNum)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;read got EOF or error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmdNum++;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%4d %5ld %5ld %5ld %5ld\n&quot;</span>, cmdNum, (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getppid(),</span><br><span class="line">            (<span class="type">long</span>)getpgrp(), (<span class="type">long</span>)getsid(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若不是最后1个进程，则向下一个进程传递信息 */</span></span><br><span class="line">    <span class="keyword">if</span> (!isatty(STDOUT_FILENO)) <span class="comment">/* 若不是tty，则应该是管道 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(STDOUT_FILENO, &amp;cmdNum, <span class="keyword">sizeof</span>(cmdNum)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errMsg(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待信号 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了shell如何将管道中的命令组织成作业
(进程组)、特定信号的发送以及在作业控制下对终端前台进程组设置所做的修改。该程序被设计为可以在管道中运行多个实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./job_mon | ./job_mon | ./job_mon</span></span><br></pre></td></tr></table></figure>
<p>　　该程序会执行以下步骤：</p>
<p>　　1)
该程序会在启动时为信号<code>SIGINT</code>、<code>SIGTSTP</code>和<code>SIGCONT</code>注册处理函数
(第30~44行)。首先，该处理函数会打印终端的前台进程组。为了避免输出多行相同的内容，该操作仅由进程组组长完成
(第11~15行)。然后，该处理函数会打印进程的ID、进程在管道中的位置以及收到的信号
(第16~17行)。当捕获的信号是<code>SIGTSTP</code>时，该处理函数还会执行一些额外的操作，因为该信号实际不会停止进程。为了停止进程，该处理函数会调用<code>raise()</code>来发送信号<code>SIGSTOP</code>
(第20~23行)。</p>
<p>　　2)
若程序是管道中的第1个进程，则会打印所有进程打印的输出的标题。为了判断自己是否为管道中的第1个
(或最后1个) 进程，程序会调用函数<code>isatty()</code>来检查其标准输入
(或输出) 是否为终端
(第46~52行)。若指定的文件描述符引用的是管道，则该函数会返回假 (0)。</p>
<p>　　3)
程序构建传递给管道中的下一个进程的信息，该信息是1个整数，表示该进程在管道中的位置的整数。对于第1个进程，该信息为数字1。此外，第1个进程会将该信息初始化为0
(第51行)。若不是管道中的第1个进程，则程序会先从上一个进程读取该信息
(第53~60行)。程序会在执行下一步前将信息值加1 (第62行)。</p>
<p>　　4)
程序打印1行包含其管道位置、进程ID、父进程ID、进程组ID和会话ID的信息
(第63~64行)。</p>
<p>　　5)
除非程序是管道中的最后1个命令，否则它会向管道中的下一个命令写入1条整数信息
(第67~73行)。</p>
<p>　　6) 程序无限循环来等待信号 (第76~79行)。</p>
<h4 id="处理作业控制信号">34.6.2 处理作业控制信号</h4>
<p>　　作业控制对大多数应用程序都是透明的，它们无需采取特殊行为来处理作业控制信号，执行屏幕处理的程序是例外
(例如，<code>vi</code>和<code>less</code>)。此类程序控制终端的文本的精确布局并更改各种终端设置
(包括1次读取1个字符的终端输入设置)。</p>
<p>　　屏幕处理程序需要处理终端停止信号
(<code>SIGTSTP</code>)。信号处理函数应该将终端重置为规范 (逐行)
输入模式，并将光标放置在终端的最左端。当恢复后，程序会将终端设置回程序所需的模式，检查终端窗口大小
(在此期间可能已更改)，并用所需的内容重绘屏幕。</p>
<p>　　当用户挂起或退出<code>xterm</code>或其他终端模拟器上的<code>vi</code>等终端处理程序时，通常会看到终端被重绘为程序启动前可见的文本。终端模拟器通过捕获需要在获取和释放终端布局控制时输出的2个字符序列来实现该效果，这些序列是使用terminfo或termcap包的程序所必需的。第1个序列称为smcap
(通常是Escape后接[?1049h)，它会使终端模拟器切换到 "备用"
屏幕。第2个序列称为rmcup
(通常是Escape后接[?1049l)，它会使终端模拟器切换到默认屏幕，从而导致在屏幕处理程序控制终端之前显示的原文本重新出现。</p>
<p>　　当处理信号<code>SIGTSTP</code>时，需要注意一些细节。34.6.1介绍了第1个细节：当捕获的信号是<code>SIGTSTP</code>时，不会停止进程
(默认处理行为)，示例程序的处理方法是让<code>SIGTSTP</code>处理函数通过<code>raise()</code>发送信号<code>SIGSTOP</code>，因为该信号无法被捕获、阻塞和忽略。但是，这种方法并不完全正确。父进程会通过<code>wait()</code>或<code>waitpid()</code>返回的等待状态值来获取导致子进程停止的信号的信息
(见26.1.3)。若<code>SIGTSTP</code>处理函数通过<code>raise()</code>发送信号<code>SIGSTOP</code>，则父进程会错误地认为子进程被信号<code>SIGSTOP</code>停止。</p>
<p>　　在这种情况下，信号<code>SIGTSTP</code>的正确处理方法是让<code>SIGTSTP</code>处理函数进一步发送信号<code>SIGTSTP</code>来停止进程，如下所示：</p>
<p>　　1)
<code>SIGTSTP</code>处理函数将信号<code>SIGTSTP</code>的处理行为重置为默认
(<code>SIG_DFL</code>)。</p>
<p>　　2) <code>SIGTSTP</code>处理函数发送信号<code>SIGTSTP</code>。</p>
<p>　　3)
信号<code>SIGTSTP</code>在进入<code>SIGTSTP</code>处理函数函数时会被阻塞
(除非指定了标志<code>SA_NODEFER</code>)，所以<code>SIGTSTP</code>处理函数解除阻塞该信号，此时，上一步发送的待处理<code>SIGTSTP</code>会立即挂起进程。</p>
<p>　　4)
当进程随后被信号<code>SIGCONT</code>恢复时，<code>SIGTSTP</code>处理函数继续执行。</p>
<p>　　5)
在返回之前，<code>SIGTSTP</code>处理函数阻塞信号<code>SIGTSTP</code>，并重新注册自己以便再次捕获该信号。</p>
<p>　　第5步中的阻塞信号<code>SIGTSTP</code>是必要的，这是为了防止<code>SIGTSTP</code>处理函数在重新注册自己之后但在返回之前又收到信号<code>SIGTSTP</code>而被递归调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* handling_SIGTSTP.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tstpHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> tstpMask, prevMask;</span><br><span class="line">    <span class="type">int</span> savedErrno;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    savedErrno = errno; <span class="comment">/* 备份errno */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught SIGTSTP\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGTSTP, SIG_DFL) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;signal&quot;</span>); <span class="comment">/* 将SIGTSTP的处理方式设置为默认 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raise(SIGTSTP); <span class="comment">/* 发送SIGTSTP */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解除阻塞SIGTSTP，待处理SIGTSTP会立即挂起程序 */</span></span><br><span class="line">    sigemptyset(&amp;tstpMask);</span><br><span class="line">    sigaddset(&amp;tstpMask, SIGTSTP);</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;tstpMask, &amp;prevMask) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 被SIGCONT恢复后，程序会从这里继续执行 */</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;prevMask, <span class="literal">NULL</span>) == <span class="number">-1</span>) <span class="comment">/* 阻塞SIGTSTP */</span></span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask); <span class="comment">/* 重新注册处理函数 */</span></span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line">    sa.sa_handler = tstpHandler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGTSTP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Exiting SIGTSTP handler\n&quot;</span>);</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有未忽略SIGTSTP时，才为其注册信号处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGTSTP, <span class="literal">NULL</span>, &amp;sa) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sa.sa_handler != SIG_IGN)</span><br><span class="line">    &#123;</span><br><span class="line">        sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">        sa.sa_flags = SA_RESTART;</span><br><span class="line">        sa.sa_handler = tstpHandler;</span><br><span class="line">        <span class="keyword">if</span> (sigaction(SIGTSTP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待信号 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Main\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何处理信号<code>SIGTSTP</code>。在注册<code>SIGTSTP</code>处理函数后，主函数会无限循环来等待信号。</p>
<p>　　对于<code>vi</code>等屏幕处理程序，这个示例程序的信号处理函数中的<code>printf()</code>调用会被替换为导致程序修改终端模式并重绘终端显示的代码。为了避免调用非异步信号安全函数，该信号处理函数应该通过设置用于通知主函数重绘屏幕的标志来实现这一点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./handling_SIGTSTP</span></span><br><span class="line">输入Control-Z来发送信号SIGTSTP</span><br><span class="line">Caught SIGTSTP</span><br><span class="line"></span><br><span class="line">[1]  + Stopped  ./handling_SIGTSTP</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">fg</span></span></span><br><span class="line">./handling_SIGTSTP</span><br><span class="line">Exiting SIGTSTP handler</span><br><span class="line">Main</span><br><span class="line">输入Control-C来终止程序</span><br></pre></td></tr></table></figure>
<p>　　<code>SIGTSTP</code>处理函数可能会中断某些阻塞系统调用。这个示例程序的输出说明了这一点：在<code>pause()</code>调用被中断后，主函数会打印信息<code>Main</code>。</p>
<p>　　这个示例程序只会在信号<code>SIGTSTP</code>未被忽略的情况下为其注册信号处理函数。这体现了1个更通用的规则：应用程序应该只在作业控制信号和终端生成的信号未被忽略的情况下处理信号。对于作业控制信号，这可以防止由非作业控制shell启动的应用程序试图处理这些信号。非作业控制shell会将这些信号的处理方式设置为<code>SIG_IGN</code>，而作业控制shell会将这些信号的处理方式设置为<code>SIG_DFL</code>。</p>
<p>　　类似的规则也适用于可以由终端生成的其他信号：<code>SIGINT</code>、<code>SIGQUIT</code>和<code>SIGHUP</code>。</p>
<p>　　●
对于信号<code>SIGINT</code>和<code>SIGQUIT</code>，当命令在非作业控制shell的后台执行时，结果进程会与shell位于同一进程组
(而非单独的进程组)，并且shell会在执行命令之前将这2个信号的处理方式设置为<code>SIG_IGN</code>。这会确保用户输入终端中断或退出字符时进程不会终止。若进程后续取消了shell对这2个信号的处理方式的修改，则它将变得容易收到这2个信号。</p>
<p>　　●
对于信号<code>SIGHUP</code>，若命令通过<code>nohup</code>执行，则它会被忽略。这是为了防止由于终端挂断而导致命令终止。因此，当信号<code>SIGHUP</code>被忽略时，应用程序不应该试图该信号的处理方式。</p>
<h4 id="孤儿进程组">34.6.3 孤儿进程组</h4>
<p>　　孤儿进程是父进程终止后被<code>init</code> (进程ID为1)
收养的进程。在程序中，可以通过以下代码创建孤儿进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　当在shell中执行包含这段代码的程序时，父进程退出后剩余进程的状态如下图所示：</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/steps_in_the_creation_of_an_orphaned_process_group.svg" class="">
<p>　　当父进程终止后，子进程不只是孤儿进程，还是<strong>孤儿进程组</strong>的一部分。SUSv3将孤儿进程组定义为
"每个进程的父进程都是该进程组的成员或不属于该进程组的会话"。换句话说，若至少有1个进程在同一的会话的其他进程组中有父进程，则该进程组不是孤儿进程组。在上图中，子进程的进程组是孤儿进程组，因为子进程的进程组与父进程
(<code>init</code>) 的进程组不是同一进程组。</p>
<p>　　根据定义，会话组长的进程组可以是孤儿进程组，因为<code>setsid()</code>会在新会话中创建了1个进程组，而会话组长的父进程属于其他会话。</p>
<p>　　为了展示孤儿进程组的重要性，需要从作业控制的角度看待事物。基于上图考虑以下场景：</p>
<p>　　1) 在父进程退出前，子进程已停止
(可能因为父进程向其发送了停止信号)。</p>
<p>　　2)
当父进程退出时，shell会将父进程的进程组从它的作业列表中删除。子进程被<code>init</code>收养并成为终端的后台进程。子进程的进程组成为孤儿进程组。</p>
<p>　　3)
此时，没有进程通过<code>wait()</code>监控停止的子进程的状态。</p>
<p>　　因为子进程不是由shell创建，所以shell不知道子进程的存在，也不知道子进程与终止的父进程属于同一进程组。此外，进程<code>init</code>只会检查终止的子进程，然后回收结果僵尸进程。因此，停止的子进程可能会永远处于停止状态，因为没有进程知道需要发送信号<code>SIGCONT</code>来恢复它。</p>
<p>　　即使孤儿进程组中的子进程有尚未终止的属于其他会话的父进程，父进程也无法保证能够发送信号<code>SIGCONT</code>来恢复子进程。进程可以发送信号<code>SIGCONT</code>给同一会话的任意进程，但当子进程属于其他会话时，将受到发送信号的正常规则的限制
(见20.3)。因此，若子进程是特权进程，并且已修改了其凭证，则父进程可能无法发送信号给子进程。</p>
<p>　　为了避免上述场景，SUSv3规定，若进程组是孤儿进程组，并且存在停止的进程，则信号<code>SIGHUP</code>会被发送给该进程组的所有进程，以通知它们已与会话断开连接。随后，信号<code>SIGCONT</code>会被发送给该进程组的所有进程，以确保它们会恢复执行。若孤儿进程组中没有停止的进程，则这些信号不会被发送。</p>
<p>　　进程组成为孤儿进程组要么是因为同一会话的不同进程组的最后1个父进程终止，要么是因为该进程组的最后1个拥有来自同一会话的其他进程组的父进程的进程终止。无论哪种情况，对包含停止的子进程的孤儿进程组的处理都是相同的。</p>
<p>　　向包含停止的进程的新孤儿进程组发送信号<code>SIGHUP</code>和<code>SIGCONT</code>是为了消除作业控制框架中的特定漏洞。没有任何事情可以阻止孤儿进程组中的进程随后被其他进程
(具有合适的权限)
发送停止信号而停止。在这种情况下，进程将保持停止状态，直到某个进程
(同样具有合适的权限) 发送信号<code>SIGCONT</code>给它。</p>
<p>　　孤儿进程组还会影响信号<code>SIGTSTP</code>、<code>SIGTTIN</code>和<code>SIGTTOU</code>的传递语义。如前所述，若后台进程试图对控制终端调用<code>read()</code>，则信号<code>SIGTTIN</code>会被发送给该进程。若后台进程试图对控制终端调用<code>write()</code>，并且该终端的标志<code>TOSTOP</code>已设置，则信号<code>SIGTTOU</code>会被发送给该进程。但是，发送这些信号给孤儿进程组没有意义，因为孤儿进程组中的进程一旦停止，就不会恢复。因此，在这种情况下，内核会让<code>read()</code>和<code>write()</code>出错
(<code>EIO</code>)。</p>
<p>　　出于类似的原因，若信号<code>SIGTSTP</code>、<code>SIGTTIN</code>或<code>SIGTTOU</code>的传递会停止孤儿进程组中的进程，则该信号会被静默丢弃
(若注册了对应的信号处理函数，则这些信号还是会被传递给该进程)。</p>
<p>　　当被孤儿进程组中的进程调用时，<code>tcsetpgrp()</code>会出错
(<code>ENOTTY</code>)，对<code>tcsetattr()</code>、<code>tcflush()</code>、<code>tcflow()</code>、<code>tcsendbreak()</code>和<code>tcdrain()</code>的调用也会出错
(<code>EIO</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* orphaned_pgrp_SIGHUP.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld: caught signal %d (%s)\n&quot;</span>, (<span class="type">long</span>)getpid(), sig, strsignal(sig));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s &#123;s|p&#125; ...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCONT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: PID=%ld, PPID=%ld, PGID=%ld, SID=%ld\n&quot;</span>, (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getppid(),</span><br><span class="line">           (<span class="type">long</span>)getpgrp(), (<span class="type">long</span>)getsid(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为每个命令行参数创建1个子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (fork())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child: PID=%ld, PPID=%ld, PGID=%ld, SID=%ld\n&quot;</span>,</span><br><span class="line">                   (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getppid(),</span><br><span class="line">                   (<span class="type">long</span>)getpgrp(), (<span class="type">long</span>)getsid(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 通过信号停止 */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld stopping\n&quot;</span>, (<span class="type">long</span>)getpid());</span><br><span class="line">                raise(SIGSTOP);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 等待信号 */</span></span><br><span class="line">                alarm(<span class="number">60</span>); <span class="comment">/* 确保进程最终会终止 */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld pausing\n&quot;</span>, (<span class="type">long</span>)getpid());</span><br><span class="line">                pause();</span><br><span class="line">            &#125;</span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* 父进程 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>); <span class="comment">/* 等待子进程执行 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS); <span class="comment">/* 让子进程的进程组成为孤儿进程组 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何处理孤儿进程组中的进程。该程序会先注册<code>SIGHUP</code>和<code>SIGCONT</code>处理函数
(第23~33行)，然后为每个命令行参数创建1个子进程。每个子进程要么通过<code>raise()</code>发送信号<code>SIGSTOP</code>给自己
(第50~55行)，要么等待信号
(第56~62行)，这取决于对应的命令行参数是否以字母<code>s</code> (表示停止)
开头。</p>
<p>　　当子进程创建完成后，父进程会睡眠来等待子进程执行
(第70行)，以这种方式调用<code>sleep()</code>是不完美但有时可行的实现方法
(见24.1)。然后，父进程退出。此时，子进程的进程组会成为孤儿进程组。若子进程因进程组成为孤儿进程组而收到信号，则信号处理函数会被调用并打印子进程的进程ID和信号编号
(第6~9行)。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第33章 线程：更多细节</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_33/</url>
    <content><![CDATA[<h3 id="线程栈">33.1 线程栈</h3>
<p>　　每个线程都有自己的栈，其大小在线程创建时就已固定。对于Linux/x86-32，主线程之外的所有线程的栈大小默认为2MB。对于某些64位架构，线程栈的默认大小更大
(例如，IA-64的默认大小是32MB)。</p>
<p>　　有时，可能需要修改线程栈的大小。函数<code>pthread_attr_setstacksize()</code>会设置1个线程属性，该线程属性决定使用线程属性对象创建的线程的栈大小。函数<code>pthread_attr_setstack()</code>可用于控制线程栈的大小和位置，但设置线程栈的位置会降低应用程序的可移植性。</p>
<p>　　修改线程栈的大小可能是因为需要为那些分配大型自动变量或进行深度嵌套函数调用的线程提供更大的栈，也可能是因为应用程序希望减小线程栈的大小
(以便在1个进程中容纳更多的线程)。x86-32的虚拟地址空间是3GB，2MB的默认栈大小表示最多可以创建大约15000个线程
(具体数量取决于文本段、数据段和共享库等内存段占用的虚拟内存)。可以通过调用<code>sysconf(_SC_THREAD_STACK_MIN)</code>来获取架构的实际最小线程栈大小。对于Linux/x86-32上的NPTL实现，该调用会返回16384。</p>
<p>　　对于NPTL线程实现，若将线程栈大小资源线程
(<code>RLIMIT_STACK</code>)
设置为<code>unlimited</code>以外的值，则创建新线程时会将该值作为默认栈大小。该限制必须在<span
style="background-color: yellow">程序执行之前</span>被设置，这通常使用命令<code>ulimit –s</code>设置。在主程序中使用<code>setrlimit()</code>设置该限制是不够的，因为NPTL会在调用<code>main()</code>之前进行的运行时初始化期间确定默认栈大小。</p>
<span id="more"></span>
<h3 id="线程和信号">33.2 线程和信号</h3>
<p>　　UNIX信号模型的设计考虑了UNIX进程模型，并且比Pthreads早出现几十年。因此，信号模型和线程模型之间存在一些重大冲突。这些冲突主要源于情况：一方面需要维护单线程进程的传统信号语义，另一方面需要开发适用于多线程进程的信号模型。</p>
<p>　　要理解UNIX信号如何映射到Pthreads模型，需要知道信号模型的哪些方面是进程级的，而哪些方面是线程级的。</p>
<p>　　● 信号处理方式是进程级的
(例如，若发送给进程的未被处理的信号的默认处理行为是停止或终止，则进程的所有线程都会停止或终止)。</p>
<p>　　●
在线程上下文中执行特定硬件指令而生成的信号、线程试图写入损坏的管道时生成的信号<code>SIGPIPE</code>以及通过<code>pthread_kill()</code>和<code>pthread_sigqueue()</code>发送的信号是线程级信号，通过其他机制生成的信号是进程级信号。</p>
<p>　　●
当信号被发送给已注册信号处理函数的多线程进程时，内核会随机选择1个线程来接收该信号并调用信号处理函数。这种行为与单线程进程的传统语义一致。进程为了响应1个信号而多次调用信号处理函数没有意义。</p>
<p>　　●
信号掩码是线程级的。新线程会继承创建线程的信号掩码。线程可以通过<code>pthread_sigmask()</code>来
(解除) 阻塞信号。</p>
<p>　　●
内核维护着关于整个进程的待处理信号的记录和每个线程的待处理信号的记录。<code>sigpending()</code>返回的是进程的待处理信号集和调用线程的待处理信号集的并集。新线程的待处理信号集为空。目标为线程的信号只能被发送给目标线程。若目标线程阻塞了该信号。则信号将保持待处理状态，直到目标线程解除阻塞该信号。</p>
<p>　　●
若<code>pthread_mutex_lock()</code>调用被信号处理函数中断，则该调用总是会自动重启。若<code>pthread_cond_wait()</code>调用被信号处理函数中断，则该调用要么自动重启，要么返回0来表示虚假唤醒
(见30.2.1)。这些行为也是SUSv3所要求的。</p>
<p>　　●
备用信号栈是线程级的。更准确地说，SUSv3要求备用信号栈是KSE级的。对于采用1:1实现的系统，每个线程都有1个KSE。</p>
<h4 id="控制线程的信号掩码">33.2.1 控制线程的信号掩码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　线程可以通过函数<code>pthread_sigmask()</code>来修改信号掩码或/和检索信号掩码。除了操作目标是线程的信号掩码之外，该函数用法与<code>sigprocmask()</code>的相同
(见20.8)。</p>
<p>　　SUSv3指出，在多线程程序中使用<code>sigprocmask()</code>将会导致未定义的结果。因此，不能在多线程程序中使用该系统调用。实际上，<code>sigprocmask()</code>和<code>pthread_sigmask()</code>在很多实现中是相同的，包括Linux。</p>
<h4 id="发送信号给线程">33.2.2 发送信号给线程</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_kill</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> sig)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pthread_kill()</code>会发送参数<code>sig</code>指定的信号给参数<code>thread</code>指定的线程。因为Pthreads线程ID仅在进程内是唯一的，所以不能通过该函数发送信号给其他进程的线程。</p>
<p>　　<code>pthread_kill()</code>被实现为基于特定于Linux的系统调用<code>tgkill(tgid, tid, sig)</code>。该系统调用会发送参数<code>sig</code>指定的信号给参数<code>tgid</code>指定的线程组内的内核线程ID为<code>tid</code>的线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigqueue</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　特定于Linux的函数<code>pthread_sigqueue()</code>结合了<code>pthread_kill()</code>和<code>sigqueue()</code>的功能。该函数会发送参数<code>sig</code>指定的信号给参数<code>thread</code>指定的线程。参数<code>value</code>用于指定随附数据，其用法与对应的<code>sigqueue()</code>参数的相同。</p>
<p>　　<code>pthread_sigqueue()</code>在glibc
2.11中被添加，并且需要内核的支持。该支持由Linux
2.6.31中添加的系统调用<code>rt_tgsigqueueinfo()</code>提供。</p>
<h4 id="处理异步信号">33.2.3 处理异步信号</h4>
<p>　　第20~22章介绍了各种可能会导致信号处理函数处理异步生成的信号更复杂的因素
(例如，可重入问题、重启系统调用和避免竞争条件)。此外，Pthreads
API中的所有函数都是非异步信号安全的。因此，必须处理异步生成的信号的多线程程序通常不应该注册信号处理函数。相反，应该通过以下方法来处理异步信号：</p>
<p>　　1)
所有线程都阻塞进程可能会收到的异步信号。实现这一点的最简单的方法是在主线程创建线程之前阻塞这些信号，新线程会继承主线程的信号掩码的副本。</p>
<p>　　2)
创建1个专用线程，该线程通过<code>sigwaitinfo()</code>、<code>sigtimedwait()</code>或<code>sigwait()</code>接收信号。</p>
<p>　　这种方法的优点是异步生成的信号可以被同步接收。当专用线程接收信号时，它可以安全地修改共享变量
(受到互斥锁控制)
并调用非异步信号安全函数。它还可以唤醒等待条件变量的线程，并使用其他线程和进程通信和同步机制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> *sig)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>sigwait()</code>会等待参数<code>set</code>指定的信号集中的任一信号到达，然后接收信号并将其编号存储在<code>sig</code>指向的缓冲区中。</p>
<p>　　<code>sigwait()</code>的行为与<code>sigwaitinfo()</code>的类似，但有以下不同：</p>
<p>　　● <code>sigwait()</code>返回的只是信号编号
(而非描述信号的结构体<code>siginfo_t</code>)。</p>
<p>　　● <code>sigwait()</code>的返回值与线程相关函数一致
(而非传统UNIX调用返回的0或-1)。</p>
<p>　　当多个线程通过<code>sigwait()</code>等待同一信号时，只会有1个线程实际接收该信号，并且哪个线程会接收该信号是不确定的。</p>
<h3 id="线程和进程控制">33.3 线程和进程控制</h3>
<p>　　与信号机制相同，<code>exec()</code>、<code>fork()</code>和<code>exit()</code>也早于Pthreads
API出现。</p>
<p>　　当线程调用<code>exec()</code>时，调用程序会完全被替换。除了调用线程之外，其他所有线程都会立即消失，这些线程的线程特定数据的析构函数以及清除处理函数都不会被调用。属于该进程的所有
(进程私有)
互斥锁和条件变量也会消失。当调用<code>exec()</code>后，剩余线程的线程ID将会是不确定的。</p>
<p>　　当多线程进程调用<code>fork()</code>时，只有调用线程会在子进程中被复制，其他线程在子进程中都会消失
(子进程中线程的ID会与父进程中调用<code>fork()</code>的线程的ID相同)。此外，这些消失的线程的线程特定数据的析构函数以及清除处理函数都不会被调用。这会导致各种问题：</p>
<p>　　●
尽管只有调用线程会在子进程中被复制，但全局变量的状态以及互斥锁和条件变量等Pthreads对象会在子进程中被保留
(因为Pthreads对象会被分配在父进程的内存，而子进程会得到这些内存的副本)。这可能会导致棘手的情况：假设其他线程在<code>fork()</code>时锁定了互斥锁，并且正在更新全局数据结构。在这种情况下，子进程中的线程将无法解锁互斥锁
(因为不存在互斥锁的所有者)，并且当它试图获取互斥锁时，会被阻塞。此外，子进程的全局数据结构副本可能处于不一致的状态
(因为正在更新它的线程在更新时消失了)。</p>
<p>　　●
因为线程特定数据的析构函数以及清理处理函数都不会被调用，多线程程序中的<code>fork()</code>调用可能会导致子进程的内存泄露。此外，子进程中的新线程可能无法访问其他线程创建的线程特定数据，因为它没有指向这些数据的指针。</p>
<p>　　正是因为这些问题，在多线程程序中调用<code>fork()</code>后通常会立即调用<code>exec()</code>。</p>
<p>　　对于那些<code>fork()</code>后不能立即调用<code>exec()</code>的程序，Pthreads
API提供了1种定义fork处理函数的机制。fork处理函数通过调用<code>pthread_atfork(prepare_func, parent_func, child_func)</code>来注册，这会将<code>prepare_func</code>指向的函数添加到1个函数列表，该函数列表中的函数会在调用<code>fork()</code>时子进程被创建之前自动被调用
(按照注册顺序的逆序)。同样，<code>parent_func</code>和<code>child_func</code>指向的函数也会分别被添加到1个函数函数，这些函数会分别在<code>fork()</code>返回后父进程和子进程立即被调用
(按照注册顺序)。</p>
<p>　　对于Linux，当使用NPTL线程库的程序调用<code>vfork()</code>时，fork处理函数不会自动被调用。但是，在这种情况下，若程序使用的是LinuxThreads，则fork处理函数会自动被调用。</p>
<p>　　有时，fork处理函数对使用线程的库代码非常有用。若没有fork处理函数，库无法处理那些直接使用库并调用<code>fork()</code>的应用程序，因为这些应用程序不知道库已经创建了一些线程。</p>
<p>　　若任一线程调用<code>exit()</code>或主线程返回，则所有线程会立即消失，线程特定数据的析构函数以及清除处理函数都不会自动被调用。</p>
<h3 id="线程实现模型">33.4 线程实现模型</h3>
<p>　　这里将介绍3种用于实现线程API的模型：<span
style="background-color: yellow">M:1实现</span>、<span
style="background-color: yellow">1:1实现</span>和<span
style="background-color: yellow">M:N实现</span>。这些实现模型之间的差异在于线程如何映射到KSE
(对于线程出现之间的传统UNIX实现，KSE等同于进程)。</p>
<h4 id="m1实现">33.4.1 M:1实现</h4>
<p>　　对于M:1线程实现，线程创建、调度和同步
(例如，锁定互斥锁和等待条件变量)
的所有细节完全在进程内部由用户空间线程库处理。内核对进程中存在多个线程的情况一无所知。</p>
<p>　　M:1实现有几个优点。最大的优点很多操作
(例如，创建和终止线程、线程间的上下文切换以及互斥锁和条件变量操作)
都很快，因为不需要切换到内核模式。此外，由于不需要内核对线程库的支持，M:1实现可以相对容易地进行移植。</p>
<p>　　但是，M:1实现存在一些严重的缺点：</p>
<p>　　●
当线程调用<code>read()</code>等系统调用时，控制权会从用户空间线程库转移到内核。这表示若<code>read()</code>阻塞，则所有线程都会阻塞。</p>
<p>　　●
内核无法调度进程的线程。因为内核不知道进程中存在多个线程，所以它无法将单独的线程调度到多处理器硬件上的不同处理器。此外，内核无法有效地为进程中的线程分配比另一个进程中的线程更高的优先级，因为线程的调度完全在进程内部进行。</p>
<h4 id="实现">33.4.2 1:1实现</h4>
<p>　　对于1:1实现，每个线程映射到单独的KSE。内核分别处理每个线程的调度。线程同步操作被实现为使用系统调用。</p>
<p>　　1:1实现消除了M:1实现的缺点。阻塞系统调用不会导致进程的其他线程都阻塞，并且内核可以将进程的线程调度到多处理器硬件上的不同处理器。</p>
<p>　　但是，1:1实现的线程创建、上下文切换和同步等操作慢于M:1实现，因为需要切换到内核模式。此外，当应用程序存在大量线程时，为每个线程维护单独的KSE的开销可能会为内核调度程序带来很大的负载，从而降低整体系统性能。</p>
<p>　　尽管存在这些缺点，但相比M:1实现，1:1实现通常是更好的选择。LinuxThreads和NPTL都是使用该模型。</p>
<h4 id="mn实现">33.4.3 M:N实现</h4>
<p>　　M:N实现旨在结合M:1实现和1:1实现的优点，同时消除它们的缺点。</p>
<p>　　对于M:N实现，每个进程都有多个关联的KSE，并且多个线程可能映射到所有KSE。这种设计允许内核将应用程序的线程分配到多个处理器上，同时消除了与使用大量线程的应用程序相关的可能出现的扩展问题。</p>
<p>　　M:N实现最大的缺点是复杂性。线程调度任务由内核和用户空间线程库共同承担，它们必须相互合作并传递信息。在使用M:N实现的情况下，按照SUSv3的要求管理信号也很复杂。</p>
<p>　　NPTL实现最初考虑采用M:N实现，但由于需要对内核进行过于广泛和可能不必要的修改
(考虑到Linux调度程序在处理大量KSE时的良好扩展性)，最终采用了1:1实现。</p>
<h3 id="posix线程的linux实现">33.5 POSIX线程的Linux实现</h3>
<p>　　Linux有2种主要的Pthreads API实现：LinuxThreads和NPTL (Native
POSIX Threads Library)。</p>
<p>　　● LinuxThreads是最初的Linux线程实现，由Xavier
Leroy开发。LinuxThreads现已过时，glibc 2.4及以上版本不支持该实现。</p>
<p>　　● NPTL是现代Linux线程实现，由Ulrich Drepper和Ingo
Molnar开发，作为LinuxThreads是后继者。NPTL的性能更优越，并且更严格地遵循SUSv3。对NPTL的支持需要修改内核，这些修改出现在Linux
2.6中。</p>
<p>　　一度，LinuxThread的后继者似乎是IBM开发的NGPT (Next Generation
POSIX
Threads)。NGPT采用M:N实现，性能明显优于LinuxThreads。但是，NPTL的开发者决定寻求1种新的实现。这个做法是合理的——1:1实现的NPTL被证明比NGPT性能更好。当NPTL发布后，NGPT的开发就停止了。</p>
<h4 id="linuxthreads">33.5.1 LinuxThreads</h4>
<p>　　多年来，LinuxThreads是Linux上的主要线程实现，它足以用于实现各种多线程应用程序。LinuxThread的要点如下：</p>
<p>　　● 线程是通过指定以下标志调用<code>clone()</code>创建的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND</span><br></pre></td></tr></table></figure>
<p>　　这表示LinuxThreads线程会共享虚拟内存、文件描述符、文件系统相关信息
(umask、根目录和当前工作目录)
和信号处理方式。但是，线程不会共享进程ID和父进程ID。</p>
<p>　　● 除了应用程序创建的线程之外，LinuxThreads还会创建1个额外的
"管理" 线程，用于处理线程的创建和终止。</p>
<p>　　● LinuxThreads会使用信号进行内部操作。对于支持实时信号的内核
(Linux
2.2及以上版本)，会使用前3个实时信号。对于较旧的内核，使用<code>SIGUSR1</code>和<code>SIGUSR2</code>。应用程序不能使用这些信号
(使用这些信号会导致各种线程同步操作出现高延迟)。</p>
<p>　　LinuxThreads在某些方面不符合SUSv3
(LinuxThreads受到开发时可用的内核特性的限制，它需要在这些限制内尽可能地符合规范)：</p>
<p>　　●
进程的不同线程调用<code>getpid()</code>会返回不同的值。调用<code>getppid()</code>反映了事实：除了主线程之外，所有线程均由进程的管理线程创建
(<code>getppid()</code>返回管理线程的进程ID)。其他线程调用<code>getppid()</code>的返回值应该与主线程调用<code>getppid()</code>的返回值相同。</p>
<p>　　●
若某个线程通过<code>fork()</code>创建子进程，则进程的其他线程都应该能通过<code>wait()</code>
(或类似函数)
来获取该子进程的终止状态。但是，事实并非如此，只有创建子进程的线程可以对其调用<code>wait()</code>。</p>
<p>　　●
SUSv3要求，若线程调用<code>exec()</code>，则进程的其他所有线程都会终止。但是，若<code>exec()</code>由主线程之外的线程调用，则结果进程将具有与调用线程相同的进程ID，即进程ID与主线程的进程ID不同。根据SUSv3，进程ID应该与主线程的进程ID相同。</p>
<p>　　● 线程不会共享凭证
(用户和组ID)。当多线程进程执行set-user-ID程序时，可能导致线程无法发送信号给其他线程
(通过<code>pthread_kill()</code>)，因为这2个线程的凭证已被修改，以至于发送线程不再具有发送信号给目标线程的权限
(见20.3)。此外，因为LinuxThreads内部会使用信号，所以线程修改其凭证后，各种Pthreads操作可能会出错或被挂起。</p>
<p>　　●
通过<code>kill()</code>或<code>sigqueue()</code>发送给进程的信号应该被传递给目标进程中未阻塞信号的任意线程并由该线程处理。但是，因为LinuxThreads线程的进程ID不同，信号的目标只能是指定的线程。若该线程阻塞了信号，则该信号将保持待处理状态
(即使进程的其他线程未阻塞该信号)。</p>
<p>　　●
LinuxThreads不支持进程级待处理信号的概念，只支持线程级待处理信号。</p>
<p>　　●
若信号是针对包含多线程应用程序的进程组，则该信号将由应用程序中的所有线程
(即已注册信号处理函数的所有线程) 处理，而非由单个 (任意) 线程处理
(例如，可以通过输入为前台进程组生成作业控制信号的终端字符来生成此类信号)。</p>
<p>　　● 备用信号栈 (由<code>sigaltstack()</code>定义)
是线程级的。但是，因为新线程会错误地继承创建线程的备用信号栈，所以这2个线程会共享备用信号栈。SUSv3要求新线程启动时不应该有备用信号栈。LinuxThreads不符合规范的行为会导致问题：当2个线程同时在共享备用信号栈上处理不同信号时，可能会导致混乱
(例如，程序崩溃)。这个问题可能很难重现和调试，因为它的发生依赖于2个信号同时被处理。对于使用LinuxThreads的程序，新线程可以调用<code>sigaltstack()</code>来确保它不会与创建线程共享备用信号栈。但是，可移植程序
(以及会创建线程的库函数)
并不知道要这样做，因为其他实现不要求这样做。此外，即使使用了该技术，仍然存在潜在的竞争条件：新线程可能在调用<code>sigaltstack()</code>之前就接收了信号并在备用信号栈上处理。</p>
<p>　　●
线程不会共享会话ID和进程组ID。系统调用<code>setsid()</code>和<code>setpgid()</code>不能用于修改多线程进程的会话或进程组ID。</p>
<p>　　●
通过<code>fcntl()</code>注册的记录锁不会被共享。同一类型的重叠锁请求不会合并。</p>
<p>　　● 线程不会共享资源限制。SUSv3要求资源线程是进程级属性。</p>
<p>　　●
<code>times()</code>返回的CPU时间和<code>getrusage()</code>返回的资源使用信息是线程级的。这些系统调用应该返回进程范围内的总计。</p>
<p>　　● 命令<code>ps</code>的某些版本会将进程中的所有线程
(包括管理线程) 显示为具有不同进程ID的独立项。</p>
<p>　　● 线程不会共享由<code>setpriority()</code>设置的nice值。</p>
<p>　　● 线程不会共享通过<code>setitimer()</code>设置的间隔定时器。</p>
<p>　　● 线程不会共享System V信号量取消 (<code>semadj</code>) 值。</p>
<p>　　除了在某些方面不符合SUSv3之外，LinuxThreads还存在以下问题：</p>
<p>　　● 当管理线程终止后，必须手动清理剩余线程。</p>
<p>　　● 多线程程序的核心转储文件可能不包含进程的所有线程
(甚至不包含触发核心转储的线程)。</p>
<p>　　●
只有在主线程中执行<code>ioctl()</code>的非标准操作<code>TIOCNOTTY</code>时，才会删除进程与控制终端的关联。</p>
<h4 id="nptl">33.5.2 NPTL</h4>
<p>　　NPTL的开发工作始于2002年，并在接下来的大约1年取得了进展。与此同时，Linux内核也进行了多项修改以满足NPTL的要求。Linux
2.6内核为支持NPTL而做出的修改如下：</p>
<p>　　● 改进线程组实现。</p>
<p>　　● 添加futex作为同步机制
(futex是通用机制，并非仅为NPTL而设计)。</p>
<p>　　●
添加系统调用<code>get_thread_area()</code>和<code>set_thread_area()</code>来支持线程本地存储。</p>
<p>　　● 支持线程核心转储和多线程进程调试。</p>
<p>　　● 修改以支持与Pthreads模型一致的方式管理信号。</p>
<p>　　●
添加系统调用<code>exit_group()</code>来终止进程中的所有线程。从glibc
2.3开始，<code>_exit()</code>变成了<code>exit_group()</code>的包装函数的别名，而调用<code>pthread_exit()</code>才会调用真正的<code>_exit()</code>
(仅终止调用线程)。</p>
<p>　　● 重写内核调度程序以允许更高效地调度大量 (即数千个) KSE。</p>
<p>　　● 提升内核进程终止代码的性能。</p>
<p>　　● 扩展系统调用<code>clone()</code>。</p>
<p>　　NPTL的要点如下：</p>
<p>　　● 线程是通过指定以下标志调用<code>clone()</code>创建的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD |</span><br><span class="line">CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</span><br></pre></td></tr></table></figure>
<p>　　除了共享LinuxThreads线程共享的所有信息之外，NPTL线程还共享更多信息
(见28.2.1)。</p>
<p>　　●
NPTL内部会使用前2个实时信号。其中的1个信号用于用于实现线程取消。另一个信号作为确保进程中的所有线程具有相同用户ID和组ID的技术的一部分。这项技术是必需的，因为在内核级别，线程具有不同的用户和组凭证。NPTL会在更改用户和组ID的系统调用
(例如，<code>setuid()</code>和<code>setresuid()</code>)
的包装函数中执行一些操作，以保证修改进程的所有线程的ID。应用程序不应该使用这些信号。</p>
<p>　　● 不同于LinuxThreads，NPTL不会使用管理线程。</p>
<p>　　虽然NPTL比LinuxThreads更严格地遵循SUSv3，但在撰写本书时，还是存在不符合规范的行为：线程不会共享nice值。</p>
<p>　　对于较旧的内核2.6.x，还存在一些额外的不符合规范的行为：</p>
<p>　　●
对于内核2.6.16之前的版本，备用信号栈是线程级的，但新线程会错误地继承创建线程的备用信号栈。因此，这2个线程会共享备用信号栈。</p>
<p>　　●
对于内核2.6.16之前的版本，只有线程组组长才能通过调用<code>setsid()</code>创建新会话。</p>
<p>　　●
对于内核2.6.16之前的版本，只有线程组组长才能通过<code>setpgid()</code>让主机进程成为进程组组长。</p>
<p>　　●
对于内核2.6.12之前的版本，线程不会共享通过<code>setitimer()</code>创建的间隔定时器。</p>
<p>　　● 对于内核2.6.10之前的版本，线程不会共享资源限制。</p>
<p>　　●
对于内核2.6.9之前的版本，<code>times()</code>返回的CPU时间和<code>getrusage()</code>返回的资源使用信息是线程级的。</p>
<p>　　NPTL被设计为与LinuxThreads
ABI兼容，所以与支持LinuxThreads的glibc链接的程序不需要重新链接即可使用NPTL。但是，当使用NPTL时，程序的某些行为可能会变化，主要是因为NPTL更严格地遵循SUSv3。</p>
<p>　　当使用命令<code>ps</code>列出使用NPTL的多线程进程时，只会有1行结果。为了查看线程的相关信息，需要加上命令行选项<code>-L</code>。</p>
<h4 id="确定当前使用的线程实现">33.5.3 确定当前使用的线程实现</h4>
<p>　　某些Linux发行版附带了glibc，该库同时支持LinuxThreads和NPTL，默认使用的线程实现由动态链接器根据系统运行的底层内核决定
(这些发行版现已成为历史，因为从版本2.4开始，glibc不再支持LinuxThreads)。</p>
<p>　　对于使用glibc
2.3.2及以上版本的系统，可以通过以下命令来确定系统支持哪个线程实现，或者系统同时支持这2个线程实现时默认使用的线程实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getconf GNU_LIBPTHREAD_VERSION</span></span><br></pre></td></tr></table></figure>
<p>　　对于仅支持NPTL或默认使用NPTL的系统，该命令的结果如下
(版本可能有所不同)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NPTL 2.3.4</span><br></pre></td></tr></table></figure>
<p>　　从glibc
2.3.2开始，可以通过库函数<code>confstr()</code>检索特定于glibc的配置变量<code>_CS_GNU_LIBPTHREAD_VERSION</code>的值来获取类似的信息。</p>
<p>　　对于使用较旧的glibc的系统，还需要进行更多的操作。首先，需要通过以下命令来获取运行程序时glibc的路径名
(这里以位于<code>/bin/ls</code>的程序<code>ls</code>为例)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd /bin/ls | grep libc.so</span></span><br><span class="line">        libc.so.6 =&gt; /lib/tls/libc.so.6 (0x40050000)</span><br></pre></td></tr></table></figure>
<p>　　<code>=&gt;</code>之后的内容是glibc的路径名
(glibc的路径名可能因Linux发行版而异)。若将该路径名作为命令执行，则会打印大量关于glibc的信息。这里可以通过<code>grep</code>进行筛选，以找到关于线程实现的那一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/lib/tls/libc.so.6 | egrep -i <span class="string">&#x27;threads|nptl&#x27;</span></span></span><br><span class="line">        Native POSIX Threads Library by Ulrich Drepper et al</span><br></pre></td></tr></table></figure>
<p>　　在<code>egrep</code>中使用正则表达式是因为某些支持NPTL的glibc版本会包含字符串<code>NPTL 0.61 by Ulrich Drepper</code>
(或类似的字符串)。</p>
<p>　　或者，直接使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">$(ldd /bin/ls | grep libc.so | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>) | egrep -i <span class="string">&#x27;threads|nptl&#x27;</span></span></span><br><span class="line">        Native POSIX Threads Library by Ulrich Drepper et al</span><br></pre></td></tr></table></figure>
<h4 id="显式控制使用的线程实现">33.5.4 显式控制使用的线程实现</h4>
<p>　　对于同时支持LinuxThreads和NPTL的Linux系统，可能需要显式地控制使用的线程实现。为此，需要使用特殊环境变量<code>LD_ASSUME_KERNEL</code>。顾名思义，该环境变量会告诉动态链接器像在特定版本的Linux内核上运行一样运行。通过指定不支持NPTL的内核版本
(例如，2.2.5)，可以确保使用LinuxThreads。因此，可以使用以下命令运行使用LinuxThreads的多线程程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ LD_ASSUME_KERNEL=<span class="number">2.2</span>.<span class="number">5</span> ./prog</span><br></pre></td></tr></table></figure>
<p>　　可以指定给环境变量<code>LD_ASSUME_KERNEL</code>的内核版本号的范围存在一些限制。对于常见的Linux发行版，版本号2.2.5足以确保使用LinuxThreads。</p>
<p>　　当将该环境变量与33.5.3中介绍的命令结合起来以显示所使用的线程实现时，得到的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> LD_ASSUME_KERNEL=2.2.5</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">$(ldd /bin/ls | grep libc.so | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>) | egrep -i <span class="string">&#x27;threads|nptl&#x27;</span></span></span><br><span class="line">        linuxthreads-0.10 by Xavier Leroy</span><br></pre></td></tr></table></figure>
<h3 id="pthreads-api的高级特性">33.6 Pthreads API的高级特性</h3>
<p>　　Pthreads API的高级特性如下：</p>
<p>　　● <span
style="background-color: yellow">实时调度</span>：可以为线程设置实时调度策略和优先级。</p>
<p>　　● <span
style="background-color: yellow">进程共享的互斥锁和条件变量</span>：SUSv3规定了1个允许在进程间共享互斥锁和条件变量的选项。在这种情况下，互斥锁和条件变量必须位于进程共享的内存区域。NPTL支持该特性。</p>
<p>　　● <span
style="background-color: yellow">高级线程同步原语</span>：包括屏障、读写锁和自旋锁。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第36章 进程资源</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_36/</url>
    <content><![CDATA[<h3 id="进程资源使用情况">36.1 进程资源使用情况</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getrusage</span><span class="params">(<span class="type">int</span> who, <span class="keyword">struct</span> rusage *res_usage)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rusage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ru_utime</span>;</span> <span class="comment">/* 使用的用户CPU时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ru_stime</span>;</span> <span class="comment">/* 使用的系统CPU时间 */</span></span><br><span class="line">    <span class="type">long</span> ru_maxrss;          <span class="comment">/* 驻留集的最大大小，单位是KB (Linux 2.6.32及以上版本) */</span></span><br><span class="line">    <span class="type">long</span> ru_ixrss;           <span class="comment">/* 整体 (共享) 文本内存大小 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_idrss;           <span class="comment">/* 整体 (非共享) 数据内存大小 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_isrss;           <span class="comment">/* 整体 (非共享) 栈内存大小 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_minflt;          <span class="comment">/* 软页故障 (无需I/O) */</span></span><br><span class="line">    <span class="type">long</span> ru_majflt;          <span class="comment">/* 硬页故障 (需要I/O) */</span></span><br><span class="line">    <span class="type">long</span> ru_nswap;           <span class="comment">/* 交换物理内存 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_inblock;         <span class="comment">/* 通过文件系统的阻塞输入操作 (Linux 2.6.22及以上版本) */</span></span><br><span class="line">    <span class="type">long</span> ru_oublock;         <span class="comment">/* 通过文件系统的阻塞输出操作 (Linux 2.6.22及以上版本) */</span></span><br><span class="line">    <span class="type">long</span> ru_msgsnd;          <span class="comment">/* 发送的IPC信息 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_msgrcv;          <span class="comment">/* 接收的IPC信息 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_nsignals;        <span class="comment">/* 接收的信号 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_nvcsw;           <span class="comment">/* 主动上下文切换，即进程在时间片到期之前放弃CPU (Linux 2.6及以上版本) */</span></span><br><span class="line">    <span class="type">long</span> ru_nivcsw;          <span class="comment">/* 被动上下文切换，即进程被更高优先级的进程抢占或时间片到期 (Linux 2.6及以上版本) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getrusage()</code>用于检索调用进程或它的所有已被回收的子进程占用的各种系统资源的统计信息，结果存储在参数<code>res_usage</code>指向的结构体<code>rusage</code>中。参数<code>who</code>用于指定带检索资源信息使用情况的目标，只能被指定为<code>RUSAGE_SELF</code>、<code>RUSAGE_CHILDREN</code>或<code>RUSAGE_THREAD</code>。</p>
<span id="more"></span>
<p>　　● <code>RUSAGE_SELF</code>表示返回调用进程的相关信息。</p>
<p>　　●
<code>RUSAGE_CHILDREN</code>表示返回调用进程的所有已被回收的子进程的相关信息。</p>
<p>　　●
<code>RUSAGE_THREAD</code>表示返回调用线程的相关信息，该值是特定于Linux的
(Linux 2.6.26及以上版本)。</p>
<p>　　对于Linux，结构体<code>rusage</code>的很多成员不会被<code>getrusage()</code>
(或<code>wait3()</code>和<code>wait4()</code>)
设置，或者只有在较新的内核版本中才会被设置。有些UNIX实现会使用Linux未使用的某些成员，但Linux也提供了这些成员。</p>
<p>　　成员<code>ru_utime</code>和<code>ru_stime</code>分别表示进程在用户和内核模式下消耗的CPU时间。</p>
<p>　　若<code>who</code>为<code>RUSAGE_CHILDREN</code>，则<code>getrusage()</code>返回的结构体<code>rusage</code>会包含调用进程的所有已被回收的后代进程的资源使用统计信息。假设有3个进程：父进程、子进程和孙进程。当子进程对孙进程调用<code>wait()</code>时，子进程的资源使用统计数据会包含孙进程的资源使用统计数据；当父进程对子进程调用<code>wait()</code>时，父进程的资源使用统计数据会包含子进程
(和孙进程)
的资源使用统计数据。相反，若子进程没有对孙进程调用<code>wait()</code>，则父进程和子进程的资源使用统计数据都不会包含孙进程的资源使用统计数据。</p>
<p>　　当<code>who</code>为<code>RUSAGE_CHILDREN</code>时，成员<code>ru_maxrss</code>返回的是调用进程的所有后代进程的最大驻留集的大小
(而非所有后代进程的驻留集的总和)。</p>
<p>　　尽管大多数UNIX实现提供了<code>getrusage()</code>，但SUSv3仅简略地说明了该系统调用
(仅说明了成员<code>ru_utime</code>和<code>ru_stime</code>)，部分是因为结构体<code>rusage</code>的大部分信息的含义取决于实现。</p>
<p>　　SUSv3要求，当<code>who</code>为<code>RUSAGE_CHILDREN</code>时，若忽略了信号<code>SIGCHLD</code>
(以避免子进程转换为僵尸进程)，则子进程的资源使用数据不应该被统计在父进程的资源使用数据中。但是，如前所述，对于2.6.9之前的内核，这种情况下的父进程的资源使用统计数据会包含子进程的资源使用统计数据。</p>
<p>　　特定于Linux的文件<code>/proc/PID/stat</code>可用于获取系统中的所有进程的部分资源使用信息
(CPU时间和页故障)。</p>
<h3 id="进程资源限制">36.2 进程资源限制</h3>
<p>　　每个进程有1组资源限制，可用于限制进程可消耗的各种系统资源的数量。可以通过内置命令<code>ulimit</code>
(<code>csh</code>的<code>limit</code>)
来设置shell的资源限制，shell创建的用于执行用户命令的进程继承会继承这些资源限制。</p>
<p>　　从内核2.6.24开始，特定于Linux的文件<code>/proc/PID/limits</code>可用于获取任意进程的所有资源限制。该文件由对应进程的实际用户ID所有，其权限仅允许该用户ID
(或特权进程) 进行读取。</p>
<p>　　资源限制通常对特权进程和非特权进程均有效。通过<code>fork()</code>创建的子进程会继承这些资源限制，并且这些资源限制在<code>exec()</code>期间会被保留。</p>
<p>　　尽管资源限制是进程级属性，但在某些情况下，资源限制不仅根据进程对资源的消耗来衡量，还根据具有相同实际用户ID的所有进程所消耗的资源总和来衡量。此外，资源限制仅对已设置该限制的进程生效
(即进程以及继承了该资源限制的子进程)。若同一实际用户ID的其他进程没有设置资源限制
(即无限)
或设置了不同的资源限制，则该进程创建的子进程的能力将受限于它设置的资源限制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur; <span class="comment">/* 软限制 */</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_max; <span class="comment">/* 硬限制 (rlim_cur的上限) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>getrlimit()</code>和<code>setrlimit()</code>允许进程检索和修改自己的资源限制。参数<code>resource</code>用于标识待检索或修改的资源限制。参数<code>rlim</code>是指向结构体<code>rlimit</code>的指针，用于存储返回的资源限制值
(<code>getrlimit()</code>) 或指定新资源限制值
(<code>setrlimit()</code>)。</p>
<p>　　结构体<code>rlimit</code>的成员<code>rlim_cur</code>和<code>rlim_max</code>分别表示软限制和硬限制。这2个成员的数据类型<code>rlim_t</code>是整数类型。软限制控制进程可消耗的资源量。进程可以将软限制调整为0到硬限制之间的值。对于大多数资源，硬限制唯一的功能是作为软限制的上限。特权进程
(能力<code>CAP_SYS_RESOURCE</code>) 可以任意调整硬限制
(只要不小于软限制)，而非特权进程只能减小硬限制。对于这2个成员，值<code>RLIM_INFINITY</code>表示无限
(资源没有限制)。</p>
<p>　　参数<code>resource</code>只能被指定为以下值之一：</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 71%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr>
<th>资源限制</th>
<th>作用于</th>
<th>SUSv3</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RLIMIT_AS</code></td>
<td>进程虚拟内存大小，单位是字节</td>
<td>✓</td>
</tr>
<tr>
<td><code>RLIMIT_CORE</code></td>
<td>核心转储文件大小，单位是字节</td>
<td>✓</td>
</tr>
<tr>
<td><code>RLIMIT_CPU</code></td>
<td>CPU时间，单位是秒</td>
<td>✓</td>
</tr>
<tr>
<td><code>RLIMIT_DATA</code></td>
<td>进程数据段资源，单位是字节</td>
<td>✓</td>
</tr>
<tr>
<td><code>RLIMIT_FSIZE</code></td>
<td>文件大小，单位是字节</td>
<td>✓</td>
</tr>
<tr>
<td><code>RLIMIT_MEMLOCK</code></td>
<td>锁定的内存，单位是字节</td>
<td></td>
</tr>
<tr>
<td><code>RLIMIT_MSGQUEUE</code></td>
<td>为实际用户ID分配的POSIX消息队列的字节 (Linux 2.6.8及以上版本)</td>
<td></td>
</tr>
<tr>
<td><code>RLIMIT_NICE</code></td>
<td>nice值 (Linux 2.6.12及以上版本)</td>
<td></td>
</tr>
<tr>
<td><code>RLIMIT_NOFILE</code></td>
<td>最大文件描述符加1</td>
<td>✓</td>
</tr>
<tr>
<td><code>RLIMIT_NPROC</code></td>
<td>实际用户ID的进程数</td>
<td></td>
</tr>
<tr>
<td><code>RLIMIT_RSS</code></td>
<td>驻留集大小，单位是字节 (未实现)</td>
<td></td>
</tr>
<tr>
<td><code>RLIMIT_RTPRIO</code></td>
<td>实时调度策略 (Linux 2.6.12及以上版本)</td>
<td></td>
</tr>
<tr>
<td><code>RLIMIT_RTTIME</code></td>
<td>实时CPU时间，单位是微秒 (Linux 2.6.25及以上版本)</td>
<td></td>
</tr>
<tr>
<td><code>RLIMIT_SIGPENDING</code></td>
<td>实际用户ID的排队信号数 (Linux 2.6.8及以上版本)</td>
<td></td>
</tr>
<tr>
<td><code>RLIMIT_STACK</code></td>
<td>栈大小，单位是字节</td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>　　在很多情况下，用于检索和设置资源限制的shell命令
(<code>bash</code>和<code>ksh</code>的<code>ulimit</code>以及<code>csh</code>的<code>limit</code>)
使用的单元不同于<code>getrlimit()</code>和<code>setrlimit()</code>
(例如，shell命令通常以KB为单位表示各种内存段大小的资源限制)。</p>
<p>　　对于某些编程环境，数据类型<code>rlim_t</code>可能无法表示特定资源限制的所有可能值。提供多种编程环境的系统可能出现这种情况，导致<code>rlim_t</code>的大小有所不同。若将具有64位<code>off_t</code>的大文件编译环境添加到<code>off_t</code>为32位的系统，则会出现这种系统
(无论哪种环境，<code>rlim_t</code>的大小都会与<code>off_t</code>一致)。这会导致情况：当具有较小<code>rlim_t</code>的程序在具有64位<code>off_t</code>的程序执行后执行时，可能继承大于<code>rlim_t</code>最大值的资源限制。</p>
<p>　　为此，SUSv3详细说明了2个用于表示无法表示的限制值的常量：<code>RLIM_SAVED_CUR</code>和<code>RLIM_SAVED_MAX</code>。若软限制无法通过<code>rlim_t</code>表示，则<code>getrlimit()</code>会通过成员<code>rlim_cur</code>返回<code>RLIM_SAVED_CUR</code>；若硬限制无法通过<code>rlim_t</code>表示，则<code>getrlimit()</code>会通过成员<code>rlim_max</code>返回<code>RLIM_SAVED_MAX</code>。</p>
<p>　　当资源限制的所有可能值都能通过<code>rlim_t</code>表示时，SUSv3允许实现将<code>RLIM_SAVED_CUR</code>和<code>RLIM_SAVED_MAX</code>定义为<code>RLIM_INFINITY</code>。对于Linux，这2个常量就是这样定义的
(因为资源限制的所以可能值都能通过<code>rlim_t</code>表示)。但是，x86-32等32位架构则不同。对于这些架构，若使用大文件编译环境
(将特性测试宏<code>_FILE_OFFSET_BITS</code>定义为64)，则glibc会将<code>rlim_t</code>定义为64位，但用于表示资源限制的内核数据类型还是32位的<code>unsigned long</code>。对于当前版本的glibc，若使用<code>_FILE_OFFSET_BITS=64</code>编译的程序试图将资源限制设置为无法通过32位无符号整数表示的值，则glibc的<code>setrlimit()</code>包装函数会自动将该值转换为<code>RLIM_INFINITY</code>。换句话说，请求的资源限制将不被执行
(有人可能会认为，这种情况下的glibc的<code>setrlimit()</code>包装函数最好返回错误。但是，根本问题是内核限制，这里的行为是glibc开发者处理这个问题的方法)。</p>
<p>　　对于很多x86-32发行版，处理文件的工具通常使用<code>_FILE_OFFSET_BITS=64</code>进行编译，所以无法遵循超过32位表示范围的资源限制的问题不仅会影响开发者，还会影响用户。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* print_rlimit.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_rlimit.h&quot;</span> <span class="comment">/* 定义函数原型的头文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印msg加上resource指定的资源限制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @param resource</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printRlimit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">int</span> resource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(resource, &amp;rlim) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s soft=&quot;</span>, msg);</span><br><span class="line">    <span class="keyword">if</span> (rlim.rlim_cur == RLIM_INFINITY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;infinite&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIM_SAVED_CUR <span class="comment">/* 有些实现未定义该资源限制 */</span></span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rlim.rlim_cur == RLIM_SAVED_CUR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unrepresentable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)rlim.rlim_cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;; hard=&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rlim.rlim_max == RLIM_INFINITY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;infinite\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIM_SAVED_MAX <span class="comment">/* 有些实现未定义该资源限制 */</span></span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rlim.rlim_max == RLIM_SAVED_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unrepresentable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)rlim.rlim_max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>printRlimit()</code>会打印1条信息以及指定资源的软限制和硬限制。这里处理数据类型<code>rlim_t</code>的表示方式与处理数据类型<code>off_t</code>的表示方法相同
(为了处理文件大小资源限制<code>RLIMIT_FSIZE</code>的表示)。因此，在打印<code>rlim_t</code>值时，会将其转换为<code>long long</code>，并在<code>printf()</code>中使用格式说明符<code>%lld</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* rlimit_nproc.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_rlimit.h&quot;</span> <span class="comment">/* printRlimit()的函数原型 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || argc &gt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s soft-limit [hard-limit]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printRlimit(<span class="string">&quot;Initial maximum process limits: &quot;</span>, RLIMIT_NPROC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置新进程的资源限制 (若未指定硬限制，则将硬限制设置为软限制的值) */</span></span><br><span class="line">    rl.rlim_cur = (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>) ? RLIM_INFINITY : getInt(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;soft-limit&quot;</span>);</span><br><span class="line">    rl.rlim_max = (argc == <span class="number">2</span>) ? rl.rlim_cur : (argv[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>) ? RLIM_INFINITY</span><br><span class="line">                                                                  : getInt(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;hard-limit&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (setrlimit(RLIMIT_NPROC, &amp;rl) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setrlimit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printRlimit(<span class="string">&quot;New maximum process limits: &quot;</span>, RLIMIT_NPROC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建尽可能多的子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>;; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (childPid = fork())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 */</span></span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* 父进程：打印每个子进程的相关信息并让它们转换为僵尸进程 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child %d (PID=%ld) started\n&quot;</span>, j, (<span class="type">long</span>)childPid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会调用<code>setrlimit()</code>来设置用户可创建的进程数量
(<code>RLIMIT_NPROC</code>)
的软限制和硬限制，然后通过函数<code>printRlimit()</code>来打印修改前后的限制值，最后创建尽可能多的子进程。</p>
<h3 id="特定资源限制的详细信息">36.3 特定资源限制的详细信息</h3>
<h4 id="rlimit_as和rlimit_core">36.3.1
<code>RLIMIT_AS</code>和<code>RLIMIT_CORE</code></h4>
<p>　　资源限制<code>RLIMIT_AS</code>指定进程的虚拟内存 (地址空间)
的最大大小
(单位是字节)。试图超过该限制会导致错误<code>ENOMEM</code>。实际上，程序最常见的达到该限制的地方调用malloc包中的函数
(使用了<code>sbrk()</code>和<code>mmap()</code>)。一旦达到该限制，栈增长也会失败，进而导致达到<code>RLIMIT_STACK</code>时的结果。</p>
<p>　　资源限制<code>RLIMIT_CORE</code>指定核心转储文件的最大大小
(单位是字节)。当达到该限制后，核心转储文件将停止生成。将该限制指定为0可以阻止核心转储文件的生成，这有时很有用，因为核心转储文件可能很大，而用户不知道如何处理。另一个原因是安全性——防止程序内存的内容被转储到磁盘。若<code>RLIMIT_FSIZE</code>低于该限制，则核心转储文件的大小将被限制到<code>RLIMIT_FSIZE</code>字节。</p>
<h4 id="rlimit_cpu">36.3.2 <code>RLIMIT_CPU</code></h4>
<p>　　资源限制<code>RLIMIT_CPU</code>指定进程可用的 (系统和用户模式)
CPU时间的最大秒数。SUSv3要求，信号<code>SIGXCPU</code>会在达到软<code>RLIMIT_CPU</code>限制时被发送给进程，但没有说明其他细节。注册<code>SIGXCPU</code>处理函数来执行一些操作并将控制权返回给主函数是可能的。因此，对于Linux，当达到软<code>RLIMIT_CPU</code>限制后，进程每耗时1秒，内核就会向进程发送1次信号<code>SIGXCPU</code>。若进程持续执行并达到硬<code>RLIMIT_CPU</code>限制，则内核会发送信号<code>SIGKILL</code>给该进程。</p>
<p>　　处理收到信号<code>SIGXCPU</code>后仍然继续占用CPU时间的进程的细节因UNIX实现而异。在大多数情况下，仍然会定期发送信号<code>SIGXCPU</code>。当考虑到该信号的可移植性时，应用程序应该被设计为在第1次收到该信号时执行所需的清理操作并终止，或者在收到该信号时修改资源限制。</p>
<h4 id="rlimit_datarlimit_fsize和rlimit_memlock">36.3.3
<code>RLIMIT_DATA</code>、<code>RLIMIT_FSIZE</code>和<code>RLIMIT_MEMLOCK</code></h4>
<p>　　资源限制<code>RLIMIT_DATA</code>指定进程的数据段
(包括已初始化数据段、未初始化数据段和堆) 的最大大小
(单位是字节)。试图超过该限制会导致错误<code>ENOMEM</code>。与<code>RLIMIT_AS</code>类似，程序最常见的达到该限制的地方调用malloc包中的函数。</p>
<p>　　资源限制<code>RLIMIT_FSIZE</code>指定进程可创建的文件的最大大小
(单位是字节)。若达到软<code>RLIMIT_FSIZE</code>限制，则信号<code>SIGXFSZ</code>会被发送给进程，并且系统调用
(例如，<code>write()</code>和<code>truncate()</code>) 会出错
(<code>EFBIG</code>)。捕获该信号并将控制权返回给主函数是可能的。但是，进程试图超过该限制会产生同样的信号和错误。</p>
<p>　　源于BSD的资源限制<code>RLIMIT_MEMLOCK</code>指定进程可以锁定在物理内存中的虚拟内存
(防止换出) 的最大大小
(单位是字节)。SUSv3没有说明该资源限制，并且只有Linux和BSD提供了该资源限制。该资源会限制影响<code>mlock()</code>和<code>mlockall()</code>以及<code>mmap()</code>和<code>shmctl()</code>的锁定选项。若调用<code>mlockall()</code>时指定了标志<code>MCL_FUTURE</code>，则该资源限制会导致后续对<code>brk()</code>、<code>sbrk()</code>、<code>mmap()</code>和<code>mremap()</code>的调用出错。</p>
<h4 id="rlimit_msgqueue和rlimit_nice">36.3.4
<code>RLIMIT_MSGQUEUE</code>和<code>RLIMIT_NICE</code></h4>
<p>　　特定于Linux的资源限制<code>RLIMIT_MSGQUEUE</code> (Linux
2.6.8及以上版本)
指定可以为调用进程的实际用户ID分配的POSIX消息队列的最大大小
(单位是字节)。当通过<code>mq_open()</code>创建POSIX消息队列时，将根据以下公式从该限制中扣除字节数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bytes = attr.mq_maxmsg * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg *) + attr.mq_maxmsg * attr.mq_msgsize;</span><br></pre></td></tr></table></figure>
<p>　　<code>attr</code>是作为第4个参数传递给<code>mq_open()</code>的结构体<code>mq_attr</code>，乘以<code>sizeof(struct msg_msg *)</code>是为了确保用户无法将无限数量的零长度消息放入队列中
(结构体<code>msg_msg</code>是内核内部使用的数据类型)。这是必要的，因为尽管零长度消息不包含数据，但会消耗一些系统内存用于记录开销。</p>
<p>　　<code>RLIMIT_MSGQUEUE</code>仅影响调用进程。调用进程的所有者的其他进程不会受到影响，除非它们设置或继承了该资源限制。</p>
<p>　　特定于Linux的资源限制<code>RLIMIT_NICE</code> (Linux
2.6.12及以上版本)
指定进程可以通过<code>sched_setscheduler()</code>或<code>nice()</code>设置的nice值的上限
(见35.1)。</p>
<h4 id="rlimit_nofile">36.3.5 <code>RLIMIT_NOFILE</code></h4>
<p>　　资源限制<code>RLIMIT_NOFILE</code>表示进程可分配的最大文件描述符加1。试图超过该限制通常会导致错误<code>EMFILE</code>。对于<code>dup2(fd, newfd)</code>，错误是<code>EBADF</code>。当调用<code>fcntl(fd, F_DUPFD, newfd)</code>时将<code>newfd</code>指定为不小于该限制的值时，错误是<code>EINVAL</code>。</p>
<p>　　对<code>RLIMIT_NOFILE</code>的修改会反映在<code>sysconf(_SC_OPEN_MAX)</code>的返回值中。SUSv3允许但不要求实现在修改该限制前后<code>sysconf(_SC_OPEN_MAX)</code>返回不同的值，所以其他实现在这一点的行为上可能与Linux不同。</p>
<p>　　SUSv3指出，当应用程序将软/硬<code>RLIMIT_NOFILE</code>限制设置为不大于当前打开的最大文件描述符的值时，会出现意外行为。</p>
<p>　　对于Linux，可以使用<code>readdir()</code>扫描目录<code>/proc/PID/fd</code>来检查进程当前打开的文件描述符，该目录包含进程当前打开的所有文件描述符的符号链接。</p>
<p>　　内核为<code>RLIMIT_NOFILE</code>设置了上限。在内核2.6.25之前，该上限是由内核常量<code>NR_OPEN</code>定义的硬编码值，其值为1048576
(增大该值需要重新构建内核)。从内核2.6.25开始，特定于Linux的文件<code>/proc/sys/fs/nr_open</code>定义该上限，默认为1048576，并且超级用户可以修改该上限。试图将软/硬<code>RLIMIT_NOFILE</code>限制设置为大于该上限的值会导致错误<code>EPERM</code>。</p>
<p>　　所有进程可以打开的文件总数还存在系统级限制，可以通过特定于Linux的文件<code>/proc/sys/fs/file-max</code>来检索或修改该限制。只有特权进程
(能力<code>CAP_SYS_ADMIN</code>)
才能超过该限制。对于非特权进程，系统调用遇到该限制时会导致错误<code>ENFILE</code>。</p>
<h4 id="rlimit_nproc">36.3.6 <code>RLIMIT_NPROC</code></h4>
<p>　　源于BSD的资源限制<code>RLIMIT_NPROC</code>指定调用进程的实际用户ID可创建的进程的最大数量。试图超过该限制会导致错误<code>EAGAIN</code>。</p>
<p>　　<code>RLIMIT_NPROC</code>仅影响调用进程。调用进程的所有者的其他进程不会受到影响，除非它们设置或继承了该资源限制。特权进程
(能力<code>CAP_SYS_ADMIN</code>或<code>CAP_SYS_RESOURCE</code>)
不会受到该资源限制的影响。</p>
<p>　　Linux还对所有用户可创建的进程数设置了系统级限制。对于Linux
2.4及以上版本，可以通过特定于Linux的文件<code>/proc/sys/kernel/threads-max</code>来检索和修改该限制。更准确地说，该限制和<code>RLIMIT_NPROC</code>实际上是对可创建的线程数量的限制，而非进程数量的限制。</p>
<p>　　<code>RLIMIT_NPROC</code>的默认值的设置方式因内核版本而异。对于Linux
2.2，该值使用固定公式计算。对于Linux
2.4及以上版本，该值使用基于可用物理内存的公式计算。</p>
<p>　　SUSv3没有说明<code>RLIMIT_NPROC</code>，并且只有Linux和BSD提供了该限制。SUSv3规定的检索用户ID允许的最大进程数的方法是调用<code>sysconf(_SC_CHILD_MAX)</code>。Linux支持该调用。在2.6.23内核之前，该调用总是返回999。从内核2.6.23
(和glibc 2.4及以上版本) 开始，该调用会正确地返回限制值
(通过检查<code>RLIMIT_NPROC</code>的值)。</p>
<p>　　不存在可移植的获取已为特定用户ID创建的进程数量的方法。对于Linux，可以扫描文件<code>/proc/PID/status</code>并检查条目<code>Uid</code>下的信息
(按序列出了4个进程用户ID：实际用户ID、有效用户ID、保存的set-user-ID和文件系统用户ID)，以估算用户当前拥有的进程数。</p>
<h4 id="rlimit_rssrlimit_rtprio和rlimit_rttime">36.3.7
<code>RLIMIT_RSS</code>、<code>RLIMIT_RTPRIO</code>和<code>RLIMIT_RTTIME</code></h4>
<p>　　源于BSD的资源限制<code>RLIMIT_RSS</code>指定进程的驻留集的最大页数，即物理内存中的当前虚拟页的总数。SUSv3没有说明该资源限制，但Linux和很多UNIX实现都提供了该资源限制。对于Linux，该限制资源目前未生效。</p>
<p>　　对于较旧的Linux 2.4内核
(直到2.4.29)，<code>RLIMIT_RSS</code>确实会影响<code>madvise()</code>的操作<code>MADV_WILLNEED</code>。若由于达到<code>RLIMIT_RSS</code>而导致无法执行该操作，则会在<code>errno</code>中返回<code>EIO</code>。</p>
<p>　　特定于Linux的资源限制<code>RLIMIT_RTPRIO</code> (Linux
2.6.12及以上版本)
指定进程可以通过<code>sched_setscheduler()</code>和<code>sched_setparam()</code>设置的实时优先级的上限。</p>
<p>　　特定于Linux的资源限制<code>RLIMIT_RTTIME</code> (Linux
2.6.25及以上版本) 指定实时调度策略下运行的进程在不睡眠
(即执行阻塞系统调用) 的情况下可消耗的最长CPU时间
(单位是微秒)。达到该限制时的行为与<code>RLIMIT_CPU</code>相同。</p>
<h4 id="rlimit_sigpending和rlimit_stack">36.3.8
<code>RLIMIT_SIGPENDING</code>和<code>RLIMIT_STACK</code></h4>
<p>　　特定于Linux的资源限制<code>RLIMIT_SIGPENDING</code> (Linux
2.6.8及以上版本) 指定调用进程的实际用户ID的排队信号
(包括标准信号和实时信号)
的最大数量。试图超过该限制会导致错误<code>EAGAIN</code>。</p>
<p>　　<code>RLIMIT_SIGPENDING</code>仅影响调用进程。调用进程的所有者的其他进程不会受到影响，除非它们设置或继承了该资源限制。</p>
<p>　　对于最初的实现，<code>RLIMIT_SIGPENDING</code>的默认值是1024。从内核2.6.12开始，该默认值与<code>RLIMIT_NPROC</code>的默认值相同。</p>
<p>　　<code>RLIMIT_SIGPENDING</code>仅对<code>sigqueue()</code>生效。即使达到该限制，仍然可以通过<code>kill()</code>将尚未排队的信号
(包括实时信号) 发送给进程。</p>
<p>　　从内核2.6.12开始，特定于Linux的文件<code>/proc/PID/status</code>的字段<code>SigQ</code>表示进程的实际用户ID的当前和最大排队信号数。</p>
<p>　　资源限制<code>RLIMIT_STACK</code>指定进程栈的最大大小
(单位是字节)。试图超过该限制会导致信号<code>SIGSEGV</code>被发送给进程。由于栈已耗尽，所以捕获信号的唯一方法是定义备用信号栈
(见21.4)。</p>
<p>　　从Linux
2.6.23开始，<code>RLIMIT_STACK</code>还决定用于存储进程的命令行参数和环境变量的空间的大小。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第38章 编写安全特权程序</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_38/</url>
    <content><![CDATA[<p>　　特权程序可以访问普通用户无法访问的特性和资源
(例如，文件和设备)。程序可以通过2种方式获取特权：</p>
<p>　　● 程序以特权用户ID启动
(例如，以root运行的守护进程和网络服务器)。</p>
<p>　　●
程序的set-user-ID或set-group-ID权限位已被设置。当执行set-user-ID
(set-group-ID) 程序时，该程序会将进程的有效用户 (组)
ID修改为该程序的所有者 (所属组)。</p>
<p>　　若特权程序存在漏洞或可以被恶意用户破坏，则系统或应用程序安全性可能受到威胁。因此，应该尽可能地避免将程序设计为特权程序。</p>
<p>　　有时，可以将需要特权的功能隔离到1个执行单一任务的程序中，并在需要时在子进程中执行该程序。这种方式对库很有用。</p>
<p>　　即使需要使用set-user-ID (set-group-ID)
程序，也不一定需要为set-user-ID (set-group-ID)
程序提供root凭证。若为进程提供其他凭证就足够了，则应该优先选择这些凭证，因为root权限可能导致漏洞。</p>
<p>　　当set-user-ID程序需要允许用户更新它们没有写权限的文件时，更安全的实现方法是为该程序创建1个专用的组账号
(组ID)，将文件的所属组修改为该组
(并使文件对该组可写)，然后编写1个set-group-ID程序来将进程的有效组ID设置该组的ID。</p>
<p>　　Linux默认不允许set-user-ID程序生成核心转储文件来响应信号，即使该程序已经放弃特权。但是，并非所有UNIX实现都提供了该安全特性。</p>
<span id="more"></span>
<p>　　当程序读取密码或其他敏感信息时，应该在执行所需的处理后立即从内存中删除这些信息。将这些信息留在内存存在安全风险，原因如下：</p>
<p>　　● 包含数据的虚拟内存页可能被换出
(除非使用<code>mlock()</code>等函数锁定在内存中)，然后特权程序可以在交换区域读取其中的数据。</p>
<p>　　●
当进程收到的信号会导致核心转储文件的生成时，可以通过读取核心转储文件来获取信息。</p>
<p>　　安全程序通常应该避免核心转储文件的生成，以防止其中的敏感信息被读取。程序可以通过<code>setrlimit()</code>将资源限制<code>RLIMIT_CORE</code>设置为0来实现这一点。</p>
<p>　　特权程序应该始终检查系统调用和库函数是否成功以及返回值是否符合预期
(这对所有程序都是如此，但对特权程序尤其重要)。很多系统调用都可能出错，即使程序以root凭证运行
(例如，<code>fork()</code>会因达到系统级进程数量限制而出错，对只读文件系统上的文件进行写入的<code>open()</code>调用会出错以及<code>chdir()</code>在目标目录不存在时会出错)。</p>
<p>　　即使系统调用成功，也可能需要检查其结果
(例如，在重要情况下，特权程序应检查<code>open()</code>调用是否返回了标准文件描述符之一)。</p>
<p>　　若特权程序遇到意外情况，通常应该终止程序
(若是服务器，则丢弃客户端请求)，因为尝试处理意外情况通常需要做出一些假设，而这些假设在某些情况下可能并不合理，甚至可能导致安全漏洞。</p>
<h3 id="以最小权限运行">38.1 以最小权限运行</h3>
<p>　　set-user-ID (set-group-ID)
程序只需要执行特定操作的权限。当它执行其他任务时，应该禁用特权。换句话说，程序应该以完成任务所需的<span
style="background-color: yellow">最小特权</span>运行，保存的set-user-ID
(set-group-ID) 正是用于该目的 (见9.2)。</p>
<h4 id="仅在需要时获取特权">38.1.1 仅在需要时获取特权</h4>
<p>　　对于set-user-ID程序，可以在通过以下顺序调用<code>seteuid()</code>来临时放弃特权，然后再次获取特权：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uid_t</span> orig_euid;</span><br><span class="line"></span><br><span class="line">orig_euid = geteuid();</span><br><span class="line"><span class="keyword">if</span> (seteuid(getuid()) == <span class="number">-1</span>) <span class="comment">/* 临时放弃特权 */</span></span><br><span class="line">&#123;</span><br><span class="line">  errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行不需要特权的任务 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (seteuid(orig_euid) == <span class="number">-1</span>) <span class="comment">/* 重新获取特权 */</span></span><br><span class="line">&#123;</span><br><span class="line">  errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行需要特权的任务 */</span></span><br></pre></td></tr></table></figure>
<p>　　第1次调用<code>seteuid()</code>会将调用进程的有效用户ID修改为其实际用户ID。第2次调用<code>seteuid()</code>会将有效用户ID恢复为保存的set-user-ID。</p>
<p>　　对于set-group-ID程序，保存的set-group-ID会存储程序的初始有效组ID，<code>setegid()</code>可用于放弃和重新获取特权。</p>
<p>　　最安全的做法是在程序启动时立即放弃特权，然后在程序需要特权时临时获取特权。当程序不再需要特权时，通过修改保存的set-user-ID来永久放弃特权。</p>
<h4 id="不再需要特权时永久放弃特权">38.1.2
不再需要特权时永久放弃特权</h4>
<p>　　当set-user-ID (set-group-ID)
程序完成所有需要特权的任务后，应该永久放弃特权，以消除因程序漏洞或其他意外行为而产生的安全风险。永久放弃特权通过将进程的所有用户
(组) ID修改为其实际用户 (组) ID完成。</p>
<p>　　对于set-user-ID-root程序，可以通过以下代码来永久放弃特权：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (setuid(getuid()) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;setuid&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　但是，当调用进程的有效用户ID不为0时，<code>setuid()</code>只会修改有效用户ID
(见9.4.1.2)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始值: real=1000 effective=0 saved=0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 临时放弃特权 */</span></span><br><span class="line">orig_euid = geteuid();</span><br><span class="line"><span class="keyword">if</span> (seteuid(getuid() == <span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改后: real=1000 effective=1000 saved=0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 试图永久放弃特权 (错误) */</span></span><br><span class="line"><span class="keyword">if</span> (setuid(getuid() == <span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;setuid&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UID不变: real=1000 effective=1000 saved=0 */</span></span><br></pre></td></tr></table></figure>
<p>　　相反，这里需要重新获取特权来永久放弃特权，即在第1步和第2步之间插入以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (seteuid(orig_euid) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于set-user-ID程序，<code>setuid()</code>不足以修改保存的set-user-ID，所以必须通过<code>setreuid()</code>或<code>setresuid()</code>来永久放弃特权：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (setreuid(getuid(), getuid()) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;setreuid&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码依赖于<code>setreuid()</code>的Linux实现的特性：若第1个参数
(<code>ruid</code>)
不为-1，则保存的set-user-ID也会被设置为有效用户ID的新值。SUSv3没有说明该特性，但很多其他实现都提供了该特性。</p>
<h4 id="关于修改进程凭证的要点">38.1.3 关于修改进程凭证的要点</h4>
<p>　　某些会修改进程凭证的系统调用的语义因系统而异，其中的部分系统调用的语义甚至因调用者是否拥有特权而异。Dan
Tsafrir等人的《Portably Solving File TOCTTOU Races with Hardness
Amplification》推荐应用程序使用特定于系统的非标准系统调用来修改进程凭证，因为在很多情况下，这些非标准系统调用提供了比对应的标准系统调用更简单、更一致的语义
(例如，Linux的<code>setresuid()</code>和<code>setresgid()</code>)。尽管并非所有系统都提供了这些系统调用，但这些系统调用更不容易出错。</p>
<p>　　对于Linux，即使调用者的有效用户ID为0，修改凭证的系统调用也可能因程序已经显式地修改了其能力而不会按照预期运行
(例如，对进程用户ID的修改可能因能力<code>CAP_SETUID</code>被禁用而出错)。</p>
<p>　　因此，强烈建议<span
style="background-color: yellow">不仅检查修改凭证的系统调用是否成功，还要验证凭证是否已被修改为预期值</span>。当需要通过<code>seteuid()</code>临时放弃特权时，应该在调用该函数后调用<code>geteuid()</code>来验证有效用户ID是否为预期值。同样，当需要永久放弃特权时，应该在调用对应的函数后验证实际用户ID、有效用户ID以及保存的set-user-ID是否为非特权用户ID。但是，标准系统调用只能检索实际ID和有效ID，无法检索保存的set-user-ID或set-group-ID。Linux和有些UNIX提供了用于该目的<code>getresuid()</code>和<code>getresgid()</code>；对于其他系统，则需要通过解析文件<code>/proc</code>的信息等方法。</p>
<p>　　有些凭证只能被有效用户ID为0的进程修改，所以当修改多个ID
(包括辅助组ID、组ID和用户ID)
时，应该在放弃特权ID时最后修改有效用户ID。相反地，当提升特权ID时，应该最先提升特权有效用户ID。</p>
<h3 id="执行程序时的注意点">38.2 执行程序时的注意点</h3>
<p>　　若set-user-ID (set-group-ID)
程序会执行其他程序，则应该在执行新程序之前将进程的所有用户 (组)
ID修改为实际用户 (组)
ID，以确保新程序不会带有特权启动，并且无法获取特权。除了38.1介绍的方法之外，还可以在<code>exec()</code>之前调用<code>setuid(getuid())</code>来达到相同的效果。<code>setuid()</code>在有效用户ID不为0时只会修改有效用户ID，但成功的<code>exec()</code>调用会将有效用户ID复制给保存的set-user-ID
(若<code>exec()</code>出错，则保持不变)。类似的方法可以用于设置保存的set-group-ID，因为成功的<code>exec()</code>调用也会将有效组ID复制给保存的set-group-ID。</p>
<p>　　处于用户控制下的特权程序不应该直接或间接
(通过<code>system()</code>、<code>popen()</code>、<code>execlp()</code>和<code>execvp()</code>等函数)
执行shell。shell (以及<code>awk</code>等不受限制的解释器)
的复杂性和功能意味着，即使被执行的shell不允许交互访问，也几乎不可能消除所有安全漏洞。即使需要执行shell，也应该在执行shell之前永久放弃特权。</p>
<p>　　对于有些UNIX实现，脚本的set-user-ID和set-group-ID权限位也会生效，以便执行脚本时执行脚本的进程会假定为其他用户
(特权)
的身份。因为这会带来安全风险，所以Linux和其他某些UNIX实现会无视脚本的这2个权限位。</p>
<p>　　在默认情况下，文件描述符会在<code>exec()</code>期间保持打开。特权进程可以打开普通进程无法访问的文件，结果文件描述符代表特权资源。在<code>exec()</code>之前，应该关闭这些文件描述符，以防止新程序访问与之关联的文件。这可以通过显式关闭文件描述符或设置close-on-exec标志完成。</p>
<h3 id="限制进程">38.3 限制进程</h3>
<p>　　Linux的能力机制将传统的 "要么拥有所有特权，要么失去所有特权"
的UNIX权限机制划分为称为<strong>能力</strong>的独立单位。进程可以启用或禁用单个能力。通过仅启用那些所需的能力，程序运行所需的权限比以完全root权限运行时更少。这样可以降低程序遭到入侵后造成的破坏。</p>
<p>　　此外，通过使用能力和securebits标志，可以创建权限有限的非root所有的进程
(所有用户ID都不为0)。这样的进程无法在通过<code>exec()</code>来获取所有能力。</p>
<p>　　在某些情况下，可以通过创建chroot
jail来限制程序可访问的目录和文件集
(需要同时调用<code>chdir()</code>来将进程的当前工作目录修改为jail中的位置)。但是，chroot
jail不足以限制set-user-ID-root程序 (见18.11)。</p>
<p>　　虚拟服务器可以作为chroot
jail的替代方法。虚拟服务器是在虚拟内核上实现的服务器。每个虚拟内核都与运行在同一硬件上的其他虚拟内核隔离，所以虚拟服务器比chroot
jail更安全、更灵活
(其他一些现代操作系统也提供了各自的虚拟服务器实现)。Linux上最早的虚拟化实现是用户模式Linux
(UML)，它是2.6内核的标准组成部分。</p>
<h3 id="小心信号和竞争条件">38.4 小心信号和竞争条件</h3>
<p>　　用户可以向其启动的set-user-ID程序发送任意信号。这些信号可能在随时到达，所以需要考虑信号在程序执行时到达而导致的竞争条件。若信号到达的时间合适，则信号应该会被捕获、阻塞或忽略，以防止可能的安全问题。此外，信号处理函数的设计应该尽可能精简，以减少意外产生竞争条件的风险。</p>
<p>　　这个问题与停止进程的信号
(例如，<code>SIGTSTP</code>和<code>SIGSTOP</code>)
尤为相关。考虑以下问题场景：</p>
<p>　　1) set-user-ID程序获取关于其运行时环境的某些信息。</p>
<p>　　2)
用户试图停止正在运行程序的进程，并修改运行时环境的细节。这些修改可能包括修改文件的权限位、修改符号链接的目标文件或删除程序依赖的文件。</p>
<p>　　3)
用户通过信号<code>SIGCONT</code>恢复进程。此时，程序会基于对运行时环境的错误假设继续执行，而这些假设可能会导致安全漏洞。</p>
<p>　　该场景实际上只是time of check to time of use (TOCTTOU)
竞争条件的特例之一。特权进程应该避免基于可能已失效的先前验证结果的操作。即使用户无法向进程发送信号，该准则依然适用。用户停止进程的能力仅仅允许用户延长检查时间与使用时间之间的间隔。</p>
<p>　　虽然在检查时间和使用时间之间仅通过单次尝试来停止进程比较困难，但恶意用户可以反复执行set-user-ID程序，并使用其他程序或shell脚本反复向其发送停止信号，从而修改运行时环境。这可以大大增加篡改set-user-ID程序设置的可能性。</p>
<h3 id="执行文件操作和文件io时的陷阱">38.5
执行文件操作和文件I/O时的陷阱</h3>
<p>　　当特权进程需要创建文件时，应该注意该文件的所有权和权限，以确保该文件在任何时刻都不会有被恶意操作的风险，即使只是短暂的瞬间。</p>
<p>　　●
进程umask应该被设置为可以确保进程不会创建公开可写的文件的值，防止这些文件被恶意用户修改。</p>
<p>　　●
因为文件的用户ID取自创建进程的有效用户ID，所以可能需要谨慎地使用<code>seteuid()</code>或<code>setreuid()</code>来临时修改进程凭证，以确保新文件不属于错误的用户。文件的组ID可能取自创建进程的有效组ID，set-group-ID程序也可能会出现类似的情况，所以也需要对组ID执行类似的操作
(对于Linux，新文件的所有者由进程的文件系统ID决定，该ID通常与进程的有效用户ID相同)。</p>
<p>　　●
当set-user-ID-root程序需要创建最初由自己所有但最终由其他用户所有的文件时，新文件应该以不允许其他用户写入的方式创建，这可以通过在调用<code>open()</code>时使用合适的参数或在调用<code>open()</code>之前设置进程的umask来完成。随后，程序可以通过<code>fchown()</code>修改其所有权，若有必要，还可以通过<code>fchown()</code>修改其权限。关键是set-user-ID程序应该确保它永远不会创建由程序所有者所有且其他用户拥有
(短暂) 写入权限的文件。</p>
<p>　　● 应该对打开的文件描述符进行文件属性检查
(例如，<code>open()</code>后跟<code>fstat()</code>)
，而不是检查与路径名关联的属性，然后在打开文件
(例如，<code>stat()</code>后跟<code>open()</code>)，因为后者会导致TOCTTOU问题。</p>
<p>　　●
若程序需要确保它是文件的创建者，则调用<code>open()</code>时应该使用标志<code>O_EXCL</code>。</p>
<p>　　● 特权程序应该避免创建或依赖公共可写目录
(例如，<code>/tmp</code>)
下的文件，因为这会让程序容易受到恶意创建特权程序预期名称的未授权文件的攻击。若程序必须在公共可写目录下创建文件，则至少应该使用<code>mktemp()</code>等函数来确保文件名不可预测。</p>
<h3 id="不要相信输入和环境">38.6 不要相信输入和环境</h3>
<p>　　set-user-ID和set-group-ID程序不应该假设环境变量的值是可靠的，尤其是<code>PATH</code>和<code>IFS</code>。</p>
<p>　　● <code>PATH</code>决定shell
(包括<code>system()</code>和<code>popen()</code>)
以及<code>execlp()</code>和<code>execvp()</code>搜索程序的位置。恶意用户可以将该环境变量设置为某个值，从而欺骗使用这些函数之一的set-user-ID程序以特权执行这些程序。若需要使用这些函数，则应该将<code>PATH</code>设置为受信任的目录列表
(更好的做法是在执行程序时指定绝对路径名)。但是，如前所述，最好在执行shell或使用这些函数之前放弃特权。</p>
<p>　　●
<code>IFS</code>决定shell分隔命令行单词的分隔符。该环境变量应该被设置为空字符串
(表示只会将空格作为单词分隔符)。某些shell会在启动时以这种方式设置<code>IFS</code>。</p>
<p>　　有时，最安全的做法可能是先清空环境列表，然后使用已知安全的值恢复特定的环境变量，尤其是在执行其他程序或调用可能受环境变量影响的库时。</p>
<p>　　特权程序在根据所有来自不可信来源的输入采取行动之前，应该仔细验证这些输入
(可能包括验证数字是否在可接受的范围内、字符串的长度是否超出范围以及字符串是否包含非法字符)。可能需要以这种方式验证的输入包括来自用户创建的文件、命令行参数、交换输入、CGI输入、电子邮件消息、环境变量、不受信任的用户可访问的IPC通道和网络分组的输入。</p>
<p>　　set-user-ID程序应该避免对其初始运行时环境做出不可靠的假设
(例如，标准输入、输出或错误已被关闭。在这种情况下，打开文件时可能意外地重用文件描述符1，从而让程序错误地认为它在向标准输入写入)。此外，还有很多其他可能性需要考虑。以资源限制为例，进程可能会耗尽资源限制，从而导致各种系统调用出错或生成各种信号。恶意用户可能会试图通过耗尽资源来破坏程序。</p>
<h3 id="小心缓冲区溢出">38.7 小心缓冲区溢出</h3>
<p>　　注意缓冲区溢出，即输入值或复制的字符串超出分配的缓冲区。切勿使用<code>get()</code>，并且谨慎使用<code>scanf()</code>、<code>sprintf()</code>、<code>strcpy()</code>和<code>strcat()</code>等函数
(例如，通过<code>if</code>语句来防止缓冲区溢出)。</p>
<p>　　缓冲区溢出会为<span
style="background-color: yellow">栈崩溃</span> (也称为<span
style="background-color: yellow">栈粉碎</span>)
等攻击敞开大门，恶意用户利用缓冲区溢出将精心编码的字节放入栈中，以强制特权程序执行任意代码。缓冲区溢出可能是计算机系统安全漏洞最常见的单一来源，CERT和Bugtrap发布的公告就证明了这一点。缓冲区溢出对网络服务器尤其危险，因为它会使系统暴露于网络上的任何地方的远程攻击。</p>
<p>　　为了增加栈崩溃的难度
(尤其是对网络服务器的远程攻击)，从内核2.6.12开始，Linux实现了<span
style="background-color: yellow">地址空间布局随机化</span>
(ASLR)，该技术会在虚拟内存顶部8MB范围内随机改变栈的位置。此外，若软<code>RLIMIT_STACK</code>限制不为无穷大，并且特定于Linux的文件<code>/proc/sys/vm/legacy_va_layout</code>包含值0，则内存映射的位置也可能随机化。</p>
<p>　　较新的x86-32架构提供了可以将页表标记为NX (禁止执行)
的硬件支持。该特性可用于防止执行栈上的程序代码，从而增加栈崩溃的难度。</p>
<p>　　此外，上述函数都有安全的替代函数
(例如，<code>snprintf()</code>、<code>strncpy()</code>和<code>strncat()</code>)，允许指定待复制数据的最大字符数。</p>
<p>　　●
对于这些替代函数中的大多数函数，若达到了指定的最大值，则源字符串的截断版本将会被放入目标缓冲区。因为截断的字符串在程序语义上可能没有意义，所以调用者必须检查是否发生了截断，并采取合适的措施。</p>
<p>　　●
使用<code>strncpy()</code>可能会影响性能。若在调用<code>strncpy(s1, s2, n)</code>时<code>s2</code>的长度小于<code>n</code>，则会向<code>s1</code>填充空字节来确保总共写入<code>n</code>个字节。</p>
<p>　　●
若<code>strncpy()</code>的最大长度不足以容纳结尾的字符<code>\0</code>，则目标字符不会包含字符<code>\0</code>。</p>
<p>　　有些UNIX实现提供了函数<code>strlcpy()</code>。给定长度参数<code>n</code>，该函数会复制最多<code>n - 1</code>个字节到目标缓冲区，并且总是会在结尾加上字符<code>\0</code>。但是，SUSv3没有说明该函数，glibc也没有实现该函数。此外，当调用者没有仔细检查字符串长度时，该函数只是将缓冲区溢出的问题替换为静默丢弃数据的问题。</p>
<h3 id="小心拒绝服务攻击">37.8 小心拒绝服务攻击</h3>
<p>　　随着基于互联网的服务的普及，远程拒绝服务攻击的机会也相应增加。这种攻击会通过向服务器发送导致崩溃的格式错误的数据或伪造大量请求来使其过载，从而让服务器无法服务客户端。</p>
<p>　　处理格式错误的请求很简单——服务器应该被设计为严格检查其输入以避免缓冲区溢出。</p>
<p>　　过载攻击更难以处理。因为服务器无法控制远程客户端的行为或客户端发送请求的频率，所以通常无法防止此类攻击
(服务器可能甚至无法确定攻击的真正来源，因为网络分组的源IP地址可以被伪造。此外，分布式攻击可能会利用不知情的中间主机来攻击目标系统)。尽管如此，还是应该采取各种措施来最小化过载攻击的风险和后果：</p>
<p>　　●
服务器应该进行负载限制，在负载超过预设限制时丢弃请求。这会丢弃一些合法请求，但可以防止服务器和主机过载。使用资源限制和磁盘配额也有助于限制负载。</p>
<p>　　●
服务器应该对客户端的通信设置超时时间，防止服务器无期限地等待客户端。</p>
<p>　　● 服务器应该被设计为面对意外负载时不会崩溃
(例如，严格执行边界检查，确保过多的请求不会导致数据结构溢出)。</p>
<p>　　● 数据结构的设计应该避免算法复杂度攻击
(例如，二叉树可能是平衡的，并且在典型负载下能够提供可以接受的性能。但是，攻击者可以特殊的输入序列来让二叉树不平衡，从而影响性能)。</p>
<p>　　本地拒绝服务攻击是可能发生的。最常见的例子是用户运行简单的fork炸弹
(不断创建子进程的程序)。但是，本地拒绝服务攻击的来源更容易确定，而且可以通过适当的物理和密码措施来应对。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第37章 守护进程</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_37/</url>
    <content><![CDATA[<p>　　守护进程是带有以下特征的进程：</p>
<p>　　● 通常，守护进程在系统启动时被创建，并且一直运行，直到关机。</p>
<p>　　●
守护进程运行在后台，并且没有控制终端。因此，内核不会为守护进程生成作业控制或终端相关信号。</p>
<p>　　守护进程旨在执行特定任务，以下示例说明了这一点：</p>
<p>　　● <code>cron</code>：按预定时间执行命令的守护进程。</p>
<p>　　●
<code>sshd</code>：安全shell守护进程，允许远程主机通过安全通信协议登录。</p>
<p>　　● <code>httpd</code>：HTTP服务器守护进程
(Apache)，用于服务网页。</p>
<p>　　●
<code>inetd</code>：互联网超级服务器守护进程，它会监听指定TCP/IP端口的传入网络连接，并启动合适的服务器程序来处理这些连接。</p>
<p>　　很多标准守护进程都是以特权进程 (有效用户ID为0)
运行。按照惯例，守护进程的名称以字母<code>d</code>结尾
(但并非普遍遵循)。</p>
<p>　　对于Linux，某些守护进程以<span
style="background-color: yellow">内核线程</span>的形式运行。这些守护进程的代码是内核的一部分，并且它们通常在系统启动时被创建。当使用命令<code>ps</code>时，这些守护进程的名称被方括号
(<code>[]</code>) 括起来。</p>
<p>　　守护进程的日志日志和配置文件通常位于标准目录。按照惯例，配置文件通常位于目录<code>/etc</code>或其子目录，而日志文件通常位于目录<code>/var/log</code>。守护进程通常会提供命令行选项来修改日志文件和配置文件的位置。</p>
<span id="more"></span>
<h3 id="创建守护进程">37.1 创建守护进程</h3>
<p>　　为了成为守护进程，程序需要执行以下步骤：</p>
<p>　　1)
调用<code>fork()</code>，然后父进程退出，子进程继续运行。这样做有2个原因。首先，若守护进程从命令行启动，则shell会注意到父进程终止，然后显示另一个shell提示符并让子进程继续在后台运行。其次，子进程一定不会成为进程组组长，因为它会继承父进程的进程组ID，并获得自己的进程ID
(这是成功执行下一步所需要的)。</p>
<p>　　2)
子进程调用<code>setsid()</code>来创建新会话和释放与控制终端的关联。</p>
<p>　　3)
若守护进程自此没有打开任何终端设备，则守护进程不会获取控制终端。为了防止守护进程随后打开终端设备，必须采取措施来确保该设备不会成为控制终端。这可以通过2种方法实现。第1种方法是通过<code>open()</code>打开终端设备时指定标志<code>O_NOCTTY</code>。第2种方法是在<code>setsid()</code>后调用<code>fork()</code>，然后子进程退出，孙进程继续运行。这会确保孙进程不会成为会话组长。根据System
V获取控制终端的规则 (Linux遵循该规则)，该进程永远不能获取控制终端
(对于遵循BSD规则的实现，进程必须通过显式地执行<code>ioctl()</code>的操作<code>TIOCSCTTY</code>来获取控制终端)。</p>
<p>　　4)
清除进程umask，以确保守护进程创建文件和目录时有所需的权限。</p>
<p>　　5)
修改进程的当前工作目录，通常修改为根目录。这是必要的，因为守护进程通常会一直运行，若守护进程的当前工作目录位于不包含<code>/</code>的文件系统，则该文件系统无法被卸载。或者，守护进程可以将其工作目录修改为它执行任务的位置或配置文件中定义的位置
(只要该目录所在的文件系统永远不需要被卸载)。</p>
<p>　　6)
关闭守护进程从父进程继承的所有不再需要的打开的文件描述符。守护进程没有控制终端，并且在后台运行，所以无需让守护进程保留引用终端的文件描述符0~2。此外，无法卸载守护进程当前打开的文件所在的文件系统，而且文件描述符属于有限资源。</p>
<p>　　7)
当关闭文件描述符0~2后，守护进程通常会打开<code>/dev/null</code>
(<code>/dev/null</code>是虚拟设备，它会丢弃向其写入的所有数据。读取该设备总是会返回EOF)，并通过<code>dup2()</code>
(或类似的函数)
让这3个文件描述符引用该设备。这样做有2个原因。首先，当守护进程调用的函数对这3个文件描述符执行I/O时，这会保证这些函数不会意外地出错。其次，这可以防止守护进程随后使用文件描述符1或2打开文件，然后通过默认将这2个文件描述符视为标准输出和错误的库函数写入文件并损坏文件的可能性。</p>
<p>　　很多标准守护进程会在关机期间被特定应用程序的脚本终止。那些不通过这种方式终止的守护进程会在关机期间收到信号<code>SIGTERM</code>，因为进程<code>init</code>会在关机期间向其所有子进程发送该信号。若守护进程需要在终止前执行清理操作，则应该注册<code>SIGTERM</code>处理函数，该处理函数必须快速执行清理操作，因为进程<code>init</code>会在信号<code>SIGTERM</code>发送5秒后发送信号<code>SIGKILL</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* become_daemon.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BECOME_DAEMON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BECOME_DAEMON_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* becomeDaemon()的参数flags的位掩码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BD_NO_CHDIR 01          <span class="comment">/* 不会切换到根目录 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BD_NO_CLOSE_FILES 02    <span class="comment">/* 保留所有打开的文件描述符 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BD_NO_REOPEN_STD_FDS 04 <span class="comment">/* 不会重新打开文件描述符0~2 (让其引用/dev/null) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BD_NO_UMASK0 010        <span class="comment">/* 不清除umask */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BD_MAX_CLOSE 8192       <span class="comment">/* 最大文件描述符 (若sysconf(_SC_OPEN_MAX)无法获取最大文件描述符) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">becomeDaemon</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* become_daemon.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;become_daemon.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将调用进程转换为守护进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param flags</span></span><br><span class="line"><span class="comment"> * @return int 成功时返回0，出错时返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">becomeDaemon</span><span class="params">(<span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxfd, fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程继续运行 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程终止 */</span></span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsid() == <span class="number">-1</span>) <span class="comment">/* 成为新会话组长 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保孙进程不会成为会话组长 */</span></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; BD_NO_UMASK0))</span><br><span class="line">    &#123;</span><br><span class="line">        umask(<span class="number">0</span>); <span class="comment">/* 清除文件模式创建掩码 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; BD_NO_CHDIR))</span><br><span class="line">    &#123;</span><br><span class="line">        chdir(<span class="string">&quot;/&quot;</span>); <span class="comment">/* 切换到根目录 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭所有打开的文件描述符 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; BD_NO_CLOSE_FILES))</span><br><span class="line">    &#123;</span><br><span class="line">        maxfd = sysconf(_SC_OPEN_MAX);</span><br><span class="line">        <span class="keyword">if</span> (maxfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxfd = BD_MAX_CLOSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (fd = <span class="number">0</span>; fd &lt; maxfd; fd++)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭文件描述符0~2并让它们引用/dev/null */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; BD_NO_REOPEN_STD_FDS))</span><br><span class="line">    &#123;</span><br><span class="line">        close(STDIN_FILENO);</span><br><span class="line">        fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != STDIN_FILENO) <span class="comment">/* fd应该为0 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dup2(STDIN_FILENO, STDOUT_FILENO) != STDOUT_FILENO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dup2(STDIN_FILENO, STDERR_FILENO) != STDERR_FILENO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>becomeDaemon()</code>是上述步骤的实现
(glibc提供了与这个函数类似的非标准函数<code>daemon()</code>)。</p>
<h3 id="通过信号sighup重新初始化守护进程">37.2
通过信号<code>SIGHUP</code>重新初始化守护进程</h3>
<p>　　很多守护进程都是长时间运行，这会为带来一些编程上的问题：</p>
<p>　　●
通常，守护进程会在启动时从相关的配置文件读取参数。有时，可能需要即时修改这些参数，而无需停止并重新启动守护进程。</p>
<p>　　●
有些守护进程会生成日志文件。若守护进程一直打开日志文件，则日志文件可能无限增长，最终堵塞文件系统
(如前所述，即使删除了文件的所有文件名，只要有进程打开该文件，该文件就会一直存在)，所以需要某种方法来告诉守护进程关闭其日志文件并打开新文件，以便轮换日志文件
(程序<code>logrotate</code>可用于自动轮换守护进程日志文件)。</p>
<p>　　这些问题的解决方法是让守护进程注册<code>SIGHUP</code>处理函数。当控制进程与控制终端断开连接时，才会收到信号<code>SIGHUP</code>。因此，内核永远不会为守护进程生成该信号。</p>
<p>　　某些守护进程在收到信号<code>SIGHUP</code>时使用不同的方法进行重新初始化：关闭所有文件，然后通过<code>exec()</code>重新启动自己。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* daemon_SIGHUP.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;become_daemon.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TS_BUF_SIZE sizeof(<span class="string">&quot;YYYY-MM-DD HH:MM:SS&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *LOG_FILE = <span class="string">&quot;/tmp/ds.log&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *CONFIG_FILE = <span class="string">&quot;/tmp/ds.conf&quot;</span>;</span><br><span class="line"><span class="type">static</span> FILE *logfp;                           <span class="comment">/* 日志文件流 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> hupReceived = <span class="number">0</span>; <span class="comment">/* 是否收到信号SIGHUP */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向日志文件写入消息 (每条消息前会加上时间戳)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param format 格式字符串</span></span><br><span class="line"><span class="comment"> * @param ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">logMessage</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *TIMESTAMP_FMT = <span class="string">&quot;%F %X&quot;</span>; <span class="comment">/* 等同于YYYY-MM-DD HH:MM:SS */</span></span><br><span class="line">    <span class="type">char</span> timestamp[TS_BUF_SIZE];</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">loc</span>;</span></span><br><span class="line"></span><br><span class="line">    t = time(<span class="literal">NULL</span>);</span><br><span class="line">    loc = localtime(&amp;t);</span><br><span class="line">    <span class="keyword">if</span> (loc == <span class="literal">NULL</span> || strftime(timestamp, TS_BUF_SIZE, TIMESTAMP_FMT, loc) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(logfp, <span class="string">&quot;???Unknown time????: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(logfp, <span class="string">&quot;%s: &quot;</span>, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    <span class="built_in">vfprintf</span>(logfp, format, argList);</span><br><span class="line">    <span class="built_in">fprintf</span>(logfp, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    va_end(argList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打开日志文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param logFilename 日志文件路径名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">logOpen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *logFilename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mode_t</span> m;</span><br><span class="line"></span><br><span class="line">    m = umask(<span class="number">077</span>);</span><br><span class="line">    logfp = fopen(logFilename, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    umask(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开失败时不写入消息 */</span></span><br><span class="line">    <span class="keyword">if</span> (logfp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(logfp, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdio缓冲 */</span></span><br><span class="line"></span><br><span class="line">    logMessage(<span class="string">&quot;Opened log file&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 关闭日志文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">logClose</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    logMessage(<span class="string">&quot;Closing log file&quot;</span>);</span><br><span class="line">    fclose(logfp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读取配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param configFilename 配置文件路径名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">readConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *configFilename)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *configfp;</span><br><span class="line">    <span class="type">char</span> str[SBUF_SIZE];</span><br><span class="line"></span><br><span class="line">    configfp = fopen(configFilename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (configfp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fgets(str, SBUF_SIZE, configfp) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            str[<span class="built_in">strlen</span>(str) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 删除结尾的字符\0 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logMessage(<span class="string">&quot;Read config file: %s&quot;</span>, str);</span><br><span class="line">        fclose(configfp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sighupHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    hupReceived = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> SLEEP_TIME = <span class="number">15</span>; <span class="comment">/* 消息之间的睡眠时间 */</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;             <span class="comment">/* 睡眠次数 */</span></span><br><span class="line">    <span class="type">int</span> unslept;               <span class="comment">/* 剩余睡眠时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line">    sa.sa_handler = sighupHandler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (becomeDaemon(<span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;becomeDaemon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logOpen(LOG_FILE);</span><br><span class="line">    readConfigFile(CONFIG_FILE);</span><br><span class="line"></span><br><span class="line">    unslept = SLEEP_TIME;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        unslept = sleep(unslept);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hupReceived) <span class="comment">/* 若收到了信号SIGHUP */</span></span><br><span class="line">        &#123;</span><br><span class="line">            logClose();</span><br><span class="line"></span><br><span class="line">            logOpen(LOG_FILE);</span><br><span class="line">            readConfigFile(CONFIG_FILE);</span><br><span class="line">            hupReceived = <span class="number">0</span>; <span class="comment">/* 准备再次收到该信号 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unslept == <span class="number">0</span>) <span class="comment">/* 若睡眠完成 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            logMessage(<span class="string">&quot;Main: %d&quot;</span>, count);</span><br><span class="line">            unslept = SLEEP_TIME; <span class="comment">/* 重置间隔 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了守护进程如何使用信号<code>SIGHUP</code>。该程序会注册<code>SIGHUP</code>处理函数、转换为守护进程、打开日志文件和读取配置文件
(第121~135行)。<code>SIGHUP</code>处理函数只会设置全局标志变量<code>hupReceived</code>
(第109~112行)。最后，主函数开始无限循环，每15秒打印1条消息
(第152~157行)。睡眠是为了模拟实际应用程序执行任务的情况。每当<code>sleep()</code>返回时，主函数会检查标志<code>hupReceived</code>是否被设置，若是，则重新打开日志文件、重新读取配置文件以及清除该标志
(第143~150行)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> START &gt; /tmp/ds.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./daemon_SIGHUP</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /tmp/ds.log</span></span><br><span class="line">2011-01-17 11:18:34: Opened log file</span><br><span class="line">2011-01-17 11:18:34: Read config file: START</span><br></pre></td></tr></table></figure>
<p>　　首先，创建1个配置文件，然后启动守护进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> CHANGED &gt; /tmp/ds.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> +<span class="string">&#x27;%F %X&#x27;</span>; <span class="built_in">mv</span> /tmp/ds.log /tmp/old_ds.log</span></span><br><span class="line">2011-01-17 11:19:03 AM</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> +<span class="string">&#x27;%F %X&#x27;</span>; killall -HUP daemon_SIGHUP</span></span><br><span class="line">2011-01-17 11:19:23 AM</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /tmp/*ds.log</span></span><br><span class="line">/tmp/ds.log /tmp/old_ds.log</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /tmp/old_ds.log</span></span><br><span class="line">2011-01-17 11:18:34: Opened log file</span><br><span class="line">2011-01-17 11:18:34: Read config file: START</span><br><span class="line">2011-01-17 11:18:49: Main: 1</span><br><span class="line">2011-01-17 11:19:04: Main: 2</span><br><span class="line">2011-01-17 11:19:19: Main: 3</span><br><span class="line">2011-01-17 11:19:23: Closing log file</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /tmp/ds.log</span></span><br><span class="line">2011-01-17 11:19:23: Opened log file</span><br><span class="line">2011-01-17 11:19:23: Read config file: CHANGED</span><br><span class="line">2011-01-17 11:19:34: Main: 4</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">killall daemon_SIGHUP</span></span><br></pre></td></tr></table></figure>
<p>　　第6行的命令<code>ls</code>的输出有1个新日志文件和1个旧日志文件。当通过命令<code>cat</code>查看旧日志文件时，可以发现通过命令<code>mv</code>重命名文件后守护进程仍然在运行
(此时，可以删除旧日志文件)。当查看新日志文件时，可以发现配置文件已经被读取。</p>
<h3 id="使用syslog记录消息和错误">37.3 使用syslog记录消息和错误</h3>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_37/overview_of_system_logging.svg" class="">
<p>　　syslog提供了单一的集中式日志记录工具，可用于记录系统上所有应用程序的消息。syslog有2个主要组件：系统日志守护进程<code>syslogd</code>和库函数<code>syslog()</code>。</p>
<p>　　守护进程<code>syslogd</code>有2个日志消息源：UNIX域套接字<code>/dev/log</code>和互联网域套接字
(UDP端口514)。前者存储本地生成的消息，后者存储通过TCP/IP网络发送的消息
(某些UNIX实现的syslog套接字位于<code>/var/run/log</code>)。</p>
<p>　　守护进程<code>syslogd</code>处理的每条消息有很多属性，包括facility
(表示生成消息的程序的类别) 和level
(表示消息的优先级)。<code>syslogd</code>会解析每条消息的facility和level，然后根据相关配置文件<code>/etc/syslog.conf</code>将消息传递给几个可能的目的地中的任意1个。可能的目的地包括终端或虚拟控制台、磁盘文件、有名管道、若干个已登录用户或通过TCP/IP网络连接的其他系统上的进程
(通常也是<code>syslogd</code>)。消息可以被发送给若干个目的地。具有不同facility和level组合的消息可以被定位到不同的目的地或目的地的不同实例
(例如，不同的控制台或磁盘文件)。</p>
<p>　　向通过TCIP/IP网络连接的其他系统发送消息有助于将来自多个系统的消息合并到单个系统，从而减少管理开销。此外，这还有助于检查系统入侵。入侵通常会在系统日志中留下痕迹，但攻击者通常会通过删除日志记录来掩盖入侵。当使用远程日志时，攻击者还需要入侵远程系统才能删除日志记录。</p>
<p>　　所有进程都可以通过库函数<code>syslog()</code>来记录消息，该函数会使用提供的参数构建标准格式的消息，然后将其放置在<code>/dev/log</code>套接字上，以供守护进程<code>syslogd</code>读取。</p>
<p>　　<code>/dev/log</code>上的消息还有另一种来源——内核日志守护进程<code>klogd</code>，该守护进程会收集日志消息
(由内核通过函数<code>printk()</code>生成)。这些消息可以通过2个特定于Linux的接口收集：文件<code>/proc/kmsg</code>和系统调用<code>syslog()</code>，然后通过库函数<code>syslog()</code>将其写入<code>/dev/log</code>。</p>
<p>　　尽管系统调用<code>syslog()</code>和库函数<code>syslog()</code>同名，但它们执行的任务截然不同。</p>
<p>　　syslog最早出现于4.2BSD，现在大多数UNIX实现都提供了该功能。SUSv3标准化了库函数<code>syslog()</code>及其相关函数，但没有说明守护进程<code>syslogd</code>的实现和行为以及文件<code>syslog.conf</code>的格式。syslog的Linux实现不同于最初的BSD实现，它允许对文件<code>syslog.conf</code>中指定的消息处理规则进行一些扩展。</p>
<h4 id="syslog-api">37.3.1 syslog API</h4>
<p>　　syslog
API包含3个主要函数：<code>openlog()</code>、<code>syslog()</code>和<code>closelog()</code>。这3个函数都不会返回状态值，部分是因为日志系统应该始终是可用的
(当日志系统不可用时，系统管理者很快就会发现)。此外，若日志系统出错，则应用程序通常也难以有效地报告错误。</p>
<h5 id="openlog">37.3.1.1 <code>openlog()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> log_options, <span class="type">int</span> facility)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>openlog()</code>会建立与日志系统
(即UNIX域套接字<code>/dev/log</code>)
的连接，并修改影响后续<code>syslog()</code>调用的设置。该函数的调用是可选的，若省略了该函数，则第1次调用<code>syslog()</code>时会使用默认设置来建立与日志系统的连接。</p>
<p>　　参数<code>ident</code>是字符串
(通常是程序名)，<code>syslog()</code>写入的每条消息都会包含该字符串。<code>openlog()</code>只是复制了该指针的值。因此，只要后续需要调用<code>syslog()</code>，就应该确保该字符串不变。若该参数为<code>NULL</code>，则glibc的实现会自动将其值设置为程序名
(有些UNIX实现也是如此)。但是，SUSv3没有要求这一点，并且有些UNIX实现也没有这样做。</p>
<p>　　参数<code>log_options</code>是标志<code>LOG_CONS</code>、<code>LOG_NDELAY</code>、<code>LOG_NOWAIT</code>、<code>LOG_ODELAY</code>、<code>LOG_PERROR</code>和<code>LOG_PID</code>中的若干个标志进行或运算<code>|</code>得到的结果：</p>
<p>　　●
标志<code>LOG_CONS</code>表示错误被发送给日志系统时将该消息打印到系统控制台
(<code>/dev/console</code>)。</p>
<p>　　●
标志<code>LOG_NDELAY</code>表示立即打开与日志系统的连接。当需要控制何时打开<code>/dev/log</code>文件描述符时，该标志很有用。调用<code>chroot()</code>的程序便是如此，调用<code>chroot()</code>后<code>/dev/log</code>的路径名将不可见，所以必须在调用<code>chroot()</code>之前调用<code>openlog()</code>并指定该标志。守护进程<code>tftpd</code>
(简单文件传输) 就是使用该标志来实现该目的的程序之一。</p>
<p>　　●
标志<code>LOG_NOWAIT</code>表示不会回收为了记录消息而创建的子进程。对于创建子进程来记录消息的实现，若调用者创建了子进程，并且在等待子进程，则需要使用该标志，以防<code>syslog()</code>试图回收已被调用者回收的子进程。对于Linux，该标志不生效，因为记录消息时不会创建子进程。</p>
<p>　　●
标志<code>LOG_ODELAY</code>与<code>LOG_NDELAY</code>相反，与日志系统的连接会被推迟到记录第1条消息。这也是<span
style="background-color: yellow">默认</span>情况，无需指定。</p>
<p>　　●
标志<code>LOG_PERROR</code>表示会将消息写入到标志错误和系统日志。通常，守护进程会关闭标志错误或将其重定向到<code>/dev/null</code>
(该标志无效)。</p>
<p>　　●
标志<code>LOG_PID</code>表示在所有消息中记录调用者的进程ID。</p>
<p>　　SUSv3详细说明了标志<code>LOG_PERROR</code>以外的所有标志，而且并非所有UNIX实现都提供了标志<code>LOG_PERROR</code>。</p>
<p>　　参数<code>facility</code>指定用于后续<code>syslog()</code>调用的默认facility值，该参数的可能值如下：</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 71%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th>facility值</th>
<th>描述</th>
<th>SUSv3</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LOG_AUTH</code></td>
<td>安全和认证消息 (例如，<code>su</code>)</td>
<td>✓</td>
</tr>
<tr>
<td><code>LOG_AUTHPRIV</code></td>
<td>私有安全和认证消息</td>
<td></td>
</tr>
<tr>
<td><code>LOG_CRON</code></td>
<td>来自守护进程<code>cron</code>和<code>at</code>的消息</td>
<td>✓</td>
</tr>
<tr>
<td><code>LOG_DAEMON</code></td>
<td>来自其他系统守护进程的消息</td>
<td>✓</td>
</tr>
<tr>
<td><code>LOG_FTP</code></td>
<td>来自守护进程<code>ftpd</code>的消息</td>
<td></td>
</tr>
<tr>
<td><code>LOG_KERN</code></td>
<td>内核消息 (无法由用户进程生成)</td>
<td>✓</td>
</tr>
<tr>
<td><code>LOG_LOCAL0</code></td>
<td>仅供本地使用
(包括<code>LOG_LOCAL1</code>到<code>LOG_LOCAL7</code>)</td>
<td>✓</td>
</tr>
<tr>
<td><code>LOG_LPR</code></td>
<td>来自行式打印机系统
(<code>lpr</code>、<code>lpd</code>和<code>lpc</code>) 的消息</td>
<td>✓</td>
</tr>
<tr>
<td><code>LOG_MAIL</code></td>
<td>来自邮件系统的消息</td>
<td>✓</td>
</tr>
<tr>
<td><code>LOG_NEWS</code></td>
<td>Usenet网络新闻相关的消息</td>
<td>✓</td>
</tr>
<tr>
<td><code>LOG_SYSLOG</code></td>
<td>来自守护进程<code>syslogd</code>的内部消息</td>
<td></td>
</tr>
<tr>
<td><code>LOG_USER</code></td>
<td>由用户进程生成的消息 (默认)</td>
<td>✓</td>
</tr>
<tr>
<td><code>LOG_UUCP</code></td>
<td>来自UUCP系统的消息</td>
<td>✓</td>
</tr>
</tbody>
</table>
<p>　　SUSv3详细说明了大部分facility值，除了仅出现在少部分UNIX实现的<code>LOG_AUTHPRIV</code>和<code>LOG_FTP</code>以及出现在大部分UNIX实现的<code>LOG_SYSLOG</code>。<code>LOG_AUTHPRIV</code>可用于将包含密码或其他敏感信息的消息记录在与<code>LOG_AUTH</code>不同的位置。</p>
<h5 id="syslog">37.3.1.2 <code>syslog()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>syslog()</code>会记录1条消息。参数<code>priority</code>是1个facility值
(指定给<code>openlog()</code>的参数<code>facility</code>的值)
和1个level值 (消息的优先级)
进行或运算<code>|</code>得到的结果。若省略了facility值，则默认使用之前<code>openlog()</code>调用中指定的值。若之前未调用<code>openlog()</code>，则默认使用<code>LOG_USER</code>。SUSv3详细说明了所有level值，这些level值如下
(从高优先级到低优先级)：</p>
<table>
<thead>
<tr>
<th>level值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LOG_EMERG</code></td>
<td>紧急或恐慌情况 (系统无法使用)</td>
</tr>
<tr>
<td><code>LOG_ALERT</code></td>
<td>需要立即采取行动的情况 (例如，系统数据库损坏)</td>
</tr>
<tr>
<td><code>LOG_CRIT</code></td>
<td>关键情况 (例如，磁盘设备出错)</td>
</tr>
<tr>
<td><code>LOG_ERR</code></td>
<td>一般错误情况</td>
</tr>
<tr>
<td><code>LOG_WARNING</code></td>
<td>警告消息</td>
</tr>
<tr>
<td><code>LOG_NOTICE</code></td>
<td>可能需要特殊处理的普通情况</td>
</tr>
<tr>
<td><code>LOG_INFO</code></td>
<td>信息消息</td>
</tr>
<tr>
<td><code>LOG_DEBUG</code></td>
<td>调试消息</td>
</tr>
</tbody>
</table>
<p>　　<code>syslog()</code>的剩余参数是格式字符串和相应的参数，类似于<code>printf()</code>。与<code>printf()</code>的区别之一是格式字符串不需要包含结尾的换行符。此外，格式字符串还可以包含双字符序列<code>%m</code>，该序列会被替换为与<code>errno</code>的当前值对应的错误字符串
(等同于<code>strerror(errno)</code>)。</p>
<p>　　以下代码展示了<code>openlog()</code>和<code>syslog()</code>的用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">openlog(argv[<span class="number">0</span>], LOG_PID | LOG_CONS | LOG_NOWAIT, LOG_LOCALO);</span><br><span class="line">syslog(LOG_ERR, <span class="string">&quot;Bad argument: %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">syslog(LOG_USER | LOG_INFO, <span class="string">&quot;Exiting&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>　　第1次调用<code>syslog()</code>没有指定facility值，所以会使用调用<code>openlog()</code>时指定的默认值<code>LOG_LOCALO</code>。当第2次调用<code>syslog()</code>时，显式指定了facility值<code>LOG_USER</code>来覆盖调用<code>openlog()</code>时指定的默认值。</p>
<p>　　<code>syslog(priority, user_supplied_string)</code>调用是错误的，因为它容易让程序受到<span
style="background-color: yellow">格式字符串攻击</span>。若用户提供的字符串包含格式字符串，则结果不可预测，从安全角度，这可能存在危险
(这也适用于<code>printf()</code>)。因此，正确的调用方式应该是<code>syslog(priority, "%s", user_supplied_string)</code>。</p>
<p>　　glibc还提供了函数<code>void vsyslog(int priority, const char *format, va_list ap)</code>。该函数执行与<code>syslog()</code>相同的任务，但它的第3个参数需要通过头文件<code>stdarg.h</code>中的可变参数列表宏处理。SUSv3没有说明了该函数，而且并非所有UNIX实现都提供了该函数。</p>
<p>　　对于shell，可以通过命令<code>logger</code>来添加条目到系统日志。该命令允许指定与日志消息关联的优先级
(类似于<code>syslog()</code>的参数<code>priority</code>) 和标识符
(类似于<code>openlog()</code>的参数<code>ident</code>)。SUSv3简要说明了该命令，并且大多数UNIX实现都提供了该命令的某个版本。</p>
<h5 id="closelog">37.3.1.3 <code>closelog()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>closelog()</code>会关闭与日志系统的连接
(释放为<code>/dev/log</code>分配的文件描述符)。</p>
<p>　　守护进程通常会持续保持与日志系统的连接，所以通常不会调用该函数。</p>
<h5 id="setlogmask">37.3.1.4 <code>setlogmask()</code></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setlogmask</span><span class="params">(<span class="type">int</span> mask_priority)</span>; <span class="comment">/* 返回日志优先级掩码的旧值 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>setlogmask()</code>用于设置过滤<code>syslog()</code>写入的消息的掩码。level不在该掩码范围内的消息都会被丢弃。默认掩码允许记录所有优先级的消息。</p>
<p>　　定义在头文件<code>syslog.h</code>中的宏<code>LOG_MASK</code>可用于将level值转换为适合指定给参数<code>mask_priority</code>的值
(SUSv3详细说明了该宏)。为了过滤优先级低于<code>LOG_ERR</code>的消息，应该通过以下方式调用<code>setlogmask()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setlogmask(LOG_MASK(LOG_EMERG) | LOG_MASK(LOG_ALERT) |</span><br><span class="line">           LOG_MASK(LOG_CRIT) | LOG_MASK(LOG_ERR));</span><br></pre></td></tr></table></figure>
<p>　　Linux和大多数UNIX实现还提供了SUSv3未说明的宏<code>LOG_UPTO</code>，该宏会创建1个位掩码，过滤某个优先级及以下的所有消息。因此，该调用可以简化为以下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setlogmask(LOG_UPTO(LOG_ERR));</span><br></pre></td></tr></table></figure>
<h4 id="文件etcsyslog.conf">37.3.2
文件<code>/etc/syslog.conf</code></h4>
<p>　　配置文件<code>/etc/syslog.conf</code>控制守护进程<code>syslogd</code>的行为。该文件包含规则和注释
(以字符<code>#</code>开头)。规则通常具有以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">facility.level  action</span><br></pre></td></tr></table></figure>
<p>　　<code>facility</code>和<code>level</code>的组合称为<span
style="background-color: yellow">选择器</span>，因为它们选择规则适用的消息。这2个字段是37.3.1.1和37.3.1.2的表格中的值对应的字符串。<code>action</code>指定消息的目的地。选择器和<code>action</code>之间使用空格分隔。以下是一些规则示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.err                           /dev/tty10</span><br><span class="line">auth.notice                     root</span><br><span class="line">*.debug;mail.none;news.none     -/var/log/messages</span><br></pre></td></tr></table></figure>
<p>　　第1条规则表示level不低于<code>err</code> (<code>LOG_ERRs</code>)
的所有消息 (<code>*</code>)
都会被发送给控制台设备<code>/dev/tty10</code>。第2条规则表示level不低于<code>notice</code>
(<code>LOG_NOTICE</code>) 的安全和认证消息 (<code>auth</code>)
都会被发送给root登录的所有控制台或终端。该规则允许登录的root用户立即收到<code>su</code>失败等消息。</p>
<p>　　第3条规则展示了规则语法的一些高级特性。1条规则可以包含多个选择器，选择器之间使用分号<code>;</code>分隔。第1个选择器指定所有消息
(对于Linux和有些UNIX实现，level也可以被指定<code>*</code>，其含义与<code>debug</code>相同。但是，并非所有syslog实现都支持了该特性)。通常，包含多个选择器的规则会匹配与任何选择器对应的消息，但level为<code>none</code>表示排除对应facility的所有消息。因此，该规则表示Usenet网络新闻相关的消息
(<code>LOG_MAIL</code>) 和来自邮件系统的消息 (<code>LOG_NEWS</code>)
以外的所有消息会被发送给文件<code>/var/log/messages</code>。文件名前的连字符<code>-</code>表示在写入该文件时不进行磁盘同步
(见13.3)。这样会提高写入速度，但系统在写入时崩溃可能会丢失一些数据。</p>
<p>　　当修改文件<code>syslog.conf</code>后，必须通过命令<code>killall -HUP syslogd</code>来重新初始化守护进程<code>syslogd</code>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第39章 能力</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_39/</url>
    <content><![CDATA[<p>　　传统UNIX特权机制将进程分为2类：有效用户ID为0 (超级用户)
的进程以及其他所有进程。前者可以绕过所有权限检查，后者根据其用户和组ID接受权限检查。</p>
<p>　　对于传统UNIX特权机制，若进程需要执行特权操作，则必须在运行该进程时将其有效用户ID设置为0
(若非特权用户需要执行特权操作，则通常会使用set-user-ID-root程序)，但这种方法会授予进程很多其他操作的权限
(例如，绕过所有访问文件的权限检查)。因此，若程序行为异常，就会导致安全漏洞。如前所述，处理该问题的传统方法是放弃特权并在有需要时临时获取特权。</p>
<p>　　Linux能力机制改进了该问题的处理方式。超级用户特权被划分为称为<strong>能力</strong>的独立单元。每个特权操作与特定的能力关联，并且进程执行特权操作需要拥有对应的能力。当进程的有效用户ID为0时，内核会授予该进程所有能力。</p>
<p>　　Linux能力实现基于POSIX
1003.1e草案。这项标准化工作在20世纪90年代末期尚未完成前就陷入了困境，但各种能力实现仍然基于该草案。</p>
<p>　　Sun的Solaris 10和早期的Trusted Solaris版本、SGI的Trusted
Irix以及FreeBSD的TrustedBSD等UNIX实现也提供了能力机制。其他操作系统也存在类似的机制
(例如，Digital的VMS系统中的特权机制)。</p>
<p>　　完全实现能力机制需要满足以下条件：</p>
<p>　　●
对于每个特权操作，内核应检查进程是否拥有对应的能力，而非检查其有效
(文件系统) 用户ID是否为0。</p>
<p>　　● 内核必须提供用于检索和修改进程能力的系统调用。</p>
<p>　　●
内核必须支持将能力附加到可执行文件的概念，以便进程在执行该文件时获取关联的能力。这与set-user-ID位类似，但允许单独指定可执行文件的所有能力。此外，系统必须提供用于检索和设置附加到可执行文件的能力的API和命令。</p>
<p>　　对于内核2.6.23及以下版本，Linux仅满足前2个要求。从内核2.6.24开始，Linux支持将能力附加到文件。内核2.6.25和2.6.26添加的各种特性使得Linux能够满足所有要求。</p>
<span id="more"></span>
<h3 id="进程和文件能力">39.1 进程和文件能力</h3>
<p>　　内核为每个进程维护了3个关联的能力集：<span
style="background-color: yellow">允许能力集</span>、<span
style="background-color: yellow">有效能力集</span>和<span
style="background-color: yellow">可继承能力集</span>。</p>
<p>　　●
进程的允许能力集是进程可以使用的能力的集合。允许能力集合是可添加到有效能力集和可继承能力集中的能力的超集。若进程从其允许能力集中删除了某个能力，则它将永远无法重新获取该能力
(除非它执行能够授予该能力的程序)。</p>
<p>　　●
进程的有效能力集是内核用于对进程执行权限检查的能力的集合。只要进程在其允许能力集中保留了某个能力，就可以通过从其有效能力集删除该能力来临时禁用它，然后再将其恢复到有效能力集。</p>
<p>　　●
进程的可继承能力集是程序被进程执行时可以被继承到进程的允许能力集的能力的集合。</p>
<p>　　进程的允许能力集、有效能力集和可继承能力集的十六进制表示分别可以通过特定于Linux的文件<code>/proc/PID/status</code>的字段<code>CapPrm</code>、<code>CapEff</code>和<code>CapInh</code>获取。</p>
<p>　　通过<code>fork()</code>创建的子进程会继承父进程的能力集。</p>
<p>　　实际上，能力是线程级属性。线程的能力可以通过文件<code>/proc/PID/task/TID/status</code>获取。主线程的能力可以通过文件<code>/proc/PID/status</code>获取。</p>
<p>　　在内核2.6.25之前，Linux使用32位能力集。内核2.6.25中新增的能力需要64位能力集。</p>
<p>　　文件可以有3个关联的能力集：<span
style="background-color: yellow">允许能力集</span>、<span
style="background-color: yellow">有效能力集</span>和<span
style="background-color: yellow">可继承能力集</span>，用于决定进程执行该文件时授予该进程的能力。</p>
<p>　　●
文件的允许能力集是在<code>exec()</code>期间添加给进程的允许能力集的能力的集合。</p>
<p>　　●
文件的有效能力集只是1个位。若启用该位，则<code>exec()</code>期间进程的新允许能力集中启用的能力也会在进程的新有效能力集中被启用。若禁用该位，则<code>exec()</code>后进程的新有效能力集最初为空。对于不知道能力机制的传统程序，<code>exec()</code>应该能让新允许能力集中启用的所有能力在新有效能力集中被启用。对于设计时考虑了能力机制的程序，最小权限表示进程的有效能力集最初应该为空。</p>
<p>　　● 文件的可继承能力集会对进程的可继承能力集进行掩码操作
(与运算<code>&amp;</code>)，以确定<code>exec()</code>后应在进程的允许能力集中启用的能力。</p>
<p>　　文件的允许能力集和可继承能力集以前称为强制能力集和允许能力集。这些术语已经过时，但仍然有参考意义。文件的允许能力集是在<code>exec()</code>期间会被强制添加到进程的允许能力集的能力的集合。文件的可继承能力集是<code>exec()</code>期间允许被添加到进程的允许能力集的能力的集合，前提进程的可继承能力集也启用了这些能力。</p>
<p>　　安全扩展属性<code>security.capability</code>存储着与文件关联的能力，更新该扩展属性需要能力<code>CAP_SETFCAP</code>。</p>
<p>　　命令<code>setcap</code>和<code>getcap</code>可用于控制文件能力集。这里将通过标准程序<code>date</code>来展示它们的用法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">Tue Dec 28 15:54:08 CST 2010</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> -s <span class="string">&#x27;2018-02-01 21:39&#x27;</span></span> </span><br><span class="line">date: cannot set date: Operation not permitted</span><br><span class="line">Thu Feb  1 21:39:00 CST 2018</span><br></pre></td></tr></table></figure>
<p>　　首先，打印当前系统时间并尝试以非特权用户修改时间。根据结果可知，修改失败，但还是以标准格式打印了参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">date</span> -s <span class="string">&#x27;2018-02-01 21:39&#x27;</span></span></span><br><span class="line">root&#x27;s password:</span><br><span class="line">Thu Feb  1 21:39:00 CST 2018</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">Thu Feb  1 21:39:00 CST 2018</span><br></pre></td></tr></table></figure>
<p>　　然后，以超级用户修改时间。根据结果可知，修改成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis -b <span class="built_in">date</span></span></span><br><span class="line">date: /bin/date</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> /bin/date .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">setcap</span> <span class="string">&quot;cap_sys_time=pe&quot;</span> <span class="built_in">date</span></span></span><br><span class="line">root&#x27;s password:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">getcap</span> <span class="built_in">date</span></span></span><br><span class="line">date = cap_sys_time+ep</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./date -s <span class="string">&#x27;2010-12-28 15:55&#x27;</span></span></span><br><span class="line">Thu Feb  1 15:55:00 CST 2010</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">Thu Feb  1 15:55:02 CST 2010</span><br></pre></td></tr></table></figure>
<p>　　最后，复制程序<code>date</code>并为它分配所需的能力。这里通过命令<code>setcap</code>将能力<code>CAP_SYS_TIME</code>添加到该程序的允许能力集
(<code>p</code>) 和有效能力集
(<code>e</code>)，通过命令<code>getcap</code>验证分配的能力，并以非特权用户运行它来修改系统时间。</p>
<h3 id="linux能力">39.2 Linux能力</h3>
<p>　　下表列出了各种Linux能力 (包括适用的操作的不完整介绍)：</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr>
<th>能力</th>
<th>允许进程执行的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CAP_AUDIT_CONTROL</code></td>
<td>(Linux 2.6.11及以上版本)
启用和禁用内核审计日志；修改审计过滤规则；检索审计状态和过滤规则</td>
</tr>
<tr>
<td><code>CAP_AUDIT_WRITE</code></td>
<td>(Linux 2.6.11及以上版本) 向内核审计日志写入记录</td>
</tr>
<tr>
<td><code>CAP_CHOWN</code></td>
<td>修改文件的用户ID或将文件的组ID修改为进程不属于的组的ID
(<code>chown()</code>)</td>
</tr>
<tr>
<td><code>CAP_DAC_OVERRIDE</code></td>
<td>绕过文件读取、写入和执行权限检查
(DAC是自主访问控制的缩写)；读取<code>/proc/PID</code>中的符号链接<code>cwd</code>、<code>exe</code>和<code>root</code>的内容</td>
</tr>
<tr>
<td><code>CAP_DAC_READ_SEARCH</code></td>
<td>绕过文件的读取权限检查以及目录的读取和执行 (搜索) 权限检查</td>
</tr>
<tr>
<td><code>CAP_FOWNER</code></td>
<td>通常忽略对那些需要进程的文件系统用户ID匹配文件的用户ID的操作的权限检查
(<code>chmod()</code>和<code>utime()</code>)；设置任意文件的i-node标志；设置和修改任意的文件的ACL；删除文件时无视目录的粘滞位
(<code>unlink()</code>、<code>rmdir()</code>和<code>rename()</code>)；对任意文件调用<code>open()</code>和<code>fcntl(F_SETFL)</code>时指定标志<code>O_NOATIME</code></td>
</tr>
<tr>
<td><code>CAP_FSETID</code></td>
<td>修改文件而不让内核禁用set-user-ID和set-group-ID位
(<code>write()</code>和<code>truncate()</code>)；进程的文件系统组ID或辅助组ID不匹配文件的组ID时启用文件的set-group-ID位
(<code>chmod()</code>)</td>
</tr>
<tr>
<td><code>CAP_IPC_LOCK</code></td>
<td>覆盖内存锁定限制
(<code>mlock()</code>、<code>mlockall()</code>、<code>shmctl(SHM_LOCK)</code>和<code>shmctl(SHM_UNLOCK)</code>)；使用<code>shmget()</code>的标志<code>SHM_HUGETLB</code>和<code>mmap()</code>的标志<code>MAP_HUGETLB</code></td>
</tr>
<tr>
<td><code>CAP_IPC_OWNER</code></td>
<td>绕过System V IPC对象操作的权限检查</td>
</tr>
<tr>
<td><code>CAP_KILL</code></td>
<td>绕过发送信号的权限检查
(<code>kill()</code>和<code>sigqueue()</code>)</td>
</tr>
<tr>
<td><code>CAP_LEASE</code></td>
<td>(Linux 2.4及以上版本) 对任意文件建立租约
(<code>fcntl(F_SETLEASE)</code>)</td>
</tr>
<tr>
<td><code>CAP_LINUX_IMMUTABLE</code></td>
<td>设置i-node标志<code>FS_APPEND_FL</code>和<code>FS_IMMUTABLE_FL</code></td>
</tr>
<tr>
<td><code>CAP_MAC_ADMIN</code></td>
<td>(Linux 2.6.25及以上版本) 配置或修改强制访问控制 (MAC) 的状态
(由某些Linux安全模块实现)</td>
</tr>
<tr>
<td><code>CAP_MAC_OVERRIDE</code></td>
<td>(Linux 2.6.25及以上版本) 覆盖MAC (由某些Linux安全模块实现)</td>
</tr>
<tr>
<td><code>CAP_MKNOD</code></td>
<td>(Linux 2.4及以上版本) 通过<code>mknod()</code>来创建设备</td>
</tr>
<tr>
<td><code>CAP_NET_ADMIN</code></td>
<td>执行各种网络相关操作
(例如，设置特权套接字选项、启用多播、配置网络接口和修改路由表)</td>
</tr>
<tr>
<td><code>CAP_NET_BIND_SERVICE</code></td>
<td>绑定特权套接字端口</td>
</tr>
<tr>
<td><code>CAP_NET_BROADCAST</code></td>
<td>(未使用) 执行套接字广播并监听多播</td>
</tr>
<tr>
<td><code>CAP_NET_RAW</code></td>
<td>使用原始和分组套接字</td>
</tr>
<tr>
<td><code>CAP_SETGID</code></td>
<td>随意修改进程组ID
(<code>setgid()</code>、<code>setegid()</code>、<code>setregid()</code>、<code>setresgid()</code>、<code>setfsgid()</code>、<code>setgroups()</code>和<code>initgroups()</code>)；通过UNIX域套接字传递凭证时伪造组ID
(<code>SCM_CREDENTIALS</code>)</td>
</tr>
<tr>
<td><code>CAP_SETFCAP</code></td>
<td>(Linux 2.6.24及以上版本) 设置文件能力</td>
</tr>
<tr>
<td><code>CAP_SETPCAP</code></td>
<td>若不支持文件能力，则能够授予或删除其他进程 (包括自身)
进程允许能力集中的能力；若支持文件能力，则能够将进程能力边界集中的任何能力添加到其可继承能力集，从边界集中删除能力，并修改securebits位</td>
</tr>
<tr>
<td><code>CAP_SETUID</code></td>
<td>随意修改进程用户ID
(<code>setuid()</code>、<code>seteuid()</code>、<code>setreuid()</code>、<code>setresuid()</code>和<code>setfsuid()</code>)；通过UNIX域套接字传递时凭证伪造用户ID
(<code>SCM_CREDENTIALS</code>)</td>
</tr>
<tr>
<td><code>CAP_SYS_ADMIN</code></td>
<td>打开文件的系统调用可以超过<code>/proc/sys/fs/file-max</code>限制
(例如，<code>open()</code>、<code>shm_open()</code>、<code>pipe()</code>、<code>socket()</code>、<code>accept()</code>、<code>exec()</code>、<code>acct()</code>和<code>epoll_create()</code>)；执行各种系统管理操作，包括<code>quotactl()</code>
(控制磁盘配额)、<code>mount()</code>、<code>umount()</code>、<code>swapon()</code>、<code>swapoff()</code>、<code>pivot_root()</code>、<code>sethostname()</code>和<code>setdomainname()</code>；调用系统调用<code>syslog()</code>；覆盖资源限制<code>RLIMIT_NPROC</code>
(<code>fork()</code>)；调用<code>lookup_dcookie()</code>；设置受信任的扩展属性和安全扩展属性；对任意System
V
IPC对象执行操作<code>IPC_SET</code>和<code>IPC_RMID</code>；通过UNIX域套接字传递凭证时伪造进程ID
(<code>SCM_CREDENTIALS</code>)；通过<code>ioprio_set()</code>分配调度类<code>IOPRIO_CLASS_RT</code>；使用<code>ioctl()</code>的操作<code>TIOCCONS</code>；调用<code>clone()</code>和<code>unshare()</code>时指定标志<code>CLONE_NEWNS</code>；执行<code>keyctl()</code>的操作<code>KEYCTL_CHOWN</code>和<code>KEYCTL_SETPERM</code>；管理内核随机数源设备；执行各种特定于设备的操作</td>
</tr>
<tr>
<td><code>CAP_SYS_BOOT</code></td>
<td>通过<code>reboot()</code>重启系统；调用<code>kexec_load()</code></td>
</tr>
<tr>
<td><code>CAP_SYS_CHROOT</code></td>
<td>通过<code>chroot()</code>设置进程根目录</td>
</tr>
<tr>
<td><code>CAP_SYS_MODULE</code></td>
<td>加载和卸载内核模块
(<code>init_module()</code>、<code>delete_module()</code>和<code>create_module()</code>)</td>
</tr>
<tr>
<td><code>CAP_SYS_NICE</code></td>
<td>减少nice值
(<code>nice()</code>和<code>setpriority()</code>)；修改任意的进程nice值
(<code>setpriority()</code>)；为调用进程设置实时调度策略<code>SCHED_RR</code>和<code>SCHED_FIFO</code>；重置标志<code>SCHED_RESET_ON_FORK</code>；设置任意进程的调度策略和优先级
(<code>sched_setscheduler()</code>和<code>sched_setparam()</code>)；设置任意进程的I/O调度类和级别
(<code>ioprio_set()</code>)；设置任意进程的CPU亲和性
(<code>sched_setaffinity()</code>)；通过<code>migrate_pages()</code>迁移进程，并允许将进程迁移到任意节点；将<code>move_pages()</code>应用于任意进程；调用<code>mbind()</code>和<code>move_pages()</code>时指定标志<code>MPOL_MF_MOVE_ALL</code></td>
</tr>
<tr>
<td><code>CAP_SYS_PACCT</code></td>
<td>通过<code>acct()</code>启用或禁用进程统计</td>
</tr>
<tr>
<td><code>CAP_SYS_PTRACE</code></td>
<td>通过<code>ptrace()</code>跟踪任意进程；访问任意进程的<code>/proc/PID/environ</code>；将<code>get_robust_list()</code>应用于任何进程</td>
</tr>
<tr>
<td><code>CAP_SYS_RAWIO</code></td>
<td>通过<code>iopl()</code>和<code>ioperm()</code>对I/O端口执行操作；访问<code>/proc/kcore</code>；打开<code>/dev/mem</code>和<code>/dev/kmem</code></td>
</tr>
<tr>
<td><code>CAP_SYS_RESOURCE</code></td>
<td>使用文件系统的保留空间；通过<code>ioctl()</code>控制ext3日志；覆盖磁盘配额限制；增加硬资源限制
(<code>setrlimit()</code>)；覆盖资源限制<code>RLIMIT_NPROC</code>
(<code>fork()</code>)；将System
V消息队列的<code>msg_qbytes</code>限制提高到<code>/proc/sys/kernel/msgmnb</code>中的限制以上；绕过<code>/proc/sys/fs/mqueue</code>下的文件定义的各种POSIX消息队列限制</td>
</tr>
<tr>
<td><code>CAP_SYS_TIME</code></td>
<td>修改系统时钟
(<code>settimeofday()</code>、<code>stime()</code>、<code>adjtime()</code>和<code>adjtimex()</code>)；设置硬件时钟</td>
</tr>
<tr>
<td><code>CAP_SYS_TTY_CONFIG</code></td>
<td>通过<code>vhangup()</code>对终端或伪终端执行虚拟挂断</td>
</tr>
</tbody>
</table>
<h3 id="exec期间进程能力的转换">39.3
<code>exec()</code>期间进程能力的转换</h3>
<p>　　在<code>exec()</code>期间，内核会根据进程的当前能力和被执行文件的能力集为进程设置新能力，规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P&#x27;(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; cap_bset)</span><br><span class="line">P&#x27;(effective) = F(effective) ? P&#x27;(permitted) : 0</span><br><span class="line">P&#x27;(inheritable) = P(inheritable)</span><br></pre></td></tr></table></figure>
<p>　　<code>P</code>表示<code>exec()</code>前的进程能力集，<code>P'</code>表示<code>exec()</code>后的进程能力集，<code>F</code>表示文件能力集。<code>cap_bset</code>表示能力边界集。能力边界集用于限制<code>exec()</code>期间进程可以获得的能力，其使用方式如下：</p>
<p>　　●
在<code>exec()</code>期间，能力边界集会与文件的允许能力集进行与运算<code>&amp;</code>来决定新程序的允许能力集
(若某个能力不在能力边界集中，则可执行文件的允许能力集就不能授予进程该能力)。</p>
<p>　　●
能力边界集是可以被添加到进程的可继承能力集的能力的有限超集。当能力边界集和进程的允许能力集中都包含某个能力时，进程才能将该能力添加到其可继承能力集。然后，当进程执行拥有该能力的文件时，该能力会被保留在其允许能力集中。</p>
<p>　　能力边界集是线程级属性。通过<code>fork()</code>创建的子进程会继承父进程中调用<code>fork()</code>的线程的能力边界集，并且能力边界集在<code>exec()</code>期间会被保留。对于支持文件能力的内核，进程<code>init</code>会以包含所有能力的能力边界集启动。</p>
<p>　　若进程拥有能力<code>CAP_SETPCAP</code>，则它可以通过<code>prctl()</code>的操作<code>PR_CAPBSET_DROP</code>来
(不可逆地)
删除其能力边界集中的能力。进程从能力边界集中删除能力不会影响其允许、有效和可继承能力集。进程可以通过<code>prctl()</code>的操作<code>PR_CAPBSET_READ</code>来读取其能力边界集。</p>
<p>　　从Linux
2.6.26开始，能力边界集显示在特定于Linux的文件<code>/proc/PID/task/TID/status</code>的字段<code>CapBnd</code>。主线程的能力边界集可以通过文件<code>/proc/PID/status</code>获取。</p>
<p>　　为了在执行文件时保留root用户的传统语义
(拥有所有特权)，与文件关联的所有能力都会被忽略。若执行的是set-user-ID-root程序或调用<code>exec()</code>的进程的实际或有效用户ID为0，则文件的允许能力集和可继承能力集会包含所有能力，并且有效能力集会被设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P&#x27;(permitted) = P(inheritable) | cap_bset</span><br><span class="line">P&#x27;(effective) = P&#x27;(permitted)</span><br></pre></td></tr></table></figure>
<h3 id="修改用户id对进程能力的影响">39.4 修改用户ID对进程能力的影响</h3>
<p>　　为了保持与用户ID为0的用户和用户ID不为0的用户之间转换的传统含义兼容，内核会在修改进程的用户ID时执行以下操作
(通过<code>setuid()</code>等函数)：</p>
<p>　　1)
当有效用户ID、有效用户ID或保存set-user-ID之前为0时，作为修改用户ID的结果，这些用户ID都会有非0值，并且允许能力集和有效能力集会被清空
(永久放弃所有能力)。</p>
<p>　　2) 当将有效用户ID从0修改为非0值时，有效能力集会被清空。</p>
<p>　　3)
当将有效用户ID从非0值修改为0时，允许能力集中的所有能力也会在有效能力集中被启用。</p>
<p>　　4)
当将文件系统用户ID从0修改为非0值时，能力<code>CAP_CHOWN</code>、<code>CAP_DAC_OVERRIDE</code>、<code>CAP_DAC_READ_SEARCH</code>、<code>CAP_FOWNER</code>、<code>CAP_FSETID</code>、<code>CAP_LINUX_IMMUTABLE</code>
(Linux
2.6.30及以上版本)、<code>CAP_MAC_OVERRIDE</code>和<code>CAP_MKNOD</code>
(Linux 2.6.30及以上版本)
会从有效能力集中被删除。相反，当将文件系统用户ID从非0值修改为0时，若允许能力集包括这些能力中的任意个，则包含的能力也会在有效能力集中被启用。这些行为是为了保持特定于Linux的文件系统用户ID操作的传统语义。</p>
<h3 id="在程序中修改进程能力">39.5 在程序中修改进程能力</h3>
<p>　　进程可以通过系统调用<code>capset()</code>或libcap
API来获取或放弃能力 (实际上，应使用库libcap
API，其中的函数提供了符合POSIX
1003.1e草案的接口以及一些Linux扩展的接口)。对进程能力的修改需遵循以下规则：</p>
<p>　　1)
若进程的有效能力集中没有能力<code>CAP_SETPCAP</code>，则新的可继承能力集必须是现有可继承能力集和允许能力集组合的子集。</p>
<p>　　2)
新的可继承能力集必须是现有可继承能力集和能力边界集组合的子集。</p>
<p>　　3) 新的允许能力集必须是现有允许能力集的子集。</p>
<p>　　4) 新的有效能力集中的能力只能是现的允许能力集中的能力。</p>
<p>　　使用libcap API的程序通常会执行以下步骤：</p>
<p>　　1)
通过函数<code>cap_get_proc()</code>来从内核中检索进程当前的能力集，并通过该函数在用户空间分配的结构体来存储结果
(或者，通过函数<code>cap_init()</code>来创建新的空能力集结构体)。在libcap
API中，数据类型<code>cap_t</code>是用于引用该结构体的指针。</p>
<p>　　2)
通过函数<code>cap_set_flag()</code>更新用户空间结构体，以从第1步获取的用户空间结构体中存储的允许能力集、有效能力集和可继承能力集中添加
(<code>CAP_SET</code>) 或删除能力 (<code>CAP_CLEAR</code>)。</p>
<p>　　3)
通过函数<code>cap_set_proc()</code>来将用户空间结构体传递到内核，以修改进程能力。</p>
<p>　　4) 通过函数<code>cap_free()</code>释放第1步分配的结构体。</p>
<p>　　在撰写本书时，libcap-ng (改进的能力库API) 的开发正在进行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check_password_caps.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE   <span class="comment">/* 定义了该宏后，getpass()会被声明在unistd.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE <span class="comment">/* 定义了该宏后，crypt()会被声明在unistd.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/capability.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shadow.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 修改调用者的有效能力集中的指定能力的设置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param capability 目标能力</span></span><br><span class="line"><span class="comment"> * @param setting 设置</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">modifyCap</span><span class="params">(<span class="type">int</span> capability, <span class="type">int</span> setting)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cap_t</span> caps;</span><br><span class="line">    <span class="type">cap_value_t</span> capList[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检索调用者的当前能力 */</span></span><br><span class="line">    caps = cap_get_proc();</span><br><span class="line">    <span class="keyword">if</span> (caps == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改caps的有效集中的capability的设置 */</span></span><br><span class="line">    capList[<span class="number">0</span>] = capability;</span><br><span class="line">    <span class="keyword">if</span> (cap_set_flag(caps, CAP_EFFECTIVE, <span class="number">1</span>, capList, setting) == <span class="number">-1</span>) <span class="comment">/* 第3个参数 (1) 是数组caplist的元素数 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        cap_free(caps);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将修改后的能力集传递给内核，以修改调用者的能力 */</span></span><br><span class="line">    <span class="keyword">if</span> (cap_set_proc(caps) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cap_free(caps);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放libcap API分配的结构体 */</span></span><br><span class="line">    <span class="keyword">if</span> (cap_free(caps) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在调用者的有效能力集中添加指定能力</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param capability 目标能力</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">raiseCap</span><span class="params">(<span class="type">int</span> capability)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> modifyCap(capability, CAP_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 清空调用者的所有能力集</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dropAllCaps</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cap_t</span> empty;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    empty = cap_init();</span><br><span class="line">    <span class="keyword">if</span> (empty == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = cap_set_proc(empty);</span><br><span class="line">    <span class="keyword">if</span> (cap_free(empty) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *username, *password, *encrypted, *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spwd</span> *<span class="title">spwd</span>;</span></span><br><span class="line">    Boolean authOk;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">long</span> lnmax;</span><br><span class="line"></span><br><span class="line">    lnmax = sysconf(_SC_LOGIN_NAME_MAX);</span><br><span class="line">    <span class="keyword">if</span> (lnmax == <span class="number">-1</span>) <span class="comment">/* 若无法获取用户名长度上限 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        lnmax = <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    username = <span class="built_in">malloc</span>(lnmax);</span><br><span class="line">    <span class="keyword">if</span> (username == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Username: &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> (fgets(username, lnmax, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">strlen</span>(username);</span><br><span class="line">    <span class="keyword">if</span> (username[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        username[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 删除结尾的\n */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pwd = getpwnam(username);</span><br><span class="line">    <span class="keyword">if</span> (pwd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;couldn&#x27;t get password record&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取能力CAP_DAC_READ_SEARCH (因为仅需要该该能力) */</span></span><br><span class="line">    <span class="keyword">if</span> (raiseCap(CAP_DAC_READ_SEARCH) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;raiseCap() failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spwd = getspnam(username);</span><br><span class="line">    <span class="keyword">if</span> (spwd == <span class="literal">NULL</span> &amp;&amp; errno == EACCES)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;no permission to read shadow password file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此时，不再需要任何能力，所以清空所有能力集 */</span></span><br><span class="line">    <span class="keyword">if</span> (dropAllCaps() == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;dropAllCaps() failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若检索到影子密码记录，则使用影子密码 */</span></span><br><span class="line">    <span class="keyword">if</span> (spwd != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pwd-&gt;pw_passwd = spwd-&gt;sp_pwdp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 加密密码并立即清除密码明文 */</span></span><br><span class="line">    password = getpass(<span class="string">&quot;Password: &quot;</span>);</span><br><span class="line">    encrypted = crypt(password, pwd-&gt;pw_passwd);</span><br><span class="line">    <span class="keyword">for</span> (p = password; *p != <span class="string">&#x27;\0&#x27;</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        *p++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encrypted == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;crypt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    authOk = <span class="built_in">strcmp</span>(encrypted, pwd-&gt;pw_passwd) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!authOk)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Incorrect password\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Successfully authenticated: UID=%ld\n&quot;</span>, (<span class="type">long</span>)pwd-&gt;pw_uid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行认证完成后的操作 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　
这个示例是8.4中的<code>check_password.c</code>的修改版，这里使用了能力和libcap
API。为了以普通用户读取影子密码文件，需要绕过标准文件权限检查，即能力<code>CAP_DAC_READ_SEARCH</code>。该程序会在读取影子密码文件之前将该能力添加到有效能力集，并在读取完成后立即放弃该能力。为了能够让非特权用户调用该程序，必须将该能力添加到文件的允许能力集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">setcap</span> <span class="string">&quot;cap_dac_read_search=p&quot;</span> check_password_caps</span></span><br><span class="line">root&#x27;s password:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">getcap</span> check_password_caps</span></span><br><span class="line">check_password_caps = cap_dac_read_search+p</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./check_password_caps</span></span><br><span class="line">Username: mtk</span><br><span class="line">Password:</span><br><span class="line">Successfully authenticated: UID=1000</span><br></pre></td></tr></table></figure>
<h3 id="创建完全基于能力的环境">39.6 创建完全基于能力的环境</h3>
<p>　　对于完全基于能力的系统，内核无需对root执行特殊处理
(见39.4)。set-user-ID-root程序也就不复存在，并且文件能力将用于授予程序所需的最少能力。</p>
<p>　　现有应用程序并未被设计为使用文件能力机制，所以内核必须保持对用户ID为0的进程的传统处理方式。尽管如此，有时可能需要让应用程序运行在完全基于能力的环境。从内核2.6.26开始，若在内核中启用了文件能力，则Linux会提供securebits机制，该机制会控制一系列线程级标志，这些标志可以启用或禁用对root的3种特殊处理。</p>
<p>　　securebits机制由3个基础标志和3个对应的锁定标志组成。每个基础标志控制1种root的特殊处理。设置对应的锁定标志是一次性操作，可防止对对应的基础标志进行进一步修改——一旦被设置，锁定标志就无法被取消。</p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SECBIT_KEEP_CAPS</code></td>
<td>当设置了该标志后，至少有1个用户ID为0的进程的所有用户ID都被修改为非0值时不会清空允许能力集。该标志仅在未设置标志<code>SECBIT_NO_SETUID_FIXUP</code>时生效。该标志在执行<code>exec()</code>时会被清除。</td>
</tr>
<tr>
<td><code>SECBIT_NO_SETUID_FIXUP</code></td>
<td>当设置了该标志后，进程的有效或文件系统用户ID在0和非0值之间切换时不会修改其能力。</td>
</tr>
<tr>
<td><code>SECBIT_NOROOT</code></td>
<td>当设置了该标志后，实际或有效用户ID为0的进程调用<code>exec()</code>或进程执行set-user-ID-root程序时不会授予该进程能力
(除非可执行文件有文件能力)。</td>
</tr>
<tr>
<td><code>SECBIT_KEEP_CAPS_LOCKED</code></td>
<td>锁定<code>SECBIT_KEEP_CAPS</code>。</td>
</tr>
<tr>
<td><code>SECBIT_NO_SETUID_FIXUP_LOCKED</code></td>
<td>锁定<code>SECBIT_NO_SETUID_FIXUP</code>。</td>
</tr>
<tr>
<td><code>SECBIT_NOROOT_LOCKED</code></td>
<td>锁定<code>SECBIT_NOROOT</code>。</td>
</tr>
</tbody>
</table>
<p>　　通过<code>fork()</code>创建的子进程会继承父进程中调用<code>fork()</code>的线程的securebits标志。所有securebits标志的设置在<code>exec()</code>期间会被保留，除了<code>SECBIT_KEEP_CAPS</code>。</p>
<p>　　进程可以通过<code>prctl()</code>的操作<code>PR_GET_SECUREBITS</code>检索securebits标志。完全基于能力的应用程序可以通过以下调用来不可逆地禁用调用进程及其所有子进程的的root特殊处理
(调用进程及其所有子进程随后只能通过执行拥有文件能力的程序来获得能力)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (prctl(PR_SET_SECUREBITS,</span><br><span class="line">          SECBIT_NO_SETUID_FIXUP | SECBIT_NO_SETUID_FIXUP_LOCKED |</span><br><span class="line">              SECBIT_NOROOT | SECBIT_NOROOT_LOCKED) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;prctl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　标志<code>SECBIT_KEEP_CAPS</code>提供的功能约等于<code>SECBIT_NO_SETUID_FIXUP</code>的一半。<code>SECBIT_KEEP_CAPS</code>的存在是为了与较旧的<code>prctl()</code>的操作<code>PR_SET_KEEPCAPS</code>对应，该操作的功能与<code>SECBIT_KEEP_CAPS</code>的相同
(两者唯一的区别是进程无需能力<code>CAP_SETPCAP</code>就可以使用<code>prctl()</code>的操作<code>PR_SET_KEEPCAPS</code>)。</p>
<p>　　<code>exec()</code>期间清除标志<code>SECBIT_KEEP_CAPS</code>也是为了与<code>prctl()</code>的操作<code>PR_SET_KEEPCAPS</code>所设置的属性的处理保持一致。</p>
<p>　　<code>prctl()</code>的操作<code>PR_SET_KEEPCAPS</code>旨在供运行在不支持文件能力的旧内核上的set-user-ID-root程序使用。</p>
<p>　　即使set-user-ID-root程序放弃它所不需要的所有能力，它仍然保留2个特权：访问root所有的文件的特权和通过执行程序重新获取能力的特权。放弃这2个特权的唯一方式是将其所有用户ID都设置为非0值。但是，这样做通常会导致清空允许能力集和有效能力集。这违背了初衷，即在与永久将用户ID修改为非0值的情况下保留部分能力。为此，<code>prctl()</code>的操作<code>PR_SET_KEEPCAPS</code>可用于在将所有用户ID修改为非0值时防止允许能力集被清空
(进程的有效能力集在这种情况下总是会被清空)。</p>
<h3 id="不支持文件能力的旧内核和系统">39.7
不支持文件能力的旧内核和系统</h3>
<p>　　尽管Linux从内核2.2开始支持能力并允许将其附加到进程，但文件能力的实现直到后几年才出现。文件能力长时间未实现更多是政策考量，而非技术难题
(内核2.6就已经支持用于实现文件能力的扩展属性)。内核开发者普遍认为系统管理者应该为每个特权程序设置和监控不同的能力集，但这会导致无法管理的复杂管理任务。相比之下，系统管理员熟悉现有UNIX权限模型，知道应该谨慎对待set-user-ID程序，并能通过命令<code>find</code>定位set-user-ID和set-group-ID程序。尽管如此，文件能力的开发者仍然提出了在管理上可行的论点，并最终提供了足以令人信服的理由，使文件能力得以集成到内核中。</p>
<p>　　对于不支持文件能力的内核
(即2.6.24之前以及从2.6.24开始的文件能力被禁用的内核)，能力<code>CAP_SETPCAP</code>的语义有所不同。受到类似于39.5中的规则的限制，从理论角度，有效能力集中包含该能力的进程可以修改除自身和<code>init</code>之外的所有进程的能力
(不能修改<code>init</code>的能力是因为该进程对系统的运行至关重要)。</p>
<p>　　从内核2.6.25开始，能力边界集成为了线程级属性。但是，对于较旧的内核，能力边界集是会影响所有进程的系统级属性，而系统级能力边界集总是会屏蔽能力<code>CAP_SETPCAP</code>。</p>
<p>　　对于2.6.25之后的内核，只有在内核中启用文件能力后，才能从线程级能力边界集中删除能力。在这种情况下，进程<code>init</code>以包含所有能力的能力边界集启动，并且系统创建的其他进程也会继承该能力边界集。若文件能力被禁用，则进程<code>init</code>的能力边界集会因能力<code>CAP_SETPCAP</code>的语义而不包含该能力。</p>
<p>　　系统级能力边界集可以通过特定于Linux的文件<code>/proc/sys/kernel/cap-bound</code>访问。进程修改该文件需要能力<code>CAP_SYS_MODULE</code>。但是，只有进程<code>init</code>才能启用该掩码中的位，其他进程只能禁用该掩码中的位。这些限制的结果是不支持文件能力的系统中的进程无法获取能力<code>CAP_SETPCAP</code>。这是合理的，因为该能力可用于破坏整个内核权限检查系统
(在这种情况下，若需要授予技能能力<code>CAP_SETPCAP</code>，则必须加载会修改能力集的内核模块并修改程序<code>init</code>的源码，或者修改内核源代码中的能力边界集初始化部分并重新编译内核)。</p>
<p>　　尽管系统级能力边界集是位掩码，但在文件<code>cap-bound</code>中表示为有符号十进制数
(例如，若该文件的初始值为-257，其二进制补码表示为11111111 11111111
11111110 11111111，则能力<code>CAP_SETPCAP</code>的值为8)。</p>
<p>　　对于不支持文件能力的系统，还是可以通过能力来提高程序的安全性。具体步骤如下：</p>
<p>　　1) 以有效用户ID为0的进程运行程序
(set-user-ID-root程序)。该进程的允许能力集和有效能力集通常会包含所有能力。</p>
<p>　　2) 程序启动时通过libcap
API清空有效能力集并从允许能力集中删除所需能力之外的所有能力。</p>
<p>　　3) 设置标志<code>SECBIT_KEEP_CAPS</code>。</p>
<p>　　4)
将进程的所有用户ID设置为非0值，以防止进程访问root所有的文件或通过<code>exec()</code>获取能力。</p>
<p>　　5) 在程序的剩余生命周期内，通过libcap
API来获取和放弃能力来执行任务。</p>
<p>　　若进程需要访问root所有的文件，则可以将第4和5步合并为设置标志<code>SECBIT_NOROOT</code>。</p>
<p>　　对于那些反对可执行文件的能力实现的内核开发者，这里介绍的方法的优点之一是应用程序开发者可以清楚地知道可执行文件需要那些能力。相比之下，系统管理者可能难以获取这些信息。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第40章 登录统计</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_40/</url>
    <content><![CDATA[<p>　　UNIX系统维护了2个包含用户登录和注销相关信息的文件：<code>utmp</code>和<code>wtmp</code>。</p>
<p>　　●
文件<code>utmp</code>维护着当前登录的用户的记录等信息。当用户登录时，1条记录会被写入到该文件。该记录的字段<code>ut_user</code>记录用户的登录名，并且该记录会在用户注销时被删除。命令<code>who</code>就是通过该文件的信息来显示当前登录用户的列表。</p>
<p>　　●
文件<code>wtmp</code>是所有用户登录和注销的审查记录。当用户登录时，除了会向文件<code>utmp</code>写入1条记录之外，也会向该文件写入1条相同的记录。当用户注销时，还会向该文件写入1条记录。用户注销时写入的记录与用户登录时写入的信息相同，除了字段<code>ut_user</code>会被清空。命令<code>last</code>可用于显示和筛选文件<code>wtmp</code>的内容。</p>
<p>　　对于Linux，文件<code>utmp</code>和<code>wtmp</code>的绝对路径名分别是<code>/var/run/utmp</code>和<code>/var/log/wtmp</code>。通常，应用程序无需知道这些路径名，因为它们会被编译到glibc。需要使用这些路径名的程序应该使用头文件<code>paths.h</code>和<code>utmpx.h</code>中定义的常量<code>_PATH_UTMP</code>和<code>_PATH_WTMP</code>
(而非显式地将路径名编码到程序中)。</p>
<p>　　SUSv3没有标准化文件<code>utmp</code>和<code>wtmp</code>的路径名的符号名。Linux和BSD使用<code>_PATH_UTMP</code>和<code>_PATH_WTMP</code>。很多其他UNIX实现将这2个路径名定义为<code>UTMP_FILE</code>和<code>WTMP_FILE</code>，Linux在头文件<code>utmp.h</code>中也定义了这2个符号名。</p>
<p>　　文件<code>utmp</code>和<code>wtmp</code>自UNIX早期就存在，但在各种UNIX实现中经历了持续的演化和分化
(尤其是BSD与System V之间)。System V Release
4极大地扩展了API，在该过程中创建了新的 (并行)
结构体<code>utmpx</code>以及相关文件<code>utmp</code>和<code>wtmp</code>。头文件和用于处理这些新文件的附加函数的名称也包括字母<code>x</code>。很多其他UNIX实现也向API中添加了自己的扩展。</p>
<p>　　Linux的utmpx API是BSD实现和System V实现的混合体。Linux不像System
V那样创建并行的文件<code>utmp</code>和<code>wtmp</code>。相反，这2个文件包含了所有必需的信息。但是，为了兼容UNIX实现，Linux同时提供了传统的utmp
API以及System V衍生的用于访问这些文件内容的utmpx
API。对于Linux，这2个API的信息完全相同
(两者的区别之一是前者提供了部分函数的可重入版本，而后者未提供)。此外，SUSv3仅说明了utmpx
API，所以考虑与UNIX实现兼容时该API是首选。但是，SUSv3没有说明utmpx
API的所有方面
(例如，文件<code>utmp</code>和<code>wtmp</code>的路径名)，所以登录统计文件在不同的实现中略有不同，并且各种实现提供了SUSv3说明的额外登录统计函数。</p>
<span id="more"></span>
<h3 id="结构体utmpx">40.1 结构体<code>utmpx</code></h3>
<p>　　文件<code>utmp</code>和<code>wtmp</code>由utmpx记录组成。utmpx记录对应的结构体<code>utmpx</code>被定义在头文件<code>utmpx.h</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 未定义该宏时，结构体exit_status的成员会带有前缀__ */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_status</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> e_termination; <span class="comment">/* 进程终止状态 (信号) */</span></span><br><span class="line">    <span class="type">short</span> e_exit;        <span class="comment">/* 进程退出状态 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UT_LINESIZE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UT_NAMESIZE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UT_HOSTSIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utmpx</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> ut_type;               <span class="comment">/* 记录类型 */</span></span><br><span class="line">    <span class="type">pid_t</span> ut_pid;                <span class="comment">/* 登录进程的PID */</span></span><br><span class="line">    <span class="type">char</span> ut_line[__UT_LINESIZE]; <span class="comment">/* 终端设备名 */</span></span><br><span class="line">    <span class="type">char</span> ut_id[<span class="number">4</span>];               <span class="comment">/* 终端设备名的后缀或文件inittab的字段ID */</span></span><br><span class="line">    <span class="type">char</span> ut_user[__UT_NAMESIZE]; <span class="comment">/* 用户名 */</span></span><br><span class="line">    <span class="type">char</span> ut_host[__UT_HOSTSIZE]; <span class="comment">/* 远程登录的主机名或运行级消息的内核版本 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_status</span> <span class="title">ut_exit</span>;</span>  <span class="comment">/* 被标记为DEAD_PROCESS的进程的退出状态 (对于Linux，进程init不会填充该成员) */</span></span><br><span class="line">    <span class="type">long</span> ut_session;             <span class="comment">/* 会话ID */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ut_tv</span>;</span>        <span class="comment">/* 条目创建时间 */</span></span><br><span class="line">    <span class="type">int32_t</span> ut_addr_v6[<span class="number">4</span>];       <span class="comment">/* 远程主机的IP地址 (IPv4地址仅使用ut_addr_v6[0]，其他元素会被设置为0 */</span></span><br><span class="line">    <span class="type">char</span> __unused[<span class="number">20</span>];           <span class="comment">/* 保留 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　结构体<code>utmpx</code>的所有字符串成员都是以字符<code>\0</code>结尾，除非它被完全填满。</p>
<p>　　对于登录进程，成员<code>ut_line</code>和<code>ut_id</code>存储的信息源于终端设备的名称。成员<code>ut_line</code>包含终端设备的完整文件名。成员<code>ut_id</code>包含文件名的后缀部分——<code>tty</code>、<code>pts</code>
(System V风格的伪终端) 或<code>pty</code> (BSD风格的伪终端) 后的字符串
(例如，对于终端<code>/dev/tty2</code>，<code>ut_line</code>和<code>ut_id</code>分别是<code>tty2</code>和<code>2</code>)。SUSv3详细说明了这2个成员，但未说明了它们的长度。</p>
<p>　　对于窗口化环境，有些终端模拟器会使用成员<code>ut_session</code>来记录终端窗口的会话ID。</p>
<p>　　SUSv3未说明成员<code>ut_host</code>、<code>ut_exit</code>、<code>ut_session</code>和<code>ut_addr_v6</code>。大多数其他实现都提供了<code>ut_host</code>和<code>ut_exit</code>，部分其他实现提供了<code>ut_session</code>，<code>ut_addr_v6</code>是特定于Linux的。</p>
<p>　　成员<code>ut_type</code>是整数，用于定义写入到文件的记录的类型。该成员可以被指定为以下常量之一
(对应的值在后面的括号中)：</p>
<p>　　● <code>EMPTY</code> (0)：该记录不会包含有效的统计信息。</p>
<p>　　● <code>RUN_LVL</code>
(1)：该记录表示系统在启动或关闭期间运行级别发生了变化。当定义了宏<code>_GNU_SOURCE</code>后，该常量的定义才会出现在头文件<code>utmpx.h</code>中。</p>
<p>　　● <code>BOOT_TIME</code>
(2)：该记录在字段<code>ut_tv</code>中包含系统引导时间。记录<code>RUN_LVL</code>和<code>BOOT_TIME</code>的写入者通常是进程<code>init</code>。这些记录会被同时记录到文件<code>utmp</code>和<code>wtmp</code>。</p>
<p>　　● <code>NEW_TIME</code>
(3)：该记录在字段<code>ut_tv</code>中包含系统时钟更改后的新时间。</p>
<p>　　● <code>OLD_TIME</code>
(4)：该记录在字段<code>ut_tv</code>中包含系统时钟更改前的旧时间。当NTP等守护进程修改系统时钟时，它会将类型为<code>NEW_TIME</code>和<code>OLD_TIME</code>的记录会被写入到文件<code>utmp</code>和<code>wtmp</code>。</p>
<p>　　● <code>INIT_PROCESS</code>
(5)：该记录是进程<code>init</code>生成的进程
(例如，进程<code>getty</code>) 的记录。</p>
<p>　　● <code>LOGIN_PROCESS</code> (6)：该记录是用户登录的会话组长进程
(例如，进程<code>login</code>) 的记录。</p>
<p>　　● <code>USER_PROCESS</code> (7)：该记录是用户进程的记录
(通常是登录会话)，用户名存储在字段<code>ut_user</code>中。登录会话可能由进程<code>login</code>启动，也可能由提供远程登录的工具
(例如，<code>ftp</code>和<code>ssh</code>) 启动。</p>
<p>　　● <code>DEAD_PROCESS</code> (8)：该记录标识已退出的进程。</p>
<p>　　这里展示这些常量的值是因为很多应用程序都依赖于具有上述数值顺序的常量。在程序<code>agetty</code>的源代码中，可以找到如下检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">utp-&gt;ut_type &gt;= INIT_PROCESS &amp;&amp; utp-&gt;ut_type &lt;= DEAD_PROCESS</span><br></pre></td></tr></table></figure>
<p>　　类型为<code>INIT_PROCESS</code>的记录通常对应<code>getty</code>
(或类似的程序)
的执行。当系统引导时，进程<code>init</code>会为每个终端行和虚拟控制台创建1个子进程，每个子进程会运行程序<code>getty</code>。程序<code>getty</code>会打开终端，提示用户登录名，然后执行<code>login</code>。当成功验证用户和执行其他步骤后，<code>login</code>会创建1个子进程来执行用户的登录shell。这种登录会话的完整生命周期由写入到文件<code>wtmp</code>的4条记录表示，顺序如下：</p>
<p>　　●
进程<code>init</code>写入的类型为<code>INIT_PROCESS</code>的记录；</p>
<p>　　●
程序<code>getty</code>写入的类型为<code>LOGIN_PROCESS</code>的记录；</p>
<p>　　●
程序<code>login</code>写入的类型为<code>USER_PROCESS</code>的记录；</p>
<p>　　● <code>init</code>检查到子<code>login</code>进程终止 (用户注销)
时写入的类型为<code>DEAD_PROCESS</code>的记录。</p>
<p>　　某些版本的进程<code>init</code>在更新文件<code>wtmp</code>之前启动程序<code>getty</code>。因此，两者会争相更新文件<code>wtmp</code>，导致类型为<code>INIT_PROCESS</code>和<code>LOGIN_PROCESS</code>的记录的写入顺序可能与这里的顺序相反。</p>
<h3 id="从文件utmp和wtmp中检索信息">40.2
从文件<code>utmp</code>和<code>wtmp</code>中检索信息</h3>
<p>　　本小节介绍的函数会从包含utmpx格式记录的文件中检索记录。这些函数默认会使用文件<code>utmp</code>，但这可以通过函数<code>utmpxname()</code>修改。</p>
<p>　　这些函数使用了<span
style="background-color: yellow">文件中的当前位置</span>
(类似于文件偏移量)
的概念，从该位置检索记录。这些函数都会更新这个位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utmpx.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setutxent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">endutxent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回指向静态分配的结构体utmpx的指针，没有匹配的记录或遇到EOF时返回NULL */</span></span><br><span class="line"><span class="keyword">struct</span> utmpx *<span class="title function_">getutxent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> utmpx *<span class="title function_">getutxid</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> utmpx *ut)</span>;</span><br><span class="line"><span class="keyword">struct</span> utmpx *<span class="title function_">getutxline</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> utmpx *ut)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>setutxent()</code>会将当前位置重置到文件开头。通常，在检索记录前应该调用该函数。这可以防止调用的第三方函数之前调用过的函数<code>getutx*()</code>而可能导致的混淆。根据正在执行的任务，可能还需要在程序后续的适当位置再次调用<code>setutxent()</code>。</p>
<p>　　函数<code>setutxent()</code>和<code>getutx*()</code>都会在文件<code>utmp</code>未打开时打开该文件。当不再需要使用该文件时，应该调用函数<code>endutxent()</code>来关闭它。</p>
<p>　　函数<code>getutxent()</code>、<code>getutxid()</code>和<code>getutxline()</code>会从文件<code>utmp</code>读取记录并返回指向静态分配的结构体<code>utmpx</code>的指针。</p>
<p>　　函数<code>getutxent()</code>会从文件<code>utmp</code>中按序检索下一条记录。</p>
<p>　　函数<code>getutxid()</code>会根据参数<code>ut</code>指向的结构体<code>utmpx</code>的成员<code>ut_type</code>和<code>ut_id</code>从文件<code>utmp</code>中检索记录：</p>
<p>　　●
若成员<code>ut_type</code>是<code>RUN_LVL</code>、<code>BOOT_TIME</code>、<code>NEW_TIME</code>或<code>OLD_TIME</code>，则<code>getutxid()</code>会搜索字段<code>ut_type</code>匹配指定值的下一条记录
(这些类型的记录与用户登录无关)。这允许搜索系统时间修改和运行级别修改的记录。</p>
<p>　　●
若成员<code>ut_type</code>是<code>INIT_PROCESS</code>、<code>LOGIN_PROCESS</code>、<code>USER_PROCESS</code>或<code>DEAD_PROCESS</code>，则<code>getutxid()</code>会搜索字段<code>ut_type</code>匹配这些值中的任意1个且字段<code>ut_id</code>匹配参数<code>ut</code>中的指定值的下一条记录。这允许搜索与特定终端对应的记录。</p>
<p>　　函数<code>getutxline()</code>会从文件<code>utmp</code>中检索字段<code>ut_type</code>为<code>LOGIN_PROCESS</code>或<code>USER_PROCESS</code>且字段<code>ut_line</code>匹配参数<code>ut</code>中的指定值的下一条记录。这对查找与用户登录对应的记录很有用。</p>
<p>　　函数<code>getutxid()</code>和<code>getutxline()</code>在搜索失败
(在未找到记录之前遇到EOF) 时会返回<code>NULL</code>。</p>
<p>　　对于有些UNIX实现，<code>getutxid()</code>和<code>getutxline()</code>会将用于返回结构体<code>utmpx</code>的静态区域视为缓存。若这2个函数确定之前的<code>getutx*()</code>调用放入该缓存中的记录与<code>ut</code>中的指定条件匹配，则不会进行文件读取，而是再次返回相同的记录
(SUSv3允许这种行为)。因此，为了防止在循环中调用这2个函数时重复返回同一条记录，必须将该静态区域清零，这可以通过以下代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utmpx</span> *<span class="title">res</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res != <span class="literal">NULL</span>) <span class="comment">/* 若上一次函数调用设置了res */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> utmpx));</span><br><span class="line">&#125;</span><br><span class="line">res = getutxline(&amp;ut);</span><br></pre></td></tr></table></figure>
<p>　　glibc实现不会进行这种缓存，但为了可移植性，还是应该这样做。</p>
<p>　　因为<code>getutx*()</code>会返回指向静态分配的结构体的指针，所以这些函数是不可重入的。glibc提供了传统utmp函数的可重入版本
(<code>getutent_r()</code>、<code>getutid_r()</code>和<code>getutline_r()</code>)，但未提供传统utmp函数的对应utmpx函数的可重入版本
(SUSv3没有说明这些可重入函数)。</p>
<p>　　在默认情况下，所有的<code>getutx*()</code>都作用于文件<code>utmp</code>。若需要使用其他文件
(例如，文件<code>wtmp</code>)，必须先调用函数<code>utmpxname()</code>来指定目标路径名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utmpx.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">utmpxname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>utmpxname()</code>仅记录参数<code>file</code>指定的路径名的副本，它不会打开文件，但会关闭之前由其他调用打开的任何文件。因此，当<code>file</code>是无效路径名时，该函数不会出错。相反，后续调用<code>getutx*()</code>会出错
(<code>ENOENT</code>)。</p>
<p>　　尽管SUSv3未说明<code>utmpxname()</code>，但大多数UNIX实现都提供了该函数或类似的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dump_utmpx.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utmpx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;paths.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utmpx</span> *<span class="title">ut</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [utmp-pathname]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) <span class="comment">/* 若指定了路径名，则使用该路径名 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (utmpxname(argv[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;utmpxname&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setutxent();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user     type        PID line   id  host      date/time\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((ut = getutxent()) != <span class="literal">NULL</span>) <span class="comment">/* 按序读取记录，直到遇到EOF */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8s &quot;</span>, ut-&gt;ut_user);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-9.9s &quot;</span>,</span><br><span class="line">               (ut-&gt;ut_type == EMPTY) ? <span class="string">&quot;EMPTY&quot;</span> : (ut-&gt;ut_type == RUN_LVL)     ? <span class="string">&quot;RUN_LVL&quot;</span></span><br><span class="line">                                              : (ut-&gt;ut_type == BOOT_TIME)     ? <span class="string">&quot;BOOT_TIME&quot;</span></span><br><span class="line">                                              : (ut-&gt;ut_type == NEW_TIME)      ? <span class="string">&quot;NEW_TIME&quot;</span></span><br><span class="line">                                              : (ut-&gt;ut_type == OLD_TIME)      ? <span class="string">&quot;OLD_TIME&quot;</span></span><br><span class="line">                                              : (ut-&gt;ut_type == INIT_PROCESS)  ? <span class="string">&quot;INIT_PR&quot;</span></span><br><span class="line">                                              : (ut-&gt;ut_type == LOGIN_PROCESS) ? <span class="string">&quot;LOGIN_PR&quot;</span></span><br><span class="line">                                              : (ut-&gt;ut_type == USER_PROCESS)  ? <span class="string">&quot;USER_PR&quot;</span></span><br><span class="line">                                              : (ut-&gt;ut_type == DEAD_PROCESS)  ? <span class="string">&quot;DEAD_PR&quot;</span></span><br><span class="line">                                                                               : <span class="string">&quot;???&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5ld %-6.6s %-3.5s %-9.9s &quot;</span>, (<span class="type">long</span>)ut-&gt;ut_pid,</span><br><span class="line">               ut-&gt;ut_line, ut-&gt;ut_id, ut-&gt;ut_host);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ctime((<span class="type">time_t</span> *)&amp;(ut-&gt;ut_tv.tv_sec)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    endutxent();</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会通过部分上述函数来显示utmpx格式文件的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./dump_utmpx</span></span><br><span class="line">user     type        PID line   id  host      date/time</span><br><span class="line">LOGIN    LOGIN_PR   1761 tty1   1             Sat Oct 23 09:29:37 2010</span><br><span class="line">LOGIN    LOGIN_PR   1762 tty2   2             Sat Oct 23 09:29:37 2010</span><br><span class="line">lynley   USER_RR   10482 tty3   3             Sat Oct 23 10:19:43 2010</span><br><span class="line">david    USER_RR    9664 tty4   4             Sat Oct 23 10:07:50 2010</span><br><span class="line">liz      USER_RR    1985 tty5   5             Sat Oct 23 10:50:12 2010</span><br><span class="line">mtk      USER_RR   10111 pts/0  /0            Sat Oct 23 09:30:57 2010</span><br></pre></td></tr></table></figure>
<p>　　当没有指定命令行参数时，该程序会显示文件<code>/var/run/utmp</code>的内容。为了简洁，这里省略了大部分输出。字段<code>line</code>为<code>tty1</code>到<code>tty5</code>的记录对应虚拟控制台
(<code>/dev/tty[1-6]</code>)
的登录信息。最后1行记录对应伪终端的<code>xterm</code>会话。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./dump_utmpx /var/log/wtmp</span></span><br><span class="line">user     type        PID line   id  host      date/time</span><br><span class="line">lynley   USER_RR   10482 tty3   3             Sat Oct 23 10:19:43 2010</span><br><span class="line">         DEAD_RR   10482 tty3   3  2.4.20-4G  Sat Oct 23 10:32:54 2010</span><br></pre></td></tr></table></figure>
<p>　　当指定参数<code>/var/log/wtmp</code>时，该程序会显示该文件的内容。当用户登录和注销时，分别会写入1条记录到该文件
(这里也省略了大部分输出)。</p>
<h3 id="getlogin">40.3 <code>getlogin()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getlogin</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 成功时用户名字符串，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>getlogin()</code>会返回在调用进程的控制终端登录的用户的名称。该函数使用的是文件<code>utmp</code>中维护的信息。</p>
<p>　　<code>getlogin()</code>会调用<code>ttyname()</code>来查找与调用进程的标准输入关联的控制终端的名称，然后在文件<code>utmp</code>中搜索字段<code>ut_line</code>与该终端名匹配的记录。若找到，则返回该记录的<code>ut_user</code>。若未找到或出错，则返回<code>NULL</code>并设置<code>error</code>。导致该函数出错的原因之一是进程没有与标准输入关联的终端
(<code>ENOTTY</code>)，这可能是因为该进程是守护进程。另一种可能性是文件<code>utmp</code>中没有记录该终端会话
(例如，某些软件终端模拟器不会在文件<code>utmp</code>中创建条目)。</p>
<p>　　即使用户ID在密码文件中有多个登录名，<code>getlogin()</code>还是能够返回用于在该终端登录的用户名，因为该函数依赖于文件<code>utmp</code>。相比之下，调用<code>getpwuid(getuid())</code>总是从密码文件中检索第1条匹配的记录。</p>
<p>　　SUSv3详细说明了<code>getlogin()</code>的可重入版本<code>getlogin_r()</code>，glibc也提供了该函数。</p>
<p>　　环境变量<code>LOGNAME</code>也能用于获取用户的登录名。但是，该环境变量的值可以被用户修改，所以该环境变量不能安全地标识用户。</p>
<h3 id="更新登录会话的文件utmp和wtmp">40.4
更新登录会话的文件<code>utmp</code>和<code>wtmp</code></h3>
<p>　　当开发创建登录会话的应用程序时，应该按照以下方式更新文件<code>utmp</code>和<code>wtmp</code>：</p>
<p>　　●
当登录时，应该向文件<code>utmp</code>中写入1条记录来表示该用户。应用程序必须检查文件<code>utmp</code>中是否已存在该终端的记录。若存在，则覆盖；否则，在该文件的末尾写入1条新记录。通常，调用<code>pututxline()</code>足以确保这会正确执行。结果记录应该至少包含字段<code>ut_type</code>、<code>ut_user</code>、<code>ut_tv</code>、<code>ut_pid</code>、<code>ut_id</code>和<code>ut_line</code>。字段<code>ut_type</code>应该被设置为<code>USER_PROCESS</code>。字段<code>ut_id</code>应该包含用户登录的设备
(终端和伪终端)
的名称后缀。字段<code>ut_line</code>应该包含登录设备的名称，并删除开头的字符串<code>/dev/</code>。相同的记录也会被写入到文件<code>wtmp</code>的末尾。文件<code>utmp</code>中的记录的唯一标识是终端名
(字段<code>ut_line</code>和<code>ut_id</code>的组合)。</p>
<p>　　●
当注销时，之前向文件<code>utmp</code>中写入的记录应该被删除。这能通过创建1条字段<code>ut_type</code>为<code>DEAD_PROCESS</code>，字段<code>ut_user</code>为空，其他字段与登录时写入的记录相同的记录来完成。该记录会覆盖之前的记录，并且也会被写入到文件<code>wtmp</code>的末尾。</p>
<p>　　若无法在注销时清理文件<code>utmp</code>中的记录
(可能因为程序崩溃)，则下一次重启时进程<code>init</code>会自动将该记录的字段<code>ut_type</code>设置为<code>DEAD_PROCESS</code>，并清空各种其他字段来清理该记录。</p>
<p>　　文件<code>utmp</code>和<code>wtmp</code>通常受到保护，所以更新它们需要特权。函数<code>getlogin()</code>的准确性取决于文件<code>utmp</code>的完整性。出于这个原因和其他原因，文件<code>utmp</code>和<code>wtmp</code>绝不应被设置为允许非特权用户写入。</p>
<p>　　除了通过<code>login</code>、<code>telnet</code>和<code>ssh</code>的登录会被记录在登录统计文件之外，大多数<code>ftp</code>实现也会创建登录统计记录。但是，系统中启动的所有终端窗口是否都会创建登录记录因UNIX实现而异。</p>
<p>　　对于某些终端模拟器程序
(例如，<code>xterm</code>)，命令行选项或其他机制可用于决定程序是否会更新登录统计文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utmpx.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> utmpx *<span class="title function_">pututxline</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> utmpx *ut)</span>; <span class="comment">/* 成功时返回指向更新后的记录的副本的指针，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>pututxline()</code>会将参数<code>ut</code>指向的结构体<code>utmpx</code>对应的记录写入到文件<code>utmp</code>
(或调用<code>utmpxname()</code>指定的文件)。</p>
<p>　　在写入记录之前，<code>pututxline()</code>会先通过<code>getutxid()</code>来搜索待更新的记录。若找到，则更新；否则，向文件的末尾写入1条新记录。在很多情况下，应用程序在调用<code>pututxline()</code>之前会先调用<code>getutx*()</code>来将当前位置设置为目标记录的位置。若<code>pututxline()</code>检查到已经发了这种情况，则不会调用<code>getutxid()</code>。</p>
<p>　　当<code>pututxline()</code>内部调用<code>getutxid()</code>时，该调用不会修改<code>getutx*()</code>用于返回结构体<code>utmpx</code>的静态区域。这也是SUSv3所要求的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utmpx.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updwtmpx</span><span class="params">(<span class="type">char</span> *wtmpx_file, <span class="keyword">struct</span> utmpx *ut)</span>;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>updwtmpx()</code>会将参数<code>ut</code>指向的结构体<code>utmpx</code>对应的记录写入到参数<code>wtmpx_file</code>指定的文件。SUSv3没有说明该函数，并且只有部分UNIX实现提供了该函数。其他实现提供了类似的函数
(例如，<code>login()</code>、<code>logout()</code>和<code>logwtmp()</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* utmpx_login.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utmpx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;paths.h&gt;</span> <span class="comment">/* _PATH_UTMP和_PATH_WTMP的定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utmpx</span> <span class="title">ut</span>;</span></span><br><span class="line">    <span class="type">char</span> *devName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s username [sleep-time]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化文件utmp和wtmp的登录记录 */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ut, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> utmpx));</span><br><span class="line">    ut.ut_type = USER_PROCESS; <span class="comment">/* 用户登录 */</span></span><br><span class="line">    <span class="built_in">strncpy</span>(ut.ut_user, argv[<span class="number">1</span>], <span class="keyword">sizeof</span>(ut.ut_user));</span><br><span class="line">    <span class="keyword">if</span> (time((<span class="type">time_t</span> *)&amp;ut.ut_tv.tv_sec) == <span class="number">-1</span>) <span class="comment">/* 加上当前时间戳 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;time&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ut.ut_pid = getpid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据stdin关联的终端设置ut_line和ut_id (假设终端名为/dev/[pt]t[sy]*) */</span></span><br><span class="line">    devName = ttyname(STDIN_FILENO);</span><br><span class="line">    <span class="keyword">if</span> (devName == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;ttyname&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(devName) &lt;= <span class="number">8</span>) <span class="comment">/* 不应该出现这种情况 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;Terminal name is too short: %s&quot;</span>, devName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strncpy</span>(ut.ut_line, devName + <span class="number">5</span>, <span class="keyword">sizeof</span>(ut.ut_line));</span><br><span class="line">    <span class="built_in">strncpy</span>(ut.ut_id, devName + <span class="number">8</span>, <span class="keyword">sizeof</span>(ut.ut_id));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Creating login entries in utmp and wtmp\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        using pid %ld, line %.*s, id %.*s\n&quot;</span>,</span><br><span class="line">           (<span class="type">long</span>)ut.ut_pid, (<span class="type">int</span>)<span class="keyword">sizeof</span>(ut.ut_line), ut.ut_line,</span><br><span class="line">           (<span class="type">int</span>)<span class="keyword">sizeof</span>(ut.ut_id), ut.ut_id);</span><br><span class="line">    setutxent(); <span class="comment">/* 重置当前位置 */</span></span><br><span class="line">    <span class="keyword">if</span> (pututxline(&amp;ut) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;pututxline&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    updwtmpx(_PATH_WTMP, &amp;ut); <span class="comment">/* 将登录记录写入到文件wtmp的末尾 */</span></span><br><span class="line"></span><br><span class="line">    sleep((argc &gt; <span class="number">2</span>) ? getInt(argv[<span class="number">2</span>], GN_NONNEG, <span class="string">&quot;sleep-time&quot;</span>) : <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模拟注销 (使用之前的ut并进行适当修改) */</span></span><br><span class="line">    ut.ut_type = DEAD_PROCESS;</span><br><span class="line">    time((<span class="type">time_t</span> *)&amp;ut.ut_tv.tv_sec);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ut.ut_user, <span class="number">0</span>, <span class="keyword">sizeof</span>(ut.ut_user)); <span class="comment">/* 注销记录的用户名为空 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Creating logout entries in utmp and wtmp\n&quot;</span>);</span><br><span class="line">    setutxent();</span><br><span class="line">    <span class="keyword">if</span> (pututxline(&amp;ut) == <span class="literal">NULL</span>) <span class="comment">/* 覆盖之前的记录 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;pututxline&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    updwtmpx(_PATH_WTMP, &amp;ut); <span class="comment">/* 将注销记录写入到文件wtmp的末尾 */</span></span><br><span class="line"></span><br><span class="line">    endutxent();</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例会使用上述函数来更新文件<code>utmp</code>和<code>wtmp</code>。该程序会对这2个文件执行必要的更新，以便登录命令行参数指定的用户，然后休眠并注销。这种行为通常与用户的登录会话创建与终止相关。该程序会使用<code>ttyname()</code>来检索与文件描述符关联的终端设备的名称。</p>
<h3 id="文件lastlog">40.5 文件<code>lastlog</code></h3>
<p>　　文件<code>lastlog</code>记录了每个用户上一次登录的时间。该文件的作用之一是允许登录程序在用户开始新登录会话时告知它们上一次登录的时间。除了更新文件<code>utmp</code>和<code>wtmp</code>之外，提供登录服务的应用程序也应该更新该文件。</p>
<p>　　与文件<code>utmp</code>和<code>wtmp</code>相同，文件<code>lastlog</code>的位置和格式在各个实现之间也存在差异
(有些UNIX实现未提供该文件)。对于Linux，该文件的位置是<code>/var/log/lastlog</code>，并且头文件<code>paths.h</code>中定义的常量<code>_PATH_LASTLOG</code>指向该位置。与文件<code>utmp</code>和<code>wtmp</code>类似，文件<code>lastlog</code>通常受到保护，所以只有特权进程才能更新该文件
(所有进程都能读该文件)。</p>
<p>　　文件<code>lastlog</code>中的记录对应的结构体<code>lastlog</code>被定义在头文件<code>lastlog.h</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UT_NAMESIZE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UT_HOSTSIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lastlog</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">time_t</span> ll_time;            <span class="comment">/* 上一次登录的时间 */</span></span><br><span class="line">    <span class="type">char</span> ll_line[UT_NAMESIZE]; <span class="comment">/* 远程登录的终端 */</span></span><br><span class="line">    <span class="type">char</span> ll_host[UT_HOSTSIZE]; <span class="comment">/* 远程登录的主机名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　文件<code>lastlog</code>中的记录不包含用户名或用户ID。相反，该文件由一系列按用户ID索引的记录组成。因此，为了查找用户ID为1000的记录，需要寻找该文件的字节<code>(1000 * sizeof(struct lastlog))</code>。这也会导致无法区分同一用户ID的不同用户名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* view_lastlog.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lastlog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;paths.h&gt;</span> <span class="comment">/* _PATH_LASTLOG的定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span> <span class="comment">/* userIdFromName()的定义 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lastlog</span> <span class="title">llog</span>;</span></span><br><span class="line">    <span class="type">int</span> fd, j;</span><br><span class="line">    <span class="type">uid_t</span> uid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [username...]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(_PATH_LASTLOG, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        uid = userIdFromName(argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (uid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No such user: %s\n&quot;</span>, argv[j]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lseek(fd, uid * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> lastlog), SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read(fd, &amp;llog, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> lastlog)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read failed for %s\n&quot;</span>, argv[j]); <span class="comment">/* 遇到EOF或出错 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8.8s %-6.6s %-20.20s %s\n&quot;</span>, argv[j], llog.ll_line,</span><br><span class="line">               llog.ll_host, ctime((<span class="type">time_t</span> *)&amp;llog.ll_time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何在文件<code>lastlog</code>中查找指定用户的记录。该程序提供了与命令<code>lastlog</code>类似的功能。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第43章 进程间通信简介</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_43/</url>
    <content><![CDATA[<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_43/a_taxonomy_of_unix_ipc_facilities.svg" class="">
<p>　　<strong>进程间通信</strong> (IPC) 工具按功能可分为3类：<span
style="background-color: yellow">通信</span>、<span
style="background-color: yellow">同步</span>和<span
style="background-color: yellow">信号</span>。如上图所示，存在多个类似的IPC工具，这主要有2个原因：</p>
<p>　　●
类似的IPC工具在不同的UNIX变体上发展起来，后来又被移植到其他UNIX系统。</p>
<p>　　●
为了解决早期类似的IPC工具的设计缺陷，人们设计了新的IPC工具。</p>
<span id="more"></span>
<h3 id="通信工具">43.1 通信工具</h3>
<p>　　通信工具可以分为2类：<span
style="background-color: yellow">数据传输工具</span>和<span
style="background-color: yellow">共享内存</span>。</p>
<p>　　●
区分数据传输工具的关键因素是写入和读取的概念。为了进行通信，进程A向IPC工具写入数据，而进程B读取数据。这些工具需要在用户内存和内核内存之间进行2次数据传输：写入时从用户内存传输数据到内核内存以及读取时从内核内存传输数据到用户内存。</p>
<p>　　● 共享内存允许进程将信息放在进程之间共享的内存区域来进行交换
(内核通过使所有进程的页表条目都指向同一内存页来实现这一点)。进程可以通过将数据放入共享内存区域来使其他进程访问这些数据。因为通信不需要系统调用或在用户内存与内核内存之间传输数据，所以共享内存能够提供非常快速的通信。</p>
<h4 id="数据传输">43.1.1 数据传输</h4>
<p>　　数据传输工具可以进一步分为3类：<span
style="background-color: yellow">字节流</span>、<span
style="background-color: yellow">消息</span>和<span
style="background-color: yellow">伪终端</span>。</p>
<p>　　●
通过有名管道、无名管道和数据报套接字交换的数据是无分隔符的字节流。每次读取操作可以从IPC工具中读取任意数量的字节
(无需考虑写入者写入的数据块大小)。该模型与UNIX传统的 "文件即字节序列"
模型类似。</p>
<p>　　● 通过System
V消息队列、POSIX消息队列和数据报套接字交换的数据是无分隔符的消息。每次读取操作会读取整条消息，每次写入操作会写入整条消息。无法仅读取消息的一部分
(而将剩余部分留在IPC工具)，也无法单次读取多条消息。</p>
<p>　　● 伪终端是用于特殊情况的通信工具。</p>
<p>　　尽管数据传输工具可以存在多个读取者，但读取操作会消耗数据
(数据将无法供其他进程使用)。</p>
<p>　　读取进程和写入进程之间的同步是自动的。若读取进程试图从当前没有数据的数据传送工具中获取数据，则读取操作默认会被阻塞，直到有进程向该工具中写入数据。</p>
<h4 id="共享内存">43.1.2 共享内存</h4>
<p>　　大部分现代UNIX系统支持3种共享内存：System
V共享内存、POSIX共享内存和内存映射。</p>
<p>　　尽管共享内存提供了快速的通信，但这种速度优势会被需要对共享内存进行同步操作的需求抵消
(例如，进程不应该在其他进程正在更新的内存中的数据结构时试图访问它)。信号量通常用于共享内存同步。</p>
<p>　　共享内存中的数据对共享该内存的所有进程都可见
(这与数据传输工具的破坏性读取语义形成对比)。</p>
<h3 id="同步工具">43.2 同步工具</h3>
<p>　　同步工具允许进程协调其操作。UNIX系统提供了3种同步工具：<span
style="background-color: yellow">信号量</span>、<span
style="background-color: yellow">文件锁</span>以及<span
style="background-color: yellow">互斥锁和条件变量</span>。</p>
<p>　　●
信号量是内核维护的1个整数，其值永远不会小于0。进程可以加减信号量。若试图将信号量的值减少至小于0，则内核会阻塞该操作，直到信号量的值增加至允许操作的值
(或者，进程可以请求非阻塞操作，内核不会阻塞该操作，而是使其立即返回表示该操作无法立即执行的错误信息)。信号量的含义由应用程序决定。进程通过递减信号量来保留对某些共享资源的独占访问权，并在完成相关操作后递增信号量来释放共享资源。二进制信号量
(其值仅为0或1)
的使用很常见。但是，处理多个共享资源实例的应用程序会使用最大值等于共享资源数量的信号量。Linux提供了System
V信号量和POSIX信号量，两者的功能基本相同。</p>
<p>　　●
文件锁是用于协调多个进程对同一文件的操作的同步方法，也能用于协调对其他资源的访问。文件锁分为2类：读取
(共享) 锁和写入 (独占) 锁。任意数量的进程都能持有文件 (或文件区域)
的读取锁。但是，当某个进程持有文件 (或文件区域)
的写入锁时，其他进程将无法获取该文件 (或文件区域)
的读取或写入锁。Linux通过系统调用<code>flock()</code>和<code>fcntl()</code>提供文件锁。系统调用<code>flocK()</code>提供了简单的上锁机制，允许进程对整个文件设置共享或独占锁。由于该系统调用的功能有限，如今很少使用。系统调用<code>fcntl()</code>提供了记录锁，允许进程对文件的不同区域设置多个读取和写入锁。</p>
<p>　　● 互斥锁和条件变量通常与POSIX一起使用
(对于部分UNIX实现和使用提供NPTL线程实现的glibc的Linux系统，进程之间可以共享互斥锁和条件变量。SUSv3允许但不要求实现支持共享的互斥锁和条件变量)。</p>
<p>　　从内核2.6.22开始，Linux通过系统调用<code>eventfd()</code>提供了额外的非标准同步机制。该系统调用会创建eventfd对象
(该对象具有由内核维护的8字节无符号整数值)，然后返回引用该对象的文件描述符。向该文件描述符写入整数会设置对应对象的值。当对象值为0时，对文件描述符进行<code>read()</code>会被阻塞。若对象值非0，则<code>read()</code>会返回该值并将其重置为0。<code>poll()</code>、<code>select()</code>和<code>epoll()</code>可用于判断eventfd对象的值是否非0，若是，则文件描述符指示为可读。使用eventfd对象进行同步的应用程序必须先使用<code>eventfd()</code>创建该对象，然后调用<code>fork()</code>创建继承引用该对象的文件描述符的相关进程。</p>
<h3 id="比较ipc工具">43.3 比较IPC工具</h3>
<p>　　为了访问IPC对象，进程必须使用某种方法来标识该对象。当后续 "打开"
该对象时，进程必须使用某种类型的句柄来引用打开的对象。下表总结了用于各种IPC工具的这些属性：</p>
<table>
<thead>
<tr>
<th>工具类型</th>
<th>用于标识对象的名称</th>
<th>用于在程序中引用对象的句柄</th>
</tr>
</thead>
<tbody>
<tr>
<td>无名管道</td>
<td></td>
<td>文件描述符</td>
</tr>
<tr>
<td>有名管道</td>
<td>路径名</td>
<td>文件描述符</td>
</tr>
<tr>
<td>UNIX域套接字</td>
<td>路径名</td>
<td>文件描述符</td>
</tr>
<tr>
<td>互联网域套接字</td>
<td>IP地址 + 端口号</td>
<td>文件描述符</td>
</tr>
<tr>
<td>System V消息队列</td>
<td>System V IPC键</td>
<td>System V IPC标识符</td>
</tr>
<tr>
<td>System V信号量</td>
<td>System V IPC键</td>
<td>System V IPC标识符</td>
</tr>
<tr>
<td>System V共享内存</td>
<td>System V IPC键</td>
<td>System V IPC标识符</td>
</tr>
<tr>
<td>POSIX消息队列</td>
<td>POSIX IPC路径名</td>
<td><code>mqd_t</code> (消息队列描述符)</td>
</tr>
<tr>
<td>POSIX有名信号量</td>
<td>POSIX IPC路径名</td>
<td><code>sem_t *</code> (信号量指针)</td>
</tr>
<tr>
<td>POSIX无名信号量</td>
<td></td>
<td><code>sem_t *</code> (信号量指针)</td>
</tr>
<tr>
<td>POSIX共享内存</td>
<td>POSIX IPC路径名</td>
<td>文件描述符</td>
</tr>
<tr>
<td>匿名映射</td>
<td></td>
<td></td>
</tr>
<tr>
<td>内存映射文件</td>
<td>路径名</td>
<td>文件描述符</td>
</tr>
<tr>
<td>文件锁</td>
<td>路径名</td>
<td>文件描述符</td>
</tr>
<tr>
<td>记录锁</td>
<td>路径名</td>
<td>文件描述符</td>
</tr>
</tbody>
</table>
<p>　　套接字允许进程通过网络通信。套接字通常用于UNIX域
(允许同一系统的进程之间进行通信) 或互联网域
(允许通过TCP/IP网络连接的不同主机的进程之间进行通信)。通常只需要进行少量修改即可将使用UNIX域套接字的程序转换为使用互联网域套接字的程序。因此，使用UNIX域套接字构建的应用程序可以轻松地实现网络通信功能。</p>
<p>　　POSIX IPC工具 (消息队列、信号量和共享内存)
的普及程度远不及对应的System IPC工具，尤其是在较旧的UNIX系统上
(POSIX消息队列的实现和POSIX信号量的完全支持直至Linux
2.6.x内核才出现)。因此，从可移植角度，System V IPC优于POSIX IPC。</p>
<h4 id="功能">43.3.1 功能</h4>
<p>　　各种IPC工具之间存在功能差异，这些差异在决定使用哪种工具时可能至关重要。数据传输工具和共享内存之间的差异如下：</p>
<p>　　●
文件传输工具涉及读写操作，传输的数据只能由1个读取进程使用。写入者和读取者之间的流量控制以及同步
(例如，当读取者试图从当前为空的存储单元读取数据时会被阻塞)
均有内核自动处理。这种模型与很多应用程序设计非常契合。</p>
<p>　　●
其他应用程序设计则更适合共享内存模型。共享内存允许进程使数据对共享同一区域的任意数量的其他进程可见。通信操作很简单——进程可以像访问其虚拟地址空间中的任何其他内存一样访问共享内存中的数据。另一方面，需要处理同步
(可能还有流量控制)
会增加共享内存设计的复杂性。这种模型非常适合那些需要维护共享状态
(例如，共享数据结构) 的应用程序设计。</p>
<p>　　关于各种数据传输工具，以下几点值得注意：</p>
<p>　　●
有些数据传输工具以字节流传输数据，其他数据传输工具则以消息传输数据。使用哪种方法取决于具体应用程序
(应用程序还可以通过使用分隔符、固定长度消息或编码消息总长度的消息首部来将以消息传输数据的模型应用于字节流机制)。</p>
<p>　　● 与其他数据传输工具相比，System
V和POSIX消息队列的显著特性之一是可以为消息分配数字类型或优先级，从而使消息能够以与发送顺序不同的顺序进行传输。</p>
<p>　　●
无名管道、有名管道和套接字是通过文件描述符实现的。它们都支持多个替代I/O模型：I/O多路复用
(系统调用<code>select()</code>和<code>poll()</code>)、信号驱动I/O以及特定于Linux的epoll
API。这些技术的主要优点是允许应用程序同时监控多个文件描述符来查看是否可以对其中任何1个进行I/O。相比之下，System
V消息队列不使用文件描述符，也不支持这些技术。对于Linux，POSIX消息队列是使用文件描述符实现的，并且支持这些技术。但是，SUSv3没有说明这种行为，而且大部分UNIX实现也不支持这种行为。</p>
<p>　　●
POSIX消息队列可以在消息到达空队列时向进程发送信号或创建新线程。</p>
<p>　　●
UNIX域套接字允许在进程之间传递文件描述符。这使得进程可以打开文件并使其可供其他可能无法访问该文件的进程使用。</p>
<p>　　● UDP套接字允许发送端将消息广播或多播到多个接收端。</p>
<p>　　关于各种进程同步工具，以下几点值得注意：</p>
<p>　　●
记录锁的所有者是设置该锁的进程。内核使用这种所有权来检测死锁。若发生死锁，则内核会拒绝其中某个进程的锁请求，并通过该系统调用返回相应的错误。System
V和POSIX信号量没有所有权属性，并且信号量不会进行死锁检测。</p>
<p>　　● 记录锁会在持有该锁的进程终止时自动被释放。System V信号量通过
"撤销"
功能提供了类似的特性，但该特性并非在所有情况下都可靠。POSIX信号量没有提供类似的功能。</p>
<h4 id="system-v-ipc设计问题">43.3.2 System V IPC设计问题</h4>
<p>　　System IPC工具的设计独立于传统的UNIX
I/O模型，所以存在若干个会使其编程接口的使用更复杂的特殊情况。对应的POSIX工具旨在解决这些问题。以下几点值得注意：</p>
<p>　　● System V
IPC工具是无连接的。这些工具没有提供用于引用打开的IPC对象的句柄
(类似于文件描述符) 的概念。内核不会为进程记录 "打开的对象"
(与其他IPC对象不同)。这表示内核无法维护当前正在使用对象的进程数的引用计数。因此，应用程序可能需要额外的编程工作来确定何时可以安全删除对象。</p>
<p>　　● System V IPC工具的编程接口与传统UNIX I/O模型不一致
(它们使用整数键值和IPC标识符，而非路径名和文件描述符)。这些编程接口也相当复杂，尤其是System
V信号量。</p>
<p>　　相比之下，内核会为POSIX
IPC对象的打开引用计数。这简化了何时可以删除对象的决策。此外，POSIX
IPC工具提供了更简洁且与传统UNIX模型更一致的接口。</p>
<h4 id="可访问性和持久性">43.3.3 可访问性和持久性</h4>
<p>　　术语<strong>持久性</strong>表示IPC对象的生命周期。持久性分为<span
style="background-color: yellow">进程持久性</span>、<span
style="background-color: yellow">内核持久性</span>和<span
style="background-color: yellow">文件系统持久性</span>。</p>
<p>　　●
进程持久的IPC对象仅在至少有1个进程保持打开状态时存在。若所有进程都关闭了该对象，则与该对象相关的所有内核资源都会被释放，任何未读取的数据也会被销毁。</p>
<p>　　● 内核持久的IPC对象会一直存在，直到它被显式删除或系统关闭。</p>
<p>　　●
文件系统持久的IPC对象即使在系统重启后也能保留其信息。这种对象会一直存在，直到被显式删除。</p>
<p>　　下表列出了各种IPC工具的可访问性和持久性：</p>
<table>
<thead>
<tr>
<th>工具类型</th>
<th>可访问性</th>
<th>持久性</th>
</tr>
</thead>
<tbody>
<tr>
<td>无名管道</td>
<td>只能被关联的进程访问</td>
<td>进程</td>
</tr>
<tr>
<td>有名管道</td>
<td>权限掩码</td>
<td>进程</td>
</tr>
<tr>
<td>UNIX域套接字</td>
<td>权限掩码</td>
<td>进程</td>
</tr>
<tr>
<td>互联网域套接字</td>
<td>可以被任何进程访问</td>
<td>进程</td>
</tr>
<tr>
<td>System V消息队列</td>
<td>权限掩码</td>
<td>进程</td>
</tr>
<tr>
<td>System V信号量</td>
<td>权限掩码</td>
<td>进程</td>
</tr>
<tr>
<td>System V共享内存</td>
<td>权限掩码</td>
<td>进程</td>
</tr>
<tr>
<td>POSIX消息队列</td>
<td>权限掩码</td>
<td>进程</td>
</tr>
<tr>
<td>POSIX有名信号量</td>
<td>权限掩码</td>
<td>进程</td>
</tr>
<tr>
<td>POSIX无名信号量</td>
<td>底层内存的权限</td>
<td></td>
</tr>
<tr>
<td>POSIX共享内存</td>
<td>权限掩码</td>
<td>进程</td>
</tr>
<tr>
<td>匿名映射</td>
<td>只能被关联的进程访问</td>
<td>进程</td>
</tr>
<tr>
<td>内存映射文件</td>
<td>权限掩码</td>
<td>文件系统</td>
</tr>
<tr>
<td>记录锁</td>
<td>对文件调用<code>open()</code></td>
<td>进程</td>
</tr>
<tr>
<td>文件锁</td>
<td>对文件调用<code>open()</code></td>
<td>进程</td>
</tr>
</tbody>
</table>
<p>　　对于有名管道和套接字等IPC工具，对象名称被存储在于文件系统中，其访问权限由关联的文件权限掩码决定
(见15.4)。尽管System
IPC对象不会被存储在文件系统中，但每个对象都有关联的权限掩码，其语义与文件权限掩码类似。</p>
<p>　　无名管道、匿名映射等IPC工具只能被关联的进程访问。这里的 "关联"
是指通过函数<code>fork()</code>建立的关联。为了使2个进程能够访问同一对象，其中的1个进程必须创建对象，然后调用<code>fork()</code>，子进程会继承引用该对象的句柄，从而允许这2个进程共享该对象。</p>
<p>　　POSIX无名信号量的可访问性由其所在的共享内存区域的可访问性决定。</p>
<p>　　为了对文件加锁，进程必须拥有引用该文件的文件描述符
(即必须有打开文件的权限)。</p>
<p>　　访问 (即连接或向其发生数据报)
互联网域套接字没有任何限制。如有必要，必须在应用程序内部实现访问控制。</p>
<h4 id="性能">43.3.4 性能</h4>
<p>　　在某些情况下，不同IPC工具可能存在显著的性能差异。但是，后续内容几乎不会进行性能比较，原因如下：</p>
<p>　　●
IPC工具的性能可能不是应用程序整体性能的重要因素，也不可能是决定选择IPC工具的唯一因素。</p>
<p>　　● 各种IPC工具的相对性能可能因UNIX实现或Linux内核版本而异。</p>
<p>　　●
IPC工具的性能会因其使用方式和环境而异。相关因素包括每次IPC操作中交换的数据单元的大小、IPC工具上可能存在的未读数据量、每次交换数据单元是否需要进行进程上下文切换以及系统的其他负载。</p>
<p>　　若IPC性能至关重要，则在与目标系统环境相匹配的环境下运行特定于应用程序的基准测试是无可替代的。为此，可以可虑编写抽象软件层，将IPC工具的细节对应用程序隐藏起来，然后在抽象层下替换不同的IPC工具来测试其性能。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第42章 共享库高级特性</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_42/</url>
    <content><![CDATA[<p>　　出于测试目的，有时可以有选择地覆盖动态链接器基于41.8中的规则通常会找到的函数
(或其他符号)。为此，可以将环境变量<code>LD_PRELOAD</code>定义为由空格或冒号<code>:</code>分隔的共享库名组成的字符串，这些共享库会在其他共享库之前被加载
(这些共享库定义的所有函数都会在可执行文件需要时自动被使用，从而覆盖动态链接器本来可能搜索的同名其他函数)。</p>
<p>　　假设程序<code>prog</code>会调用函数<code>x1()</code>和<code>x2()</code>，这2个函数被定义在位于标准目录的共享库<code>libdemo.so</code>中。当运行该程序时，会得到以下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./prog</span></span><br><span class="line">Called mod1-x1 DEMO</span><br><span class="line">Called mod2-x2 DEMO</span><br></pre></td></tr></table></figure>
<p>　　这里可以通过创建共享库<code>libalt.so</code>来覆盖函数<code>x1()</code>，该共享库包含<code>x1()</code>的不同定义。当运行程序时，预加载该库会得到以下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_PRELOAD=libalt.so ./prog</span></span><br><span class="line">Called mod1-x1 ALT</span><br><span class="line">Called mod2-x2 DEMO</span><br></pre></td></tr></table></figure>
<p>　　根据结果可知，程序调用的是<code>libalt.so</code>中的<code>x1()</code>定义和<code>libdemo.so</code>中的<code>x2()</code>定义，因为<code>libalt.so</code>中未定义<code>x2()</code>。</p>
<p>　　环境变量<code>LD_PRELOAD</code>用于控制进程级预加载，而文件<code>/etc/ld.so.preload</code>
(其中的共享库由空格分隔)
用于控制系统级预加载。环境变量<code>LD_PRELOAD</code>指定的库在文件<code>/etc/ld.so.preload</code>指定的库之前被加载。</p>
<p>　　出于安全原因，set-user-ID和set-group-ID程序会忽略环境变量<code>LD_PRELOAD</code>。</p>
<span id="more"></span>
<h3 id="动态加载库">42.1 动态加载库</h3>
<p>　　当启动可执行文件时，动态链接器会加载程序动态依赖列表中的所有共享库。有时，延迟加载共享库可能很有用
(例如，仅在需要时加载插件)。该功能由称为<span
style="background-color: yellow">dlopen</span>的动态加载器API提供。该API源于Solaris，其中的大部分内容都已被SUSv3标准化。该API的核心函数包括<code>dlopen()</code>、<code>dlsym()</code>、<code>dlclose()</code>和<code>dlerror()</code>。对于Linux，为了构建使用该API的程序，必须指定选项<code>-ldl</code>来链接库<code>libdl</code>。</p>
<p>　　dlopen
API允许程序在运行时打开共享库并按照名称在该库中搜索函数，然后调用该函数。以这种方式在运行时被加载的共享库通常称为<strong>动态加载库</strong>，其创建方式与常规共享库相同。</p>
<h4 id="dlopen">42.1.1 <code>dlopen()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *libfilename, <span class="type">int</span> flags)</span>; <span class="comment">/* 成功时返回库句柄，出错时返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>dlopen()</code>会将名为<code>libfilename</code>的共享库加载到调用进程的虚拟地址空间并增加该库的打开引用计数。</p>
<p>　　若参数<code>libfilename</code>包含斜杠<code>/</code>，则<code>dlopen()</code>会将其解释为路径名；否则，动态链接器会按照41.8中的规则搜索共享库。若目标共享库依赖于其他共享库，则该函数会自动加载这些库。该过程会在必要时递归执行，这些加载库的集合称为该库的<span
style="background-color: yellow">依赖树</span>。</p>
<p>　　若<code>dlopen()</code>找到目标库，则返回可以在后续调用dlopen
API中的其他函数时引用该库的句柄。若该函数出错
(例如，未找到共享库)，则返回<code>NULL</code>。</p>
<p>　　可以对同一库文件多次调用<code>dlopen()</code>。该库只会被加载1次
(第1次调用)，并且所有调用都会同一句柄值。但是，dlopen
API为每个库句柄维护了引用计数。当调用<code>dlopen()</code>时，会增加引用计数；当调用<code>dlclose()</code>时，会减少引用计数。当且仅当引用计数为0时，<code>dlclose()</code>才会将库从内存中卸载。</p>
<p>　　参数<code>flags</code>是位掩码，必须正好包含标志<code>RTLD_LAZY</code>和<code>RTLD_NOW</code>之一。</p>
<p>　　●
标志<code>RTLD_LAZY</code>表示库中未定义的函数符号应该只在代码执行时才被解析。若需要某符号的代码段不会被执行，则该符号永远不会被解析。延迟加载仅适用于函数引用，变量引用总是立即被解析。指定该标志会提供与动态链接器在加载可执行文件动态依赖列表指定的共享库时的正常操作相对应的行为。</p>
<p>　　●
标志<code>RTLD_NOW</code>表示库中未定义的符号都应该在<code>dlopen()</code>完成之前立即被解析。因此，打开库会更慢，但所有潜在的未定义的函数符号错误都会立即被检测到，而非在后续的某个时间被检测到。对于调试应用程序或为了确保应用程序遇到未解析的符号时立即失败，这很有用。</p>
<p>　　参数<code>flags</code>还可以包含很多标志，SUSv3说明的标志如下：</p>
<p>　　●
标志<code>RTLD_GLOBAL</code>表示库以及其依赖树中的符号可用于解析该进程加载的其他库中的引用以及通过<code>dlsym()</code>进行搜索。</p>
<p>　　●
标志<code>RTLD_LOCAL</code>与<code>RTLD_GLOBAL</code>相反，即库以及其依赖树中的符号无法用于解析该进程加载的其他库中的引用。</p>
<p>　　SUSv3没有说明未指定这2个标志时的默认标志。Linux和大部分UNIX实现默认使用标志<code>RTLD_LOCAL</code>，而少部分UNIX实现默认使用标志<code>RTLD_GLOBAL</code>。</p>
<p>　　Linus还支持很多SUSv3未说明的标志：</p>
<p>　　●
标志<code>RTLD_NODELETE</code>表示即使引用计数为0，函数<code>dlclose()</code>也不会卸载库。这表示后续通过<code>dlopen()</code>重新加载库时其中的静态变量不会重新初始化
(对于由动态链接器自动加载的库，可以在通过命令<code>gcc</code>创建库时指定选项<code>–Wl,–znodelete</code>来达到类似的效果)。</p>
<p>　　● 标志<code>RTLD_NOLOAD</code> (glibc 2.2及以上版本)
表示不加载库，它有2个用途。首先，该标志可用于检查特定库是否已被加载。若是，则<code>dlopen()</code>返回库句柄；否则，<code>dlopen()</code>返回<code>NULL</code>。其次，该标志可用于
"提升" 已加载库的标志
(例如，在使用<code>dlopen()</code>打开之前使用<code>RTLD_LOCAL</code>打开的库时指定<code>RTLD_NOLOAD | RTLD_GLOBAL</code>)。</p>
<p>　　● 标志<code>RTLD_DEEPBIND</code> (glibc 2.3.4及以上版本)
表示当解析该库引用的符号时，应先在该库搜索定义，然后在已加载的库中搜索定义
(类似于链接器选项<code>–Bsymbolic</code>)。</p>
<p>　　Solaris的dlopen
API也实现了标志<code>RTLD_NODELETE</code>和<code>RTLD_NOLOAD</code>，但只有少部分UNIX提供了这2个标志。标志<code>RTLD_DEEPBIND</code>是特定于Linux的。</p>
<p>　　对于glibc
2.1.1及以上版本，可以将环境变量<code>LD_BIND_NOW</code>设置未非空字符串来确保动态链接器在加载可执行文件的动态依赖列表指定的共享库时立即解析所有符号
(与标志<code>RTLD_NOW</code>类似)，该环境变量会覆盖<code>dlopen()</code>的标志<code>RTLD_LAZY</code>的效果。</p>
<p>　　作为特殊情况，<code>libfilename</code>可以被指定为<code>NULL</code>。这会导致<code>dlopen()</code>返回主程序的句柄
(SUSv3将其称为 "全局符号目标"
的句柄)。若在后续调用<code>dlsym()</code>时指定该句柄，则会先在主程序中搜索目标符号，然后在程序启动时加载的库中搜索，最后在用标志<code>RTLD_GLOBAL</code>动态加载的库中搜索。</p>
<h4 id="dlerror">42.1.2 <code>dlerror()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 上一次调用出错时返回错误诊断字符串，否则返回返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　当dlopen
API函数出错时，可以通过函数<code>dlerror()</code>来获取表示错误原因的字符串。该函数会在上一次调用dlopen
API函数未出错时返回<code>NULL</code>。</p>
<h4 id="dlsym">42.2.3 <code>dlsym()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">char</span> *symbol)</span>; <span class="comment">/* 找到symbol时返回其地址，否则返回NULL */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>dlsym()</code>会在参数<code>handle</code>
(通常是之前调用<code>dlopen()</code>返回的库句柄，有时也可以是<span
style="background-color: yellow">伪句柄</span>)
引用的库及其依赖树中搜索名称<code>symbol</code>
(函数或变量)。若找到，则返回其地址；否则，返回<code>NULL</code>。</p>
<p>　　<code>dlsym()</code>返回的符号的值可能是<code>NULL</code>，这会与未找到符号的情况混淆。为此，必须在调用<code>dlsym()</code>前后都调用<code>dlerror()</code>
(第1次调用<code>dlerror()</code>是为了清空已存储的错误字符串)。若第2次调用<code>dlerror()</code>不返回<code>NULL</code>，则表示<code>dlsym()</code>出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"></span><br><span class="line">ip = (<span class="type">int</span> *)dlsym(symbol, <span class="string">&quot;myvar&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ip != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value is %d\n&quot;</span>, *ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　若<code>symbol</code>是变量名，则可以为<code>dlsym()</code>的返回值分配合适类型的指针并通过解引用来获取该变量的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*funcp)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">*(<span class="type">void</span> **)(&amp;funcp) = dlsym(handle, symbol);</span><br><span class="line">res = (*funcp)(somearg);</span><br></pre></td></tr></table></figure>
<p>　　若<code>symbol</code>是函数名，则<code>dlsym()</code>返回的指针可用于调用该函数。但是，因为C99禁止在函数指针和<code>void *</code>之间赋值，所以需要进行类型转换，然后照常通过函数指针调用函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="type">void</span> *)funcp = dlsym(handle, symbol);</span><br></pre></td></tr></table></figure>
<p>　　这行代码看似更精简，但<code>gcc -pedantic</code>会警告 "ANSI
C禁止将类型转换表达式作为左值"。<code>*(void **)</code>语法不会导致该警告，因为该语法是将值赋值给左值指向的地址。</p>
<p>　　对于很多UNIX实现，可以通过以下类型转换来避免C编译器的这种警告：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">funcp = (<span class="type">int</span> (*)(<span class="type">int</span>))dlsym(handle, symbol);</span><br></pre></td></tr></table></figure>
<p>　　但是，SUSv3 Technical Corrigendum Number
1的<code>dlsym()</code>规范指出，C99仍然要求编译器对这种类型转换生成警告，并建议使用<code>*(void **)</code>语法。</p>
<p>　　SUSv3
TC1指出，因为需要使用<code>*(void **)</code>语法，该标准的未来版本可能会定义用于处理数据指针和函数指针的类似于<code>dlsym()</code>的独立API。但是，SUSv4在这一点上没有进行任何修改。</p>
<p>　　除了库句柄之外，<code>dlsym()</code>的参数<code>handle</code>还可以被指定为伪句柄<code>RTLD_DEFAULT</code>或<code>RTLD_NEXT</code>。</p>
<p>　　●
<code>RTLD_DEFAULT</code>表示先搜索主程序，然后按序遍历所有已加载的共享库，包括那些使用标志<code>RTLD_GLOBAL</code>动态加载的共享库。这对应动态链接器采用的默认搜索模型。</p>
<p>　　●
<code>RTLD_NEXT</code>表示在调用<code>dlsym()</code>之后加载的共享库中搜索符号。这在创建与其他地方定义的函数同名的包装函数时很有用
(例如，在主程序中定义自己的<code>malloc()</code>，该函数会调用<code>func = dlsym(RTLD_NEXT, "malloc"</code>来获取真正的<code>malloc()</code>的地址并调用它)。</p>
<p>　　SUSv3不要求实现提供这2个伪句柄
(尽管SUSV3将其保留以供将来使用)，而且并非所有UNIX实现都提供了这2个伪句柄。为了从头文件<code>dlfcn.h</code>中获取这2个常量的定义，需要定义特性测试宏<code>_GNU_SOURCE</code>。</p>
<p>　　函数<code>dlvsym(handle, symbol, version)</code>类似于<code>dlsym()</code>，但可用于在具有符号版本的库中搜索符号定义，版本由<code>version</code>指定。当定义了特性测试宏<code>_GNU_SOURCE</code>，才能从头文件<code>dlfcn.h</code>中获取其声明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dynload.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *libHandle;     <span class="comment">/* 共享库句柄 */</span></span><br><span class="line">    <span class="type">void</span> (*funcp)(<span class="type">void</span>); <span class="comment">/* 指向无参数的函数的指针 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s lib-path func-name\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 加载共享库并获取其句柄 */</span></span><br><span class="line">    libHandle = dlopen(argv[<span class="number">1</span>], RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (libHandle == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;dlopen: %s&quot;</span>, dlerror());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在共享库中搜索argv[2] */</span></span><br><span class="line">    (<span class="type">void</span>)dlerror(); <span class="comment">/* 清除错误原因字符串 */</span></span><br><span class="line">    *(<span class="type">void</span> **)(&amp;funcp) = dlsym(libHandle, argv[<span class="number">2</span>]);</span><br><span class="line">    err = dlerror();</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;dlsym: %s&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若dlsym()返回的地址不为NULL，则尝试调用它 */</span></span><br><span class="line">    <span class="keyword">if</span> (funcp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is NULL\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        (*funcp)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dlclose(libHandle); <span class="comment">/* 关闭库 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了部分dlopen
API的用法。该程序有2个命令行参数。第1个命令行参数是目标库的名称，第2个命令行参数是该库中的函数的名称。</p>
<h4 id="dlclose">42.2.4 <code>dlclose()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>dlclose()</code>会减少参数<code>handle</code>引用的库的系统级打开引用计数。若该引用计数减少至0，并且其他库不需要该库中的符号，则该库会被卸载。该过程会
(递归地)
对该库依赖树中的所有库执行。当进程终止时，会隐式对所有库都调用<code>dlclose()</code>。</p>
<p>　　从glibc 2.2.3开始，共享库的函数可以使用<code>atexit()</code>
(<code>on_exit()</code>) 来注册卸载库时自动被调用的函数。</p>
<h4 id="dladdr">42.2.5 <code>dladdr()</code></h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dladdr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, Dl_info *info)</span>; <span class="comment">/* 在共享库中找到addr时返回非0值，否则返回0 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dli_fname; <span class="comment">/* 包含addr的共享库的路径名 */</span></span><br><span class="line">    <span class="type">void</span> *dli_fbase;       <span class="comment">/* 共享库加载的基地址 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dli_sname; <span class="comment">/* 地址不大于addr的最近运行时符号 */</span></span><br><span class="line">    <span class="type">void</span> *dli_saddr;       <span class="comment">/* dli_sname返回的符号的实际值 */</span></span><br><span class="line">&#125; Dl_info;</span><br></pre></td></tr></table></figure>
<p>　　函数<code>dladdr()</code>会通过参数<code>info</code>指向的结构体<code>Dl_info</code>
(由调用者分配)
返回参数<code>addr</code>指定的地址的信息。结构体<code>Dl_info</code>的前2个成员分别是包含<code>addr</code>指定的地址的共享库的路径名和运行时基地址，后2个成员是该地址的相关信息。若该地址是共享库中某个符号的精确地址，则成员<code>dli_saddr</code>包含的值与<code>addr</code>指定的值相同。</p>
<p>　　SUSv3没有说明<code>dladdr()</code>，而且并非所有UNIX实现都提供了该函数。</p>
<h4 id="在主程序中访问符号">42.2.6 在主程序中访问符号</h4>
<p>　　假设使用<code>dlopen()</code>动态加载共享库后，使用<code>dlsym()</code>从该库获取函数<code>x()</code>的地址，然后调用该函数。若<code>x()</code>会调用函数<code>y()</code>，则<code>y()</code>通常会在程序加载的共享库中被找到。</p>
<p>　　有时，可能需要<code>x()</code>调用主程序中的<code>y()</code>实现。为此，必须使用链接器选项<code>––export–dynamic</code>来使主程序中的
(全局作用域) 符号可供动态链接器使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Wl,--export-dynamic main.c</span></span><br></pre></td></tr></table></figure>
<p>　　或者，使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -export-dynamic main.c</span></span><br></pre></td></tr></table></figure>
<p>　　这2条命令都会让动态加载库访问主程序中的全局符号。</p>
<p>　　此外，命令<code>gcc</code>的选项<code>-rdynamic</code>和<code>–Wl,–E</code>等同于<code>–Wl,––export–dynamic</code>。</p>
<h3 id="控制符号可见性">42.2 控制符号可见性</h3>
<p>　　设计良好的共享库应该仅公开那些构成其指定ABI一部分的符号
(函数和变量)。原因如下：</p>
<p>　　●
当共享库开发者意外地公开了未指定的接口时，使用该库的应用程序开发者可能会使用该接口。这会为共享库的后续升级带来兼容性问题。库开发者希望能够修改或删除文档中指定的ABI之外的所有接口，而库用户希望继续使用其目前使用的相同接口
(具有相同语义)。</p>
<p>　　●
在运行时符号解析期间，共享库公开的任何符号都可能影响其他共享库提供的定义。</p>
<p>　　● 公共不必要的符号会增加运行时加载的动态符号表的大小。</p>
<p>　　若库开发者能确保仅公开库指定ABI所需的符号，则所有这些问题都可以被最小化或完全避免。可以使用以下方法来控制符号的可见性：</p>
<p>　　●
对于C程序，可以使用关键字<code>static</code>来将符号设置为源代码模块私有，以防止它被其他目标文件绑定
(除了将符号设置为源代码模块私有之外，关键字<code>static</code>还会使该模块中所有对该符号的引用都绑定到该模块中该符号的定义)。</p>
<p>　　●
特定于gcc的属性声明可以提供与关键字<code>static</code>类似的作用
(属性<code>hidden</code>会使符号对构成共享库的所有源代码文件可见，但对库外的文件不可见)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__((visibility(<span class="string">&quot;hidden&quot;</span>))) func(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　●
版本脚本可用于精准控制符号可见性，并选择引用所绑定的符号版本。</p>
<p>　　●
当动态加载共享库时，可以通过<code>dlopen()</code>的标志<code>RTLD_GLOBAL</code>来指定库中定义的符号可供后续加载的库绑定，同时可以使用链接器选项<code>––export–dynamic</code>使主程序的全局符号对动态加载库可见。</p>
<h3 id="链接器版本脚本">42.3 链接器版本脚本</h3>
<p>　　<strong>版本脚本</strong>是包含链接器指令的文本文件。为了使用版本脚本，必须指定链接器选项<code>––version–script</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Wl,--version-script,myscriptfile.map ...</span></span><br></pre></td></tr></table></figure>
<p>　　版本脚本通常由扩展名<code>.map</code>标识。</p>
<h4 id="使用版本脚本控制符号可见性">42.3.1
使用版本脚本控制符号可见性</h4>
<p>　　版本脚本可用于控制符号可见性。假设需要使用源文件<code>vis_comm.c</code>、<code>vis_f1.c</code>和<code>vis_f2.c</code>构建共享库，这3个源文件分别定义了函数<code>vis_comm()</code>、<code>vis_f1()</code>和<code>vis_f2()</code>。函数<code>vis_comm()</code>由<code>vis_f1()</code>和<code>vis_f2()</code>调用，但并非旨在供链接到该库的应用程序直接使用。进一步假设构建该共享库的方式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o</span></span><br></pre></td></tr></table></figure>
<p>　　当使用命令<code>readelf</code>来列出该共享库公开的动态符号时，会得到以下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf --syms --use-dynamic vis.so | grep vis_</span></span><br><span class="line">    30 12: 00000790   59 FUNC    GLOBAL DEFAULT   10 vis_f1</span><br><span class="line">    25 13: 000007d0   73 FUNC    GLOBAL DEFAULT   10 vis_f2</span><br><span class="line">    27 16: 00000770   20 FUNC    GLOBAL DEFAULT   10 vis_comm</span><br></pre></td></tr></table></figure>
<p>　　该共享库公开了符号<code>vis_comm()</code>、<code>vis_f1()</code>和<code>vis_f2()</code>。为了让其仅公共<code>vis_f1()</code>和<code>vis_f2()</code>，可以使用以下版本脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> vis.map</span></span><br><span class="line">VER_1 &#123;</span><br><span class="line">    global:</span><br><span class="line">        vis_f1;</span><br><span class="line">        vis_f2;</span><br><span class="line">    local:</span><br><span class="line">        *; # 隐藏其他所有符号</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　版本脚本可以包含多个<span
style="background-color: yellow">版本节点</span>，所有版本节点都被大括号
(<code>{}</code>) 括起来，并以唯一的<span
style="background-color: yellow">版本标签</span>为前缀。若仅将版本脚本用于控制符号可见性，则版本标签是多余的。但是，较旧的链接器要求必须包含版本标签。现代链接器允许省略版本标签。在这种情况下，版本节点可视为具有匿名版本标签，并且版本脚本中不能包含其他版本节点。</p>
<p>　　在版本节点内，关键字<code>global</code>后的由分号<code>;</code>分隔的符号对外可见，关键字<code>local</code>后的由分号<code>;</code>分隔的符号对外不可见。星号<code>*</code>表示使用通配符模式。版本节点中的通配符与用于shell文件名匹配的通配符相同。此外，版本脚本的注释以<code>#</code>开头。这里的星号<code>*</code>表示除了显式声明为<code>global</code>的符号之外，其他所有符号都会被隐藏。若不使用这种说明，则<code>vis_comm()</code>将对外可见，因为C全局符号默认对共享库外部可见。</p>
<p>　　因此，可以使用以下脚本构建共享库<code>vis.so</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o -Wl,--version-script,vis.map</span></span><br></pre></td></tr></table></figure>
<p>　　当再次使用命令<code>readelf</code>时，符号<code>vis_comm()</code>不再对外可见：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf --syms --use-dynamic vis.so | grep vis_</span></span><br><span class="line">    25  0: 00000730   73 FUNC    GLOBAL DEFAULT   10 vis_f2</span><br><span class="line">    29 16: 000006f0   59 FUNC    GLOBAL DEFAULT   10 vis_f1</span><br></pre></td></tr></table></figure>
<h4 id="符号版本控制">42.3.2 符号版本控制</h4>
<p>　　符号版本控制允许共享库提供同一函数的多个版本。程序使用的是其与共享库静态链接时使用的函数版本。因此，可以在不增加库的主要版本号的情况下进行不兼容的修改。如果符号版本控制运用得当，可以取代传统的共享库的主要和次要版本控制方案。glibc
2.1及以上版本就采用了这种方式，使得从2.0开始的所有glibc版本都可以在单个主要版本
(<code>libc.so.6</code>) 中得到支持。</p>
<p>　　这里将使用简单的示例将展示符号版本控制的用法。首先，使用版本脚本创建共享库的第1个版本
(为了简化示例，这里没有使用库的soname和主要版本号)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sv_lib_v1.c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">void xyz(void) </span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;v1 xyz\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sv_v1.map</span></span><br><span class="line">VER_1 &#123;</span><br><span class="line">    global: xyz;</span><br><span class="line">    local: *;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall sv_lib_v1.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libsv.so sv_lib_v1.o -Wl,--version-script,sv_v1.maps</span></span><br></pre></td></tr></table></figure>
<p>　　此时，版本脚本<code>sv_v1.map</code>仅用于控制符号可见性。然后，创建使用该共享库的程序<code>p1</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sv_prog.c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdlib.h&gt;</span></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    void xyz(void);</span><br><span class="line"></span><br><span class="line">    xyz();</span><br><span class="line"></span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -o p1 sv_prog.c libsv.sos</span></span><br></pre></td></tr></table></figure>
<p>　　当运行该程序时，会得到以下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./p1</span></span><br><span class="line">v1 xyz</span><br></pre></td></tr></table></figure>
<p>　　假设需要修改共享库中的<code>xyz()</code>定义，同时保持程序<code>p1</code>继续使用该函数的旧版本。为此，必须在共享库中定义<code>xyz()</code>的2个版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sv_lib_v2.c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">__asm__(&quot;.symver xyz_old,xyz@VER_1&quot;);</span><br><span class="line">__asm__(&quot;.symver xyz_new,xyz@@VER_2&quot;);</span><br><span class="line"></span><br><span class="line">void xyz_old(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;v1 xyz\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void xyz_new(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;v2 xyz\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pqr(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;v2 pqr\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　<code>xyz()</code>的2个版本由函数<code>xyz_old()</code>和<code>xyz_new()</code>提供。前者对应<code>xyz()</code>的旧定义
(以供程序<code>p1</code>使用)，后者提供<code>xyz()</code>的新定义
(以供链接到该库新版本的程序使用)。</p>
<p>　　汇编指示<code>.symver</code>是将<code>xyz_old()</code>和<code>xyz_new()</code>与用于创建共享库新版本的修改后的版本脚本中的不同版本标签关联起来的纽带。第1个汇编指示表示<code>xyz_old()</code>是用于与版本标签<code>VER_1</code>链接的应用程序的<code>xyz()</code>定义，第2个汇编指示表示<code>xyz_new()</code>是用于与版本标签<code>VER_2</code>链接的应用程序的<code>xyz()</code>定义。此外，第2个汇编指示包含<code>@@</code>，表示该定义是静态链接到该库的应用程序默认使用的<code>xyz()</code>定义。每个符号都应该正好只有1个包含<code>@@</code>的汇编指示<code>.symver</code>。</p>
<p>　　修改后的共享库对应的版本脚本如下
(最后1行表示版本标签<code>VER_2</code>依赖于<code>VER_1</code>)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sv_v2.map</span></span><br><span class="line">VER_1 &#123;</span><br><span class="line">    global: xyz;</span><br><span class="line">    local: *;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VER_2 &#123;</span><br><span class="line">    global: pqr;</span><br><span class="line">&#125; VER_1; # VER_2依赖于VER_1</span><br></pre></td></tr></table></figure>
<p>　　版本标签依赖表示连续库版本之间的关系。从语义角度，Linux版本标签依赖关系唯一的影响是版本节点会从其所依赖的版本节点继承<code>global</code>和<code>local</code>规范。版本标签本身没有含义，它们之间的关系仅由指定的版本依赖关系决定。为了便于维护，建议使用<code>GLIBC_2.1</code>等包含包名和版本号的版本标签。此外，依赖关系可以形成依赖链
(例如，创建依赖于<code>VER_2</code>的版本节点<code>VER_3</code>)。</p>
<p>　　版本标签<code>VER_2</code>也公开了新函数<code>pqr()</code>，并且该函数是绑定该标签的。若不以这种方式声明<code>pqr()</code>，则继承自版本标签<code>VER_1</code>的<code>local</code>规范会使该函数对外不可见。</p>
<p>　　共享库新版本的构建可以照常执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall sv_lib_v2.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libsv.so sv_lib_v2.o -Wl,--version-script,sv_v2.map</span></span><br></pre></td></tr></table></figure>
<p>　　然后，创建使用<code>xyz()</code>新定义的程序<code>p2</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -o p2 sv_prog.c libsv.so</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./p2</span></span><br><span class="line">v2 xyz</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./p1</span></span><br><span class="line">v1 xyz</span><br></pre></td></tr></table></figure>
<p>　　可执行文件的版本标签依赖在静态链接时被记录。可以使用命令<code>objdump –t</code>来显示可执行文件的符号表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -t p1 | grep xyz</span></span><br><span class="line">08048380       F *UND*  0000002e              xyz@@VER_1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -t p2 | grep xyz</span></span><br><span class="line">080483a0       F *UND*  0000002e              xyz@@VER_2</span><br></pre></td></tr></table></figure>
<p>　　命令<code>readelf –s</code>可用于获取类似的信息。</p>
<h3 id="初始化和终止函数">42.4 初始化和终止函数</h3>
<p>　　定义共享库加载和卸载时自动被调用的函数是可能的。这使得开发者能够在在使用共享库时执行初始化和终止操作。无论是自动加载还是使用dlopen
API显式加载，初始化和终止函数都会自动被调用。</p>
<p>　　实现初始化和终止函数的方法之一是将函数<code>_init()</code>和<code>_fini()</code>作为库的一部分。函数<code>void _init(void)</code>包含共享库第1次被加载时执行的代码。函数<code>void _fini(void)</code>包含共享库被卸载时执行的代码。</p>
<p>　　若需要创建函数<code>_init()</code>和<code>_fini()</code>，则必须在通过命令<code>gcc</code>构建共享库时指定选项<code>-nostartfiles</code>，以防止链接器包含这些函数的默认版本
(可以通过链接器选项<code>–Wl,–init</code>和<code>–Wl,–fini</code>为这2个函数选择别名)。</p>
<p>　　函数<code>_init()</code>和<code>_fini()</code>现已过时，取而代之的是gcc属性<code>constructor</code>和<code>destructor</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((constructor)) some_name_load(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__ ((destructor)) some_name_unload(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 终止代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这2个gcc属性的优势之一是允许定义多个初始化和终止函数。此外，可以主程序中使用这2个属性来创建初始化和终止函数。</p>
<h3 id="监控动态加载器">42.5 监控动态加载器</h3>
<p>　　有时，监控动态加载器的操作可能很有用
(例如，了解它正在搜索的库的位置)。环境变量<code>LD_DEBUG</code>可用于实现这一点。可以通过将该环境变量设置为合适的值来从动态链接器获取各种类型的跟踪信息。</p>
<p>　　若将环境变量<code>LD_DEBUG</code>设置为<code>help</code>，则动态链接器会显示与该环境变量相关的帮助信息，并且指定的命令不会被执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_DEBUG=<span class="built_in">help</span> <span class="built_in">date</span></span></span><br><span class="line">Valid options for the LD_DEBUG environment variable are:</span><br><span class="line"></span><br><span class="line">  libs        display library search paths</span><br><span class="line">  reloc       display relocation processing</span><br><span class="line">  files       display progress for input file</span><br><span class="line">  symbols     display symbol table processing</span><br><span class="line">  bindings    display information about symbol binding</span><br><span class="line">  versions    display version dependencies</span><br><span class="line">  scopes      display scope information</span><br><span class="line">  all         all previous options combined</span><br><span class="line">  statistics  display relocation statistics</span><br><span class="line">  unused      determined unused DSOs</span><br><span class="line">  help        display this help message and exit</span><br><span class="line"></span><br><span class="line">To direct the debugging output into a file instead of standard output</span><br><span class="line">a filename can be specified using the LD_DEBUG_OUTPUT environment variable.</span><br></pre></td></tr></table></figure>
<p>　　以下示例展示了请求跟踪库搜索相关信息时提供的输出的简化版
(每行开头的值10687是正在被跟踪的进程的进程ID)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_DEBUG=libs <span class="built_in">date</span></span></span><br><span class="line">     10687:     find library=librt.so.1 [0]; searching</span><br><span class="line">     10687:      search cache=/etc/ld.so.cache</span><br><span class="line">     10687:       trying file=/lib/librt.so.1</span><br><span class="line">     10687:     find library=libc.so.6 [0]; searching</span><br><span class="line">     10687:      search cache=/etc/ld.so.cache</span><br><span class="line">     10687:       trying file=/lib/libc.so.6</span><br><span class="line">     10687:     find library=libpthread.so.0 [0]; searching</span><br><span class="line">     10687:      search cache=/etc/ld.so.cache</span><br><span class="line">     10687:       trying file=/lib/libpthread.so.0</span><br><span class="line">     10687:     calling init: /lib/libpthread.so.0</span><br><span class="line">     10687:     calling init: /lib/libc.so.6</span><br><span class="line">     10687:     calling init: /lib/librt.so.1</span><br><span class="line">     10687:     initialize program: date</span><br><span class="line">     10687:     transferring control: date</span><br><span class="line">Tue Dec 17:26:56 CEST 2010</span><br><span class="line">     10687:     calling fini: date [0]</span><br><span class="line">     10687:     calling fini: /lib/librt.so.1 [0]</span><br><span class="line">     10687:     calling fini: /lib/libpthread.so.0 [0]</span><br><span class="line">     10687:     calling fini: /lib/libc.so.6 [0]</span><br></pre></td></tr></table></figure>
<p>　　在默认情况下，环境变量<code>LD_DEBUG</code>的输出会被写入到标准错误，但可以将环境变量<code>LD_DEBUG_OUTPUT</code>设置为路径名将其重定向。</p>
<p>　　若有需要，可以环境变量<code>LD_DEBUG</code>设置为由逗号<code>,</code>分隔的多个选项
(不应包含空格)。</p>
<p>　　环境变量<code>LD_DEBUG</code>对由动态链接器隐式加载的库以及通过<code>dlopen()</code>动态加载的库都有效。出于安全原因，该环境变量会被set-user-ID和set-group-ID程序忽略
(glibc 2.5.5及以上版本)。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第41章 共享库基础</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/</url>
    <content><![CDATA[<p>　　构建程序的方式之一是编译所有源文件来产生对应的目标文件，并将这些目标文件链接在一起来生成可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -c prog.c mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -o prog_nolib prog.o mod1.o mod2.o mod3.o</span></span><br></pre></td></tr></table></figure>
<p>　　这里的编译命令使用了选项<code>-g</code>来将调试信息存储在编译后的程序中。实际上，应该尽量创建允许调试的程序和库。此外，对于x86-32架构，不应该指定选项<code>–fomit–frame–pointer</code>，因为该选项会禁用调试
(在x86-64等架构，该选项默认启用，因为它不再禁用调试)。出于同样的原因，不应该使用<code>strip</code>等工具删除可执行文件和库的调试信息。</p>
<p>　　在很多情况下，多个程序会使用同一源文件。作为节省工作量的第1步，可以先将这些源文件编译1次，然后按需将它们链接成不同的可执行文件。尽管这种方式节省了编译时间，但还是存在必须在链接阶段命名所有目标文件的缺点。此外，目录可能充斥着大量目标文件。</p>
<p>　　为了解决这些问题，可以将目标文件组合成称为<strong>目标库</strong>的单元。目标库分为2种类型：<strong>静态库</strong>
(也称为<strong>归档文件</strong>) 和<strong>共享库</strong>。</p>
<span id="more"></span>
<p>　　静态库是UNIX系统提供的第1种库。静态库存在以下优点：</p>
<p>　　●
可以将若干个常用的目标文件放入单个库文件，然后使用该库文件构建多个可执行文件
(而无需在构建每个可执行文件时重新编译源文件)。</p>
<p>　　●
简化编译命令。在链接命令中可以直接指定静态库的名称，而非指定多个目标文件。链接器知道如何搜索静态库并提取可执行文件所需的目标。</p>
<p>　　若程序以链接静态库的形式构建，则生成的可执行文件会包含链接到程序中的所有目标文件的副本。当多个不同的程序使用同一模块时，所有可执行文件都会拥有目标模块的副本。这种代码冗余会导致以下问题：</p>
<p>　　● 存储多个相同的模块会浪费磁盘空间。</p>
<p>　　●
当多个使用同一模块的程序同时运行时，所有程序都会在虚拟内存中存储目标的独立副本，从而增加对虚拟内存的整体需求。</p>
<p>　　●
当修改静态库中的某个模块后，所有使用该模块的静态库都必须重新链接以同步修改。系统管理员需要知道哪些应用程序链接了该库，这进一步加剧了这一问题。</p>
<p>　　共享库旨在解决这些问题。共享库的核心思想是所有使用同一模块的程序共享该模块的
(单份)
副本。目标模块不会被复制到可执行文件。相反，当第1个使用目标模块的程序启动时，包含该目标模块的库的副本会在运行时被加载到内存。随后，当其他使用该模块的程序启动时，它们会使用已加载到内存中库的副本。共享库的使用可以减少程序所需的磁盘空间和虚拟内存。此外，共享库还具有以下优点：</p>
<p>　　●
由于程序整体体积更小，在某些情况下，程序可以更快地被加载到内存和启动。这一点仅适用于已被其他程序使用的大型共享库
(第1个使用共享库的程序的启动时间相对较长，因为需要找到共享库并将其加载到内存)。</p>
<p>　　●
目标模块不会被复制到可执行文件，而是集中存储在共享库中，所以修改目标模块后无需重新链接程序。即使正在运行的程序正在使用共享库，也可以进行修改。</p>
<p>　　相比静态库，共享库存在以下缺点：　　</p>
<p>　　●
共享库比静态库更复杂，无论是从概念角度，还是从创建共享库和构建使用它们的程序的实际操作角度。</p>
<p>　　●
共享库必须被编译为位置无关代码，这在大多数架构上会带来性能开销，因为它需要使用额外的寄存器。</p>
<p>　　●
必须在运行时执行符号重定位。当执行符号重定位时，需要修改对共享库中的所有符号的引用，以对应符号在虚拟内存中实际运行时的位置。因此，使用共享库的程序的执行时间比链接对应静态库的程序的执行时间更长。</p>
<p>　　链接实际上是由链接器程序<code>ld</code>执行。当通过命令<code>cc</code>
(或<code>gcc</code>)
链接程序时，编译器会在后台调用链接器。对于Linux，链接器应该总是通过<code>gcc</code>间接调用，因为<code>gcc</code>会确保<code>ld</code>被调用时带有正确的选项，并将程序与正确的库文件链接。</p>
<p>　　通常，术语<span
style="background-color: yellow">链接</span>用于描述使用链接器
(<code>ld</code>)
将若干个已编译的目标文件组合为可执行文件的过程。有时，术语<span
style="background-color: yellow">静态链接</span>用于将该步骤与<span
style="background-color: yellow">动态链接</span>区分，动态链接是在运行加载可执行文件使用的共享库
(静态链接也称为<span
style="background-color: yellow">链接编辑</span>，而<code>ld</code>等静态链接器有时也称为<span
style="background-color: yellow">链接编辑器</span>)。所有程序都需要经历静态链接阶段，而使用动态库的程序在运行时还会进行动态链接。</p>
<p>　　<strong>可执行与可链接格式</strong> (ELF)
是现代Linux和很多UNIX实现用于可执行文件和共享库的格式。该格式了取代了较旧的<code>a.out</code>和<span
style="background-color: yellow">通用目标文件格式</span> (COFF)。</p>
<p>　　尽管多个进程会共享共享库的代码，但不会共享共享库中的变量。对于共享库中定义的全局和静态变量，所有使用该库的进程都会拥有自己的副本。</p>
<p>　　共享库可以在<span
style="background-color: yellow">Java本地接口</span> (JNI)
中作为构建模块。
JNI允许Java代码通过调用共享库中的C函数直接访问底层操作系统的特性。</p>
<h3 id="创建和使用静态库">41.1 创建和使用静态库</h3>
<p>　　静态库包含所有添加到其中的目标文件的副本，并且会记录所有组件目标文件的各种属性，包括文件权限、用户和组ID以及最后修改时间。按照惯例，静态库的名称格式为<code>libname.a</code>。</p>
<p>　　静态库可以通过命令<code>ar</code>创建和维护。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar options archive object-file...</span></span><br></pre></td></tr></table></figure>
<p>　　参数<code>options</code>由若干个字母组成，其中1个字母是操作代码，其余字母是影响操作执行方式的修饰符。部分常用操作码如下：</p>
<p>　　● <code>r</code>
(replace)：添加指定目标文件到静态库，若存在同名目标文件，则进行替换。这是创建和更新静态库的标准方式。因此，可以通过以下命令构建静态库
(当构建静态库后，可以删除原始目标，因为不再需要它们)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -c mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar r libdemo.a mod1.o mod2.o mod3.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> mod1.o mod2.o mod3.o</span></span><br></pre></td></tr></table></figure>
<p>　　● <code>t</code> (table of
contents)：列出静态库的目录列表。在默认情况下，该列表只会列出目标文件的名称。可以通过添加修饰符<code>v</code>
(verbose) 来查看目标文件的其他属性
(从左到右依次是目标文件的权限、用户ID、组ID、大小以及最后修改时间)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar tv libdemo.a</span> </span><br><span class="line">rw-r--r-- 1000/100 1001016 Nov 15 12:26 2009 mod1.o</span><br><span class="line">rw-r--r-- 1000/100  406668 Nov 15 12:21 2009 mod2.o</span><br><span class="line">rw-r--r-- 1000/100   46672 Nov 15 12:21 2009 mod3.o</span><br></pre></td></tr></table></figure>
<p>　　● <code>d</code> (delete)：从静态库中删除指定目标文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar d libdemo.a mod3.o</span></span><br></pre></td></tr></table></figure>
<p>　　程序链接静态库的方式有2种。第1种方式是将静态库作为链接命令的一部分：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -c prog.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -o prog prog.o libdemo.a</span></span><br></pre></td></tr></table></figure>
<p>　　第2种方式是将库放置在链接器搜索的标准目录下，然后使用选项<code>-l</code>指定库名
(即不带有前缀<code>lib</code>和后缀<code>.a</code>的库文件名)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -o prog prog.o -ldemo</span></span><br></pre></td></tr></table></figure>
<p>　　尽管静态库可能包含多个目标模块，但链接器只会使用程序所需的模块。</p>
<p>　　当链接程序后，可以照常运行它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./prog</span></span><br><span class="line">Called mod1-x1</span><br><span class="line">Called mod2-x2</span><br></pre></td></tr></table></figure>
<h3 id="创建和使用共享库">41.2 创建和使用共享库</h3>
<p>　　为了创建41.1中的静态库对应的共享库，需要执行以下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libfoo.so mod1.o mod2.o mod3.o</span></span><br></pre></td></tr></table></figure>
<p>　　第1条命令会创建待放入库中的3个目标模块。第2条命令会创建包含这3个目标模块的共享库。按照惯例，共享库通常带有前缀<code>lib</code>和后缀<code>.so</code>
(表示共享对象)。这里使用的命令是<code>gcc</code>，因为共享库的创建方式取决于编译器
(其他C编译器可能会使用不同的选项)。</p>
<p>　　此外，可以通过单行命令来编译源文件并创建共享库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -fPIC -Wall mod1.c mod2.c mod3.c -shared -o libfoo.so</span></span><br></pre></td></tr></table></figure>
<p>　　但是，为了清除地区分编译和库构建步骤，之后的内容还是会将这2个步骤写出单独的命令。</p>
<p>　　不同于静态库，无法向共享库中添加或删除目标模块。共享库中的目标文件并非各自独立。</p>
<p>　　为了使用共享库，需要执行2个链接静态库的程序不需要的步骤：</p>
<p>　　●
因为可执行文件不包含所需的目标文件的副本，所以它需要某种机制来表示运行时所需的共享库。这是通过在链接阶段将共享库名嵌入到可执行文件实现的。程序的所有共享库依赖称为其<strong>动态依赖列表</strong>
(共享库依赖被记录在ELF的标签<code>DT_NEEDED</code>中)。</p>
<p>　　●
在运行时，需要某种机制来解析嵌入的库名——搜索可执行文件中的库名对应的共享库，并将其加载到内存。</p>
<p>　　当将程序与共享库链接时，会自动将库名嵌入到可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -o prog prog.c libfoo.so</span></span><br></pre></td></tr></table></figure>
<p>　　当执行该程序时，可能会出现以下错误信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./prog</span></span><br><span class="line">./prog: error in loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>　　这就引出了第2个必要步骤：<strong>动态链接</strong>，即在运行时解析嵌入的库名。该任务由<strong>动态链接器</strong>
(也称为<strong>动态链接加载器</strong>或<strong>运行时链接器</strong>)
执行。动态链接器实际上是共享库<code>/lib/ld-linux.so.2</code>，所有ELF可执行文件都会使用该共享库。</p>
<p>　　路径名<code>/lib/ld-linux.so.2</code>通常是指向动态链接器可执行文件的符号链接。该文件名为<code>ld-version.so</code>，其中<code>version</code>是glibc版本
(例如，<code>ld-2.11.so</code>)。动态链接器的路径名在某些架构上有所不同
(例如，IA-64架构的动态链接器的符号链接名为<code>/lib/ld-linux-ia64.so.2</code>)。</p>
<p>　　动态链接器会检查程序所需的共享库列表，并通过若干个预定义的规则来搜索库文件，其中的某些规则指定了共享库通常所在的标准目录
(运行程序<code>prog</code>出现的错误信息是因为共享库位于这些标准目录之外)。</p>
<p>　　某些架构 (例如，zSeries、PowerPC64和x86-64)
支持执行32位和64位程序。对于这些系统，32位库位于子目录<code>*/lib</code>，64位库位于子目录<code>*/lib64</code>。</p>
<p>　　可以将目录指定为环境变量<code>LD_LIBRARY_PATH</code>中以冒号<code>:</code>分隔的目录列表的一部分来将通知动态链接器共享库所在的非标准目录
(分号<code>;</code>也可以用于分隔目录，在这种情况下，必须将列表加引号来防止shell解释分号)。若定义了该环境变量，则动态链接器会在搜索标准库目录之前先搜索该环境变量定义的目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">Called mod1-x1</span><br><span class="line">Called mod2-x2</span><br></pre></td></tr></table></figure>
<p>　　这条命令会为执行<code>prog</code>的进程定义环境变量<code>LD_LIBRARY_PATH</code>。该定义会告诉动态链接器在<code>.</code>
(当前工作目录) 搜索共享库。</p>
<p>　　环境变量<code>LD_LIBRARY_PATH</code>中定义的空目录
(例如，<code>dirx::diry</code>) 等同于<code>.</code>
(将该环境变量设置为空字符串不能达到同样的效果)。SUSv3不鼓励在路径环境变量中以这种方式指定路径名，所以应该避免这样做。</p>
<h4 id="位置无关代码">41.2.1 位置无关代码</h4>
<p>　　命令<code>gcc</code>的编译选项<code>-fPIC</code>指定编译器应该生成<strong>位置无关代码</strong>。这会修改编译器为访问全局变量、访问静态变量、访问外部变量、访问字符串常量和获取函数地址等操作生成代码的方式。这些修改允许代码在运行时位于任意虚拟地址。这是共享库所必需的，因为链接时无法得知共享库代码在内存中的位置，而共享库的运行时内存位置取决于多种因素
(例如，加载共享库的程序已占用的内存空间以及该程序已加载了那些其他共享库)。</p>
<p>　　对于Linux/x86-32，可以用不带有选项<code>-fPIC</code>编译的目标模块创建共享库
(对于某些架构，若没有该选项，则无法构建共享库)。但是，这样做会失去共享库的部分优势，因为包含位置无关内存引用的程序文本页不会在进程之间共享。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nm mod1.o | grep _GLOBAL_OFFSET_TABLE_</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -s mod1.o | grep _GLOBAL_OFFSET_TABLE_</span></span><br></pre></td></tr></table></figure>
<p>　　这2条命令都可以用于确定现有目标文件在编译时是否带有选项<code>-fPIC</code>
(检查目标文件的符号表中是否存在名称<code>_GLOBAL_OFFSET_TABLE_</code>)。若这2条命令都没有输出，则表示共享库中存在至少1个目标模块在编译时未带有选项<code>-fPIC</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump --all-headers libfoo.so | grep TEXTREL</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -d libfoo.so | grep TEXTREL</span></span><br></pre></td></tr></table></figure>
<p>　　字符串<code>TEXTREL</code>表示文本段包含需要运行时重定位的引用的目标模块。</p>
<h4 id="共享库soname">41.2.2 共享库soname</h4>
<p>　　嵌入到可执行文件并在运行时由动态链接器搜索的名称是共享库的<span
style="background-color: yellow">实际名</span>，但通常的做法是为共享库创建别名，该别名称为<strong>soname</strong>
(ELF的标签<code>DT_SONAME</code>)。</p>
<p>　　当共享库有soname时，在静态链接期间，soname会被嵌入到可执行文件
(而非实际名)，随后动态链接器在运行时也是搜索soname。soname的目的是提供间接层，使可执行文件在运行时可以使用与其链接时不同
(但兼容) 的共享库版本。</p>
<p>　　使用soname的第1步是在创建共享库指定它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -Wl,-soname,libbar.so -o libfoo.so mod1.o mod2.o mod3.o</span></span><br></pre></td></tr></table></figure>
<p>　　选项<code>-Wl,-soname,libbar.so</code>指示链接器将共享库<code>libfoo.so</code>标记为soname
<code>libbar.so</code>。</p>
<p>　　当需要获取现有共享库的soname时，可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -p libfoo.so | grep SONAME</span></span><br><span class="line">  SONAME                libbar.so</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -d libfoo.so | grep SONAME</span></span><br><span class="line"> 0x0000000e (SONAME)        Library soname: [libbar.so]</span><br></pre></td></tr></table></figure>
<p>　　当创建带有soname的共享库后，可以照常创建可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -o prog prog.c libfoo.so</span></span><br></pre></td></tr></table></figure>
<p>　　此时，链接器检查到库<code>libfoo.so</code>包含soname
<code>libbar.so</code>并将后者嵌入到可执行文件。</p>
<p>　　当运行程序<code>prog</code>时，会得到以下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">./prog: error in loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>　　这是因为动态链接器无法找到共享库<code>libbar.so</code>。当使用soname时，需要创建从soname到库的实际名的符号链接。该符号链接必须被创建在动态链接器搜索的目录之一。因此，可以通过以下方式运行程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s libfoo.so libbar.so</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">Called mod1-x1</span><br><span class="line">Called mod2-x2</span><br></pre></td></tr></table></figure>
<p>　　下图展示了涉及创建带有嵌入的soname的共享库、将程序链接到该库并创建运行程序所需的soname符号链接的编译和链接步骤：</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/creating_a_shared_library_and_linking_a_program_against_it.svg" class="">
<p>　　下图展示了程序<code>prog</code>在准备执行时加载共享库的步骤：</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/execution_of_a_program_that_loads_a_shared_library.svg" class="">
<p>　　特定于Linux的文件<code>/proc/PID/maps</code>可用于获取进程当前正在使用的共享库。</p>
<h3 id="与共享库相关的实用工具">41.3 与共享库相关的实用工具</h3>
<p>　　命令<code>ldd</code> (list dynamic dependencies) 会显示程序
(或共享库) 运行所需的共享库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd prog</span></span><br><span class="line">        libtlpi.so.1 =&gt; /usr/lib/libdemo.so.1 (0x40019000)</span><br><span class="line">        libc.so.6 =&gt; /usr/tls/libc.so.6 (0x4017b000)</span><br><span class="line">        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</span><br></pre></td></tr></table></figure>
<p>　　命令<code>ldd</code>会解析每个库引用
(使用与动态链接器相同的搜索约定) 并通过以下形式显示结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library-name =&gt; resolves-to-path</span><br></pre></td></tr></table></figure>
<p>　　对于大多数ELF可执行文件，命令<code>ldd</code>列出的条目至少会包含<code>ld-linux.so.2</code>
(动态链接器) 和<code>libc.so.6</code>
(标准C库)。对于某些架构，C库的名称有所不同
(例如，对于IA-64和Alpha，标准C库的名称为<code>libc.so.6.1</code>)。</p>
<p>　　命令<code>objdump</code>可用于从可执行文件、编译目标以及共享库获取各种信息
(包括反汇编二进制机器代码)。该命令也能用于显示这些文件各个ELF段的首部信息，在这种情况下，该命令类似于<code>readelf</code>，后者显示类似的信息，但格式不同。</p>
<p>　　命令<code>nm</code>会列出在目标库或可执行文件中定义的符号集。该命令的用法之一是找出哪些库定义了指定符号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nm -A /usr/lib/lib*.so 2&gt; /dev/null | grep <span class="string">&#x27; crypt$&#x27;</span></span></span><br><span class="line">/usr/lib/libcrypt.so:00007080 W crypt</span><br></pre></td></tr></table></figure>
<p>　　命令<code>nm</code>的选项<code>-A</code>指定在显示符号的每行开头显示库名。这是必要的，因为该命令默认只会显示1次库名，然后在后续的行中显示它包含的所有符号，这对于这里所示的过滤方法没有用。此外，这里还丢弃了标准错误输出来隐藏该命令无法识别的文件格式的错误信息。根据结果可知，函数<code>crypt()</code>被定义在库<code>libcrypt</code>中。</p>
<h3 id="共享库版本和命名约定">41.4 共享库版本和命名约定</h3>
<p>　　连续版本的共享库通常兼容，这表示这些模块的函数呈现相同的调用接口，并且在语义上是等效的。这种不同但兼容的版本称为共享库的<span
style="background-color: yellow">次要版本</span>。有时，需要创建库的新的<span
style="background-color: yellow">主要版本</span>，即与上一个版本不兼容的版本。与此同时，必须仍然能够继续运行需要旧版本的程序。</p>
<p>　　为了满足这个版本控制需求，共享库的实际名和soname采用标准命名约定。</p>
<p>　　共享库的不兼容的版本由唯一的<span
style="background-color: yellow">主要版本标识符</span>区分，该标识符会作为其实际名的一部分。按照惯例，主要版本标识符采用数字形式，随着库的不兼容版本而顺序递增。除了主要版本标识符之外，实际名还包含<span
style="background-color: yellow">次要版本标识符</span>，用于区分主要版本内兼容的次要版本。实际名采用的格式约定为<code>libname.so.major-id.minor-id</code>。</p>
<p>　　与主要版本标识符类似，次要版本标识符可以为任何字符串。但是，按照惯例，该标识符要么是1个数字，要么是2个由<code>.</code>分隔的数字，第1个数字表示次要版本，第2个数字表示次要版本的补丁级别或修订号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libdemo.so.1.0.1</span><br><span class="line">libdemo.so.1.0.2</span><br><span class="line">libdemo.so.2.0.0</span><br><span class="line">libreadline.so.5.0</span><br></pre></td></tr></table></figure>
<p>　　soname仅包含对应实际名的主要版本标识符，所以其格式为<code>libname.so.major-id</code>。通常，soname是实际名所在的目录下的相对符号链接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libdemo.so.1        -&gt; libdemo.so.1.0.2</span><br><span class="line">libdemo.so.2        -&gt; libdemo.so.2.0.0</span><br><span class="line">libreadline.so.5    -&gt; libreadline.so.5.0</span><br></pre></td></tr></table></figure>
<p>　　对于共享库的特定主要版本，可能会存在多个次要版本的库文件。soanme通常指向对应主要版本的最新次要版本。这种设置允许共享库在运行时操作期间实现正确的版本控制语义。因为静态链接阶段会将soname的副本嵌入到可执行文件，并且soname符号链接后续可以被修改为指向较新的次要版本，所以可以确保可执行文件在运行时加载库的最新次要版本。此外，不同主要版本有不同的soname，所以它们可以共存，并且程序可以按需访问它们。</p>
<p>　　除了实际名和soname之外，将可执行文件与共享库链接时通常还会使用<span
style="background-color: yellow">链接器名</span>来定义共享库。链接器名是仅包含库名
(不包含版本标识符)
的符号链接，所以其格式为<code>libname.so</code>。链接器名可用于构建与版本无关的链接命令，这些命令会自动使用正确的
(即最新的) 共享库版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libdemo.so      -&gt; libdemo.so.2</span><br><span class="line">libreadline.so  -&gt; libreadline.so.5</span><br></pre></td></tr></table></figure>
<p>　　链接器名通常会与其引用的文件位于同一目录。它可以链接到库的实际名或最新的主要版本的soname。链接器名通常应该链接到soname，因为这样可以让链接器名反映对soname的修改。</p>
<p>　　若需要将程序链接到共享库的较旧的主要版本，则不能使用链接器名。相反，应该在编译命令中指定所需版本的实际名或soname。</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 22%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr>
<th>名称</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>实际名</td>
<td><code>libname.so.maj.min</code></td>
<td>存储库代码的文件；所有版本都只有1个实例</td>
</tr>
<tr>
<td>soname</td>
<td><code>libname.so.maj</code></td>
<td>共享库的每个主要版本1个实例；链接时会被嵌入到可执行文件；在运行时用于通过指向对应
(最新) 实际名的同名符号链接来搜索库</td>
</tr>
<tr>
<td>链接器名</td>
<td><code>libname.so</code></td>
<td>指向最新实际名或最新soname的符号链接；单个实例；允许构建独立于版本的编译命令</td>
</tr>
</tbody>
</table>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/various_shared_library_names.svg" class="">
<p>　　综合以上信息，可以通过以下步骤来按照标准规范构建示例共享库：</p>
<p>　　1) 创建目标文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br></pre></td></tr></table></figure>
<p>　　2)
创建实际名为<code>libdemo.so.1.0.1</code>的共享库，并创建对应的soname
<code>libdemo.so.1</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.1 mod1.o mod2.o mod3.o</span></span><br></pre></td></tr></table></figure>
<p>　　3) 为soname和链接器名创建合适的符号链接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s libdemo.so.1.0.1 libdemo.so.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s libdemo.so.1 libdemo.so</span></span><br></pre></td></tr></table></figure>
<p>　　当共享库创建完成后，可以通过命令<code>ls</code>进行验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l libdemo.so* | awk <span class="string">&#x27;&#123;print $1, $9, $10, $11&#125;&#x27;</span></span></span><br><span class="line">lrwxrwxrwx libdemo.so -&gt; libdemo.so.1</span><br><span class="line">lrwxrwxrwx libdemo.so.1 -&gt; libdemo.so.1.0.1</span><br><span class="line">-rwxr-xr-x libdemo.so.1.0.1</span><br></pre></td></tr></table></figure>
<p>　　构建可执行文件时可以使用链接器名，然后照常运行可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -o prog prog.c -L. -ldemo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">Called mod1-x1</span><br><span class="line">Called mod2-x2</span><br></pre></td></tr></table></figure>
<h3 id="安装共享库">41.5 安装共享库</h3>
<p>　　在之前的示例中，共享库被创建在用户私有目录下，然后通过环境变量<code>LD_LIBRARY_PATH</code>来确保动态链接器会搜索该目录。特权用户和非特权用户都可以使用该技术。但是，生产应用程序中不应该使用该技术。更常见的做法是将共享库以及相关的符号链接安装到某个标准库目录下，特别是以下目录之一
(在大多数情况下，将文件复制到这些目录需要超级用户特权)：</p>
<p>　　● <code>/usr/lib</code>：大部分标准库的安装目录。</p>
<p>　　● <code>/lib</code>：系统启动时所需的库的安装目录
(因为系统启动时<code>/usr/lib</code>可能还未挂载)。</p>
<p>　　● <code>/usr/local/lib</code>：非标准或实验库的安装目录
(当<code>/usr/lib</code>是在多个系统之间共享的网络挂载点时，若需要安装仅供当前系统使用的库，则可以将该库安装到<code>/usr/local/lib</code>)。</p>
<p>　　● <code>/etc/ld.so.conf</code>中列出的目录。</p>
<p>　　当安装完成后，必须创建soname和链接器名的符号链接，通常是在库文件所在的目录下创建相对符号链接。因此，需要通过以下方式在<code>/usr/lib</code>下安装示例库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> libdemo.so.1.0.1 /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s libdemo.so.1.0.1 libdemo.so.1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s libdemo.so.1 libdemo.so</span></span><br></pre></td></tr></table></figure>
<p>　　程序<code>ldconfig</code>可以解决共享库的2个潜在问题：</p>
<p>　　●
共享库可以位于各种目录。因此，当动态链接器需要搜索这些目录才能找到共享库时，加载共享库的速度可能很慢。</p>
<p>　　●
随着共享库新版本的安装或旧版本的删除，soname符号链接可能过期。</p>
<p>　　程序<code>ldconfig</code>会通过执行2个步骤来解决这些问题：</p>
<p>　　1)
该程序会搜索标准目录并创建或更新缓存文件<code>/etc/ld.so.cache</code>，以保证该缓存文件包含由标准目录下的所有库的所有主要版本的最新次要版本组成的列表
(命令<code>ldconfig –p</code>会显示该缓存文件的内容)。动态链接器在运行时解析库名时会使用该缓存文件。为了构建缓存，该程序会先搜索文件<code>/etc/ld.so.conf</code>指定的目录，然后搜索目录<code>/lib</code>和<code>/usr/lib</code>。文件<code>/etc/ld.so.conf</code>包含若干个由换行符、空格、制表符、逗号或冒号分隔的目录绝对路径名。对于某些发行版，该文件会包含目录<code>/usr/local/lib</code>
(若不包含，则需要手动添加)。</p>
<p>　　2)
该程序会检查所有库的所有主要版本的最新次要版本来搜索待嵌入的soname，并在同一目录下为soname创建
(或更新) 相对符号链接。</p>
<p>　　程序<code>ldconfig</code>默认会执行这些步骤，其行为可以通过命令行选项控制。选项<code>-N</code>会禁用重新构建缓存，选项<code>-X</code>会禁用创建soname符号链接。此外，选项<code>-v</code>会使该程序显示描述其操作的输出。为了正确地执行这些步骤，该程序会按照之前的约定
(库的实际名包括主要版本号和次要版本号，并随着版本增加) 解析库名。</p>
<p>　　当创建库、更新库、删除库或修改<code>/etc/ld.so.conf</code>的目录列表时，应该运行程序<code>ldconfig</code>。</p>
<p>　　假设需要按照同一库的2个不同主要版本，可以通过以下方式实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> libdemo.so.1.0.1 libdemo.so.2.0.0 /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ldconfig -v | grep libdemo</span></span><br><span class="line">        libdemo.so.1 -&gt; libdemo.so.1.0.1 (changed)</span><br><span class="line">        libdemo.so.2 -&gt; libdemo.so.2.0.0 (changed)</span><br></pre></td></tr></table></figure>
<p>　　这里过滤了<code>ldconfig</code>的输出来仅显示库<code>libdemo</code>的相关信息。</p>
<p>　　然后，列出目录<code>/usr/lib</code>下名为<code>libdemo</code>的文件，以验证soname符号链接的设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l libdemo* | awk <span class="string">&#x27;&#123;print $1, $$9, $10, $11&#125;&#x27;</span></span></span><br><span class="line">lrwxrwxrwx libdemo.so.1 -&gt; libdemo.so.1.0.1</span><br><span class="line">-rwxr-xr-x libdemo.so.1.0.1</span><br><span class="line">lrwxrwxrwx libdemo.so.2 -&gt; libdemo.so.2.0.0</span><br><span class="line">-rwxr-xr-x libdemo.so.2.0.0</span><br></pre></td></tr></table></figure>
<p>　　这里必须创建链接器名的符号链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s libdemo.so.2 libdemo.so</span></span><br></pre></td></tr></table></figure>
<p>　　当后续需要安装库的新2.x次要版本时，因为链接器名指向最新的soname，所以<code>ldconfig</code>会更新链接器名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> libdemo.so.2.0.1 /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ldconfig -v | grep libdemo</span></span><br><span class="line">        libdemo.so.1 -&gt; libdemo.so.1.0.1</span><br><span class="line">        libdemo.so.2 -&gt; libdemo.so.2.0.1 (changed)</span><br></pre></td></tr></table></figure>
<p>　　若需要构建和使用私有库
(安装在非标准目录的库)，则可以在运行<code>ldconfig</code>时使用选项<code>-n</code>来创建soname符号链接
(这会让<code>ldconfig</code>仅处理命令行指定目录下的库文件，并且不更新缓存文件)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.1 mod1.o mod2.o mod3.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/sbin/ldconfig -nv .</span></span><br><span class="line">.:</span><br><span class="line">        libdemo.so.1 -&gt; libdemo.so.1.0.1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l libdemo.so* | awk <span class="string">&#x27;&#123;print $1, $9, $10, $11&#125;&#x27;</span></span></span><br><span class="line">lrwxrwxrwx libdemo.so.1 -&gt; libdemo.so.1.0.1</span><br><span class="line">-rwxr-xr-x libdemo.so.1.0.1</span><br></pre></td></tr></table></figure>
<p>　　这里在运行<code>ldconfig</code>时指定了完整路径名，因为使用的是非特权用户，其环境变量<code>PATH</code>不包含目录<code>/sbin</code>。</p>
<h3 id="更新共享库">41.6 更新共享库</h3>
<p>　　随着时间的推移，可能需要对共享库代码进行修改。这些修改会导致共享库的新版本与旧版本<span
style="background-color: yellow">兼容</span>
(仅需要修改库实际名的次要版本标识符) 或<span
style="background-color: yellow">不兼容</span>
(必须要修改库实际名的主要版本标识符)。</p>
<p>　　对库的修改与现有版本兼容需要满足以下所有条件：</p>
<p>　　●
库中的所有函数和变量的语义都保持不变。换句话说，所有函数的参数列表都保持不变，继续对全局变量和返回的参数产生其指定的影响并返回相同的结果值。因此，能够提升性能或修复漏洞的修改是兼容的修改。</p>
<p>　　●
函数公共API中的函数或变量不会被删除。此外，向公共API添加函数和变量是兼容的。</p>
<p>　　●
函数内部分配的结构体、函数返回的结构体以及库定义的公共结构体都保持不变。该规则存在1个例外：有时，可能会向现有结构体的末尾添加新成员，不过即使这样也可能会导致问题
(例如，调用程序试图分配由该结构体组成的数组)。库设计者有时会通过将这些结构体定义为比库初始版本所需的大小更大来规避这一限制，并预留一些额外填充字段以
"供将来使用"。</p>
<p>　　若满足以上所有条件，则可以通过调整现有库名的次要版本来进行更新；否则，应该创建库的新的主要版本。</p>
<p>　　共享库的优势之一是可以在运行中的程序使用库时安装库的新版本，只需要创建库的新版本并将其安装在合适的目录，然后按需更新soname和链接器名符号链接
(或者让程序<code>ldconfig</code>来完成这一步)。为了创建共享库<code>/usr/lib/libdemo.1.0.1</code>的新次要版本
(兼容更新)，可以通过以下方式实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.2 mod1.o mod2.o mod3.o</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> libdemo.so.1.0.2 /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ldconfig -v | grep libdemo</span></span><br><span class="line">        libdemo.so.1 -&gt; libdemo.so.1.0.2 (changed)</span><br></pre></td></tr></table></figure>
<p>　　这里假设链接器名已被正确地设置
(指向对应的soname)，所以无需修改它。</p>
<p>　　正在运行的程序会继续使用共享库的旧次要版本。当且仅当该程序终止并再次启动时，它才会使用共享库的新次要版本。</p>
<p>　　当后续需要创建共享库的新主要版本 (2.0)
时，可以通过以下方式实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc -g -shared -Wl,-soname,libdemo.so.2 -o libdemo.so.2.0.0 mod1.o mod2.o mod3.o</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> libdemo.so.2.0.0 /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ldconfig -v | grep libdemo</span></span><br><span class="line">        libdemo.so.1 -&gt; libdemo.so.1.0.2</span><br><span class="line">        libdemo.so.2 -&gt; libdemo.so.2.0.0 (changed)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -sf libdemo.so.2 libdemo.so</span></span><br></pre></td></tr></table></figure>
<p>　　根据结果可知，<code>ldconfig</code>会自动创建新主要版本的soname符号链接。但是，如最后1行命令所示，还必须手动更新链接器名符号链接。</p>
<h3 id="在目标文件中指定搜索目录">41.7 在目标文件中指定搜索目录</h3>
<p>　　除了环境变量<code>LD_LIBRARY_PATH</code>和将共享库安装在标准目录之外，还有第3种通知动态链接器共享库位置的方法：在静态编辑阶段，在可执行文件中插入1个目录列表，以便在运行时搜索共享库。当某些库位于动态链接器搜索的标准目录之外的固定位置时，这种方法很有用。为此，在构建可执行文件时需要使用选项<code>-rpath</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -Wl,-rpath,/home/mtk/pdir -o prog prog.c libdemo.so</span></span><br></pre></td></tr></table></figure>
<p>　　这条命令会将字符串<code>/home/mtk/pdir</code>复制到可执行文件<code>prog</code>的运行时库路径
(<code>rpath</code>)。因此，当该程序运行时，动态链接器在解析共享库引用时也会搜索该目录。</p>
<p>　　选项<code>-rpath</code>可以被指定多次，这些目录会被合并为1个有序的<code>rpath</code>列表，并被放置在可执行文件中。此外，在1个选项<code>-rpath</code>中可以指定多个由冒号<code>:</code>分隔的目录。动态链接器会在运行时按照选项<code>-rpath</code>中指定的顺序搜索目录。</p>
<p>　　选项<code>-rpath</code>的替代方法是环境变量<code>LD_RUN_PATH</code>，该环境变量的值可以是多个由冒号<code>:</code>分隔的目录。但是，当且仅当构建可执行文件未指定选项<code>-rpath</code>时，该环境变量才有效。</p>
<h4 id="在构建共享库时使用链接器选项-rpath">41.7.1
在构建共享库时使用链接器选项<code>-rpath</code></h4>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/a_shared_library_that_depends_on_another_shared_library.svg" class="">
<p>　　当构建共享库时，链接器选项<code>-rpath</code>也很有用。假设共享库<code>libx1.so</code>依赖于共享库<code>libx2.so</code>，而这些库分别位于非标准目录<code>d1</code>和<code>d2</code>。创建这2个库和程序的步骤如下：</p>
<p>　　1) 在目录<code>pdir/d2</code>下创建库<code>libx2.so</code>
(这里省略了版本命名和soname指定)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/mtk/pdir/d2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall modx2.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libx2.so modx2.o</span></span><br></pre></td></tr></table></figure>
<p>　　2)
在目录<code>pdir/d1</code>下创建库<code>libx1.so</code>。因为库<code>libx1.so</code>依赖于位于非标准目录的库<code>libx2.so</code>，所以在链接器选项<code>-rpath</code>中指定了后者的运行时位置。该位置可能与该库的链接时位置不同，但这里它们是相同的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/mtk/pdir/d1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -Wall -fPIC modx1.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libx1.so modx1.o -Wl,-rpath,/home/mtk/pdir/d2 -L/home/mtk/pdir/d2 -lx2</span></span><br></pre></td></tr></table></figure>
<p>　　3)
在目录<code>pdir</code>下构建主程序。因为主程序会使用位于非标准目录的库<code>libx1.so</code>，所以也会使用链接器选项<code>-rpath</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/mtk/pdir</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -o prog prog.c -Wl,-rpath,/home/mtk/pdir/d1 -L/home/mtk/pdir/d1 -lx1</span></span><br></pre></td></tr></table></figure>
<p>　　这里在构建主程序时无需指定库<code>libx2.so</code>，因为链接器能够分析库<code>libx1.so</code>的<code>rpath</code>列表来找到该库，所以所有符号都可以在静态链接阶段被解析。</p>
<p>　　可以通过以下命令检查程序<code>prog</code>和库<code>libx1.so</code>来查看它们的<code>rpath</code>列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -p dump_utmpx | grep PATH</span></span><br><span class="line">  RPATH              /home/mtk/pdir/d1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -p d1/libx1.so | grep PATH</span></span><br><span class="line">  RPATH              /home/mtk/pdir/d2</span><br></pre></td></tr></table></figure>
<p>　　也可以对命令<code>readelf ––dynamic</code>或<code>readelf –d</code>的输出进行grep来查看<code>rpath</code>列表。</p>
<p>　　此外，可以通过命令<code>ldd</code>来显示程序<code>prog</code>的所有动态依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd dump_utmpx</span></span><br><span class="line">        libx1.so =&gt; /home/mtk/pdir/d1/libx1.so (0x40017000)</span><br><span class="line">        libc.so.6 =&gt; /lib/tls/libc.so.6 (0x40024000)</span><br><span class="line">        libx2.so =&gt; /home/mtk/pdir/d2/libx2.so (0x4014c000)</span><br><span class="line">        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</span><br></pre></td></tr></table></figure>
<h4 id="elf的标签dt_rpath和dt_runpath">41.7.2
ELF的标签<code>DT_RPATH</code>和<code>DT_RUNPATH</code></h4>
<p>　　对于最初的ELF规范，只有1种类型的<code>rpath</code>列表可以被嵌入到可执行文件或共享库，这对应ELF文件中的标签<code>DT_RPATH</code>。后来的ELF规范弃用了该标签，并添加了标签<code>DT_RUNPATH</code>来表示<code>rpath</code>列表。这2种<code>rpath</code>列表的区别在于，当动态链接器在运行时搜索共享库时，它们相对于环境变量<code>LD_LIBRARY_PATH</code>的优先级不同，标签<code>DT_RPATH</code>的优先级更高，而标签<code>DT_RUNPATH</code>的优先级更低。</p>
<p>　　链接器默认会将<code>rpath</code>列表创建为标签<code>DT_RPATH</code>。为了让链接器将<code>rpath</code>列表创建为标签<code>DT_RUNPATH</code>，需要指定链接器选项<code>––enable–new–dtags</code>。若使用该选项构建程序，则通过命令<code>objdump</code>查看程序时可以得到以下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -o prog prog.c -Wl,--enable-new-dtags -Wl,-rpath,/home/mtk/pdir/d1 -L/home/mtk/pdir/d1 -lx1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -p prog | grep PATH</span></span><br><span class="line">  RPATH                /home/mtk/pdir/d1</span><br><span class="line">  RUNPATH              /home/mtk/pdir/d1</span><br></pre></td></tr></table></figure>
<p>　　根据结果可知，可执行文件同时包含这2个标签。链接器以这种方式复制<code>rpath</code>列表是为了方便那些无法识别标签<code>DT_RUNPATH</code>的旧版动态链接器
(glibc
2.2添加了对标签<code>DT_RUNPATH</code>的支持)。能够识别标签<code>DT_RUNPATH</code>的动态链接器会忽略标签<code>DT_RPATH</code>。</p>
<h4 id="在rpath中使用origin">41.7.3
在<code>rpath</code>中使用<code>$ORIGIN</code></h4>
<p>　　假设需要分发使用了私有共享库的应用程序，但不能要求用户将这些库安装到标准目录。相反，用户可以在其选择的任意目录下解压应用程序，并能够立即运行该应用程序。问题在于，应用程序无法确定其共享库的位置，除非要求用户设置环境变量<code>LD_LIBRARY_PATH</code>或运行安装脚本来识别所需的目录，但这2种方法都不理想。</p>
<p>　　为此，动态链接器被设计为能够理解<code>rpath</code>规范中的特殊字符串<code>$ORIGIN</code>
(或<code>$&#123;ORIGIN&#125;</code>)。动态链接器会将该字符串解释为
"应用程序所在的目录"。因此，可以通过以下命令来构建应用程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Wl,-rpath,<span class="string">&#x27;$ORIGIN&#x27;</span>/lib ...</span></span><br></pre></td></tr></table></figure>
<p>　　该命令会假设运行时应用程序的共享库位于应用程序所在目录的子目录<code>lib</code>下。因此，可以向用户提供包含应用程序和相关库的安装包，用户可以将安装包安装在任意位置，然后运行应用程序
(即 "turn-key" 应用程序)。</p>
<h3 id="在运行时搜索共享库">41.8 在运行时搜索共享库</h3>
<p>　　在解析库依赖时，动态链接器会先检查所有依赖字符串是否包含斜杠<code>/</code>。若在链接可执行文件时显式指定了库路径名，则可能出现这种情况。若发现斜杠，则依赖字符串会被解释为路径名，并使用该路径名加载库；否则，动态链接器按照以下规则搜索共享库：</p>
<p>　　1) 若可执行文件的<code>DT_RPATH</code>运行时库路径列表
(<code>rpath</code>)
中包含目录，并且可执行文件没有<code>DT_RUNPATH</code>列表，则按照链接程序时指定的顺序搜索这些目录。</p>
<p>　　2)
若定义了环境变量<code>LD_LIBRARY_PATH</code>，则依次搜索该环境变量的值中的目录。若可执行文件是set-user-ID或set-group-ID程序，则会忽略该环境变量。这是为了防止用户欺骗动态连接起加载与可执行文件所需的库同名的私有版本库。</p>
<p>　　3)
若可执行文件的<code>DT_RUNPATH</code>运行时库路径列表中包含目录，则按照链接程序时指定的顺序搜索这些目录。</p>
<p>　　4) 检查文件<code>/etc/ld.so.cache</code>是否包含库条目。</p>
<p>　　5)
先搜索目录<code>/lib</code>，再搜索目录<code>/usr/lib</code>。</p>
<h3 id="运行时符号解析">41.9 运行时符号解析</h3>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/resolving_a_global_symbol_reference.svg" class="">
<p>　　假设主程序和共享库都定义了全局函数<code>xyz()</code>，并且该共享库中的函数也调用了<code>xyz()</code>。当构建主程序和共享库后，运行该程序时会得到以下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall -c foo.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libfoo.so foo.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -o prog prog.c libfoo.so</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">main-xyz</span><br></pre></td></tr></table></figure>
<p>　　根据结果可知，主程序的<code>xyz()</code>定义覆盖了共享库的<code>xyz()</code>定义。虽然这乍看之下令人惊讶，但这是有历史原因的。最初的共享库实现的设计使得符号解析的默认语义完全与链接到该库的静态库版本的应用程序的语义完全一致。这表示以下语义适用：</p>
<p>　　● 主程序中的全局符号定义会覆盖库中的相同定义。</p>
<p>　　●
若多个库都定义了同一全局符号，则对该符号的引用会绑定到按照静态链接命令中列出的库从左到右搜索到的第1个定义。</p>
<p>　　虽然这些语义使得从静态库过渡到动态库相对简单，但也可能会导致一些问题。最显著的问题是这些语义与共享库作为实现包含子系统的模型相冲突。在默认情况下，共享库不会保证对其全局符号的引用实际上会绑定到该库对该符号的定义。因此，当共享库被聚合到更大的单元时，其属性可能会发生变化。这可能会导致应用程序以意想不到的方式崩溃，也使得分而治之的调试方法
(即试图使用较少或不同的库重现问题) 变得困难。</p>
<p>　　链接器选项<code>-Bsymbolic</code>会让共享库中的全局符号引用优先绑定到该库中的定义。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall -c foo.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -Wl,-Bsymbolic -o libfoo.so foo.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -o prog prog.c libfoo.so</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">foo-xyz</span><br></pre></td></tr></table></figure>
<p>　　这里无论是否指定了链接器选项<code>-Bsymbolic</code>，在主程序中调用<code>xyz()</code>都会使用主程序中的定义。</p>
<h3 id="使用静态库的场景">41.10 使用静态库的场景</h3>
<p>　　在某些情况下，相比动态库，更适合使用静态库。假设用户无法或不希望在运行程序的系统上按照共享库，或者程序将在chroot
jail等共享库不可用的环境中运行，那么静态链接就很有用。此外，即使是兼容的共享库升级也可能无意中引入错误，从而导致应用程序崩溃。对于静态链接的应用程序，可以确保它不会受到系统中共享库变化的影响，并且具备运行时所需的所有代码
(代价是程序体积更大以及随之增加的磁盘和内核需求)。</p>
<p>　　若链接器可以选择同名的共享库和静态库，则默认会使用共享库。为了强制使用静态库，可以使用以下方法之一：</p>
<p>　　● 在使用命令<code>gcc</code>时指定静态库的路径名
(包含后缀<code>.a</code>)。</p>
<p>　　● 在使用命令<code>gcc</code>时指定选项<code>-static</code>。</p>
<p>　　●
在使用命令<code>gcc</code>时指定选项<code>–Wl,–Bstatic</code>或<code>–Wl,–Bdynamic</code>来显式地让链接器选择静态库或动态库。这些选项可以与选项<code>-l</code>一起使用。链接器将按照指定的顺序处理这些选项。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>《Linux/UNIX系统编程手册》第44章 无名管道和有名管道</title>
    <url>/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/</url>
    <content><![CDATA[<p>　　无名管道是UNIX系统上最古老的IPC方式，出现于20世纪70年代早期的UNIX第3版中。无名管道为常见需求提供了精简的解决方法：创建2个进程来允许不同程序
(命令)。无名管道可用于相关进程之间的通信。有名管道是无名管道的变体，但可用于任意进程之间的通信。</p>
<p>　　命令<code>ls | wc -l</code>会统计目录下的文件数。为了执行该命令，shell会创建2个进程来分别执行<code>ls</code>和<code>wc</code>。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/using_a_pipe_to_connect_two_processes.svg" class="">
<p>　　上图说明了无名管道名称的由来——可以将无名管道看作管道系统，允许数据从进程流向其他进程。</p>
<p>　　从无名管道读取数据的进程可以读取任意大小的字节块
(无论写入进程写入的数据块的大小)。此外，数据在无名管道中按序传输——字节的读取顺序和写入顺序完全一致，所以无法使用<code>lseek()</code>随机访问其中的数据。</p>
<p>　　对当前为空的无名管道的读取操作会被阻塞，直到至少有1个字节被写入到该无名管道。当无名管道写入端关闭后，一旦读取端读取完无名管道中的剩余数据，就会遇到EOF
(<code>read()</code>返回0)。</p>
<p>　　无名管道是单向的，但某些UNIX实现 (尤其是System V Release
4衍生实现) 的无名管道是双向的 (即所谓的<span
style="background-color: yellow">流无名管道</span>)。没有UNIX标准说明双向无名管道，所以应该避免依赖其语义
(即使是那些提供它的实现)。作为替代方案，可以使用UNIX域套接字对
(通过系统调用<code>socketpair()</code>创建)，它提供了标准双向通信机制，其语义等同于流无名管道。</p>
<p>　　当多个进程向同一无名管道写入时，只要单次写入的数据不超过<code>PIPE_BUF</code>字节，写入的数据就不会交错。</p>
<p>　　SUSv3要求<code>PIPE_BUF</code>至少为<code>_POSIX_PIPE_BUF</code>
(512)。实现应该在头文件<code>limits.h</code>中定义<code>PIPE_BUF</code>或/和允许调用<code>fpathconf(fd, _PC_PIPE_BUF)</code>返回原子写入的实际上限。<code>PIPE_BUF</code>因UNIX实现而异
(例如，FreeBSD 6.0是512，Tru64 5.1是4096，Solaris
8是5120)。对于Linux，其值为4096。</p>
<p>　　当写入到无名管道的数据块大于<code>PIPE_BUF</code>字节时，内核会将其转换为多个较小的数据块传输，并在读取进程从无名管道中读取字节时追加数据
(<code>write()</code>调用会被阻塞，直到所有数据都被写入到数据)。当只有1个进程向无名管道写入时，这不会导致问题。但是，当存在多个写入进程时，较大的数据块的写入会被分成任意大小的块
(可能小于<code>PIPE_BUF</code>字节)，并与其他进程的写入交错进行。</p>
<p>　　限制<code>PIPE_BUF</code>决定数据传输到无名管道的具体时间。当写入的数据不超过该限制时，若无名管道中没有足够的空间以便原子地完成操作，则<code>write()</code>将会被阻塞来等待空间。当写入的数据超过该限制时，<code>write()</code>将传输尽可能多的数据来填满无名管道，然后被阻塞，直到无名管道中的数据被读取。当以这种方式被阻塞的<code>write()</code>被信号处理函数中断时，<code>write()</code>会解除阻塞并返回成功写入的字节数，该值小于请求的字节数
(即所谓的<span style="background-color: yellow">部分写入</span>)。</p>
<p>　　对于Linux
2.2，向无名管道写入任意数据都是以原子方式完成，除非被信号处理函数中断。对于Linux
2.4及以上版本，若向无名管道写入的数据大于<code>PIPE_BUF</code>字节，则可能与其他进程的写入操作交错进行
(在内核版本2.2和2.4之间，实现无名管道的内核代码发生了重大变化)。</p>
<span id="more"></span>
<p>　　无名管道只是内核内存中的缓冲区，该缓冲区有容量限制。一旦达到上限，对无名管道的写入会被阻塞，直到其中的数据被读取。</p>
<p>　　SUSv3没有要求无名管道的容量。在Linux
2.6.11之前，无名管道容量与系统页大小 (x86-32的页大小是4096字节)
相同。从Linux
2.6.11开始，无名管道的容量为65536字节。UNIX实现的无名管道容量各不相同。</p>
<p>　　应用程序通常不需要知道无名管道的具体容量。为了防止写入进程被阻塞，读取进程应该被设计为尽可能快地从无名管道中读取数据。</p>
<p>　　从理论角度，无名管道完全可以以更小的容量运行，即使是单字节缓冲区。但是，使用更大的缓冲区可以提升效率。当写入进程填满无名管道后，内核必须执行上下文切换来让读取进程读取。使用更大的缓冲区表示所需的上下文切换次数更少。</p>
<p>　　从Linux
2.6.35开始，无名管道的容量可以被修改。特定于Linux的调用<code>fcntl(fd, F_SETPIPE_SZ, size)</code>会将<code>fd</code>引用的无名管道的容量修改为不小于<code>size</code>字节，内核会将<code>size</code>向上取整到某个便于实现的值。非特权进程可以将无名管道的容量修改为从系统页大小到<code>/proc/sys/fs/pipe-max-size</code>中的值之间的任意值。<code>pipe-max-size</code>的默认值为1048576字节。特权进程
(能力<code>CAP_SYS_RESOURCE</code>)
可以超过该限制。调用<code>fcntl(fd, F_GETPIPE_SZ)</code>会返回为无名管道分配的空间的实际大小。</p>
<h3 id="无名管道">44.1 无名管道</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> filedes[<span class="number">2</span>])</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　系统调用<code>pipe()</code>会创建无名管道。若成功，则会通过数组<code>filedes</code>返回2个打开的文件描述符，分别用于无名管道的读取端
(<code>filedes[0]</code>) 和写入端 (<code>filedes[1]</code>)。</p>
<p>　　与其他文件描述符相同，可以对<code>pipe()</code>返回的文件描述符调用<code>read()</code>和<code>write()</code>。一旦向无名管道写入端写入数据，数据会立即到达读取端。当从无名管道读取数据时，会获取请求字节数与当前无名管道中可用字节数中较小的值
(若无名管道为空，则会被阻塞)。此外，可以先使用<code>fopen()</code>获取与<code>filedes</code>中某个文件描述符对应的文件流，然后使用stdio函数
(例如，<code>printf()</code>和<code>scanf()</code>) 来操作无名管道。</p>
<p>　　<code>ioctl(fd, FIONREAD, &amp;cnt)</code>调用会返回<code>fd</code>引用的无名管道或有名管道的待读取字节数。某些其他实现也支持该特性，但SUSv3没有说明该特性。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/setting_up_a_pipe_to_transfer_data_from_a_parent_to_a_child.svg" class="">
<p>　　对于单个进程，无名管道的用途很少。无名管道通常用于2个进程之间的通信。为了使用无名管道连接2个进程，需要在调用<code>pipe()</code>后调用<code>fork()</code>。在<code>fork()</code>期间，子进程会继承父进程的文件描述符的副本
(上图左侧的情况)。虽然父进程和子进程都可以读写无名管道，但这并不常见。因此，当<code>fork()</code>完成后，其中的某个进程立即关闭无名管道写入端的文件描述符，而另一个会立即关闭无名管道读取端的文件描述符
(上图右侧的情况)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> filedes[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建无名管道 */</span></span><br><span class="line"><span class="keyword">if</span> (pipe(filedes) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (fork())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">    errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程：关闭无名管道写入端 */</span></span><br><span class="line">    <span class="keyword">if</span> (close(filedes[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 从无名管道读取 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 父进程：关闭无名管道读取端 */</span></span><br><span class="line">    <span class="keyword">if</span> (close(filedes[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向无名管道写入 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　父进程和子进程都从无名管道读取的情况不常见的原因之一是2个进程同时读取会导致竞争，防止这种竞争需要同步机制。更简单的方法是创建2个无名管道，分别用于2个进程之间的双向数据传输
(这种方法需要注意2个进程在试图读取空无名管道或写入已满的无名管道时被阻塞而导致的死锁)。</p>
<p>　　虽然多个进程可以向同一无名管道写入，但通常只有1个写入进程。相比之下，多个进程写入同一有名管道有时会很有用。</p>
<p>　　从内核2.6.27开始，Linux支持非标准系统调用<code>pipe2()</code>。该系统调用执行与<code>pipe()</code>相同的任务，但支持可用于修改其行为的参数<code>flags</code>。该参数支持标志：<code>O_CLOEXEC</code>
(启用返回的2个文件描述符的close-on-exec标志) 和 <code>O_NONBLOCK</code>
(用于设置返回的2个文件描述符的打开文件状态标志<code>O_NONBLOCK</code>)。</p>
<p>　　实际上，无名管道也可用于多个相关进程之间的通信。只要无名管道是共同的祖先进程在通过<code>fork()</code>创建子进程前创建的，该无名管道就可以用于多个相关进程之间的通信。此外，通过UNIX域套接字将无名管道的文件描述符传递给无关进程就可以实现无关进程之间的通信。</p>
<p>　　关闭未使用的无名管道文件描述符不仅仅是为了确保进程不会耗尽其有限的文件描述符集合——这对于正确使用无名管道至关重要。</p>
<p>　　●
读取进程会关闭无名管道的写入文件描述符。因此，当写入进程完成写入并关闭其写入文件描述符后，读取进程会遇到EOF
(一旦从无名管道读取所有数据)。若读取进程没有关闭无名管道的写入文件描述符，则即使写入进程关闭了其写入文件描述符，读取进程也无法遇到EOF
(即使它已从无名管道中读取所有数据)。相反，<code>read()</code>会被阻塞
(等待数据)，因为内核知道无名管道至少有1个打开的写入文件描述符。这个写入文件描述符是否由读取进程打开并不重要。从理论角度，即使读取进程被阻塞，它仍然可以向无名管道写入数据。</p>
<p>　　●
写入进程关闭无名管道的读取文件描述符的原因有所不同。当写入进程试图写入没有进程拥有打开的读取文件描述符的无名管道时，内核会向写入进程发送信号<code>SIGPIPE</code>。在默认情况下，该信号会终止进程。进程可以捕获或忽略该信号。在这种情况下，对无名管道的<code>write()</code>会出错
(<code>EPIPE</code>)。收到信号<code>SIGPIPE</code>或错误<code>EPIPE</code>可以有效地指示无名管道的状态，所以应该关闭无名管道未使用的读取文件描述符。若写入进程没有关闭无名管道的读取文件描述符，则即使其他进程关闭了无名管道的读取文件描述符，写入进程仍然可以写入无名管道。最终，写入进程会填满无名管道，后续对无名管道的写入都会被无期限地阻塞。</p>
<p>　　●
当且仅当所有进程中引用无名管道的所有文件描述符都关闭后，无名管道才会被销毁，其资源会被释放以供其他进程重用。此时，无名管道中任何未读取的数据都会丢失。</p>
<p>　　在默认情况下，当<code>write()</code>等慢系统调用被信号处理函数中断时，调用要么自动重启，要么出错
(<code>EINTR</code>)，具体取决于调用<code>sigaction()</code>注册信号处理函数时是否使用了标志<code>SA_RESTART</code>。<code>SIGPIPE</code>信号处理函数的情况则有所不同，因为自动重启<code>write()</code>或仅仅指示<code>write()</code>被中断都没有意义。无论哪种情况，后续的<code>write()</code>调用都无法完成，因为无名管道仍然出于断开状态
(broken pipe)。</p>
<h4 id="将无名管道用于进程间通信">44.1.1 将无名管道用于进程间通信</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* simple_pipe.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pfd[<span class="number">2</span>]; <span class="comment">/* 无名管道文件描述符 */</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> numRead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s string\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建无名管道 */</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pfd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程：从无名管道读取 */</span></span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close - child&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从无名管道读取数据，然后在stdout中回显 */</span></span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            numRead = read(pfd[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (write(STDOUT_FILENO, buf, numRead) != numRead)</span><br><span class="line">            &#123;</span><br><span class="line">                fatal(<span class="string">&quot;child - partial/failed write&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(STDOUT_FILENO, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程：向无名管道写入 */</span></span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close - parent&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pfd[<span class="number">1</span>], argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>])) != <span class="built_in">strlen</span>(argv[<span class="number">1</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;parent - partial/failed write&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>) <span class="comment">/* 子进程会遇到EOF */</span></span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">/* 等待子进程完成 */</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了父进程和子进程如何通过无名管道通信以及无名管道的字节流特性——父进程一次性写入数据，而子进程以小数据块的形式读取数据。</p>
<p>　　该程序会先调用<code>pipe()</code>来创建无名管道
(第19~22行)，然后调用<code>fork()</code>创建子进程。父进程会在创建子进程后关闭无名管道的读取文件描述符，然后将命令行参数指定的字符串写入到无名管道并关闭无名管道的写入文件描述符，最后等待子进程终止
(第63~80行)。当子进程关闭无名管道的写入文件描述符后，开始循环读取<code>BUF_SIZE</code>字节的数据块并将它们写入到标准输出
(直到遇到EOF)，然后写入换行符，最后关闭无名管道的读取文件描述符并终止
(第29~61行)。</p>
<h4 id="将无名管道用于进程同步">44.1.2 将无名管道用于进程同步</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pipe_sync.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span> <span class="comment">/* 函数currTime()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pfd[<span class="number">2</span>]; <span class="comment">/* 进程同步无名管道 */</span></span><br><span class="line">    <span class="type">int</span> j, dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s sleep-time...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲，因为这里通过_exit()终止子进程 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s Parent started\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pfd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (fork())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork %d&quot;</span>, j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 */</span></span><br><span class="line">            <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sleep(getInt(argv[j], GN_NONNEG, <span class="string">&quot;sleep-time&quot;</span>)); <span class="comment">/* 模拟执行任务 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s Child %d (PID=%ld) closing pipe\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), j, (<span class="type">long</span>)getpid());</span><br><span class="line">            <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 子进程继续执行其他任务 */</span></span><br><span class="line"></span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* 父进程循环创建子进程 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(pfd[<span class="number">0</span>], &amp;dummy, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;parent didn&#x27;t get EOF&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s Parent ready to go\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程继续执行其他任务 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了父进程和子进程如何通过无名管道同步。该程序会创建多个子进程
(每个命令行参数对应1个子进程)，所有子进程都会完成某些操作
(通过睡眠模拟)。父进程会等待所有子进程完成其操作。</p>
<p>　　为了进行同步，父进程会先创建无名管道
(第18~21行)，然后创建子进程，子进程会继承无名管道的写入文件描述符，子进程会在完成其操作后关闭该文件描述符
(第30~45行)。当所有子进程都关闭无名管道的写入文件描述符后，父进程对无名管道调用的<code>read()</code>会遇到EOF。此时，父进程可以继续执行其他任务。这里父进程关闭无名管道的写入文件描述符至关重要，否则父进程会永远被阻塞
(第52~65行)。</p>
<p>　　相比使用信号进行同步，使用无名管道进行同步的优势之一是可以协调单个进程与多个其他进程的行为。因为标准信号不会排队，所以标准信号不适用于这种情况
(相反，标准信号的优势之一是它可以被单个进程发送给进程组中的所有进程)。</p>
<p>　　其他同步拓扑也是可能的
(例如，使用多个无名管道)。此外，这种技术可以扩展，使得每个子进程不关闭无名管道，而是向其中写入包含进程ID和某些状态的信息。或者，每个子进程向无名管道写入1字节。父进程随后可以统计和分析这些消息。这种方法可以防止子进程意外终止
(而非显式地关闭管道)。</p>
<h4 id="使用无名管道连接过滤器">44.1.3 使用无名管道连接过滤器</h4>
<p>　　当创建无名管道时，两端的文件描述符是可用的编号最小的文件描述符。文件描述符0~2通常已被使用，所以无名管道的文件描述符的编号通常较大。为了达到类似于命令<code>ls | wc -l</code>的效果，即2个过滤器
(从标准输入读取数据并将其写入到标准输出的程序)
通过无名管道连接，使得其中1个程序的标准输出被定向到无名管道，而另一个程序的标准输入则从无名管道获取数据，需要进行文件描述符复制
(见5.3)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pipe_ls_wc.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pfd[<span class="number">2</span>]; <span class="comment">/* 无名管道 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pfd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 第1个子进程：执行命令ls写入无名管道 */</span></span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将标准输出复制给无名管道写入端并关闭未使用的文件描述符 */</span></span><br><span class="line">        <span class="keyword">if</span> (pfd[<span class="number">1</span>] != STDOUT_FILENO) <span class="comment">/* 防御性检查 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dup2(pfd[<span class="number">1</span>], STDOUT_FILENO) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;dup2 1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;close 2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>); <span class="comment">/* 写入无名管道 */</span></span><br><span class="line">        errExit(<span class="string">&quot;execlp ls&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程继续创建子进程 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 第2个子进程：执行命令ws读取无名管道 */</span></span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close 3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将标准输入复制给无名管道读取端并关闭未使用的文件描述符 */</span></span><br><span class="line">        <span class="keyword">if</span> (pfd[<span class="number">0</span>] != STDIN_FILENO) <span class="comment">/* 防御性检查 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dup2(pfd[<span class="number">0</span>], STDIN_FILENO) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;dup2 2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;close 4&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        execlp(<span class="string">&quot;wc&quot;</span>, <span class="string">&quot;wc&quot;</span>, <span class="string">&quot;-l&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>); <span class="comment">/* 读取无名管道 */</span></span><br><span class="line">        errExit(<span class="string">&quot;execlp wc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程继续执行 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭未使用的文件描述符并等待子进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close 5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close 6&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait(<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;wait 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait(<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;wait 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了如何使用无名管道连接过滤器。当创建无名管道后，该程序会创建2个子进程。第1个子进程会将其标准输出绑定到无名管道写入端并执行命令<code>ls</code>。第2个子进程会将其标准输入绑定到无名管道读取端并执行命令<code>wc</code>。</p>
<h4 id="popen和pclose">44.1.4
<code>popen()</code>和<code>pclose()</code></h4>
<p>　　无名管道的常见用途之一是执行shell命令并读取其输出或向其发送输入。函数<code>popen()</code>和<code>pclose()</code>简化了这一任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *mode)</span>; <span class="comment">/* 成功时返回文件流，出错时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>; <span class="comment">/* 成功时返回子进程的终止状态，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>popen()</code>会创建无名管道并创建子进程来执行shell，shell又会创建子进程来执行字符串<code>command</code>。参数<code>mode</code>用于指定无名管道的数据方向，其值必须包含<code>r</code>或<code>w</code>。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/overview_of_process_relationships_and_pipe_usage_for_popen.svg" class="">
<p>　　●
当<code>mode</code>为<code>r</code>时，表示调用进程从无名管道读取
(执行的命令的标准输出连接到无名管道写入端)。</p>
<p>　　●
当<code>mode</code>为<code>w</code>时，表示调用进程向无名管道写入
(执行的命令的标准输入连接到无名管道读取端)。</p>
<p>　　当<code>popen()</code>成功调用时，会返回可与stdio库函数一起使用的文件流指针。若出错
(例如，<code>mode</code>值无效、无名管道创建失败以及<code>fork()</code>创建子进程失败)，则返回<code>NULL</code>并设置<code>errno</code>。</p>
<p>　　当<code>popen()</code>调用后，调用进程可通过无名管道来读取<code>command</code>的输出或向其发送输入。与<code>pipe()</code>创建的无名管道相同，若调用进程读取<code>popen()</code>创建的无名管道时<code>command</code>关闭了无名管道写入端，则调用进程会遇到EOF；若调用进程读取<code>popen()</code>创建的无名管道时<code>command</code>关闭了无名管道写入端，则调用进程会收到信号<code>SIGPIPE</code>并出错
(<code>EPIPE</code>)。</p>
<p>　　当I/O完成后，函数<code>pclose()</code>可用于关闭无名管道并等待子shell终止。若成功调用时，则会返回子shell的终止状态
(见27.5)。与<code>system()</code>相同，若无法执行shell，则<code>pclose()</code>的返回值就像子shell通过调用<code>_exit(127)</code>终止一样。若出现了其他错误
(例如，无法获取终止状态)，则<code>pclose()</code>会返回-1。</p>
<p>　　当执行等待来获取子shell的状态时，SUSv3要求<code>pclose()</code>应该在对<code>waitpid()</code>的内部调用被信号处理函数中断时重启该调用
(如同<code>system()</code>)。</p>
<p>　　<code>popen()</code>会创建无名管道、复制文件描述符、关闭未使用的文件描述符以及处理<code>fork()</code>和<code>exec()</code>的细节，并且命令由shell处理。这种便利性是以效率为代价的，该函数至少会创建2个额外的进程：1个进程用于shell，其他进程用于shell执行的命令。与<code>system()</code>相同，<code>pclose()</code>永远不应该在特权程序中使用。</p>
<p>　　尽管<code>popen()</code>与<code>pclose()</code>的组合与<code>system()</code>之间有若干个相同之处，但也存在多个显著差异。这是因为使用<code>system()</code>时shell命令的执行被封装在单个函数调用中，而使用<code>popen()</code>时调用进程与shell命令并行运行，然后调用<code>pclose()</code>。这些差异如下：</p>
<p>　　●
由于调用进程和被执行的命令并行运行，SUSv3要求<code>popen()</code>不应该忽略信号<code>SIGINT</code>和<code>SIGQUIT</code>。若这些信号由键盘生成，则它们会发送给调用进程和被执行的命令。这是因为这2个进程位于同一进程组，而终端生成的信号会被发送给前台进程组的所有进程。</p>
<p>　　●
由于调用进程可能会在<code>popen()</code>和<code>pclose()</code>执行之间创建其他子进程，SUSv3要求<code>popen()</code>不应该阻塞信号<code>SIGCHLD</code>。这表示若调用进程在调用<code>pclose()</code>之前执行等待操作，则它可能会得到<code>popen()</code>创建的子进程的终止状态。在这种情况下，当后续调用<code>pclose()</code>时，会返回-1并将<code>errno</code>设置为<code>ECHILD</code>
(表示无法获取子进程的状态)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* popen_glob.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_wait_status.h&quot;</span> <span class="comment">/* 函数printWaitStatus()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POPEN_FMT <span class="string">&quot;/bin/ls -d %s 2&gt; /dev/null&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAT_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCMD_BUF_SIZE (sizeof(POPEN_FMT) + PAT_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> pat[PAT_SIZE]; <span class="comment">/* glob模式 */</span></span><br><span class="line">    <span class="type">char</span> popenCmd[PCMD_BUF_SIZE];</span><br><span class="line">    FILE *fp;           <span class="comment">/* popen()返回的文件流指针 */</span></span><br><span class="line">    Boolean badPattern; <span class="comment">/* 模式中是否包含无效字符 */</span></span><br><span class="line">    <span class="type">int</span> len, status, fileCnt, j;</span><br><span class="line">    <span class="type">char</span> pathname[PATH_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取glob模式，展示globbing结果 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pattern: &quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(pat, PAT_SIZE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">strlen</span>(pat);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 空行 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pat[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pat[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 去除结尾的换行符 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 为了确保仅包含有效字符，即字母、数字、下划线、点号以及shell通配符 (这里有效</span></span><br><span class="line"><span class="comment">           字符的定义比shell更严格，shell允许其他字符，只要这些字符用括号括起来即可) */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, badPattern = FALSE; j &lt; len &amp;&amp; !badPattern; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>((<span class="type">unsigned</span> <span class="type">char</span>)pat[j]) &amp;&amp; <span class="built_in">strchr</span>(<span class="string">&quot;_*?[^-].&quot;</span>, pat[j]) == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                badPattern = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (badPattern)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Bad pattern character: %c\n&quot;</span>, pat[j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 构建和执行命令来展开pat */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(popenCmd, PCMD_BUF_SIZE, POPEN_FMT, pat);</span><br><span class="line">        popenCmd[PCMD_BUF_SIZE - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 确保字符串以\0结尾 */</span></span><br><span class="line">        fp = popen(popenCmd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;popen() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 读取路径名列表的结果，直到遇到EOF */</span></span><br><span class="line">        fileCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fgets(pathname, PATH_MAX, fp) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, pathname);</span><br><span class="line">            fileCnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 关闭无名管道并展示终止状态 */</span></span><br><span class="line">        status = pclose(fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;	%d matching file%s\n&quot;</span>, fileCnt, (fileCnt != <span class="number">1</span>) ? <span class="string">&quot;s&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;	pclose() status == %#x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)status);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printWaitStatus(<span class="string">&quot;\t&quot;</span>, status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这个示例展示了<code>popen()</code>和<code>pclose()</code>的用法。该程序会反复读取文件名通配符模式
(第25~38行)，然后通过<code>popen()</code>来获取结果并将其传递给命令<code>ls</code>
(第59~72行)。在库函数<code>glob()</code>出现之前，早期的UNIX实现使用了类似的技术来进行文件名生成
(也称为<span style="background-color: yellow">globbing</span>)。</p>
<p>　　用于globbing的命令构造 (第7和57行)
需要一些说明。模式匹配实际由shell执行，命令<code>ls</code>仅用于列出匹配结果。这里似乎可以使用命令<code>echo</code>，但这会产生不理想的结果：若模式没有匹配结果，shell会保持原模式不变，而<code>echo</code>只会简单地显示该模式。相比之下，<code>ls</code>在这种情况下仅会在标准错误上打印错误信息
(这里将标准错误重定向到<code>/dev/null</code>来处理) 并以状态1退出。</p>
<p>　　第42~54行的输入检查是为了防止无效输入导致<code>popen()</code>执行意外的shell命令。假设没有这些检查，若用户输入<code>; rm *</code>，则传递给<code>popen()</code>的命令将会是<code>/bin/ls -d ; rm * 2&gt; /dev/null</code>，这会导致灾难性后果。对于使用<code>popen()</code>
(或<code>system()</code>)
执行由用户输入构建的shell命令时，始终需要这样的输入检查
(或者应用程序对除正在检查的字符之外的所有字符都用引号括起来，这样shell就不会对这些字符进行特殊处理)。</p>
<p>　　以下shell会话展示了该程序的用法
(这里先提供了匹配2个文件名的模式，然后提供了无匹配结果的模式)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./popen_glob</span> </span><br><span class="line">pattern: popen_glob*</span><br><span class="line">popen_glob</span><br><span class="line">popen_glob.c</span><br><span class="line">    2 matching files</span><br><span class="line">    pclose() status == 0</span><br><span class="line">        child exited, status=0</span><br><span class="line">pattern: x*</span><br><span class="line">    0 matching files</span><br><span class="line">    pclose() status == 0x100</span><br><span class="line">        child exited, status=1</span><br><span class="line">pattern: ^D$</span><br></pre></td></tr></table></figure>
<h4 id="无名管道与stdio缓冲">44.1.5 无名管道与stdio缓冲</h4>
<p>　　<code>popen()</code>返回的文件流指针不会引用终端，所以stdio库函数会对其指向的文件流使用块缓冲
(见13.2)。这表示若调用<code>popen()</code>时将<code>mode</code>指定为<code>w</code>，则在默认情况下，只有stdio缓冲区被填满或调用<code>pclose()</code>时无名管道另一端的子进程才会收到进程。为了保证子进程立即收到数据，可以周期性地调用<code>fflush()</code>或调用<code>setbuf(fp, NULL)</code>禁用stdio缓冲。当先使用<code>pipe()</code>打开无名管道，再使用<code>fpopen()</code>获取无名管道写入端对应的stdio流时，也可以使用这种方法。</p>
<p>　　若进程调用<code>popen()</code>时将<code>mode</code>指定为<code>r</code>，并且子进程使用的是stdio库，则只有子进程显式调用<code>fflusth()</code>或<code>setbuf()</code>后，调用进程才能访问其输出
(当读取<code>pipe()</code>创建的无名管道时，若写入进程使用的是stdio库，则同样的道理也适用)。若这会导致问题，则只能修改程序的源代码，使子进程调用<code>fflusth()</code>或<code>setbuf()</code>
(若无法修改源代码，则可以不使用无名管道，而使用伪终端。对于一端的进程，伪终端就像终端，所以stdio库会使用行缓冲输出)。</p>
<h3 id="有名管道">44.2 有名管道</h3>
<p>　　从语义角度，有名管道类似于无名管道。主要区别是有名管道在文件系统中有名称，并且可以通过与普通文件相同的方式打开。这使得有名管道可用于不相关进程
(例如，客户端和服务端) 之间的通信。</p>
<p>　　当打开有名管道后，可以使用与无名管道和其他文件一起使用的I/O系统调用
(例如，<code>read()</code>和<code>write()</code>)。与无名管道相同，有名管道包含读取端和写入端，数据的读取顺序与写入顺序相同。有名管道的另一个名称
"先进先出" 便源于该特性。</p>
<p>　　与无名管道相同，当所有引用有名管道的文件描述符都关闭后，其中的所有数据都会丢失。</p>
<p>　　命令<code>mkfifo</code>可用于创建有名管道：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> [ -m mode ] pathname</span></span><br></pre></td></tr></table></figure>
<p>　　<code>pathname</code>是有名管道的名称。选项<code>-m</code>用于以与命令<code>chmod</code>的相同方式指定权限<code>mode</code>。</p>
<p>　　当对有名管道 (或无名管道)
调用<code>fstat()</code>和<code>stat()</code>时，返回的结构体<code>stat</code>的成员<code>st_mode</code>为<code>S_IFIFO</code>。当使用命令<code>ls -l</code>时，有名管道的第1列显示为了类型<code>p</code>，而<code>ls -F</code>会在有名管道路径名后附加管道符号<code>|</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure>
<p>　　函数<code>mkfifo()</code>会创建名为<code>pathname</code>的有名管道。参数<code>mode</code>用于指定有名管道的权限，其值为15.4.1的表格中的常量进行或运算<code>|</code>得到的结果。</p>
<p>　　从历史角度，有名管道是通过调用<code>mknod(pathname, S_FIFO, 0)</code>创建的。POSIX.1-1990详细说明了更简洁的API，从而避免了<code>mknod()</code>的通用性，后者允许创建各种类型的文件，包括设备文件
(SUSv3详细说明了<code>mknod()</code>，但仅定义了用于创建有名管道的用途)。大多数UNIX实现都将<code>mkfifo()</code>作为基于<code>mknod()</code>的库函数提供。</p>
<p>　　当创建有名管道后，所有进程都可以打开它，但需要遵守常规的文件权限检查规则
(见15.4.3)。</p>
<p>　　打开有名管道的语义有些特殊。通常，有名管道唯一合理的用途是在两端设置读取进程和写入进程。因此，在一般情况下，以读取方式打开有名管道
(使用<code>open()</code>的标志<code>O_RDONLY</code>)
会被阻塞，直到其他进程以写入方式打开有名管道
(使用<code>open()</code>的标志<code>O_WRONLY</code>)。相反，以写入方式打开有名管道也会被阻塞，直到其他进程以读取方式打开有名管道。换句话说，打开有名管道会同步读取进程和写入进程。若有名管道的另一端已经打开
(可能因为一对进程已经打开了有名管道的两端)，则<code>open()</code>会立即成功。</p>
<p>　　对于Linux和大多数UNIX实现，通过在打开有名管道时指定标志<code>O_RDWR</code>，可以防止被阻塞。此时，<code>open()</code>会立即返回可用于读写有名管道的文件描述符。这样做实际上颠覆了有名管道的I/O模型，而且SUSv3明确指出，用标志<code>O_RDWR</code>打开有名管道的行为是未定义的。因此，出于可移植性的考虑，应该避免使用这种方法。为了防止打开有名管道时被阻塞，可以使用<code>open()</code>的标志<code>O_NONBLOCK</code>。</p>
<p>　　打开有名管道应避免使用标志<code>O_RDWR</code>还有另一个原因。若以这种方式调用<code>open()</code>，则调用进程在读取结果文件描述符时不会遇到EOF，因为始终至少有1个文件描述符可用于写入有名管道——该文件描述符自己。</p>
<h4 id="使用有名管道和命令tee来创建双管道">44.2.1
使用有名管道和命令<code>tee</code>来创建双管道</h4>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/using_a_fifo_and_command_tee_to_create_a_dual_pipeline.svg" class="">
<p>　　shell管道的特点之一是线性：每个进程会读取上一个进程产生的数据，并将其发送给下一个进程。通过有名管道，可以在管道中创建分支，使得进程的输出副本除了发送给管道中的下一个进程之外，还可以发送给另一个进程。为了实现这一点，还需要命令<code>tee</code>，它会将从标准输入读取的内容写入到2个地方：标准输出和命令行参数指定的文件。</p>
<p>　　通过将<code>tee</code>的参数<code>file</code>设置为有名管道，可以实现2个进程同时读取<code>tee</code>产生的重复输出。以下shell会话展示了这一点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> myfifo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> -l &lt; myfifo &amp;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | <span class="built_in">tee</span> myfifo | <span class="built_in">sort</span> -k5n</span></span><br></pre></td></tr></table></figure>
<p>　　第1行命令会创建有名管道<code>myfifo</code>。第2个命令会在后台执行命令<code>wc</code>，该命令以读取方式打开该有名管道
(该操作会被阻塞，直到该有名管道被以写入方式打开)。第3行命令会执行管道，将<code>ls</code>的输出发送给<code>tee</code>，而<code>tee</code>同时将其输出传递给有名管道<code>myfifo</code>以及管道的下一个命令<code>sort</code>
(<code>sort</code>的选项<code>-k5n</code>会使<code>ls</code>的输出按第5个以空格分隔的字段的数值升序排序)。</p>
<p>　　程序<code>tee</code>之所以得名，是因为其形状。该程序可以被视为类似于无名管道，但它多了1个用于发送重复输出的分支。如上图所示，其形状就像大写的字母T。除了这里描述的用途之外，该程序还可以用于调试管道以及保存复杂管道中某个中间点产生的结果。</p>
<h4 id="使用有名管道的客户端-服务端应用程序">44.2.2
使用有名管道的客户端-服务端应用程序</h4>
<p>　　这里将实现通过有名管道进行IPC的简单客户端-服务器应用程序。所有客户端会使用同一服务器有名管道来向服务器发送请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* fifo_seqnum.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_FIFO <span class="string">&quot;/tmp/seqnum_sv&quot;</span>                             <span class="comment">/* 服务器有名管道的知名名称 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_FIFO_TEMPLATE <span class="string">&quot;/tmp/seqnum_cl.%ld&quot;</span>                <span class="comment">/* 构建客户端有名管道名称的模板 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_FIFO_NAME_LEN (sizeof(CLIENT_FIFO_TEMPLATE) + 20) <span class="comment">/* 客户端有名管道路径名所需的空间 (+20是为PID预留) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请求 (客户端 -&gt; 服务器) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">pid_t</span> pid;  <span class="comment">/* 客户端PID */</span></span><br><span class="line">    <span class="type">int</span> seqLen; <span class="comment">/* 序列的长度 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 响应 (服务器 -&gt; 客户端) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">response</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> seqNum; <span class="comment">/* 序列的起始值 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　头文件<code>fifo_seqnum.h</code>定义了服务器有名管道的知名名称。该名称是固定的，以便所有客户端都知道如何联系服务器
(这里将在目录<code>/tmp</code>下创建有名管道，因为这样可以保证程序直接在大多数系统上运行。但是，在<code>/tmp</code>等公共可写的目录下创建文件可能导致安全漏洞，在实际应用程序中应该避免这样做)。</p>
<p>　　但是，不可能使用单个有名管道向所有客户端发送响应，因为这会导致客户端之间竞争，并且可能会读取其他客户端的响应消息，而非自己的响应消息。因此，所有客户端都会创建唯一的有名管道，服务器使用该有名管道向客户端发送响应，而服务器需要知道如何找到客户端的有名管道。客户端生成其有名管道路径名，然后将该路径名作为请求消息的一部分传递。或者，客户端和服务器约定构建客户端有名管道路径名的规则，客户端在请求中将构建该客户端专属路径名所需的信息传递给服务器。这里使用第2个方法，所有客户端的有名管道的名称都基于模板构建，该模板包含客户端的进程ID
(包含进程ID可以方便地生成唯一的有名管道名称)。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/using_fifos_in_a_single-server,multiple-client_application.svg" class="">
<p>　　头文件<code>fifo_seqnum.h</code>也定义了客户端发送给服务器的请求消息的格式以及服务器发送给客户端的响应消息的格式。由于无名管道和有名管道中的数据是字节流，多条消息之间的边界不会被保留。这表示当多条消息被发送给同一进程时，发送端和接收端之间必须约定分隔消息的方法。分隔消息可以采用各种方法：</p>
<p>　　● 所有消息以<span
style="background-color: yellow">分隔符</span>结尾。在这种情况下，要么消息不能包含分隔符，要么转义分隔符
(以换行符作为分隔符为例，字符<code>\</code>加上换行符表示消息内的换行符，<code>\\</code>表示消息内的<code>\</code>)。这种方法的缺点之一是读取端必须每次读取1个字节，直到找到分隔符。</p>
<p>　　● 加上<span
style="background-color: yellow">长度固定的包含长度字段的首部</span>，长度字段表示消息剩余部分的长度。在这种情况下，读取端需要先读取首部，再使用其中的长度字段获取消息剩余部分的长度。这种方法的优点是可以高效地处理任意长度的消息，但格式错误的消息可能会导致问题。</p>
<p>　　● 使用<span
style="background-color: yellow">长度固定的消息</span>。这种方法的优点是程序简单。但是，这限制了消息的长度，所以会浪费部分信道容量
(因为较短的信息必须填充到固定长度)。此外，若某个客户端发送了长度错误的消息，则后续的所有消息都会失去同步，进而导致服务器难以恢复。</p>
<p>　　无论使用哪种方法，消息的整体长度必须小于<code>PIPE_BUF</code>字节，以防止消息被内核拆分并与其他写入进程的消息交错。</p>
<p>　　除了所有客户端的消息共用同一信道 (有名管道) 之外，还可以让<span
style="background-color: yellow">每条信息使用独立的连接</span>。发送端打开通信信道，发送消息，然后关闭信道。当接收端遇到EOF，表示消息结束。若多个发送端同时打开同一信道，则这种方法不可行，因为当仅其中某个发送端关闭信道时，接收端不会遇到EOF。但是，当使用流套接字时，这种方法是可行的，在这种情况下，服务器会为每个客户端连接创建唯一的通信信道。</p>
<p>　　对于示例应用程序，将使用长度固定的消息。消息由结构体<code>request</code>定义。所有请求都包含客户端的进程ID，这使得服务器能够构建客户端用于接收响应的有名管道的名称。请求还包含字段<code>seqLen</code>，用于指定应分配给该客户端的序列号数量。服务器发送给客户端的响应仅包含字段<code>seqNum</code>，它是分配给该客户端的序列号范围的起始值。</p>
<h5 id="服务器程序">44.2.2.1 服务器程序</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* fifo_seqnum_server.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fifo_seqnum.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serverFd, dummyFd, clientFd;</span><br><span class="line">    <span class="type">char</span> clientFifo[CLIENT_FIFO_NAME_LEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">response</span> <span class="title">resp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> seqNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建知名有名管道并以读取方式打开 */</span></span><br><span class="line">    umask(<span class="number">0</span>); <span class="comment">/* 以便获取预期权限 */</span></span><br><span class="line">    <span class="keyword">if</span> (mkfifo(SERVER_FIFO, S_IRUSR | S_IWUSR | S_IWGRP) == <span class="number">-1</span> &amp;&amp; errno != EEXIST)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;mkfifo %s&quot;</span>, SERVER_FIFO);</span><br><span class="line">    &#125;</span><br><span class="line">    serverFd = open(SERVER_FIFO, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (serverFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open %s&quot;</span>, SERVER_FIFO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开额外的写入文件描述符，以确保不会遇到EOF */</span></span><br><span class="line">    dummyFd = open(SERVER_FIFO, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (dummyFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open %s&quot;</span>, SERVER_FIFO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGPIPE, SIG_IGN) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取请求并发送响应 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (read(serverFd, &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error reading request; discarding\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 部分读取或出错 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 打开客户端有名管道 (已由客户端创建) */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(clientFifo, CLIENT_FIFO_NAME_LEN, CLIENT_FIFO_TEMPLATE, (<span class="type">long</span>)req.pid);</span><br><span class="line">        clientFd = open(clientFifo, O_WRONLY);</span><br><span class="line">        <span class="keyword">if</span> (clientFd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            errMsg(<span class="string">&quot;open %s&quot;</span>, clientFifo);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 打开失败时放弃该客户端 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 发送响应并关闭有名管道 */</span></span><br><span class="line">        resp.seqNum = seqNum;</span><br><span class="line">        <span class="keyword">if</span> (write(clientFd, &amp;resp, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> response)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> response))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error writing to FIFO %s\n&quot;</span>, clientFifo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close(clientFd) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errMsg(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seqNum += req.seqLen; <span class="comment">/* 更新序列号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是服务器的代码。服务器会执行以下步骤：</p>
<p>　　1) 创建服务器知名有名管道并以只读方式打开
(第15~24行)。服务器必须在所有客户端之前运行，以保证客户端试图打开服务器有名管道时该有名管道已存在。服务器的<code>open()</code>会被阻塞，直到客户端以只写方式打开服务器有名管道。</p>
<p>　　2) 以只写方式打开服务器有名管道
(第27~31行)。该<code>open()</code>调用不会被阻塞，因为有名管道的已经被以只读方式打开。第2次打开为了确保所有客户端都关闭有名管道写入端后不会遇到EOF。</p>
<p>　　3) 忽略信号<code>SIGPIPE</code>
(第33~36行)。当服务器写入没有读取端的客户端有名管道时，不会收到该信号，而是从<code>write()</code>得到错误<code>EPIPE</code>。</p>
<p>　　4) 循环读取并响应客户端请求
(第39~70行)。为了发送响应，服务器会构建客户端有名管道的名称并以只写方式打开。若打开客户端有名管道出错，则放弃该客户端请求。</p>
<p>　　该服务器属于<span
style="background-color: yellow">迭代服务器</span>，服务器会先读取并处理上一个客户端请求，再处理下一个客户端请求。这种设计适合客户端请求可以被快速处理并响应的情况。另一种设计是并发服务器，主服务器会使用单独的进程或线程来处理客户端请求。</p>
<h5 id="客户端请求">44.2.2.2 客户端请求</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* fifo_seqnum_client.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fifo_seqnum.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> clientFifo[CLIENT_FIFO_NAME_LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除客户端有名管道</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">removeFifo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    unlink(clientFifo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serverFd, clientFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">response</span> <span class="title">resp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [seq-len...]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建客户端有名管道 */</span></span><br><span class="line">    umask(<span class="number">0</span>); <span class="comment">/* 以便获取预期权限 */</span></span><br><span class="line">    <span class="built_in">snprintf</span>(clientFifo, CLIENT_FIFO_NAME_LEN, CLIENT_FIFO_TEMPLATE, (<span class="type">long</span>)getpid());</span><br><span class="line">    <span class="keyword">if</span> (mkfifo(clientFifo, S_IRUSR | S_IWUSR | S_IWGRP) == <span class="number">-1</span> &amp;&amp; errno != EEXIST)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;mkfifo %s&quot;</span>, clientFifo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (atexit(removeFifo) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;atexit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建请求、打开客户端有名管道以及发送请求 */</span></span><br><span class="line">    req.pid = getpid();</span><br><span class="line">    req.seqLen = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;seq-len&quot;</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    serverFd = open(SERVER_FIFO, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (serverFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open %s&quot;</span>, SERVER_FIFO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(serverFd, &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request))</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;Can&#x27;t write to server&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开客户端有名管道，然后读取并打印响应 */</span></span><br><span class="line">    clientFd = open(clientFifo, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (clientFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open %s&quot;</span>, clientFifo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(clientFd, &amp;resp, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> response)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> response))</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;Can&#x27;t read response from server&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, resp.seqNum);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是客户端的代码。客户端会执行以下步骤：</p>
<p>　　1) 创建用于接收服务器响应的客户端有名管道
(第27~37行)。该步骤应该在发送请求前完成，以确保服务器试图打开客户端有名管道并发送响应时该有名管道已存在。</p>
<p>　　2) 构建发送给服务器的消息，其中包含客户端进程ID和数字
(取自命令行参数)，该数字指定客户端希望服务器分配给它的序列长度。若未指定，则默认为1
(第40~47行)。</p>
<p>　　3) 打开服务器有名管道并发送消息给服务器 (第49~52行)。</p>
<p>　　4) 打开客户端有名管道并打印服务器响应 (第55~66行)。</p>
<p>　　这里唯一值得注意的其他细节是通过<code>atexit()</code>注册退出处理函数，以确保客户端有名管道会在进程终止时被删除。或者，这里可以直接在通过<code>open()</code>打开客户端有名管道后调用<code>unlink()</code>。</p>
<p>　　以下shell会话展示了示例客户端和服务器的用法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fifo_seqnum_server &amp;</span></span><br><span class="line">[1] 5066</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fifo_seqnum_client 3</span></span><br><span class="line">0</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fifo_seqnum_client 2</span></span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fifo_seqnum_client</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h4 id="非阻塞io">44.2.3 非阻塞I/O</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;fifopath&quot;</span>, O_RDONLY | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　如前所述，当进程打开有名管道的一端时，若另一端未打开，则该进程会被阻塞。有时，可能需要让进程不会被阻塞。为此，可以在调用<code>open()</code>时指定标志<code>O_NONBLOCK</code>，该标志的效果取决于打开的是有名管道读取端还是写入端。</p>
<p>　　●
若打开的是有名管道读取端，并且没有进程拥有有名管道写入端，则<code>open()</code>会立即成功
(就像有名管道写入端已打开一样)。</p>
<p>　　●
若打开的是有名管道写入端，并且没有进程拥有有名管道读取端，则<code>open()</code>会出错
(<code>ENXIO</code>)。</p>
<p>　　若有名管道的另一端已打开，则标志<code>O_NONBLOCK</code>不会生效。</p>
<p>　　标志<code>O_NONBLOCK</code>在打开有名管道进行读取或写入时的不对称性的原因如下：</p>
<p>　　●
当没有进程拥有有名管道写入端时，打开有名管道读取端不会导致问题，因为读取该有名管道不会返回数据。</p>
<p>　　●
当没有进程拥有有名管道读取端时，打开有名管道写入端会导致信号<code>SIGPIPE</code>的生成，并且<code>write()</code>会出错
(<code>EPIPE</code>)。</p>
<p>　　在打开有名管道时使用标志<code>O_NONBLOCK</code>主要有2个目的：</p>
<p>　　●
它允许同一进程打开有名管道的两端。进程可以先使用该标志打开有名管道读取端，然后打开有名管道写入端。</p>
<img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/deadlock_between_processes_opening_two_fifos.svg" class="">
<p>　　●
它可以防止打开2个有名管道的进程之间的死锁。如图所示，进程X和Y都被阻塞在打开有名管道读取端。只要其中某个进程能先执行第2步时，就不会出现这种阻塞。但是，在某些应用程序中，这可能难以实现。在这种情况下，可以在打开有名管道读取端时指定该标志来解决这个问题。</p>
<p>　　有时，可能需要修改已打开的有名管道 (或其他类型的文件)
的标志<code>O_NONBLOCK</code>的状态。以下情况可能需要这样做：</p>
<p>　　●
打开有名管道时使用了该标志，但后续的<code>read()</code>和<code>write()</code>调用需要以阻塞模式运行。</p>
<p>　　● 需要修改<code>open()</code>以外的其他方式获取的文件描述符
(例如，shell为每个新运行的程序自动打开的3个标准文件描述符以及<code>socket()</code>返回的文件描述符)
的非阻塞状态。</p>
<p>　　● 某些应用程序需要启用或禁用某个文件描述符的该标志。</p>
<p>　　为此，可以通过<code>fcntl()</code>来启用或禁用打开文件状态标志<code>O_NONBLOCK</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">flags = fcntl(fd, F_GETFL); <span class="comment">/* 获取打开文件状态标志 */</span></span><br><span class="line">flags |= O_NONBLOCK;        <span class="comment">/* 启用位O_NONBLOCK */</span></span><br><span class="line">fcntl(fd, F_SETFL, flags);  <span class="comment">/* 更新打开文件状态标志 */</span></span><br></pre></td></tr></table></figure>
<p>　　这段代码会启用标志<code>O_NONBLOCK</code>
(这里省略了错误检查)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flags = fcntl(fd, F_GETFL);</span><br><span class="line">flags &amp;= ~O_NONBLOCK; <span class="comment">/* 禁用位O_NONBLOCK */</span></span><br><span class="line">fcntl(fd, F_SETFL, flags);</span><br></pre></td></tr></table></figure>
<p>　　这段代码会禁用标志<code>O_NONBLOCK</code>。</p>
<h3 id="无名管道和有名管道的read和write的语义">44.3
无名管道和有名管道的<code>read()</code>和<code>write()</code>的语义</h3>
<p>　　下表列出了无名管道和有名管道的<code>read()</code>操作的语义
(n表示希望读取的字节数，p表示无名管道或有名管道中的实际字节数)：</p>
<table>
<thead>
<tr>
<th></th>
<th>启用标志<code>O_NONBLOCK</code></th>
<th>禁用标志<code>O_NONBLOCK</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>p = 0且写入端打开</td>
<td>错误<code>EAGAIN</code></td>
<td>阻塞</td>
</tr>
<tr>
<td>p = 0且写入端关闭</td>
<td>返回0 (EOF)</td>
<td>返回0 (EOF)</td>
</tr>
<tr>
<td>p &lt; n</td>
<td>读取p字节</td>
<td>读取p字节</td>
</tr>
<tr>
<td>p &gt;= n</td>
<td>读取n字节</td>
<td>读取n字节</td>
</tr>
</tbody>
</table>
<p>　　阻塞读取和非阻塞读取的唯一区别在没有数据且写入端打开时出现。此时，常规的<code>read()</code>会被阻塞，而非阻塞<code>read()</code>会导致错误<code>EAGAIN</code>。</p>
<p>　　当写入无名管道或有名管道时，标志<code>O_NONBLOCK</code>与限制<code>PIPE_BUF</code>的相互作用会导致情况变得更复杂。下表列出了无名管道和有名管道的<code>write()</code>操作的语义
(n表示希望写入的字节数)：</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 40%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>启用标志<code>O_NONBLOCK</code></th>
<th>禁用标志<code>O_NONBLOCK</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>n &lt;= <code>PIPE_BUF</code>且读取端打开</td>
<td>若空间足够，则立即以原子方式写入n字节；否则，出错
(<code>EAGAIN</code>)</td>
<td>以原子方式写入n字节 (可能被阻塞，直到有足够的空间)</td>
</tr>
<tr>
<td>n &gt; <code>PIPE_BUF</code>且读取端打开</td>
<td>若空间足以立即写入部分字节，则写入1到n字节
(可能与其他进程写入的数据交错)；否则，出错 (<code>EAGAIN</code>)</td>
<td>写入n字节
(可能被阻塞，直到有足够的空间)，并且数据可能与其他进程写入的数据交错</td>
</tr>
<tr>
<td>读取端关闭</td>
<td>信号<code>SIGPIPE</code> + 错误<code>EPIPE</code></td>
<td>信号<code>SIGPIPE</code> + 错误<code>EPIPE</code></td>
</tr>
</tbody>
</table>
<p>　　当无法立即写入数据时，标志<code>O_NONBLOCK</code>会导致无名管道或有名管道的<code>write()</code>出错
(<code>EAGAIN</code>)。因此，当写入的数据不超过<code>PIPE_BUF</code>字节时，若无名管道或有名管道中的空间不足，则<code>write()</code>会出错，因为内核无法立即完成操作，也无法执行执行部分写入
(这会违反写入不超过<code>PIPE_BUF</code>字节的数据需要以原子方式执行的要求)。</p>
<p>　　当单次写入的数据超过<code>PIPE_BUF</code>字节时，写入操作不再需要以原子方式执行。因此，<code>write()</code>会尽可能多地写入数据
(部分写入)
来填满无名管道或有名管道。在这种情况下，<code>write()</code>的返回值是实际写入的字节数，并且调用进程必须稍后再次写入剩余字节。但是，若无名管道或有名管道已满，则<code>write()</code>会出错
(<code>EAGAIN</code>)。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
