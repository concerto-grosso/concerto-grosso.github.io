<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_36/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_36/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_36/","title":"《Linux/UNIX系统编程手册》第36章 进程资源"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第36章 进程资源 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-text">36.1 进程资源使用情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="nav-text">36.2 进程资源限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%AE%9A%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="nav-text">36.3 特定资源限制的详细信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rlimit_as%E5%92%8Crlimit_core"><span class="nav-text">36.3.1 RLIMIT_AS和RLIMIT_CORE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rlimit_cpu"><span class="nav-text">36.3.2 RLIMIT_CPU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rlimit_datarlimit_fsize%E5%92%8Crlimit_memlock"><span class="nav-text">36.3.3 RLIMIT_DATA、RLIMIT_FSIZE和RLIMIT_MEMLOCK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rlimit_msgqueue%E5%92%8Crlimit_nice"><span class="nav-text">36.3.4 RLIMIT_MSGQUEUE和RLIMIT_NICE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rlimit_nofile"><span class="nav-text">36.3.5 RLIMIT_NOFILE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rlimit_nproc"><span class="nav-text">36.3.6 RLIMIT_NPROC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rlimit_rssrlimit_rtprio%E5%92%8Crlimit_rttime"><span class="nav-text">36.3.7 RLIMIT_RSS、RLIMIT_RTPRIO和RLIMIT_RTTIME</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rlimit_sigpending%E5%92%8Crlimit_stack"><span class="nav-text">36.3.8 RLIMIT_SIGPENDING和RLIMIT_STACK</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_36/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第36章 进程资源 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第36章 进程资源</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-17 00:00:00" itemprop="dateCreated datePublished" datetime="2025-10-17T00:00:00+08:00">2025-10-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-10-18 00:00:00" itemprop="dateModified" datetime="2025-10-18T00:00:00+08:00">2025-10-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>11k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="进程资源使用情况">36.1 进程资源使用情况</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getrusage</span><span class="params">(<span class="type">int</span> who, <span class="keyword">struct</span> rusage *res_usage)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rusage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ru_utime</span>;</span> <span class="comment">/* 使用的用户CPU时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ru_stime</span>;</span> <span class="comment">/* 使用的系统CPU时间 */</span></span><br><span class="line">    <span class="type">long</span> ru_maxrss;          <span class="comment">/* 驻留集的最大大小，单位是KB (Linux 2.6.32及以上版本) */</span></span><br><span class="line">    <span class="type">long</span> ru_ixrss;           <span class="comment">/* 整体 (共享) 文本内存大小 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_idrss;           <span class="comment">/* 整体 (非共享) 数据内存大小 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_isrss;           <span class="comment">/* 整体 (非共享) 栈内存大小 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_minflt;          <span class="comment">/* 软页故障 (无需I/O) */</span></span><br><span class="line">    <span class="type">long</span> ru_majflt;          <span class="comment">/* 硬页故障 (需要I/O) */</span></span><br><span class="line">    <span class="type">long</span> ru_nswap;           <span class="comment">/* 交换物理内存 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_inblock;         <span class="comment">/* 通过文件系统的阻塞输入操作 (Linux 2.6.22及以上版本) */</span></span><br><span class="line">    <span class="type">long</span> ru_oublock;         <span class="comment">/* 通过文件系统的阻塞输出操作 (Linux 2.6.22及以上版本) */</span></span><br><span class="line">    <span class="type">long</span> ru_msgsnd;          <span class="comment">/* 发送的IPC信息 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_msgrcv;          <span class="comment">/* 接收的IPC信息 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_nsignals;        <span class="comment">/* 接收的信号 (未使用) */</span></span><br><span class="line">    <span class="type">long</span> ru_nvcsw;           <span class="comment">/* 主动上下文切换，即进程在时间片到期之前放弃CPU (Linux 2.6及以上版本) */</span></span><br><span class="line">    <span class="type">long</span> ru_nivcsw;          <span class="comment">/* 被动上下文切换，即进程被更高优先级的进程抢占或时间片到期 (Linux 2.6及以上版本) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>getrusage()</code>用于检索调用进程或它的所有已被回收的子进程占用的各种系统资源的统计信息，结果存储在参数<code>res_usage</code>指向的结构体<code>rusage</code>中。参数<code>who</code>用于指定带检索资源信息使用情况的目标，只能被指定为<code>RUSAGE_SELF</code>、<code>RUSAGE_CHILDREN</code>或<code>RUSAGE_THREAD</code>。</p><p>　　● <code>RUSAGE_SELF</code>表示返回调用进程的相关信息。</p><p>　　● <code>RUSAGE_CHILDREN</code>表示返回调用进程的所有已被回收的子进程的相关信息。</p><p>　　● <code>RUSAGE_THREAD</code>表示返回调用线程的相关信息，该值是特定于Linux的 (Linux 2.6.26及以上版本)。</p><p>　　对于Linux，结构体<code>rusage</code>的很多成员不会被<code>getrusage()</code> (或<code>wait3()</code>和<code>wait4()</code>) 设置，或者只有在较新的内核版本中才会被设置。有些UNIX实现会使用Linux未使用的某些成员，但Linux也提供了这些成员。</p><p>　　成员<code>ru_utime</code>和<code>ru_stime</code>分别表示进程在用户和内核模式下消耗的CPU时间。</p><span id="more"></span><p>　　若<code>who</code>为<code>RUSAGE_CHILDREN</code>，则<code>getrusage()</code>返回的结构体<code>rusage</code>会包含调用进程的所有已被回收的后代进程的资源使用统计信息。假设有3个进程：父进程、子进程和孙进程。当子进程对孙进程调用<code>wait()</code>时，子进程的资源使用统计数据会包含孙进程的资源使用统计数据；当父进程对子进程调用<code>wait()</code>时，父进程的资源使用统计数据会包含子进程 (和孙进程) 的资源使用统计数据。相反，若子进程没有对孙进程调用<code>wait()</code>，则父进程和子进程的资源使用统计数据都不会包含孙进程的资源使用统计数据。</p><p>　　当<code>who</code>为<code>RUSAGE_CHILDREN</code>时，成员<code>ru_maxrss</code>返回的是调用进程的所有后代进程的最大驻留集的大小 (而非所有后代进程的驻留集的总和)。</p><p>　　尽管大多数UNIX实现提供了<code>getrusage()</code>，但SUSv3仅简略地说明了该系统调用 (仅说明了成员<code>ru_utime</code>和<code>ru_stime</code>)，部分是因为结构体<code>rusage</code>的大部分信息的含义取决于实现。</p><p>　　SUSv3要求，当<code>who</code>为<code>RUSAGE_CHILDREN</code>时，若忽略了信号<code>SIGCHLD</code> (以避免子进程转换为僵尸进程)，则子进程的资源使用数据不应该被统计在父进程的资源使用数据中。但是，如前所述，对于2.6.9之前的内核，这种情况下的父进程的资源使用统计数据会包含子进程的资源使用统计数据。</p><p>　　特定于Linux的文件<code>/proc/PID/stat</code>可用于获取系统中的所有进程的部分资源使用信息 (CPU时间和页故障)。</p><h3 id="进程资源限制">36.2 进程资源限制</h3><p>　　每个进程有1组资源限制，可用于限制进程可消耗的各种系统资源的数量。可以通过内置命令<code>ulimit</code> (<code>csh</code>的<code>limit</code>) 来设置shell的资源限制，shell创建的用于执行用户命令的进程继承会继承这些资源限制。</p><p>　　从内核2.6.24开始，特定于Linux的文件<code>/proc/PID/limits</code>可用于获取任意进程的所有资源限制。该文件由对应进程的实际用户ID所有，其权限仅允许该用户ID (或特权进程) 进行读取。</p><p>　　资源限制通常对特权进程和非特权进程均有效。通过<code>fork()</code>创建的子进程会继承这些资源限制，并且这些资源限制在<code>exec()</code>期间会被保留。</p><p>　　尽管资源限制是进程级属性，但在某些情况下，资源限制不仅根据进程对资源的消耗来衡量，还根据具有相同实际用户ID的所有进程所消耗的资源总和来衡量。此外，资源限制仅对已设置该限制的进程生效 (即进程以及继承了该资源限制的子进程)。若同一实际用户ID的其他进程没有设置资源限制 (即无限) 或设置了不同的资源限制，则该进程创建的子进程的能力将受限于它设置的资源限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur; <span class="comment">/* 软限制 */</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_max; <span class="comment">/* 硬限制 (rlim_cur的上限) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>getrlimit()</code>和<code>setrlimit()</code>允许进程检索和修改自己的资源限制。参数<code>resource</code>用于标识待检索或修改的资源限制。参数<code>rlim</code>是指向结构体<code>rlimit</code>的指针，用于存储返回的资源限制值 (<code>getrlimit()</code>) 或指定新资源限制值 (<code>setrlimit()</code>)。</p><p>　　结构体<code>rlimit</code>的成员<code>rlim_cur</code>和<code>rlim_max</code>分别表示软限制和硬限制。这2个成员的数据类型<code>rlim_t</code>是整数类型。软限制控制进程可消耗的资源量。进程可以将软限制调整为0到硬限制之间的值。对于大多数资源，硬限制唯一的功能是作为软限制的上限。特权进程 (能力<code>CAP_SYS_RESOURCE</code>) 可以任意调整硬限制 (只要不小于软限制)，而非特权进程只能减小硬限制。对于这2个成员，值<code>RLIM_INFINITY</code>表示无限 (资源没有限制)。</p><p>　　参数<code>resource</code>只能被指定为以下值之一：</p><table><colgroup><col style="width:22%"><col style="width:71%"><col style="width:5%"></colgroup><thead><tr><th>资源限制</th><th>作用于</th><th>SUSv3</th></tr></thead><tbody><tr><td><code>RLIMIT_AS</code></td><td>进程虚拟内存大小，单位是字节</td><td>✓</td></tr><tr><td><code>RLIMIT_CORE</code></td><td>核心转储文件大小，单位是字节</td><td>✓</td></tr><tr><td><code>RLIMIT_CPU</code></td><td>CPU时间，单位是秒</td><td>✓</td></tr><tr><td><code>RLIMIT_DATA</code></td><td>进程数据段资源，单位是字节</td><td>✓</td></tr><tr><td><code>RLIMIT_FSIZE</code></td><td>文件大小，单位是字节</td><td>✓</td></tr><tr><td><code>RLIMIT_MEMLOCK</code></td><td>锁定的内存，单位是字节</td><td></td></tr><tr><td><code>RLIMIT_MSGQUEUE</code></td><td>为实际用户ID分配的POSIX消息队列的字节 (Linux 2.6.8及以上版本)</td><td></td></tr><tr><td><code>RLIMIT_NICE</code></td><td>nice值 (Linux 2.6.12及以上版本)</td><td></td></tr><tr><td><code>RLIMIT_NOFILE</code></td><td>最大文件描述符加1</td><td>✓</td></tr><tr><td><code>RLIMIT_NPROC</code></td><td>实际用户ID的进程数</td><td></td></tr><tr><td><code>RLIMIT_RSS</code></td><td>驻留集大小，单位是字节 (未实现)</td><td></td></tr><tr><td><code>RLIMIT_RTPRIO</code></td><td>实时调度策略 (Linux 2.6.12及以上版本)</td><td></td></tr><tr><td><code>RLIMIT_RTTIME</code></td><td>实时CPU时间，单位是微秒 (Linux 2.6.25及以上版本)</td><td></td></tr><tr><td><code>RLIMIT_SIGPENDING</code></td><td>实际用户ID的排队信号数 (Linux 2.6.8及以上版本)</td><td></td></tr><tr><td><code>RLIMIT_STACK</code></td><td>栈大小，单位是字节</td><td>✓</td></tr></tbody></table><p>　　在很多情况下，用于检索和设置资源限制的shell命令 (<code>bash</code>和<code>ksh</code>的<code>ulimit</code>以及<code>csh</code>的<code>limit</code>) 使用的单元不同于<code>getrlimit()</code>和<code>setrlimit()</code> (例如，shell命令通常以KB为单位表示各种内存段大小的资源限制)。</p><p>　　对于某些编程环境，数据类型<code>rlim_t</code>可能无法表示特定资源限制的所有可能值。提供多种编程环境的系统可能出现这种情况，导致<code>rlim_t</code>的大小有所不同。若将具有64位<code>off_t</code>的大文件编译环境添加到<code>off_t</code>为32位的系统，则会出现这种系统 (无论哪种环境，<code>rlim_t</code>的大小都会与<code>off_t</code>一致)。这会导致情况：当具有较小<code>rlim_t</code>的程序在具有64位<code>off_t</code>的程序执行后执行时，可能继承大于<code>rlim_t</code>最大值的资源限制。</p><p>　　为此，SUSv3详细说明了2个用于表示无法表示的限制值的常量：<code>RLIM_SAVED_CUR</code>和<code>RLIM_SAVED_MAX</code>。若软限制无法通过<code>rlim_t</code>表示，则<code>getrlimit()</code>会通过成员<code>rlim_cur</code>返回<code>RLIM_SAVED_CUR</code>；若硬限制无法通过<code>rlim_t</code>表示，则<code>getrlimit()</code>会通过成员<code>rlim_max</code>返回<code>RLIM_SAVED_MAX</code>。</p><p>　　当资源限制的所有可能值都能通过<code>rlim_t</code>表示时，SUSv3允许实现将<code>RLIM_SAVED_CUR</code>和<code>RLIM_SAVED_MAX</code>定义为<code>RLIM_INFINITY</code>。对于Linux，这2个常量就是这样定义的 (因为资源限制的所以可能值都能通过<code>rlim_t</code>表示)。但是，x86-32等32位架构则不同。对于这些架构，若使用大文件编译环境 (将功能测试宏<code>_FILE_OFFSET_BITS</code>定义为64)，则glibc会将<code>rlim_t</code>定义为64位，但用于表示资源限制的内核数据类型还是32位的<code>unsigned long</code>。对于当前版本的glibc，若使用<code>_FILE_OFFSET_BITS=64</code>编译的程序试图将资源限制设置为无法通过32位无符号整数表示的值，则glibc的<code>setrlimit()</code>包装函数会自动将该值转换为<code>RLIM_INFINITY</code>。换句话说，请求的资源限制将不被执行 (有人可能会认为，这种情况下的glibc的<code>setrlimit()</code>包装函数最好返回错误。但是，根本问题是内核限制，这里的行为是glibc开发者处理这个问题的方法)。</p><p>　　对于很多x86-32发行版，处理文件的工具通常使用<code>_FILE_OFFSET_BITS=64</code>进行编译，所以无法遵循超过32位表示范围的资源限制的问题不仅会影响开发者，还会影响用户。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* print_rlimit.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_rlimit.h&quot;</span> <span class="comment">/* 定义函数原型的头文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印msg加上resource指定的资源限制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @param resource</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printRlimit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">int</span> resource)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(resource, &amp;rlim) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s soft=&quot;</span>, msg);</span><br><span class="line">    <span class="keyword">if</span> (rlim.rlim_cur == RLIM_INFINITY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;infinite&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIM_SAVED_CUR <span class="comment">/* 有些实现未定义该资源限制 */</span></span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rlim.rlim_cur == RLIM_SAVED_CUR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unrepresentable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)rlim.rlim_cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;; hard=&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rlim.rlim_max == RLIM_INFINITY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;infinite\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIM_SAVED_MAX <span class="comment">/* 有些实现未定义该资源限制 */</span></span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rlim.rlim_max == RLIM_SAVED_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unrepresentable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)rlim.rlim_max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>printRlimit()</code>会打印1条信息以及指定资源的软限制和硬限制。这里处理数据类型<code>rlim_t</code>的表示方式与处理数据类型<code>off_t</code>的表示方法相同 (为了处理文件大小资源限制<code>RLIMIT_FSIZE</code>的表示)。因此，在打印<code>rlim_t</code>值时，会将其转换为<code>long long</code>，并在<code>printf()</code>中使用格式说明符<code>%lld</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rlimit_nproc.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_rlimit.h&quot;</span> <span class="comment">/* printRlimit()的函数原型 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || argc &gt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s soft-limit [hard-limit]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printRlimit(<span class="string">&quot;Initial maximum process limits: &quot;</span>, RLIMIT_NPROC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置新进程的资源限制 (若未指定硬限制，则将硬限制设置为软限制的值) */</span></span><br><span class="line">    rl.rlim_cur = (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>) ? RLIM_INFINITY : getInt(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;soft-limit&quot;</span>);</span><br><span class="line">    rl.rlim_max = (argc == <span class="number">2</span>) ? rl.rlim_cur : (argv[<span class="number">2</span>][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>) ? RLIM_INFINITY</span><br><span class="line">                                                                  : getInt(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;hard-limit&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (setrlimit(RLIMIT_NPROC, &amp;rl) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setrlimit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printRlimit(<span class="string">&quot;New maximum process limits: &quot;</span>, RLIMIT_NPROC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建尽可能多的子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>;; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (childPid = fork())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 */</span></span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* 父进程：打印每个子进程的相关信息并让它们转换为僵尸进程 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child %d (PID=%ld) started\n&quot;</span>, j, (<span class="type">long</span>)childPid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会调用<code>setrlimit()</code>来设置用户可创建的进程数量 (<code>RLIMIT_NPROC</code>) 的软限制和硬限制，然后通过函数<code>printRlimit()</code>来打印修改前后的限制值，最后创建尽可能多的子进程。</p><h3 id="特定资源限制的详细信息">36.3 特定资源限制的详细信息</h3><h4 id="rlimit_as和rlimit_core">36.3.1 <code>RLIMIT_AS</code>和<code>RLIMIT_CORE</code></h4><p>　　资源限制<code>RLIMIT_AS</code>指定进程的虚拟内存 (地址空间) 的最大大小 (单位是字节)。试图超过该限制会导致错误<code>ENOMEM</code>。实际上，程序最常见的达到该限制的地方调用malloc包中的函数 (使用了<code>sbrk()</code>和<code>mmap()</code>)。一旦达到该限制，栈增长也会失败，进而导致达到<code>RLIMIT_STACK</code>时的结果。</p><p>　　资源限制<code>RLIMIT_CORE</code>指定核心转储文件的最大大小 (单位是字节)。当达到该限制后，核心转储文件将停止生成。将该限制指定为0可以阻止核心转储文件的生成，这有时很有用，因为核心转储文件可能很大，而用户不知道如何处理。另一个原因是安全性——防止程序内存的内容被转储到磁盘。若<code>RLIMIT_FSIZE</code>低于该限制，则核心转储文件的大小将被限制到<code>RLIMIT_FSIZE</code>字节。</p><h4 id="rlimit_cpu">36.3.2 <code>RLIMIT_CPU</code></h4><p>　　资源限制<code>RLIMIT_CPU</code>指定进程可用的 (系统和用户模式) CPU时间的最大秒数。SUSv3要求，信号<code>SIGXCPU</code>会在达到软<code>RLIMIT_CPU</code>限制时被发送给进程，但没有说明其他细节。注册<code>SIGXCPU</code>处理函数来执行一些操作并将控制权返回给主函数是可能的。因此，对于Linux，当达到软<code>RLIMIT_CPU</code>限制后，进程每耗时1秒，内核就会向进程发送1次信号<code>SIGXCPU</code>。若进程持续执行并达到硬<code>RLIMIT_CPU</code>限制，则内核会发送信号<code>SIGKILL</code>给该进程。</p><p>　　处理收到信号<code>SIGXCPU</code>后仍然继续占用CPU时间的进程的细节因UNIX实现而异。在大多数情况下，仍然会定期发送信号<code>SIGXCPU</code>。当考虑到该信号的可移植性时，应用程序应该被设计为在第1次收到该信号时执行所需的清理操作并终止，或者在收到该信号时修改资源限制。</p><h4 id="rlimit_datarlimit_fsize和rlimit_memlock">36.3.3 <code>RLIMIT_DATA</code>、<code>RLIMIT_FSIZE</code>和<code>RLIMIT_MEMLOCK</code></h4><p>　　资源限制<code>RLIMIT_DATA</code>指定进程的数据段 (包括已初始化数据段、未初始化数据段和堆) 的最大大小 (单位是字节)。试图超过该限制会导致错误<code>ENOMEM</code>。与<code>RLIMIT_AS</code>类似，程序最常见的达到该限制的地方调用malloc包中的函数。</p><p>　　资源限制<code>RLIMIT_FSIZE</code>指定进程可创建的文件的最大大小 (单位是字节)。若达到软<code>RLIMIT_FSIZE</code>限制，则信号<code>SIGXFSZ</code>会被发送给进程，并且系统调用 (例如，<code>write()</code>和<code>truncate()</code>) 会出错 (<code>EFBIG</code>)。捕获该信号并将控制权返回给主函数是可能的。但是，进程试图超过该限制会产生同样的信号和错误。</p><p>　　源于BSD的资源限制<code>RLIMIT_MEMLOCK</code>指定进程可以锁定在物理内存中的虚拟内存 (防止换出) 的最大大小 (单位是字节)。SUSv3没有说明该资源限制，并且只有Linux和BSD提供了该资源限制。该资源会限制影响<code>mlock()</code>和<code>mlockall()</code>以及<code>mmap()</code>和<code>shmctl()</code>的锁定选项。若调用<code>mlockall()</code>时指定了标志<code>MCL_FUTURE</code>，则该资源限制会导致后续对<code>brk()</code>、<code>sbrk()</code>、<code>mmap()</code>和<code>mremap()</code>的调用出错。</p><h4 id="rlimit_msgqueue和rlimit_nice">36.3.4 <code>RLIMIT_MSGQUEUE</code>和<code>RLIMIT_NICE</code></h4><p>　　特定于Linux的资源限制<code>RLIMIT_MSGQUEUE</code> (Linux 2.6.8及以上版本) 指定可以为调用进程的实际用户ID分配的POSIX消息队列的最大大小 (单位是字节)。当通过<code>mq_open()</code>创建POSIX消息队列时，将根据以下公式从该限制中扣除字节数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes = attr.mq_maxmsg * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg *) + attr.mq_maxmsg * attr.mq_msgsize;</span><br></pre></td></tr></table></figure><p>　　<code>attr</code>是作为第4个参数传递给<code>mq_open()</code>的结构体<code>mq_attr</code>，乘以<code>sizeof(struct msg_msg *)</code>是为了确保用户无法将无限数量的零长度消息放入队列中 (结构体<code>msg_msg</code>是内核内部使用的数据类型)。这是必要的，因为尽管零长度消息不包含数据，但会消耗一些系统内存用于记录开销。</p><p>　　<code>RLIMIT_MSGQUEUE</code>仅影响调用进程。调用进程的所有者的其他进程不会受到影响，除非它们设置或继承了该资源限制。</p><p>　　特定于Linux的资源限制<code>RLIMIT_NICE</code> (Linux 2.6.12及以上版本) 指定进程可以通过<code>sched_setscheduler()</code>或<code>nice()</code>设置的nice值的上限 (见35.1)。</p><h4 id="rlimit_nofile">36.3.5 <code>RLIMIT_NOFILE</code></h4><p>　　资源限制<code>RLIMIT_NOFILE</code>表示进程可分配的最大文件描述符加1。试图超过该限制通常会导致错误<code>EMFILE</code>。对于<code>dup2(fd, newfd)</code>，错误是<code>EBADF</code>。当调用<code>fcntl(fd, F_DUPFD, newfd)</code>时将<code>newfd</code>指定为不小于该限制的值时，错误是<code>EINVAL</code>。</p><p>　　对<code>RLIMIT_NOFILE</code>的修改会反映在<code>sysconf(_SC_OPEN_MAX)</code>的返回值中。SUSv3允许但不要求实现在修改该限制前后<code>sysconf(_SC_OPEN_MAX)</code>返回不同的值，所以其他实现在这一点的行为上可能与Linux不同。</p><p>　　SUSv3指出，当应用程序将软/硬<code>RLIMIT_NOFILE</code>限制设置为不大于当前打开的最大文件描述符的值时，会出现意外行为。</p><p>　　对于Linux，可以使用<code>readdir()</code>扫描目录<code>/proc/PID/fd</code>来检查进程当前打开的文件描述符，该目录包含进程当前打开的所有文件描述符的符号链接。</p><p>　　内核为<code>RLIMIT_NOFILE</code>设置了上限。在内核2.6.25之前，该上限是由内核常量<code>NR_OPEN</code>定义的硬编码值，其值为1048576 (增大该值需要重新构建内核)。从内核2.6.25开始，特定于Linux的文件<code>/proc/sys/fs/nr_open</code>定义该上限，默认为1048576，并且超级用户可以修改该上限。试图将软/硬<code>RLIMIT_NOFILE</code>限制设置为大于该上限的值会导致错误<code>EPERM</code>。</p><p>　　所有进程可以打开的文件总数还存在系统级限制，可以通过特定于Linux的文件<code>/proc/sys/fs/file-max</code>来检索或修改该限制。只有特权进程 (能力<code>CAP_SYS_ADMIN</code>) 才能超过该限制。对于非特权进程，系统调用遇到该限制时会导致错误<code>ENFILE</code>。</p><h4 id="rlimit_nproc">36.3.6 <code>RLIMIT_NPROC</code></h4><p>　　源于BSD的资源限制<code>RLIMIT_NPROC</code>指定调用进程的实际用户ID可创建的进程的最大数量。试图超过该限制会导致错误<code>EAGAIN</code>。</p><p>　　<code>RLIMIT_NPROC</code>仅影响调用进程。调用进程的所有者的其他进程不会受到影响，除非它们设置或继承了该资源限制。特权进程 (能力<code>CAP_SYS_ADMIN</code>或<code>CAP_SYS_RESOURCE</code>) 不会受到该资源限制的影响。</p><p>　　Linux还对所有用户可创建的进程数设置了系统级限制。对于Linux 2.4及以上版本，可以通过特定于Linux的文件<code>/proc/sys/kernel/threads-max</code>来检索和修改该限制。更准确地说，该限制和<code>RLIMIT_NPROC</code>实际上是对可创建的线程数量的限制，而非进程数量的限制。</p><p>　　<code>RLIMIT_NPROC</code>的默认值的设置方式因内核版本而异。对于Linux 2.2，该值使用固定公式计算。对于Linux 2.4及以上版本，该值使用基于可用物理内存的公式计算。</p><p>　　SUSv3没有说明<code>RLIMIT_NPROC</code>，并且只有Linux和BSD提供了该限制。SUSv3规定的检索用户ID允许的最大进程数的方法是调用<code>sysconf(_SC_CHILD_MAX)</code>。Linux支持该调用。在2.6.23内核之前，该调用总是返回999。从内核2.6.23 (和glibc 2.4及以上版本) 开始，该调用会正确地返回限制值 (通过检查<code>RLIMIT_NPROC</code>的值)。</p><p>　　不存在可移植的获取已为特定用户ID创建的进程数量的方法。对于Linux，可以扫描文件<code>/proc/PID/status</code>并检查条目<code>Uid</code>下的信息 (按序列出了4个进程用户ID：实际用户ID、有效用户ID、保存的set-user-ID和文件系统用户ID)，以估算用户当前拥有的进程数。</p><h4 id="rlimit_rssrlimit_rtprio和rlimit_rttime">36.3.7 <code>RLIMIT_RSS</code>、<code>RLIMIT_RTPRIO</code>和<code>RLIMIT_RTTIME</code></h4><p>　　源于BSD的资源限制<code>RLIMIT_RSS</code>指定进程的驻留集的最大页数，即物理内存中的当前虚拟页的总数。SUSv3没有说明该资源限制，但Linux和很多UNIX实现都提供了该资源限制。对于Linux，该限制资源目前未生效。</p><p>　　对于较旧的Linux 2.4内核 (直到2.4.29)，<code>RLIMIT_RSS</code>确实会影响<code>madvise()</code>的操作<code>MADV_WILLNEED</code>。若由于达到<code>RLIMIT_RSS</code>而导致无法执行该操作，则会在<code>errno</code>中返回<code>EIO</code>。</p><p>　　特定于Linux的资源限制<code>RLIMIT_RTPRIO</code> (Linux 2.6.12及以上版本) 指定进程可以通过<code>sched_setscheduler()</code>和<code>sched_setparam()</code>设置的实时优先级的上限。</p><p>　　特定于Linux的资源限制<code>RLIMIT_RTTIME</code> (Linux 2.6.25及以上版本) 指定实时调度策略下运行的进程在不睡眠 (即执行阻塞系统调用) 的情况下可消耗的最长CPU时间 (单位是微秒)。达到该限制时的行为与<code>RLIMIT_CPU</code>相同。</p><h4 id="rlimit_sigpending和rlimit_stack">36.3.8 <code>RLIMIT_SIGPENDING</code>和<code>RLIMIT_STACK</code></h4><p>　　特定于Linux的资源限制<code>RLIMIT_SIGPENDING</code> (Linux 2.6.8及以上版本) 指定调用进程的实际用户ID的排队信号 (包括标准信号和实时信号) 的最大数量。试图超过该限制会导致错误<code>EAGAIN</code>。</p><p>　　<code>RLIMIT_SIGPENDING</code>仅影响调用进程。调用进程的所有者的其他进程不会受到影响，除非它们设置或继承了该资源限制。</p><p>　　对于最初的实现，<code>RLIMIT_SIGPENDING</code>的默认值是1024。从内核2.6.12开始，该默认值与<code>RLIMIT_NPROC</code>的默认值相同。</p><p>　　<code>RLIMIT_SIGPENDING</code>仅对<code>sigqueue()</code>生效。即使达到该限制，仍然可以通过<code>kill()</code>将尚未排队的信号 (包括实时信号) 发送给进程。</p><p>　　从内核2.6.12开始，特定于Linux的文件<code>/proc/PID/status</code>的字段<code>SigQ</code>表示进程的实际用户ID的当前和最大排队信号数。</p><p>　　资源限制<code>RLIMIT_STACK</code>指定进程栈的最大大小 (单位是字节)。试图超过该限制会导致信号<code>SIGSEGV</code>被发送给进程。由于栈已耗尽，所以捕获信号的唯一方法是定义备用信号栈 (见21.4)。</p><p>　　从Linux 2.6.23开始，<code>RLIMIT_STACK</code>还决定用于存储进程的命令行参数和环境变量的空间的大小。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_35/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第35章 进程优先级和调度"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第35章 进程优先级和调度</a></div><div class="post-nav-item"><a href="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/" rel="next" title="《ARM Cortex-M3与Cortex-M4权威指南 第3版》第4章 架构">《ARM Cortex-M3与Cortex-M4权威指南 第3版》第4章 架构 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>