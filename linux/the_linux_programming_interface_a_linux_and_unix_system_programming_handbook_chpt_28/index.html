<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_28/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_28/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_28/","title":"《Linux/UNIX系统编程手册》第28章 详述进程创建和程序执行"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第28章 详述进程创建和程序执行 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%9F%E8%AE%A1"><span class="nav-text">28.1 进程统计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%9F%E8%AE%A1%E8%AE%B0%E5%BD%95"><span class="nav-text">28.1.1 进程统计记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%89%88%E6%9C%AC3"><span class="nav-text">28.1.2 统计文件格式版本3</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clone"><span class="nav-text">28.2 clone()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0flags"><span class="nav-text">28.2.1 参数flags</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="nav-text">28.2.1.1 共享文件描述符表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-text">28.2.1.2 共享文件系统相关信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">28.2.1.3 共享信号处理方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-text">28.2.1.4 共享虚拟内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="nav-text">28.2.1.5 线程组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%BA%93%E6%94%AF%E6%8C%81"><span class="nav-text">28.2.1.6 线程库支持</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-text">28.2.1.7 线程本地存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%ABsystem-v%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%92%A4%E9%94%80%E5%80%BC"><span class="nav-text">28.2.1.8 共享System V信号量撤销值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%A7%E6%8C%82%E8%BD%BD%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">28.2.1.9 进程级挂载命名空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A9%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%B0%83%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%90%8C"><span class="nav-text">28.2.1.10 让子进程的父进程与调用进程的父进程相同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%A9%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%9B%E7%A8%8Bid%E4%B8%8E%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%9B%E7%A8%8Bid%E7%9B%B8%E5%90%8C"><span class="nav-text">28.2.1.11 让子进程的进程ID与父进程的进程ID相同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B7%9F%E8%B8%AA"><span class="nav-text">28.2.1.12 进程跟踪</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9B%B4%E5%88%B0%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E6%88%96%E8%B0%83%E7%94%A8exec"><span class="nav-text">28.2.1.13 挂起父进程，直到子进程退出或调用exec()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E6%94%AF%E6%8C%81%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B0clone%E6%A0%87%E5%BF%97"><span class="nav-text">28.2.1.14 用于支持容器的新clone()标志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#clone%E6%A0%87%E5%BF%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-text">28.2.1.15 clone()标志的用法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%8B%E9%9A%86%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84waitpid%E6%89%A9%E5%B1%95"><span class="nav-text">28.2.2 克隆子进程的waitpid()扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E9%80%9F%E5%BA%A6"><span class="nav-text">28.3 进程创建速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exec%E5%92%8Cfork%E5%AF%B9%E8%BF%9B%E7%A8%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">28.4 exec()和fork()对进程属性的影响</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_28/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第28章 详述进程创建和程序执行 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第28章 详述进程创建和程序执行</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-07-12 00:00:00" itemprop="dateCreated datePublished" datetime="2025-07-12T00:00:00+08:00">2025-07-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-07-13 00:00:00" itemprop="dateModified" datetime="2025-07-13T00:00:00+08:00">2025-07-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>23k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　当启用<strong>进程统计</strong>后，内核会在进程终止时将相关记录写入到系统级进程统计文件，该记录包含内核维护的关于该进程的各种信息 (例如，进程终止状态和使用的CPU时间)。统计文件可以通过标准工具 (<code>sa</code>会总结统计文件中的信息，<code>lastcomm</code>会列出最近执行的命令的相关信息) 或特定的应用程序分析。</p><p>　　对于2.6.10之前的内核版本，当通过NPTL线程实现创建线程时，会向进程统计文件中写入1条关于该线程的统计记录。从内核2.6.10开始，只有当进程的最后1个线程终止时，才会向进程统计文件中写入1条关于该进程的统计记录。当使用较旧的LinuxThreads线程实现时，总是会为线程写入统计记录。</p><p>　　从历史角度，进程统计的主要用途是在多用户UNIX系统上记录用户使用的系统资源。但是，进程统计也可用于获取进程的相关信息，这些信息是父进程没有监控和报告的。</p><p>　　大多数UNIX实现都提供了进程统计，但SUSv3没有说明它。统计记录的格式和统计文件的位置因UNIX实现而异。这里介绍的内容是基于Linux，也会说明与UNIX实现之间的差异。</p><p>　　对于Linux，进程统计是可选的内核组件，由选项<code>CONFIG_BSD_PROCESS_ACCT</code>配置。</p><h3 id="进程统计">28.1 进程统计</h3><p>　　特权进程 (能力<code>CAP_SYS_PACCT</code>) 可以通过系统调用<code>acct()</code>来启用和禁用进程统计。应用程序通常不会使用该系统调用。进程统计通常以在系统启动脚本中加入合适的命令的方式来启用 (保证每次系统重启时都会启用进程统计)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">acct</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *acctfile)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　为了启用进程统计，需要将<code>acct()</code>的参数<code>acctfile</code>指定为已存在的常规文件的路径名。统计文件的路径名通常是<code>/var/log/pacct</code>或<code>/usr/account/pacct</code>)。为了禁用进程统计，需要将<code>acctfile</code>指定为<code>NULL</code>。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* acct_on.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span> || (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [file]\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acct(argv[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;acct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process accounting %s\n&quot;</span>, (argv[<span class="number">1</span>] == <span class="literal">NULL</span>) ? <span class="string">&quot;disabled&quot;</span> : <span class="string">&quot;enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>acct()</code>的用法。</p><h4 id="进程统计记录">28.1.1 进程统计记录</h4><p>　　当启用进程统计后，进程终止时会向统计文件写入1条<code>acct</code>记录。结构体<code>acct</code>定义在头文件<code>sys/acct.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ACCT_COMM 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">u_int16_t</span> <span class="type">comp_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> ac_flag;                <span class="comment">/* 统计标志 */</span></span><br><span class="line">    <span class="type">u_int16_t</span> ac_uid;            <span class="comment">/* 进程的用户ID */</span></span><br><span class="line">    <span class="type">u_int16_t</span> ac_gid;            <span class="comment">/* 进程的组ID */</span></span><br><span class="line">    <span class="type">u_int16_t</span> ac_tty;            <span class="comment">/* 进程的控制终端 (0表示没有控制终端) */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_btime;          <span class="comment">/* 进程创建时间 (time_t，自纪元以来的秒数) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_utime;             <span class="comment">/* 用户CPU时间 (时钟节拍) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_stime;             <span class="comment">/* 系统CPU时间 (时钟节拍) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_etime;             <span class="comment">/* 已使用的 (实际) 时间 (时钟节拍) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_mem;               <span class="comment">/* 平均内存使用 (KB) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_io;                <span class="comment">/* read()和write()传输的字节数 (未使用) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_rw;                <span class="comment">/* 读取/写入的块数 (未使用) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_minflt;            <span class="comment">/* 次要页故障 (特定于Linux) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_majflt;            <span class="comment">/* 主要页故障 (特定于Linux) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_swaps;             <span class="comment">/* 交换次数 (未使用，特定于Linux) */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_exitcode;       <span class="comment">/* 进程终止状态 */</span></span><br><span class="line">    <span class="type">char</span> ac_comm[ACCT_COMM + <span class="number">1</span>]; <span class="comment">/* 命令名 (最近执行的命令的基础名称，以\0结尾) */</span></span><br><span class="line">    <span class="type">char</span> ac_pad[X];              <span class="comment">/* 填充字节 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　● <code>u_int16_t</code>和<code>u_int32_t</code>是16位和32位无符号整数类型。</p><p>　　● <code>comp_t</code>是浮点类型，该数据类型也称为<strong>压缩时钟节拍</strong>。<code>comp_t</code>的前3位是以8为底数的指数 (表示8<sup>0</sup>到8<sup>7</sup>)，后13位表示尾数。例如，当尾数和指数分别为125和1时，表示值1000。</p><p>　　● 成员<code>ac_flag</code>是位掩码，用于记录进程的各种事件。该成员可以指定的位如下 (并非所有UNIX实现都提供了这些位)：</p><table><thead><tr><th>位</th><th>描述</th></tr></thead><tbody><tr><td><code>AFORK</code></td><td>进程由<code>fork()</code>创建，但直到终止也没有调用<code>exec()</code></td></tr><tr><td><code>ASU</code></td><td>进程使用了超级用户特权</td></tr><tr><td><code>AXSIG</code></td><td>进程被信号终止 (有些UNIX实现未提供该位)</td></tr><tr><td><code>ACORE</code></td><td>进程生成了核心转储文件 (有些UNIX实现未提供该位)</td></tr></tbody></table><p>　　● 成员<code>ac_comm</code>用于记录进程最近执行的命令 (可执行文件) 的名称。每次调用<code>execve()</code>时内核会记录该值。对于有些UNIX实现，该成员的长度限制为8个字符。</p><p>　　● 3个<code>comp_t</code>类型的时间成员以系统时钟节拍表示时间，所以需要将这些时间除以<code>sysconf(_SC_CLK_TCK)</code>来获取秒数。</p><p>　　● 成员<code>ac_exitcode</code>用于记录进程的终止状态 (见26.1.3)。大多数UNIX实现未提供该成员，相反，提供的是单字节成员<code>ac_stat</code>，<code>ac_stat</code>仅记录终止进程的信号，并使用其中的1位来表示是否生成核心转储文件。BSD衍生实现未提供这2个成员。</p><p>　　由于统计记录在进程终止时写入，所以统计记录按照终止时间排序 (统计记录没有记录终止时间) 。此外，系统崩溃时不会为任何执行中的进程写入统计记录。</p><p>　　由于向统计文件写入统计记录会占用大量磁盘空间，所以Linux提供了虚拟文件<code>/proc/sys/kernel/acct</code>来控制进程统计的操作。该文件包含3个数字，依次定义了参数<code>high-water</code>、<code>low-water</code>和<code>frequency</code>。这3个参数的默认值分别是4、2和30。若启用了进程统计，并且空闲磁盘空间低于<code>low-water</code>指定的百分比，则挂起统计。若空闲磁盘空间高于<code>high-water</code>指定的百分比，则恢复统计。<code>frequency</code>指定检查空闲磁盘空间百分比的频率 (单位为秒)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* acct_view.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/acct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span> <span class="comment">/* userNameFromId()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将comp_t值转换为long long值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param ct</span></span><br><span class="line"><span class="comment"> * @return long long</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">comptToLL</span><span class="params">(<span class="type">comp_t</span> ct)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> EXP_SIZE = <span class="number">3</span>;       <span class="comment">/* 指数 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MANTISSA_SIZE = <span class="number">13</span>; <span class="comment">/* 尾数 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MANTISSA_MASK = (<span class="number">1</span> &lt;&lt; MANTISSA_SIZE) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mantissa, <span class="built_in">exp</span>;</span><br><span class="line"></span><br><span class="line">    mantissa = ct &amp; MANTISSA_MASK;</span><br><span class="line">    <span class="built_in">exp</span> = (ct &gt;&gt; MANTISSA_SIZE) &amp; ((<span class="number">1</span> &lt;&lt; EXP_SIZE) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mantissa &lt;&lt; (<span class="built_in">exp</span> * <span class="number">3</span>); <span class="comment">/* 通过左移3位来获取8的幂 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> acctFile;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">acct</span> <span class="title">ac</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> numRead;</span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="type">char</span> timeBuf[TIME_BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">loc</span>;</span></span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s file\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    acctFile = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (acctFile == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;command  flags   term.  user     start time            CPU   elapsed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                status                                 time    time\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((numRead = read(acctFile, &amp;ac, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acct))) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numRead != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acct))</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;partial read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8.8s  &quot;</span>, ac.ac_comm);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (ac.ac_flag &amp; AFORK) ? <span class="string">&#x27;F&#x27;</span> : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (ac.ac_flag &amp; ASU) ? <span class="string">&#x27;S&#x27;</span> : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 并非所有UNIX实现都提供了AXSIG和ACORE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AXSIG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (ac.ac_flag &amp; AXSIG) ? <span class="string">&#x27;X&#x27;</span> : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ACORE</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (ac.ac_flag &amp; ACORE) ? <span class="string">&#x27;C&#x27;</span> : <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __linux__</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %#6lx   &quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)ac.ac_exitcode);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* 很多UNIX实现提供的是成员ac_stat */</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %#6lx   &quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)ac.ac_stat);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        s = userNameFromId(ac.ac_uid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8.8s &quot;</span>, (s == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : s);</span><br><span class="line"></span><br><span class="line">        t = ac.ac_btime;</span><br><span class="line">        loc = localtime(&amp;t);</span><br><span class="line">        <span class="keyword">if</span> (loc == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;???Unknown time???  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            strftime(timeBuf, TIME_BUF_SIZE, <span class="string">&quot;%Y-%m-%d %T &quot;</span>, loc);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, timeBuf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5.2f %7.2f &quot;</span>,</span><br><span class="line">               (<span class="type">double</span>)(comptToLL(ac.ac_utime) + comptToLL(ac.ac_stime)) / sysconf(_SC_CLK_TCK),</span><br><span class="line">               (<span class="type">double</span>)comptToLL(ac.ac_etime) / sysconf(_SC_CLK_TCK));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会打印进程统计文件的统计记录的某些字段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> pacct</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./acct_on pacct</span></span><br><span class="line">Process accounting enabled</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure><p>　　首先，创建统计文件并启用进程统计。此时，自启用进程统计以来，已经有3个进程终止。这些进程执行了程序<code>acct_on</code>、<code>su</code>和<code>bash</code>。执行<code>bash</code>的进程由<code>su</code>启动，用于运行特权shell会话。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sleep</span> 15 &amp;</span></span><br><span class="line">[1] 18063</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -c unlimited</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span></span></span><br><span class="line">输入Control-\ (生成信号SIGQUIT) 来终止cat</span><br><span class="line">Quit (core dumped)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">按下回车键可以在下一个shell提示符前查看睡眠完成后的shell通知</span></span><br><span class="line">[1]  + done       sleep 15</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep xxx badfile</span></span><br><span class="line">grep: badfile: No such file or directory</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $?</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>　　这里将执行一系列命令来为统计文件添加记录 (第3行的命令会解除核心转储文件的大小限制)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_execve /bin/echo</span></span><br><span class="line">hello world goodbye</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_fork</span></span><br><span class="line">PID=18350 (child) idata=333 istack=666</span><br><span class="line">PID=18349 (parent) idata=111 istack=222</span><br></pre></td></tr></table></figure><p>　　然后，运行<code>t_execve</code>和<code>t_fork</code>。第1行的命令会执行文件<code>/bin/echo</code>，所以记录中显示的命令名是<code>echo</code>。第3行的命令会创建不调用<code>exec()</code>的子进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./acct_view pacct</span></span><br><span class="line">command  flags   term.  user     start time            CPU   elapsed</span><br><span class="line">                status                                 time    time</span><br><span class="line">acct_on  -S--       0   root     2010-07-23 17:19:05   0.00    0.00</span><br><span class="line">bash     ----       0   root     2010-07-23 17:18:55   0.02   21.10</span><br><span class="line">su       -S--       0   root     2010-07-23 17:18:51   0.01   24.94</span><br><span class="line">cat      --XC    0x83   mtk      2010-07-23 17:19:55   0.00    1.72</span><br><span class="line">sleep    ----       0   mtk      2010-07-23 17:19:42   0.00   15.01</span><br><span class="line">grep     ----   0x200   mtk      2010-07-23 17:20:12   0.00    0.00</span><br><span class="line">echo     ----       0   mtk      2010-07-23 17:21:15   0.01    0.01</span><br><span class="line">t_fork   F---       0   mtk      2010-07-23 17:21:36   0.00    0.00</span><br><span class="line">t_fork   ----       0   mtk      2010-07-23 17:21:36   0.00    3.01</span><br></pre></td></tr></table></figure><p>　　最后，通过<code>acct_view</code>来查看统计文件。</p><h4 id="统计文件格式版本3">28.1.2 统计文件格式版本3</h4><p>　　从内核2.6.8开始，Linux添加了可选的替代进程统计文件版本来解决传统统计文件的某些问题，该版本称为<span style="background-color:#ff0">版本3</span>。为了使用该版本，在构建内核前必须先启用内核选项<code>CONFIG_BSD_PROCESS_ACCT_V3</code>。</p><p>　　当使用版本3时，进程统计操作唯一的区别在于写入到统计文件的记录格式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ACCT_COMM 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">acct_v3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> ac_flag;            <span class="comment">/* 统计标志 */</span></span><br><span class="line">    <span class="type">char</span> ac_version;         <span class="comment">/* 统计版本 (3) */</span></span><br><span class="line">    <span class="type">u_int16_t</span> ac_tty;        <span class="comment">/* 进程的控制终端 */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_exitcode;   <span class="comment">/* 进程终止状态 */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_uid;        <span class="comment">/* 进程的用户ID */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_gid;        <span class="comment">/* 进程的组ID */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_pid;        <span class="comment">/* 进程ID */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_ppid;       <span class="comment">/* 父进程ID */</span></span><br><span class="line">    <span class="type">u_int32_t</span> ac_btime;      <span class="comment">/* 进程创建时间 (time_t，自纪元以来的秒数) */</span></span><br><span class="line">    <span class="type">float</span> ac_etime;          <span class="comment">/* 已使用的 (实际) 时间 */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_utime;         <span class="comment">/* 用户CPU时间 (时钟节拍)  */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_stime;         <span class="comment">/* 系统CPU时间 (时钟节拍) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_mem;           <span class="comment">/* 平均内存使用 (KB) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_io;            <span class="comment">/* 读取/写入的字节数 (未使用) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_rw;            <span class="comment">/* 读取/写入的块数 (未使用) */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_minflt;        <span class="comment">/* 次要页故障 */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_majflt;        <span class="comment">/* 主要页故障 */</span></span><br><span class="line">    <span class="type">comp_t</span> ac_swaps;         <span class="comment">/* 交换次数 (未使用，特定于Linux) */</span></span><br><span class="line">    <span class="type">char</span> ac_comm[ACCT_COMM]; <span class="comment">/* 命令名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　结构体<code>acct_v3</code>和<code>acct</code>的主要区别如下：</p><p>　　● 添加了成员<code>ac_version</code>，该成员包含对应记录的版本号 (总是为3)。</p><p>　　● 添加了成员<code>ac_pid</code>和<code>ac_ppid</code>，分别包含终止进程的进程ID和父进程ID。</p><p>　　● 成员<code>ac_uid</code>和<code>ac_gid</code>从16位扩展到32位，以容纳Linux 2.4中添加的32位用户ID和组ID (传递统计文件无法正确地表示这些ID)。</p><p>　　● 成员<code>ac_etime</code>的数据类型修改为<code>float</code>，以记录更长的时间。</p><h3 id="clone">28.2 <code>clone()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *func_arg, ...</span></span><br><span class="line"><span class="params">          <span class="comment">/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */</span>)</span>; <span class="comment">/* 成功时返回子进程的进程ID，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　与<code>fork()</code>和<code>vfork()</code>类似，特定于Linux的系统调用<code>clone()</code>也会创建1个新进程，但后者允许更精细地控制进程创建步骤。<code>clone()</code>主要用于线程库的实现中。由于该系统调用是不可移植的，所以应该尽量避免直接在应用程序中使用该系统调用。</p><p>　　<code>clone()</code>创建的子进程几乎是父进程的精确副本。但是，子进程不是从调用<code>clone()</code> 的位置继续执行，而是以调用参数<code>func</code> 指向的函数开始，该函数称为<strong>子函数</strong>。当子函数被调用时，参数<code>func_arg</code>指定的值会传递给子函数。通过合适的类型转换，子函数可以自由地解释该参数 (例如，作为<code>int</code>或指向结构体的指针。将其解释为指针是可能的，因为子进程要么获得父进程内存的副本，要么与父进程共享内存)。</p><p>　　克隆的子进程会在<code>func</code>指向的函数返回或调用<code>exit()</code> (或<code>_exit()</code>) 时终止。父进程可以使用<code>wait()</code>等函数来以常规方式等待克隆的子进程。</p><p>　　由于克隆的子进程可能会与父进程共享内存 (与<code>vforK()</code>类似)，所以它不能使用父进程的栈。相反，调用者必须分配1个大小合适的内存块作为子进程的栈 (通过参数<code>child_stack</code>传递)。对于大多数硬件架构，栈向低地址增长，所以<code>child_stack</code>应该指向分配的内存块的最后1个字节。</p><p>　　<code>clone()</code>的参数<code>flags</code>分为2个部分。最低字节用于指定子进程的终止信号，即子进程终止时父进程收到的信号 (若克隆的子进程被信号停止，则父进程会收到信号<code>SIGCHLD</code>)。该字节可能为0，此时，表示不会生成信号 (可以通过Linux的文件<code>/proc/PID/stat</code>来获取任何进程的终止信号)。剩余字节作为控制<code>clone()</code>操作的位掩码，可以包含以下标志中的任意个标志 (或运算<code>|</code>)：</p><table><colgroup><col style="width:26%"><col style="width:73%"></colgroup><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td><code>CLONE_CHILD_CLEARTID</code></td><td>子进程调用<code>exec()</code>或<code>exit()</code>时清除<code>ctid</code> (Linux 2.6及以上版本)</td></tr><tr><td><code>CLONE_CHILD_SETTID</code></td><td>将子进程的线程ID写入到<code>ctid</code> (Linux 2.6及以上版本)</td></tr><tr><td><code>CLONE_FILES</code></td><td>父进程和子进程共享打开的文件描述符表</td></tr><tr><td><code>CLONE_FS</code></td><td>父进程和子进程共享文件系统相关属性</td></tr><tr><td><code>CLONE_IO</code></td><td>父进程和子进程共享I/O上下文 (Linux 2.6.25及以上版本)</td></tr><tr><td><code>CLONE_NEWIPC</code></td><td>子进程获得新的System V IPC命名空间 (Linux 2.6.19及以上版本)</td></tr><tr><td><code>CLONE_NEWNET</code></td><td>子进程获得新的网络命名空间 (Linux 2.4.24及以上版本)</td></tr><tr><td><code>CLONE_NEWNS</code></td><td>子进程获得父进程的挂载命名空间的副本 (Linux 2.4.19及以上版本)</td></tr><tr><td><code>CLONE_NEWPID</code></td><td>子进程获得新的进程ID命名空间 (Linux 2.6.19及以上版本)</td></tr><tr><td><code>CLONE_NEWUSER</code></td><td>子进程获得新的用户ID命名空间 (Linux 2.6.23及以上版本)</td></tr><tr><td><code>CLONE_NEWUTS</code></td><td>子进程获得新的UTS (<code>utsname()</code>) 命名空间 (Linux 2.6.19及以上版本)</td></tr><tr><td><code>CLONE_PARENT</code></td><td>让子进程的父进程与调用进程的父进程相同 (Linux 2.4及以上版本)</td></tr><tr><td><code>CLONE_PARENT_SETTID</code></td><td>将子进程的线程ID写入到<code>ptid</code> (Linux 2.6及以上版本)</td></tr><tr><td><code>CLONE_PID</code></td><td>仅用于系统引导进程的过期标志 (Linux 2.4及以下版本)</td></tr><tr><td><code>CLONE_PTRACE</code></td><td>若父进程正在被跟踪，则子进程也会被跟踪</td></tr><tr><td><code>CLONE_SETTLS</code></td><td><code>tls</code>会描述线子进程的线程本地存储 (Linux 2.6及以上版本)</td></tr><tr><td><code>CLONE_SIGHAND</code></td><td>父进程和子进程共享信号处理方式</td></tr><tr><td><code>CLONE_SYSVSEM</code></td><td>父进程和子进程共享信号量撤销值 (Linux 2.6及以上版本)</td></tr><tr><td><code>CLONE_THREAD</code></td><td>让子进程和父进程属于同一线程组 (Linux 2.4及以上版本)</td></tr><tr><td><code>CLONE_UNTRACED</code></td><td>无法强制将<code>CLONE_PTRACE</code>应用于子进程 (Linux 2.6及以上版本)</td></tr><tr><td><code>CLONE_VFORK</code></td><td>挂起父进程，直到子进程调用<code>exec()</code>或<code>_exit()</code></td></tr><tr><td><code>CLONE_VM</code></td><td>父进程和子进程共享虚拟内存</td></tr></tbody></table><p>　　<code>clone()</code>的剩余参数是<code>ptid</code>、<code>tls</code>和<code>ctid</code>。这些参数与线程实现有关，尤其是线程ID和线程本地存储的使用。对于Linux 2.4及以下版本，这些参数是未提供的。这些参数添加到Linux 2.6专门是为了支持NPTL POSIX线程实现。</p><p>　　<code>clone()</code>的设计缺陷之一就是对栈增长方向的架构依赖。对于Intel IA-64架构，还提供了<code>clone()</code>的改进版：<code>clone2()</code>。<code>clone2()</code>提供了栈的起始地址和大小，所以子进程的栈的范围定义不再依赖于栈的增长方向。</p><p>　　在内核中，<code>fork()</code>、<code>vfork()</code>和<code>clone()</code>最终都是通过同一函数 (<code>kernel/fork.c</code>中的<code>do_fork()</code>) 实现。在这个层级上，克隆更接近于fork：<code>sys_clone()</code>没有参数<code>func</code>和<code>func_arg</code>，并且被在调用后，<code>sys_clone()</code>会以与<code>fork()</code>相同的方式在子进程中返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_clone.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHILD_SIG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHILD_SIG SIGUSR1 <span class="comment">/* 克隆子进程终止时父进程收到的信号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 克隆子进程的启动函数 (关闭arg指向的文件描述符)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arg</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">childFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (close(*((<span class="type">int</span> *)arg)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 子进程终止 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> STACK_SIZE = <span class="number">65536</span>; <span class="comment">/* 克隆子进程的栈大小 */</span></span><br><span class="line">    <span class="type">char</span> *<span class="built_in">stack</span>;                  <span class="comment">/* 栈缓冲区的开头 */</span></span><br><span class="line">    <span class="type">char</span> *stackTop;               <span class="comment">/* 栈缓冲区的结尾 */</span></span><br><span class="line">    <span class="type">int</span> s, fd, flags;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR); <span class="comment">/* 子进程会关闭该描述符 */</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags = (argc &gt; <span class="number">1</span>) ? CLONE_FILES : <span class="number">0</span>; <span class="comment">/* 若argc大于1，则子进程会与父进程共享文件描述符表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = <span class="built_in">malloc</span>(STACK_SIZE); <span class="comment">/* 为子进程分配栈 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stackTop = <span class="built_in">stack</span> + STACK_SIZE; <span class="comment">/* 假设栈向低地址增长 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略CHILD_SIG (防止其处理方式是终止进程)，但不忽略SIGCHLD (忽略SIGCHLD会阻止僵尸进程的生成) */</span></span><br><span class="line">    <span class="keyword">if</span> (CHILD_SIG != <span class="number">0</span> &amp;&amp; CHILD_SIG != SIGCHLD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (signal(CHILD_SIG, SIG_IGN) == SIG_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建子进程 (子进程会从执行childFunc()开始 */</span></span><br><span class="line">    <span class="keyword">if</span> (clone(childFunc, stackTop, flags | CHILD_SIG, (<span class="type">void</span> *)&amp;fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;clone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程等待子进程 (__WCLONE表示仅等待克隆的子进程) */</span></span><br><span class="line">    <span class="keyword">if</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, (CHILD_SIG != SIGCHLD) ? __WCLONE : <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child has terminated\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断子进程关闭文件描述符是否影响父进程 */</span></span><br><span class="line">    s = write(fd, <span class="string">&quot;x&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">-1</span> &amp;&amp; errno == EBADF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file descriptor %d has been closed\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write() on file descriptor %d failed unexpectedly (%s)\n&quot;</span>, fd, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write() on file descriptor %d succeeded\n&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>clone()</code>的用法。父进程会执行以下步骤：</p><p>　　1) 打开1个文件描述符 (<code>/dev/null</code>)，子进程可能与父进程共享该文件描述符 (第36~40行)。</p><p>　　2) 将<code>CLONE_FILES</code>指定给<code>clone()</code>的参数<code>flags</code>。若提供了命令行参数，则父进程和子进程共享同一文件描述符表。若未提供命令行参数，则将<code>flags</code>设置为0 (第42行)。</p><p>　　3) 为子进程分配栈 (第44~49行)。</p><p>　　4) 若<code>CHILD_SIG</code>不等于0和<code>SIGCHLD</code>，则忽略该信号，以防止它会终止进程。这里不会忽略<code>SIGCHLD</code>，因为这样会导致无法等待子进程来获取其终止状态 (第52~58行)。</p><p>　　5) 调用<code>clone()</code>来创建子进程。第3个参数 (位掩码) 会包括终止信号。 第4个参数指定之前打开的文件描述符 (第61~64行)。</p><p>　　6) 等待子进程终止 (第67~71行)。</p><p>　　7) 通过向文件描述符写入来检查其是否仍然处于打开状态，然后根据结果打印提示信息 (第74~86行)。</p><p>　　子进程会从调用<code>childFunc()</code>开始，该函数会接收父进程打开的文件描述符并将其关闭，然后通过<code>return</code>终止 (第19~27行)。</p><h4 id="参数flags">28.2.1 参数<code>flags</code></h4><p>　　在某种程度上，试图区分术语线程和进程是在玩文字游戏。为此，这里将使用术语<span style="background-color:#ff0">内核调度实体</span> (KES)，某些文档中使用该术语来表示内核调度程序的处理对象。实际上，线程和进程都是KSE，它们提供了与其他KSE不同程度的属性共享 (例如，虚拟内存、打开的文件描述符、信号处理方式和进程ID)。POSIX线程规范仅提供了线程之间应共享的属性的各种可能定义之一。</p><p>　　从内核2.6.16开始，Linux提供了系统调用<code>unshare()</code>，该系统调用允许通过<code>clone()</code>、<code>fork()</code>或<code>vfork()</code>创建的子进程撤销在它被创建时设置的部分属性共享 (即逆转部分在子进程创建时设置的<code>clone()</code>标志位的效果)。</p><p>　　在接下来的内容中，可能会提供到Linux上可用的2个主要POSIX线程实现：较旧的LinuxThreads实现和较新的NPTL实现。</p><h5 id="共享文件描述符表">28.2.1.1 共享文件描述符表</h5><p>　　若指定了标志<code>CLONE_FILES</code>，则父进程和子进程会共享同一打开的文件描述符表，这表示文件描述符的分配和释放 (例如，<code>open()</code>、<code>close()</code>、<code>dup()</code>、<code>pipe()</code>和<code>socket()</code>) 对这些进程都可见。若未指定该标志，则不会共享文件描述符表，子进程会获得父进程调用<code>clone()</code>时的文件描述符表的副本。这些复制的文件描述符与父进程的对应文件描述符引用同一文件 (与<code>fork()</code>和<code>vfork()</code>相同)。</p><p>　　POSIX线程要求进程的所有线程共享同一文件描述符表。</p><h5 id="共享文件系统相关信息">28.2.1.2 共享文件系统相关信息</h5><p>　　若指定了标志<code>CLONE_FS</code>，则父进程和子进程会共享文件系统相关信息——umask、根目录和当前工作目录，这表示这些进程中的任一进程调用<code>umask()</code>、<code>chdir()</code>和<code>chroot()</code>也会影响其他进程。若未指定该标志，则父进程和子进程不会共享这些信息 (与<code>fork()</code>和<code>vfork()</code>相同)。</p><p>　　<code>CLONE_FS</code>提供的属性共享是POSIX线程所要求的。</p><h5 id="共享信号处理方式">28.2.1.3 共享信号处理方式</h5><p>　　若指定了标志<code>CLONE_SIGHAND</code>，则父进程和子进程会共享信号处理方式，这表示这些进程中的任一进程通过<code>signal()</code>或<code>sigaction()</code>修改信号处理方式也会影响其他进程。若未指定该标志，则父进程和子进程不会共享信号处理方式，子进程会获得父进程调用<code>clone()</code>时的信号处理方式的副本 (与<code>fork()</code>和<code>vfork()</code>相同)。</p><p>　　<code>CLONE_SIGHAND</code>不会影响进程信号掩码和等待信号集，父进程和子进程的信号掩码和等待信号集始终是独立的。对于Linux 2.6及以上版本，若指定了<code>CLONE_SIGHAND</code>，则必须还指定<code>CLONE_VM</code>。</p><p>　　POSIX线程要求共享信号处理方式。</p><h5 id="共享虚拟内存">28.2.1.4 共享虚拟内存</h5><p>　　若指定了标志<code>CLONE_VM</code>，则父进程和子进程会共享虚拟内存页，这表示这些进程中的任一进程通过<code>mmap()</code>和<code>munmap()</code>更新内存映射也会影响其他进程 (与<code>vfork()</code>相同)。若未指定该标志，则父进程和子进程不会共享虚拟内存页，子进程会获得父进程调用<code>clone()</code>时的虚拟内存的副本 (与<code>fork()</code>相同)。</p><p>　　共享虚拟内存是线程的关键属性之一，也是POSIX线程所要求的。</p><h5 id="线程组">28.2.1.5 线程组</h5><p>　　若指定了标志<code>CLONE_THREAD</code>，则将子进程放置在父进程所在的进程组。若未指定该标志，则将子进程放置在自己的进程组。</p><p>　　Linux 2.4添加了<span style="background-color:#ff0">线程组</span>，以允许线程库支持POSIX线程要求——进程的所有线程共享同一进程ID。线程组是1组共享相同线程组ID的KSE。在<code>CLONE_THREAD</code>的后续内容中，会将这些KSE称为线程。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_28/a_thread_group_containing_four_threads.svg" title="a_thread_group_containing_four_threads"><p>　　线程组中的线程通过系统范围内唯一的线程ID (TID) 区分。Linux 2.4添加了系统调用<code>gettid()</code>，该系统调用允许线程获取自己的线程ID。线程ID使用的数据类型与进程ID的相同，即<code>pid_t</code>。这里的线程ID不同于POSIX线程使用的线程ID (数据类型为<code>pthread_t</code>)，后者由POSIX线程在内部 (用户空间) 生成和维护。</p><p>　　新线程组中的第1个线程是<span style="background-color:#ff0">线程组组长</span>，其线程ID与线程组ID相同。内核会保证没有线程ID会与系统中的任何进程ID相同 (除非线程是进程的线程组组长)。线程组中的所有线程的父进程ID相同 (即线程组组长的线程ID)。只有线程组中的所有线程都终止后，信号<code>SIGCHLD</code> (或其他终止信号) 才会被发送给其父进程 (这是POSIX线程所要求的)。</p><p>　　<code>CLONE_THREAD</code>线程终止时调用<code>clone()</code>的线程不会收到任何信号，所以无法通过<code>wait()</code> (或类似的函数) 来等待此类线程 (这是POSIX线程所要求的)。POSIX线程不同于进程，需要通过<code>pthread_join()</code>等待 (而非<code>wait()</code>)。为了获取<code>CLONE_THREAD</code>线程的终止状态，需要使用称为<span style="background-color:#ff0">futex</span>的特殊同步原语。</p><p>　　若线程组中的任一线程调用<code>exec()</code>，则该线程组中的除线程组组长之外的所有线程都会终止 (这是POSIX线程所要求的)，并且新程序将在线程组组长中执行。在<code>exec()</code>期间， 该进程终止时发送给父进程的终止信号会被重置为<code>SIGCHLD</code>。</p><p>　　若线程组中的任一线程调用<code>fork()</code>或<code>vfork()</code>，则该线程组中的所有线程都可以通过<code>wait()</code> (或类似的函数) 来监控子进程。</p><p>　　对于Linux 2.2及以下版本，<code>clone()</code>实现未提供<code>CLONE_THREAD</code>。LinuxThreads将POSIX线程实现为共享虚拟内存等属性的进程 (进程ID不同)。为了保证兼容性，即使对于现代Linux内核，LinuxThreads实现也不会使用该标志，所以LinuxThreads实现中的线程的进程ID不同。</p><p>　　对于Linux 2.6及以上版本，若指定了<code>CLONE_THREAD</code>，则必须还指定<code>CLONE_SIGHAND</code>。这是POSIX线程所要求的 (内核对<code>CLONE_THREAD</code>线程组的信号的处理反映了POSIX对进程中的线程如何响应信号的要求)。</p><h5 id="线程库支持">28.2.1.6 线程库支持</h5><p>　　Linux 2.6添加了标志<code>CLONE_PARENT_SETTID</code>、<code>CLONE_CHILD_SETTID</code>和<code>CLONE_CHILD_CLEARTID</code>来支持POSIX线程实现。这些标志会影响<code>clone()</code>如何处理参数<code>ptid</code>和<code>ctid</code>。</p><p>　　标志<code>CLONE_PARENT_SETTID</code>和<code>CLONE_CHILD_CLEARTID</code>用于NPTL线程实现。</p><p>　　若指定了标志<code>CLONE_PARENT_SETTID</code>，则内核会将子线程的线程ID写入到<code>ptid</code>指向的位置。线程ID的复制先于父进程内存的复制，这表示即使未指定标志<code>CLONE_VM</code>，父线程和子线程都可以该位置看到子线程的线程ID。</p><p>　　标志<code>CLONE_PARENT_SETTID</code>的存在是为了给线程实现提供1种可靠的方法来获取新线程的线程ID，因为仅仅通过<code>clone()</code>的返回值来获取新线程的线程ID是不够的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tid = clone(...);</span><br></pre></td></tr></table></figure><p>　　这会导致竞争条件，因为赋值实际发生在<code>clone()</code>之后。假设新线程终止，并且其终止信号的处理函数在赋值之前被调用。此时，信号处理函数通常无法访问<code>tid</code> (在线程库中，<code>tid</code>可能是全局记录结构中的1个条目，用于跟踪所有线程的状态)。直接调用<code>clone()</code>的程序通常设计为可以避免这个竞争条件，但线程库无法控制调用它的程序的行为。使用标志<code>CLONE_PARENT_SETTID</code>可以确保在<code>clone()</code>返回之前将新线程的线程ID放置<code>ptid</code>指向的位置，进而让线程库避免此类竞争条件。</p><p>　　若指定了标志<code>CLONE_CHILD_SETTID</code>，则<code>clone()</code>会将子线程的线程ID写入到<code>ctid</code>指向的位置。<code>ctid</code>的设置仅在子线程的内存中完成 (若指定了标志<code>CLONE_VM</code>，则也会影响父线程)。尽管NPTL不需要该标志，但提供该标志是为了给其他的可能实现库提供灵活性。</p><p>　　若指定了标志<code>CLONE_CHILD_CLEARTID</code>，则<code>clone()</code>会在子线程终止时将<code>ctid</code>指向的位置设置为0。</p><p>　　参数<code>ctid</code>是NPTL线程实现获取线程终止通知的机制，而这些通知是<code>pthread_join()</code>所需要的。</p><p>　　当通过<code>pthread_create()</code>创建子线程时，NPTL会调用<code>clone()</code>来让<code>ptid</code>和<code>ctid</code>指向同一位置 (这也是NPTL为什么不需要<code>CLONE_CHILD_SETTID</code>)。标志<code>CLONE_PARENT_SETTID</code>会导致该位置初始化为新线程的线程ID。当子线程终止时，<code>ctid</code>会被清除，而这些修改对进程的所有线程都是可见的 (因为指定了标志<code>CLONE_VM</code>)。</p><p>　　内核处理<code>ctid</code>指向的位置的方式如同futex。线程终止通知可以通过系统调用<code>futex()</code>来获取，该系统调用会阻塞在等待<code>ctid</code>指向的位置的值发生变化 (这就是<code>pthred_join()</code>所做的事情)。内核在清除<code>ctid</code>的同时还会唤醒任一在该地址上执行futex等待而被阻塞的线程 (在POSIX线程级别，这会导致<code>pthred_join()</code>调用解除阻塞)。</p><h5 id="线程本地存储">28.2.1.7 线程本地存储</h5><p>　　若指定了标志<code>CLONE_SETTLS</code>，则参数<code>tls</code>会指向结构体<code>user_desc</code>，该结构体描述了用于该线程的线程本地存储缓冲区。Linux 2.6添加了该标志来支持线程本地存储的NPTL实现。</p><h5 id="共享system-v信号量撤销值">28.2.1.8 共享System V信号量撤销值</h5><p>　　若指定了标志<code>CLONE_SYSVSEM</code>，则父进程和子进程会共享System V信号量撤销值列表。若未指定该标志，则父进程和子进程的撤销列表独立，并且子进程的撤销列表初始为空。</p><p>　　Linux 2.6开始支持标志<code>CLONE_SYSVSEM</code>，并且提供了POSIX线程所需的共享语义。</p><h5 id="进程级挂载命名空间">28.2.1.9 进程级挂载命名空间</h5><p>　　父进程和子进程默认共享挂载命名空间 (见14.7)，这表示这些进程中的任一进程通过<code>mount()</code>和<code>umount()</code>对挂载命名空间的修改对其他进程是可见的 (与<code>fork()</code>和<code>vfork()</code>相同)。特权进程 (能力<code>CAP_SYS_ADMIN</code>) 可以指定标志<code>CLONE_NEWNS</code>来让子进程获得父进程的挂载命名空间的副本。此后，这些进程中的任一进程通过<code>mount()</code>和<code>umount()</code>对挂载命名空间的修改对其他进程不可见。</p><p>　　进程级挂载命名空间可用于创建与chroot jail类似的环境列表。相比chroot jail，这种方式更安全和灵活 (例如，可以为jail中的进程提供1个对系统中的其他进程不可见的挂载点)。挂载命名空间在设置虚拟服务器环境时也很有用。</p><p>　　调用<code>clone()</code>时同时指定标志<code>CLONE_NEWNS</code>和<code>CLONE_FS</code>是没有意义的，也是不允许的。</p><h5 id="让子进程的父进程与调用进程的父进程相同">28.2.1.10 让子进程的父进程与调用进程的父进程相同</h5><p>　　当通过<code>clone()</code>创建新进程时，新进程的父进程默认是调用<code>clone()</code>的进程 (与<code>forK()</code>和<code>vforK()</code>相同)。若指定了标志<code>CLONE_PARENT</code>，则新进程的父进程将会是调用<code>clone()</code>的进程的父进程。当新进程终止时，信号会被发送给调用<code>clone()</code>的进程的父进程。</p><p>　　Linux 2.4开始支持标志<code>CLONE_PARENT</code>。该标志最初设计为供POSIX线程实现使用。但是，Linux 2.6使用了1种无需使用该标志的实现线程的方式，从而消除了对该标志的依赖。</p><h5 id="让子进程的进程id与父进程的进程id相同">28.2.1.11 让子进程的进程ID与父进程的进程ID相同</h5><p>　　若指定了标志<code>CLONE_PID</code>，则子进程的进程ID会与父进程的进程ID相同。若未指定该标志，则父进程的进程ID与子进程的进程ID不同 (与<code>forK()</code>和<code>vforK()</code>相同)。只有系统引导进程 (进程ID为0) 可以指定该标志 (初始化多处理器系统时)。</p><p>　　标志<code>CLONE_PID</code>不适用于用户应用程序。对于Linux 2.6，该标志被删除，并被标志<code>CLONE_IDLETASK</code>取代，后者会将新进程的进程ID设置为0。<code>CLONE_IDLETASK</code>仅供内核内部使用 (若调用<code>clone()</code>时指定了该标志，则会被忽略)。该标志用于创建不可见的CPU级空闲进程，在多处理器系统中，该进程可能存在多个实例。</p><h5 id="进程跟踪">28.2.1.12 进程跟踪</h5><p>　　若指定了标志<code>CLONE_PTRACE</code>，并且调用进程正在被跟踪，则子进程也会被跟踪 (进程跟踪详情见<code>ptrace()</code>的手册页)。对于Linux 2.6及以上版本，可以指定标志<code>CLONE_UNTRACED</code>，这会导致正在被跟踪的调用进程无法强制将<code>CLONE_PTRACE</code>应用于子进程。标志<code>CLONE_UNTRACED</code>在创建内核线程时供内核内部使用。</p><h5 id="挂起父进程直到子进程退出或调用exec">28.2.1.13 挂起父进程，直到子进程退出或调用<code>exec()</code></h5><p>　　若指定了标志<code>CLONE_VFORK</code>，则父进程会被挂起，直到子进程通过<code>exec()</code>或<code>_exit()</code> (或<code>exit()</code>) 释放其虚拟内存资源 (与<code>vfork()</code>相同)。</p><h5 id="用于支持容器的新clone标志">28.2.1.14 用于支持容器的新<code>clone()</code>标志</h5><p>　　Linux 2.6.19及以上版本添加了<code>clone()</code>标志<code>CLONE_IO</code>、<code>CLONE_NEWIPC</code>、<code>CLONE_NEWNET</code>、<code>CLONE_NEWPID</code>、<code>CLONE_NEWUSER</code>和<code>CLONE_NEWUTS</code>。</p><p>　　这些标志大多是为了支持<span style="background-color:#ff0">容器</span>实现而提供的。容器是轻量级虚拟化的形式之一，通过这种形式，在同一内核上运行的进程组可以在看似独立机器的环境中彼此隔离。此外，容器还可以嵌套。容器与完全虚拟化形成对比，在完全虚拟化中，所有虚拟化环境都运行不同的内核。</p><p>　　为了实现容器，内核开发者必须在内核中为每个全局系统资源 (例如，进程ID、网络栈、<code>uname()</code>返回的ID、System V IPC对象以及用户和组ID命名空间) 提供1个间接层，以便每个容器可以提供自己的这些资源实例。</p><p>　　容器有多种可能的用途，包括如下：</p><p>　　● 控制网络带宽和CPU时间等系统资源的分配 (例如，某个容器可能被授予75%的CPU时间，而另一个容器被授予25%的CPU时间)。</p><p>　　● 在单个主机上提供多个轻量级虚拟化服务器。</p><p>　　● 冻结容器，以便暂停容器中所有进程的执行，随后重新启动 (可能迁移到其他机器上)。</p><p>　　● 通过冻结容器来转储 (创建检查点) 应用程序的状态并在稍后恢复 (可能是在应用程序崩溃或系统关闭后)，以便从检查点的时间继续计算。</p><h5 id="clone标志的用法">28.2.1.15 <code>clone()</code>标志的用法</h5><p>　　 <code>forK()</code>大致可以视为仅指定了标志<code>SIGCHLD</code>的<code>clone()</code>， 而<code>vforK()</code>可以视为指定了以下标志的<code>clone()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLONE_VM | CLONE_VFORK | SIGCHLD</span><br></pre></td></tr></table></figure><p>　　LinuxThreads线程实现使用<code>clone()</code> (仅使用前4个参数) 创建线程会指定以下标志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND</span><br></pre></td></tr></table></figure><p>　　NPTL线程实现使用<code>clone()</code> (使用所有参数) 创建线程会指定以下标志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD |</span><br><span class="line">CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</span><br></pre></td></tr></table></figure><p>　　从版本2.3.3开始，作为NPTL线程实现的一部分的glibc的<code>fork()</code>包装函数绕过了内核的系统调用<code>fork()</code>，直接调用<code>clone()</code>。这个包装函数会调用由调用者使用<code>pthread_atfork()</code>注册的任何fork处理函数。</p><h4 id="克隆子进程的waitpid扩展">28.2.2 克隆子进程的<code>waitpid()</code>扩展</h4><p>　　为了等待通过<code>clone()</code>创建的子进程，<code>waitpid()</code>、<code>wait3()</code>和<code>wait4()</code>的位掩码参数<code>options</code>可以包含特定于Linux的附加位<code>__WCLONE</code>、<code>__WALL</code>和<code>__WNOTHREAD</code>。</p><p>　　● 若指定了<code>__WCLONE</code>，则仅等待<span style="background-color:#ff0">克隆子进程</span>。若未指定该值，则等待非克隆子进程。这里的克隆子进程是指终止时发送给父进程的信号是<code>SIGCHLD</code>之外的信号的子进程。若还指定了<code>__WALL</code>，则<code>__WCLONE</code>会被忽略。</p><p>　　● 若指定了<code>__WALL</code> (Linux 2.4及以上版本)，则等待所有子进程 (无论是否为克隆子进程)。</p><p>　　● 若指定了<code>__WNOTHREAD</code> (Linux 2.4及以上版本)，则仅等待调用进程的子进程 (在默认情况下，等待调用会等待调用进程所属线程组中的所有进程的子进程)。</p><p>　　这些位不能与<code>waitid()</code>一起使用。</p><h3 id="进程创建速度">28.3 进程创建速度</h3><table><colgroup><col style="width:11%"><col style="width:29%"><col style="width:29%"><col style="width:29%"></colgroup><thead><tr><th>创建进程的使用方法</th><th>1.70M的进程内存</th><th>2.70M的进程内存</th><th>11.70M的进程内存</th></tr></thead><tbody><tr><td><code>fork()</code></td><td>用时22.27 (7.99) 秒，进程创建速度为4544个进程/秒</td><td>用时26.38 (8.98) 秒，进程创建速度为为4135个进程/秒</td><td>用时126.38 (52.55)秒，进程创建速度为为1276个进程/秒</td></tr><tr><td><code>vfork()</code></td><td>用时3.52 (2.49) 秒，进程创建速度为28955个进程/秒</td><td>用时3.55 (2.50) 秒，进程创建速度为为28621个进程/秒</td><td>用时3.53 (2.51) 秒，进程创建速度为为28810个进程/秒</td></tr><tr><td><code>clone()</code></td><td>用时2.97 (2.14) 秒，进程创建速度为34333个进程/秒</td><td>用时2.98 (2.13) 秒，进程创建速度为为34217个进程/秒</td><td>用时2.93 (2.10) 秒，进程创建速度为为34688个进程/秒</td></tr><tr><td><code>fork()</code> + <code>exec()</code></td><td>用时135.72 (12.39) 秒，进程创建速度为为764个进程/秒</td><td>用时146.15 (16.69) 秒，进程创建速度为为719个进程/秒</td><td>用时260.34 (61.68) 秒，进程创建速度为为435个进程/秒</td></tr><tr><td><code>vfork()</code> + <code>exec()</code></td><td>用时107.36 (6.27) 秒，进程创建速度为为969个进程/秒</td><td>用时107.81 (6.35) 秒，进程创建速度为为964个进程/秒</td><td>用时107.97 (6.38) 秒，进程创建速度为为960个进程/秒</td></tr></tbody></table><p>　　上表列出了不同进程创建方法的速度比较。测试程序会循环创建子进程并等待其终止。此外，上表还展示了不同进程内存大小对进程创建速度的影响。进程内存大小的差异通过在计时前让程序使用<code>malloc()</code>在堆上分配额外内存来模拟 (进程内存的值取自命令<code>ps –o "pid vsz cmd"</code>的结果的VSZ值)。</p><p>　　对于每个进程，上表提供展示了2种类型的统计数据：</p><p>　　● 第1个统计数据是时间。主要测量执行100000个进程创建操作所有的总 (实际) 时间。括号中的时间是父进程使用的CPU时间。因为这些测试是在没有负载的机器上进行，所以这2个时间值之间的差值表示测试期间创建的子进程所使用的总时间。</p><p>　　● 第2个统计数据是进程创建速度。</p><p>　　这些数据是每种情况运行20次的平均值，使用的是x86-32系统上运行的内核2.6.27。</p><p>　　前3行展示了简单进程创建 (子进程不会执行新程序) 的时间。对于每种情况，子进程在被创建后会立即终止，然后父进程在等待子进程终止后继续创建下一个子进程 (<code>vfork()</code>和<code>clone()</code>数据的细微变化是因为采样误差和调用差异)。</p><p>　　第1行展示了<code>fork()</code>的数据。随着进程内存的增加，<code>fork()</code>的用时更长。这些时间差体现了为子进程复制越来越大的页表并将所有数据、堆和栈段页标记为只读所需的额外时间 (这里实际上不会复制页，因为子进程不会修改其数据段或栈)。</p><p>　　第2行展示了<code>vfork()</code>的数据。随着进程内存的增加，<code>vfork()</code>的用时不变。因为<code>vfork()</code>不会复制页表或页，所以调用进程的虚拟内存大小对其没有影响。</p><p>　　第3行展示了<code>clone()</code>指定以下标志时的数据 (这里的时间是基于glibc的<code>clone()</code>包装函数，而非直接调用<code>sys_clone()</code>。这里未展示的其他测试表明，在子进程立即退出的情况下，两者之间的时间差异可以忽略不计)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLONE_VM | CLONE_VFORK | CLONE_FS | CLONE_SIGHAND | CLONE_FILES</span><br></pre></td></tr></table></figure><p>　　前2个标志用于模拟<code>vfork()</code>，其他标志用于指定父进程和子进程应该共享其他文件系统属性 (umask、根目录和当前工作目录)、信号处理方式和打开的文件描述符表。<code>vfork()</code>和<code>clone()</code>的数据之间的差异表示<code>vfork()</code>执行的一些额外操作，这些操作用于将这些信息复制到子进程。复制文件系统属性和信号处理方式的时间是不变的。但是，复制打开的文件描述符表的时间会随着描述符的数量而变化。当进程内存为1.70MB时，若在父进程中打开100个文件描述符，则<code>vfork()</code>的总耗时会从3.52秒增加到5.04秒，但<code>clone()</code>不受影响。</p><p>　　<code>fork()</code>和<code>vfork()</code>之间的差异非常明显。但是，需要注意以下几点：</p><p>　　● 最后1列的数据表明，对于较大的进程，<code>vfork()</code>比<code>fork()</code>快30倍以上 (常规进程的数据大致位于前2列)。</p><p>　　● 由于创建进程所需的时间通常比<code>exec()</code>所需的时间短很多，所以当<code>fork()</code>或<code>vfork()</code>后立即调用<code>exec()</code>时，差距就不会那么明显。这在上表的最后2行得到了体现，在这些数据中，每个子进程都会调用<code>exec()</code> (而非立即退出)。这里执行的程序是命令<code>true</code> (即<code>/bin/true</code>，选择它是因为不会产生任何输出)。在这种情况下，<code>fork()</code>和<code>vfork()</code>的相对差异小很多。</p><p>　　实际上，上表的数据并未揭示<code>exec()</code>的全部成本，因为子进程在测试的每个循环中都执行同一程序。因此，将程序读取到内存的磁盘I/O成本基本上被消除了 (程序在第1次调用<code>exec()</code>时会被读取到内核缓冲区缓存，并一直留在那里)。若测试的每次循环都执行不同的程序 (例如，同一程序的不同命名副本)，则<code>exec()</code>的成本会更大。</p><h3 id="exec和fork对进程属性的影响">28.4 <code>exec()</code>和<code>fork()</code>对进程属性的影响</h3><p>　　下表列出了进程调用<code>exec()</code>对进程属性的影响和调用<code>fork()</code>后子进程继承的进程属性 (<code>exec()</code>列表示<code>exec()</code>期间哪些进程属性会被保留。<code>fork()</code>列表示<code>fork()</code>后子进程继承或共享的进程属性。除了标记为特定于Linux的进程属性之外，其他所有列出的进程属性均出现在标准UNIX实现中，并且它们在<code>exec()</code>和<code>fork()</code>期间的处理符合SUSv3的要求)：</p><table><colgroup><col style="width:24%"><col style="width:6%"><col style="width:4%"><col style="width:30%"><col style="width:33%"></colgroup><thead><tr><th>进程属性</th><th><code>exec()</code></th><th><code>fork()</code></th><th>影响进程属性的接口</th><th>说明</th></tr></thead><tbody><tr><td>文本段</td><td>✕</td><td>共享</td><td></td><td>子进程与父进程共享文本段</td></tr><tr><td>栈段</td><td>✕</td><td>✓</td><td><code>allloca()</code>、<code>longjmp()</code>和<code>siglongjmp()</code></td><td>函数入口/出口</td></tr><tr><td>数据和堆段</td><td>✕</td><td>✓</td><td><code>brk()</code>和<code>sbrk()</code></td><td></td></tr><tr><td>环境变量</td><td>✓</td><td>✓</td><td><code>putenv()</code>和<code>setenv()</code></td><td>直接修改环境列表 (环境变量会被<code>execle()</code>和<code>execve()</code>覆盖，其余的<code>exec()</code>调用会保留环境列表)</td></tr><tr><td>内存映射</td><td>✕</td><td>✓</td><td><code>mmap()</code>和<code>munmap()</code></td><td>被标记为<code>madvise(MADV_DONTFORK)</code>的映射在<code>forK()</code>后不会被继承。映射的标志<code>MAP_NORESERVE</code>在<code>fork()</code>后会被继承</td></tr><tr><td>内存锁</td><td>✕</td><td>✕</td><td><code>mlock()</code>和<code>munlock()</code></td><td></td></tr><tr><td>进程ID</td><td>✓</td><td>✕</td><td></td><td></td></tr><tr><td>父进程ID</td><td>✓</td><td>✕</td><td></td><td></td></tr><tr><td>进程组ID</td><td>✓</td><td>✓</td><td><code>setpgid()</code></td><td></td></tr><tr><td>会话ID</td><td>✓</td><td>✓</td><td><code>setsid()</code></td><td></td></tr><tr><td>实际ID</td><td>✓</td><td>✓</td><td><code>setuid()</code>、<code>setgid()</code>和相关调用</td><td></td></tr><tr><td>有效ID、保存的set-user-ID和保存的set-group-ID</td><td>✓</td><td>✓</td><td><code>setuid()</code>、<code>setgid()</code>和相关调用</td><td>见第9章</td></tr><tr><td>辅助组ID</td><td>✓</td><td>✓</td><td><code>setgroups()</code>和<code>initgroups()</code></td><td></td></tr><tr><td>打开的文件描述符</td><td>✓</td><td>✓</td><td><code>open()</code>、<code>close()</code>、<code>dup()</code>、<code>pipe()</code>、<code>socket()</code>等函数</td><td>文件描述符在<code>exec()</code>期间会被保留，除非启用了close-on-exec标志。子进程的文件描述符和父进程的对应文件描述符引用同一文件 (见第5章)</td></tr><tr><td>close-on-exec标志</td><td>✓ (若未启用)</td><td>✓</td><td><code>fcntl(F_SETFD)</code></td><td></td></tr><tr><td>文件偏移量</td><td>✓</td><td>共享</td><td><code>lseek()</code>、<code>read()</code>、<code>write()</code>、<code>readv()</code>和<code>writev()</code></td><td>子进程与父进程共享文件偏移量</td></tr><tr><td>打开文件状态标志</td><td>✓</td><td>共享</td><td><code>open()</code>和<code>fcntl(F_SETFL)</code></td><td>子进程与父进程共享打开文件状态标志</td></tr><tr><td>异步I/O操作</td><td>✓</td><td>✕</td><td><code>aio_read()</code>、<code>aio_write()</code>和相关调用</td><td>未完成的操作在<code>exec()</code>期间会被取消</td></tr><tr><td>目录流</td><td>✕</td><td>✓</td><td><code>opendir()</code>和<code>readdir()</code></td><td>SUSv3规定，子进程会获得父进程目录流的副本，但这些副本可能会共享 (或不共享) 目录流的位置。对于Linux，目录流的位置不会共享</td></tr><tr><td>当前工作目录</td><td>✓</td><td>✓</td><td><code>chdir()</code></td><td></td></tr><tr><td>根目录</td><td>✓</td><td>✓</td><td><code>chroot()</code></td><td></td></tr><tr><td>文件模式创建掩码</td><td>✓</td><td>✓</td><td><code>umask()</code></td><td></td></tr><tr><td>信号处理方式</td><td>✓</td><td>✓</td><td><code>signal()</code>和<code>sigaction()</code></td><td>在<code>exec()</code>期间，处理方式是默认或被忽略的信号的处理方式保持不变，其他信号的处理方式将会被设置为默认 (见27.4)</td></tr><tr><td>信号掩码</td><td>✓</td><td>✓</td><td><code>sigprocmask()</code>和<code>sigaction()</code></td><td></td></tr><tr><td>待处理信号集</td><td>✓</td><td>✕</td><td><code>raise()</code>、<code>kill()</code>和<code>sigqueue()</code></td><td></td></tr><tr><td>备用信号栈</td><td>✕</td><td>✓</td><td><code>sigaltstack()</code></td><td></td></tr><tr><td>间隔定时器</td><td>✓</td><td>✕</td><td><code>setitimer()</code></td><td></td></tr><tr><td>由<code>alarm()</code>设置的定时器</td><td>✓</td><td>✕</td><td><code>alarm()</code></td><td></td></tr><tr><td>POSIX定时器</td><td>✕</td><td>✕</td><td><code>timer_create()</code>和相关调用</td><td></td></tr><tr><td>线程</td><td>✕</td><td>✓</td><td></td><td>在<code>fork()</code>期间，只有调用线程会在子进程中复制</td></tr><tr><td>线程可取消状态和类型</td><td>✕</td><td>✓</td><td></td><td>在<code>exec()</code>后，可取消类型和状态会被分别重置为<code>PTHREAD_CANCEL_ENABLE</code>和<code>PTHREAD_CANCEL_DEFERRED</code></td></tr><tr><td>互斥锁和条件变量</td><td>✕</td><td>✓</td><td></td><td></td></tr><tr><td>nice值</td><td>✓</td><td>✓</td><td><code>nice()</code>和<code>setpriority()</code></td><td></td></tr><tr><td>调度策略和优先级</td><td>✓</td><td>✓</td><td><code>sched_setscheduler()</code>和<code>sched_setparam()</code></td><td></td></tr><tr><td>资源限制</td><td>✓</td><td>✓</td><td><code>setrlimit()</code></td><td></td></tr><tr><td>进程和子进程CPU时间</td><td>✓</td><td>✕</td><td></td><td>由<code>times()</code>返回</td></tr><tr><td>资源使用情况</td><td>✓</td><td>✕</td><td></td><td>由<code>getrusage()</code>返回</td></tr><tr><td>System V共享内存段</td><td>✕</td><td>✓</td><td><code>shmat()</code>和<code>shmdt()</code></td><td></td></tr><tr><td>POSIX共享内存</td><td>✕</td><td>✓</td><td><code>shm_open()</code>和相关调用</td><td></td></tr><tr><td>POSIX消息队列</td><td>✕</td><td>✓</td><td><code>mq_open()</code>和相关调用</td><td>子进程的描述符与父进程的对应描述符引用同一打开消息队列描述。子进程不会继承父进程的消息通知注册</td></tr><tr><td>POSIX命名信号量</td><td>✕</td><td>共享</td><td><code>sem_open()</code>和相关调用</td><td>子进程与父进程共享相同信号量的引用</td></tr><tr><td>POSIX未命名信号量</td><td>✕</td><td>✓</td><td><code>sem_init()</code>和相关调用</td><td>若信号量位于共享内存区域，则子进程与父进程共享信号量；否则，子进程拥有自己的信号量副本</td></tr><tr><td>System V信号量调整</td><td>✓</td><td>✕</td><td><code>semop()</code></td><td></td></tr><tr><td>文件锁</td><td>✓</td><td>✓</td><td><code>flock()</code></td><td>子进程继承与父进程相同的锁的引用</td></tr><tr><td>记录锁</td><td>✓</td><td>✕</td><td><code>fcntl(F_SETLK)</code></td><td>在<code>exec()</code>期间，锁将被保留，除非引用文件的文件描述符被标记为close-on-exec</td></tr><tr><td>区域设置</td><td>✕</td><td>✓</td><td><code>setlocale()</code></td><td>作作为C运行时初始化的一部分，等同于<code>setlocale(LC_ALL, "C")</code>的命令会在执行新程序后被执行</td></tr><tr><td>浮点环境</td><td>✕</td><td>✓</td><td></td><td></td></tr><tr><td>控制终端</td><td>✓</td><td>✓</td><td></td><td>当执行新程序时，浮点环境的状态会被重置为默认</td></tr><tr><td>退出处理函数</td><td>✕</td><td>✓</td><td><code>atexit()</code>和<code>on_exit()</code></td><td></td></tr><tr><td>文件系统ID</td><td>✓</td><td>✓</td><td><code>setfsuid()</code>和<code>setfsgid()</code></td><td>这些ID会在对应的有效ID更改时随之更改</td></tr><tr><td>timerfd定时器</td><td>✓</td><td>✓</td><td><code>timerfd_create()</code></td><td>子进程会继承引用与父进程相同定时器的文件描述符</td></tr><tr><td>能力</td><td>✓</td><td>✓</td><td><code>capset()</code></td><td></td></tr><tr><td>能力边界集</td><td>✓</td><td>✓</td><td></td><td></td></tr><tr><td>能力<code>securebits</code>标志</td><td>✓</td><td>✓</td><td></td><td>在<code>exec()</code>期间，除<code>SECBIT_KEEP_CAPS</code>之外的所有<code>securebits</code>标志都会被保留 (<code>SECBIT_KEEP_CAPS</code>总是会被清除)</td></tr><tr><td>CPU亲和性</td><td>✓</td><td>✓</td><td><code>sched_setaffinity()</code></td><td></td></tr><tr><td><code>SCHED_RESET_ON_FORK</code></td><td>✓</td><td>✕</td><td></td><td></td></tr><tr><td>允许的CPU</td><td>✓</td><td>✓</td><td></td><td>见cpuset文件系统</td></tr><tr><td>允许的内存节点</td><td>✓</td><td>✓</td><td></td><td>见cpuset文件系统</td></tr><tr><td>内存策略</td><td>✓</td><td>✓</td><td></td><td>见<code>set_mempolicy()</code></td></tr><tr><td>文件租约</td><td>✓</td><td>✓</td><td><code>fcntl(F_SETLEASE)</code></td><td>子进程会继承与父进程相同的租约引用</td></tr><tr><td>目录修改通知</td><td>✓</td><td>✕</td><td>dnotify API</td><td></td></tr><tr><td><code>prctl(PR_SET_DUMPABLE)</code></td><td>✓</td><td>✕</td><td></td><td>在<code>exec()</code>期间，除了set-user-ID程序和set-group-ID程序之外的所有程序的标志<code>PR_SET_DUMPABLE</code>会被设置 (set-user-ID程序和set-group-ID程序程序的该标志会被清除)</td></tr><tr><td><code>prctl(PR_SET_PDEATHSIG)</code></td><td>✕</td><td>✓</td><td></td><td></td></tr><tr><td><code>oom_adj</code></td><td>✓</td><td>✓</td><td></td><td></td></tr><tr><td><code>coredump_filter</code></td><td>✓</td><td>✓</td><td></td><td></td></tr></tbody></table></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_27/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第27章 程序执行"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第27章 程序执行</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_29/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第29章 线程：简介">《Linux/UNIX系统编程手册》第29章 线程：简介 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>