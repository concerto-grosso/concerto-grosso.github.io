<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_42/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_42/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_42/","title":"《Linux/UNIX系统编程手册》第42章 共享库高级特性"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第42章 共享库高级特性 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%BA%93"><span class="nav-text">42.1 动态加载库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dlopen"><span class="nav-text">42.1.1 dlopen()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dlerror"><span class="nav-text">42.1.2 dlerror()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dlsym"><span class="nav-text">42.2.3 dlsym()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dlclose"><span class="nav-text">42.2.4 dlclose()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dladdr"><span class="nav-text">42.2.5 dladdr()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%B8%BB%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%AC%A6%E5%8F%B7"><span class="nav-text">42.2.6 在主程序中访问符号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%AC%A6%E5%8F%B7%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">42.2 控制符号可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E7%89%88%E6%9C%AC%E8%84%9A%E6%9C%AC"><span class="nav-text">42.3 链接器版本脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%89%88%E6%9C%AC%E8%84%9A%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AC%A6%E5%8F%B7%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">42.3.1 使用版本脚本控制符号可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="nav-text">42.3.2 符号版本控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%BB%88%E6%AD%A2%E5%87%BD%E6%95%B0"><span class="nav-text">42.4 初始化和终止函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">42.5 监控动态加载器</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_42/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第42章 共享库高级特性 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第42章 共享库高级特性</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2026-01-18 00:00:00" itemprop="dateCreated datePublished" datetime="2026-01-18T00:00:00+08:00">2026-01-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2026-01-19 00:00:00" itemprop="dateModified" datetime="2026-01-19T00:00:00+08:00">2026-01-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　出于测试目的，有时可以有选择地覆盖动态链接器基于41.8中的规则通常会找到的函数 (或其他符号)。为此，可以将环境变量<code>LD_PRELOAD</code>定义为由空格或冒号<code>:</code>分隔的共享库名组成的字符串，这些共享库会在其他共享库之前被加载 (这些共享库定义的所有函数都会在可执行文件需要时自动被使用，从而覆盖动态链接器本来可能搜索的同名其他函数)。</p><p>　　假设程序<code>prog</code>会调用函数<code>x1()</code>和<code>x2()</code>，这2个函数被定义在位于标准目录的共享库<code>libdemo.so</code>中。当运行该程序时，会得到以下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./prog</span></span><br><span class="line">Called mod1-x1 DEMO</span><br><span class="line">Called mod2-x2 DEMO</span><br></pre></td></tr></table></figure><p>　　这里可以通过创建共享库<code>libalt.so</code>来覆盖函数<code>x1()</code>，该共享库包含<code>x1()</code>的不同定义。当运行程序时，预加载该库会得到以下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_PRELOAD=libalt.so ./prog</span></span><br><span class="line">Called mod1-x1 ALT</span><br><span class="line">Called mod2-x2 DEMO</span><br></pre></td></tr></table></figure><p>　　根据结果可知，程序调用的是<code>libalt.so</code>中的<code>x1()</code>定义和<code>libdemo.so</code>中的<code>x2()</code>定义，因为<code>libalt.so</code>中未定义<code>x2()</code>。</p><p>　　环境变量<code>LD_PRELOAD</code>用于控制进程级预加载，而文件<code>/etc/ld.so.preload</code> (其中的共享库由空格分隔) 用于控制系统级预加载。环境变量<code>LD_PRELOAD</code>指定的库在文件<code>/etc/ld.so.preload</code>指定的库之前被加载。</p><p>　　出于安全原因，set-user-ID和set-group-ID程序会忽略环境变量<code>LD_PRELOAD</code>。</p><span id="more"></span><h3 id="动态加载库">42.1 动态加载库</h3><p>　　当启动可执行文件时，动态链接器会加载程序动态依赖列表中的所有共享库。有时，延迟加载共享库可能很有用 (例如，仅在需要时加载插件)。该功能由称为<span style="background-color:#ff0">dlopen</span>的动态加载器API提供。该API源于Solaris，其中的大部分内容都已被SUSv3标准化。该API的核心函数包括<code>dlopen()</code>、<code>dlsym()</code>、<code>dlclose()</code>和<code>dlerror()</code>。对于Linux，为了构建使用该API的程序，必须指定选项<code>-ldl</code>来链接库<code>libdl</code>。</p><p>　　dlopen API允许程序在运行时打开共享库并按照名称在该库中搜索函数，然后调用该函数。以这种方式在运行时被加载的共享库通常称为<strong>动态加载库</strong>，其创建方式与常规共享库相同。</p><h4 id="dlopen">42.1.1 <code>dlopen()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *libfilename, <span class="type">int</span> flags)</span>; <span class="comment">/* 成功时返回库句柄，出错时返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>dlopen()</code>会将名为<code>libfilename</code>的共享库加载到调用进程的虚拟地址空间并增加该库的打开引用计数。</p><p>　　若参数<code>libfilename</code>包含斜杠<code>/</code>，则<code>dlopen()</code>会将其解释为路径名；否则，动态链接器会按照41.8中的规则搜索共享库。若目标共享库依赖于其他共享库，则该函数会自动加载这些库。该过程会在必要时递归执行，这些加载库的集合称为该库的<span style="background-color:#ff0">依赖树</span>。</p><p>　　若<code>dlopen()</code>找到目标库，则返回可以在后续调用dlopen API中的其他函数时引用该库的句柄。若该函数出错 (例如，未找到共享库)，则返回<code>NULL</code>。</p><p>　　可以对同一库文件多次调用<code>dlopen()</code>。该库只会被加载1次 (第1次调用)，并且所有调用都会同一句柄值。但是，dlopen API为每个库句柄维护了引用计数。当调用<code>dlopen()</code>时，会增加引用计数；当调用<code>dlclose()</code>时，会减少引用计数。当且仅当引用计数为0时，<code>dlclose()</code>才会将库从内存中卸载。</p><p>　　参数<code>flags</code>是位掩码，必须正好包含标志<code>RTLD_LAZY</code>和<code>RTLD_NOW</code>之一。</p><p>　　● 标志<code>RTLD_LAZY</code>表示库中未定义的函数符号应该只在代码执行时才被解析。若需要某符号的代码段不会被执行，则该符号永远不会被解析。延迟加载仅适用于函数引用，变量引用总是立即被解析。指定该标志会提供与动态链接器在加载可执行文件动态依赖列表指定的共享库时的正常操作相对应的行为。</p><p>　　● 标志<code>RTLD_NOW</code>表示库中未定义的符号都应该在<code>dlopen()</code>完成之前立即被解析。因此，打开库会更慢，但所有潜在的未定义的函数符号错误都会立即被检测到，而非在后续的某个时间被检测到。对于调试应用程序或为了确保应用程序遇到未解析的符号时立即失败，这很有用。</p><p>　　参数<code>flags</code>还可以包含很多标志，SUSv3说明的标志如下：</p><p>　　● 标志<code>RTLD_GLOBAL</code>表示库以及其依赖树中的符号可用于解析该进程加载的其他库中的引用以及通过<code>dlsym()</code>进行搜索。</p><p>　　● 标志<code>RTLD_LOCAL</code>与<code>RTLD_GLOBAL</code>相反，即库以及其依赖树中的符号无法用于解析该进程加载的其他库中的引用。</p><p>　　SUSv3没有说明未指定这2个标志时的默认标志。Linux和大部分UNIX实现默认使用标志<code>RTLD_LOCAL</code>，而少部分UNIX实现默认使用标志<code>RTLD_GLOBAL</code>。</p><p>　　Linus还支持很多SUSv3未说明的标志：</p><p>　　● 标志<code>RTLD_NODELETE</code>表示即使引用计数为0，函数<code>dlclose()</code>也不会卸载库。这表示后续通过<code>dlopen()</code>重新加载库时其中的静态变量不会重新初始化 (对于由动态链接器自动加载的库，可以在通过命令<code>gcc</code>创建库时指定选项<code>–Wl,–znodelete</code>来达到类似的效果)。</p><p>　　● 标志<code>RTLD_NOLOAD</code> (glibc 2.2及以上版本) 表示不加载库，它有2个用途。首先，该标志可用于检查特定库是否已被加载。若是，则<code>dlopen()</code>返回库句柄；否则，<code>dlopen()</code>返回<code>NULL</code>。其次，该标志可用于 "提升" 已加载库的标志 (例如，在使用<code>dlopen()</code>打开之前使用<code>RTLD_LOCAL</code>打开的库时指定<code>RTLD_NOLOAD | RTLD_GLOBAL</code>)。</p><p>　　● 标志<code>RTLD_DEEPBIND</code> (glibc 2.3.4及以上版本) 表示当解析该库引用的符号时，应先在该库搜索定义，然后在已加载的库中搜索定义 (类似于链接器选项<code>–Bsymbolic</code>)。</p><p>　　Solaris的dlopen API也实现了标志<code>RTLD_NODELETE</code>和<code>RTLD_NOLOAD</code>，但只有少部分UNIX提供了这2个标志。标志<code>RTLD_DEEPBIND</code>是特定于Linux的。</p><p>　　对于glibc 2.1.1及以上版本，可以将环境变量<code>LD_BIND_NOW</code>设置未非空字符串来确保动态链接器在加载可执行文件的动态依赖列表指定的共享库时立即解析所有符号 (与标志<code>RTLD_NOW</code>类似)，该环境变量会覆盖<code>dlopen()</code>的标志<code>RTLD_LAZY</code>的效果。</p><p>　　作为特殊情况，<code>libfilename</code>可以被指定为<code>NULL</code>。这会导致<code>dlopen()</code>返回主程序的句柄 (SUSv3将其称为 "全局符号目标" 的句柄)。若在后续调用<code>dlsym()</code>时指定该句柄，则会先在主程序中搜索目标符号，然后在程序启动时加载的库中搜索，最后在用标志<code>RTLD_GLOBAL</code>动态加载的库中搜索。</p><h4 id="dlerror">42.1.2 <code>dlerror()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 上一次调用出错时返回错误诊断字符串，否则返回返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　当dlopen API函数出错时，可以通过函数<code>dlerror()</code>来获取表示错误原因的字符串。该函数会在上一次调用dlopen API函数未出错时返回<code>NULL</code>。</p><h4 id="dlsym">42.2.3 <code>dlsym()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">char</span> *symbol)</span>; <span class="comment">/* 找到symbol时返回其地址，否则返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>dlsym()</code>会在参数<code>handle</code> (通常是之前调用<code>dlopen()</code>返回的库句柄，有时也可以是<span style="background-color:#ff0">伪句柄</span>) 引用的库及其依赖树中搜索名称<code>symbol</code> (函数或变量)。若找到，则返回其地址；否则，返回<code>NULL</code>。</p><p>　　<code>dlsym()</code>返回的符号的值可能是<code>NULL</code>，这会与未找到符号的情况混淆。为此，必须在调用<code>dlsym()</code>前后都调用<code>dlerror()</code> (第1次调用<code>dlerror()</code>是为了清空已存储的错误字符串)。若第2次调用<code>dlerror()</code>不返回<code>NULL</code>，则表示<code>dlsym()</code>出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"></span><br><span class="line">ip = (<span class="type">int</span> *)dlsym(symbol, <span class="string">&quot;myvar&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ip != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value is %d\n&quot;</span>, *ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　若<code>symbol</code>是变量名，则可以为<code>dlsym()</code>的返回值分配合适类型的指针并通过解引用来获取该变量的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*funcp)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">*(<span class="type">void</span> **)(&amp;funcp) = dlsym(handle, symbol);</span><br><span class="line">res = (*funcp)(somearg);</span><br></pre></td></tr></table></figure><p>　　若<code>symbol</code>是函数名，则<code>dlsym()</code>返回的指针可用于调用该函数。但是，因为C99禁止在函数指针和<code>void *</code>之间赋值，所以需要进行类型转换，然后照常通过函数指针调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">void</span> *)funcp = dlsym(handle, symbol);</span><br></pre></td></tr></table></figure><p>　　这行代码看似更精简，但<code>gcc -pedantic</code>会警告 "ANSI C禁止将类型转换表达式作为左值"。<code>*(void **)</code>语法不会导致该警告，因为该语法是将值赋值给左值指向的地址。</p><p>　　对于很多UNIX实现，可以通过以下类型转换来避免C编译器的这种警告：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcp = (<span class="type">int</span> (*)(<span class="type">int</span>))dlsym(handle, symbol);</span><br></pre></td></tr></table></figure><p>　　但是，SUSv3 Technical Corrigendum Number 1的<code>dlsym()</code>规范指出，C99仍然要求编译器对这种类型转换生成警告，并建议使用<code>*(void **)</code>语法。</p><p>　　SUSv3 TC1指出，因为需要使用<code>*(void **)</code>语法，该标准的未来版本可能会定义用于处理数据指针和函数指针的类似于<code>dlsym()</code>的独立API。但是，SUSv4在这一点上没有进行任何修改。</p><p>　　除了库句柄之外，<code>dlsym()</code>的参数<code>handle</code>还可以被指定为伪句柄<code>RTLD_DEFAULT</code>或<code>RTLD_NEXT</code>。</p><p>　　● <code>RTLD_DEFAULT</code>表示先搜索主程序，然后按序遍历所有已加载的共享库，包括那些使用标志<code>RTLD_GLOBAL</code>动态加载的共享库。这对应动态链接器采用的默认搜索模型。</p><p>　　● <code>RTLD_NEXT</code>表示在调用<code>dlsym()</code>之后加载的共享库中搜索符号。这在创建与其他地方定义的函数同名的包装函数时很有用 (例如，在主程序中定义自己的<code>malloc()</code>，该函数会调用<code>func = dlsym(RTLD_NEXT, "malloc"</code>来获取真正的<code>malloc()</code>的地址并调用它)。</p><p>　　SUSv3不要求实现提供这2个伪句柄 (尽管SUSV3将其保留以供将来使用)，而且并非所有UNIX实现都提供了这2个伪句柄。为了从头文件<code>dlfcn.h</code>中获取这2个常量的定义，需要定义特性测试宏<code>_GNU_SOURCE</code>。</p><p>　　函数<code>dlvsym(handle, symbol, version)</code>类似于<code>dlsym()</code>，但可用于在具有符号版本的库中搜索符号定义，版本由<code>version</code>指定。当定义了特性测试宏<code>_GNU_SOURCE</code>，才能从头文件<code>dlfcn.h</code>中获取其声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* dynload.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *libHandle;     <span class="comment">/* 共享库句柄 */</span></span><br><span class="line">    <span class="type">void</span> (*funcp)(<span class="type">void</span>); <span class="comment">/* 指向无参数的函数的指针 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s lib-path func-name\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 加载共享库并获取其句柄 */</span></span><br><span class="line">    libHandle = dlopen(argv[<span class="number">1</span>], RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (libHandle == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;dlopen: %s&quot;</span>, dlerror());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在共享库中搜索argv[2] */</span></span><br><span class="line">    (<span class="type">void</span>)dlerror(); <span class="comment">/* 清除错误原因字符串 */</span></span><br><span class="line">    *(<span class="type">void</span> **)(&amp;funcp) = dlsym(libHandle, argv[<span class="number">2</span>]);</span><br><span class="line">    err = dlerror();</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;dlsym: %s&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若dlsym()返回的地址不为NULL，则尝试调用它 */</span></span><br><span class="line">    <span class="keyword">if</span> (funcp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is NULL\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        (*funcp)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dlclose(libHandle); <span class="comment">/* 关闭库 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了部分dlopen API的用法。该程序有2个命令行参数。第1个命令行参数是目标库的名称，第2个命令行参数是该库中的函数的名称。</p><h4 id="dlclose">42.2.4 <code>dlclose()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>dlclose()</code>会减少参数<code>handle</code>引用的库的系统级打开引用计数。若该引用计数减少至0，并且其他库不需要该库中的符号，则该库会被卸载。该过程会 (递归地) 对该库依赖树中的所有库执行。当进程终止时，会隐式对所有库都调用<code>dlclose()</code>。</p><p>　　从glibc 2.2.3开始，共享库的函数可以使用<code>atexit()</code> (<code>on_exit()</code>) 来注册卸载库时自动被调用的函数。</p><h4 id="dladdr">42.2.5 <code>dladdr()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dladdr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, Dl_info *info)</span>; <span class="comment">/* 在共享库中找到addr时返回非0值，否则返回0 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dli_fname; <span class="comment">/* 包含addr的共享库的路径名 */</span></span><br><span class="line">    <span class="type">void</span> *dli_fbase;       <span class="comment">/* 共享库加载的基地址 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dli_sname; <span class="comment">/* 地址不大于addr的最近运行时符号 */</span></span><br><span class="line">    <span class="type">void</span> *dli_saddr;       <span class="comment">/* dli_sname返回的符号的实际值 */</span></span><br><span class="line">&#125; Dl_info;</span><br></pre></td></tr></table></figure><p>　　函数<code>dladdr()</code>会通过参数<code>info</code>指向的结构体<code>Dl_info</code> (由调用者分配) 返回参数<code>addr</code>指定的地址的信息。结构体<code>Dl_info</code>的前2个成员分别是包含<code>addr</code>指定的地址的共享库的路径名和运行时基地址，后2个成员是该地址的相关信息。若该地址是共享库中某个符号的精确地址，则成员<code>dli_saddr</code>包含的值与<code>addr</code>指定的值相同。</p><p>　　SUSv3没有说明<code>dladdr()</code>，而且并非所有UNIX实现都提供了该函数。</p><h4 id="在主程序中访问符号">42.2.6 在主程序中访问符号</h4><p>　　假设使用<code>dlopen()</code>动态加载共享库后，使用<code>dlsym()</code>从该库获取函数<code>x()</code>的地址，然后调用该函数。若<code>x()</code>会调用函数<code>y()</code>，则<code>y()</code>通常会在程序加载的共享库中被找到。</p><p>　　有时，可能需要<code>x()</code>调用主程序中的<code>y()</code>实现。为此，必须使用链接器选项<code>––export–dynamic</code>来使主程序中的 (全局作用域) 符号可供动态链接器使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Wl,--export-dynamic main.c</span></span><br></pre></td></tr></table></figure><p>　　或者，使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -export-dynamic main.c</span></span><br></pre></td></tr></table></figure><p>　　这2条命令都会让动态加载库访问主程序中的全局符号。</p><p>　　此外，命令<code>gcc</code>的选项<code>-rdynamic</code>和<code>–Wl,–E</code>等同于<code>–Wl,––export–dynamic</code>。</p><h3 id="控制符号可见性">42.2 控制符号可见性</h3><p>　　设计良好的共享库应该仅公开那些构成其指定ABI一部分的符号 (函数和变量)。原因如下：</p><p>　　● 当共享库开发者意外地公开了未指定的接口时，使用该库的应用程序开发者可能会使用该接口。这会为共享库的后续升级带来兼容性问题。库开发者希望能够修改或删除文档中指定的ABI之外的所有接口，而库用户希望继续使用其目前使用的相同接口 (具有相同语义)。</p><p>　　● 在运行时符号解析期间，共享库公开的任何符号都可能影响其他共享库提供的定义。</p><p>　　● 公共不必要的符号会增加运行时加载的动态符号表的大小。</p><p>　　若库开发者能确保仅公开库指定ABI所需的符号，则所有这些问题都可以被最小化或完全避免。可以使用以下方法来控制符号的可见性：</p><p>　　● 对于C程序，可以使用关键字<code>static</code>来将符号设置为源代码模块私有，以防止它被其他目标文件绑定 (除了将符号设置为源代码模块私有之外，关键字<code>static</code>还会使该模块中所有对该符号的引用都绑定到该模块中该符号的定义)。</p><p>　　● 特定于gcc的属性声明可以提供与关键字<code>static</code>类似的作用 (属性<code>hidden</code>会使符号对构成共享库的所有源代码文件可见，但对库外的文件不可见)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__((visibility(<span class="string">&quot;hidden&quot;</span>))) func(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　● 版本脚本可用于精准控制符号可见性，并选择引用所绑定的符号版本。</p><p>　　● 当动态加载共享库时，可以通过<code>dlopen()</code>的标志<code>RTLD_GLOBAL</code>来指定库中定义的符号可供后续加载的库绑定，同时可以使用链接器选项<code>––export–dynamic</code>使主程序的全局符号对动态加载库可见。</p><h3 id="链接器版本脚本">42.3 链接器版本脚本</h3><p>　　<strong>版本脚本</strong>是包含链接器指令的文本文件。为了使用版本脚本，必须指定链接器选项<code>––version–script</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Wl,--version-script,myscriptfile.map ...</span></span><br></pre></td></tr></table></figure><p>　　版本脚本通常由扩展名<code>.map</code>标识。</p><h4 id="使用版本脚本控制符号可见性">42.3.1 使用版本脚本控制符号可见性</h4><p>　　版本脚本可用于控制符号可见性。假设需要使用源文件<code>vis_comm.c</code>、<code>vis_f1.c</code>和<code>vis_f2.c</code>构建共享库，这3个源文件分别定义了函数<code>vis_comm()</code>、<code>vis_f1()</code>和<code>vis_f2()</code>。函数<code>vis_comm()</code>由<code>vis_f1()</code>和<code>vis_f2()</code>调用，但并非旨在供链接到该库的应用程序直接使用。进一步假设构建该共享库的方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o</span></span><br></pre></td></tr></table></figure><p>　　当使用命令<code>readelf</code>来列出该共享库公开的动态符号时，会得到以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf --syms --use-dynamic vis.so | grep vis_</span></span><br><span class="line">    30 12: 00000790   59 FUNC    GLOBAL DEFAULT   10 vis_f1</span><br><span class="line">    25 13: 000007d0   73 FUNC    GLOBAL DEFAULT   10 vis_f2</span><br><span class="line">    27 16: 00000770   20 FUNC    GLOBAL DEFAULT   10 vis_comm</span><br></pre></td></tr></table></figure><p>　　该共享库公开了符号<code>vis_comm()</code>、<code>vis_f1()</code>和<code>vis_f2()</code>。为了让其仅公共<code>vis_f1()</code>和<code>vis_f2()</code>，可以使用以下版本脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> vis.map</span></span><br><span class="line">VER_1 &#123;</span><br><span class="line">    global:</span><br><span class="line">        vis_f1;</span><br><span class="line">        vis_f2;</span><br><span class="line">    local:</span><br><span class="line">        *; # 隐藏其他所有符号</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　版本脚本可以包含多个<span style="background-color:#ff0">版本节点</span>，所有版本节点都被大括号 (<code>{}</code>) 括起来，并以唯一的<span style="background-color:#ff0">版本标签</span>为前缀。若仅将版本脚本用于控制符号可见性，则版本标签是多余的。但是，较旧的链接器要求必须包含版本标签。现代链接器允许省略版本标签。在这种情况下，版本节点可视为具有匿名版本标签，并且版本脚本中不能包含其他版本节点。</p><p>　　在版本节点内，关键字<code>global</code>后的由分号<code>;</code>分隔的符号对外可见，关键字<code>local</code>后的由分号<code>;</code>分隔的符号对外不可见。星号<code>*</code>表示使用通配符模式。版本节点中的通配符与用于shell文件名匹配的通配符相同。此外，版本脚本的注释以<code>#</code>开头。这里的星号<code>*</code>表示除了显式声明为<code>global</code>的符号之外，其他所有符号都会被隐藏。若不使用这种说明，则<code>vis_comm()</code>将对外可见，因为C全局符号默认对共享库外部可见。</p><p>　　因此，可以使用以下脚本构建共享库<code>vis.so</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o -Wl,--version-script,vis.map</span></span><br></pre></td></tr></table></figure><p>　　当再次使用命令<code>readelf</code>时，符号<code>vis_comm()</code>不再对外可见：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf --syms --use-dynamic vis.so | grep vis_</span></span><br><span class="line">    25  0: 00000730   73 FUNC    GLOBAL DEFAULT   10 vis_f2</span><br><span class="line">    29 16: 000006f0   59 FUNC    GLOBAL DEFAULT   10 vis_f1</span><br></pre></td></tr></table></figure><h4 id="符号版本控制">42.3.2 符号版本控制</h4><p>　　符号版本控制允许共享库提供同一函数的多个版本。程序使用的是其与共享库静态链接时使用的函数版本。因此，可以在不增加库的主要版本号的情况下进行不兼容的修改。如果符号版本控制运用得当，可以取代传统的共享库的主要和次要版本控制方案。glibc 2.1及以上版本就采用了这种方式，使得从2.0开始的所有glibc版本都可以在单个主要版本 (<code>libc.so.6</code>) 中得到支持。</p><p>　　这里将使用简单的示例将展示符号版本控制的用法。首先，使用版本脚本创建共享库的第1个版本 (为了简化示例，这里没有使用库的soname和主要版本号)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sv_lib_v1.c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">void xyz(void) </span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;v1 xyz\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sv_v1.map</span></span><br><span class="line">VER_1 &#123;</span><br><span class="line">    global: xyz;</span><br><span class="line">    local: *;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall sv_lib_v1.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libsv.so sv_lib_v1.o -Wl,--version-script,sv_v1.maps</span></span><br></pre></td></tr></table></figure><p>　　此时，版本脚本<code>sv_v1.map</code>仅用于控制符号可见性。然后，创建使用该共享库的程序<code>p1</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sv_prog.c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdlib.h&gt;</span></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    void xyz(void);</span><br><span class="line"></span><br><span class="line">    xyz();</span><br><span class="line"></span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -o p1 sv_prog.c libsv.sos</span></span><br></pre></td></tr></table></figure><p>　　当运行该程序时，会得到以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./p1</span></span><br><span class="line">v1 xyz</span><br></pre></td></tr></table></figure><p>　　假设需要修改共享库中的<code>xyz()</code>定义，同时保持程序<code>p1</code>继续使用该函数的旧版本。为此，必须在共享库中定义<code>xyz()</code>的2个版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sv_lib_v2.c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">__asm__(&quot;.symver xyz_old,xyz@VER_1&quot;);</span><br><span class="line">__asm__(&quot;.symver xyz_new,xyz@@VER_2&quot;);</span><br><span class="line"></span><br><span class="line">void xyz_old(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;v1 xyz\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void xyz_new(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;v2 xyz\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pqr(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;v2 pqr\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>xyz()</code>的2个版本由函数<code>xyz_old()</code>和<code>xyz_new()</code>提供。前者对应<code>xyz()</code>的旧定义 (以供程序<code>p1</code>使用)，后者提供<code>xyz()</code>的新定义 (以供链接到该库新版本的程序使用)。</p><p>　　汇编指示<code>.symver</code>是将<code>xyz_old()</code>和<code>xyz_new()</code>与用于创建共享库新版本的修改后的版本脚本中的不同版本标签关联起来的纽带。第1个汇编指示表示<code>xyz_old()</code>是用于与版本标签<code>VER_1</code>链接的应用程序的<code>xyz()</code>定义，第2个汇编指示表示<code>xyz_new()</code>是用于与版本标签<code>VER_2</code>链接的应用程序的<code>xyz()</code>定义。此外，第2个汇编指示包含<code>@@</code>，表示该定义是静态链接到该库的应用程序默认使用的<code>xyz()</code>定义。每个符号都应该正好只有1个包含<code>@@</code>的汇编指示<code>.symver</code>。</p><p>　　修改后的共享库对应的版本脚本如下 (最后1行表示版本标签<code>VER_2</code>依赖于<code>VER_1</code>)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sv_v2.map</span></span><br><span class="line">VER_1 &#123;</span><br><span class="line">    global: xyz;</span><br><span class="line">    local: *;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VER_2 &#123;</span><br><span class="line">    global: pqr;</span><br><span class="line">&#125; VER_1; # VER_2依赖于VER_1</span><br></pre></td></tr></table></figure><p>　　版本标签依赖表示连续库版本之间的关系。从语义角度，Linux版本标签依赖关系唯一的影响是版本节点会从其所依赖的版本节点继承<code>global</code>和<code>local</code>规范。版本标签本身没有含义，它们之间的关系仅由指定的版本依赖关系决定。为了便于维护，建议使用<code>GLIBC_2.1</code>等包含包名和版本号的版本标签。此外，依赖关系可以形成依赖链 (例如，创建依赖于<code>VER_2</code>的版本节点<code>VER_3</code>)。</p><p>　　版本标签<code>VER_2</code>也公开了新函数<code>pqr()</code>，并且该函数是绑定该标签的。若不以这种方式声明<code>pqr()</code>，则继承自版本标签<code>VER_1</code>的<code>local</code>规范会使该函数对外不可见。</p><p>　　共享库新版本的构建可以照常执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall sv_lib_v2.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libsv.so sv_lib_v2.o -Wl,--version-script,sv_v2.map</span></span><br></pre></td></tr></table></figure><p>　　然后，创建使用<code>xyz()</code>新定义的程序<code>p2</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -o p2 sv_prog.c libsv.so</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./p2</span></span><br><span class="line">v2 xyz</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./p1</span></span><br><span class="line">v1 xyz</span><br></pre></td></tr></table></figure><p>　　可执行文件的版本标签依赖在静态链接时被记录。可以使用命令<code>objdump –t</code>来显示可执行文件的符号表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -t p1 | grep xyz</span></span><br><span class="line">08048380       F *UND*  0000002e              xyz@@VER_1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -t p2 | grep xyz</span></span><br><span class="line">080483a0       F *UND*  0000002e              xyz@@VER_2</span><br></pre></td></tr></table></figure><p>　　命令<code>readelf –s</code>可用于获取类似的信息。</p><h3 id="初始化和终止函数">42.4 初始化和终止函数</h3><p>　　定义共享库加载和卸载时自动被调用的函数是可能的。这使得开发者能够在在使用共享库时执行初始化和终止操作。无论是自动加载还是使用dlopen API显式加载，初始化和终止函数都会自动被调用。</p><p>　　实现初始化和终止函数的方法之一是将函数<code>_init()</code>和<code>_fini()</code>作为库的一部分。函数<code>void _init(void)</code>包含共享库第1次被加载时执行的代码。函数<code>void _fini(void)</code>包含共享库被卸载时执行的代码。</p><p>　　若需要创建函数<code>_init()</code>和<code>_fini()</code>，则必须在通过命令<code>gcc</code>构建共享库时指定选项<code>-nostartfiles</code>，以防止链接器包含这些函数的默认版本 (可以通过链接器选项<code>–Wl,–init</code>和<code>–Wl,–fini</code>为这2个函数选择别名)。</p><p>　　函数<code>_init()</code>和<code>_fini()</code>现已过时，取而代之的是gcc属性<code>constructor</code>和<code>destructor</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((constructor)) some_name_load(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__ ((destructor)) some_name_unload(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 终止代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这2个gcc属性的优势之一是允许定义多个初始化和终止函数。此外，可以主程序中使用这2个属性来创建初始化和终止函数。</p><h3 id="监控动态加载器">42.5 监控动态加载器</h3><p>　　有时，监控动态加载器的操作可能很有用 (例如，了解它正在搜索的库的位置)。环境变量<code>LD_DEBUG</code>可用于实现这一点。可以通过将该环境变量设置为合适的值来从动态链接器获取各种类型的跟踪信息。</p><p>　　若将环境变量<code>LD_DEBUG</code>设置为<code>help</code>，则动态链接器会显示与该环境变量相关的帮助信息，并且指定的命令不会被执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_DEBUG=<span class="built_in">help</span> <span class="built_in">date</span></span></span><br><span class="line">Valid options for the LD_DEBUG environment variable are:</span><br><span class="line"></span><br><span class="line">  libs        display library search paths</span><br><span class="line">  reloc       display relocation processing</span><br><span class="line">  files       display progress for input file</span><br><span class="line">  symbols     display symbol table processing</span><br><span class="line">  bindings    display information about symbol binding</span><br><span class="line">  versions    display version dependencies</span><br><span class="line">  scopes      display scope information</span><br><span class="line">  all         all previous options combined</span><br><span class="line">  statistics  display relocation statistics</span><br><span class="line">  unused      determined unused DSOs</span><br><span class="line">  help        display this help message and exit</span><br><span class="line"></span><br><span class="line">To direct the debugging output into a file instead of standard output</span><br><span class="line">a filename can be specified using the LD_DEBUG_OUTPUT environment variable.</span><br></pre></td></tr></table></figure><p>　　以下示例展示了请求跟踪库搜索相关信息时提供的输出的简化版 (每行开头的值10687是正在被跟踪的进程的进程ID)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_DEBUG=libs <span class="built_in">date</span></span></span><br><span class="line">     10687:     find library=librt.so.1 [0]; searching</span><br><span class="line">     10687:      search cache=/etc/ld.so.cache</span><br><span class="line">     10687:       trying file=/lib/librt.so.1</span><br><span class="line">     10687:     find library=libc.so.6 [0]; searching</span><br><span class="line">     10687:      search cache=/etc/ld.so.cache</span><br><span class="line">     10687:       trying file=/lib/libc.so.6</span><br><span class="line">     10687:     find library=libpthread.so.0 [0]; searching</span><br><span class="line">     10687:      search cache=/etc/ld.so.cache</span><br><span class="line">     10687:       trying file=/lib/libpthread.so.0</span><br><span class="line">     10687:     calling init: /lib/libpthread.so.0</span><br><span class="line">     10687:     calling init: /lib/libc.so.6</span><br><span class="line">     10687:     calling init: /lib/librt.so.1</span><br><span class="line">     10687:     initialize program: date</span><br><span class="line">     10687:     transferring control: date</span><br><span class="line">Tue Dec 17:26:56 CEST 2010</span><br><span class="line">     10687:     calling fini: date [0]</span><br><span class="line">     10687:     calling fini: /lib/librt.so.1 [0]</span><br><span class="line">     10687:     calling fini: /lib/libpthread.so.0 [0]</span><br><span class="line">     10687:     calling fini: /lib/libc.so.6 [0]</span><br></pre></td></tr></table></figure><p>　　在默认情况下，环境变量<code>LD_DEBUG</code>的输出会被写入到标准错误，但可以将环境变量<code>LD_DEBUG_OUTPUT</code>设置为路径名将其重定向。</p><p>　　若有需要，可以环境变量<code>LD_DEBUG</code>设置为由逗号<code>,</code>分隔的多个选项 (不应包含空格)。</p><p>　　环境变量<code>LD_DEBUG</code>对由动态链接器隐式加载的库以及通过<code>dlopen()</code>动态加载的库都有效。出于安全原因，该环境变量会被set-user-ID和set-group-ID程序忽略 (glibc 2.5.5及以上版本)。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第41章 共享库基础"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第41章 共享库基础</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_43/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第43章 进程间通信简介">《Linux/UNIX系统编程手册》第43章 进程间通信简介 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>