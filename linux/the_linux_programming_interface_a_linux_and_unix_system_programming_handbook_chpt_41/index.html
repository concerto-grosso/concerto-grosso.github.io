<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/","title":"《Linux/UNIX系统编程手册》第41章 共享库基础"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第41章 共享库基础 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-text">41.1 创建和使用静态库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-text">41.2 创建和使用共享库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="nav-text">41.2.1 位置无关代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93soname"><span class="nav-text">41.2.2 共享库soname</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="nav-text">41.3 与共享库相关的实用工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93%E7%89%88%E6%9C%AC%E5%92%8C%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="nav-text">41.4 共享库版本和命名约定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-text">41.5 安装共享库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-text">41.6 更新共享库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%90%9C%E7%B4%A2%E7%9B%AE%E5%BD%95"><span class="nav-text">41.7 在目标文件中指定搜索目录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%9E%84%E5%BB%BA%E5%85%B1%E4%BA%AB%E5%BA%93%E6%97%B6%E4%BD%BF%E7%94%A8%E9%93%BE%E6%8E%A5%E5%99%A8%E9%80%89%E9%A1%B9-rpath"><span class="nav-text">41.7.1 在构建共享库时使用链接器选项-rpath</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#elf%E7%9A%84%E6%A0%87%E7%AD%BEdt_rpath%E5%92%8Cdt_runpath"><span class="nav-text">41.7.2 ELF的标签DT_RPATH和DT_RUNPATH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8rpath%E4%B8%AD%E4%BD%BF%E7%94%A8origin"><span class="nav-text">41.7.3 在rpath中使用$ORIGIN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%90%9C%E7%B4%A2%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-text">41.8 在运行时搜索共享库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90"><span class="nav-text">41.9 运行时符号解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-text">41.10 使用静态库的场景</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第41章 共享库基础 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第41章 共享库基础</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2026-01-05 00:00:00" itemprop="dateCreated datePublished" datetime="2026-01-05T00:00:00+08:00">2026-01-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2026-01-07 00:00:00" itemprop="dateModified" datetime="2026-01-07T00:00:00+08:00">2026-01-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>17k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　构建程序的方式之一是编译所有源文件来产生对应的目标文件，并将这些目标文件链接在一起来生成可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -c prog.c mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -o prog_nolib prog.o mod1.o mod2.o mod3.o</span></span><br></pre></td></tr></table></figure><p>　　这里的编译命令使用了选项<code>-g</code>来将调试信息存储在编译后的程序中。实际上，应该尽量创建允许调试的程序和库。此外，对于x86-32架构，不应该指定选项<code>–fomit–frame–pointer</code>，因为该选项会禁用调试 (在x86-64等架构，该选项默认启用，因为它不再禁用调试)。出于同样的原因，不应该使用<code>strip</code>等工具删除可执行文件和库的调试信息。</p><p>　　在很多情况下，多个程序会使用同一源文件。作为节省工作量的第1步，可以先将这些源文件编译1次，然后按需将它们链接成不同的可执行文件。尽管这种方式节省了编译时间，但还是存在必须在链接阶段命名所有目标文件的缺点。此外，目录可能充斥着大量目标文件。</p><p>　　为了解决这些问题，可以将目标文件组合成称为<strong>目标库</strong>的单元。目标库分为2种类型：<strong>静态库</strong> (也称为<strong>归档文件</strong>) 和<strong>共享库</strong>。</p><span id="more"></span><p>　　静态库是UNIX系统提供的第1种库。静态库存在以下优点：</p><p>　　● 可以将若干个常用的目标文件放入单个库文件，然后使用该库文件构建多个可执行文件 (而无需在构建每个可执行文件时重新编译源文件)。</p><p>　　● 简化编译命令。在链接命令中可以直接指定静态库的名称，而非指定多个目标文件。链接器知道如何搜索静态库并提取可执行文件所需的目标。</p><p>　　若程序以链接静态库的形式构建，则生成的可执行文件会包含链接到程序中的所有目标文件的副本。当多个不同的程序使用同一模块时，所有可执行文件都会拥有目标模块的副本。这种代码冗余会导致以下问题：</p><p>　　● 存储多个相同的模块会浪费磁盘空间。</p><p>　　● 当多个使用同一模块的程序同时运行时，所有程序都会在虚拟内存中存储目标的独立副本，从而增加对虚拟内存的整体需求。</p><p>　　● 当修改静态库中的某个模块后，所有使用该模块的静态库都必须重新链接以同步修改。系统管理员需要知道哪些应用程序链接了该库，这进一步加剧了这一问题。</p><p>　　共享库旨在解决这些问题。共享库的核心思想是所有使用同一模块的程序共享该模块的 (单份) 副本。目标模块不会被复制到可执行文件。相反，当第1个使用目标模块的程序启动时，包含该目标模块的库的副本会在运行时被加载到内存。随后，当其他使用该模块的程序启动时，它们会使用已加载到内存中库的副本。共享库的使用可以减少程序所需的磁盘空间和虚拟内存。此外，共享库还具有以下优点：</p><p>　　● 由于程序整体体积更小，在某些情况下，程序可以更快地被加载到内存和启动。这一点仅适用于已被其他程序使用的大型共享库 (第1个使用共享库的程序的启动时间相对较长，因为需要找到共享库并将其加载到内存)。</p><p>　　● 目标模块不会被复制到可执行文件，而是集中存储在共享库中，所以修改目标模块后无需重新链接程序。即使正在运行的程序正在使用共享库，也可以进行修改。</p><p>　　相比静态库，共享库存在以下缺点：　　</p><p>　　● 共享库比静态库更复杂，无论是从概念角度，还是从创建共享库和构建使用它们的程序的实际操作角度。</p><p>　　● 共享库必须被编译为位置无关代码，这在大多数架构上会带来性能开销，因为它需要使用额外的寄存器。</p><p>　　● 必须在运行时执行符号重定位。当执行符号重定位时，需要修改对共享库中的所有符号的引用，以对应符号在虚拟内存中实际运行时的位置。因此，使用共享库的程序的执行时间比链接对应静态库的程序的执行时间更长。</p><p>　　链接实际上是由链接器程序<code>ld</code>执行。当通过命令<code>cc</code> (或<code>gcc</code>) 链接程序时，编译器会在后台调用链接器。对于Linux，链接器应该总是通过<code>gcc</code>间接调用，因为<code>gcc</code>会确保<code>ld</code>被调用时带有正确的选项，并将程序与正确的库文件链接。</p><p>　　通常，术语<span style="background-color:#ff0">链接</span>用于描述使用链接器 (<code>ld</code>) 将若干个已编译的目标文件组合为可执行文件的过程。有时，术语<span style="background-color:#ff0">静态链接</span>用于将该步骤与<span style="background-color:#ff0">动态链接</span>区分，动态链接是在运行加载可执行文件使用的共享库 (静态链接也称为<span style="background-color:#ff0">链接编辑</span>，而<code>ld</code>等静态链接器有时也称为<span style="background-color:#ff0">链接编辑器</span>)。所有程序都需要经历静态链接阶段，而使用动态库的程序在运行时还会进行动态链接。</p><p>　　<strong>可执行与可链接格式</strong> (ELF) 是现代Linux和很多UNIX实现用于可执行文件和共享库的格式。该格式了取代了较旧的<code>a.out</code>和<span style="background-color:#ff0">通用目标文件格式</span> (COFF)。</p><p>　　尽管多个进程会共享共享库的代码，但不会共享共享库中的变量。对于共享库中定义的全局和静态变量，所有使用该库的进程都会拥有自己的副本。</p><p>　　共享库可以在<span style="background-color:#ff0">Java本地接口</span> (JNI) 中作为构建模块。 JNI允许Java代码通过调用共享库中的C函数直接访问底层操作系统的特性。</p><h3 id="创建和使用静态库">41.1 创建和使用静态库</h3><p>　　静态库包含所有添加到其中的目标文件的副本，并且会记录所有组件目标文件的各种属性，包括文件权限、用户和组ID以及最后修改时间。按照惯例，静态库的名称格式为<code>libname.a</code>。</p><p>　　静态库可以通过命令<code>ar</code>创建和维护。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar options archive object-file...</span></span><br></pre></td></tr></table></figure><p>　　参数<code>options</code>由若干个字母组成，其中1个字母是操作代码，其余字母是影响操作执行方式的修饰符。部分常用操作码如下：</p><p>　　● <code>r</code> (replace)：添加指定目标文件到静态库，若存在同名目标文件，则进行替换。这是创建和更新静态库的标准方式。因此，可以通过以下命令构建静态库 (当构建静态库后，可以删除原始目标，因为不再需要它们)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -c mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar r libdemo.a mod1.o mod2.o mod3.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> mod1.o mod2.o mod3.o</span></span><br></pre></td></tr></table></figure><p>　　● <code>t</code> (table of contents)：列出静态库的目录列表。在默认情况下，该列表只会列出目标文件的名称。可以通过添加修饰符<code>v</code> (verbose) 来查看目标文件的其他属性 (从左到右依次是目标文件的权限、用户ID、组ID、大小以及最后修改时间)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar tv libdemo.a</span> </span><br><span class="line">rw-r--r-- 1000/100 1001016 Nov 15 12:26 2009 mod1.o</span><br><span class="line">rw-r--r-- 1000/100  406668 Nov 15 12:21 2009 mod2.o</span><br><span class="line">rw-r--r-- 1000/100   46672 Nov 15 12:21 2009 mod3.o</span><br></pre></td></tr></table></figure><p>　　● <code>d</code> (delete)：从静态库中删除指定目标文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ar d libdemo.a mod3.o</span></span><br></pre></td></tr></table></figure><p>　　程序链接静态库的方式有2种。第1种方式是将静态库作为链接命令的一部分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -c prog.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -o prog prog.o libdemo.a</span></span><br></pre></td></tr></table></figure><p>　　第2种方式是将库放置在链接器搜索的标准目录下，然后使用选项<code>-l</code>指定库名 (即不带有前缀<code>lib</code>和后缀<code>.a</code>的库文件名)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g -o prog prog.o -ldemo</span></span><br></pre></td></tr></table></figure><p>　　尽管静态库可能包含多个目标模块，但链接器只会使用程序所需的模块。</p><p>　　当链接程序后，可以照常运行它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./prog</span></span><br><span class="line">Called mod1-x1</span><br><span class="line">Called mod2-x2</span><br></pre></td></tr></table></figure><h3 id="创建和使用共享库">41.2 创建和使用共享库</h3><p>　　为了创建41.1中的静态库对应的共享库，需要执行以下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libfoo.so mod1.o mod2.o mod3.o</span></span><br></pre></td></tr></table></figure><p>　　第1条命令会创建待放入库中的3个目标模块。第2条命令会创建包含这3个目标模块的共享库。按照惯例，共享库通常带有前缀<code>lib</code>和后缀<code>.so</code> (表示共享对象)。这里使用的命令是<code>gcc</code>，因为共享库的创建方式取决于编译器 (其他C编译器可能会使用不同的选项)。</p><p>　　此外，可以通过单行命令来编译源文件并创建共享库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -fPIC -Wall mod1.c mod2.c mod3.c -shared -o libfoo.so</span></span><br></pre></td></tr></table></figure><p>　　但是，为了清除地区分编译和库构建步骤，之后的内容还是会将这2个步骤写出单独的命令。</p><p>　　不同于静态库，无法向共享库中添加或删除目标模块。共享库中的目标文件并非各自独立。</p><p>　　为了使用共享库，需要执行2个链接静态库的程序不需要的步骤：</p><p>　　● 因为可执行文件不包含所需的目标文件的副本，所以它需要某种机制来表示运行时所需的共享库。这是通过在链接阶段将共享库名嵌入到可执行文件实现的。程序的所有共享库依赖称为其<strong>动态依赖列表</strong> (共享库依赖被记录在ELF的标签<code>DT_NEEDED</code>中)。</p><p>　　● 在运行时，需要某种机制来解析嵌入的库名——搜索可执行文件中的库名对应的共享库，并将其加载到内存。</p><p>　　当将程序与共享库链接时，会自动将库名嵌入到可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -o prog prog.c libfoo.so</span></span><br></pre></td></tr></table></figure><p>　　当执行该程序时，可能会出现以下错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./prog</span></span><br><span class="line">./prog: error in loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>　　这就引出了第2个必要步骤：<strong>动态链接</strong>，即在运行时解析嵌入的库名。该任务由<strong>动态链接器</strong> (也称为<strong>动态链接加载器</strong>或<strong>运行时链接器</strong>) 执行。动态链接器实际上是共享库<code>/lib/ld-linux.so.2</code>，所有ELF可执行文件都会使用该共享库。</p><p>　　路径名<code>/lib/ld-linux.so.2</code>通常是指向动态链接器可执行文件的符号链接。该文件名为<code>ld-version.so</code>，其中<code>version</code>是glibc版本 (例如，<code>ld-2.11.so</code>)。动态链接器的路径名在某些架构上有所不同 (例如，IA-64架构的动态链接器的符号链接名为<code>/lib/ld-linux-ia64.so.2</code>)。</p><p>　　动态链接器会检查程序所需的共享库列表，并通过若干个预定义的规则来搜索库文件，其中的某些规则指定了共享库通常所在的标准目录 (运行程序<code>prog</code>出现的错误信息是因为共享库位于这些标准目录之外)。</p><p>　　某些架构 (例如，zSeries、PowerPC64和x86-64) 支持执行32位和64位程序。对于这些系统，32位库位于子目录<code>*/lib</code>，64位库位于子目录<code>*/lib64</code>。</p><p>　　可以将目录指定为环境变量<code>LD_LIBRARY_PATH</code>中以冒号<code>:</code>分隔的目录列表的一部分来将通知动态链接器共享库所在的非标准目录 (分号<code>;</code>也可以用于分隔目录，在这种情况下，必须将列表加引号来防止shell解释分号)。若定义了该环境变量，则动态链接器会在搜索标准库目录之前先搜索该环境变量定义的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">Called mod1-x1</span><br><span class="line">Called mod2-x2</span><br></pre></td></tr></table></figure><p>　　这条命令会为执行<code>prog</code>的进程定义环境变量<code>LD_LIBRARY_PATH</code>。该定义会告诉动态链接器在<code>.</code> (当前工作目录) 搜索共享库。</p><p>　　环境变量<code>LD_LIBRARY_PATH</code>中定义的空目录 (例如，<code>dirx::diry</code>) 等同于<code>.</code> (将该环境变量设置为空字符串不能达到同样的效果)。SUSv3不鼓励在路径环境变量中以这种方式指定路径名，所以应该避免这样做。</p><h4 id="位置无关代码">41.2.1 位置无关代码</h4><p>　　命令<code>gcc</code>的编译选项<code>-fPIC</code>指定编译器应该生成<strong>位置无关代码</strong>。这会修改编译器为访问全局变量、访问静态变量、访问外部变量、访问字符串常量和获取函数地址等操作生成代码的方式。这些修改允许代码在运行时位于任意虚拟地址。这是共享库所必需的，因为链接时无法得知共享库代码在内存中的位置，而共享库的运行时内存位置取决于多种因素 (例如，加载共享库的程序已占用的内存空间以及该程序已加载了那些其他共享库)。</p><p>　　对于Linux/x86-32，可以用不带有选项<code>-fPIC</code>编译的目标模块创建共享库 (对于某些架构，若没有该选项，则无法构建共享库)。但是，这样做会失去共享库的部分优势，因为包含位置无关内存引用的程序文本页不会在进程之间共享。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nm mod1.o | grep _GLOBAL_OFFSET_TABLE_</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -s mod1.o | grep _GLOBAL_OFFSET_TABLE_</span></span><br></pre></td></tr></table></figure><p>　　这2条命令都可以用于确定现有目标文件在编译时是否带有选项<code>-fPIC</code> (检查目标文件的符号表中是否存在名称<code>_GLOBAL_OFFSET_TABLE_</code>)。若这2条命令都没有输出，则表示共享库中存在至少1个目标模块在编译时未带有选项<code>-fPIC</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump --all-headers libfoo.so | grep TEXTREL</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -d libfoo.so | grep TEXTREL</span></span><br></pre></td></tr></table></figure><p>　　字符串<code>TEXTREL</code>表示文本段包含需要运行时重定位的引用的目标模块。</p><h4 id="共享库soname">41.2.2 共享库soname</h4><p>　　嵌入到可执行文件并在运行时由动态链接器搜索的名称是共享库的<span style="background-color:#ff0">实际名</span>，但通常的做法是为共享库创建别名，该别名称为<strong>soname</strong> (ELF的标签<code>DT_SONAME</code>)。</p><p>　　当共享库有soname时，在静态链接期间，soname会被嵌入到可执行文件 (而非实际名)，随后动态链接器在运行时也是搜索soname。soname的目的是提供间接层，使可执行文件在运行时可以使用与其链接时不同 (但兼容) 的共享库版本。</p><p>　　使用soname的第1步是在创建共享库指定它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -Wl,-soname,libbar.so -o libfoo.so mod1.o mod2.o mod3.o</span></span><br></pre></td></tr></table></figure><p>　　选项<code>-Wl,-soname,libbar.so</code>指示链接器将共享库<code>libfoo.so</code>标记为soname <code>libbar.so</code>。</p><p>　　当需要获取现有共享库的soname时，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -p libfoo.so | grep SONAME</span></span><br><span class="line">  SONAME                libbar.so</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -d libfoo.so | grep SONAME</span></span><br><span class="line"> 0x0000000e (SONAME)        Library soname: [libbar.so]</span><br></pre></td></tr></table></figure><p>　　当创建带有soname的共享库后，可以照常创建可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -o prog prog.c libfoo.so</span></span><br></pre></td></tr></table></figure><p>　　此时，链接器检查到库<code>libfoo.so</code>包含soname <code>libbar.so</code>并将后者嵌入到可执行文件。</p><p>　　当运行程序<code>prog</code>时，会得到以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">./prog: error in loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>　　这是因为动态链接器无法找到共享库<code>libbar.so</code>。当使用soname时，需要创建从soname到库的实际名的符号链接。该符号链接必须被创建在动态链接器搜索的目录之一。因此，可以通过以下方式运行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s libfoo.so libbar.so</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">Called mod1-x1</span><br><span class="line">Called mod2-x2</span><br></pre></td></tr></table></figure><p>　　下图展示了涉及创建带有嵌入的soname的共享库、将程序链接到该库并创建运行程序所需的soname符号链接的编译和链接步骤：</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/creating_a_shared_library_and_linking_a_program_against_it.svg"><p>　　下图展示了程序<code>prog</code>在准备执行时加载共享库的步骤：</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/execution_of_a_program_that_loads_a_shared_library.svg"><p>　　特定于Linux的文件<code>/proc/PID/maps</code>可用于获取进程当前正在使用的共享库。</p><h3 id="与共享库相关的实用工具">41.3 与共享库相关的实用工具</h3><p>　　命令<code>ldd</code> (list dynamic dependencies) 会显示程序 (或共享库) 运行所需的共享库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd prog</span></span><br><span class="line">        libtlpi.so.1 =&gt; /usr/lib/libdemo.so.1 (0x40019000)</span><br><span class="line">        libc.so.6 =&gt; /usr/tls/libc.so.6 (0x4017b000)</span><br><span class="line">        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</span><br></pre></td></tr></table></figure><p>　　命令<code>ldd</code>会解析每个库引用 (使用与动态链接器相同的搜索约定) 并通过以下形式显示结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library-name =&gt; resolves-to-path</span><br></pre></td></tr></table></figure><p>　　对于大多数ELF可执行文件，命令<code>ldd</code>列出的条目至少会包含<code>ld-linux.so.2</code> (动态链接器) 和<code>libc.so.6</code> (标准C库)。对于某些架构，C库的名称有所不同 (例如，对于IA-64和Alpha，标准C库的名称为<code>libc.so.6.1</code>)。</p><p>　　命令<code>objdump</code>可用于从可执行文件、编译目标以及共享库获取各种信息 (包括反汇编二进制机器代码)。该命令也能用于显示这些文件各个ELF段的首部信息，在这种情况下，该命令类似于<code>readelf</code>，后者显示类似的信息，但格式不同。</p><p>　　命令<code>nm</code>会列出在目标库或可执行文件中定义的符号集。该命令的用法之一是找出哪些库定义了指定符号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nm -A /usr/lib/lib*.so 2&gt; /dev/null | grep <span class="string">&#x27; crypt$&#x27;</span></span></span><br><span class="line">/usr/lib/libcrypt.so:00007080 W crypt</span><br></pre></td></tr></table></figure><p>　　命令<code>nm</code>的选项<code>-A</code>指定在显示符号的每行开头显示库名。这是必要的，因为该命令默认只会显示1次库名，然后在后续的行中显示它包含的所有符号，这对于这里所示的过滤方法没有用。此外，这里还丢弃了标准错误输出来隐藏该命令无法识别的文件格式的错误信息。根据结果可知，函数<code>crypt()</code>被定义在库<code>libcrypt</code>中。</p><h3 id="共享库版本和命名约定">41.4 共享库版本和命名约定</h3><p>　　连续版本的共享库通常兼容，这表示这些模块的函数呈现相同的调用接口，并且在语义上是等效的。这种不同但兼容的版本称为共享库的<span style="background-color:#ff0">次要版本</span>。有时，需要创建库的新的<span style="background-color:#ff0">主要版本</span>，即与上一个版本不兼容的版本。与此同时，必须仍然能够继续运行需要旧版本的程序。</p><p>　　为了满足这个版本控制需求，共享库的实际名和soname采用标准命名约定。</p><p>　　共享库的不兼容的版本由唯一的<span style="background-color:#ff0">主要版本标识符</span>区分，该标识符会作为其实际名的一部分。按照惯例，主要版本标识符采用数字形式，随着库的不兼容版本而顺序递增。除了主要版本标识符之外，实际名还包含<span style="background-color:#ff0">次要版本标识符</span>，用于区分主要版本内兼容的次要版本。实际名采用的格式约定为<code>libname.so.major-id.minor-id</code>。</p><p>　　与主要版本标识符类似，次要版本标识符可以为任何字符串。但是，按照惯例，该标识符要么是1个数字，要么是2个由<code>.</code>分隔的数字，第1个数字表示次要版本，第2个数字表示次要版本的补丁级别或修订号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libdemo.so.1.0.1</span><br><span class="line">libdemo.so.1.0.2</span><br><span class="line">libdemo.so.2.0.0</span><br><span class="line">libreadline.so.5.0</span><br></pre></td></tr></table></figure><p>　　soname仅包含对应实际名的主要版本标识符，所以其格式为<code>libname.so.major-id</code>。通常，soname是实际名所在的目录下的相对符号链接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libdemo.so.1        -&gt; libdemo.so.1.0.2</span><br><span class="line">libdemo.so.2        -&gt; libdemo.so.2.0.0</span><br><span class="line">libreadline.so.5    -&gt; libreadline.so.5.0</span><br></pre></td></tr></table></figure><p>　　对于共享库的特定主要版本，可能会存在多个次要版本的库文件。soanme通常指向对应主要版本的最新次要版本。这种设置允许共享库在运行时操作期间实现正确的版本控制语义。因为静态链接阶段会将soname的副本嵌入到可执行文件，并且soname符号链接后续可以被修改为指向较新的次要版本，所以可以确保可执行文件在运行时加载库的最新次要版本。此外，不同主要版本有不同的soname，所以它们可以共存，并且程序可以按需访问它们。</p><p>　　除了实际名和soname之外，将可执行文件与共享库链接时通常还会使用<span style="background-color:#ff0">链接器名</span>来定义共享库。链接器名是仅包含库名 (不包含版本标识符) 的符号链接，所以其格式为<code>libname.so</code>。链接器名可用于构建与版本无关的链接命令，这些命令会自动使用正确的 (即最新的) 共享库版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libdemo.so      -&gt; libdemo.so.2</span><br><span class="line">libreadline.so  -&gt; libreadline.so.5</span><br></pre></td></tr></table></figure><p>　　链接器名通常会与其引用的文件位于同一目录。它可以链接到库的实际名或最新的主要版本的soname。链接器名通常应该链接到soname，因为这样可以让链接器名反映对soname的修改。</p><p>　　若需要将程序链接到共享库的较旧的主要版本，则不能使用链接器名。相反，应该在编译命令中指定所需版本的实际名或soname。</p><table><colgroup><col style="width:9%"><col style="width:22%"><col style="width:68%"></colgroup><thead><tr><th>名称</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>实际名</td><td><code>libname.so.maj.min</code></td><td>存储库代码的文件；所有版本都只有1个实例</td></tr><tr><td>soname</td><td><code>libname.so.maj</code></td><td>共享库的每个主要版本1个实例；链接时会被嵌入到可执行文件；在运行时用于通过指向对应 (最新) 实际名的同名符号链接来搜索库</td></tr><tr><td>链接器名</td><td><code>libname.so</code></td><td>指向最新实际名或最新soname的符号链接；单个实例；允许构建独立于版本的编译命令</td></tr></tbody></table><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/various_shared_library_names.svg"><p>　　综合以上信息，可以通过以下步骤来按照标准规范构建示例共享库：</p><p>　　1) 创建目标文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br></pre></td></tr></table></figure><p>　　2) 创建实际名为<code>libdemo.so.1.0.1</code>的共享库，并创建对应的soname <code>libdemo.so.1</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.1 mod1.o mod2.o mod3.o</span></span><br></pre></td></tr></table></figure><p>　　3) 为soname和链接器名创建合适的符号链接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s libdemo.so.1.0.1 libdemo.so.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s libdemo.so.1 libdemo.so</span></span><br></pre></td></tr></table></figure><p>　　当共享库创建完成后，可以通过命令<code>ls</code>进行验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l libdemo.so* | awk <span class="string">&#x27;&#123;print $1, $9, $10, $11&#125;&#x27;</span></span></span><br><span class="line">lrwxrwxrwx libdemo.so -&gt; libdemo.so.1</span><br><span class="line">lrwxrwxrwx libdemo.so.1 -&gt; libdemo.so.1.0.1</span><br><span class="line">-rwxr-xr-x libdemo.so.1.0.1</span><br></pre></td></tr></table></figure><p>　　构建可执行文件时可以使用链接器名，然后照常运行可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -o prog prog.c -L. -ldemo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">Called mod1-x1</span><br><span class="line">Called mod2-x2</span><br></pre></td></tr></table></figure><h3 id="安装共享库">41.5 安装共享库</h3><p>　　在之前的示例中，共享库被创建在用户私有目录下，然后通过环境变量<code>LD_LIBRARY_PATH</code>来确保动态链接器会搜索该目录。特权用户和非特权用户都可以使用该技术。但是，生产应用程序中不应该使用该技术。更常见的做法是将共享库以及相关的符号链接安装到某个标准库目录下，特别是以下目录之一 (在大多数情况下，将文件复制到这些目录需要超级用户特权)：</p><p>　　● <code>/usr/lib</code>：大部分标准库的安装目录。</p><p>　　● <code>/lib</code>：系统启动时所需的库的安装目录 (因为系统启动时<code>/usr/lib</code>可能还未挂载)。</p><p>　　● <code>/usr/local/lib</code>：非标准或实验库的安装目录 (当<code>/usr/lib</code>是在多个系统之间共享的网络挂载点时，若需要安装仅供当前系统使用的库，则可以将该库安装到<code>/usr/local/lib</code>)。</p><p>　　● <code>/etc/ld.so.conf</code>中列出的目录。</p><p>　　当安装完成后，必须创建soname和链接器名的符号链接，通常是在库文件所在的目录下创建相对符号链接。因此，需要通过以下方式在<code>/usr/lib</code>下安装示例库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> libdemo.so.1.0.1 /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s libdemo.so.1.0.1 libdemo.so.1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s libdemo.so.1 libdemo.so</span></span><br></pre></td></tr></table></figure><p>　　程序<code>ldconfig</code>可以解决共享库的2个潜在问题：</p><p>　　● 共享库可以位于各种目录。因此，当动态链接器需要搜索这些目录才能找到共享库时，加载共享库的速度可能很慢。</p><p>　　● 随着共享库新版本的安装或旧版本的删除，soname符号链接可能过期。</p><p>　　程序<code>ldconfig</code>会通过执行2个步骤来解决这些问题：</p><p>　　1) 该程序会搜索标准目录并创建或更新缓存文件<code>/etc/ld.so.cache</code>，以保证该缓存文件包含由标准目录下的所有库的所有主要版本的最新次要版本组成的列表 (命令<code>ldconfig –p</code>会显示该缓存文件的内容)。动态链接器在运行时解析库名时会使用该缓存文件。为了构建缓存，该程序会先搜索文件<code>/etc/ld.so.conf</code>指定的目录，然后搜索目录<code>/lib</code>和<code>/usr/lib</code>。文件<code>/etc/ld.so.conf</code>包含若干个由换行符、空格、制表符、逗号或冒号分隔的目录绝对路径名。对于某些发行版，该文件会包含目录<code>/usr/local/lib</code> (若不包含，则需要手动添加)。</p><p>　　2) 该程序会检查所有库的所有主要版本的最新次要版本来搜索待嵌入的soname，并在同一目录下为soname创建 (或更新) 相对符号链接。</p><p>　　程序<code>ldconfig</code>默认会执行这些步骤，其行为可以通过命令行选项控制。选项<code>-N</code>会禁用重新构建缓存，选项<code>-X</code>会禁用创建soname符号链接。此外，选项<code>-v</code>会使该程序显示描述其操作的输出。为了正确地执行这些步骤，该程序会按照之前的约定 (库的实际名包括主要版本号和次要版本号，并随着版本增加) 解析库名。</p><p>　　当创建库、更新库、删除库或修改<code>/etc/ld.so.conf</code>的目录列表时，应该运行程序<code>ldconfig</code>。</p><p>　　假设需要按照同一库的2个不同主要版本，可以通过以下方式实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> libdemo.so.1.0.1 libdemo.so.2.0.0 /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ldconfig -v | grep libdemo</span></span><br><span class="line">        libdemo.so.1 -&gt; libdemo.so.1.0.1 (changed)</span><br><span class="line">        libdemo.so.2 -&gt; libdemo.so.2.0.0 (changed)</span><br></pre></td></tr></table></figure><p>　　这里过滤了<code>ldconfig</code>的输出来仅显示库<code>libdemo</code>的相关信息。</p><p>　　然后，列出目录<code>/usr/lib</code>下名为<code>libdemo</code>的文件，以验证soname符号链接的设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l libdemo* | awk <span class="string">&#x27;&#123;print $1, $$9, $10, $11&#125;&#x27;</span></span></span><br><span class="line">lrwxrwxrwx libdemo.so.1 -&gt; libdemo.so.1.0.1</span><br><span class="line">-rwxr-xr-x libdemo.so.1.0.1</span><br><span class="line">lrwxrwxrwx libdemo.so.2 -&gt; libdemo.so.2.0.0</span><br><span class="line">-rwxr-xr-x libdemo.so.2.0.0</span><br></pre></td></tr></table></figure><p>　　这里必须创建链接器名的符号链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s libdemo.so.2 libdemo.so</span></span><br></pre></td></tr></table></figure><p>　　当后续需要安装库的新2.x次要版本时，因为链接器名指向最新的soname，所以<code>ldconfig</code>会更新链接器名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> libdemo.so.2.0.1 /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ldconfig -v | grep libdemo</span></span><br><span class="line">        libdemo.so.1 -&gt; libdemo.so.1.0.1</span><br><span class="line">        libdemo.so.2 -&gt; libdemo.so.2.0.1 (changed)</span><br></pre></td></tr></table></figure><p>　　若需要构建和使用私有库 (安装在非标准目录的库)，则可以在运行<code>ldconfig</code>时使用选项<code>-n</code>来创建soname符号链接 (这会让<code>ldconfig</code>仅处理命令行指定目录下的库文件，并且不更新缓存文件)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.1 mod1.o mod2.o mod3.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/sbin/ldconfig -nv .</span></span><br><span class="line">.:</span><br><span class="line">        libdemo.so.1 -&gt; libdemo.so.1.0.1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l libdemo.so* | awk <span class="string">&#x27;&#123;print $1, $9, $10, $11&#125;&#x27;</span></span></span><br><span class="line">lrwxrwxrwx libdemo.so.1 -&gt; libdemo.so.1.0.1</span><br><span class="line">-rwxr-xr-x libdemo.so.1.0.1</span><br></pre></td></tr></table></figure><p>　　这里在运行<code>ldconfig</code>时指定了完整路径名，因为使用的是非特权用户，其环境变量<code>PATH</code>不包含目录<code>/sbin</code>。</p><h3 id="更新共享库">41.6 更新共享库</h3><p>　　随着时间的推移，可能需要对共享库代码进行修改。这些修改会导致共享库的新版本与旧版本<span style="background-color:#ff0">兼容</span> (仅需要修改库实际名的次要版本标识符) 或<span style="background-color:#ff0">不兼容</span> (必须要修改库实际名的主要版本标识符)。</p><p>　　对库的修改与现有版本兼容需要满足以下所有条件：</p><p>　　● 库中的所有函数和变量的语义都保持不变。换句话说，所有函数的参数列表都保持不变，继续对全局变量和返回的参数产生其指定的影响并返回相同的结果值。因此，能够提升性能或修复漏洞的修改是兼容的修改。</p><p>　　● 函数公共API中的函数或变量不会被删除。此外，向公共API添加函数和变量是兼容的。</p><p>　　● 函数内部分配的结构体、函数返回的结构体以及库定义的公共结构体都保持不变。该规则存在1个例外：有时，可能会向现有结构体的末尾添加新成员，不过即使这样也可能会导致问题 (例如，调用程序试图分配由该结构体组成的数组)。库设计者有时会通过将这些结构体定义为比库初始版本所需的大小更大来规避这一限制，并预留一些额外填充字段以 "供将来使用"。</p><p>　　若满足以上所有条件，则可以通过调整现有库名的次要版本来进行更新；否则，应该创建库的新的主要版本。</p><p>　　共享库的优势之一是可以在运行中的程序使用库时安装库的新版本，只需要创建库的新版本并将其安装在合适的目录，然后按需更新soname和链接器名符号链接 (或者让程序<code>ldconfig</code>来完成这一步)。为了创建共享库<code>/usr/lib/libdemo.1.0.1</code>的新次要版本 (兼容更新)，可以通过以下方式实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.2 mod1.o mod2.o mod3.o</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> libdemo.so.1.0.2 /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ldconfig -v | grep libdemo</span></span><br><span class="line">        libdemo.so.1 -&gt; libdemo.so.1.0.2 (changed)</span><br></pre></td></tr></table></figure><p>　　这里假设链接器名已被正确地设置 (指向对应的soname)，所以无需修改它。</p><p>　　正在运行的程序会继续使用共享库的旧次要版本。当且仅当该程序终止并再次启动时，它才会使用共享库的新次要版本。</p><p>　　当后续需要创建共享库的新主要版本 (2.0) 时，可以通过以下方式实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc -g -shared -Wl,-soname,libdemo.so.2 -o libdemo.so.2.0.0 mod1.o mod2.o mod3.o</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> libdemo.so.2.0.0 /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ldconfig -v | grep libdemo</span></span><br><span class="line">        libdemo.so.1 -&gt; libdemo.so.1.0.2</span><br><span class="line">        libdemo.so.2 -&gt; libdemo.so.2.0.0 (changed)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -sf libdemo.so.2 libdemo.so</span></span><br></pre></td></tr></table></figure><p>　　根据结果可知，<code>ldconfig</code>会自动创建新主要版本的soname符号链接。但是，如最后1行命令所示，还必须手动更新链接器名符号链接。</p><h3 id="在目标文件中指定搜索目录">41.7 在目标文件中指定搜索目录</h3><p>　　除了环境变量<code>LD_LIBRARY_PATH</code>和将共享库安装在标准目录之外，还有第3种通知动态链接器共享库位置的方法：在静态编辑阶段，在可执行文件中插入1个目录列表，以便在运行时搜索共享库。当某些库位于动态链接器搜索的标准目录之外的固定位置时，这种方法很有用。为此，在构建可执行文件时需要使用选项<code>-rpath</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -Wl,-rpath,/home/mtk/pdir -o prog prog.c libdemo.so</span></span><br></pre></td></tr></table></figure><p>　　这条命令会将字符串<code>/home/mtk/pdir</code>复制到可执行文件<code>prog</code>的运行时库路径 (<code>rpath</code>)。因此，当该程序运行时，动态链接器在解析共享库引用时也会搜索该目录。</p><p>　　选项<code>-rpath</code>可以被指定多次，这些目录会被合并为1个有序的<code>rpath</code>列表，并被放置在可执行文件中。此外，在1个选项<code>-rpath</code>中可以指定多个由冒号<code>:</code>分隔的目录。动态链接器会在运行时按照选项<code>-rpath</code>中指定的顺序搜索目录。</p><p>　　选项<code>-rpath</code>的替代方法是环境变量<code>LD_RUN_PATH</code>，该环境变量的值可以是多个由冒号<code>:</code>分隔的目录。但是，当且仅当构建可执行文件未指定选项<code>-rpath</code>时，该环境变量才有效。</p><h4 id="在构建共享库时使用链接器选项-rpath">41.7.1 在构建共享库时使用链接器选项<code>-rpath</code></h4><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/a_shared_library_that_depends_on_another_shared_library.svg"><p>　　当构建共享库时，链接器选项<code>-rpath</code>也很有用。假设共享库<code>libx1.so</code>依赖于共享库<code>libx2.so</code>，而这些库分别位于非标准目录<code>d1</code>和<code>d2</code>。创建这2个库和程序的步骤如下：</p><p>　　1) 在目录<code>pdir/d2</code>下创建库<code>libx2.so</code> (这里省略了版本命名和soname指定)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/mtk/pdir/d2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall modx2.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libx2.so modx2.o</span></span><br></pre></td></tr></table></figure><p>　　2) 在目录<code>pdir/d1</code>下创建库<code>libx1.so</code>。因为库<code>libx1.so</code>依赖于位于非标准目录的库<code>libx2.so</code>，所以在链接器选项<code>-rpath</code>中指定了后者的运行时位置。该位置可能与该库的链接时位置不同，但这里它们是相同的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/mtk/pdir/d1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -Wall -fPIC modx1.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libx1.so modx1.o -Wl,-rpath,/home/mtk/pdir/d2 -L/home/mtk/pdir/d2 -lx2</span></span><br></pre></td></tr></table></figure><p>　　3) 在目录<code>pdir</code>下构建主程序。因为主程序会使用位于非标准目录的库<code>libx1.so</code>，所以也会使用链接器选项<code>-rpath</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/mtk/pdir</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -o prog prog.c -Wl,-rpath,/home/mtk/pdir/d1 -L/home/mtk/pdir/d1 -lx1</span></span><br></pre></td></tr></table></figure><p>　　这里在构建主程序时无需指定库<code>libx2.so</code>，因为链接器能够分析库<code>libx1.so</code>的<code>rpath</code>列表来找到该库，所以所有符号都可以在静态链接阶段被解析。</p><p>　　可以通过以下命令检查程序<code>prog</code>和库<code>libx1.so</code>来查看它们的<code>rpath</code>列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -p dump_utmpx | grep PATH</span></span><br><span class="line">  RPATH              /home/mtk/pdir/d1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -p d1/libx1.so | grep PATH</span></span><br><span class="line">  RPATH              /home/mtk/pdir/d2</span><br></pre></td></tr></table></figure><p>　　也可以对命令<code>readelf ––dynamic</code>或<code>readelf –d</code>的输出进行grep来查看<code>rpath</code>列表。</p><p>　　此外，可以通过命令<code>ldd</code>来显示程序<code>prog</code>的所有动态依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd dump_utmpx</span></span><br><span class="line">        libx1.so =&gt; /home/mtk/pdir/d1/libx1.so (0x40017000)</span><br><span class="line">        libc.so.6 =&gt; /lib/tls/libc.so.6 (0x40024000)</span><br><span class="line">        libx2.so =&gt; /home/mtk/pdir/d2/libx2.so (0x4014c000)</span><br><span class="line">        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</span><br></pre></td></tr></table></figure><h4 id="elf的标签dt_rpath和dt_runpath">41.7.2 ELF的标签<code>DT_RPATH</code>和<code>DT_RUNPATH</code></h4><p>　　对于最初的ELF规范，只有1种类型的<code>rpath</code>列表可以被嵌入到可执行文件或共享库，这对应ELF文件中的标签<code>DT_RPATH</code>。后来的ELF规范弃用了该标签，并添加了标签<code>DT_RUNPATH</code>来表示<code>rpath</code>列表。这2种<code>rpath</code>列表的区别在于，当动态链接器在运行时搜索共享库时，它们相对于环境变量<code>LD_LIBRARY_PATH</code>的优先级不同，标签<code>DT_RPATH</code>的优先级更高，而标签<code>DT_RUNPATH</code>的优先级更低。</p><p>　　链接器默认会将<code>rpath</code>列表创建为标签<code>DT_RPATH</code>。为了让链接器将<code>rpath</code>列表创建为标签<code>DT_RUNPATH</code>，需要指定链接器选项<code>––enable–new–dtags</code>。若使用该选项构建程序，则通过命令<code>objdump</code>查看程序时可以得到以下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -Wall -o prog prog.c -Wl,--enable-new-dtags -Wl,-rpath,/home/mtk/pdir/d1 -L/home/mtk/pdir/d1 -lx1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -p prog | grep PATH</span></span><br><span class="line">  RPATH                /home/mtk/pdir/d1</span><br><span class="line">  RUNPATH              /home/mtk/pdir/d1</span><br></pre></td></tr></table></figure><p>　　根据结果可知，可执行文件同时包含这2个标签。链接器以这种方式复制<code>rpath</code>列表是为了方便那些无法识别标签<code>DT_RUNPATH</code>的旧版动态链接器 (glibc 2.2添加了对标签<code>DT_RUNPATH</code>的支持)。能够识别标签<code>DT_RUNPATH</code>的动态链接器会忽略标签<code>DT_RPATH</code>。</p><h4 id="在rpath中使用origin">41.7.3 在<code>rpath</code>中使用<code>$ORIGIN</code></h4><p>　　假设需要分发使用了私有共享库的应用程序，但不能要求用户将这些库安装到标准目录。相反，用户可以在其选择的任意目录下解压应用程序，并能够立即运行该应用程序。问题在于，应用程序无法确定其共享库的位置，除非要求用户设置环境变量<code>LD_LIBRARY_PATH</code>或运行安装脚本来识别所需的目录，但这2种方法都不理想。</p><p>　　为此，动态链接器被设计为能够理解<code>rpath</code>规范中的特殊字符串<code>$ORIGIN</code> (或<code>$&#123;ORIGIN&#125;</code>)。动态链接器会将该字符串解释为 "应用程序所在的目录"。因此，可以通过以下命令来构建应用程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Wl,-rpath,<span class="string">&#x27;$ORIGIN&#x27;</span>/lib ...</span></span><br></pre></td></tr></table></figure><p>　　该命令会假设运行时应用程序的共享库位于应用程序所在目录的子目录<code>lib</code>下。因此，可以向用户提供包含应用程序和相关库的安装包，用户可以将安装包安装在任意位置，然后运行应用程序 (即 "turn-key" 应用程序)。</p><h3 id="在运行时搜索共享库">41.8 在运行时搜索共享库</h3><p>　　在解析库依赖时，动态链接器会先检查所有依赖字符串是否包含斜杠<code>/</code>。若在链接可执行文件时显式指定了库路径名，则可能出现这种情况。若发现斜杠，则依赖字符串会被解释为路径名，并使用该路径名加载库；否则，动态链接器按照以下规则搜索共享库：</p><p>　　1) 若可执行文件的<code>DT_RPATH</code>运行时库路径列表 (<code>rpath</code>) 中包含目录，并且可执行文件没有<code>DT_RUNPATH</code>列表，则按照链接程序时指定的顺序搜索这些目录。</p><p>　　2) 若定义了环境变量<code>LD_LIBRARY_PATH</code>，则依次搜索该环境变量的值中的目录。若可执行文件是set-user-ID或set-group-ID程序，则会忽略该环境变量。这是为了防止用户欺骗动态连接起加载与可执行文件所需的库同名的私有版本库。</p><p>　　3) 若可执行文件的<code>DT_RUNPATH</code>运行时库路径列表中包含目录，则按照链接程序时指定的顺序搜索这些目录。</p><p>　　4) 检查文件<code>/etc/ld.so.cache</code>是否包含库条目。</p><p>　　5) 先搜索目录<code>/lib</code>，再搜索目录<code>/usr/lib</code>。</p><h3 id="运行时符号解析">41.9 运行时符号解析</h3><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_41/resolving_a_global_symbol_reference.svg"><p>　　假设主程序和共享库都定义了全局函数<code>xyz()</code>，并且该共享库中的函数也调用了<code>xyz()</code>。当构建主程序和共享库后，运行该程序时会得到以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall -c foo.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -o libfoo.so foo.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -o prog prog.c libfoo.so</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">main-xyz</span><br></pre></td></tr></table></figure><p>　　根据结果可知，主程序的<code>xyz()</code>定义覆盖了共享库的<code>xyz()</code>定义。虽然这乍看之下令人惊讶，但这是有历史原因的。最初的共享库实现的设计使得符号解析的默认语义完全与链接到该库的静态库版本的应用程序的语义完全一致。这表示以下语义适用：</p><p>　　● 主程序中的全局符号定义会覆盖库中的相同定义。</p><p>　　● 若多个库都定义了同一全局符号，则对该符号的引用会绑定到按照静态链接命令中列出的库从左到右搜索到的第1个定义。</p><p>　　虽然这些语义使得从静态库过渡到动态库相对简单，但也可能会导致一些问题。最显著的问题是这些语义与共享库作为实现包含子系统的模型相冲突。在默认情况下，共享库不会保证对其全局符号的引用实际上会绑定到该库对该符号的定义。因此，当共享库被聚合到更大的单元时，其属性可能会发生变化。这可能会导致应用程序以意想不到的方式崩溃，也使得分而治之的调试方法 (即试图使用较少或不同的库重现问题) 变得困难。</p><p>　　链接器选项<code>-Bsymbolic</code>会让共享库中的全局符号引用优先绑定到该库中的定义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -c -fPIC -Wall -c foo.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -shared -Wl,-Bsymbolic -o libfoo.so foo.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -o prog prog.c libfoo.so</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=. ./prog</span></span><br><span class="line">foo-xyz</span><br></pre></td></tr></table></figure><p>　　这里无论是否指定了链接器选项<code>-Bsymbolic</code>，在主程序中调用<code>xyz()</code>都会使用主程序中的定义。</p><h3 id="使用静态库的场景">41.10 使用静态库的场景</h3><p>　　在某些情况下，相比动态库，更适合使用静态库。假设用户无法或不希望在运行程序的系统上按照共享库，或者程序将在chroot jail等共享库不可用的环境中运行，那么静态链接就很有用。此外，即使是兼容的共享库升级也可能无意中引入错误，从而导致应用程序崩溃。对于静态链接的应用程序，可以确保它不会受到系统中共享库变化的影响，并且具备运行时所需的所有代码 (代价是程序体积更大以及随之增加的磁盘和内核需求)。</p><p>　　若链接器可以选择同名的共享库和静态库，则默认会使用共享库。为了强制使用静态库，可以使用以下方法之一：</p><p>　　● 在使用命令<code>gcc</code>时指定静态库的路径名 (包含后缀<code>.a</code>)。</p><p>　　● 在使用命令<code>gcc</code>时指定选项<code>-static</code>。</p><p>　　● 在使用命令<code>gcc</code>时指定选项<code>–Wl,–Bstatic</code>或<code>–Wl,–Bdynamic</code>来显式地让链接器选择静态库或动态库。这些选项可以与选项<code>-l</code>一起使用。链接器将按照指定的顺序处理这些选项。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_40/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第40章 登录统计"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第40章 登录统计</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_42/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第42章 共享库高级特性">《Linux/UNIX系统编程手册》第42章 共享库高级特性 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>