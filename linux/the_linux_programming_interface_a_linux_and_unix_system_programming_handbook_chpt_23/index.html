<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_23/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_23/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_23/","title":"《Linux/UNIX系统编程手册》第23章 定时器和睡眠"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第23章 定时器和睡眠 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E9%9A%94%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-text">23.1 间隔定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alarm"><span class="nav-text">23.2 alarm()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E9%98%BB%E5%A1%9E%E6%93%8D%E4%BD%9C%E8%AE%BE%E7%BD%AE%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="nav-text">23.3 为阻塞操作设置超时时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9D%A1%E7%9C%A0"><span class="nav-text">23.4 睡眠</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#posix%E6%97%B6%E9%92%9F"><span class="nav-text">23.5 POSIX时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#clock_gettime"><span class="nav-text">23.5.1 clock_gettime()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clock_settime"><span class="nav-text">23.5.2 clock_settime()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clock_getcpuclockid%E5%92%8Cpthread_getcpuclockid"><span class="nav-text">23.5.3 clock_getcpuclockid()和pthread_getcpuclockid()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clock_nanosleep"><span class="nav-text">23.5.4 clock_nanosleep()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#posix%E9%97%B4%E9%9A%94%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-text">23.6 POSIX间隔定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#timer_create"><span class="nav-text">23.6.1 timer_create()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timer_settime"><span class="nav-text">23.6.2 timer_settime()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timer_gettime"><span class="nav-text">23.6.3 timer_gettime()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timer_delete"><span class="nav-text">23.6.4 timer_delete()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E8%B6%85%E9%99%90"><span class="nav-text">23.6.5 定时器超限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BF%A1%E5%8F%B7%E9%80%9A%E7%9F%A5"><span class="nav-text">23.6.6 通过信号通知</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E9%80%9A%E7%9F%A5"><span class="nav-text">23.6.7 通过线程通知</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timerfd-api"><span class="nav-text">23.7 timerfd API</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_23/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第23章 定时器和睡眠 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第23章 定时器和睡眠</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-05-13 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-13T00:00:00+08:00">2025-05-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-05-15 00:00:00" itemprop="dateModified" datetime="2025-05-15T00:00:00+08:00">2025-05-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>27k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　定时器允许进程将通知安排在未来的某个时刻。睡眠允许进程 (或线程) 在一段时间内挂起执行。</p><p>　　由于系统负载和进程调度，进程在定时器过期或睡眠完成后可能需要等待一小段时间 (通常是几分之一秒) 才能被调度。但是，周期性定时器<span style="background-color:#ff0">不会</span>受到影响。</p><p>　　通过结构体<code>timeval</code>设置定时器的实际精度受限于系统时钟。若定时器的值不是系统时钟的整数倍，则定时器的值会向上取整 (保证其值是系统时钟的整数倍)。例如，定时器设置为19100微秒后过期 (即略长于19毫秒)，而jiffy为4毫秒，则定时器的实际过期时间是20毫秒后。但是，Linux从内核2.6.21开始提供可选的高精度定时器 (通过内核配置选项<code>CONFIG_HIGH_RES_TIMERS</code>)。当启用了该功能后，各种定时器和睡眠接口不再受限于jiffy，其精度可以达到硬件支持的精度 (对于现代硬件，精度通常可以达到微秒)。</p><h3 id="间隔定时器">23.1 间隔定时器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value, <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getitimer</span><span class="params">(<span class="type">int</span> which, <span class="keyword">struct</span> itimerval *curr_value)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* 周期性定时器的间隔 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* 第1次过期时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>setitimer()</code>会为调用进程设置<strong>间隔定时器</strong>，间隔定时器会在未来的某个时刻过期，并且可以设置为在此之后定期过期。</p><p>　　参数<code>which</code>表示创建的间隔定时器的类型，可以指定为<code>ITIMER_REAL</code>、<code>ITIMER_VIRTUAL</code>或<code>ITIMER_PROF</code>，分别对应3种不同类型的间隔定时器：</p><p>　　● <code>ITIMER_REAL</code>表示实时间隔定时器 (基于挂钟时间)。当该定时器过期时，会为进程生成信号<code>SIGALRM</code>。</p><p>　　● <code>ITIMER_VIRTUAL</code>表示基于用户CPU时间的间隔定时器。当该定时器过期时，会为进程生成信号<code>SIGVTALRM</code>。</p><p>　　● <code>ITIMER_PROF</code>表示基于进程时间 (即用户CPU时间和系统CPU时间之和) 的剖析定时器。当该定时器过期时，会为进程生成信号<code>SIGPROF</code>。</p><p>　　这些间隔定过期时生成的信号的默认处理方式都是终止进程。</p><span id="more"></span><p>　　参数<code>new_value</code>和<code>old_value</code>是指向结构体<code>itimerval</code>的指针。</p><p>　　● <code>new_value</code>指向的结构体<code>itimerval</code>的成员<code>it_value</code>和<code>it_interval</code>分别用于指定间隔定时器的第1次过期时间以及是否为周期性定时器。若<code>new_value.it_interval</code>的所有成员都指定为0，则间隔定时器只会过期1次 (即<code>new_value.it_value</code>指定的时间)。若<code>new_value.it_interval</code>的所有成员都指定为非0值，则每次间隔定时器过期后，间隔定时器都会重置 (以便于在指定间隔后再次过期)。</p><p>　　● 若<code>old_value</code>不为<code>NULL</code>，则它指向的结构体<code>itimerval</code>会包含间隔定时器的旧值。若<code>old_value.it_value</code>的所有成员都为0，则表示间隔定时器之前处于关闭状态。若<code>old_value.it_interval</code>的所有成员都为0，则表示间隔定时器之前只会过期1次 (即<code>old_value.it_value</code>指定的时间)。</p><p>　　进程只能设置这3种间隔定时器之一。若再次调用<code>setitimer()</code>，则会将现有间隔定时器修改为<code>which</code>对应的间隔定时器。若第2次调用<code>setitimer()</code>时将<code>new_value.it_value</code>指定为0，则会关闭现有间隔定时器。</p><p>　　间隔定时器会从初始值 (即<code>it_value</code>) 向下计数到0。当间隔定时器计数到0时，对应的信号会发送给进程。若间隔 (即<code>it_interval</code>) 不为0，则间隔定时器的值 (<code>it_value</code>) 会重新装载为间隔值，并再次向下计数。</p><p>　　系统调用<code>getitimer()</code>可用于检索间隔定时器的当前状态，以便于获取距离下一次过期的时间。该系统调用会将参数<code>which</code>指定的间隔定时器的当前状态 (即<code>setitimer()</code>的参数<code>old_value</code>包含的信息) 存储在参数<code>curr_value</code>指向的结构体<code>itimerval</code>中。</p><p>　　SUSv4将<code>setitimer()</code>和<code>getitimer()</code>标记为过时，并且建议使用POSIX间隔定时器API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* real_timer.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> gotAlarm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigalrmHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    gotAlarm = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 检索和打印挂钟时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @param includeTimer 若该参数为TRUE，则还会打印实时间隔定时器的当前值和间隔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">displayTimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, Boolean includeTimer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">itv</span>;</span></span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">curr</span>;</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> callNum = <span class="number">0</span>; <span class="comment">/* 本函数的被调用次数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callNum == <span class="number">0</span>) <span class="comment">/* 初始化已用时计时器 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gettimeofday(&amp;start, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;gettimeofday&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callNum % <span class="number">20</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       Elapsed  Value Interval\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gettimeofday(&amp;curr, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;gettimeofday&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-7s %6.2f&quot;</span>, msg, curr.tv_sec - start.tv_sec + (curr.tv_usec - start.tv_usec) / <span class="number">1000000.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (includeTimer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (getitimer(ITIMER_REAL, &amp;itv) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;getitimer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %6.2f %6.2f&quot;</span>, itv.it_value.tv_sec + itv.it_value.tv_usec / <span class="number">1000000.0</span>,</span><br><span class="line">               itv.it_interval.tv_sec + itv.it_interval.tv_usec / <span class="number">1000000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    callNum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">itv</span>;</span></span><br><span class="line">    <span class="type">clock_t</span> prevClock;</span><br><span class="line">    <span class="type">int</span> maxSigs; <span class="comment">/* 退出前捕获的信号的数量 */</span></span><br><span class="line">    <span class="type">int</span> sigCnt;  <span class="comment">/* 当前捕获的信号的数量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [secs [usecs [int-secs [int-usecs]]]]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = sigalrmHandler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 捕获3个信号或1个信号 (it_interval为0时) 后退出 */</span></span><br><span class="line">    maxSigs = (itv.it_interval.tv_sec == <span class="number">0</span> &amp;&amp; itv.it_interval.tv_usec == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">3</span>;</span><br><span class="line">    displayTimes(<span class="string">&quot;START:&quot;</span>, FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据命令行参数设置间隔定时器 */</span></span><br><span class="line">    itv.it_value.tv_sec = (argc &gt; <span class="number">1</span>) ? getLong(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;secs&quot;</span>) : <span class="number">2</span>;</span><br><span class="line">    itv.it_value.tv_usec = (argc &gt; <span class="number">2</span>) ? getLong(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;usecs&quot;</span>) : <span class="number">0</span>;</span><br><span class="line">    itv.it_interval.tv_sec = (argc &gt; <span class="number">3</span>) ? getLong(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="string">&quot;int-secs&quot;</span>) : <span class="number">0</span>;</span><br><span class="line">    itv.it_interval.tv_usec = (argc &gt; <span class="number">4</span>) ? getLong(argv[<span class="number">4</span>], <span class="number">0</span>, <span class="string">&quot;int-usecs&quot;</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setitimer(ITIMER_REAL, &amp;itv, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevClock = clock();</span><br><span class="line">    sigCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 内部循环至少使用0.5秒的CPU时间 */</span></span><br><span class="line">        <span class="keyword">while</span> (((clock() - prevClock) * <span class="number">10</span> / CLOCKS_PER_SEC) &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (gotAlarm)</span><br><span class="line">            &#123;</span><br><span class="line">                gotAlarm = <span class="number">0</span>;</span><br><span class="line">                displayTimes(<span class="string">&quot;ALARM:&quot;</span>, TRUE);</span><br><span class="line"></span><br><span class="line">                sigCnt++;</span><br><span class="line">                <span class="keyword">if</span> (sigCnt &gt;= maxSigs)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s all folks\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prevClock = clock();</span><br><span class="line">        displayTimes(<span class="string">&quot;Main: &quot;</span>, TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>setitimer()</code>和<code>getitimer()</code>的用法。该程序会执行以下步骤：</p><p>　　1) 为信号<code>SIGALRM</code>注册处理函数 (第75~81行)，该处理函数会设置全局标志<code>gotAlarm</code>。</p><p>　　2) 通过命令行参数设置实时间隔定时器，若没有提供这些命令行参数，则定时器只会在2秒后过期1次 (第88~96行)。</p><p>　　3) 进行循环，直到捕获的信号的数量达到上限。每次循环会适当延时，然后根据全局标志<code>gotAlarm</code>来判断是否设置变量<code>sigCnt</code>并打印相关时间 (第101~122行)。</p><h3 id="alarm">23.2 <code>alarm()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>; <span class="comment">/* 总是会成功，存在之前设置的定时器时返回该定时器的剩余秒数，没有之前设置的定时器时返回0 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>alarm()</code>会为调用进程设置只会过期1次的实时定时器，该定时器会在参数<code>seconds</code>指定的秒数后过期，过期时会为调用进程生成信号<code>SIGALRM</code>。</p><p>　　若存在之前设置的定时器，则<code>alarm()</code>会返回该定时器的剩余秒数；否则，<code>alarm()</code>会返回0。</p><p>　　通过<code>alarm()</code>设置的定时器会覆盖之前设置的定时器，所以可以通过调用<code>alarm(0)</code>来关闭现有定时器。</p><p>　　通过<code>setitimer()</code>和<code>alarm()</code>设置的定时器可以在<code>exec()</code>期间保留，并且不会被通过<code>fork()</code>创建的子进程继承。</p><p>　　从历史角度，<code>alarm()</code>原本是用于设置定时器的UNIX API。</p><p>　　对于Linux，<code>alarm()</code>和<code>setitimer()</code>会共享进程级的实时定时器，这表示通过其中1个系统调用设置的定时器会覆盖之前由这2个系统调用之一设置的任意定时器。这种情况并不适用于所有UNIX实现，并且SUSv3故意没有说明这2个系统调用之间的相互作用。</p><p>　　在之后的某些示例中，会通过调用<code>alarm()</code>和不注册<code>SIGALRM</code>处理函数的组合来保证程序在一段时间后自动终止。</p><h3 id="为阻塞操作设置超时时间">23.3 为阻塞操作设置超时时间</h3><p>　　实时定时器的用法之一就是为阻塞系统调用的阻塞时间设置上限。例如，可以通过以下步骤来为保证用户在一段时间内没有输入时自动取消对终端的<code>read()</code>：</p><p>　　1) 通过<code>sigaction()</code>为信号<code>SIGALRM</code>注册处理函数，并且不指定标志<code>SA_RESTART</code> (保证阻塞系统调用不会重启)。</p><p>　　2) 通过<code>alarm()</code>或<code>setitimer()</code>设置实时定时器，该定时器为阻塞系统调用设置超时时间。</p><p>　　3) 调用阻塞系统调用。</p><p>　　4) 在阻塞系统调用返回后，再次调用<code>alarm()</code>或<code>setitimer()</code>来关闭实时定时器 (在这种情况下，阻塞系统调用会在预期时间内完成)。</p><p>　　5) 检查阻塞系统调用是否将<code>errno</code>设置为<code>EINTR</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* timed_read.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数printf()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> numRead;</span><br><span class="line">    <span class="type">int</span> savedErrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [num-secs [restart-flag]]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为SIGALRM注册处理函数。默认允许系统调用被中断，除非提供了第2个命令行参数 */</span></span><br><span class="line">    sa.sa_flags = (argc &gt; <span class="number">2</span>) ? SA_RESTART : <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm((argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_NONNEG, <span class="string">&quot;num-secs&quot;</span>) : <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    numRead = read(STDIN_FILENO, buf, BUF_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    savedErrno = errno; <span class="comment">/* 防止alarm()修改errno */</span></span><br><span class="line">    alarm(<span class="number">0</span>);           <span class="comment">/* 关闭定时器 */</span></span><br><span class="line">    errno = savedErrno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断read()的结果 */</span></span><br><span class="line">    <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Read timed out\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            errMsg(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Successful read (%ld bytes): %.*s&quot;</span>, (<span class="type">long</span>)numRead, (<span class="type">int</span>)numRead, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会通过<code>alarm()</code>设置实时定时器来实现上述步骤。这里存在1个理论上的竞争条件：若通过<code>alarm()</code>设置的定时器在调用<code>read()</code>之前过期，则<code>read()</code>不会被信号处理函数中断。但是，实际中设置的超时时间相对较长 (至少几秒)，所以该竞争条件基本上不会出现。</p><h3 id="睡眠">23.4 睡眠</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>; <span class="comment">/* 正常结束时返回0，提前结束时返回剩余秒数 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>sleep()</code>会将调用进程的执行挂起参数<code>seconds</code>指定的秒数，或者被信号中断。</p><p>　　若睡眠完成，则<code>sleep()</code>返回0。若睡眠被信号中断，则<code>sleep()</code>返回剩余 (未睡眠) 秒数。</p><p>　　SUSv3故意没有说明<code>sleep()</code>与<code>alarm()</code>和<code>setitimer()</code>之间的相互作用。对于Linux，<code>sleep()</code>被实现为调用<code>nanosleep()</code>，所以<code>sleep()</code>和这2个系统调用之间没有相互作用。但是，对于部分UNIX实现 (尤其是较旧的UNIX实现)，<code>sleep()</code>被实现为<code>alarm()</code>和<code>SIGALRM</code>处理函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nanosleep</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timespec *request, <span class="keyword">struct</span> timespec *remain)</span>; <span class="comment">/* 完成睡眠时返回0，睡眠被中断或出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>nanosleep()</code>与<code>sleep()</code>类似，但提供了更高的精度。</p><p>　　参数<code>request</code>指向的结构体<code>timespec</code>指定睡眠时间，其成员<code>tv_nsec</code>只能指定为0到999999999之间的数。</p><p>　　SUSv3明确说明<code>nanosleep()</code>不应该通过信号实现，所以<code>nanosleep()</code>与<code>alarm()</code>和<code>setitimer()</code>之间没有相互作用。</p><p>　　尽管不会通过信号实现，<code>nanosleep()</code>还是会被信号中断。在这种情况下，<code>nanosleep()</code>会返回-1，并将<code>errno</code>设置为<code>EINTR</code>。若参数<code>remain</code>不为<code>NULL</code>，则该参数指向的结构体<code>timespec</code>还会包含剩余时间。</p><p>　　与通过结构体<code>timeval</code>设置定时器相同，<code>nanosleep()</code>的睡眠时间受限于系统时钟。若指定的睡眠时间不是系统时钟的整数倍，则会向上取整 (保证其值是系统时钟频率的整数倍)。对于支持高精度定时器的系统，睡眠时间的精度可以比系统时钟的精度更高。</p><p>　　对于Linux 2.4及以下版本，<code>nanosleep()</code>实现还存在1个偏差：假设进程执行该函数时被信号停止，当进程随后被信号<code>SIGCONT</code>恢复时，<code>nanosleep()</code>会返回-1，并将<code>errno</code>设置为<code>EINTR</code>。但是，当程序随重启该函数时，停止期间所用的时间不会计入睡眠时间，所以进程睡眠的实际时间可能比预期时间更长。这个偏差在Linux 2.6得到了修复，信号<code>SIGCONT</code>恢复进程时会自动恢复该函数，并且停止期间所用的时间会计入睡眠时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_nanosleep.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigintHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">finish</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">request</span>, <span class="title">remain</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s secs nanosecs\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request.tv_sec = getLong(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;secs&quot;</span>);</span><br><span class="line">    request.tv_nsec = getLong(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;nanosecs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = sigintHandler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gettimeofday(&amp;start, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;gettimeofday&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        s = nanosleep(&amp;request, &amp;remain);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">-1</span> &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;nanosleep&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gettimeofday(&amp;finish, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;gettimeofday&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Slept for: %9.6f secs\n&quot;</span>, finish.tv_sec - start.tv_sec +</span><br><span class="line">                                              (finish.tv_usec - start.tv_usec) / <span class="number">1000000.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* nanosleep()完成 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Remaining: %2ld.%09ld\n&quot;</span>, (<span class="type">long</span>)remain.tv_sec, remain.tv_nsec);</span><br><span class="line">        request = remain; <span class="comment">/* 下一次睡眠时间是剩余时间 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sleep complete\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>nanosleep()</code>的用法。该程序会根据命令行参数来设置<code>nanosleep()</code>的睡眠时间，然后循环调用<code>nanosleep()</code>，直到睡眠完成。若<code>nanosleep()</code>被<code>SIGINT</code>处理函数中断，则会用<code>remain</code>再次调用该函数。</p><h3 id="posix时钟">23.5 POSIX时钟</h3><p>　　POSIX时钟 (最初由POSIX.1b定义) 提供了1个用于访问以纳秒精度测量时间的时钟的API。纳秒时间通过结构体<code>timespec</code>表示 (见15.2.2)。对于glibc 2.17之前的版本，使用该API的程序在编译时必须带有选项<code>-lrt</code>，以链接实时库librt。</p><p>　　POSIX时钟API中的主要系统调用是<code>clock_gettime()</code>、<code>clock_getres()</code>和<code>clock_settime()</code>。</p><h4 id="clock_gettime">23.5.1 <code>clock_gettime()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">(<span class="type">clockid_t</span> clockid, <span class="keyword">struct</span> timespec *tp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_getres</span><span class="params">(<span class="type">clockid_t</span> clockid, <span class="keyword">struct</span> timespec *res)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>clock_gettime()</code>会将参数<code>clockid</code>指定的时钟的时间值存储在参数<code>tp</code>指向的结构体<code>timespec</code>中 (尽管该结构体的精度可以达到纳秒，但这里存储在该结构体中的时间的精度可能更低)。系统调用<code>clock_getres()</code>会将参数<code>clockid</code>指定的时钟的精度存储在参数<code>res</code>指向的结构体<code>timespec</code>中。</p><p>　　SUSv3详细说明了数据类型<code>clockid_t</code>，该数据类型用于表示时钟标识符。</p><table><colgroup><col style="width:38%"><col style="width:61%"></colgroup><thead><tr><th>时钟ID</th><th>描述</th></tr></thead><tbody><tr><td><code>CLOCK_REALTIME</code></td><td>可设置的系统级实时时钟</td></tr><tr><td><code>CLOCK_MONOTONIC</code></td><td>不可设置的单调时钟</td></tr><tr><td><code>CLOCK_PROCESS_CPUTIME_ID</code></td><td>进程级CPU时间时钟 (Linux 2.6.12及以上版本)</td></tr><tr><td><code>CLOCK_THREAD_CPUTIME_ID</code></td><td>线程级CPU时间时钟 (Linux 2.6.12及以上版本)</td></tr></tbody></table><p>　　<code>CLOCK_REALTIME</code>时钟是测量挂钟时间的系统级时钟。与<code>CLOCK_MONOTONIC</code>时钟相比，该时钟的设置可以修改。</p><p>　　SUSv3规定，<code>CLOCK_MONOTONIC</code>时钟测量自过去某个时间点以来的时间，该时间点在系统启动后就不会改变。对于不能受到系统时钟的不连续修改 (例如，手动修改系统时间) 的影响的应用程序，该时钟很有用。对于Linux，该时钟测量自系统启动以来的时间。</p><p>　　<code>CLOCK_PROCESS_CPUTIME_ID</code>时钟测量调用进程所用的用户和系统CPU时间。<code>CLOCK_THREAD_CPUTIME_ID</code>为线程执行类似的任务。</p><p>　　SUSv3详细说明了这4个时钟，但只有<code>CLOCK_REALTIME</code>时钟是必须提供的，并且在UNIX实现中得到了广泛的支持。</p><p>　　Linux 2.6.28添加了时钟类型<code>CLOCK_MONOTONIC_RAW</code> (用于特殊的时钟同步应用程序)。该时钟不可设置，但可以访问不受NTP调整影响的仅基于硬件的时间。</p><p>　　Linux 2.6.32添加了时钟类型<code>CLOCK_REALTIME_COARSE</code>和<code>CLOCK_MONOTIC_COARSE</code> (用于以最小代价获取低精度时间戳的应用程序)。这2种时钟与<code>CLOCK_REALTIME</code>和<code>CLOCK_MONOTONIC</code>时钟类似，但时间精度更低。这2种非标准时钟无法访问硬件时钟 (某些硬件时钟源的访问成本较高)，并且返回值的精度是jiffy。</p><h4 id="clock_settime">23.5.2 <code>clock_settime()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_settime</span><span class="params">(<span class="type">clockid_t</span> clockid, <span class="type">const</span> <span class="keyword">struct</span> timespec *tp)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>clock_settime()</code>会通过参数<code>tp</code>指向的结构体<code>timespec</code>中的时间设置参数<code>clockid</code>指定的时钟。</p><p>　　若<code>tp</code>指向的结构体<code>timespec</code>中的时间不是<code>clock_getres()</code>返回的时间精度的整数倍，则该时间会向下取整。</p><p>　　特权进程 (能力<code>CAP_SYS_TIME</code>) 可以设置<code>CLOCK_REALTIME</code>时钟。该时钟的初始值通常是自纪元以来的时间。23.5.1的表格中的其他时钟类型不可修改。</p><p>　　SUSv3允许设置<code>CLOCK_PROCESS_CPUTIME_ID</code>和<code>CLOCK_THREAD_CPUTIME_ID</code>时钟。在撰写本书时，这2个时钟在Linux上是不可设置的。</p><h4 id="clock_getcpuclockid和pthread_getcpuclockid">23.5.3 <code>clock_getcpuclockid()</code>和<code>pthread_getcpuclockid()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_getcpuclockid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">clockid_t</span> *clockid)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>clock_getcpuclockid()</code>会将进程ID为<code>pid</code>的进程的CPU时间时钟标识符存储在参数<code>clockid</code>指向的缓冲区中。若<code>pid</code>为0，则将调用进程的CPU时间时钟标识符存储在缓冲区中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_getcpuclockid</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">clockid_t</span> *clockid)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>pthread_getcpuclockid()</code>是<code>clock_getcpuclockid()</code>的POSIX线程版本。</p><h4 id="clock_nanosleep">23.5.4 <code>clock_nanosleep()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_nanosleep</span><span class="params">(<span class="type">clockid_t</span> clockid, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="keyword">struct</span> timespec *request, <span class="keyword">struct</span> timespec *remain)</span>; <span class="comment">/* 完成睡眠时返回0，睡眠被中断或出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　与<code>nanosleep()</code>类似，特定于Linux的系统调用<code>clock_nanosleep()</code>会将调用进程的执行挂起指定时间，或者被信号中断。参数<code>request</code>和<code>remain</code>与对应的<code>nanosleep()</code>参数类似。</p><p>　　在默认情况下 (即<code>flags</code>为0)，<code>request</code>指定的睡眠时间是相对的。但是，若指定了标志<code>TIMER_ABSTIME</code>，则<code>request</code>指定的时间是由<code>clockid</code>标识的时钟测量的绝对时间。</p><p>　　对于23.4中介绍的 "睡过头" 问题 (尤其是进程通过循环来重启被信号中断的睡眠)，若信号以较高的频率到达，则相对时间 (通过<code>nanosleep()</code>睡眠) 会让睡眠时间更不准确。这个问题可以通过使用绝对时间避免 (先通过<code>clock_gettime()</code>获取当前时间，然后加上预期睡眠时间得到目标时间，最后调用<code>clock_nanosleep()</code>时指定标志<code>TIMER_ABSTIME</code>)。</p><p>　　若指定了标志<code>TIMER_ABSTIME</code>，则参数<code>remain</code>不会生效。当<code>clock_nanosleep()</code>被信号中断时，可以以相同参数再次调用该函数来重启睡眠。</p><p>　　区分<code>clock_nanosleep()</code>和<code>nanosleep</code>的另一个特性是<code>clock_nanosleep()</code>可以指定测量睡眠时间的时钟 (例如，<code>CLOCK_REALTIME</code>、<code>CLOCK_MONOTONIC</code>或<code>CLOCK_PROCESS_CPUTIME_ID</code>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">request</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检索CLOCK_REALTIME时钟的当前值 */</span></span><br><span class="line"><span class="keyword">if</span> (clock_gettime(CLOCK_REALTIME, &amp;request) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;clock_gettime&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.tv_sec += <span class="number">20</span>; <span class="comment">/* 睡眠20秒 */</span></span><br><span class="line"></span><br><span class="line">s = clock_nanosleep(CLOCK_REALTIME, TIMER_ABSTIME, &amp;request, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Interrupted by signal handler\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;clock_nanosleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会通过<code>clock_nanosleep()</code>以<code>CLOCK_REALTIME</code>时钟的绝对时间来睡眠20秒。</p><h3 id="posix间隔定时器">23.6 POSIX间隔定时器</h3><p>　　通过<code>setitimer()</code>设置的经典间隔定时器存在很多限制：</p><p>　　● 只能设置3种间隔定时器：<code>ITIMER_REAL</code>、<code>ITIMER_VIRTUAL</code>和<code>ITIMER_PROF</code>。</p><p>　　● 只能通过信号来通知进程间隔定时器过期。此外，无法修改间隔定时器过期时生成的信号。</p><p>　　● 在间隔定时器对应的信号被阻塞期间，即使间隔定时器多次过期，信号处理函数也只会被调用1次，所以无法得知是否出现了这种情况。</p><p>　　● 间隔定时器的精度只能达到微妙。</p><p>　　POSIX.1b定义的POSIX定时器API没有这些限制。Linux从2.6开始支持该API。对于glibc 2.17之前的版本，使用该API的程序在编译时必须带有选项<code>-lrt</code>，以链接实时库librt。</p><p>　　POSIX定时器API将定时器的生命周期划分为以下阶段：</p><p>　　● 系统调用<code>timer_create()</code>会创建定时器，并定义该定时器过期时通知进程的方法。</p><p>　　● 系统调用<code>timer_settime()</code>会启动或停止定时器。</p><p>　　● 系统调用<code>timer_delete()</code>会删除定时器。所有POSIX定时器都会占用系统资源，所以当不再需要POSIX定时器时，应该通过该系统调用来释放相关系统资源。</p><p>　　对于较旧的Linux版本，glibc的基于线程的实现仅提供了该API的部分功能。但是，该用户空间实现并未提供这里介绍的所有功能。</p><p>　　POSIX定时器不会被通过<code>fork()</code>创建的子进程继承。此外，POSIX定时器会在<code>exec()</code>期间或进程终止时停止并删除。</p><h4 id="timer_create">23.6.1 <code>timer_create()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_create</span><span class="params">(<span class="type">clockid_t</span> clockid, <span class="keyword">struct</span> sigevent *evp, <span class="type">timer_t</span> *timerid)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sigev_notify;         <span class="comment">/* 通知方法 */</span></span><br><span class="line">    <span class="type">int</span> sigev_signo;          <span class="comment">/* 定时器过期信号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">sigev_value</span>;</span> <span class="comment">/* 作为信号随附数据或传递给线程函数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">pid_t</span> _tid; <span class="comment">/* 接收信号的线程的线程ID */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="type">void</span> (*_function)(<span class="keyword">union</span> sigval); <span class="comment">/* 线程通知函数 */</span></span><br><span class="line">            <span class="type">void</span> *_attribute;                <span class="comment">/* 通知属性 */</span></span><br><span class="line">        &#125; _sigev_thread;</span><br><span class="line">    &#125; _sigev_un;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sigev_notify_function _sigev_un._sigev_thread._function</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sigev_notify_attributes _sigev_un._sigev_thread._attribute</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sigev_notify_thread_id _sigev_un._tid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>timer_create()</code>会创建1个使用参数<code>clockid</code>指定的时钟测量时间的定时器。<code>clockid</code>可以指定为23.5.1的表格中的值，或者通过<code>clock_getcpuclockid()</code>或<code>pthread_getcpuclockid()</code>返回的<code>clockid</code>值。</p><p>　　参数<code>timerid</code>指向的缓冲区会包含1个句柄，该句柄用于在POSIX定时器API的其他系统调用中引用定时器。SUSv3详细说明了数据类型<code>clockid_t</code>，该数据类型用于表示定时器标识符。</p><p>　　参数<code>evp</code>是指向结构体<code>sigevent</code>的指针，用于指定定时器过期时程序如何收到通知。</p><p>　　结构体<code>sigevent</code>的成员<code>sigev_notify</code>可以指定为以下标志之一：</p><p>　　● <code>SIGEV_NONE</code>表示定时器过期时不进行通知。进程依然可以通过<code>timer_gettime()</code>来监控程序的定时器。</p><p>　　● <code>SIGEV_SIGNAL</code>表示定时器过期时为进程生成成员<code>sigev_signo</code>指定的信号。若成员<code>sigev_signo</code>是实时信号，则成员<code>sigev_value</code>将作为其随附数据 (见22.4)。</p><p>　　● <code>SIGEV_THREAD</code>表示定时器过期时调用成员<code>sigev_notify_function</code>指定的函数，该函数将在新线程中作为启动函数被调用 (SUSv3要求如此，并且允许实现以将每个通知传递到1个新的独立线程或将通知按序传递给新线程的方式为周期性定时器生成通知)。成员<code>sigev_notify_attributes</code>可以指定为<code>NULL</code>或指向结构体<code>pthread_attr_t</code>的指针。成员<code>sigev_value</code>将作为传递给该函数的唯一参数。</p><p>　　● <code>SIGEV_THREAD_ID</code>与<code>SIGEV_SIGNAL</code>类似，但是信号会传递给线程ID为<code>sigev_notify_thread_id</code>的线程，该线程的进程ID必须匹配调用进程的进程ID (当使用<code>SIGEV_SIGNAL</code>通知时，信号会排队到进程。若进程有多个线程，则信号会传递给该进程的任意线程)。成员<code>sigev_notify_thread_id</code>可以设置为<code>clone()</code>或<code>gettid()</code>的返回值。该标志旨在供线程库使用 (需要线程实现使用选项<code>CLONE_THREAD</code>)。</p><p>　　SUSv3详细说明了前3个标志，第4个标志是特定于Linux。</p><p>　　参数<code>evp</code>可以指定为<code>NULL</code>，这等同于将成员<code>sigev_notify</code>指定为<code>SIGEV_SIGNAL</code>，成员<code>sigev_signo</code>指定为<code>SIGALRM</code> (其他系统可能有所不同，因为SUSv3仅要求指定为默认信号编号) 以及成员<code>sigev_value.sival_int</code>指定为定时器ID。</p><p>　　在当前的实现中，内核会为每个通过<code>timer_create()</code>创建的POSIX定时器预分配1个排队实时信号结构体，以保证至少有1个这样的结构体可用于定时器过期时排队信号。这表示可创建的POSIX定时器的数量受限于可以排队的实时信号的数量限制。</p><h4 id="timer_settime">23.6.2 <code>timer_settime()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_settime</span><span class="params">(<span class="type">timer_t</span> timerid, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> itimerspec *value,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> itimerspec *old_value)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">it_interval</span>;</span> <span class="comment">/* 周期性定时器的间隔 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">it_value</span>;</span>    <span class="comment">/* 第1次过期时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>timer_settime()</code>会启动或停止参数<code>timerid</code>指定的定时器 (之前通过<code>timer_create()</code>创建)。</p><p>　　参数<code>value</code>和<code>old_value</code>都是指向结构体<code>itimerspec</code>的指针，前者用于指定定时器的新设置，后者用于存储定时器的旧设置。</p><p>　　结构体<code>itimerspec</code>的成员<code>it_value</code>表示定时器的第1次过期时间。若成员<code>it_interval</code>的所有成员都是非0值，则定时器会周期性过期 (当第1次过期后，会按照该成员的值定期过期)。若成员<code>it_interval</code>的所有成员都是0，则定时器只会过期1次。</p><p>　　若参数<code>flags</code>指定为0，则<code>value.it_value</code>会被解释为相对于调用<code>timer_settime()</code>的时间的相对时间。若该参数指定为<code>TIMER_ABSTIME</code>，则<code>value.it_value</code>会被解释为绝对时间。若指定的绝对时间已经过去，则定时器会立即过期。</p><p>　　为了启动定时器，调用<code>timer_settime()</code>时需要将<code>value.it_value</code>的所有成员都指定为非0值。若该定时器已启动，则会覆盖设置。</p><p>　　若结构体<code>itimerspec</code>的成员值不是对应时钟精度的整数倍，则这些值会向上取整。</p><p>　　每次定时器过期时，进程会以通过<code>timer_create()</code>指定的方式收到通知。若成员<code>it_interval</code>包含非0值，则这些值会重新装载给成员<code>it_value</code>。</p><p>　　为了停止定时器，调用<code>timer_settime()</code>时需要将<code>value.it_value</code>的所有成员都指定为0。</p><h4 id="timer_gettime">23.6.3 <code>timer_gettime()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_gettime</span><span class="params">(<span class="type">timer_t</span> timerid, <span class="keyword">struct</span> itimerspec *curr_value)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>timer_settime()</code>会将参数<code>timerid</code>指定的定时器 (之前通过<code>timer_create()</code>创建) 的间隔和距离下一次过期的时间存储在参数<code>curr_value</code>指向的结构体<code>itimerspec</code>中。</p><p>　　若<code>curr_value.it_value</code>的成员都是0，则表示定时器处于停止状态。若<code>curr_value.it_interval</code>的成员都是0，则表示定时器只会过期1次。</p><h4 id="timer_delete">23.6.4 <code>timer_delete()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_delete</span><span class="params">(<span class="type">timer_t</span> timerid)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>timer_delete()</code>会删除参数<code>timerid</code>指定的定时器 (之前通过<code>timer_create()</code>创建)。若该定时器已启动，则会在删除前停止该定时器。若存在来自该定时器过期的待处理信号，则信号会保持待处理状态 (SUSv3没有说明这一点，所以有些UNIX实现可能有所不同)。</p><p>　　当进程终止时，相关的POSIX定时器会自动删除。</p><h4 id="定时器超限">23.6.5 定时器超限</h4><p>　　当选择信号作为定时器过期的通知时，定时器在对应的信号被接收或捕获前多次过期的情况称为<strong>定时器超限</strong> (因为进程在下一次被调度前需要等待一小段时间或信号被阻塞)。</p><p>　　即使将实时信号作为定时器过期的通知，定时器超限的问题也不能完全解决，因为排队的实时信号的数量存在上限。因此，POSIX.1b规定：当选择信号作为定时器过期的通知时，同一信号的多个实例<span style="background-color:#ff0">不会排队</span> (即使使用的是实时信号)。在收到信号后 (通过信号处理函数或<code>sigwaitinfo()</code>)，可以获取<strong>定时器超限计数</strong>，即定时器在信号被生成到信号被接收期间<span style="background-color:#ff0">额外</span>过期的次数 (例如，若定时器在此期间过期了3次，则超限计数为2)。当信号被接收后，对应的定时器的超限计数会重置。</p><p>　　除了使用结构体<code>siginfo_t()</code>的成员<code>si_overrun</code>来获取超限计数之外，还可以使用SUSv3详细说明的系统调用<code>timer_getoverrun()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timer_getoverrun</span><span class="params">(<span class="type">timer_t</span> timerid)</span>; <span class="comment">/* 成功时返回定时器的超限计数，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>timer_getoverrun()</code>会返回参数<code>timerid</code>指定的定时器的超限计数。该系统调用是异步信号安全的，所以可以在信号处理函数中调用该系统调用。</p><h4 id="通过信号通知">23.6.6 通过信号通知</h4><p>　　当选择信号作为定时器过期的通知时，可以通过信号处理函数、<code>sigwaitinfo()</code>或<code>sigtimedwait()</code>来接收信号。当调用<code>sigwaitinfo()</code>或<code>sigtimedwait()</code>来接收信号时，结构体<code>siginfo_t</code>的以下成员会被设置：</p><p>　　● <code>si_signo</code>会被设置为定时器过期时生成的信号。</p><p>　　● <code>si_code</code>会被设置为<code>SI_TIMER</code>。</p><p>　　● <code>si_value</code>会被设置为调用<code>timer_create()</code>时指定给<code>evp.sigev_value</code>的值 (可用于区分定时多个过期时生成同一信号的定时器)。</p><p>　　特定于Linux的结构体<code>siginfo_t</code>成员<code>si_timerid</code>会包含系统内部使用的定时器ID，但这个定时器ID不同于<code>timer_create()</code>返回的ID，所以该ID对应用程序没有用。</p><p>　　当调用<code>timer_create()</code>时，<code>evp.sigev_value.sival_ptr</code>通常赋值为指定给参数<code>timerid</code>的值 (或者包含该值的结构体) 的地址，以允许接收进程获取定时器的ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* itimerspec_from_str.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;itimerspec_from_str.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据字符串设置结构体itimerspec的成员</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param str 格式为it_value.tv_sec[/it_value.tv_nsec][:it_interval.tv_sec[/it_interval.tv_nsec]</span></span><br><span class="line"><span class="comment"> * @param tsp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">itimerspecFromStr</span><span class="params">(<span class="type">char</span> *str, <span class="keyword">struct</span> itimerspec *tsp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *cptr, *sptr;</span><br><span class="line"></span><br><span class="line">    cptr = <span class="built_in">strchr</span>(str, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *cptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sptr = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *sptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tsp-&gt;it_value.tv_sec = atoi(str);</span><br><span class="line">    tsp-&gt;it_value.tv_nsec = (sptr != <span class="literal">NULL</span>) ? atoi(sptr + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cptr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tsp-&gt;it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">        tsp-&gt;it_interval.tv_nsec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sptr = <span class="built_in">strchr</span>(cptr + <span class="number">1</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *sptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tsp-&gt;it_interval.tv_sec = atoi(cptr + <span class="number">1</span>);</span><br><span class="line">        tsp-&gt;it_interval.tv_nsec = (sptr != <span class="literal">NULL</span>) ? atoi(sptr + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ptmr_sigev_signal.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span>           <span class="comment">/* 函数currTime()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;itimerspec_from_str.h&quot;</span> <span class="comment">/* 函数itimerspecFromStr()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_SIG SIGRTMAX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数printf()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> * @param si</span></span><br><span class="line"><span class="comment"> * @param uc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *si, <span class="type">void</span> *uc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">timer_t</span> *tidptr;</span><br><span class="line"></span><br><span class="line">    tidptr = si-&gt;si_value.sival_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s] Got signal %d\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), sig);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    *sival_ptr = %ld\n&quot;</span>, (<span class="type">long</span>)*tidptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    timer_getoverrun() = %d\n&quot;</span>, timer_getoverrun(*tidptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sev</span>;</span></span><br><span class="line">    <span class="type">timer_t</span> *tidlist;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s secs[/nsecs][:int-secs[/int-nsecs]]...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tidlist = <span class="built_in">calloc</span>(argc - <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">timer_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (tidlist == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册信号处理函数 */</span></span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line">    sa.sa_sigaction = handler;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    <span class="keyword">if</span> (sigaction(TIMER_SIG, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为每个命令行参数创建POSIX定时器并启动 */</span></span><br><span class="line">    sev.sigev_notify = SIGEV_SIGNAL;</span><br><span class="line">    sev.sigev_signo = TIMER_SIG;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc - <span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        itimerspecFromStr(argv[j + <span class="number">1</span>], &amp;ts);</span><br><span class="line"></span><br><span class="line">        sev.sigev_value.sival_ptr = &amp;tidlist[j]; <span class="comment">/* 允许信号处理函数获取定时器ID */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer_create(CLOCK_REALTIME, &amp;sev, &amp;tidlist[j]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;timer_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Timer ID: %ld (%s)\n&quot;</span>, (<span class="type">long</span>)tidlist[j], argv[j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer_settime(tidlist[j], <span class="number">0</span>, &amp;ts, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;timer_settime&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待信号 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何将信号作为POSIX定时器过期的通知。该程序的命令行参数指定定时器的初始值和间隔。该程序会执行以下步骤：</p><p>　　1) 为作为定时器过期的通知的信号注册处理函数 (第49~55行)。</p><p>　　2) 为每个命令行参数创建POSIX定时器并启动 (第58~76行)。</p><p>　　3) 每次定时器过期时，<code>sev.sigev_signo</code>指定的信号会传递给进程。信号处理函数会打印对应的定时器的ID和超限计数值 (第18~27行)。</p><p>　　4) 循环调用<code>pause()</code>来等待定时器过期时生成的信号 (第79~82行)。</p><h4 id="通过线程通知">23.6.7 通过线程通知</h4><p>　　标志<code>SIGEV_THREAD</code>允许程序通过在1个单独的线程中调用函数的方式来接收定时器过期的通知。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ptmr_sigev_thread.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span>           <span class="comment">/* 函数currTime()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;itimerspec_from_str.h&quot;</span> <span class="comment">/* 函数itimerspecFromStr()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> expireCnt = <span class="number">0</span>; <span class="comment">/* 所有定时器的过期次数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线程通知函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">threadFunc</span><span class="params">(<span class="keyword">union</span> sigval sv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">timer_t</span> *tidptr;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    tidptr = sv.sival_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s] Thread notify\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    timer ID=%ld\n&quot;</span>, (<span class="type">long</span>)*tidptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    timer_getoverrun()=%d\n&quot;</span>, timer_getoverrun(*tidptr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 增加与主线程共享的计数器变量，并发送条件变量来通知主线程 */</span></span><br><span class="line">    s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    expireCnt += <span class="number">1</span> + timer_getoverrun(*tidptr);</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_cond_signal(&amp;cond);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_cond_signal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="type">timer_t</span> *tidlist;</span><br><span class="line">    <span class="type">int</span> s, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s secs[/nsecs][:int-secs[/int-nsecs]]...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tidlist = <span class="built_in">calloc</span>(argc - <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">timer_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (tidlist == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sev.sigev_notify = SIGEV_THREAD;</span><br><span class="line">    sev.sigev_notify_function = threadFunc;</span><br><span class="line">    sev.sigev_notify_attributes = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为每个命令行参数创建POSIX定时器并启动 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc - <span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        itimerspecFromStr(argv[j + <span class="number">1</span>], &amp;ts);</span><br><span class="line"></span><br><span class="line">        sev.sigev_value.sival_ptr = &amp;tidlist[j]; <span class="comment">/* 作为参数传递给threadFunc() */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer_create(CLOCK_REALTIME, &amp;sev, &amp;tidlist[j]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;timer_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Timer ID: %ld (%s)\n&quot;</span>, (<span class="type">long</span>)tidlist[j], argv[j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer_settime(tidlist[j], <span class="number">0</span>, &amp;ts, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;timer_settime&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主线程等待每次调用线程通知函数时都会发送的条件变量，并打印1条信息 */</span></span><br><span class="line">    s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pthread_cond_wait(&amp;cond, &amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_cond_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main(): expireCnt = %d\n&quot;</span>, expireCnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何将线程作为POSIX定时器过期的通知。该程序的命令行参数与<code>ptmr_sigev_signal</code>的相同。该程序会执行以下步骤：</p><p>　　1) 为每个命令行参数创建POSIX定时器并启动。每次定时器过期时，<code>sev.sigev_notify_function</code>指定的函数都会在1个单独的线程中被调用。当该函数被调用时，<code>sev.sigev_value.sival_ptr</code>指定的值会作为参数，这里将其赋值为定时器ID的地址 (第75~91行)。</p><p>　　2) 主线程通过循环来等待定时器过期，每次循环时会调用<code>pthread_cond_wait()</code>来等待由处理定时器通知的线程发送的条件变量<code>cond</code> (第100~108行)。</p><p>　　3) 每次定时器过期时会调用函数<code>threadFunc()</code>。在打印信息后，该函数会增加全局变量<code>expireCnt</code>，并发送条件变量<code>cond</code>给主线程来作为定时器过期的通知 (第19~50行)。</p><h3 id="timerfd-api">23.7 timerfd API</h3><p>　　Linux从内核2.6.25开始提供特定于Linux的timerfd API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">timerfd_create</span><span class="params">(<span class="type">int</span> clockid, <span class="type">int</span> flags)</span>; <span class="comment">/* 成功时返回文件描述符，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">timerfd_settime</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> itimerspec *new_value,</span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> itimerspec *old_value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">timerfd_gettime</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> itimerspec *curr_value)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>timerfd_create()</code>会创建1个定时器，并返回引用该定时器的文件描述符。参数<code>clockid</code>可以指定为<code>CLOCK_REALTIME</code>或<code>CLOCK_MONOTONIC</code>。</p><p>　　在<code>timerfd_create()</code>的最初实现中，参数<code>flags</code>只能指定0。直到Linux 2.6.27，该参数才支持以下2个标志：</p><p>　　● <code>TFD_CLOEXEC</code>表示启用新文件描述符的close-on-exec标志 (<code>FD_CLOEXEC</code>)。</p><p>　　● <code>TFD_NONBLOCK</code>表示启用底层文件描述符的标志<code>O_NONBLOCK</code>。</p><p>　　当不再需要通过<code>timerfd_create()</code>创建的文件描述符时，应该通过<code>close()</code>来关闭该文件描述符，以释放该文件描述符引用的定时器的相关资源。</p><p>　　系统调用<code>timerfd_settime()</code>会启动或停止参数<code>fd</code>引用的定时器。参数<code>flags</code>、<code>new_value</code>和<code>old_value</code>的用法与对应的<code>timer_settime()</code>参数的相同。</p><p>　　与<code>timer_gettime()</code>类似，系统调用<code>timerfd_gettime()</code>会将参数<code>fd</code>引用的定时器的间隔和距离下一次过期的时间存储在参数<code>curr_value</code>指向的结构体<code>itimerspec</code>中。</p><p>　　通过<code>timerfd_create()</code>创建的文件描述符可以被通过<code>fork()</code>创建的子进程继承，并且这些文件描述符引用的是同一定时器，所以子进程也可以从该文件描述符中读取定时器过期的通知。</p><p>　　通过<code>timerfd_create()</code>创建的文件描述符在<code>exec()</code>期间会被保留 (除非启用了该文件描述符的close-on-exec标志)，并且已启动的定时器在此期间会正常过期。</p><p>　　当定时器启动后，可以对引用该定时器的文件描述符调用<code>read()</code>来获取定时器的过期信息。为此，提供给<code>read()</code>的缓冲区必须能够容纳至少1个无符号64位整数 (<code>uint64_t</code>)。若自上一次<code>timerfd_settime()</code>修改定时器或调用<code>read()</code>以来定时器过期了至少1次，则<code>read()</code>会立即返回，并且缓冲区会包含过期次数。若定时器不曾过期，则<code>read()</code>会阻塞，直到定时器过期。在这种情况下，若启用了该文件描述符的标志<code>O_NONBLOCK</code>，则<code>read()</code>不会阻塞，但会导致错误<code>EAGAIN</code>。</p><p>　　通过<code>timerfd_create()</code>创建的文件描述可以通过<code>select()</code>、<code>poll()</code>和epoll监控。当文件描述符引用的定时器过期时，文件描述符会变为可读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* demo_timerfd.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;itimerspec_from_str.h&quot;</span> <span class="comment">/* 函数itimerspecFromStr()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">now</span>;</span></span><br><span class="line">    <span class="type">int</span> maxExp, fd, secs, nanosecs;</span><br><span class="line">    <span class="type">uint64_t</span> numExp, totalExp;</span><br><span class="line">    <span class="type">ssize_t</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s secs[/nsecs][:int-secs[/int-nsecs]] [max-exp]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    itimerspecFromStr(argv[<span class="number">1</span>], &amp;ts);</span><br><span class="line">    maxExp = (argc &gt; <span class="number">2</span>) ? getInt(argv[<span class="number">2</span>], GN_GT_0, <span class="string">&quot;max-exp&quot;</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    fd = timerfd_create(CLOCK_REALTIME, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;timerfd_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timerfd_settime(fd, <span class="number">0</span>, &amp;ts, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;timerfd_settime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clock_gettime(CLOCK_MONOTONIC, &amp;start) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;clock_gettime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (totalExp = <span class="number">0</span>; totalExp &lt; maxExp;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 读取定时器的过期次数，并打印自定时器启动以来的时间、读取的过期次数和总过期次数 */</span></span><br><span class="line">        s = read(fd, &amp;numExp, <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        totalExp += numExp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clock_gettime(CLOCK_MONOTONIC, &amp;now) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;clock_gettime&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        secs = now.tv_sec - start.tv_sec;</span><br><span class="line">        nanosecs = now.tv_nsec - start.tv_nsec;</span><br><span class="line">        <span class="keyword">if</span> (nanosecs &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            secs--;</span><br><span class="line">            nanosecs += <span class="number">1000000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d.%03d: expirations read: %llu; total=%llu\n&quot;</span>, secs, (nanosecs + <span class="number">500000</span>) / <span class="number">1000000</span>,</span><br><span class="line">               (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)numExp, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)totalExp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了timerfd API的用法。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_22/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第22章 信号：高级特性"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第22章 信号：高级特性</a></div><div class="post-nav-item"><a href="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_03/" rel="next" title="《ARM Cortex-M3与Cortex-M4权威指南 第3版》第3章 技术综述">《ARM Cortex-M3与Cortex-M4权威指南 第3版》第3章 技术综述 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>