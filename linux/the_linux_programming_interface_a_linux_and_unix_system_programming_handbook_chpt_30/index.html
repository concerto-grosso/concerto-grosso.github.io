<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_30/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_30/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_30/","title":"《Linux/UNIX系统编程手册》第30章 线程：线程同步"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第30章 线程：线程同步 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">30.1 互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%AE%9A%E5%92%8C%E8%A7%A3%E9%94%81%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">30.1.1 锁定和解锁互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-text">30.1.2 互斥锁的性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E6%AD%BB%E9%94%81"><span class="nav-text">30.1.3 互斥锁死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">30.1.4 动态初始化互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%80%E6%AF%81%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">30.1.5 销毁互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="nav-text">30.1.6 互斥锁类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-text">30.2 条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92"><span class="nav-text">30.2.1 等待和唤醒</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E8%B0%93%E8%AF%8D"><span class="nav-text">30.2.2 判断条件变量的谓词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-text">30.2.3 动态初始化条件变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%80%E6%AF%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-text">30.2.4 销毁条件变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-text">30.2.5 示例程序</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_30/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第30章 线程：线程同步 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第30章 线程：线程同步</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-07-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-07-28T00:00:00+08:00">2025-07-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-07-29 00:00:00" itemprop="dateModified" datetime="2025-07-29T00:00:00+08:00">2025-07-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>17k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　线程的主要优势之一就是能够通过全局变量共享信息。但是，这种共享信息的方式是有代价的：必须保证不能有多个线程同时修改同一变量，并且线程不能读取其他线程正在修改的变量。</p><p>　　术语<strong>临界区</strong>是指访问共享资源且应具有代码原子性的代码段 (其执行不应该被访问同一资源的其他线程干扰)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* thread_incr.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> glob = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 循环arg次，每次循环会将glob加1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arg</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> loops = *((<span class="type">int</span> *)arg);</span><br><span class="line">    <span class="type">int</span> loc, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; loops; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        loc = glob;</span><br><span class="line">        loc++;</span><br><span class="line">        glob = loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="type">int</span> loops, s;</span><br><span class="line"></span><br><span class="line">    loops = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;num-loops&quot;</span>) : <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = pthread_create(&amp;t2, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;glob = %d\n&quot;</span>, glob);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了不以原子方式访问共享资源时可能出现的问题。该程序会创建2个线程，这2个线程都会执行同一函数，该函数将全局变量<code>glob</code>复制给局部变量<code>loc</code>，然后将<code>loc</code>加1并复制回<code>glob</code>。</p><span id="more"></span> <img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_30/two_threads_incrementing_a_global_variable_without_synchronization.svg"><p>　　上图展示了程序<code>thread_incr</code>的问题。</p><p>　　1) 线程1将<code>glob</code>的当前值复制给<code>loc</code>，这里假设其值为2000。</p><p>　　2) 线程1的调度程序时间片到期，线程2开始执行。</p><p>　　3) 线程2会循环将<code>glob</code>的当前值复制给<code>loc</code>，假设第1次循环时<code>glob</code>的值是2000。当线程2的调度程序时间片到期后，<code>glob</code>增加到3000。</p><p>　　4) 线程2的调度程序时间片到期，线程1从停止的位置恢复执行。由于<code>loc</code>的值为2000，所以会将其加1 (得到2001) 并复制回<code>glob</code>，这无效化了线程2的增加操作。</p><p>　　这种不确定性行为是内核CPU调度决策变化的结果。</p><p>　　将函数<code>threadFunc()</code>的循环中的增加<code>glob</code>的3条语句替换为<code>glob++;</code>看似可以解决问题。但是，对于很多硬件架构 (例如，RISC架构)，编译器会将这条语句转换为等同于这3条语句的机器代码 (自增操作符可能不是原子的)。</p><p>　　为了避免这一问题，必须要使用<strong>互斥锁</strong>来保证同时只能有1个线程访问共享变量。实际上，互斥锁也能用于确保对任何共享资源的原子访问，但保护共享变量是最常见的用法。</p><p>　　互斥锁有2个状态：<strong>加锁</strong>和<strong>解锁</strong>。在任何时刻，最多只能有1个线程持有互斥锁。试图对已锁定的互斥锁加锁会导致阻塞或出错 (取决于加锁的方法)。</p><p>　　当线程锁定互斥锁时，它会成为互斥锁的所有者，互斥锁只能由其所有者解锁。该特性改善了使用互斥锁的代码结构，并且还允许在互斥锁的实现中使用一些优化。由于这个所有权特性，术语<span style="background-color:#ff0">获取</span>和<span style="background-color:#ff0">释放</span>有时等同于加锁和解锁。</p><p>　　通常，每个共享资源会使用不同的互斥锁，并且每个线程使用以下协议来访问资源：</p><p>　　● 对共享资源加锁。</p><p>　　● 访问资源。</p><p>　　● 解锁。</p><p>　　当多个线程试图执行临界区时，只能有1个线程持有互斥锁 (其他线程会被阻塞)，所以只能有1个线程进入临界区。</p><h3 id="互斥锁">30.1 互斥锁</h3><p>　　互斥锁可以被分配为静态变量，也可以在运行时被动态创建。</p><p>　　互斥锁是<code>pthread_mutex_t</code>类型的变量，在使用之前必须先将其初始化。对于静态分配的互斥锁，可以通过将其赋值为<code>PTHREAD_MUTEX_INITIALIZER</code>来初始化。</p><h4 id="锁定和解锁互斥锁">30.1.1 锁定和解锁互斥锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>pthread_mutex_lock()</code>会锁定参数<code>mutex</code>指定的互斥锁。若互斥锁当前未被锁定，则该调用会锁定互斥锁并立即返回。若互斥锁当前已被其他线程锁定，则该调用会阻塞，直到互斥锁被解锁，此时，它会立即锁定互斥锁并返回。</p><p>　　当调用线程已经持有指定给<code>pthread_mutex_lock()</code>的互斥锁时，对于默认类型的互斥锁，可能会导致线程阻塞在试图锁定已持有的互斥锁或调用失败并返回<code>EDEADLK</code> (取决于实现)。对于Linux，这种情况会导致线程阻塞在锁定已持有的互斥锁。</p><p>　　函数<code>pthread_mutex_unlock()</code>会解锁参数<code>mutex</code>指定的互斥锁。若互斥锁当前未被锁定或互斥锁已由其他线程锁定，则会返回错误。</p><p>　　若多个线程正在等待获取<code>pthread_mutex_unlock()</code>解锁的互斥锁，则成功获取该互斥锁的线程是不确定的。</p><p>　　此外，Pthreads API还提供了函数<code>pthread_mutex_trylock()</code>和<code>pthread_mutex_timedlock()</code>，这2个函数都是<code>pthread_mutex_lock()</code>的变体。</p><p>　　● <code>pthread_mutex_trylock()</code>与<code>pthread_mutex_lock()</code>相似，不同之处在于当互斥锁当前已被锁定时，该函数会返回错误<code>EBUSY</code>。</p><p>　　● <code>pthread_mutex_timedlock()</code>与<code>pthread_mutex_lock()</code>相似，不同之处在于该函数还提供了参数<code>abstime</code>，该参数对线程在等待获取互斥锁时睡眠的时间施加了限制。若该参数指定的时间内调用者仍未成为互斥锁的所有者，则该函数会返回错误<code>ETIMEDOUT</code>。</p><p>　　<code>pthread_mutex_trylock()</code>和<code>pthread_mutex_timedlock()</code>的使用频率较低。对于设计良好的应用程序，线程应该只会在短期内持有互斥锁，以便其他线程的并发执行不会受到影响。这保证了其他被互斥锁阻塞的线程可以很快地获取该互斥锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* thread_incr_mutex.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> glob = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 循环arg次，每次循环会将glob加1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arg</span></span><br><span class="line"><span class="comment"> * @return void*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> loops = *((<span class="type">int</span> *)arg);</span><br><span class="line">    <span class="type">int</span> loc, j, s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; loops; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        loc = glob;</span><br><span class="line">        loc++;</span><br><span class="line">        glob = loc;</span><br><span class="line"></span><br><span class="line">        s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="type">int</span> loops, s;</span><br><span class="line"></span><br><span class="line">    loops = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;num-loops&quot;</span>) : <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = pthread_create(&amp;t2, <span class="literal">NULL</span>, threadFunc, &amp;loops);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;glob = %d\n&quot;</span>, glob);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例是<code>thread_incr.c</code>的修改版，这里使用了互斥锁来保护对全局变量<code>glob</code>的访问。</p><h4 id="互斥锁的性能">30.1.2 互斥锁的性能</h4><p>　　当在运行Linux (带有NPTL) 的x86-32系统上运行<code>thread_incr.c</code>和<code>thread_incr_mutex.c</code>时，前者在每个线程中执行1000万次循环共需要0.35秒 (并产生错误的结果)，后者则需要3.1秒。互斥锁看似成本很高，但对比两者的时间可以得出，在<code>threadFunc()</code>的<code>for</code>循环中，加锁和解锁的总耗时略低于其他操作的10倍，这样的成本相对较小。此外，线程通常会使用更多的时间来执行其他操作，并且执行相对较少的加锁和解锁操作。因此，对于大多数应用程序，使用互斥锁的性能影响并不显著。</p><p>　　为了进一步体现互斥锁的性能，在同一系统上运行一些简单的测试程序，结果表明，使用<code>fcntl()</code>对文件区域进行2000万次加锁和解锁的循环需要44秒，而对System V信号量进行2000万次增减循环则需要28秒。文件锁和信号量的问题在于始终需要通过系统调用来执行加锁和解锁操作，虽然每次系统调用的成本虽然较小，但也不能忽略。相比之下，互斥锁是使用原子机器语言操作 (在所有线程可见的内存位置上执行) 实现的，并且仅在发生锁竞争时才需要系统调用。</p><p>　　对于Linux，互斥锁被实现为基于futex (fast user space mutex的缩写)，锁竞争则通过系统调用<code>futex()</code>来处理。</p><h4 id="互斥锁死锁">30.1.3 互斥锁死锁</h4><p>　　有时，线程需要同时访问多个不同的共享资源，每个共享资源由不同的互斥锁控制。当多个线程同时锁定同一组互斥锁时，可能会导致<strong>死锁</strong>。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_30/a_deadlock_when_two_threads_lock_two_mutexes.svg"><p>　　如图所示，2个线程都成功地获取了1个互斥锁，并且都试图锁定已由对方锁定的互斥锁。最终，2个线程都会无限阻塞。</p><p>　　避免死锁最简单的方法就是定义互斥锁层次结构。当多个线程能够锁定同一组互斥锁时，它们应该应该以相同的顺序锁定互斥锁。</p><p>　　另一种不太常用的策略是 "尝试，然后退回"。对于这种策略，线程使用<code>pthread_mutex_lock()</code>获取第1个互斥锁，然后通过<code>pthread_mutex_trylock()</code>获取其他互斥锁，若任一<code>pthread_mutex_trylock()</code>调用返回错误<code>EBUSY</code>，则释放所有互斥锁，然后再次尝试 (可能会等待一段时间)。这种方法的效率低于互斥锁层次结构，但更灵活。</p><h4 id="动态初始化互斥锁">30.1.4 动态初始化互斥锁</h4><p>　　静态初始化值<code>PTHREAD_MUTEX_INITIALIZER</code>只能用于初始化具有默认属性的静态分配互斥锁。对于其他情况，必须通过<code>pthread_mutex_init()</code>来动态初始化互斥锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　参数<code>mutex</code>用于指定待初始化的互斥锁。参数<code>attr</code>指向<code>pthread_mutexattr_t</code>对象，用于定义互斥锁的属性 (之前以被初始化)。若<code>attr</code>为<code>NULL</code>，则将使用默认属性来初始化互斥锁。</p><p>　　SUSv3规定，初始化已初始化的互斥锁会导致未定义的行为。</p><p>　　以下情况必须使用<code>pthread_mutex_init()</code>来动态初始化互斥锁：</p><p>　　● 互斥锁被动态分配在堆中 (例如，动态分配的结构体链表，并且链表中的所有结构体都包含用于保护对结构体的访问的成员<code>pthread_mutex_t</code>)。</p><p>　　● 互斥锁是被分配在栈中的自动变量。</p><p>　　● 需要使用默认属性以外的属性来初始静态分配的互斥锁。</p><h4 id="销毁互斥锁">30.1.5 销毁互斥锁</h4><p>　　当自动或动态分配的互斥锁不再需要时，应该调用<code>pthread_mutex_destroy()</code>来将其销毁 (无需调用该函数来销毁通过<code>PTHREAD_MUTEX_INITIALIZER</code>静态初始化的互斥锁)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　只有互斥锁未被锁定，并且随后不会有线程试图锁定它时，销毁互斥锁才是安全的。若互斥锁位于动态分配的内存区域，则在销毁该互斥锁前应先释放该内存区域。自动分配的互斥锁应该在其所在的函数返回前被销毁。</p><p>　　当互斥锁被<code>pthread_mutex_destroy()</code>销毁后，可以通过<code>pthread_mutex_destroy()</code>将其重新初始化。</p><h4 id="互斥锁类型">30.1.6 互斥锁类型</h4><p>　　在之前的内容中，对互斥锁的行为做出了以下陈述：</p><p>　　● 1个线程不能多次锁定同一互斥锁。</p><p>　　● 线程不能解锁未持有的互斥锁 (即不是由它锁定的互斥锁)。</p><p>　　● 线程不能解锁未被锁定的互斥锁。</p><p>　　对于这些情况，具体行为取决于互斥锁的类型。SUSv3定义了以下互斥锁类型：</p><p>　　● <code>PTHREAD_MUTEX_NORMAL</code>互斥锁不提供死锁检测。对于该类型的互斥锁，若线程试图锁定当前已被锁定的互斥锁，则会导致死锁。解锁未被锁定或未持有的互斥锁会导致未定义的结果 (对于Linux，对该类型的互斥锁执行这2种操作不会出错)。</p><p>　　● <code>PTHREAD_MUTEX_ERRORCHECK</code>互斥锁会对所有操作进行错误检查。上述3种情况对都会导致Pthreads相关函数返回错误。该类型的互斥锁通常比普通互斥锁更慢，但可以作为调试工具来检查应用程序在哪里违反了互斥锁的使用规则。</p><p>　　● <code>PTHREAD_MUTEX_RECURSIVE</code>互斥锁是递归互斥锁，它会维护锁计数的概念。同一线程可以多次锁定该类型的互斥锁。当线程第1次获取递归互斥锁时，锁计数会被设置为1，该线程的每次后续的锁定操都会增加锁计数。当且仅当锁计数为0时，才会释放对应的递归互斥锁 (即其他线程才能获取该递归互斥锁)。解锁未被锁定或未持有的递归互斥锁会返回错误。</p><p>　　Linux线程实现为这3种互斥锁类型提供了非标准的静态初始化值，所以无需使用<code>pthread_mutex_init()</code>来初始化静态分配的这些类型的互斥锁。但是，可移植应用程序应该避免使用这些静态初始化值。</p><p>　　除了这3种类型的互斥锁，SUSv3还定义了<code>PTHREAD_MUTEX_DEFAULT</code>互斥锁，即默认互斥锁。对于上述3种情况，该类型的互斥锁的行为都是故意未定义的，这为其实现提供了最大的灵活性。对于Linux，该类型的互斥锁的行为如同<code>PTHREAD_MUTEX_NORMAL</code>互斥锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mtx;</span><br><span class="line"><span class="type">pthread_mutexattr_t</span> mtxAttr;</span><br><span class="line"><span class="type">int</span> s, type;</span><br><span class="line"></span><br><span class="line">s = pthread_mutexattr_init(&amp;mtxAttr);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutexattr_init&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = pthread_mutexattr_settype(&amp;mtxAttr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutexattr_settype&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = pthread_mutex_init(mtx, &amp;mtxAttr);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_init&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = pthread_mutexattr_destroy(&amp;mtxAttr); <span class="comment">/* 不再需要mtxAttr */</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutexattr_destroy&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何将互斥锁的类型设置为<code>PTHREAD_MUTEX_ERRORCHECK</code>。</p><h3 id="条件变量">30.2 条件变量</h3><p>　　互斥锁可用于防止多个线程同时访问共享变量。条件变量允许线程通知其他线程共享变量状态变化的信息，并允许其他线程等待 (阻塞) 此类通知。</p><p>　　1个不使用条件变量的简单示例就可以说明条件变量为何有用。假设存在多个会产生供主线程消费的 "结果单元" 的生产者线程，并且会使用互斥锁保护的变量<code>avail</code>来表示待消费的单元的数量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> avail = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>　　生产者线程包含以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 产生1个单元的代码 */</span></span><br><span class="line"></span><br><span class="line">s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avail++; <span class="comment">/* 待消费的单元加1 */</span></span><br><span class="line"></span><br><span class="line">s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　主 (消费者) 线程包含以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">    s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 消耗所有待消耗的单元 */</span></span><br><span class="line">    <span class="keyword">while</span> (avail &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 执行一些操作 */</span></span><br><span class="line">        avail--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段代码可以正常运行，但它会浪费CPU时间，因为主线程会在无限循环中检查变量<code>avail</code>的状态。<strong>条件变量</strong>正好解决了这一问题，它允许线程睡眠 (等待)，直到其他线程通知该线程必须执行某些操作 (即出现了某个 "条件"，睡眠线程必须立即响应)。</p><p>　　条件变量总是会与互斥锁一起使用。互斥锁为访问共享变量提供了互斥，而条件变量用于指示变量状态的变化。</p><p>　　与互斥锁相同，条件变量可以被静态或动态分配。</p><p>　　条件变量的数据类型是<code>pthread_cond_t</code>。与互斥锁相同，使用条件变量前必须先将其初始化。对于静态分配的条件变量，可以通过将其赋值为<code>PTHREAD_COND_INITIALIZER</code>来初始化。</p><h4 id="等待和唤醒">30.2.1 等待和唤醒</h4><p>　　条件变量的主要操作是<strong>唤醒</strong>和<strong>等待</strong>。唤醒操作是向等待线程发送共享变量已发生变化的通知，等待操作是阻塞直到收到此类通知的方式。</p><p>　　条件变量不存储状态信息，它只是1种用于传递应用程序状态信息的机制。若执行唤醒操作时没有线程在等待对应的条件变量，则通知会被丢弃。随后等待条件变量的线程只会在下一次执行唤醒操作时解除阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>pthread_cond_signal()</code>和<code>pthread_cond_broadcast()</code>都会发送参数<code>cond</code>指定的条件变量的状态变化的通知 (即唤醒操作)。函数<code>pthread_cond_wait()</code>会阻塞线程，直到收到参数<code>cond</code>指定的条件变量的状态变化的通知 (即等待操作)。</p><p>　　函数<code>pthread_cond_timedwait()</code>与<code>pthread_cond_wait()</code>相似，但可以通过参数<code>abstime</code>来指定等待操作的时间上限。该参数指向结构体<code>abstime</code> (见23.4)，指定自纪元以来以秒和纳秒表示的绝对时间。若该参数的指定的时间过期后线程未被唤醒，则<code>pthread_cond_timedwait()</code>会返回错误<code>ETIMEDOUT</code>。</p><p>　　当多个线程都阻塞在对同一条件变量调用<code>pthread_cond_wait()</code>时，<code>pthread_cond_signal()</code>会保证唤醒至少1个阻塞线程，而<code>pthread_cond_broadcast()</code>会唤醒所有阻塞线程。</p><p>　　使用<code>pthread_cond_broadcast()</code>总能得到正确的结果 (因为所有线程都应该被设计为处理冗余和虚假唤醒)，但<code>pthread_cond_signal()</code>可能更高效。但是，当仅需要唤醒任一等待线程来处理共享变量的状态变化，并且唤醒哪一个线程不重要时，才应该使用<code>pthread_cond_signal()</code>。这种场景通常适用于所有等待线程都被设计为执行同一任务。基于这些假设，<code>pthread_cond_signal()</code>可能比<code>pthread_cond_broadcast()</code>更高效，因为它避免了以下可能情况：</p><p>　　1) 唤醒所有等待线程。</p><p>　　2) 首先调度1个线程，该线程会检查共享变量的状态 (受到相关互斥锁的保护)，发现有工作待完成。该线程完成工作，更改共享变量的状态以指示工作已完成，并解锁相关互斥锁。</p><p>　　3) 剩余的每个线程轮流锁定互斥锁，并检查共享变量的状态。但是，由于第1个线程做出的修改，这些线程会发现没有工作可做，所以会解锁互斥锁并继续睡眠 (即再次调用<code>pthread_cond_wait()</code>)。</p><p>　　相比之下，<code>pthread_cond_broadcast()</code>适用于等待线程被设计为执行不同任务的情况 (在这种情况下，这些线程可能包含与条件变量相关的不同谓词)。</p><p>　　为了将条件变量应用于本小节开头的示例，可以将全局变量以及相关的互斥锁和条件变量声明为以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> avail = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>　　生产者线程的代码将加入调用<code>pthread_cond_signal()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avail++; <span class="comment">/* 让消费者知道可供消耗的单元的数量加1 */</span></span><br><span class="line"></span><br><span class="line">s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = pthread_cond_signal(&amp;cond); <span class="comment">/* 唤醒睡眠的消费者 */</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_cond_signal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　实际上，这里可用先调用<code>pthread_cond_signal()</code>再调用<code>pthread_mutex_unlock()</code>。SUSv3允许以任意顺序调用这2个函数。</p><p>　　在考虑消费者线程的代码时，这里会先详细介绍<code>pthread_cond_wait()</code>的行为。条件变量总是有1个与之关联的互斥锁，这2个对象会作为参数传递给<code>pthread_cond_wait()</code>，该函数会执行以下步骤：</p><p>　　● 解锁<code>mutex</code>指定的互斥锁。</p><p>　　● 执行等待操作。</p><p>　　● 锁定<code>mutex</code>。</p><p>　　<code>pthread_cond_wait()</code>被设计为执行以上步骤是因为访问共享变量的方式通常如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/* 判断共享变量是否处于预期状态 */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;mtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 共享变量已处于预期状态，执行合适的操作 */</span></span><br><span class="line"></span><br><span class="line">s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于以上代码，对共享变量的访问必须由互斥锁保护，即条件变量与互斥锁之间有天然的联系：</p><p>　　1) 线程会在检查共享变量的状态之前锁定互斥锁。</p><p>　　2) 判断共享变量的状态。</p><p>　　3) 若共享变量不处于预期状态，则线程在进入等待操作前必须先解锁互斥锁 (以便其他线程可以访问共享变量)。</p><p>　　4) 当线程被唤醒后，互斥锁会再次被锁定，因为线程通常会立即访问共享变量。</p><p>　　<code>pthread_cond_wait()</code>会自动执行最后2步中的解锁和加锁操作。在第3步中，解锁互斥锁和阻塞在条件变量是以原子方式执行的，所以其他线程无法在调用<code>pthread_cond_wait()</code>的线程阻塞在条件变量前获取互斥锁和执行唤醒操作。</p><p>　　因此，所有同时等待条件变量的线程必须在<code>pthread_cond_wait()</code>或<code>pthread_cond_timedwait()</code>调用中指定同一互斥锁。实际上，在<code>pthread_cond_wait()</code>调用期间，条件变量会动态地绑定到唯一的互斥锁。SUSv3指出，若对同一条件变量同时进行多个<code>pthread_cond_wait()</code>调用，并且指定不同的互斥锁，则结果是未定义的。</p><p>　　根据以上细节，可以对主 (消费者) 线程进行适当的修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">    s = pthread_mutex_lock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待生产者消除生产单元 */</span></span><br><span class="line">    <span class="keyword">while</span> (avail == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pthread_cond_wait(&amp;cond, &amp;mtx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_cond_wait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 消费所有可用的单元 */</span></span><br><span class="line">    <span class="keyword">while</span> (avail &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 消费1个单元 */</span></span><br><span class="line">        avail--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行一些不需要互斥锁的操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　David Butenhof的《Programming with POSIX Threads》指出，对于某些实现，生产者线程先解锁互斥锁再执行唤醒操作可能比以相反的顺序执行这些操作更具性能优势。若生产者线程先执行唤醒操作再解锁互斥锁，则在唤醒消费者线程后互斥锁仍然被锁定，消费者线程会立即再次执行等待操作，这会导致2次多余的上下文切换。有些实现通过wait morphing技术来解决这个问题，该技术会在互斥锁被锁定且不进行上下文切换的情况下，将被唤醒的线程从条件变量等待队列移动到互斥锁等待队列。</p><h4 id="判断条件变量的谓词">30.2.2 判断条件变量的谓词</h4><p>　　每个条件变量都有1个关联的谓词，该谓词涉及若干个共享变量。在上一小节中的示例中，与<code>cond</code>关联的谓词是<code>(avail == 0)</code>。这段代码展示了1个通用设计原则：<code>pthread_cond_wait()</code>调用必须由<code>while</code>语句控制 (而非<code>if</code>语句)。这也是因为从<code>pthread_cond_wait()</code>返回时没有任何关于谓词状态的保证。因此，应该立即重新检查谓词，若它不处于预期状态，则继续睡眠。</p><p>　　不能对<code>pthread_cond_wait()</code>返回时的谓词状态做出假设的原因如下：</p><p>　　● <span style="background-color:#ff0">其他线程可能更早被唤醒</span>。可能存在多个线程等待获取与条件变量关联的互斥锁。即使执行唤醒操作的线程将谓词设置为预期状态，其他线程可能更早获取互斥锁并修改相关共享变量的状态，从而更改谓词的状态。</p><p>　　● <span style="background-color:#ff0">"宽松" 谓词的设计可能更易于实现</span>。有时，将应用程序设计为与基于表示可能性 (而非确定性) 的条件变量更容易，即唤醒操作发送的通知表示 "可能需要做一些事情" (而非 "做一些事情")。通过这种方法，条件变量的唤醒操作可以基于预期谓词状态的疑似状态，被唤醒的线程可以通过重新检查谓词状态来确定是否真的有事情要做。</p><p>　　● <span style="background-color:#ff0">可能发生虚假唤醒</span>。对于某些实现，执行等待操作的线程可能在没有线程执行唤醒的操作的情况下被唤醒。这种虚假唤醒是某些多处理器系统高效实现所需技术的 (罕见) 结果，并被SUSv3明确允许。</p><h4 id="动态初始化条件变量">30.2.3 动态初始化条件变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>pthread_cond_init()</code>会动态初始化参数<code>cond</code>指定的条件变量。与互斥锁相同，可以通过参数<code>attr</code> (之前已被初始化) 来在初始化时设置条件变量的属性。若<code>attr</code>为<code>NULL</code>，则会将使用默认属性来初始化条件变量。</p><p>　　SUSv3指出，初始化已初始化的条件变量的结果是未定义的。</p><h4 id="销毁条件变量">30.2.4 销毁条件变量</h4><p>　　当自动或动态分配的条件变量不再需要时，应该通过<code>pthread_cond_destroy()</code>将其销毁 (无需调用该函数来销毁通过<code>PTHREAD_COND_INITIALIZER</code>静态初始化的条件变量)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　当没有线程等待条件变量时，销毁该条件变量才是安全的。若条件变量位于动态分配的内存区域，则在销毁该条件变量前应先释放该内存区域。自动分配的条件变量应该在其所在的函数返回前被销毁。</p><p>　　当条件变量被<code>pthread_cond_destroy()</code>销毁后，可以通过<code>pthread_cond_init()</code>将其重新初始化。</p><h4 id="示例程序">30.2.5 示例程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* thread_multijoin.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> threadDied = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> threadMutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保护以下全局变量 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> totThreads = <span class="number">0</span>;  <span class="comment">/* 创建的线程的总数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numLive = <span class="number">0</span>;     <span class="comment">/* 未被合并的线程的总数 (无论是否终止) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numUnjoined = <span class="number">0</span>; <span class="comment">/* 未被合并的终止的线程的总数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程状态 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TS_ALIVE,      <span class="comment">/* 线程未终止 */</span></span><br><span class="line">    TS_TERMINATED, <span class="comment">/* 线程已终止，但未被合并 */</span></span><br><span class="line">    TS_JOINED      <span class="comment">/* 线程已终止，并且已被合并 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程的相关信息 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;     <span class="comment">/* 线程ID */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">tstate</span> <span class="title">state</span>;</span> <span class="comment">/* 线程状态 (TS_*常量) */</span></span><br><span class="line">    <span class="type">int</span> sleepTime;     <span class="comment">/* 线程在终止之前存活的秒数 */</span></span><br><span class="line">&#125; *thread;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx = *((<span class="type">int</span> *)arg);</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    sleep(thread[idx].sleepTime); <span class="comment">/* 模拟执行一些操作 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %d terminating\n&quot;</span>, idx);</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_lock(&amp;threadMutex);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numUnjoined++;</span><br><span class="line">    thread[idx].state = TS_TERMINATED;</span><br><span class="line"></span><br><span class="line">    s = pthread_mutex_unlock(&amp;threadMutex);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_cond_signal(&amp;threadDied);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_cond_signal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s, idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s nsecs...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread = <span class="built_in">calloc</span>(argc - <span class="number">1</span>, <span class="keyword">sizeof</span>(*thread));</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建线程 */</span></span><br><span class="line">    <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; argc - <span class="number">1</span>; idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        thread[idx].sleepTime = getInt(argv[idx + <span class="number">1</span>], GN_NONNEG, <span class="literal">NULL</span>);</span><br><span class="line">        thread[idx].state = TS_ALIVE;</span><br><span class="line">        s = pthread_create(&amp;thread[idx].tid, <span class="literal">NULL</span>, threadFunc, &amp;idx);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totThreads = argc - <span class="number">1</span>;</span><br><span class="line">    numLive = totThreads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 合并终止的线程 */</span></span><br><span class="line">    <span class="keyword">while</span> (numLive &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = pthread_mutex_lock(&amp;threadMutex);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_lock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (numUnjoined == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = pthread_cond_wait(&amp;threadDied, &amp;threadMutex);</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExitEN(s, <span class="string">&quot;pthread_cond_wait&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (idx = <span class="number">0</span>; idx &lt; totThreads; idx++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (thread[idx].state == TS_TERMINATED)</span><br><span class="line">            &#123;</span><br><span class="line">                s = pthread_join(thread[idx].tid, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                thread[idx].state = TS_JOINED;</span><br><span class="line">                numLive--;</span><br><span class="line">                numUnjoined--;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Reaped thread %d (numLive=%d)\n&quot;</span>, idx, numLive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = pthread_mutex_unlock(&amp;threadMutex);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_mutex_unlock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何合并任意终止的线程。该程序会为每个命令行参数创建1个线程，每个线程会睡眠对应的命令行参数指定的秒数并终止 (睡眠是为了模拟执行一些操作)。</p><p>　　该程序会维护1组全局变量来记录创建的线程的相关信息。对于每个线程，全局数组<code>thread</code>中会有1个对应的元素记录其线程ID (成员<code>tid</code>) 和当前状态 (成员<code>state</code>)。成员<code>state</code>的值只能是<code>TS_ALIVE</code> (表示线程未终止)、<code>TS_TERMINATED</code> (表示线程已终止，但未被合并) 或<code>TS_JOINED</code> (表示线程已终止，并且已被合并)。</p><p>　　对于新线程，在睡眠完成后，会将对应的<code>thread</code>元素的成员<code>state</code>赋值为<code>TS_TERMINATED</code>，然后将全局变量<code>numUnjoined</code>加1，最后执行唤醒操作。</p><p>　　对于主线程，在创建完线程后，会循环等待条件变量<code>threadDied</code>。当它被唤醒后，会寻找未被合并的终止的线程，然后对这些线程调用<code>pthread_join()</code>，最后将对应的<code>thread</code>元素的成员<code>state</code>赋值为<code>TS_JOINED</code>以及将全局变量<code>numLive</code>和<code>numUnjoined</code>减1。当创建的所有线程都被合并后，主线程会终止循环 (这里也可以让新线程成为分离线程，并从主线程中删除<code>pthread_join()</code>调用)。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_29/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第29章 线程：简介"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第29章 线程：简介</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_31/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第31章 线程：线程安全和线程级存储">《Linux/UNIX系统编程手册》第31章 线程：线程安全和线程级存储 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>