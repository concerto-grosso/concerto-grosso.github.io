<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_10/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_10/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_10/","title":"《Linux/UNIX系统编程手册》第10章 时间"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第10章 时间 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4"><span class="nav-text">10.1 日历时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-text">10.2 时间转换函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">10.2.1 将日历时间转换为字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E5%92%8C%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2"><span class="nav-text">10.2.2 在日历时间和分解时间之间转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2"><span class="nav-text">10.2.3 在分解时间与字符串之间转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">10.2.3.1 将分解时间转换为字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4"><span class="nav-text">10.2.3.2 将字符串转换为分解时间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E5%8C%BA"><span class="nav-text">10.3 时区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE"><span class="nav-text">10.4 区域设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F"><span class="nav-text">10.5 更新系统时钟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%97%B6%E9%97%B4"><span class="nav-text">10.6 进程时间</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_10/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第10章 时间 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第10章 时间</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-12-07 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-07T00:00:00+08:00">2024-12-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-10 00:00:00" itemprop="dateModified" datetime="2025-01-10T00:00:00+08:00">2025-01-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>19k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　在程序中，有2种重要的时间：<strong>实际时间</strong>和<strong>进程时间</strong>。</p><p>　　● 实际时间基于某个标准时间点 (即<strong>日历时间</strong>) 或进程的生命周期中的某个固定时间点 (即<strong>运行时间</strong>或<strong>挂钟时间</strong>) 测量。日历时间用于为数据库记录和文件添加时间戳的程序。运行时间用于执行定期操作或通过外部输入设备进行定期采样的程序。</p><p>　　● 进程时间是进程所用的CPU时间。进程时间用于检测或优化程序和算法的性能。</p><p>　　大多数计算机架构都有1个内部硬件时钟，使内核能够测量实际时间和进程时间。</p><p>　　进程时间是自进程创建以来所用的CPU时间。为了便于记录，内核将CPU时间分为<strong>用户CPU时间</strong> (也称为<strong>虚拟时间</strong>) 和<strong>系统CPU时间</strong>。当通过shell运行程序时，可以使用命令<code>time</code>来查看程序所用的各种进程时间。</p><p>　　● 用户CPU时间是在用户模式下执行所用的时间。</p><p>　　● 系统CPU时间是在内核模式下执行所用的时间，即内核执行系统调用或代表程序执行其他任务 (例如，处理缺页) 所用的时间。</p><p>　　有时，进程时间也称为程序所用的<span style="background-color:#ff0">总CPU时间</span>。</p><p>　　UNIX系统将内部时间表示自UTC (或GMT) 时间1970年1月1日凌晨 (即<strong>纪元</strong>) 以来的秒数，这大约是UNIX的诞生之日。日历时间存储为整型数据类型<code>time_t</code>。</p><p>　　对于32位Linux系统，<code>time_t</code>被实现为有符号整数，只能表示1901年12月13日 20:45:52到2038年1月19日 03:14:07内的时间 (SUSv3没有说明<code>time_t</code>的负值的含义)。因此，很多32位UNIX系统都面临<span style="background-color:#ff0">2038年危机</span>。到2038年，可能所有UNIX实现早已变为64位及以上，这一事实大大缓解了该问题。但是，32位嵌入式系统 (其使用寿命通常比对应的桌面系统的更长) 可能会受到该问题的影响。此外，对于以32位<code>time_t</code>维护时间的遗留数据和应用程序，该问题仍然存在。</p><span id="more"></span><p>　　不同的国家 (甚至同一国家的不同地区) 通常使用不同的时区和夏令时 (DST)。时区信息通常繁多，所以通常不会将其编码为程序或库，而是将其以标准格式保存在文件中。</p><p>　　时区信息通常维护在目录<code>/usr/share/zoneinfo</code>下，该目录下的所有文件都包含特定国家或地区的时区信息。这些文件的名称与其内容相关，例如，<code>EST</code> (美国西部标准时间)、<code>CET</code> (欧洲中部标准时间)、<code>UTC</code>、<code>Turkey</code>和<code>Iran</code>。此外，可能会使用子目录来将相关时区组织为层次结构，例如，子目录<code>Pacific</code>可能会有文件<code>Auckland</code>、<code>Port_Moresby</code>和<code>Galapagos</code>。当指定程序使用的时区时，指定的就是该目录下的时区文件的相对路径名。</p><p>　　时区文件的格式记录在<code>tzfile</code>的手册中。时区文件通过<span style="background-color:#ff0">时区信息编译器</span><code>zic</code>构建。命令<code>zdump</code>可用于根据指定时区文件中的时区显式时间。</p><p>　　系统的本地时间定义在时区文件<code>/etc/localtime</code>中，该文件通常链接到<code>/usr/share/zoneinfo</code>下的某个文件。</p><p>　　SUSv3将<strong>区域设置</strong>定义为取决于语言和文化习俗的用户环境子集。与时区信息类似，区域设置也是以标准格式保存在文件中。</p><p>　　术语<strong>国际化</strong>经常缩写为<span style="background-color:#ff0">I18N</span>。除了写得更快，该缩写还避免了英式英语和美式英语中术语本身拼写的差距。</p><p>　　本书中描述的与时间相关的系统调用都受到系统<strong>软件时钟</strong>的精度的影响。软件时钟测量时间的单位称为<span style="background-color:#ff0">jiffy</span>。jiffy的大小由内核源代码中常量<code>HZ</code>定义。这是内核将CPU分配给循环分时算法下的进程的单元。</p><p>　　对于Linux/x86-32，内核2.4及以下版本的软件时钟的频率是100赫兹 (jiffy是10毫秒)，内核 2.6的软件时钟是1000赫兹。随着时钟频率的增加，定时器操作的精度会变得更高，时间测量也会变得更精准。但是，软件时钟并非越高越好，因为每次时钟中断都会消耗少量CPU时间，在此期间，CPU不能服务进程。</p><p>　　内核开发者之间的争论最终导致软件时钟频率成为了1个可配置的内核选项。从内核 2.6.13开始，软件时钟频率可以设置100250或1000赫兹。从内核 2.6.20开始，软件时钟频率可以设置100250、1000或300赫兹，300赫兹的频率是25帧每秒的PAL制和30帧每秒的NTSC制的帧数的整数倍。</p><h3 id="日历时间">10.1 日历时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;       <span class="comment">/* 自纪元以来的秒数 */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec; <span class="comment">/* 附加的微秒 (long int) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> tz_minuteswest; <span class="comment">/* UTC减去本地时区得到的分钟数 (对于UTC+1时区，该成员为-60) */</span></span><br><span class="line">    <span class="type">int</span> tz_dsttime;     <span class="comment">/* 表示本地时区中生效的DST制度的常数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>gettimeofday()</code>用于获取日历时间，结果存储在参数<code>tv</code>指向的结构体中。</p><p>　　尽管结构体<code>timeval</code>中的成员<code>tv_usec</code>用于表示精确微秒，但该成员的精度取决于依赖于架构的实现。该成员的名称中的<code>u</code>源于该成员与公制中用于表示百万分之一的希腊字母μ的相似之处。对于现代x86-32系统 (即时间戳计数器寄存器在每个CPU时钟周期都递增的Pentium系统)，<code>gettimeofday()</code>确实提供了微秒级精度。</p><p>　　参数<code>tz</code>是历史产物。对于早期UNIX实现，该参数用于检索系统的时区信息。该参数现已过时，并且应该指定为<code>NULL</code>。若<code>tz</code>不是<code>NULL</code>，则它指向的结构体的值会变为最近1次调用<code>settimeofday()</code> (其参数与<code>gettimeofday()</code>的相同) 时指定给<code>tz</code>的值。因为DST制度无法用简单的算法实现，所以<code>tz</code>会过时 (Linux从未支持该成员)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *timep)</span>; <span class="comment">/* 成功时返回自纪元以来的秒数，出错时返回(time_t)-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>time()</code>会返回自纪元以来的秒数。若参数<code>timep</code>不是<code>NULL</code>，则返回值也会存储在该参数指向的内存中。</p><p>　　因为<code>time()</code>会以2种方式返回相同的值，并且只有在<code>timep</code>是无效地址时才会出错 (<code>EFAULT</code>)，所以可以直接以<code>t = time(NULL)</code>的方式调用。</p><p>　　由于历史原因，<code>gettimeofday()</code>与<code>time()</code>得以共存。早期UNIX实现提供了<code>time()</code>。4.3BSD添加了更精准的<code>gettimeofday()</code>。</p><h3 id="时间转换函数">10.2 时间转换函数</h3><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_10/functions_for_retrieving_and_working_with_calendar_time.svg" title="functions_for_retrieving_and_working_with_calendar_time"><p>　　如图所示，这里展示了各种用于在日历时间和其他时间格式之间转换的函数。</p><h4 id="将日历时间转换为字符串">10.2.1 将日历时间转换为字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>; <span class="comment">/* 成功时返回静态分配的以\n\0结尾的字符串，出错时返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>ctime()</code>会将日历时间转换为26位的固定格式字符串 (形如<code>Wed Jun 8 14:22:34 2011\n\0</code>) 并返回。</p><p>　　<code>ctime()</code>在执行转换时，会应用时区和DST设置。该函数返回的字符串是静态分配的，所以后续对该函数的失败调用会将其覆盖。</p><p>　　<code>ctime()</code>的可重入版本是<code>ctime_r()</code>。调用<code>ctime_r()</code>时可以指定额外的指针参数，该参数指向用于存储转换结果字符串的缓冲区。</p><p>　　SUSv3规定，对<code>ctime()</code>、<code>gmtime()</code>、<code>localtime()</code>或<code>asctime()</code>的调用可能会覆盖其他函数返回的静态分配的结构体。换句话说，这些函数可能共享相同的返回字符串和结构体<code>tm</code>。</p><h4 id="在日历时间和分解时间之间转换">10.2.2 在日历时间和分解时间之间转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回静态分配的分解时间结构体，出错时返回NULL */</span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">/* 秒 (0-60) */</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">/* 分 (0-59) */</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">/* 时 (0-23) */</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">/* 日 (1-31) */</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">/* 月 (0-11) */</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">/* 年 (自1900年以来) */</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">/* 周 (0表示周日)*/</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">/* 1年中的某天 (0-365，0表示1月1日)*/</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">/* DST标志 (大于0表示DST生效，等于0表示DST不生效，小于0表示DST视情况而定) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　函数<code>gmtime()</code> (名称中的<code>gm</code>源于GMT) 会将日历时间转换为对应UTC的<strong>分解时间</strong>，分解时间存储在静态分配的结构体<code>tm</code>中，然后返回该结构体的地址。相比之下，函数<code>localtime()</code>会将日历时间转换为系统本地时间。</p><p>　　结构体<code>tm</code>的成员<code>tm_sec</code>的最大值是60，因为其中包括了用于保证人类日历接近回归年的<span style="background-color:#ff0">闰秒</span>。</p><p>　　若定义了功能测试宏<code>_BSD_SOURCE</code>，glibc版本的结构体<code>tm</code>会包含2个额外成员。第1个额外成员是<code>long int tm_gmtoff</code>，其值为本地时区减去UTC得到的秒数。第2个额外成员是<code>char *tm_zone</code>，表示时区名的缩写形式 (例如，CEST表示欧洲中部DST)。SUSv3没有说明这2个额外成员，并且只有少数UNIX实现 (主要是BSD衍生的实现) 提供了这2个额外成员。</p><p>　　<code>gmtime()</code>和<code>localtime()</code>的可重入版本是<code>gmtime_r()</code>和<code>localtime_r()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *timeptr)</span>; <span class="comment">/* 成功时返回timeptr对应的自纪元以来的秒数，出错时返回(time_t)-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>mktime()</code>会将本地时间对应的分解时间 (参数<code>timeptr</code>) 转换为日历时间并返回。转换时会忽略结构体<code>tm</code>中的成员<code>tm_wday</code>和<code>tm_yday</code>。</p><p>　　<code>mktime()</code>可能会修改<code>timeptr</code>指向的结构体。至少，它会保证成员<code>tm_wday</code>和<code>tm_yday</code>与其他成员匹配。此外，<code>mktime()</code>允许其他成员的值超出范围。对于每个超出范围的成员，<code>mktime()</code>会将其值调整为范围内的值，并且对其他成员进行适当的调整。这些调整会在<code>mktime()</code>更新成员<code>tm_wday</code>和<code>tm_yday</code>和计算返回值之前进行。</p><p>　　例如，若输入时成员<code>tm_sec</code>是123，则返回时该成员会变为3，并且成员<code>tm_min</code>会加2 (若成员<code>tm_min</code>加2后溢出，则会将<code>tm_hour</code>加1，依此类推)。若输入时<code>tm_sec</code>是-1，则返回时该成员会变为59，并且成员<code>tm_min</code>会减1。</p><p>　　<code>mktime()</code>进行转换时会应用时区设置。此外，也可能会应用DST，取决于成员<code>tm_isdst</code>。若该成员等于0，则会忽略DST；若该成员大于0，则会直接应用DST (无论给定时间是否受到DST影响)；若该成员小于0，则会先判断给定时间是否受到DST影响，再根据结果来决定是否应用DST。</p><p>　　转换完成后，成员<code>tm_isdst</code>会被设置为正值 (给定时间受到DST影响) 或0 (DST不生效)。</p><h4 id="在分解时间与字符串之间转换">10.2.3 在分解时间与字符串之间转换</h4><h5 id="将分解时间转换为字符串">10.2.3.1 将分解时间转换为字符串</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span>; <span class="comment">/* 成功时返回静态分配的以\n\0结尾的字符串，出错时返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>asctime()</code>会将分解时间 (参数<code>timeptr</code>) 转换为26位的固定格式字符串 (形如<code>Wed Jun 8 14:22:34 2011\n\0</code>) 并返回。</p><p>　　与<code>ctime()</code>相比，<code>asctime()</code>不会应用时区设置，因为该函数转换的时间通常是通过<code>localtime()</code>本地化后的时间或<code>gmtime()</code>返回的时间。</p><p>　　<code>asctime()</code>的可重入版本是<code>asctime_r()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* calendar_time.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDS_IN_TROPICAL_YEAR (365.24219 * 24 * 60 * 60)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">gmp</span>, *<span class="title">locp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">gm</span>, <span class="title">loc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    t = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Seconds since the Epoch (1 Jan 1970): %ld&quot;</span>, (<span class="type">long</span>)t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; (about %6.3f years)\n&quot;</span>, t / SECONDS_IN_TROPICAL_YEAR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gettimeofday(&amp;tv, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;gettimeofday&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; gettimeofday() returned %ld secs, %ld microsecs\n&quot;</span>,</span><br><span class="line">           (<span class="type">long</span>)tv.tv_sec, (<span class="type">long</span>)tv.tv_usec);</span><br><span class="line"></span><br><span class="line">    gmp = gmtime(&amp;t);</span><br><span class="line">    <span class="keyword">if</span> (gmp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;gmtime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gm = *gmp; <span class="comment">/* 保存副本，因为*gmp可能会被后续对asctime()和gmtime()的调用覆盖 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Broken down by gmtime():\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; year=%d mon=%d mday=%d hour=%d min=%d sec=%d &quot;</span>, gm.tm_year,</span><br><span class="line">           gm.tm_mon, gm.tm_mday, gm.tm_hour, gm.tm_min, gm.tm_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wday=%d yday=%d isdst=%d\n&quot;</span>, gm.tm_wday, gm.tm_yday, gm.tm_isdst);</span><br><span class="line"></span><br><span class="line">    locp = localtime(&amp;t);</span><br><span class="line">    <span class="keyword">if</span> (locp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;localtime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loc = *locp; <span class="comment">/* 保存副本 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Broken down by localtime():\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; year=%d mon=%d mday=%d hour=%d min=%d sec=%d &quot;</span>, loc.tm_year,</span><br><span class="line">           loc.tm_mon, loc.tm_mday, loc.tm_hour, loc.tm_min, loc.tm_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wday=%d yday=%d isdst=%d\n\n&quot;</span>, loc.tm_wday, loc.tm_yday, loc.tm_isdst);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;asctime() formats the gmtime() value as: %s&quot;</span>, asctime(&amp;gm));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ctime() formats the time() value as: %s&quot;</span>, ctime(&amp;t));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mktime() of gmtime() value: %ld secs\n&quot;</span>, (<span class="type">long</span>)mktime(&amp;gm));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mktime() of localtime() value: %ld secs\n&quot;</span>, (<span class="type">long</span>)mktime(&amp;loc));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了上述函数的用法。该程序会检索当前日历时间，然后通过各种时间转换函数来转换时间，最后打印转换结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *outstr, <span class="type">size_t</span> maxsize, <span class="type">const</span> <span class="type">char</span> *format,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span>; <span class="comment">/* 成功时返回outstr的长度减1 (不包括结尾的字符\0)，出错时返回0 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>strftime()</code>会将分解时间 (参数<code>timeptr</code>) 转换为以字符<code>\0</code>字符结尾的指定格式字符串 (参数<code>outstr</code>)。</p><p>　　字符串<code>outstr</code>的格式取决于参数<code>format</code>。参数<code>maxsize</code>指定<code>outstr</code>的长度。此外，<code>outstr</code>不包括换行符<code>\n</code> (除非<code>format</code>要求如此)。</p><p>　　若<code>strftime()</code>成功，则返回<code>outstr</code>的长度减1 (不包括结尾的字符<code>\0</code>字符)。若转换结果的长度超过了<code>maxsize</code>，则返回0，并且<code>outstr</code>是不确定的。</p><table><colgroup><col style="width:15%"><col style="width:49%"><col style="width:35%"></colgroup><thead><tr><th style="text-align:left">格式说明符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>%%</code></td><td><code>%</code>字符</td><td>%</td></tr><tr><td style="text-align:left"><code>%a</code></td><td>每周7天的名称的缩写</td><td>Tue</td></tr><tr><td style="text-align:left"><code>%A</code></td><td>每周7天的全名</td><td>Tuesday</td></tr><tr><td style="text-align:left"><code>%b, %h</code></td><td>月名的缩写</td><td>Feb</td></tr><tr><td style="text-align:left"><code>%B</code></td><td>月名的全称</td><td>February</td></tr><tr><td style="text-align:left"><code>%c</code></td><td>日期和时间</td><td>Tue Feb 1 21:39:46 2011</td></tr><tr><td style="text-align:left"><code>%d</code></td><td>月份中的某天 (01~31，2位数)</td><td>01</td></tr><tr><td style="text-align:left"><code>%D</code></td><td>美国时间格式 (等同于<code>%m/%d/%y</code>)</td><td>02/01/11</td></tr><tr><td style="text-align:left"><code>%e</code></td><td>字符形式的月份中的某天 (2个字符)</td><td>1</td></tr><tr><td style="text-align:left"><code>%F</code></td><td>ISO时间格式 (等同于<code>%Y-%m-%d</code>)</td><td>2011-02-01</td></tr><tr><td style="text-align:left"><code>%H</code></td><td>小时 (24小时制，2位数)</td><td>21</td></tr><tr><td style="text-align:left"><code>%I</code></td><td>小时 (12小时制，2位数)</td><td>09</td></tr><tr><td style="text-align:left"><code>%j</code></td><td>1年中的某天 (001~365，3位数)</td><td>032</td></tr><tr><td style="text-align:left"><code>%m</code></td><td>十进制形式的月份 (01~12，2位数)</td><td>02</td></tr><tr><td style="text-align:left"><code>%M</code></td><td>分钟 (2位数)</td><td>39</td></tr><tr><td style="text-align:left"><code>%p</code></td><td>AM/PM</td><td>PM</td></tr><tr><td style="text-align:left"><code>%P</code></td><td>am/pm (GNU扩展)</td><td>pm</td></tr><tr><td style="text-align:left"><code>%R</code></td><td>23小时制的时间 (等同于<code>%H:%M</code>)</td><td>21:39</td></tr><tr><td style="text-align:left"><code>%S</code></td><td>秒钟 (00~60)</td><td>46</td></tr><tr><td style="text-align:left"><code>%T</code></td><td>时间 (等同于<code>%H:%M:%S</code>)</td><td>21:39:46</td></tr><tr><td style="text-align:left"><code>%u</code></td><td>1周中的某天 (1~7，1表示周一)</td><td>2</td></tr><tr><td style="text-align:left"><code>%U</code></td><td>1年中的第几个周日 (00~53)</td><td>05</td></tr><tr><td style="text-align:left"><code>%w</code></td><td>1周中的某天 (0~6，0表示周日)</td><td>2</td></tr><tr><td style="text-align:left"><code>%W</code></td><td>1年中的第几个周一 (00~53)</td><td>05</td></tr><tr><td style="text-align:left"><code>%x</code></td><td>本地日期</td><td>02/01/11</td></tr><tr><td style="text-align:left"><code>%X</code></td><td>本地时间</td><td>21:39:46</td></tr><tr><td style="text-align:left"><code>%y</code></td><td>年份 (2位数)</td><td>11</td></tr><tr><td style="text-align:left"><code>%Y</code></td><td>年份 (4位数)</td><td>2011</td></tr><tr><td style="text-align:left"><code>%Z</code></td><td>时区名</td><td>CET</td></tr></tbody></table><p>　　<code>format</code>与提供给<code>printf()</code>的格式说明符类似，以百分号<code>%</code>开头 (按照规范)，之后是表示日期或时间的字符串。除非另有说明，否则，这些转换格式说明符默认是SUSv3的一部分。</p><p>　　格式说明符<code>%U</code>和<code>%W</code>都可用于表示1年中的第几周。<code>%U</code>会将1年中第1个包含周日的周记为第1周，第1周前的周记为第0周。若周日正好是1年的第1天，则不会有第0周，并且同年的最后1天会记为第53周。<code>%W</code>与之类似，但以周一为基准来计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* curr_time.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span> <span class="comment">/* 函数原型在该头文件中 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将当前时间转换为以字符\0结尾的指定格式字符串 (出错时返回NULL)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param format 若为NULL，则默认使用格式说明符%c</span></span><br><span class="line"><span class="comment"> * @return char* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">currTime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[BUF_SIZE]; <span class="comment">/* 不可重入 */</span></span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    <span class="type">size_t</span> s;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tm</span>;</span></span><br><span class="line"></span><br><span class="line">    t = time(<span class="literal">NULL</span>);</span><br><span class="line">    tm = localtime(&amp;t);</span><br><span class="line">    <span class="keyword">if</span> (tm == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = strftime(buf, BUF_SIZE, (format != <span class="literal">NULL</span>) ? format : <span class="string">&quot;%c&quot;</span>, tm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (s == <span class="number">0</span>) ? <span class="literal">NULL</span> : buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在之后的示例程序中，会经常需要打印当前时间。因此，这里实现了函数<code>currTime()</code>，该函数会返回当前时间对应的指定格式字符串 (参数<code>format</code>)。</p><h5 id="将字符串转换为分解时间">10.2.3.2 将字符串转换为分解时间</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strptime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, <span class="keyword">struct</span> tm *timeptr)</span>; <span class="comment">/* 成功时返回指向str中下一个未被处理字符的指针，出错时返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>strptime()</code>会根据参数<code>format</code>指定的格式说明符来将参数<code>str</code>解析为分解时间，然后将结果存储在参数<code>timeptr</code>指向的结构体中。</p><p>　　若<code>strptime()</code>成功，则会返回指向<code>str</code>中下一个未被处理字符的指针 (当<code>str</code>中包含需要调用进程进一步处理的字符时，这很有用)。</p><p>　　<code>format</code>与提供给<code>strftime()</code>的格式说明符类似，主要区别是<code>strptime()</code>的格式说明符更通用。例如，<code>%a</code>和<code>%A</code>都可用于读取每周7天的名称 (无论全称还是缩写)，<code>%d</code>和<code>%e</code>都可用于读取月份中的某天 (无论<code>1</code>还是<code>01</code>)。此外，转换时会忽略<code>str</code>中字符的大小写 (例如，<code>May</code>等同于<code>MAY</code>)。<code>format</code>中的<code>%%</code>用于匹配<code>str</code>中的百分号。若<code>format</code>不符合规范，则<code>strptime()</code>会返回<code>NULL</code>。</p><p>　　glibc版本的<code>strptime()</code>不会修改结构体<code>tm</code>中的没有对应格式说明符的成员。因此，可以通过多次调用<code>strptime()</code>来解析多个字符串，以构建单个结构体 (SUSv3没有说明这种行为)。在大多数情况下，通过<code>memset()</code>将整个结构体初始化为0就足够了。但是，对于glibc等大多数实现，成员<code>tm_mday</code>为0时表示上一个月的最后1天。此外，<code>strptime()</code>不会修改成员<code>tm_isdst</code>。</p><p>　　<code>glic</code>提供了2个与<code>strptime()</code>类似的函数：<code>getdate()</code>和对应的可重入版本<code>getdate_r()</code>。这2个函数需要使用外部文件 (由环境变量<code>DATEMSK</code>标识) 来指定转换格式，外部文件使得这些函数难以使用，并且会在set-user-ID程序中产生安全漏洞。SUSv3详细说明了<code>getdate()</code>，并且大部分UNIX实现都提供了该函数。SUSv3没有说明<code>getdate_r()</code>，并且只有少部分UNIX实现提供了该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* strtime.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUF_SIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line">    <span class="type">char</span> sbuf[SBUF_SIZE];</span><br><span class="line">    <span class="type">char</span> *ofmt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s input-date-time in-format [out-format]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setlocale(LC_ALL, <span class="string">&quot;&quot;</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setlocale&quot;</span>); <span class="comment">/* 转换时应用区域设置 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tm, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tm)); <span class="comment">/* 初始化tm */</span></span><br><span class="line">    <span class="keyword">if</span> (strptime(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;tm) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;strptime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tm.tm_isdst = <span class="number">-1</span>; <span class="comment">/* 告诉mktime()检测DST是否生效 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;calendar time (seconds since Epoch): %ld\n&quot;</span>, (<span class="type">long</span>)mktime(&amp;tm));</span><br><span class="line"></span><br><span class="line">    ofmt = (argc &gt; <span class="number">3</span>) ? argv[<span class="number">3</span>] : <span class="string">&quot;%H:%M:%S %A, %d %B %Y %Z&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (strftime(sbuf, SBUF_SIZE, ofmt, &amp;tm) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;strftime returned 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strftime() yields: %s\n&quot;</span>, sbuf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>strptime()</code>和<code>strftime()</code>的用法。该程序会通过<code>strptime()</code>来将包含日期和时间的命令行参数转换为分解时间，然后通过<code>strftime()</code>来将分解时间转换为日历时间，最后打印结果。该程序最多接收3个命令行参数，但只有前2个命令行参数是必需的。第1个命令行参数是包含日期和时间的字符串，第2个命令行参数是通过<code>strptime()</code>解析第1个命令行参数时所用的格式说明符。第3个命令行参数是通过<code>strftime()</code>将分解时间转换为日历时间时所用的格式说明符。若第3个命令行参数未指定，则使用默认的格式说明符。</p><h3 id="时区">10.3 时区</h3><p>　　为了在运行程序时指定时区，需要将环境变量<code>TZ</code>设置为由冒号<code>:</code>加上<code>/usr/share/zoneinfo</code>中的时区名组成的字符串。函数<code>ctime()</code>、<code>localtime()</code>、<code>mktime()</code>和<code>strftime()</code>都会受到时区设置的影响。为了获取当前时区设置，这些函数会使用函数<code>tzset()</code>，<code>tzset()</code>会初始化以下3个全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *tzname[<span class="number">2</span>]; <span class="comment">/* 时区和备用 (DST) 时区的名称 */</span></span><br><span class="line"><span class="type">int</span> daylight;    <span class="comment">/* 使用了备选 (DST) 时区时非0 */</span></span><br><span class="line"><span class="type">long</span> timezone;   <span class="comment">/* UTC和本地时区相差的秒数 */</span></span><br></pre></td></tr></table></figure><p>　　<code>tzset()</code>会先检查环境变量<code>TZ</code>。若该环境变量未设置，则使用时区文件<code>/etc/localtime</code>中的定义来将时区初始化为默认设置；若该环境变量是空字符串或没有匹配的时区文件，则将时区设置为UTC。环境变量<code>TZDIR</code> (非标准的GNU扩展) 可以设置为时区对应的文件的目录名 (而非默认的<code>/usr/share/zoneinfo</code>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* show_time.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 200</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">loc</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setlocale(LC_ALL, <span class="string">&quot;&quot;</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setlocale&quot;</span>); <span class="comment">/* 转换时应用区域设置 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ctime() of time() value is: %s&quot;</span>, ctime(&amp;t));</span><br><span class="line"></span><br><span class="line">    loc = localtime(&amp;t);</span><br><span class="line">    <span class="keyword">if</span> (loc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;localtime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;asctime() of local time is: %s&quot;</span>, asctime(loc));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strftime(buf, BUF_SIZE, <span class="string">&quot;%A, %d %B %Y, %H:%M:%S %Z&quot;</span>, loc) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;strftime returned 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strftime() of local time is: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了时区设置和区域设置的影响。</p><p>　　SUSv3定义了设置环境变量<code>TZ</code>的2种常用方法。第1方法是设置为由冒号<code>:</code>加上<code>/usr/share/zoneinfo</code>中的时区名组成的字符串 (Linux和部分UNIX实现允许省略冒号，但SUSv3不允许这样)。第2种方法是SUSv3详细说明的方法，将环境变量<code>TZ</code>设置为以下格式的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std offset [ dst [ offset ][ , start-date [ /time ] , end-date [ /time ]]]</span><br></pre></td></tr></table></figure><p>　　为了进行区分，这里使用了<span style="background-color:#ff0">实际上不存在的空格</span>。括号<code>([])</code>中的字段是可选项。</p><p>　　字段<code>std</code>和<code>dst</code>用于标识标准时区和DST时区。字段<code>offset</code>是本地时区减去UTC得到的值。最后4个字段表示何时从标准时间更改为DST时间。日期字段能以多种形式指定，例如，<code>Mm.n.d</code>表示<code>m</code>月 (1~12) 的第<code>n</code>周 (1~5，5表示最后<code>d</code>天) 的第<code>d</code>天 (0表示周日，6表示周六)。若字段<code>time</code>未指定，则默认为<code>02:00:00</code>。</p><p>　　<code>TZ="CET-1:00:00CEST-2:00:00,M3.5.0,M10.5.0"</code>会将环境变量<code>TZ</code>设置为欧洲中部 (标准时区是UTC-1，DST时区是UTC-2 ，从3月的最后1个周日到10月最后1个周日)。这里省略了DST转换的规范，因为它发生在默认的<code>02:00:00</code>。对于Linux，这等同于<code>TZ=":Europe/Berlin"</code>。</p><h3 id="区域设置">10.4 区域设置</h3><p>　　区域设置控制着GNU/Linux工具以及很多glibc函数 (例如，<code>strftime()</code>和<code>strptime()</code>) 的多种行为。</p><p>　　区域设置信息维护在目录<code>/usr/share/locale</code>下的层次结构中 (某些发行版是<code>/usr/lib/locale</code>)。该目录下的每个子目录都包含1个特定的区域设置。这些子目录按照以下格式命名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language[_territory[.codeset]][@modifier]</span><br></pre></td></tr></table></figure><p>　　字段<code>language</code>是2个字母的ISO语言代码。字段<code>territory</code>是2个字母的ISO国家代码。字段<code>codeset</code>是字符编码集。字段<code>modifier</code>用于区分其它3个字段都相同的不同区域设置。例如，<code>de_DE.utf-8@euro</code>表示区域设置的语言是德语，地区是德国，字符编码集是UTF-8，货币单位是欧元。</p><p>　　括号中的字段是可选项。通常，子目录的名称仅包含字段<code>language</code>和<code>territory</code>。因此，<code>en_US</code>是 (英语) 美国的区域设置，<code>fr_CH</code> (<code>CH</code>表示瑞士的拉丁语名Confoederatio Helvetica) 是瑞士法语区的区域设置子目录。</p><p>　　SUSv3对区域设置唯一的要求是<span style="background-color:#ff0">定义1个名为POSIX的标准区域设置</span>，该区域设置反映了UNIX系统的历史行为。因此，该区域设置基于ASCII字符集，并使用英语表示日期和月份的名称以及肯定/否定响应。此外，该区域设置的货币和数字部分是未定义的。</p><p>　　每个区域设置子目录下都是1组标准文件，这些文件指定了区域设置的规范，如下表所示：</p><table><colgroup><col style="width:17%"><col style="width:82%"></colgroup><thead><tr><th>文件名</th><th>目的</th></tr></thead><tbody><tr><td><code>LC_TYPE</code></td><td>包含字符分类 (见函数<code>isalpha()</code>) 和大小写转换规则的文件</td></tr><tr><td><code>LC_COLLATE</code></td><td>包含字符集的排序规则的文件</td></tr><tr><td><code>LC_MONETARY</code></td><td>包含货币值格式规则的文件 (见函数<code>localeconv()</code>和头文件<code>locale.h</code>)</td></tr><tr><td><code>LC_NUMERIC</code></td><td>包含除货币值之外的数字的格式规则的文件</td></tr><tr><td><code>LC_TIME</code></td><td>包含日期和时间的格式规则的文件</td></tr><tr><td><code>LC_MESSAGES</code></td><td>包含指定用于肯定和否定响应的格式和值的文件</td></tr></tbody></table><p>　　● 文件<code>LC_COLLATE</code>定义了1组描述字符集的排序规则 (按字母顺序排序) 的规则。这些规则决定函数<code>strcoll()</code>和<code>strxfrm</code>的行为。即使基于拉丁语脚本的语言也不遵循相同的排序规则。例如，部分欧洲语言有额外的字母，在某些情况下，这些字母排在字母Z之后。其他特殊情况包括西班牙语双字母序列ll (作为单个字母，排在字母l之后) 和德语元音变音符 (例如，ä对应ae，并且按照这2个字母排序)。</p><p>　　● 目录<code>LC_MESSAGES</code>用于将程序显示的信息国际化。通过使用消息目录 (见函数<code>catopen()</code>和<code>catgets()</code>的手册) 或GNU的API<code>gettext</code> 可以完成更全面的程序信息国际化。</p><p>　　glibc 2.2.2添加了大量非标准的区域设置目录。<code>LC_ADDRESS</code>定义了用于表示邮寄地址的区域设置专属规则。<code>LC_IDENTIFICATION</code>指定区域设置的标识信息。<code>LC_MEASUREMENT</code>定义区域设置的度量系统 (例如，公制与英制)。<code>LC_NAME</code>定义了用于表示人的姓名和头衔的区域设置专属规则。<code>LC_PAPER</code>定义了区域设置的标准纸张大小 (例如，美国等大多数国家/地区使用A4格式)。<code>LC_TELEPHONE</code>定义了用于表示国内和国际电话号码以及国际国家/地区前缀和国际拨出前缀的区域设置专属规则。</p><p>　　函数<code>setlocale()</code>可用于设置和查询程序的当前区域设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">setlocale</span><span class="params">(<span class="type">int</span> category, <span class="type">const</span> <span class="type">char</span> *locale)</span>; <span class="comment">/* 成功时返回标识当前区域设置或新区域设置的字符串 (通常静态分配)，出错时返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　参数<code>category</code>表示待设置或查询的区域设置的部分。该参数可以指定为1组常量之一，这些常量的名称与区域设置子目录下的文件名相同。因此，可以将区域设置的时间设置为德国，而货币设置为美元。大多数情况下，该参数都是指定为<code>LC_ALL</code>，表示设置或查询区域设置的所有方面。</p><p>　　有2种通过<code>setlocale()</code>设置区域设置的方法。参数<code>locale</code>可以指定为<code>/usr/lib/locale</code>下的子目录名，例如，<code>de_DE</code>或<code>en_US</code>。此外，<code>locale</code>也可以指定为空字符串，表示应该从环境变量中读取区域设置。</p><p>　　当在程序中调用<code>setlocale(LC_ALL, "")</code>时，可以通过一组名称为<code>LC_*</code> (与区域设置子目录下的文件名相同) 的环境变量来控制区域设置的各个方面。或者，使用环境变量<code>LC_ALL</code>或<code>LANG</code>来指定区域设置的各个方面。若设置了多个上述环境变量，则环境变量<code>LC_ALL</code>的优先级最高，<code>LANG</code>的优先级最低。因此，可以使用环境变量<code>LANG</code>来设置区域设置的默认值，然后通过环境变量<code>LC_*</code>来设置区域设置的某些方面。</p><p>　　当<code>setlocale()</code>成功时，会返回标识区域设置的指定方面的 (通常静态分配) 字符串。若只需要查询区域设置，则可以将<code>locale</code>指定为<code>NULL</code>。</p><p>　　当指定程序使用的区域设置时，指定的就是<code>/usr/share/locale</code>下的子目录名。当程序的区域设置没有对应的区域设置子目录时，<code>setlocale()</code>会去除区域设置中的<span style="background-color:#ff0">字符编码集</span>部分，然后再进行匹配。若依然没有匹配项目，则依次去除<span style="background-color:#ff0">规格化的字符编码集</span>部分、<span style="background-color:#ff0">地区</span>部分和<span style="background-color:#ff0">修饰符</span>部分后再匹配。规格化的字符编码集是经过处理后的字符编码集名称，处理过程包括删除所有字母和数字以外的字符和将所有字母都转换为小写，并且生成的字符串都有前缀<code>iso</code>。</p><p>　　假设程序将区域设置指定为<code>fr_CH.utf-8</code>，但没有对应的区域设置子目录，则会先判断区域设置子目录<code>fr_CH</code>是否存在。若<code>fr_CH</code>不存在，则判断区域设置子目录<code>fr</code>是否存在。若<code>fr</code>也不存在，则函数<code>setlocale()</code>会报告错误。</p><p>　　文件<code>/usr/share/locale/locale.alias</code>定义了为程序指定区域设置的替代方式，具体详情查看<code>locale.alias</code>的手册。</p><p>　　命令<code>locale</code>会显示shell的当前区域设置的相关信息。命令<code>locale -a</code>会列出系统中定义的所有区域设置。</p><h3 id="更新系统时钟">10.5 更新系统时钟</h3><p>　　系统调用<code>settimeofday()</code>和库函数<code>adjtime()</code>可以更新系统时钟，但它们很少用于应用程序，因为系统时钟通常由<span style="background-color:#ff0">网络时间协议</span> (NTP) 守护进程等工具维护，并且调用它们需要调用者拥有能力<code>CAP_SYS_TIME</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">settimeofday</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timeval *tv, <span class="type">const</span> <span class="keyword">struct</span> timezone *tz)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">adjtime</span><span class="params">(<span class="keyword">struct</span> timeval *delta, <span class="keyword">struct</span> timeval *olddelta)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>settimeofday()</code>的功能与<code>gettimeofday()</code>的相反，它会将系统日历时间设置为参数<code>tv</code>指定的结构体<code>timeval</code>。与<code>gettimeofday()</code>相同，参数<code>tz</code>已过时，应该指定为<code>NULL</code>。</p><p>　　结构体<code>timeval</code>的成员<code>tv_usec</code>的精度不代表通过<code>settimeofday()</code>设置的系统时钟拥有同样的精度，因为系统时钟的精度可能没有达到微妙级。</p><p>　　由于调用<code>settimeofday()</code>而导致的系统时钟的突然变化可能会对依赖于单调增加的系统时钟的应用程序 (例如，<code>make</code>和使用时间戳或日志使用时间戳的数据库) 产生有害影响。因此，当仅需要对系统时钟进行小幅更改时 (大约几秒)，尽量使用库函数<code>adjtime()</code>，该函数会让系统时间逐渐调整到所需的值。</p><p>　　参数<code>delta</code>指向的结构体指定需要将系统时钟修改多少秒和微妙。若<code>delta</code>指向的结构体中的成员是正值，则表示每秒向系统时钟增加少量额外时间，直到达到成员指定的值；若<code>delta</code>指向的结构体中的成员是负值，则以类似的方式减少。对于Linux/x86-32，增加/减少速率是每2000秒增加/减少1秒。</p><p>　　当调用<code>adjtime()</code>时最近1次调用<code>adjtime()</code>设置的时间调整未完成，最近1次调用<code>adjtime()</code>设置的时间调整的剩余时间会存储在参数<code>olddelta</code>。若不需要该值，则可以将<code>olddelta</code>指定为<code>NULL</code>。相反，若只需要该值，则可以将<code>delta</code>指定为<code>NULL</code>。</p><p>　　SUSv3没有说明<code>settimeofday()</code>和<code>adjtime()</code>，但大部分UNIX实现都提供了它们。</p><p>　　Linux还提供了用于更新系统时钟的系统调用<code>stime()</code>。<code>stime()</code>与<code>settimeofday()</code>的区别是<code>stime()</code>的精度只能达到秒级。这2个系统调用得以共存原因是4.3BSD添加了<code>stime()</code>。</p><p>　　对于Linux，<code>adjtime()</code>基于更常用的特定于Linux的系统调用<code>adjtimex()</code>，并且NTP守护进程使用了该系统调用。</p><h3 id="进程时间">10.6 进程时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">times</span><span class="params">(<span class="keyword">struct</span> tms *buf)</span>; <span class="comment">/* 成功时返回自过去 &quot;任意&quot; 时间以来的时钟节拍数，出错时返回(clock_t)-1 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">clock_t</span> tms_utime;  <span class="comment">/* 调用进程所用的用户CPU时间 */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_stime;  <span class="comment">/* 调用进程所用的系统CPU时间 */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_cutime; <span class="comment">/* 调用进程等待子进程所用的用户CPU时间 (包括tms_utime) */</span></span><br><span class="line">    <span class="type">clock_t</span> tms_cstime; <span class="comment">/* 调用进程等待子进程所用的系统CPU时间 (包括tms_stime) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>times()</code>用于检索进程时间信息，结果存储在参数<code>buf</code>指向的结构体中。</p><p>　　参数<code>buf</code>指向的结构体<code>tms</code>的前2个成员是调用进程所用的用户CPU时间和系统CPU时间。第3个成员是调用进程调用<code>wait()</code>等待子进程所用的用户CPU时间 (包括<code>tms_utime</code>)。第4个成员是调用进程调用<code>wait()</code>等待子进程所用的系统CPU时间 (包括<code>tms_stime</code>)。</p><p>　　结构体<code>tms</code>的成员的数据类型<code>clock_t</code>是整数类型，它以称为<strong>时钟节拍</strong>的单位测量时间。可以通过调用<code>sysconf(_SC_CLK_TCK)</code>来获取每秒的时钟节拍数，然后用<code>clock_t</code>值除以这个数来获取秒数。</p><p>　　若<code>times()</code>成功，则会返回自过去某个时间点以来的时钟节拍数。SUSv3故意没有说明该时间点是什么时候，仅提及该时间点在调用进程的生命周期内是不变的，所以该返回值的唯一可移植的用法是计算2次调用<code>times()</code>得到的返回值的差值。就算如此，<code>times()</code>的返回值仍然是不可靠的，因为返回值值可能会溢出，然后重置到0。测试所用时间的可靠方式是使用<code>gettimeofday()</code>。</p><p>　　对于Linux，<code>buf</code>可以指定为<code>NULL</code>。在这种情况下，<code>times()</code>还是会返回时钟节拍数。但是，SUSv3没有说明这种用法，并且很多其他UNIX实现要求<code>buf</code>不能为<code>NULL</code>。</p><p>　　对于大多数Linux硬件架构，<code>sysconf(_SC_CLK_TCK)</code>会返回100，与内核常量<code>USER_HZ</code>对应。但是，对于Alpha和IA-64等少部分架构，常量<code>USER_HZ</code>可以定义为100以外的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">clock</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 成功时返回调用进程所用的总CPU时间 (CLOCKS_PER_SEC为单位)，出错时返回(clock_t)-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>clock()</code>会返回调用进程所用的总CPU时间，其单位是<code>CLOCKS_PER_SEC</code>。因此，需要将返回值除以该单位才能得到对应的秒钟。对于POSIX.1，无论软件时钟是多少，<code>CLOCKS_PER_SEC</code>固定为100万。但是，<code>clock()</code>的精度还是受到软件时钟的影响。</p><p>　　尽管<code>CLOCKS_PER_SEC</code>固定为100万，但SUSv3规定，该常量在不符合XSI的系统上可以被实现为整数常量 (即<code>1000000L</code>)，而非宏。因此，从可移植性角度，<code>CLOCKS_PER_SEC</code>不是编译时常量 (不能使用条件编译语句<code>ifdef</code>)，并且对其调用<code>printf()</code>前应先将其转换为<code>long</code>。</p><p>　　SUSv3规定，<code>clock()</code>应该返回 "进程所用的CPU时间"，这有不同的解释。对于部分UNIX实现，<code>clock()</code>的返回值包括等待子进程所用的CPU时间。对于Linux，<code>clock()</code>的返回值不包括等待子进程所用的CPU时间。</p><p>　　<code>clock()</code>和<code>times()</code>的返回值类型都是<code>clock_t</code>，但两者的测量单位不同。这是POSIX.1和C标准对<code>clock_t</code>定义不同而导致的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* process_time.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印msg和进程时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">displayProcessTimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">t</span>;</span></span><br><span class="line">    <span class="type">clock_t</span> clockTime;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> clockTicks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clockTicks == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 第1次调用时记录时钟节拍 */</span></span><br><span class="line">        clockTicks = sysconf(_SC_CLK_TCK);</span><br><span class="line">        <span class="keyword">if</span> (clockTicks == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sysconf&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clockTime = clock();</span><br><span class="line">    <span class="keyword">if</span> (clockTime == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;clock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; clock() returns: %ld clocks-per-sec (%.2f secs)\n&quot;</span>,</span><br><span class="line">           (<span class="type">long</span>)clockTime, (<span class="type">double</span>)clockTime / CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (times(&amp;t) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;times&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; times() yields: user CPU=%.2f; system CPU: %.2f\n&quot;</span>,</span><br><span class="line">           (<span class="type">double</span>)t.tms_utime / clockTicks, (<span class="type">double</span>)t.tms_stime / clockTicks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numCalls, j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CLOCKS_PER_SEC=%ld sysconf(_SC_CLK_TCK)=%ld\n\n&quot;</span>,</span><br><span class="line">           (<span class="type">long</span>)CLOCKS_PER_SEC, sysconf(_SC_CLK_TCK));</span><br><span class="line"></span><br><span class="line">    displayProcessTimes(<span class="string">&quot;At program start:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    numCalls = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;num-calls&quot;</span>) : <span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numCalls; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        (<span class="type">void</span>)getppid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    displayProcessTimes(<span class="string">&quot;After getppid() loop:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了上述函数的用法。函数<code>displayProcessTimes()</code>会打印参数<code>msg</code>并通过<code>clock()</code>和<code>times()</code>获取的进程时间。主函数在开始时会调用1次<code>displayProcessTimes()</code>，在循环完成后会再次调用该函数。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_09/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第9章 进程凭证"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第9章 进程凭证</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_11/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第11章 系统限制和选项">《Linux/UNIX系统编程手册》第11章 系统限制和选项 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>