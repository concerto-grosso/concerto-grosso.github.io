<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_20/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_20/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_20/","title":"《Linux/UNIX系统编程手册》第20章 信号：基本概念"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第20章 信号：基本概念 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">20.1 信号类型和默认处理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#signal"><span class="nav-text">20.2 signal()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kill%E5%92%8Cpause"><span class="nav-text">20.3 kill()和pause()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="nav-text">20.4 判断进程是否存在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#raise%E5%92%8Ckillpg"><span class="nav-text">20.5 raise()和killpg()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E4%BF%A1%E5%8F%B7%E6%8F%8F%E8%BF%B0"><span class="nav-text">20.6 打印信号描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="nav-text">20.7 信号集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%8E%A9%E7%A0%81"><span class="nav-text">20.8 信号掩码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%85%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7"><span class="nav-text">20.9 待处理信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigaction"><span class="nav-text">20.10 sigaction()</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_20/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第20章 信号：基本概念 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第20章 信号：基本概念</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-03-22 00:00:00" itemprop="dateCreated datePublished" datetime="2025-03-22T00:00:00+08:00">2025-03-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-03-23 00:00:00" itemprop="dateModified" datetime="2025-03-23T00:00:00+08:00">2025-03-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>20k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　<strong>信号</strong>是事件发生时进程收到的通知。信号有时也称为<strong>软件中断</strong>。与硬件中断类似，信号也会中断程序的正常执行流程。在大多数情况下，信号何时达到是无法预测的。</p><p>　　进程 (需要合适的权限) 可以发送信号给其他进程，所以信号可以作为同步技术或进程间通信的原始形式。此外，进程也可以发送信号给自己。但是，在大多数情况下，信号都是由内核发送。以下事件会导致内核发送信号给进程：</p><p>　　● 发生<span style="background-color:#ff0">硬件异常</span> (例如，执行格式错误的机器语言指令、除以0或引用无法访问的内存区域)，这表示硬件检测到故障，并通知内核，然后内核发送对应的信号给相关进程。</p><p>　　● 用户在终端输入<span style="background-color:#ff0">中断字符</span> (通常是Control-C) 和<span style="background-color:#ff0">挂起字符</span> (通常是Control-Z)。</p><p>　　● 发生<span style="background-color:#ff0">软件事件</span> (例如，文件描述符的输入可用、终端窗口的大小被调整、定时器过期、超过进程的CPU时间限制或子进程终止)。</p><p>　　每个信号都有1个唯一的整数编号 (从1开始)。这些编号定义在头文件<code>signal.h</code>中，其符号名为<code>SIGxxxx</code>。信号的编号因实现而异，所以程序中使用的都是对应的符号名。</p><p>　　信号分为2个大类。第1个大类由<span style="background-color:#ff0">传统信号</span>或<span style="background-color:#ff0">标准信号</span>组成，内核使用这些信号来通知进程事件的发生。对于Linux，标准信号的编号是1~31。第2个大类由<span style="background-color:#ff0">实时信号</span>组成。</p><p>　　信号由某些事件生成。随后，信号会传递给进程，进程会采取对应的处理方式来响应。<strong>待处理信号</strong>是已生成但未传递的信号。若目标进程被挂起，则待处理信号会在进程下次调度运行时尽快传递；若目标进程正在运行，则待处理信号会立即传递。</p><p>　　有时，可能需要保证代码块不会被某些信号中断。为此，需要将这些信号添加带进程的<strong>信号掩码</strong> (即当前被阻塞的信号的集合)。若信号生成时已被阻塞，则该信号会一直位于待处理状态，直达目标进程解除阻塞 (将其从信号掩码中删除)。</p><p>　　当信号到达后，进程会根据信号来采取以下默认处理方式之一：</p><p>　　● 忽略信号，即内核会丢弃信号，并且信号对进程没有任何影响 (进程甚至不会知道信号的到达)。</p><p>　　● 终止进程，这种情况也称为<strong>异常进程终止</strong> (与进程通过<code>exit()</code>正常终止相反)。</p><p>　　● 生成核心转储文件，然后终止进程。核心转储文件包含进程的虚拟内存映像，该映像可以加载调试器中，以便检查进程终止时的状态。</p><p>　　● 停止进程，即进程的执行被挂起。</p><p>　　● 进程从停止中恢复执行。</p><p>　　程序可以更改信号到达后的处理方式 (而非以上默认处理方式)，即信号的处理方式。程序可以将信号的处理方式设置为默认处理方式、忽略信号或执行<strong>信号处理函数</strong>。信号处理函数是程序员编写的函数，用于执行合适的任务来响应信号。通知内核调用信号处理函数称为<span style="background-color:#ff0">安装</span>或<span style="background-color:#ff0">注册</span>信号处理函数。若信号处理函数被调用来响应信号，则表示信号已被<span style="background-color:#ff0">处理</span>或<span style="background-color:#ff0">捕获</span>。</p><span id="more"></span><p>　　UNIX系统提供了2种注册信号处理函数的方法，系统调用<code>signal()</code>和<code>sigaction()</code>。前者是注册信号处理函数的原生API，其接口比后者更简单，但后者提供的功能更多。此外，前者的行为可能因UNIX实现而异。考虑到可移植问题，后者是注册信号处理函数的首选API。</p><p>　　无法将信号的处理方式设置为终止进程或生成核心转储文件 (除非是信号的默认处理方式)，只能通过注册调用<code>exit()</code>或<code>abort()</code> (生成信号<code>SIGABRT</code>) 的信号处理函数来模拟这些处理方式。</p><p>　　可以通过特定于Linux的文件<code>/proc/PID/status</code>中的位掩码字段来获取进程如何处理信号。这些位掩码字段展示为十六进制数，最低有效位表示信号1，其左边的第1个位表示信号2，依此类推。这些字段是<code>SigPnd</code> (线程的待处理信号)、<code>ShdPnd</code> (进程的待处理信号，Linux 2.6及以上版本)、<code>SigBlk</code> (阻塞的信号)、<code>SigIgn</code> (忽略的信号) 和<code>SigCgt</code> (捕获的信号)。同样的信息也可以通过命令<code>ps</code>获取。</p><p>　　信号出现在非常早期的UNIX实现中，但自诞生以来已经经历了很多重大变化。在早期实现中，信号在某些情况下可以丢弃 (即不传递给目标进程)。此外，尽管提供了用于在执行关键代码时阻塞信号传递的机制，但阻塞在某些情况下不会生效。这个问题在4.2BSD得到修复，它提供了<span style="background-color:#ff0">可靠信号</span> (BSD的另一项创新是添加了额外的信号来支持shell作业控制)。</p><p>　　System V也为信号添加了可靠的语义，但使用的模型与BSD不兼容。POSIX.1-1990解决了这些不兼容问题，因为POSIX.1-1990采用了主要基于BSD模型的可靠信号规范。</p><h3 id="信号类型和默认处理方式">20.1 信号类型和默认处理方式</h3><p>　　Linux标准信号的编号是1~31，但Linux的信号手册列出的信号名不止31个，多余的信号名功能不尽相同。有些信号名等同于其他信号名，这些信号名是为了保证与其他UNIX实现的源代码级兼容而定义。其他信号名没有实际使用。</p><p>　　● 信号<code>SIGABRT</code>是进程调用<code>abort()</code>时收到的信号。在默认情况下，该信号导致进程生成核心转储文件，然后终止，这正是调用<code>abort()</code>的目的。</p><p>　　● 信号<code>SIGALRM</code>是调用<code>alarm()</code>或<code>settimer()</code>设置的<span style="background-color:#ff0">实时定时器</span> (基于挂钟时间) 过期时内核生成的信号。</p><p>　　● 信号<code>SIGBUS</code> (意为 "总线错误") 表示特定类型的内存访问错误。</p><p>　　● 信号<code>SIGCHLD</code>是进程的子进程终止时收到的信号 (由内核生成)。当进程的子进程被信号停止或恢复时，进程也会收到该信号。</p><p>　　● 信号<code>SIGCLD</code>等同于<code>SIGCHLD</code>。</p><p>　　● 信号<code>SIGCONT</code>用于恢复停止的进程。若进程收到该信号时不处于停止状态，则该信号默认会被忽略。进程可以捕获该信号，以便在恢复时执行某些操作。</p><p>　　● 信号<code>SIGEMT</code>在UNIX系统中通常表示依赖于实现的硬件错误 (后缀<code>EMT</code>源于Digital PDP-11中的汇编助记符emulator trap)。对于Linux，该信号仅用于Sun SPARC实现。</p><p>　　● 信号<code>SIGFPE</code>表示除以0等算术错误 (后缀<code>FPE</code>是floating-point exception的缩写，尽管整数算术错误也会生成该信号)。该信号的具体生成时间取决于硬件架构和CPU控制寄存器的设置。例如，对于x86-32，整数除以0会生成该信号，但浮点数除以0是否生成该信号取决于异常<code>FE_DIVBYZERO</code>是否启用。若通过<code>feenableexcept()</code>启用了该异常，则生成信号<code>SIGFPE</code>；否则，生成IEEE标准的结果 (浮点数形式的无穷大)。</p><p>　　● 信号<code>SIGHUP</code>是终端断开连接时终端的控制进程收到的信号 (后缀<code>HUP</code>是hang up的缩写)。该信号的第2个用途是与守护进程 (例如，<code>init</code>、<code>httpd</code>和<code>inetd</code>) 一起使用，很多守护进程被设计为收到该信号后重新初始化，然后重新读取配置文件。系统管理员可以通过手动发送该信号给守护进程 (命令<code>kill</code>) 来触发这些行为。</p><p>　　● 信号<code>SIGILL</code>是进程试图执行格式错误的机器语言指令时收到的信号。</p><p>　　● 信号<code>SIGINFO</code>在Linux中等同于<code>SIGPWR</code>。对于BSD系统，该信号是用户在终端输入Control-T (获取前台进程组的状态信息) 时生成的信号。</p><p>　　● 信号<code>SIGINT</code>是用户在终端输入中断字符时终端驱动程序发送给前台进程组的信号。该信号的默认处理方式是终止进程。</p><p>　　● 信号<code>SIGIO</code>是调用<code>fcntl()</code>对特定类型的打开的文件描述符 (例如，用于终端和套接字的打开的文件描述符) 执行某些操作后，文件描述符的I/O事件 (例如，输入可用) 生成的信号。</p><p>　　● 信号<code>SIGIOT</code>在Linux中等同于<code>SIGABRT</code>。对于部分UNIX实现，该信号表示实现定义的硬件故障。</p><p>　　● 信号<code>SIGKILL</code>会终止进程，并且无法被阻塞、忽略或捕获。</p><p>　　● 信号<code>SIGLOST</code>在Linux中未使用。对于有些UNIX实现，若NFS客户端在恢复崩溃的远程NFS服务器时无法重新获取本地进程持有的锁，则NFS客户端会发送该信号给这些本地进程 (该特性没有被NFS规范标准化)。</p><p>　　● 信号<code>SIGPIPE</code>是发送进程试图写没有接收进程的有名管道、无名管道或套接字时生成的信号。这通常是因为接收进程关闭了其IPC通道的文件描述符。</p><p>　　● 信号<code>SIGPOLL</code>在Linux中等同于<code>SIGIO</code> (源于System V)。</p><p>　　● 信号<code>SIGPROF</code>是调用<code>settimer()</code>设置的<span style="background-color:#ff0">剖析定时器</span> (基于进程使用的CPU时间) 过期时内核生成的信号。与虚拟定时器不同，剖析定时器计算进程在用户模式和内核模式下所用的CPU时间。</p><p>　　● 信号<code>SIGPWR</code>是<span style="background-color:#ff0">电源故障</span>信号。对于带有不间断电源 (UPS) 的系统，可以设置1个用于在发生电源故障事件时监控备用电池的守护进程。若电池电量即将耗尽 (长时间停电)，则监控进程会发送该信号给进程<code>init</code>，进程<code>init</code>会将该信号视为以快速有序的方式关闭系统的请求。</p><p>　　● 信号<code>SIGQUIT</code>是用户在终端输入<span style="background-color:#ff0">退出字符</span> (通常是Control-\) 时前台进程组收到的信号。在默认情况下，该信号会让进程生成核心转储文件，然后终止。当进程陷入无限循环或无响应时，通过这种方式使用该信号很有用。通过输入Control-\生成核心转储文件，并使用gdb加载核心转储文件，然后通过命令<code>backtrace</code>来获取栈追踪，就可以获取程序代码的哪一部分正在执行。</p><p>　　● 信号<code>SIGSEGV</code>是程序引用无效地址时生成的信号 (后缀<code>EGV</code>源于术语segmentation violation)。程序引用的地址无效可能是因为引用的页不存在 (例如，该页位于堆与栈之间某个未映射的区域)、进程试图更新只读内存的数据 (例如，程序文本段或映射为只读的内存区域) 或进程试图在用户模式下访问内核内存。在C中，这些事件通常是由于解引用包含错误地址的指针 (例如，未初始化的指针) 或在函数调用中传递无效参数。</p><p>　　● 信号<code>SIGSTKFLT</code>在Linux中未使用 (手册中记录为 "协处理器的栈故障")。</p><p>　　● 信号<code>SIGSTOP</code>会停止进程，并且无法被阻塞、忽略或捕获。</p><p>　　● 信号<code>SIGSYS</code>是进程调用无效系统调用时生成的信号。这表示进程执行的指令会被解释为系统调用陷阱，但关联的系统调用号无效。</p><p>　　● 信号<code>SIGTERM</code>是用于终止进程的标准信号，默认由命令<code>kill</code>和<code>killall</code>发送。用户可以通过命令<code>kill -9</code>或<code>kill -KILL</code>显式发送信号<code>SIGKILL</code>来终止进程。但是，这种行为通常是<span style="background-color:#ff0">错误</span>的，因为精心设计的应用程序会包含<code>SIGTERM</code>处理函数，该处理函数会让应用程序正常退出，清理临时文件并提前释放其他资源。通过信号<code>SIGKILL</code>终止进程会绕过<code>SIGTERM</code>处理函数。因此，终止进程的首选信号是<code>SIGTERM</code>。</p><p>　　● 信号<code>SIGTRAP</code>用于实现调试器断点和系统调用追踪。</p><p>　　● 信号<code>SIGTSTP</code>是作业控制停止信号 (后缀<code>TSTP</code>源于术语terminal stop)，当用户在终端输入挂起字符时，前台进程组会收到该信号。</p><p>　　● 信号<code>SIGTTIN</code>是作业控制shell下运行的后台进程组中的进程试图对终端调用<code>read()</code>时终端驱动程序发送给该后台进程组的信号。该信号默认会停止进程。</p><p>　　● 信号<code>SIGTTOU</code>与<code>SIGTTIN</code>类似，但用于后台作业的终端输出。对于在作业控制shell下运行的后台进程组，若终端启用了选项<code>TOSTOP</code> (终端输出停止)，则该后台进程组的进程试图对终端调用<code>write()</code>时终端驱动程序会发送该信号给该后台进程组。该信号默认会停止进程。</p><p>　　● 信号<code>SIGUNUSED</code>未使用。对于Linux 2.4及以上版本，该信号在很多架构上等同于<code>SIGSYS</code>。换句话说，该信号不再未使用，尽管保留该信号是为了向后兼容性。</p><p>　　● 信号<code>SIGURG</code>表示套接字中存在紧急数据。</p><p>　　● 信号<code>SIGUSR1</code>和<code>SIGUSR2</code>可用于程序员定义的用途。内核永远不会为进程生成这2个信号。进程可以通过这2个信号来通知彼此事件或相互同步。对于早期UNIX实现，这2个信号是仅有的可以在应用程序中随意使用的信号 (实际上，进程发送任意信号给其他进程，但这可能会与内核发送给该进程相同的信号混淆)。现代UNIX实现提供了大量可用于程序员定义的用途的实时信号。</p><p>　　● 信号<code>SIGVTALRM</code>是调用<code>setitimer()</code>设置的<span style="background-color:#ff0">虚拟定时器</span> (基于进程使用的用户模式CPU时间) 过期时内核生成的信号。</p><p>　　● 信号<code>SIGWINCH</code>是窗口环境下的终端窗口大小改变时发送给前台进程组的信号。通过注册处理函数，<code>vi</code>和<code>less</code>等程序可以知道在窗口大小改变后刷新输出。</p><p>　　● 信号<code>SIGXCPU</code>是进程超过其CPU时间资源限制时收到的信号。</p><p>　　● 信号<code>SIGXFSZ</code>是进程试图将文件大小增加到大于其文件大小资源限制的值时收到的信号。</p><p>　　下表是对各种Linux信号的总结 (信号编号行中的S表示Sun SPARC和SPARC64，A表示HP/Compaq/Digital Alpha，M表示MIPS，P表示HP PA-RISC。默认处理方式行中的core表示进程会生成核心转储文件并终止，term表示终止进程，ignore表示忽略信号，stop表示停止进程，cont表示恢复停止的进程)：</p><table><colgroup><col style="width:20%"><col style="width:34%"><col style="width:24%"><col style="width:6%"><col style="width:14%"></colgroup><thead><tr><th>信号名</th><th>信号编号</th><th>描述</th><th>SUSv3</th><th>默认处理方式</th></tr></thead><tbody><tr><td><code>SIGABRT</code></td><td>6</td><td>中止进程</td><td>✓</td><td>core</td></tr><tr><td><code>SIGALRM</code></td><td>14</td><td>实时定时器过期</td><td>✓</td><td>term</td></tr><tr><td><code>SIGBUS</code></td><td>7 (SAMP = 10)</td><td>内存访问错误</td><td>✓</td><td>core</td></tr><tr><td><code>SIGCHLD</code></td><td>17 (SA = 20，MP = 18)</td><td>子进程终止或停止</td><td>✓</td><td>ignore</td></tr><tr><td><code>SIGCONT</code></td><td>18 (SA = 19，MP = 25，P = 26)</td><td>恢复停止的进程</td><td>✓</td><td>cont</td></tr><tr><td><code>SIGEMT</code></td><td>未定义 (SAMP = 7)</td><td>硬件故障</td><td></td><td>term</td></tr><tr><td><code>SIGFPE</code></td><td>8</td><td>算术异常</td><td>✓</td><td>core</td></tr><tr><td><code>SIGHUP</code></td><td>1</td><td>终端断开链接</td><td>✓</td><td>term</td></tr><tr><td><code>SIGILL</code></td><td>4</td><td>格式错误的指令</td><td>✓</td><td>core</td></tr><tr><td><code>SIGINT</code></td><td>2</td><td>终端中断</td><td>✓</td><td>term</td></tr><tr><td><code>SIGIO</code>/<code>SIGPOLL</code></td><td>29 (SA = 23，MP = 22)</td><td>I/O可用</td><td>✓</td><td>term</td></tr><tr><td><code>SIGKILL</code></td><td>9</td><td>终止进程</td><td>✓</td><td>term</td></tr><tr><td><code>SIGPIPE</code></td><td>13</td><td>不完整的管道</td><td>✓</td><td>term</td></tr><tr><td><code>SIGPROF</code></td><td>27 (M = 29，P = 21)</td><td>剖析定时器过期</td><td>✓</td><td>term</td></tr><tr><td><code>SIGPWR</code></td><td>30 (SA = 29，MP = 19)</td><td>电源即将耗尽</td><td></td><td>term</td></tr><tr><td><code>SIGQUIT</code></td><td>3</td><td>终端退出</td><td>✓</td><td>core</td></tr><tr><td><code>SIGSEGV</code></td><td>11</td><td>无效内存引用</td><td>✓</td><td>core</td></tr><tr><td><code>SIGSTKFLT</code></td><td>16 (SAM = 未定义，P = 36)</td><td>协处理器的栈故障</td><td></td><td>term</td></tr><tr><td><code>SIGSTOP</code></td><td>19 (SA = 17，M = 23，P = 24)</td><td>停止进程</td><td>✓</td><td>stop</td></tr><tr><td><code>SIGSYS</code></td><td>31 (SAMP = 12)</td><td>无效系统调用</td><td>✓</td><td>core</td></tr><tr><td><code>SIGTERM</code></td><td>15</td><td>终止进程</td><td>✓</td><td>term</td></tr><tr><td><code>SIGTRAP</code></td><td>5</td><td>追踪/断点陷阱</td><td>✓</td><td>core</td></tr><tr><td><code>SIGTSTP</code></td><td>20 (SA = 18，M = 24，P = 25)</td><td>终端停止</td><td>✓</td><td>stop</td></tr><tr><td><code>SIGTTIN</code></td><td>21 (M = 26，P = 27)</td><td>后台进程组读终端</td><td>✓</td><td>stop</td></tr><tr><td><code>SIGTTOU</code></td><td>22 (M = 27，P = 28)</td><td>后台进程组写终端</td><td>✓</td><td>stop</td></tr><tr><td><code>SIGURG</code></td><td>23 (SA = 16，M = 21，P = 29)</td><td>套接字中存在紧急数据</td><td>✓</td><td>ignore</td></tr><tr><td><code>SIGUSR1</code></td><td>10 (SA = 30，MP = 16)</td><td>用户定义的信号1</td><td>✓</td><td>term</td></tr><tr><td><code>SIGUSR2</code></td><td>12 (SA = 31，MP = 17)</td><td>用户定义的信号2</td><td>✓</td><td>term</td></tr><tr><td><code>SIGVTALRM</code></td><td>26 (M = 28，P = 20)</td><td>虚拟定时器过期</td><td>✓</td><td>term</td></tr><tr><td><code>SIGWINCH</code></td><td>28 (M = 20，P = 23)</td><td>终端窗口大小改变</td><td></td><td>ignore</td></tr><tr><td><code>SIGXCPU</code></td><td>24 (M = 30，P = 33)</td><td>超过CPU时间限制</td><td>✓</td><td>core</td></tr><tr><td><code>SIGXFSZ</code></td><td>25 (M = 31，P = 34)</td><td>超过文件大小限制</td><td>✓</td><td>core</td></tr></tbody></table><p>　　● 对于Linux 2.2，信号<code>SIGBUS</code>、<code>SIGSYS</code>、<code>SIGXCPU</code>和<code>SIGXFSZ</code>的默认处理方式是终止进程 (不生成核心转储文件)。Linux从2.4开始遵循SUSv3，这些信号会导致进程生成核心转储文件并终止。对于有些UNIX实现，信号<code>SIGXCPU</code>和<code>SIGXFSZ</code>的默认处理方式是终止进程 (不生成核心转储文件)。</p><p>　　● 对于有些UNIX实现，信号<code>SIGPWR</code>默认会被忽略。</p><p>　　● 对于有些UNIX实现 (尤其是BSD衍生实现)，信号<code>SIGIO</code>默认会被忽略。</p><p>　　● 尽管没有任何标准说明信号<code>SIGEMT</code>，但大多数UNIX实现都提供了该信号。对于部分UNIX实现，该信号会导致进程生成核心转储文件并终止。</p><p>　　● 对于SUSv1，信号<code>SIGURG</code>的默认处理方式是终止进程，并且有些较旧的UNIX实现也是如此。SUSv2将该信号的默认处理方式修改为忽略信号。</p><h3 id="signal">20.2 <code>signal()</code></h3><p>　　对于Linux，<code>signal()</code>在glibc中被实现为基于系统调用<code>sigaction()</code>的库函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> sig, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>); <span class="comment">/* 成功时返回目标信号的旧处理方式，出错时返回SIG_ERR */</span></span><br></pre></td></tr></table></figure><p>　　参数<code>sig</code>是目标信号。参数<code>handler</code>是<code>SIG_DFL</code>、<code>SIG_IGN</code>或信号处理函数的地址。<code>SIG_DFL</code>表示将信号的处理方式恢复到默认处理方式，<code>SIG_IGN</code>表示将信号的处理方式修改为忽略信号。</p><p>　　<code>signal()</code>的函数原型等同于如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> sig, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure><p>　　若定义了功能测试宏<code>_GNU_SOURCE</code>，则非标准数据类型<code>sighandler_t</code>会出现在头文件<code>signal.h</code>中。</p><p>　　若<code>signal()</code>成功，则会返回目标信号的旧处理方式；否则，返回<code>SIG_ERR</code> (即-1)。因此，可以临时修改信号的处理方式，然后恢复：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*oldHandler)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">oldHandler = signal(SIGINT, newHandler);</span><br><span class="line"><span class="keyword">if</span> (oldHandler == SIG_ERR)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal(SIGINT, oldHandler) == SIG_ERR)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<strong>信号处理函数</strong> (也称为<strong>信号捕获函数</strong>) 是在进程收到特定信号时调用的函数。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_20/signal_delivery_and_handler_execution.svg" title="signal_delivery_and_handler_execution"><p>　　信号处理函数的调用可能随时中断主程序流。内核会代表进程调用处理函数，并且当处理函数返回时，程序会在处理函数中断的位置恢复执行。</p><p>　　尽管信号处理函数几乎可以做任何事情，但一般而言，它们应该设计得尽可能简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* intquit.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数 (printf()和exit())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Caught SIGINT (%d)\n&quot;</span>, count);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* 返回到中断点 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught SIGQUIT - that&#x27;s all folks!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 为信号SIGINT和SIGQUIT注册相同的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sigHandler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGQUIT, sigHandler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) <span class="comment">/* 无限循环 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        pause(); <span class="comment">/* 阻塞，直到捕获信号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序会为信号<code>SIGINT</code>和<code>SIGQUIT</code>注册相同的处理函数。但是，在实际应用程序中，应避免在处理函数中调用stdio函数，因为它们不是异步信号安全的。</p><p>　　<code>signal()</code>无法在不修改当前信号的处理方式的前提下检索当前信号的处理方式，但<code>sigaction()</code>可以做到这一点。</p><h3 id="kill和pause">20.3 <code>kill()</code>和<code>pause()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　进程可以通过系统调用<code>kill()</code>来发送信号给其他进程 (等同于命令<code>kill</code>)。选择kill作为名称是因为早期UNIX实现上大多数可用的信号的默认处理方式都是终止进程。</p><p>　　参数<code>pid</code>用于标识目标进程。参数<code>sig</code>是发送给目标进程的信号。</p><p>　　● 若<code>pid</code>大于0，则信号会发送给进程ID为<code>pid</code>的进程。</p><p>　　● 若<code>pid</code>等于0，则信号会发送给调用进程所属的进程组的所有进程，包括调用进程。SUSv3要求信号的目标进程是整个进程组时应该排除 "未指定的系统进程集"，并且也对剩余情况施加了同样的限制。</p><p>　　● 若<code>pid</code>等于-1，则信号会发送给调用进程有权发送信号的所有进程，除了进程<code>init</code> (进程ID为1) 和调用进程自己。因此，这种发送信号的方式也称为<strong>广播信号</strong>。若特权进程以这种方式调用<code>kill()</code>，则会发送信号给除特权进程自己和<code>init</code>之外的所有进程。SUSv3不要求在这种情况下排除调用进程，但Linux在这方面遵从BSD语义。</p><p>　　● 若<code>pid</code>小于-1，则信号会发送给进程组ID为<code>pid</code>的绝对值的进程组的所有进程。</p><p>　　若没有符号条件的进程，则<code>kill</code>会失败，并将<code>errno</code>设置为<code>ESRCH</code>。</p><p>　　进程需要合适的权限才能发送信号给其他进程，权限规则如下：</p><p>　　● 特权进程 (能力<code>CAP_KILL</code>) 可以发送信号给任意进程。</p><p>　　● 进程<code>init</code>是特例，唯一可以发送给进程<code>init</code>的信号是那些进程<code>init</code>已显式注册处理函数的信号。这是为了防止系统管理员意外地终止该进程。</p><p>　　● 对于非特权进程，需要其<span style="background-color:#ff0">实际用户ID或有效用户ID匹配接收进程的实际用户ID或保存的set-user-ID</span>。此规则允许用户发送信号给自己启动的set-user-ID程序。匹配时排除接收进程的有效用户ID是为了防止用户A发送信号给用户B的正在运行用户A的set-user-ID程序的进程。SUSv3的要求也是如此，但Linux 2.0及以下版本的行为略有不同。</p><p>　　● 信号<code>SIGCONT</code>是特例。非特权进程可以发送该信号给同一会话中的其他进程。此规则允许作业控制shell恢复停止的任务 (进程组)，即使作业的进程已经修改了其用户ID。</p><p>　　若调用进程没有发送信号给<code>pid</code>指定的进程的权限，则<code>kill()</code>会失败，并将<code>error</code>设置为<code>EPERM</code>。若<code>pid</code>指定的是多个进程 (即负值)，则只要进程能够发送信号给其中的1个进程，<code>kill()</code>就会成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 总是会返回-1，并将errno设置为EINTR */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>pause()</code>会挂起调用进程，直到被信号处理函数中断或进程被信号终止。对于前者，该函数会返回-1，并将<code>errno</code>设置为<code>EINTR</code>。</p><h3 id="判断进程是否存在">20.4 判断进程是否存在</h3><p>　　系统调用<code>kill()</code>还可以用于其他目的。若将参数<code>sig</code>指定为0，则不会发送信号。相反，<code>kill()</code>只会执行错误检查，以判断是否可以向目标进程发送信号。因此，可以通过这种方式判断进程是否存在，若<code>kill()</code>将<code>error</code>设置为<code>ESRCH</code>，则目标进程不存在；否则，目标进程存在。</p><p>　　特定进程ID的存在并不保证特定的程序正在运行。因为随着进程的创建和终止，内核会回收进程ID，这表示进程ID一段时间后可能引用不同的进程。此外，即使进程ID存在，对应的进程还可能是僵尸进程 (进程已终止，但父进程还没有通过系统调用<code>wait()</code>来获取其终止状态)。</p><p>　　还可以通过系统调用<code>wait()</code>、信号量和文件锁、IPC通道以及<code>/proc/PID</code>接口来判断特定进程是否正在运行：</p><p>　　● 系统调用<code>wait()</code>可以用于判断子进程是否存在。</p><p>　　● 若目标进程持有信号量或文件锁，则只有在该进程终止后才能获取信号量或文件锁。</p><p>　　● 将目标进程设置为持有IPC通道的写描述符，若持有读描述符的进程读到EOF，则表示目标进程已终止。</p><p>　　● 目录<code>/proc/PID</code>只有在对应的进程存在时才会存在，所以可以通过合适的调用 (例如，<code>stat()</code>) 来判断进程是否存在。</p><p>　　除了最后1个方法之外，其他方法都不受到进程ID回收的影响。</p><h3 id="raise和killpg">20.5 <code>raise()</code>和<code>killpg()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>; <span class="comment">/* 成功时返回0，出错时返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">killpg</span><span class="params">(<span class="type">pid_t</span> pgrp, <span class="type">int</span> sig)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>raise()</code>会发送参数<code>sig</code>指定的信号给调用进程。该函数只会在<code>sig</code>无效时才会出错 (<code>EINVAL</code>)，并返回非0值。</p><p>　　当进程发送信号给自己时 (通过<code>kill()</code>或<code>raise()</code>)，信号会立即传递 (在从<code>raise</code>返回之前)。</p><p>　　对于单线程程序，<code>raise(sig)</code>等同于<code>kill(gitpid(), sig)</code>。对于支持多线程的系统，<code>raise(sig)</code>等同于<code>pthread_kill(pthread_self(), sig)</code>。</p><p>　　<code>raise()</code>源于C89。C标准不涵盖进程ID等操作系统细节，但C标准说明了<code>raise()</code>，因为该函数不需要指定进程ID。</p><p>　　函数<code>killpg()</code>会发送参数<code>sig</code>指定的信号给参数<code>pgrp</code>指定的进程组的所有进程。<code>killpg(pgrp, sig)</code>等同于<code>kill(-pgrp, sig)</code>。</p><p>　　若<code>pgrp</code>为0，则信号会发送给调用进程所属的进程组的所有进程。SUSv3没有说明这一点，但大多数UNIX实现在这一点上与Linux相同。</p><h3 id="打印信号描述">20.6 打印信号描述</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> sys_siglist[];</span><br></pre></td></tr></table></figure><p>　　每个信号都有1个关联的可打印描述，这些描述存储在数组<code>sys_siglist</code> (例如，<code>sys_siglist[SIGPIPE]</code>是信号<code>SIGPIPE</code>的描述)。但是，函数<code>strsignal()</code>是打印信号描述的首选。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strsignal</span><span class="params">(<span class="type">int</span> sig)</span>; <span class="comment">/* 返回信号描述字符串 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>strsignal()</code>会对参数<code>sig</code>边界检查，然后返回信号描述字符串。若<code>sig</code>无效，则返回错误字符串 (有些UNIX实现在这种情况下会返回<code>NULL</code>)。</p><p>　　除了边界检查之外，<code>strsignal()</code>返回的字符串会受到区域设置的影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">psignal</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="type">char</span> *msg)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>psignal()</code>会在标准错误中打印参数<code>msg</code>指定的字符串加上冒号和参数<code>sig</code>对应的信号描述字符串。与<code>strsignal()</code>相同，该函数也会受到区域设置的影响。</p><p>　　尽管<code>sys_siglist</code>、<code>strsignal()</code>和<code>psignal()</code>没有被SUSv3标准化，但很多UNIX实现都提供了这个数组和这2个函数 (SUSv4添加了<code>strsignal()</code>和<code>psignal()</code>的规范)。</p><h3 id="信号集">20.7 信号集</h3><p>　　多个信号可以用称为<strong>信号集</strong>的数据结构表示，对应的数据类型是<code>sigset_t</code>。对于Linux和大多数UNIX实现，<code>sigset_t</code>被实现为位掩码，但SUSv3没有说明这一点，只要求该数据类型是可赋值的。因此，该数据类型只能被实现为标量类型 (例如，整数类型) 或结构体。</p><p>　　SUSv3详细说明了以下控制信号集的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> sig)</span>; <span class="comment">/* sig属于set时返回1，否则返回0 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>sigemptyset()</code>会将参数<code>set</code>指向的信号集初始化为空信号集。函数<code>sigfillset()</code>会将参数<code>set</code>指向的信号集初始化为包含所有信号的信号集。</p><p>　　C不会初始化自动变量，并且静态变量的自动初始化为0也不能保证新信号集是空集合 (因为信号集可能被实现为结构体。同样，使用<code>memset()</code>将信号集设置为0也是不正确的)，所以使用信号集前<span style="background-color:#ff0">必须</span>先通过<code>sigemptyset()</code>或<code>sigfillset()</code>初始化它。</p><p>　　在初始化信号集后，可以通过函数<code>sigaddset()</code>和<code>sigdelset()</code>来添加和删除信号 (参数<code>sig</code>)。</p><p>　　若参数<code>sig</code>指定的信号属于参数<code>set</code>指向的信号集，则<code>sigismember()</code>返回1；否则，返回0。</p><p>　　glibc实现了3个非标准函数，这些函数执行与以上函数互补的任务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigandset</span><span class="params">(<span class="type">sigset_t</span> *dset, <span class="type">sigset_t</span> *left, <span class="type">sigset_t</span> *right)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigorset</span><span class="params">(<span class="type">sigset_t</span> *dest, <span class="type">sigset_t</span> *left, <span class="type">sigset_t</span> *right)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigisemptyset</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">/* set为空时返回1，否则返回0 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>sigandset()</code>会将参数<code>left</code>指向的信号集和参数<code>right</code>指向的信号集的交集放置在参数<code>dset</code>指向的信号集中。</p><p>　　函数<code>sigandset()</code>会将参数<code>left</code>指向的信号集和参数<code>right</code>指向的信号集的并集放置在参数<code>dest</code>指向的信号集中。</p><p>　　函数<code>sigisemptyset()</code>会判断参数<code>set</code>指向的信号集是否为空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* signal_functions.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;signal_functions.h&quot;</span> <span class="comment">/* 函数声明在该头文件中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下函数调用了非异步信号安全函数fprintf()，所以这些函数也不是异步信号安全的 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印信号集中的所有信号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param of</span></span><br><span class="line"><span class="comment"> * @param prefix</span></span><br><span class="line"><span class="comment"> * @param sigset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printSigset</span><span class="params">(FILE *of, <span class="type">const</span> <span class="type">char</span> *prefix, <span class="type">const</span> <span class="type">sigset_t</span> *sigset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sig, cnt;</span><br><span class="line"></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (sig = <span class="number">1</span>; sig &lt; NSIG; sig++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sigismember(sigset, sig))</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">fprintf</span>(of, <span class="string">&quot;%s%d (%s)\n&quot;</span>, prefix, sig, strsignal(sig));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(of, <span class="string">&quot;%s&lt;empty signal set&gt;\n&quot;</span>, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印进程的信号掩码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param of</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printSigMask</span><span class="params">(FILE *of, <span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> currMask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(of, <span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, <span class="literal">NULL</span>, &amp;currMask) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printSigset(of, <span class="string">&quot;\t\t&quot;</span>, &amp;currMask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印进程的当前待处理信号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param of</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printPendingSigs</span><span class="params">(FILE *of, <span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> pendingSigs;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(of, <span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigpending(&amp;pendingSigs) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printSigset(of, <span class="string">&quot;\t\t&quot;</span>, &amp;pendingSigs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了上述函数的用法。函数<code>printSigset()</code>会打印指定信号集中的所有信号，该函数使用了常量<code>NSIG</code>作为循环的上限，该常量定义在头文件<code>signal.h</code>中，其值比最大信号编号大1。</p><p>　　函数<code>printSigMask()</code>和<code>printPendingSigs()</code>会调用<code>printSigset()</code>来分别打印进程的信号掩码和当前待处理信号集。</p><p>　　SUSv3没有说明常量<code>NSIG</code>，但大多数UNIX实现都提供了该常量。此外，可能需要使用特定于实现的编译器选项来让该常量可见。例如，对于Linux，需要定义功能测试宏<code>_BSD_SOURCE</code>、<code>_SVID_SOURCE</code>或<code>_GNU_SOURCE</code>。</p><h3 id="信号掩码">20.8 信号掩码</h3><p>　　内核会为每个进程都维护1个信号掩码 (信号掩码实际上是线程级属性，线程可以通过函数<code>pthread_sigmask()</code>来查看和修改其信号掩码)。</p><p>　　信号可以通过以下方式添加到信号掩码：</p><p>　　● 当调用信号处理函数时，对应的信号会自动添加到信号掩码。</p><p>　　● 当通过<code>sigaction()</code>注册信号处理函数时，可以指定调用该信号处理函数时额外阻塞的信号。</p><p>　　● 系统调用<code>sigprocmask()</code>可用于显式地在信号掩码中添加和删除信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>sigprocmask()</code>可用于修改或/和检索进程的信号掩码。参数<code>how</code>决定如何修改信号掩码，只能指定为<code>SIG_BLOCK</code>、<code>SIG_UNBLOCK</code>或<code>SIG_SETMASK</code>。</p><p>　　● <code>SIG_BLOCK</code>表示将参数<code>set</code>指向的信号集添加到信号掩码，即信号掩码会设置为当前信号掩码与<code>set</code>指向的信号集的并集。</p><p>　　● <code>SIG_UNBLOCK</code>表示从信号掩码中删除参数<code>set</code>指向的信号集。<code>set</code>指向的信号集中包含未阻塞的信号不会导致错误。</p><p>　　● <code>SIG_SETMASK</code>表示将参数<code>set</code>指向的信号集赋值给信号掩码。</p><p>　　若参数<code>oldset</code>不是<code>NULL</code>，则它指向的信号集会用于存储信号掩码的旧值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> blockSet, prevMask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化信号集，并将信号SIGINT添加到该信号集 */</span></span><br><span class="line">sigemptyset(&amp;blockSet);</span><br><span class="line">sigaddset(&amp;blockSet, SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阻塞信号SIGINT */</span></span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;blockSet, &amp;prevMask) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigprocmask1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 解除阻塞信号SIGINT */</span></span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;prevMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigprocmask2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会临时阻塞信号<code>SIGINT</code>。</p><p>　　SUSv3规定，若通过<code>sigprocmask()</code>解除阻塞待处理信号，则待处理信号会立即传递给进程。</p><p>　　通过<code>sigprocmask()</code>阻塞信号<code>SIGKILL</code>和<code>SIGSTOP</code>不会生效，并且不会导致错误。因此，可以通过以下方式来阻塞除这2个信号之外的所有信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sigfillset(&amp;blockSet);</span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;blockSet, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="待处理信号">20.9 待处理信号</h3><p>　　若接收信号的进程阻塞了信号，则信号会被添加到接收进程的待处理信号集。当信号稍后被解除阻塞时，信号会传递给进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>sigpending()</code>会将调用进程的待处理信号集存储在参数<code>set</code>指向的信号集中。</p><p>　　若被阻塞的信号的处理方式是被忽略，则该信号生成后<span style="background-color:#ff0">不会</span>添加到待处理信号集，所以也不会传递。</p><p>　　待处理信号集只是1个掩码。即使被阻塞的信号多次生成，该信号也只会在待处理信号集中记录1次，并且后续只会传递1次 (这仅适用于标准信号，实时信号依旧会排队)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sig_sender.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numSigs, sig, j;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pid num-sigs sig-num [sig-num-2]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = getLong(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;PID&quot;</span>);</span><br><span class="line">    numSigs = getInt(argv[<span class="number">2</span>], GN_GT_0, <span class="string">&quot;num-sigs&quot;</span>);</span><br><span class="line">    sig = getInt(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="string">&quot;sig-num&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送信号到目标进程 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: sending signal %d to process %ld %d times\n&quot;</span>,</span><br><span class="line">           argv[<span class="number">0</span>], sig, (<span class="type">long</span>)pid, numSigs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numSigs; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (kill(pid, sig) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若指定了第4个命令行参数，则发送对应的信号 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (kill(pid, getInt(argv[<span class="number">4</span>], <span class="number">0</span>, <span class="string">&quot;sig-num-2&quot;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: exiting\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序有4个命令行参数。第1个命令行参数表示目标进程的进程ID。第2个命令行参数表示发送给目标进程的信号数。第3个命令行参数表示发送给目标进程的信号。若指定了第4个命令行参数，则在发送完第3个命令行参数指定的信号后会发送1次该命令行参数指定的信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sig_receiver.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;signal_functions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sigCnt[NSIG];                    <span class="comment">/* 记录接收到的信号数 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> gotSigint = <span class="number">0</span>; <span class="comment">/* 收到SIGINT时设置为非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT)</span><br><span class="line">    &#123;</span><br><span class="line">        gotSigint = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sigCnt[sig]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, numSecs;</span><br><span class="line">    <span class="type">sigset_t</span> pendingMask, blockingMask, emptyMask;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: PID is %ld\n&quot;</span>, argv[<span class="number">0</span>], (<span class="type">long</span>)getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; NSIG; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 所有信号都注册相同的处理函数 */</span></span><br><span class="line">        (<span class="type">void</span>)signal(n, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若指定了睡眠时间，则临时阻塞所有信号并睡眠，然后打印待处理信号的掩码和解除阻塞所有信号 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        numSecs = getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        sigfillset(&amp;blockingMask);</span><br><span class="line">        <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;blockingMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: sleeping for %d seconds\n&quot;</span>, argv[<span class="number">0</span>], numSecs);</span><br><span class="line">        sleep(numSecs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sigpending(&amp;pendingMask) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigpending&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: pending signals are: \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        printSigset(<span class="built_in">stdout</span>, <span class="string">&quot;\t\t&quot;</span>, &amp;pendingMask);</span><br><span class="line"></span><br><span class="line">        sigemptyset(&amp;emptyMask); <span class="comment">/* 解除阻塞所有信号 */</span></span><br><span class="line">        <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;emptyMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!gotSigint) <span class="comment">/* 循环，直到收到信号SIGINT */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; NSIG; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 打印收到的信号数 */</span></span><br><span class="line">        <span class="keyword">if</span> (sigCnt[n] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: signal %d caught %d time%s\n&quot;</span>, argv[<span class="number">0</span>], n,</span><br><span class="line">                   sigCnt[n], (sigCnt[n] == <span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;s&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序会捕获<code>sig_sender.c</code>发送的信号，并打印相关数据。这个程序会执行如下步骤：</p><p>　　● 在第29~33行，程序会对所有信号都注册相同的处理函数 (信号<code>SIGKILL</code>和<code>SIGSTOP</code>无法捕获，但这里忽略了注册信号处理函数时可能出现的错误)。对于大多数信号，信号处理函数只会通过数组对其计数。若捕获的信号是<code>SIGINT</code>，则会设置让程序退出主循环的标志<code>gotSigint</code>。</p><p>　　● 在第35~62行，若提供了命令行参数，则程序会在命令行参数指定的秒数内阻塞所有信号，然后解除阻塞这些信号，并打印待处理信号集。</p><p>　　● 在第64~67行，程序会一直进行<code>while</code>循环，直到标志<code>gotSigint</code>为1。</p><p>　　● 在第69~77行，当<code>while</code>循环完成后，程序会打印收到的所有信号的数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./sig_receiver 15 &amp;</span></span><br><span class="line">[1] 5368</span><br><span class="line">./sig_receiver: PID is 5368</span><br><span class="line">./sig_receiver: sleeping for 15 seconds</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./sig_sender 5368 1000000 10 2</span></span><br><span class="line">./sig_sender: sending signal 10 to process 5368 1000000 times</span><br><span class="line">./sig_sender: exiting</span><br><span class="line">./sig_receiver: pending signals are:</span><br><span class="line">                2 (Interrupt)</span><br><span class="line">                10 (User defined signal 1)</span><br><span class="line">./sig_receiver: signal 10 caught 1 time</span><br><span class="line">[1]  + done       ./sig_receiver 15</span><br></pre></td></tr></table></figure><p>　　这个示例中会先运行信号接收程序，并将命令行参数指定为15 (睡眠15秒)。然后，运行信号发送程序，发送1000000次信号10，再发送1次信号2。从结果可以看出，信号接收程序仅收到了1次信号10。</p><h3 id="sigaction">20.10 <code>sigaction()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">        <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    &#125; __sigaction_handler; <span class="comment">/* 处理函数的地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_handler __sigaction_handler.sa_handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sa_sigaction __sigaction_handler.sa_sigaction</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;          <span class="comment">/* 调用处理函数期间阻塞的信号 */</span></span><br><span class="line">    <span class="type">int</span> sa_flags;              <span class="comment">/* 控制信号处理函数行为的标志 */</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>); <span class="comment">/* 不供应用程序使用 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>sigaction()</code>会为参数<code>sig</code>指定的信号 (除了信号<code>SIGKILL</code>和<code>SIGSTOP</code>) 注册参数<code>act</code>指定的信号处理函数，信号的旧处理方式会存储在参数<code>oldact</code>指向的结构体中。若仅需要获取信号的当前处理方式，则可以将<code>act</code>指定为<code>NULL</code>。若仅需要修改信号的处理方式，则可以将<code>oldact</code>指定为<code>NULL</code>。</p><p>　　结构体<code>sigaction</code>使用共用体<code>__sigaction_handler</code>来合并成员<code>sa_handler</code>和<code>sa_sigaction</code>，因为在调用该系统调用时只会指定其中之一 (大多数UNIX实现也是如此)。成员<code>sa_handler</code>与<code>signal()</code>的参数<code>handler</code>相同 (可以是<code>SIG_DFL</code>、<code>SIG_IGN</code>或信号处理函数的地址)。成员<code>sa_mask</code>是信号集，指定调用处理函数期间阻塞的信号。当调用信号处理函数时，属于该信号集但不属于信号掩码的信号会自动添加到信号掩码，这些信号会在信号处理函数返回时自动从信号掩码中删除。成员<code>sa_flags</code>用于控制信号处理函数的行为。成员<code>sa_restorer</code>仅供内部使用，以保证信号处理函数顺利完成 (调用特殊用途的系统调用<code>sigreturn()</code>，这将恢复进程的上下文，以便进程可以在被信号处理函数中断的位置继续执行)，SUSv3也没有说明该成员。</p><p>　　成员<code>sa_flags</code>是用于控制信号处理函数的行为的位掩码，可以包含标志<code>SA_NOCLDSTOP</code>、<code>SA_NOCLDWAIT</code>、<code>SA_NODEFER</code>、<code>SA_ONSTACK</code>、<code>SA_RESETHAND</code>、<code>SA_RESTART</code>和<code>SA_SIGINFO</code>中的任意个标志 (或运算<code>|</code>)。SUSv3详细说明了这些标志。</p><p>　　● <code>SA_NOCLDSTOP</code>表示若<code>sig</code>是<code>SIGCHLD</code>，则子进程停止或恢复时不生成该信号。</p><p>　　● <code>SA_NOCLDWAIT</code>表示若<code>sig</code>是<code>SIGCHLD</code>，则子进程终止时不会转换为僵尸进程 (Linux 2.6及以上版本)。</p><p>　　● <code>SA_NODEFER</code>表示捕获信号时不自动将其添加到信号掩码。该标志还有1个历史别名——<code>SA_NOMASK</code>。但是，因为SUSv3标准化了<code>SA_NODEFER</code>，所以<code>SA_NODEFER</code>是首选。</p><p>　　● <code>SA_ONSTACK</code>表示使用通过<code>sigaltstack()</code>定义的备用信号栈调用信号处理函数。</p><p>　　● <code>SA_RESETHAND</code>表示捕获信号后，先将处理方式恢复到默认，再调用处理函数 (在默认情况下，信号处理函数会一直处于已注册状态，直到显式调用<code>sigaction()</code>来注销)。该标志还有1个历史别名——<code>SA_ONESHOT</code>。但是，因为SUSv3标准化了<code>SA_RESETHAND</code>，所以<code>SA_RESETHAND</code>是首选。</p><p>　　● <code>SA_RESTART</code>表示自动重启被信号处理函数中断的系统调用。</p><p>　　● <code>SA_SIGINFO</code>表示使用额外参数调用信号处理函数，以提供有关信号的更多信息，与成员<code>sa_sigaction</code>一起使用。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_19/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第19章 监控文件事件"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第19章 监控文件事件</a></div><div class="post-nav-item"><a href="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_01/" rel="next" title="《ARM Cortex-M3与Cortex-M4权威指南 第3版》第1章 ARM Cortex-M处理器简介">《ARM Cortex-M3与Cortex-M4权威指南 第3版》第1章 ARM Cortex-M处理器简介 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>