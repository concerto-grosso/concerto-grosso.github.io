<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_31/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_31/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_31/","title":"《Linux/UNIX系统编程手册》第31章 线程：线程安全和线程级存储"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第31章 线程：线程安全和线程级存储 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">31.1 一次性初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE"><span class="nav-text">31.2 线程特定数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE%E6%A6%82%E8%BF%B0"><span class="nav-text">31.2.1 线程特定数据概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread_key_create"><span class="nav-text">31.2.2 pthread_key_create()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pthread_setspecific%E5%92%8Cpthread_getspecific"><span class="nav-text">31.2.3 pthread_setspecific()和pthread_getspecific()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AEapi"><span class="nav-text">31.2.4 使用线程特定数据API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-text">31.2.5 线程特定数据实现的限制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-text">31.3 线程本地存储</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_31/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第31章 线程：线程安全和线程级存储 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第31章 线程：线程安全和线程级存储</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-08-08 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-08T00:00:00+08:00">2025-08-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-08-09 00:00:00" itemprop="dateModified" datetime="2025-08-09T00:00:00+08:00">2025-08-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>10k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　若函数可以被多个线程同时调用，则该函数是<span style="background-color:#ff0">线程安全函数</span>；否则，该函数是非线程安全函数。SUSv3说明的大部分函数都是线程安全函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> glob = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">incr</span><span class="params">(<span class="type">int</span> loops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> loc, j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; loops; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        loc = glob;</span><br><span class="line">        loc++;</span><br><span class="line">        glob = loc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>incr()</code>是非线程安全函数。当多个线程同时调用该函数时，<code>glob</code>的最终值将是不确定的。这个函数说明了函数是非线程安全函数的典型原因：使用了由所有线程共享的全局变量或静态变量。</p><p>　　让函数成为线程安全函数的方法有多种。最简单的方法是直接将整个函数关联互斥锁，这表示同时只能有1个线程执行该函数，此时，对该函数的访问是<span style="background-color:#ff0">序列化</span>的。若线程需要花费大量时间来执行该函数，则这种序列化将导致并发性损失，因为程序的线程无法并行执行。更复杂的方法是将共享变量关联互斥锁，这需要确定临界区，并仅在执行临界区期间获取和释放互斥锁。这允许多个线程同时执行该函数和并行操作，除非多个线程都需要执行临界区。</p><p>　　尽管通过临界区来实现线程安全比将整个函数关联互斥锁更高效，但这种方法还是会带来性能影响，因为加锁和解锁是有成本的。<span style="background-color:#ff0">可重入函数</span>是在不使用互斥锁的情况下实现线程安全的函数，因为此类函数通过不使用全局变量和静态变量来实现线程安全。对于可重入函数，所有信息都会返回给调用者，或者函数调用之间维护的信息都存储在调用者分配的缓冲区中。但是，并非所有函数都能以这种方式方式实现，原因如下：</p><p>　　● 有些必须要使用全局数据结构。malloc库中的函数就是很好的示例，这些函数在堆上维护了1个空闲内存快的全局链表。这些函数只能通过互斥锁来实现线程安全。</p><p>　　● 有些函数 (在线程出现之前) 具有根据定义不可重入的接口，因为它们会返回由函数静态分配的指针或使用静态存储来维护对同一 (或相关) 函数的连续调用之间的信息。例如，函数<code>asctime()</code> (见10.2.3.1) 会返回静态分配的日期时间字符串。</p><p>　　对于部分具有不可重入接口的函数，SUSv3要求对应的可重入版本以后缀<code>_r</code>结尾 (例如，<code>asctime_r()</code>)。这些函数要求调用者分配缓冲区，并将缓冲区的地址作为参数传递 (用于返回结果)。这允许调用线程将局部 (栈) 变量作为函数结果缓冲区。</p><p>　　有些实现也提供了其他传统不可重入函数的可重入版本 (例如，glibc的<code>crypt_r()</code>)。但是，可移植应用程序应该避免使用这些函数的可重入版本，因为其他实现可能没有提供这些函数的可重入版本。此外，在某些情况下，SUSv3没有说明某些传统函数的可重入版本，因为存在比这些函数更高效的可重入替代函数。</p><span id="more"></span><h3 id="一次性初始化">31.1 一次性初始化</h3><p>　　有时，多线程应用程序可能需要确保某些初始化行为只会发生1次，无论创建了多少个线程。当主线程创建线程时，这很容易实现——只需要在创建依赖于该初始化的线程之前执行初始化。但是，这不适用于库函数，因为主线程可能在调用库函数之前创建了线程。因此，库函数需要1种在任何线程第1次调用该函数时执行初始化的方法，这正是函数<code>pthread_once()</code>的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init)(<span class="type">void</span>))</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>pthread_once()</code>会使用参数<code>once_control</code>指定的状态来确保参数<code>init</code>指向的调用者定义的函数只会被调用1次，无论调用线程调用<code>pthread_once()</code>多少次或多少个不同的线程调用<code>pthread_once()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_once_t</span> once_var = PTHREAD_ONCE_INIT;</span><br></pre></td></tr></table></figure><p>　　<code>once_control</code>指向的变量必须使用值<code>PTHREAD_ONCE_INIT</code>静态初始化。当第1次调用<code>pthread_once()</code>时，若指定了指向特定<code>pthread_once_t</code>变量的指针，则会修改<code>once_control</code>指向的变量的值，以便后续调用该函数时不再调用<code>init</code>指向的函数。</p><p>　　<code>pthread_once()</code>存在的主要原因是，对于Pthreads早期版本，无法静态初始化互斥锁。相反，初始化互斥锁必须通过<code>pthread_mutex_init()</code>完成。鉴于后来添加了静态分配的互斥锁，库函数可以使用静态分配的互斥锁和静态Boolean变量来执行一次性初始化。尽管如此，<code>pthread_once()</code>仍然被保留为1种便利方法。</p><h3 id="线程特定数据">31.2 线程特定数据</h3><p>　　让函数线程安全的最高效的方式是使其可重入。所有新的库函数都应该以这种方式实现。但是，对于现有的不可重入库函数 (可能在线程普及之前设计的函数)，这种方式需要修改函数的接口，这表示需要修改所有使用了该函数的程序。</p><p>　　<strong>线程特定数据</strong> (TSD) 是1种无需修改现有函数接口即可使其线程安全的技术。这种技术的成本略高于让函数可重入，但可以保证调用该函数的程序不变。</p><p>　　线程特定数据允许函数为调用该函数的每个线程<span style="background-color:#ff0">维护1个变量的独立副本</span>。线程特定数据具有持久性，每个线程的变量在该线程多次调用该函数之间持续存在。这使得函数能够在函数调用之间维护每个线程的信息，并允许函数将不同的结果缓冲区传递给调用线程 (若有必要)。</p><p>　　为了理解线程特定数据API的用法，需要从使用线程特定数据的库函数的角度考虑问题：</p><p>　　● 函数必须为每个调用该函数的线程分配1个独立的存储块，该存储块只需要被分配1次，即线程第1次调用该函数时。</p><p>　　● 当线程后续调用该函数时，函数需要获取该线程第1次调用该函数时分配的存储块的地址。函数不能将指向存储块的指针维护为自动变量，因为函数返回时自动变量会被释放；函数也不能将指向存储块的指针维护为静态变量，因为静态变量在进程中只有1个实例。Pthreads API提供了函数来执行该任务。</p><p>　　● 多个函数可能都需要线程特定数据。这些函数需要1种方法来识别其线程特定数据 (1个键)，以区别于其他函数使用的线程特定数据。</p><p>　　● 函数无法直接控制线程终止时发生的事情。当线程终止时，可能正在执行该函数之外的其他代码。尽管如此，必须存在某种机制来保证线程终止时会自动释放为该线程分配的存储块 (因为不这样做可能会导致内存泄漏)。</p><h4 id="线程特定数据概述">31.2.1 线程特定数据概述</h4><p>　　库函数使用线程特定数据的步骤通常如下：</p><p>　　1) 函数创建1个键，用于区分该函数使用的线程特定数据与其他函数使用的线程特定数据。该键通过调用函数<code>pthread_key_create()</code>生成。创建键只需要在线程第1次调用函数时完成 (通过<code>pthread_once()</code>)。创建键不会分配任何线程特定数据块。</p><p>　　2) 调用<code>pthread_key_create()</code>还有1个目的：允许调用者指定程序员定义的析构函数 (用于释放该键对应的存储块) 的地址。当使用了线程特定数据的线程终止时，Pthreads API会自动调用析构函数，并传递1个指向该线程的数据块的指针。</p><p>　　3) 函数会为调用该函数的所有线程都分配1个线程特定数据块 (通过<code>malloc()</code>等函数)，这发生在线程第1次调用该函数时。</p><p>　　4) 通过函数<code>pthread_setspecific()</code>和<code>pthread_getspecific()</code>保存指向第3步分配的数据块的指针。前者会向Pthreads实现发送请求，要求它 "保存该指针，并记录它与特定键 (该函数的键) 和特定线程 (调用线程) 相关联的事实"。后者会执行与前者互补的任务，即返回之前与调用线程的给定键关联的指针。若没有指针与给定键和线程关联，则返回<code>NULL</code>。这样，函数就可以确定它是第1次被线程调用，所以必须为线程分配存储块。</p><h4 id="pthread_key_create">31.2.2 <code>pthread_key_create()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span> *))</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>pthread_key_create()</code>会创建1个线程特定数据键，并将其存储在参数<code>key</code>指向的缓冲区中。由于进程的所有线程都会使用该键，所以<code>key</code>应该指向全局变量。</p><p>　　参数<code>destructor</code>指向由程序员定义的析构函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dest</span><span class="params">(<span class="type">void</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 释放value指向的内存区域 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当线程终止时，若存在与键关联的析构函数 (调用<code>pthread_key_create()</code>时<code>destructor</code>不为<code>NULL</code>) 和线程特定数据，则会以线程特定数据的地址作为参数调用析构函数。若不需要析构函数，则可以将<code>destructor</code>指定为<code>NULL</code>。</p><p>　　若线程有多个线程特定数据块，则析构函数的调用顺序是不确定的。析构函数应该被设计为彼此相互独立。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_31/implementation_of_thread-specific_data_keys.svg"><p>　　典型的线程特定数据实现 (即NPTL) 会涉及1个关于线程特定数据键的 (进程级) 全局信息数组和1组线程级数组，线程级数组包含指向为特定线程分配的所有线程特定数据块的指针 (通过调用<code>pthread_setspecific()</code>获取的指针)。对于该实现，<code>pthread_key_create()</code>返回的<code>pthread_key_t</code>值是全局数组的索引。该数组的元素是包含2个成员的结构体，第1个成员表示该元素是否正在使用 (即之前已通过<code>pthread_key_create()</code>分配)，第2个成员用于存储指向该键对应的线程特定数据块的析构函数的指针 (即<code>pthread_key_create()</code>的参数<code>destructor</code>的副本)。</p><h4 id="pthread_setspecific和pthread_getspecific">31.2.3 <code>pthread_setspecific()</code>和<code>pthread_getspecific()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>; <span class="comment">/* 存在与key关联的线程特定数据块时返回指向线程特定数据块的指针，不存在时返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>pthread_setspecific()</code>会请求Pthreads API将参数<code>value</code>的副本保存在与线程和参数<code>key</code>关联的数据结构中，<code>key</code>必须被指定为之前调用<code>pthread_key_create()</code>返回的键。函数<code>pthread_setspecific()</code>执行与之互补的操作，即返回指向之前与参数<code>key</code>关联的该线程的数据的指针。</p><p>　　<code>pthread_setspecific()</code>的参数<code>value</code>通常是指向之前由调用者分配的内存块的指针，该指针在线程终止时会作为参数传递给<code>key</code>对应的析构函数的指针。实际上，<code>value</code>也可以是赋值给<code>void *</code>的标量值 (强制类型转换)。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_31/data_structure_used_to_implement_thread-specific_data_pointers.svg"><p>　　上图展示了用于存储<code>value</code>的数据结构的典型实现。这里假设<code>pthread_keys[1]</code>被分配给函数<code>myfunc()</code>。对于每个线程，Pthreads API维护了1个由指向线程特定数据块的指针组成的数组，其元素与31.2.2中的图所示的数组元素一一对应。函数<code>pthread_setspecific()</code>会为调用线程设置中与<code>key</code>对应的数组元素。</p><p>　　当第1次创建线程时，其所有线程特定数据指针都会被初始化为<code>NULL</code>。这表示当线程第1次调用库函数时，它必须通过<code>pthread_getspecific()</code>来检查线程是否已有与<code>key</code>关联的值。若没有，则函数应该分配内存块，并通过<code>pthread_setspecific()</code>来保存指向该内存块的指针。</p><h4 id="使用线程特定数据api">31.2.4 使用线程特定数据API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* strerror.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，_sys_nerr和_sys_errlist会被声明在stdio.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">/* 获取strerror()的声明 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ERROR_LEN 256 <span class="comment">/* strerror()返回的字符串的最大长度 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[MAX_ERROR_LEN]; <span class="comment">/* 静态分配的返回缓冲区 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> || err &gt;= _sys_nerr || _sys_errlist[err] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, MAX_ERROR_LEN, <span class="string">&quot;Unknown error %d&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf, _sys_errlist[err], MAX_ERROR_LEN - <span class="number">1</span>);</span><br><span class="line">        buf[MAX_ERROR_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 确保以\0结尾 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例是<code>strerror()</code>的非线程安全实现。该函数会使用glibc定义的全局变量<code>_sys_nerr</code> (由<code>errno</code>错误号对应的字符串组成的数组) 和全局数组<code>_sys_errlist</code> (表示<code>_sys_errlist</code>的元素数量)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* strerror_test.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">/* 获取strerror()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Other thread about to call strerror()\n&quot;</span>);</span><br><span class="line">    str = strerror(EPERM);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Other thread: str (%p) = %s\n&quot;</span>, str, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">    str = strerror(EINVAL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread has called strerror()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_create(&amp;t, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = pthread_join(t, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_join&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread: str (%p) = %s\n&quot;</span>, str, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例是<code>strerror()</code>的测试程序。该程序会在2个线程中调用<code>strerror()</code>，并且仅在2个线程都完成调用后才打印结果。尽管2个线程使用了不同的错误号 (<code>EINVAL</code>和<code>EPERM</code>) 作为<code>strerror()</code>的参数，编译该测试程序并与<code>strerror.c</code>链接得到的可执行文件的运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./strerror_test</span></span><br><span class="line">Main thread has called strerror()</span><br><span class="line">Other thread about to call strerror()</span><br><span class="line">Other thread: str (0x804a7c0) = Operation not permitted</span><br><span class="line">Main thread: str (0x804a7c0) = Operation not permitted</span><br></pre></td></tr></table></figure><p>　　2个线程打印的都是<code>EPERM</code>对应的字符串，因为新线程调用<code>strerror()</code>会覆写主线程调用<code>strerror()</code>写入到缓冲区的内容。根据输出结果可知，2个线程中的局部变量<code>str</code>指向同一内存地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* strerror_tsd.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，_sys_nerr和_sys_errlist会被声明在stdio.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">/* 获取strerror()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ERROR_LEN 256 <span class="comment">/* strerror()返回的线程级缓冲区的字符串的最大长度 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> strerrorKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 析构函数 (释放buf指向的缓冲区)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param buf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">destructor</span><span class="params">(<span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建一次性键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">createKey</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配1个唯一的线程特定数据键，并保存线程特定数据缓冲区的析构函数的地址 */</span></span><br><span class="line">    s = pthread_key_create(&amp;strerrorKey, destructor);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_key_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 让第1个调用者为线程特定数据分配键 */</span></span><br><span class="line">    s = pthread_once(&amp;once, createKey);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExitEN(s, <span class="string">&quot;pthread_once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若线程第1次调用该函数，则为线程分配缓冲区，并保存其地址 */</span></span><br><span class="line">    buf = pthread_getspecific(strerrorKey);</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf = <span class="built_in">malloc</span>(MAX_ERROR_LEN);</span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = pthread_setspecific(strerrorKey, buf);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExitEN(s, <span class="string">&quot;pthread_setspecific&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> || err &gt;= _sys_nerr || _sys_errlist[err] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, MAX_ERROR_LEN, <span class="string">&quot;Unknown error %d&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf, _sys_errlist[err], MAX_ERROR_LEN - <span class="number">1</span>);</span><br><span class="line">        buf[MAX_ERROR_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 确保以\0结尾 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例是的使用线程特定数据的<code>strerror()</code>实现。</p><p>　　首先，<code>strerror()</code>调用<code>pthread_once()</code>来确保线程第1次调用该函数时会调用函数<code>createKey()</code> (第45~49行)。<code>createKey()</code>会调用<code>pthread_key_create()</code>来分配存储1个存储在全局变量<code>strerrorKey</code>中的线程特定数据键，调用<code>pthread_key_create()</code>也会记录用于释放与键对应的线程特定数据的析构函数的地址 (第27~37行)。</p><p>　　然后，<code>strerror()</code>调用<code>pthread_getspecific()</code>来检索与<code>strerrorKey</code>对应的线程的唯一缓冲区的地址。若该调用返回<code>NULL</code>，则表示线程是第1次调用<code>strerror()</code>，所以<code>strerror()</code>会通过<code>malloc()</code>来创建1个新的缓冲区，并通过<code>pthread_setspecific()</code>来将该缓冲区与<code>strerrorKey</code>关联。若该调用的返回值不是<code>NULL</code>，则表示返回值是指向线程之前调用<code>strerror()</code>时分配的缓冲区的指针 (第51~66行)。</p><p>　　最后，<code>strerror()</code>实现执行与之前的非线程安全实现相似的操作，区别在于这里的<code>buf</code>是线程特定数据缓冲区的地址 (而非静态变量)。</p><p>　　编译测试程序 (<code>strerror_test.c</code>) 并与<code>strerror_tsd.c</code>链接得到的可执行文件的运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./strerror_test_tsd</span></span><br><span class="line">Main thread has called strerror()</span><br><span class="line">Other thread about to call strerror()</span><br><span class="line">Other thread: str (0x804b158) = Operation not permitted</span><br><span class="line">Main thread: str (0x804b008) = Invalid argument</span><br></pre></td></tr></table></figure><p>　　根据输出结果可知，<code>strerror_tsd.c</code>是线程安全的 (2个线程中的局部变量<code>str</code>指向不同地址)。</p><h4 id="线程特定数据实现的限制">31.2.5 线程特定数据实现的限制</h4><p>　　正如对线程特定数据的典型实现方式的描述所暗示的那样，实现需要对其支持的线程特定数据键的数量施加限制。SUSv3要求实现支持至少128个键 (<code>_POSIX_THREAD_KEYS_MAX</code>)，而Linux支持最多1024个键。应用程序可以通过<code>PTHREAD_KEYS_MAX</code>的定义 (定义在头文件<code>limits.h</code>中) 或调用<code>sysconf(_SC_THREAD_KEYS_MAX)</code>来获取实现实际支持多少个键。</p><p>　　对于大多数应用程序，128个键也绰绰有余，因为库函数使用的键很少——通常只有1个。当函数需要多个线程特定数据值时，通常也是将这些值放在1个结构体中 (只需要1个与之关联的键)。</p><h3 id="线程本地存储">31.3 线程本地存储</h3><p>　　与线程特定数据类似，线程本地存储也提供了持久的线程级存储。该特性是非标准特性，Solaris和FreeBSD等很多UNIX实现都以相同或类似的形式提供该特性。</p><p>　　线程本地存储的主要优势是比线程特定数据简单很多。为了创建线程本地变量，只需要在全局或静态变量的声明中使用说明符<code>__thread</code> (例如，<code>static __thread buf[MAX_ERROR_LEN]</code>)。</p><p>　　每个线程都有线程本地变量的副本。线程的线程本地存储中的变量会一直存在，直到线程终止，届时会自动释放线程本地存储。</p><p>　　线程本地存储需要内核 (Linux 2.6及以上版本)、Pthreads实现 (NPTL) 和C编译器 (gcc 3.3及以上版本) 的支持。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* strerror_tls.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，_sys_nerr和_sys_errlist会被声明在stdio.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">/* 获取strerror()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ERROR_LEN 256 <span class="comment">/* strerror()返回的线程级缓冲区的字符串的最大长度 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">char</span> buf[MAX_ERROR_LEN]; <span class="comment">/* 线程本地返回缓冲区 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> err)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> || err &gt;= _sys_nerr || _sys_errlist[err] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, MAX_ERROR_LEN, <span class="string">&quot;Unknown error %d&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf, _sys_errlist[err], MAX_ERROR_LEN - <span class="number">1</span>);</span><br><span class="line">        buf[MAX_ERROR_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 确保以\0结尾 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例是使用线程本地存储的<code>strerror()</code>实现。编译测试程序 (<code>strerror_test.c</code>) 并与该程序链接得到的可执行文件的运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./strerror_test_tls</span></span><br><span class="line">Main thread has called strerror()</span><br><span class="line">Other thread about to call strerror()</span><br><span class="line">Other thread: str (0x40376ab0) = Operation not permitted</span><br><span class="line">Main thread: str (0x40175080) = Invalid argument</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_30/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第30章 线程：线程同步"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第30章 线程：线程同步</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_32/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第32章 线程：线程取消">《Linux/UNIX系统编程手册》第32章 线程：线程取消 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>