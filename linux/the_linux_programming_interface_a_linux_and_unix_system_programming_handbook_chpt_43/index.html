<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_43/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_43/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_43/","title":"《Linux/UNIX系统编程手册》第43章 进程间通信简介"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第43章 进程间通信简介 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7"><span class="nav-text">43.1 通信工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-text">43.1.1 数据传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">43.1.2 共享内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="nav-text">43.2 同步工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83ipc%E5%B7%A5%E5%85%B7"><span class="nav-text">43.3 比较IPC工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-text">43.3.1 功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#system-v-ipc%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="nav-text">43.3.2 System V IPC设计问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-text">43.3.3 可访问性和持久性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-text">43.3.4 性能</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_43/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第43章 进程间通信简介 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第43章 进程间通信简介</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2026-01-31 00:00:00" itemprop="dateCreated datePublished" datetime="2026-01-31T00:00:00+08:00">2026-01-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2026-02-01 00:00:00" itemprop="dateModified" datetime="2026-02-01T00:00:00+08:00">2026-02-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.5k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_43/a_taxonomy_of_unix_ipc_facilities.svg"><p>　　<strong>进程间通信</strong> (IPC) 工具按功能可分为3类：<span style="background-color:#ff0">通信</span>、<span style="background-color:#ff0">同步</span>和<span style="background-color:#ff0">信号</span>。如上图所示，存在多个类似的IPC工具，这主要有2个原因：</p><p>　　● 类似的IPC工具在不同的UNIX变体上发展起来，后来又被移植到其他UNIX系统。</p><p>　　● 为了解决早期类似的IPC工具的设计缺陷，人们设计了新的IPC工具。</p><span id="more"></span><h3 id="通信工具">43.1 通信工具</h3><p>　　通信工具可以分为2类：<span style="background-color:#ff0">数据传输工具</span>和<span style="background-color:#ff0">共享内存</span>。</p><p>　　● 区分数据传输工具的关键因素是写入和读取的概念。为了进行通信，进程A向IPC工具写入数据，而进程B读取数据。这些工具需要在用户内存和内核内存之间进行2次数据传输：写入时从用户内存传输数据到内核内存以及读取时从内核内存传输数据到用户内存。</p><p>　　● 共享内存允许进程将信息放在进程之间共享的内存区域来进行交换 (内核通过使所有进程的页表条目都指向同一内存页来实现这一点)。进程可以通过将数据放入共享内存区域来使其他进程访问这些数据。因为通信不需要系统调用或在用户内存与内核内存之间传输数据，所以共享内存能够提供非常快速的通信。</p><h4 id="数据传输">43.1.1 数据传输</h4><p>　　数据传输工具可以进一步分为3类：<span style="background-color:#ff0">字节流</span>、<span style="background-color:#ff0">消息</span>和<span style="background-color:#ff0">伪终端</span>。</p><p>　　● 通过有名管道、无名管道和数据报套接字交换的数据是无分隔符的字节流。每次读取操作可以从IPC工具中读取任意数量的字节 (无需考虑写入者写入的数据块大小)。该模型与UNIX传统的 "文件即字节序列" 模型类似。</p><p>　　● 通过System V消息队列、POSIX消息队列和数据报套接字交换的数据是无分隔符的消息。每次读取操作会读取整条消息，每次写入操作会写入整条消息。无法仅读取消息的一部分 (而将剩余部分留在IPC工具)，也无法单次读取多条消息。</p><p>　　● 伪终端是用于特殊情况的通信工具。</p><p>　　尽管数据传输工具可以存在多个读取者，但读取操作会消耗数据 (数据将无法供其他进程使用)。</p><p>　　读取进程和写入进程之间的同步是自动的。若读取进程试图从当前没有数据的数据传送工具中获取数据，则读取操作默认会被阻塞，直到有进程向该工具中写入数据。</p><h4 id="共享内存">43.1.2 共享内存</h4><p>　　大部分现代UNIX系统支持3种共享内存：System V共享内存、POSIX共享内存和内存映射。</p><p>　　尽管共享内存提供了快速的通信，但这种速度优势会被需要对共享内存进行同步操作的需求抵消 (例如，进程不应该在其他进程正在更新的内存中的数据结构时试图访问它)。信号量通常用于共享内存同步。</p><p>　　共享内存中的数据对共享该内存的所有进程都可见 (这与数据传输工具的破坏性读取语义形成对比)。</p><h3 id="同步工具">43.2 同步工具</h3><p>　　同步工具允许进程协调其操作。UNIX系统提供了3种同步工具：<span style="background-color:#ff0">信号量</span>、<span style="background-color:#ff0">文件锁</span>以及<span style="background-color:#ff0">互斥锁和条件变量</span>。</p><p>　　● 信号量是内核维护的1个整数，其值永远不会小于0。进程可以加减信号量。若试图将信号量的值减少至小于0，则内核会阻塞该操作，直到信号量的值增加至允许操作的值 (或者，进程可以请求非阻塞操作，内核不会阻塞该操作，而是使其立即返回表示该操作无法立即执行的错误信息)。信号量的含义由应用程序决定。进程通过递减信号量来保留对某些共享资源的独占访问权，并在完成相关操作后递增信号量来释放共享资源。二进制信号量 (其值仅为0或1) 的使用很常见。但是，处理多个共享资源实例的应用程序会使用最大值等于共享资源数量的信号量。Linux提供了System V信号量和POSIX信号量，两者的功能基本相同。</p><p>　　● 文件锁是用于协调多个进程对同一文件的操作的同步方法，也能用于协调对其他资源的访问。文件锁分为2类：读取 (共享) 锁和写入 (独占) 锁。任意数量的进程都能持有文件 (或文件区域) 的读取锁。但是，当某个进程持有文件 (或文件区域) 的写入锁时，其他进程将无法获取该文件 (或文件区域) 的读取或写入锁。Linux通过系统调用<code>flock()</code>和<code>fcntl()</code>提供文件锁。系统调用<code>flocK()</code>提供了简单的上锁机制，允许进程对整个文件设置共享或独占锁。由于该系统调用的功能有限，如今很少使用。系统调用<code>fcntl()</code>提供了记录锁，允许进程对文件的不同区域设置多个读取和写入锁。</p><p>　　● 互斥锁和条件变量通常与POSIX一起使用 (对于部分UNIX实现和使用提供NPTL线程实现的glibc的Linux系统，进程之间可以共享互斥锁和条件变量。SUSv3允许但不要求实现支持共享的互斥锁和条件变量)。</p><p>　　从内核2.6.22开始，Linux通过系统调用<code>eventfd()</code>提供了额外的非标准同步机制。该系统调用会创建eventfd对象 (该对象具有由内核维护的8字节无符号整数值)，然后返回引用该对象的文件描述符。向该文件描述符写入整数会设置对应对象的值。当对象值为0时，对文件描述符进行<code>read()</code>会被阻塞。若对象值非0，则<code>read()</code>会返回该值并将其重置为0。<code>poll()</code>、<code>select()</code>和<code>epoll()</code>可用于判断eventfd对象的值是否非0，若是，则文件描述符指示为可读。使用eventfd对象进行同步的应用程序必须先使用<code>eventfd()</code>创建该对象，然后调用<code>fork()</code>创建继承引用该对象的文件描述符的相关进程。</p><h3 id="比较ipc工具">43.3 比较IPC工具</h3><p>　　为了访问IPC对象，进程必须使用某种方法来标识该对象。当后续 "打开" 该对象时，进程必须使用某种类型的句柄来引用打开的对象。下表总结了用于各种IPC工具的这些属性：</p><table><thead><tr><th>工具类型</th><th>用于标识对象的名称</th><th>用于在程序中引用对象的句柄</th></tr></thead><tbody><tr><td>无名管道</td><td></td><td>文件描述符</td></tr><tr><td>有名管道</td><td>路径名</td><td>文件描述符</td></tr><tr><td>UNIX域套接字</td><td>路径名</td><td>文件描述符</td></tr><tr><td>互联网域套接字</td><td>IP地址 + 端口号</td><td>文件描述符</td></tr><tr><td>System V消息队列</td><td>System V IPC键</td><td>System V IPC标识符</td></tr><tr><td>System V信号量</td><td>System V IPC键</td><td>System V IPC标识符</td></tr><tr><td>System V共享内存</td><td>System V IPC键</td><td>System V IPC标识符</td></tr><tr><td>POSIX消息队列</td><td>POSIX IPC路径名</td><td><code>mqd_t</code> (消息队列描述符)</td></tr><tr><td>POSIX有名信号量</td><td>POSIX IPC路径名</td><td><code>sem_t *</code> (信号量指针)</td></tr><tr><td>POSIX无名信号量</td><td></td><td><code>sem_t *</code> (信号量指针)</td></tr><tr><td>POSIX共享内存</td><td>POSIX IPC路径名</td><td>文件描述符</td></tr><tr><td>匿名映射</td><td></td><td></td></tr><tr><td>内存映射文件</td><td>路径名</td><td>文件描述符</td></tr><tr><td>文件锁</td><td>路径名</td><td>文件描述符</td></tr><tr><td>记录锁</td><td>路径名</td><td>文件描述符</td></tr></tbody></table><p>　　套接字允许进程通过网络通信。套接字通常用于UNIX域 (允许同一系统的进程之间进行通信) 或互联网域 (允许通过TCP/IP网络连接的不同主机的进程之间进行通信)。通常只需要进行少量修改即可将使用UNIX域套接字的程序转换为使用互联网域套接字的程序。因此，使用UNIX域套接字构建的应用程序可以轻松地实现网络通信功能。</p><p>　　POSIX IPC工具 (消息队列、信号量和共享内存) 的普及程度远不及对应的System IPC工具，尤其是在较旧的UNIX系统上 (POSIX消息队列的实现和POSIX信号量的完全支持直至Linux 2.6.x内核才出现)。因此，从可移植角度，System V IPC优于POSIX IPC。</p><h4 id="功能">43.3.1 功能</h4><p>　　各种IPC工具之间存在功能差异，这些差异在决定使用哪种工具时可能至关重要。数据传输工具和共享内存之间的差异如下：</p><p>　　● 文件传输工具涉及读写操作，传输的数据只能由1个读取进程使用。写入者和读取者之间的流量控制以及同步 (例如，当读取者试图从当前为空的存储单元读取数据时会被阻塞) 均有内核自动处理。这种模型与很多应用程序设计非常契合。</p><p>　　● 其他应用程序设计则更适合共享内存模型。共享内存允许进程使数据对共享同一区域的任意数量的其他进程可见。通信操作很简单——进程可以像访问其虚拟地址空间中的任何其他内存一样访问共享内存中的数据。另一方面，需要处理同步 (可能还有流量控制) 会增加共享内存设计的复杂性。这种模型非常适合那些需要维护共享状态 (例如，共享数据结构) 的应用程序设计。</p><p>　　关于各种数据传输工具，以下几点值得注意：</p><p>　　● 有些数据传输工具以字节流传输数据，其他数据传输工具则以消息传输数据。使用哪种方法取决于具体应用程序 (应用程序还可以通过使用分隔符、固定长度消息或编码消息总长度的消息首部来将以消息传输数据的模型应用于字节流机制)。</p><p>　　● 与其他数据传输工具相比，System V和POSIX消息队列的显著特性之一是可以为消息分配数字类型或优先级，从而使消息能够以与发送顺序不同的顺序进行传输。</p><p>　　● 无名管道、有名管道和套接字是通过文件描述符实现的。它们都支持多个替代I/O模型：I/O多路复用 (系统调用<code>select()</code>和<code>poll()</code>)、信号驱动I/O以及特定于Linux的epoll API。这些技术的主要优点是允许应用程序同时监控多个文件描述符来查看是否可以对其中任何1个进行I/O。相比之下，System V消息队列不使用文件描述符，也不支持这些技术。对于Linux，POSIX消息队列是使用文件描述符实现的，并且支持这些技术。但是，SUSv3没有说明这种行为，而且大部分UNIX实现也不支持这种行为。</p><p>　　● POSIX消息队列可以在消息到达空队列时向进程发送信号或创建新线程。</p><p>　　● UNIX域套接字允许在进程之间传递文件描述符。这使得进程可以打开文件并使其可供其他可能无法访问该文件的进程使用。</p><p>　　● UDP套接字允许发送端将消息广播或多播到多个接收端。</p><p>　　关于各种进程同步工具，以下几点值得注意：</p><p>　　● 记录锁的所有者是设置该锁的进程。内核使用这种所有权来检测死锁。若发生死锁，则内核会拒绝其中某个进程的锁请求，并通过该系统调用返回相应的错误。System V和POSIX信号量没有所有权属性，并且信号量不会进行死锁检测。</p><p>　　● 记录锁会在持有该锁的进程终止时自动被释放。System V信号量通过 "撤销" 功能提供了类似的特性，但该特性并非在所有情况下都可靠。POSIX信号量没有提供类似的功能。</p><h4 id="system-v-ipc设计问题">43.3.2 System V IPC设计问题</h4><p>　　System IPC工具的设计独立于传统的UNIX I/O模型，所以存在若干个会使其编程接口的使用更复杂的特殊情况。对应的POSIX工具旨在解决这些问题。以下几点值得注意：</p><p>　　● System V IPC工具是无连接的。这些工具没有提供用于引用打开的IPC对象的句柄 (类似于文件描述符) 的概念。内核不会为进程记录 "打开的对象" (与其他IPC对象不同)。这表示内核无法维护当前正在使用对象的进程数的引用计数。因此，应用程序可能需要额外的编程工作来确定何时可以安全删除对象。</p><p>　　● System V IPC工具的编程接口与传统UNIX I/O模型不一致 (它们使用整数键值和IPC标识符，而非路径名和文件描述符)。这些编程接口也相当复杂，尤其是System V信号量。</p><p>　　相比之下，内核会为POSIX IPC对象的打开引用计数。这简化了何时可以删除对象的决策。此外，POSIX IPC工具提供了更简洁且与传统UNIX模型更一致的接口。</p><h4 id="可访问性和持久性">43.3.3 可访问性和持久性</h4><p>　　术语<strong>持久性</strong>表示IPC对象的生命周期。持久性分为<span style="background-color:#ff0">进程持久性</span>、<span style="background-color:#ff0">内核持久性</span>和<span style="background-color:#ff0">文件系统持久性</span>。</p><p>　　● 进程持久的IPC对象仅在至少有1个进程保持打开状态时存在。若所有进程都关闭了该对象，则与该对象相关的所有内核资源都会被释放，任何未读取的数据也会被销毁。</p><p>　　● 内核持久的IPC对象会一直存在，直到它被显式删除或系统关闭。</p><p>　　● 文件系统持久的IPC对象即使在系统重启后也能保留其信息。这种对象会一直存在，直到被显式删除。</p><p>　　下表列出了各种IPC工具的可访问性和持久性：</p><table><thead><tr><th>工具类型</th><th>可访问性</th><th>持久性</th></tr></thead><tbody><tr><td>无名管道</td><td>只能被关联的进程访问</td><td>进程</td></tr><tr><td>有名管道</td><td>权限掩码</td><td>进程</td></tr><tr><td>UNIX域套接字</td><td>权限掩码</td><td>进程</td></tr><tr><td>互联网域套接字</td><td>可以被任何进程访问</td><td>进程</td></tr><tr><td>System V消息队列</td><td>权限掩码</td><td>进程</td></tr><tr><td>System V信号量</td><td>权限掩码</td><td>进程</td></tr><tr><td>System V共享内存</td><td>权限掩码</td><td>进程</td></tr><tr><td>POSIX消息队列</td><td>权限掩码</td><td>进程</td></tr><tr><td>POSIX有名信号量</td><td>权限掩码</td><td>进程</td></tr><tr><td>POSIX无名信号量</td><td>底层内存的权限</td><td></td></tr><tr><td>POSIX共享内存</td><td>权限掩码</td><td>进程</td></tr><tr><td>匿名映射</td><td>只能被关联的进程访问</td><td>进程</td></tr><tr><td>内存映射文件</td><td>权限掩码</td><td>文件系统</td></tr><tr><td>记录锁</td><td>对文件调用<code>open()</code></td><td>进程</td></tr><tr><td>文件锁</td><td>对文件调用<code>open()</code></td><td>进程</td></tr></tbody></table><p>　　对于有名管道和套接字等IPC工具，对象名称被存储在于文件系统中，其访问权限由关联的文件权限掩码决定 (见15.4)。尽管System IPC对象不会被存储在文件系统中，但每个对象都有关联的权限掩码，其语义与文件权限掩码类似。</p><p>　　无名管道、匿名映射等IPC工具只能被关联的进程访问。这里的 "关联" 是指通过函数<code>fork()</code>建立的关联。为了使2个进程能够访问同一对象，其中的1个进程必须创建对象，然后调用<code>fork()</code>，子进程会继承引用该对象的句柄，从而允许这2个进程共享该对象。</p><p>　　POSIX无名信号量的可访问性由其所在的共享内存区域的可访问性决定。</p><p>　　为了对文件加锁，进程必须拥有引用该文件的文件描述符 (即必须有打开文件的权限)。</p><p>　　访问 (即连接或向其发生数据报) 互联网域套接字没有任何限制。如有必要，必须在应用程序内部实现访问控制。</p><h4 id="性能">43.3.4 性能</h4><p>　　在某些情况下，不同IPC工具可能存在显著的性能差异。但是，后续内容几乎不会进行性能比较，原因如下：</p><p>　　● IPC工具的性能可能不是应用程序整体性能的重要因素，也不可能是决定选择IPC工具的唯一因素。</p><p>　　● 各种IPC工具的相对性能可能因UNIX实现或Linux内核版本而异。</p><p>　　● IPC工具的性能会因其使用方式和环境而异。相关因素包括每次IPC操作中交换的数据单元的大小、IPC工具上可能存在的未读数据量、每次交换数据单元是否需要进行进程上下文切换以及系统的其他负载。</p><p>　　若IPC性能至关重要，则在与目标系统环境相匹配的环境下运行特定于应用程序的基准测试是无可替代的。为此，可以可虑编写抽象软件层，将IPC工具的细节对应用程序隐藏起来，然后在抽象层下替换不同的IPC工具来测试其性能。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_42/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第42章 共享库高级特性"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第42章 共享库高级特性</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第44章 无名管道和有名管道">《Linux/UNIX系统编程手册》第44章 无名管道和有名管道 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>