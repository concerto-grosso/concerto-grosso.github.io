<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_19/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_19/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_19/","title":"《Linux/UNIX系统编程手册》第19章 监控文件事件"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第19章 监控文件事件 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#inotify-api"><span class="nav-text">19.1 inotify API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inotify%E4%BA%8B%E4%BB%B6"><span class="nav-text">19.2 inotify事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96inotify%E4%BA%8B%E4%BB%B6"><span class="nav-text">19.3 读取inotify事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dnotify"><span class="nav-text">19.4 dnotify</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_19/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第19章 监控文件事件 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第19章 监控文件事件</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-03-10 00:00:00" itemprop="dateCreated datePublished" datetime="2025-03-10T00:00:00+08:00">2025-03-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-03-11 00:00:00" itemprop="dateModified" datetime="2025-03-11T00:00:00+08:00">2025-03-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.7k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　有些应用程序需要能够监控文件或目录，以确定监控对象是否发生了事件。例如，图形文件管理器需要能够确定何时在当前显示的目录下新增或删除文件，或者守护进程可能需要监控其配置文件，以便了解该文件是否已被修改。</p><p>　　从内核2.6.13开始，Linux提供了<strong>inotify</strong>机制，该机制允许应用程序监控文件事件。inotify机制取代了较旧的<strong>dnotify</strong>机制，dnotify的功能是inotify的子集 (Linux从内核2.4开始支持dnotify)。这2个机制是特定于Linux的，少部分UNIX实现提供了类似的机制 (例如，BSD提供了kqueue API)。少部分库提供了比这2个机制更抽象和更易于移植的API，其中的部分库在可能时会使用inotify和dnotify (例如，FAM和Gamin)。</p><p>　　使用inotify API的关键步骤如下：</p><p>　　1) 应用程序通过系统调用<code>inotify_init()</code>来创建1个<span style="background-color:#ff0">inotify实例</span>，该系统调用会返回引用inotify实例的文件描述符。</p><p>　　2) 应用程序通过系统调用<code>inotify_add_watch()</code>来将监控项添加到第1步创建的inotify实例的监控列表。每个监控项都由1个路径名和1个关联的位掩码组成，位掩码指定对路径名的监控事件集。该系统调用会返回<strong>监控描述符</strong>。系统调用<code>inotify_rm_watch()</code>执行相反的任务，它会从监控列表中删除监控项。</p><p>　　3) 为了获取事件通知，应用程序可以对inotify文件描述符调用<code>read()</code>。每次成功调用<code>read()</code>都会返回若干个结构体<code>inotify_event</code>，该结构体包含通过inotify实例监控的路径名之一发生的事件的相关信息。</p><p>　　4) 当应用程序完成监控后，会关闭inotify文件描述符。这会自动删除与inotify实例关联的所有监控项。</p><p>　　inotify机制可用于监控文件或目录。当监控目录时，应用程序会收到目录本身和目录下的所有文件的事件通知。</p><p>　　inotify机制不是递归的。若应用程序需要监控整个目录树的事件，则必须将树中的所有目录都添加到inotify实例的监控列表 (<code>inotify_add_watch()</code>)。</p><p>　　inotify文件描述符可以通过<code>select()</code>、<code>poll()</code>、epoll和信号驱动I/O (Linux 2.6.25及以上版本) 监控。若事件可供读取，则这些接口会指示inotify文件描述符可读。</p><p>　　inotify机制是Linux内核的可选组件，由选项<code>CONFIG_INOTIFY</code>和<code>CONFIG_INOTIFY_USER</code>配置。</p><span id="more"></span><h3 id="inotify-api">19.1 inotify API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inotify_init</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 成功时返回文件描述符，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inotify_add_watch</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uint32_t</span> mask)</span>; <span class="comment">/* 成功时返回监控描述符，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inotify_rm_watch</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> wd)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>inotify_init()</code>会返回文件描述符。该文件描述符是用于在后续操作中引用inotify实例的句柄。</p><p>　　从内核2.6.27开始，Linux支持新的非标准系统调用<code>inotify_init1()</code>。该系统调用与<code>inotify_init()</code>类似，但提供了参数<code>flags</code>。该参数可用于修改该系统调用的行为。<code>flags</code>支持标志<code>IN_CLOEXEC</code>和<code>IN_NONBLOCK</code>。前者会让内核为新文件描述符启用close-on-exec标志 (<code>FD_CLOEXEC</code>)，后者会内核为底层打开的文件描述符启用标志<code>O_NONBLOCK</code> (以后的读取都是非阻塞的)。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_19/an_inotify_instance_and_associated_kernel_data_structures.svg"><p>　　系统调用<code>inotify_add_watch()</code>会在参数<code>fd</code>引用的inotify实例的监控列表中新增监控项或修改现有监控项。参数<code>pathname</code>标识监控项的目标文件，调用者需要拥有该文件的读权限 (文件权限检查只会在调用该系统调用时执行1次。只要监控项存在，即使随后调用者不再拥有该文件的读权限，调用者依然能够收到该文件的事件通知)。参数<code>mask</code>是指定监控事件的位掩码。</p><p>　　● 若<code>pathname</code>之前未添加到<code>fd</code>的监控列表，则<code>inotify_add_watch()</code>会创建监控项，然后返回非负监控描述符 (同一inotify实例的监控描述符不会重复)。</p><p>　　● 若<code>pathname</code>之前已添加到<code>fd</code>的监控列表，则<code>inotify_add_watch()</code>会将<code>pathname</code>对应的监控项的位掩码修改为<code>mask</code>，然后返回该监控项的监控描述符。</p><p>　　系统调用<code>inotify_rm_watch()</code>会从参数<code>fd</code>引用的inotify实例的监控列表中删除参数<code>wd</code>指定的监控项 (<code>wd</code>是之前调用<code>inotify_add_watch()</code>时返回的监控描述符)。</p><h3 id="inotify事件">19.2 inotify事件</h3><p>　　当调用<code>inotify_add_watch()</code>时，可以指定给参数<code>mask</code>的事件位如下：</p><table><colgroup><col style="width:24%"><col style="width:5%"><col style="width:5%"><col style="width:65%"></colgroup><thead><tr><th>事件位</th><th>输入</th><th>输出</th><th>描述</th></tr></thead><tbody><tr><td><code>IN_ACCESS</code></td><td>✓</td><td>✓</td><td>文件被访问 (<code>read()</code>)</td></tr><tr><td><code>IN_ATTRIB</code></td><td>✓</td><td>✓</td><td>文件元数据被修改</td></tr><tr><td><code>IN_CLOSE_WRITE</code></td><td>✓</td><td>✓</td><td>打开的用于写入的文件被关闭</td></tr><tr><td><code>IN_CLOSE_NOWRITE</code></td><td>✓</td><td>✓</td><td>以只读方式打开的文件被关闭</td></tr><tr><td><code>IN_CREATE</code></td><td>✓</td><td>✓</td><td>在监控目录下创建文件或目录</td></tr><tr><td><code>IN_DELETE</code></td><td>✓</td><td>✓</td><td>在监控目录下删除文件或目录</td></tr><tr><td><code>IN_DELETE_SELF</code></td><td>✓</td><td>✓</td><td>监控目录或文件被删除</td></tr><tr><td><code>IN_MODIFY</code></td><td>✓</td><td>✓</td><td>文件被修改</td></tr><tr><td><code>IN_MOVE_SELF</code></td><td>✓</td><td>✓</td><td>监控目录或文件被移动</td></tr><tr><td><code>IN_MOVED_FROM</code></td><td>✓</td><td>✓</td><td>文件被移入监控目录</td></tr><tr><td><code>IN_MOVED_TO</code></td><td>✓</td><td>✓</td><td>文件被移出监控目录</td></tr><tr><td><code>IN_OPEN</code></td><td>✓</td><td>✓</td><td>文件被打开</td></tr><tr><td><code>IN_ALL_EVENTS</code></td><td>✓</td><td></td><td>以上所有输入事件的简写</td></tr><tr><td><code>IN_MOVE</code></td><td>✓</td><td></td><td><code>IN_MOVED_FROM | IN_MOVED_TO</code>的简写</td></tr><tr><td><code>IN_CLOSE</code></td><td>✓</td><td></td><td><code>IN_CLOSE_WRITE | IN_CLOSE_NOWRITE</code>的简写</td></tr><tr><td><code>IN_DONT_FOLLOW</code></td><td>✓</td><td></td><td>不要解引用符号链接 (Linux 2.6.15及以上版本)</td></tr><tr><td><code>IN_MASK_ADD</code></td><td>✓</td><td></td><td>将事件添加到<code>pathname</code>的监控位掩码</td></tr><tr><td><code>IN_ONESHOT</code></td><td>✓</td><td></td><td>仅监控1个事件的<code>pathname</code></td></tr><tr><td><code>IN_ONLYDIR</code></td><td>✓</td><td></td><td><code>pathname</code>不是目录时出错 (Linux 2.6.15及以上版本)</td></tr><tr><td><code>IN_IGNORED</code></td><td></td><td>✓</td><td>应用程序或内核取消监控</td></tr><tr><td><code>IN_ISDIR</code></td><td></td><td>✓</td><td><code>name</code>返回的文件名是目录</td></tr><tr><td><code>IN_Q_OVERFLOW</code></td><td></td><td>✓</td><td>事件队列溢出</td></tr><tr><td><code>IN_UNMOUNT</code></td><td></td><td>✓</td><td>对象所在的文件系统被卸载</td></tr></tbody></table><p>　　● 当权限、所有权、链接数、扩展属性、用户ID或组ID等文件元数据被修改时，将发生事件<code>IN_ATTRIB</code>。</p><p>　　● 当监控对象 (即文件或目录) 被删除时，将发生事件<code>IN_DELETE_SELF</code>。当监控目录下的文件被删除时，将发生事件<code>IN_DELETE</code>。</p><p>　　● 当监控对象被重命名时，将发生事件<code>IN_MOVE_SELF</code>。当监控目录下的文件被重命名时，将发生事件<code>IN_MOVED_FROM</code>和<code>IN_MOVED_TO</code> (当目录下的文件名是旧文件名时，将发生前者；当目录下的文件名是新文件名时，将发生后者)。</p><p>　　● <code>IN_DONT_FOLLOW</code>表示当<code>pathname</code>是符号链接时，不会解引用 (即监控对象是符号链接)。</p><p>　　● 当通过<code>inotify_add_watch()</code>修改监控项时，<code>mask</code>默认会替换当前位掩码。若指定了<code>IN_MASK_ADD</code>，则位掩码会修改为当前位掩码与<code>mask</code>进行或运算<code>|</code>得到的结果。</p><p>　　● <code>IN_ONESHOT</code>允许应用程序监控单个事件的<code>pathname</code>。当发生该事件后，监控项会自动删除。</p><p>　　● <code>IN_ONLYDIR</code>允许应用程序仅监控目录。若<code>pathname</code>不是目录，则<code>inotify_add_watch()</code>会出错 (<code>ENOTDIR</code>)。</p><h3 id="读取inotify事件">19.3 读取inotify事件</h3><p>　　在将监控项添加到监控列表后，应用程序可以通过<code>read()</code>从inotify文件描述符中读事件，以确定发生了哪些事件。若没有发生任何事件，则<code>read()</code>会阻塞，直到事件发生，除非文件描述符的状态标志<code>O_NONBLOCK</code>已启用 (在这种情况下，<code>read()</code>会导致错误<code>EAGAIN</code>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> wd;          <span class="comment">/* 发生事件的监控描述符 */</span></span><br><span class="line">    <span class="type">uint32_t</span> mask;   <span class="comment">/* 表示发生的事件的位 */</span></span><br><span class="line">    <span class="type">uint32_t</span> cookie; <span class="comment">/* 相关事件的cookie (用于rename()) */</span></span><br><span class="line">    <span class="type">uint32_t</span> len;    <span class="comment">/* 成员name的长度 */</span></span><br><span class="line">    <span class="type">char</span> name[];     <span class="comment">/* 可选的以字符\0结尾的文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　当事件发生后，每次调用<code>read()</code>都会将若干个结构体<code>inotify_event</code>存储在参数<code>buffer</code>指向的缓冲区中。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_19/an_input_buffer_containing_three_inotify_event_structures.svg"><p>　　成员<code>wd</code>表示发生事件的监控描述符，其值是之前调用<code>inotify_add_watch()</code>时返回的值。当通过1个inotify文件描述符监控多个文件或目录时，该成员很有用，它允许应用程序确定发生事件的文件或目录 (为此，应用程序需要维护用于关联监控描述符和路径名的数据结构)。</p><p>　　成员<code>mask</code>是表示发生的事件的位掩码，其取值范围与<code>inotify_add_watch()</code>的参数<code>mask</code>的相同，但含义有所不同：</p><p>　　● 当删除监控项时 (应用程序通过<code>inotify_rm_watch()</code>显式删除监控项，或者由于监控对象被删除或监控对象所在的文件系统被卸载而导致内核隐式删除监控项)，将会发生事件<code>IN_IGNORED</code>。当通过位<code>IN_ONESHOT</code>指定的事件自动删除时，<span style="background-color:#ff0">不会</span>发生事件<code>IN_IGNORED</code>。</p><p>　　● 若监控对象是目录，则<code>mask</code>会自动加上位<code>IN_ISDIR</code>。</p><p>　　● 当监控对象所在的文件系统被卸载时，会先发生事件<code>IN_UNMOUNT</code>，然后发生事件<code>IN_IGNORED</code>。</p><p>　　成员<code>cookie</code>用于将关联的事件绑定在一起。目前，只有重命名文件时，才会用到该成员。在这种情况下，文件的旧目录和新目录会分别发生事件<code>IN_MOVED_FROM</code>和<code>IN_MOVED_TO</code> (若这2个目录是同一目录，则该目录会发生这2个事件)。这2个事件的成员<code>cookie</code>有相同的唯一值，以允许应用程序关联它们。</p><p>　　当监控目录下的文件发生事件时，成员<code>name</code>会包含该文件的以字符<code>\0</code>结尾的文件名。当监控对象发生事件时，不会使用成员<code>name</code>，并且成员<code>len</code>将会是0。</p><p>　　成员<code>len</code>表示实际为成员<code>name</code>分配的字节数。因为成员<code>name</code>和下一个结构体<code>inotify_event</code>之间会有填充字节，所以结构体<code>inotify_event</code>的长度是<code>sizeof(struct inotify_event) + len</code>。</p><p>　　若传递给<code>read()</code>的缓冲区不足以容纳1个结构体<code>inotify_event</code>，则<code>read()</code>会导致错误<code>EINVAL</code> (在内核2.6.21之前，<code>read()</code>在这种情况下会返回0)。这可以通过为缓冲区分配<code>(sizeof(struct inotify_event) + NAME_MAX + 1)</code>字节解决。为缓冲区分配更大的空间允许应用程序通过单次调用<code>read()</code>来检索多个事件。</p><p>　　可以通过调用<code>ioctl(fd, FIONREAD, &amp;numbytes)</code>来获取当前可以从<code>fd</code>指定的inotify实例中读取的字节数。</p><p>　　从inotify文件描述符读出的事件会形成1个有序队列 (例如，当重命名文件后，事件<code>IN_MOVED_FROM</code>会先于<code>IN_MOVED_TO</code>读出)。该队列会占用内核内存，所以内核对inotify的操作施加了各种限制。超级用户可以通过目录<code>/proc/sys/fs/inotify</code>下的3个文件来配置这些限制：</p><p>　　● <code>max_queued_events</code>表示通过<code>inotify_init()</code>创建的新inotify实例上的排队的事件数的上限。若达到该限制，则会发生事件<code>IN_Q_OVERFLOW</code>，并且溢出的事件会被丢弃。溢出的事件的成员<code>wd</code>是-1。该限制的默认值通常是16384。</p><p>　　● <code>max_user_instances</code>表示每个实际用户ID可以创建的inotify实例数的限制。该限制的默认值通常是128。</p><p>　　● <code>max_user_watches</code>表示每个实际用户ID可以创建的监控项数的限制。该限制的默认值通常是8192。</p><p>　　当在队列末尾添加新事件时，若新事件的成员<code>wd</code>、<code>mask</code>、<code>cookie</code>和<code>name</code>与队列末尾的事件的相同，则内核会合并这2个事件 (即新事件不会参与排队)。这是因为很多应用程序不需要知道同一事件的重复实例，并且这样做还可以减少事件队列占用的内核内存。但是，这表示无法通过inotify准确地获取复发事件的发生次数或频率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* demo_inotify.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN (10 * (sizeof(struct inotify_event) + NAME_MAX + 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印结构体inotify_event的内容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">displayInotifyEvent</span><span class="params">(<span class="keyword">struct</span> inotify_event *i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    wd =%2d; &quot;</span>, i-&gt;wd);</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;cookie &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cookie =%4d; &quot;</span>, i-&gt;cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mask = &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_ACCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_ACCESS &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_ATTRIB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_ATTRIB &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_CLOSE_NOWRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_CLOSE_NOWRITE &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_CLOSE_WRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_CLOSE_WRITE &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_CREATE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_CREATE &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_DELETE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_DELETE &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_DELETE_SELF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_DELETE_SELF &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_IGNORED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_IGNORED &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_ISDIR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_ISDIR &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_MODIFY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_MODIFY &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_MOVE_SELF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_MOVE_SELF &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_MOVED_FROM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_MOVED_FROM &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_MOVED_TO)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_MOVED_TO &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_OPEN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_OPEN &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_Q_OVERFLOW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_Q_OVERFLOW &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i-&gt;mask &amp; IN_UNMOUNT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IN_UNMOUNT &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i-&gt;len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        name = %s\n&quot;</span>, i-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> inotifyFd, wd, j;</span><br><span class="line">    <span class="type">char</span> buf[BUF_LEN];</span><br><span class="line">    <span class="type">ssize_t</span> numRead;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> *<span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pathname... \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inotifyFd = inotify_init(); <span class="comment">/* 创建inotify实例 */</span></span><br><span class="line">    <span class="keyword">if</span> (inotifyFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;inotify_init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        wd = inotify_add_watch(inotifyFd, argv[j], IN_ALL_EVENTS);</span><br><span class="line">        <span class="keyword">if</span> (wd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;inotify_add_watch&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Watching %s using wd %d\n&quot;</span>, argv[j], wd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        numRead = read(inotifyFd, buf, BUF_LEN);</span><br><span class="line">        <span class="keyword">if</span> (numRead == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;read() from inotify fd returned 0!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %ld bytes from inotify fd\n&quot;</span>, (<span class="type">long</span>)numRead);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 处理read()通过缓冲区返回的所有事件 */</span></span><br><span class="line">        <span class="keyword">for</span> (p = buf; p &lt; buf + numRead;)</span><br><span class="line">        &#123;</span><br><span class="line">            event = (<span class="keyword">struct</span> inotify_event *)p;</span><br><span class="line">            displayInotifyEvent(event);</span><br><span class="line"></span><br><span class="line">            p += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inotify_event) + event-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了inotify的用法。首先，该程序会创建1个inotify文件描述符。然后，通过将命令行参数指定的文件添加到监控列表，每个监控项都会监控所有可能的事件。最后，进行无限循环，每次循环都会从inotify实例读1个缓冲区的事件，并且打印这些事件的相关信息。</p><h3 id="dnotify">19.4 dnotify</h3><p>　　相比inotify，dnotify存在很多限制。</p><p>　　● dnotify将事件通知实现为信号，信号的使用让应用程序的设计更加复制。此外，调用程序可能会修改信号的处理，所以难以在库中使用dnotify。inotify机制没有使用信号。</p><p>　　● dnotify的监控单元是目录。只要操作监控目录下的文件，应用程序就会收到事件通知。inotify允许监控目录或文件。</p><p>　　● 为了监控目录，dnotify需要应用程序打开监控目录的文件描述符，所以监控目录所在的文件系统无法卸载。此外，每个监控目录都需要1个文件描述符，所以应用程序会占用大量文件描述符。inotify没有使用引用监控对象的文件描述符，所以避免了这2个问题。</p><p>　　● 当监控目录下的文件被修改时，dnotify只会通知应用程序发生了事件，不会提供涉及该事件的文件的信息。此外，inotify提供的关于事件类型的信息比dnotify的更详细。</p><p>　　● 在某些情况下，dnotify不提供可靠的文件事件通知。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_18/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第18章 目录和链接"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第18章 目录和链接</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_20/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第20章 信号：基本概念">《Linux/UNIX系统编程手册》第20章 信号：基本概念 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>