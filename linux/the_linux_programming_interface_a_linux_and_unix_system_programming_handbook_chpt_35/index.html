<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_35/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_35/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_35/","title":"《Linux/UNIX系统编程手册》第35章 进程优先级和调度"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第35章 进程优先级和调度 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#nice%E5%80%BC"><span class="nav-text">35.1 nice值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0"><span class="nav-text">35.2 实时进程调度概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%96%E7%95%A5sched_rr"><span class="nav-text">35.2.1 策略SCHED_RR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%96%E7%95%A5sched_fifo"><span class="nav-text">35.2.2 策略SCHED_FIFO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%96%E7%95%A5sched_batch%E5%92%8Csched_idle"><span class="nav-text">35.2.3 策略SCHED_BATCH和SCHED_IDLE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6api"><span class="nav-text">35.3 实时进程调度API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E4%BC%98%E5%85%88%E7%BA%A7%E8%8C%83%E5%9B%B4"><span class="nav-text">35.3.1 实时优先级范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%92%8C%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">35.3.2 修改和检索策略和优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">35.3.2.1 修改调度策略和优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%B1%E5%93%8D%E8%B0%83%E5%BA%A6%E5%8F%82%E6%95%B0%E4%BF%AE%E6%94%B9%E7%9A%84%E7%89%B9%E6%9D%83%E5%92%8C%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="nav-text">35.3.2.2 影响调度参数修改的特权和资源限制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">35.3.2.3 检索调度策略和优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E9%94%81%E5%AE%9A%E7%B3%BB%E7%BB%9F"><span class="nav-text">35.3.2.4 防止实时进程锁定系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%BB%A7%E6%89%BF%E7%89%B9%E6%9D%83%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="nav-text">35.3.2.5 防止子进程继承特权调度策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BE%E5%BC%83cpu"><span class="nav-text">35.3.3 放弃CPU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sched_rr%E6%97%B6%E9%97%B4%E7%89%87"><span class="nav-text">35.3.4 SCHED_RR时间片</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E4%BA%B2%E5%92%8C%E6%80%A7"><span class="nav-text">35.4 CPU亲和性</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_35/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第35章 进程优先级和调度 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第35章 进程优先级和调度</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-10 00:00:00" itemprop="dateCreated datePublished" datetime="2025-10-10T00:00:00+08:00">2025-10-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-10-11 00:00:00" itemprop="dateModified" datetime="2025-10-11T00:00:00+08:00">2025-10-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>14k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　对于Linux和大多数UNIX实现，调度进程使用CPU的默认模型是<strong>轮询分时</strong>，即每个进程依次被允许使用CPU一小段时间，这段时间称为<strong>时间片</strong>或<strong>量子</strong>。轮询分时满足交互式多任务系统所需的2个重要要求：</p><p>　　● <span style="background-color:#ff0">公平性</span>：每个进程都获得CPU的一部分。</p><p>　　● <span style="background-color:#ff0">响应性</span>：进程无需长时间等待就能使用CPU。</p><p>　　在轮询时分算法下，进程不能直接决定何时能够使用CPU以及使用时间。每个进程默认轮流使用CPU，直到时间片耗尽或主动放弃CPU (例如，通过进入睡眠状态或执行磁盘读取)。若所有进程都试图尽可能多地使用CPU (即没有进程在I/O操作上休眠或阻塞)，则它们将获得大致相当的CPU份额。</p><p>　　进程属性<span style="background-color:#ff0">nice值</span>允许进程间接地影响内核调度算法。每个进程都有nice值，其范围从-20 (高优先级) 到+19 (低优先级)，默认为0。但是，对于Linux，nice值是线程属性。对于传统UNIX实现，只有特权进程才能为任意进程分配负nice值 (高优先级)。非特权进程只能通过将自己的nice值设置为大于0的值来降低自己的优先级。通过降低自己的优先级，进程对其他进程很 "友好"，这一事实赋予了该属性名称。</p><p>　　通过<code>fork()</code>创建的子进程会继承父进程的nice值，并且nice值在<code>exec()</code>期间会被保留。</p><p>　　进程并非严格按照nice值进行调度。相反，nice值仅充当权重因子，使内核调度程序优先调度优先级较高的进程。为进程分配较大的nice值不会导致它完全无法获得CPU，但会使它获得相对较少的CPU时间。nice值对进程调度的影响程度因Linux内核版本或UNIX系统而异。</p><p>　　从内核2.6.23开始，新添加的<span style="background-color:#ff0">完全公平调度程序</span> (CFS) 导致nice值的差值对内核调度的影响比之前的内核大很多。因此，nice值较小的进程获得的CPU时间比以前更长，而nice值较大的进程获得的CPU时间比以前更短。</p><p>　　对于多处理器系统，需要对 "高优先级的可运行进程始终优先于低优先级进程" 这一说法进行修正，因为每个CPU都有单独的运行队列，并且能够仅根据CPU运行队列进行优先级排序。</p><span id="more"></span><h3 id="nice值">35.1 nice值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who)</span>; <span class="comment">/* 成功时返回指定进程的nice值 (可能为负)，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who, <span class="type">int</span> prio)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>getpriority()</code>和<code>setpriority()</code>允许进程检索和修改进程的nice值。</p><p>　　这2个系统调用都有参数<code>which</code>和<code>who</code>，用于标识目标进程。参数<code>which</code>决定如何解释参数<code>who</code>，该参数只能被指定为<code>PRIO_PROCESS</code>、<code>PRIO_PGRP</code>或<code>PRIO_USER</code>。</p><p>　　● <code>PRIO_PROCESS</code>表示目标进程为进程ID等于<code>who</code>的进程。若<code>who</code>为0，则使用调用进程的进程ID。</p><p>　　● <code>PRIO_PGRP</code>表示目标进程为进程组ID等于<code>who</code>的所有进程。若<code>who</code>为0，则使用调用进程的进程组ID。</p><p>　　● <code>PRIO_USER</code>表示目标进程为实际用户ID等于<code>who</code>的所有进程。若<code>who</code>为0，则使用调用进程的实际用户ID。</p><p>　　参数<code>who</code>的数据类型<code>id_t</code>足以容纳进程ID或用户ID。</p><p>　　<code>getpriority()</code>会返回指定进程的nice值。若存在多个符合要求的进程，则返回最小的nice值。因为该系统调用在成功调用时可能会返回-1，所以在调用该系统调用前必须先将<code>errno</code>设置为0，然后在返回后检查返回值是否为-1以及<code>errno</code>是否为非0值。</p><p>　　<code>setpriority()</code>会将所有目标进程的nice值设置为参数<code>prio</code>指定的值。试图将nice值设置为范围 (+20到-19) 之外的值会自动被限制在该范围内。特权进程 (能力<code>CAP_SYS_NICE</code>) 可以修改任意进程的nice值。除了可以修改自己的nice值之外，当非特权进程的有效用户ID匹配其他进程的实际或有效用户ID时，非特权进程还可以修改该进程的nice值。<code>setpriority()</code>的Linux权限规则不同于SUSv3，SUSv3要求当非特权进程的实际或有效用户ID匹配其他进程的有效用户ID时，非特权进程才能修改该进程的nice值。不同的UNIX实现在这一点上有所不同。有些UNIX实现遵循SUSv3，而其他UNIX实现 (特别是BSD) 则与Linux相同。</p><p>　　在Linux内核2.6.12之前，<code>setpriority()</code>的非特权进程调用权限不同于之后的版本和SUSv3。当非特权进程的实际或有效用户ID匹配其他进程的实际用户ID时，非特权进程才能修改该进程的nice值。从Linux 2.6.12开始，权限规则修改为与Linux上的其他类似API (例如，<code>sched_setscheduler()</code>和<code>sched_setaffinity()</code>) 一致。</p><p>　　在Linux内核2.6.12之前，非特权进程只能通过<code>setpriority()</code> (不可逆地) 增加自己或其他进程的nice值。特权进程 (能力<code>CAP_SYS_NICE</code>) 可以通过该系统调用来减小nice值。</p><p>　　从内核2.6.12开始，Linux提供了资源限制<code>RLIMIT_NICE</code>，允许非特权进程增加nice值。非特权进程能够将自己的nice值最大增加至<code>20 - RLIMIT_NICE</code>。因为nice值的范围是-20到+19，所以<code>RLIMIT_NICE</code>的有效范围是1到40 (资源限制的负值有特殊含义，所以<code>RLIMIT_NICE</code>不使用范围-20到+19)。</p><p>　　从历史角度，nice值可通过调用<code>nice(incr)</code>修改，该调用会将调用进程的nice值增加<code>incr</code>。该函数仍然可用，但已被更通用的<code>setpriority()</code>取代。</p><p>　　与<code>setpriority()</code>类似的命令包括<code>nice</code>和<code>renice</code>。非特权进程可以通过命令<code>nice</code>来以更大的nice值运行程序，而特权进程可以通过该命令来以更小的nice值运行程序。超级用户可通过命令<code>renice</code>来修改现有进程的nice值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_setpriority.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> which, prio;</span><br><span class="line">    <span class="type">id_t</span> who;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span> || <span class="built_in">strchr</span>(<span class="string">&quot;pgu&quot;</span>, argv[<span class="number">1</span>][<span class="number">0</span>]) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(</span><br><span class="line">            <span class="string">&quot;%s &#123;p|g|u&#125; who priority\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  set priority of: p=process; g=process group; u=processes for user\n&quot;</span>,</span><br><span class="line">            argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据命令行参数设置nice值 */</span></span><br><span class="line">    which = (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>) ? PRIO_PROCESS : (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;g&#x27;</span>) ? PRIO_PGRP</span><br><span class="line">                                                                     : PRIO_USER;</span><br><span class="line">    who = getLong(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;who&quot;</span>);</span><br><span class="line">    prio = getInt(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="string">&quot;prio&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setpriority(which, who, prio) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;getpriority&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检索nice值 */</span></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    prio = getpriority(which, who);</span><br><span class="line">    <span class="keyword">if</span> (prio == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;getpriority&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nice value = %d\n&quot;</span>, prio);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>setpriority()</code>和<code>getpriority()</code>的用法。</p><h3 id="实时进程调度概述">35.2 实时进程调度概述</h3><p>　　标准内核调度算法通常为系统中运行的交互式进程和后台进程提供了足够的性能和响应能力。但是，实时应用程序对调度程序的要求更严格，包括以下要求：</p><p>　　● 实时应用程序为外部输入必须提供保证的最大响应时间。在很多情况下，这些保证的最大响应时间必须非常短 (例如，几分之一秒的数量级)。为了满足这一要求，内核必须提供高优先级进程及时获取CPU控制权的功能，从而抢占当前正在运行的任何进程。</p><p>　　● 高优先级进程应该能够保持对CPU的独占访问权，直到它完成或主动放弃CPU。</p><p>　　● 实时应用程序应该能够控制其组件进程的精确调度顺序。</p><p>　　SUSv3详细说明了能够部分满足这些要求的实时进程调度API (最初在POSIX.1b中定义)。该API提供了2种实时调度策略：<code>SCHED_RR</code> (轮询) 和<code>SCHED_FIFO</code> (先到先服务)。在这2个调度策略下运行的进程始终优先于标准轮询分时调度的进程，实时调度API使用常量<code>SCHED_OTHER</code>来标识标准轮询分时调度。</p><p>　　满足这3个要求的应用程序称为<span style="background-color:#ff0">硬实时</span>应用程序。但是，POSIX进程调度API不满足这3个要求，尤其是它没有为应用程序提供保证处理输入的响应时间的方法。要实现这一点，需要一些不属于主线Linux内核的操作系统特性 (这些特性也不是大多数标准操作系统的特性)。POSIX API提供的是<span style="background-color:#ff0">软实时</span>，允许控制进程调度。</p><p>　　在不给系统带来额外开销的情况下，很难添加对硬实时应用程序的支持，而这种开销又会与典型的桌面和服务器系统中占大多数的分时应用程序的性能要求冲突 (这也是为什么大多数UNIX内核和较旧的Linux内核不提供实时应用程序的原生支持)。但是，从大约版本2.6.18开始，Linux内核添加了各种用于原生完全支持硬实时应用程序而不会对分时操作施加这些开销的特性。</p><p>　　Linux提供了99个实时优先级，编号从1到99，并且该范围适用于这2种调度策略。这2种策略的优先级是相同的。若存在2个优先级相同的进程，并且分别采用<code>SCHED_RR</code>和<code>SCHED_FIFO</code>，则根据他们的调度顺序，这2个进程都可能是下一个有资格执行的进程。实际上，每个优先级都有1个可运行进程队列，并且下一个运行的进程是从最高优先级的非空队列的前面选择。</p><h4 id="策略sched_rr">35.2.1 策略<code>SCHED_RR</code></h4><p>　　对于策略<code>SCHED_RR</code>，同一优先级的进程以轮询分时的方式执行。进程每次使用CPU时都会获得固定时长的时间片。一旦被调度，使用该策略的进程将保持对CPU的控制，直到出现以下情况下之一：</p><p>　　● 进程的时间片到期。</p><p>　　● 进程通过执行阻塞系统调用或调用系统调用<code>sched_yield()</code>主动放弃CPU。</p><p>　　● 进程终止。</p><p>　　● 进程被更高优先级的进程抢占。</p><p>　　对于前2种情况，进程会失去对CPU的访问，并且被放置在其优先级队列的末尾。对于最后1个情况，当更高优先级的进程停止执行时，被抢占的进程会继续执行，消耗剩余的时间片 (即被抢占的进程仍然处于其优先级队列的开头)。</p><p>　　对于策略<code>SCHED_RR</code>和<code>SCHED_FIFO</code>，运行中的进程可能因以下原因之一而被抢占：</p><p>　　● 更高优先级的进程退出阻塞状态 (例如，等待的I/O操作完成)。</p><p>　　● 其他进程的优先级被提高至高于运行中的进程的优先级的值。</p><p>　　● 运行中的进程的优先级被降低至低于其他某些可运行的进程的优先级的值。</p><p>　　策略<code>SCHED_RR</code>与标准轮询分时调度算法 (<code>SCHED_OTHER</code>) 类似，最大的区别是严格的优先级，高优先级进程始终优先于低优先级进程。相比之下，较低的nice值 (即较高的优先级) 并不会赋予进程独占CPU的权限，nice值只是充当权重因子。另一个重要的区别是该策略允许精确地控制进程的调度顺序。</p><h4 id="策略sched_fifo">35.2.2 策略<code>SCHED_FIFO</code></h4><p>　　策略<code>SCHED_FIFO</code>与<code>SCHED_RR</code>类似，最大的不同是没有时间片。一旦<code>SCHED_FIFO</code>进程获得CPU的访问权，它会一直执行，直到出现以下情况之一：</p><p>　　● 进程通过执行阻塞系统调用或调用系统调用<code>sched_yield()</code>主动放弃CPU。</p><p>　　● 进程终止。</p><p>　　● 进程被更高优先级的进程抢占。</p><p>　　对于第1种情况，进程会被放置在其优先级队列的末尾。对于最后1种情况，当更高优先级的进程 (因阻塞或终止) 停止执行时，被抢占的进程会继续执行 (即被抢占的进程仍然处于其优先级队列的开头)。</p><h4 id="策略sched_batch和sched_idle">35.2.3 策略<code>SCHED_BATCH</code>和<code>SCHED_IDLE</code></h4><p>　　Linux内核2.6系列添加了非标准调度策略<code>SCHED_BATCH</code>和<code>SCHED_IDLE</code>。尽管这2个策略需要通过POSIX实时调度API设置，但它们并不是实时策略。</p><p>　　策略<code>SCHED_BATCH</code>添加于内核2.6.16，与策略<code>SCHED_OTHER</code>类似。不同之处在于该策略会降低经常唤醒的作业的调度频率。该策略旨在用于进程的批量执行。</p><p>　　策略<code>SCHED_IDLE</code>添加于内核2.6.23，与策略<code>SCHED_OTHER</code>类似，但提供的功能等同于非常大的nice值 (即大于+19)。nice值对该策略没有意义。该策略旨在用于运行低优先级作业，只有当系统中没有其他作业需要CPU时，这些作业才会得到CPU的很大一部分。</p><h3 id="实时进程调度api">35.3 实时进程调度API</h3><p>　　尽管实时调度从内核2.0开始就成为了Linux的一部分，但实现过程中存在一些问题。2.2内核以及早期的2.4内核中的很多特性的实现仍然存在问题。大部分问题在内核2.4.20中得到了解决。</p><h4 id="实时优先级范围">35.3.1 实时优先级范围</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回非负的整数优先级，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_min</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_max</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>sched_get_priority_min()</code>和<code>sched_get_priority_max()</code>分别会返回参数<code>policy</code>指定的调度策略的最小和最大优先级。<code>policy</code>可以被指定为<code>SCHED_RR</code>或<code>SCHED_FIFO</code>。对于Linux，这2个系统调用分别会返回1和99 (无论<code>SCHED_RR</code>还是<code>SCHED_FIFO</code>)。换句话说，这2个实时策略的优先级范围完全重合 (哪个进程先被调度取决于进程在优先级队列中的位置)。</p><p>　　实时优先级的范围因UNIX实现而异。因此，不应该将优先级编码到应用程序中，而应根据这2个系统调用的返回值来指定优先级 (例如，策略<code>SCHED_RR</code>的最小优先级应该被指定为<code>sched_get_priority_min(SCHED_RR)</code>)。</p><p>　　SUSv3并未要求策略<code>SCHED_RR</code>和<code>SCHED_FIFO</code>使用相同的优先级范围，但大多数UNIX实现都是如此。</p><h4 id="修改和检索策略和优先级">35.3.2 修改和检索策略和优先级</h4><h5 id="修改调度策略和优先级">35.3.2.1 修改调度策略和优先级</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setscheduler</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> policy, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setparam</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sched_priority; <span class="comment">/* 调度优先级 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>sched_setscheduler()</code>会修改进程ID为<code>pid</code>的进程的调度策略和优先级。若<code>pid</code>为0，则修改调用进程的调度策略和优先级。系统调用<code>sched_setparam()</code>会修改进程ID为<code>pid</code>的进程的调度优先级。这2个系统调用的参数<code>pid</code>和<code>param</code>相同。</p><p>　　SUSv3将参数<code>param</code>定义为结构体，并且允许实现添加额外的特定于实现的成员。但是，Linux和大多数UNIX实现仅提供了成员<code>sched_priority</code>，用于指定调度优先级。对于策略<code>SCHED_RR</code>和<code>SCHED_FIFO</code>，该成员必须被指定为<code>sched_get_priority_min()</code>和<code>sched_get_priority_max()</code>之间的值。对于其他策略，该成员必须被指定为0。</p><p>　　参数<code>policy</code>用于指定进程的调度策略，只能被指定为以下策略之一：</p><table><colgroup><col style="width:16%"><col style="width:76%"><col style="width:6%"></colgroup><thead><tr><th>策略</th><th>描述</th><th>SUSv3</th></tr></thead><tbody><tr><td><code>SCHED_FIFO</code></td><td>实时先到先服务</td><td>✓</td></tr><tr><td><code>SCHED_RR</code></td><td>实时轮询</td><td>✓</td></tr><tr><td><code>SCHED_OTHER</code></td><td>标准轮询分时</td><td>✓</td></tr><tr><td><code>SCHED_BATCH</code></td><td>与<code>SCHED_OTHER</code>类似，但用于批量执行 (Linux 2.6.16及以上版本)</td><td></td></tr><tr><td><code>SCHED_IDLE</code></td><td>与<code>SCHED_OTHER</code>类似，但优先级低于nice值+19 (Linux 2.6.23及以上版本)</td><td></td></tr></tbody></table><p>　　成功的<code>sched_setscheduler()</code>和<code>sched_setparam()</code>调用会将<code>pid</code>指定的进程移动到优先级队列的末尾。</p><p>　　SUSv3要求，成功的<code>sched_setscheduler()</code>调用应该返回上一个调度策略。但是，Linux有所不同，该系统调用会在成功时返回0。可移植应用程序应该通过检查该系统调用的返回值不是-1来判断是否成功。</p><p>　　通过<code>fork()</code>创建的子进程会继承父进程的调度策略和优先级，并且调度策略和优先级在<code>exec()</code>期间会被保留。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sched_set.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j, pol;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">sp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strchr</span>(<span class="string">&quot;rfo&quot;</span>, argv[<span class="number">1</span>][<span class="number">0</span>]) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s policy priority [pid...]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  policy is &#x27;r&#x27; (RR), &#x27;f&#x27; (FIFO), &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH <span class="comment">/* 特定于Linux */</span></span></span><br><span class="line">                 <span class="string">&quot;&#x27;b&#x27; (BATCH), &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE <span class="comment">/* 特定于Linux */</span></span></span><br><span class="line">                 <span class="string">&quot;&#x27;i&#x27; (IDLE), &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                 <span class="string">&quot;or &#x27;o&#x27; (OTHER)\n&quot;</span>,</span><br><span class="line">                 argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pol = (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>) ? SCHED_RR : (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>) ? SCHED_FIFO</span><br><span class="line">                                       :</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH</span></span><br><span class="line">                                       (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;b&#x27;</span>) ? SCHED_BATCH</span><br><span class="line">                                       :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE</span></span><br><span class="line">                                       (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>) ? SCHED_IDLE</span><br><span class="line">                                                           :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                                           SCHED_OTHER;</span><br><span class="line">    sp.sched_priority = getInt(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;priority&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sched_setscheduler(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>), pol, &amp;sp) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sched_setscheduler&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>sched_setscheduler()</code>的用法。第1个命令行参数是1个字母，用于指定调度策略。第2个命令行参数是整数，用于指定优先级。剩余的命令行参数是目标进程的进程ID。</p><h5 id="影响调度参数修改的特权和资源限制">35.3.2.2 影响调度参数修改的特权和资源限制</h5><p>　　对于2.6.12之前的内核，通常只有特权进程 (能力<code>CAP_SYS_NICE</code>) 才能修改调度策略和优先级。但是，当非特权进程的有效用户ID匹配目标进程的实际或有效用户ID时，它可以将目标进程的调度策略修改为<code>SCHED_OTHER</code>。</p><p>　　从内核2.6.12开始，随着新的非标准资源限制<code>RLIMIT_RTPRIO</code>的添加，设置实时调度策略和优先级的规则发生了变化。与较旧的内核相同，特权进程 (能力<code>CAP_SYS_NICE</code>) 可以修改任意进程的调度策略和优先级。但是，非特权进程也可以根据以下规则修改调度策略和优先级：</p><p>　　● 若进程的<code>RLIMIT_RTPRIO</code>软限制不为0，则它可以任意修改自己的调度策略和优先级，但它可以设置的实时优先级上限不能超过其当前实时优先级 (若进程当前在实时策略下运行) 与其<code>RLIMIT_RTPRIO</code>软限制中的最大值。</p><p>　　● 若进程的<code>RLIMIT_RTPRIO</code>软限制为0，则它只能降低自己的实时优先级或从实时策略切换到非实时策略。</p><p>　　● 策略<code>SCHED_IDLE</code>比较特殊，运行在该策略下的进程无法修改自己的策略 (无论<code>RLIMIT_RTPRIO</code>软限制是多少)。</p><p>　　● 进程也可以修改其他非特权进程的调度策略和优先级，只要该进程的有效用户ID匹配目标进程的实际或有效用户ID。</p><p>　　● 进程的<code>RLIMIT_RTPRIO</code>软限制仅决定其他进程对该进程或该进程对自己的调度策略和优先级的修改。非0的限制不会赋予非特权进程修改其他进程的调度策略和优先级的能力。</p><p>　　从内核2.6.25开始，Linux添加了实时调度组的概念，由内核选项<code>CONFIG_RT_GROUP_SCHED</code>配置，它还会影响设置实时调度策略时可以做出的修改。</p><h5 id="检索调度策略和优先级">35.3.2.3 检索调度策略和优先级</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getscheduler</span><span class="params">(<span class="type">pid_t</span> pid)</span>; <span class="comment">/* 成功时返回调度策略，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getparam</span><span class="params">(<span class="type">pid_t</span> pid, <span class="keyword">struct</span> sched_param *param)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>sched_getscheduler()</code>和<code>sched_getparam()</code>分别会检索进程ID为<code>pid</code>的进程的调度策略和优先级。若<code>pid</code>为0，则检索调用进程的信息。此外，非特权进程可以通过这2个系统调用来检索任意进程的信息。</p><p>　　<code>sched_getparam()</code>会通过参数<code>param</code>指向的结构体<code>sched_param</code>的成员<code>sched_priority</code>来返回指定进程的实时优先级。</p><p>　　若<code>sched_getscheduler()</code>调用成功，则返回35.3.2.1的表格所列出的策略之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sched_view.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j, pol;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">sp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        pol = sched_getscheduler(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (pol == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sched_getscheduler&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sched_getparam(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>), &amp;sp) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sched_getparam&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %-5s %2d\n&quot;</span>, argv[j],</span><br><span class="line">               (pol == SCHED_OTHER) ? <span class="string">&quot;OTHER&quot;</span> : (pol == SCHED_RR) ? <span class="string">&quot;RR&quot;</span></span><br><span class="line">                                            : (pol == SCHED_FIFO) ? <span class="string">&quot;FIFO&quot;</span></span><br><span class="line">                                            :</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH <span class="comment">/* 特定于Linux */</span></span></span><br><span class="line">                                            (pol == SCHED_BATCH) ? <span class="string">&quot;BATCH&quot;</span></span><br><span class="line">                                            :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE <span class="comment">/* 特定于Linux */</span></span></span><br><span class="line">                                            (pol == SCHED_IDLE) ? <span class="string">&quot;IDLE&quot;</span></span><br><span class="line">                                                                :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                                                <span class="string">&quot;???&quot;</span>,</span><br><span class="line">               sp.sched_priority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>sched_getscheduler()</code>和<code>sched_getparam()</code>的用法。以下shell会话展示了该程序的用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">sleep</span> 100 &amp;</span></span><br><span class="line">[1] 2006</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./sched_view 2006</span></span><br><span class="line">2006: OTHER  0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./sched_set f 25 2006</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./sched_view 2006</span></span><br><span class="line">2006: FIFO  25</span><br></pre></td></tr></table></figure><h5 id="防止实时进程锁定系统">35.3.2.4 防止实时进程锁定系统</h5><p>　　<code>SCHED_RR</code>和<code>SCHED_FIFO</code>进程会抢占所有低优先级的进程，所以当开发使用这些策略的应用程序时，需要注意失控的实时应用程序可能因过度占用CPU而锁定系统。从编程角度，可以通过以下方法来避免这种可能性：</p><p>　　● 通过<code>setrlimit()</code>设置合适的较小的软CPU时间资源限制 (<code>RLIMIT_CPU</code>)。若进程消耗过多的CPU时间，则信号<code>SIGXCPU</code>会被发送给该进程 (默认处理方式是终止进程并生成核心转储文件)。</p><p>　　● 通过<code>alarm()</code>设置定时器。若进程持续运行的挂钟时间超过<code>alarm()</code>指定的秒数，则信号<code>SIGALRM</code>会被发送给该进程 (默认处理方式是终止进程)。</p><p>　　● 创建1个以高实时优先级运行的看门狗进程，该进程会反复循环，休眠指定时间，然后唤醒并监控其他进程的状态。这种监控可以包括每个进程的CPU时间时钟的值以及通过<code>sched_getscheduler()</code>和<code>sched_getparam()</code>检查每个进程的调度策略和优先级。若某个进程被认为行为异常，则看门狗线程可以降低其优先级，或者通过发送合适的信号来暂停或终止它。</p><p>　　● 从内核2.6.25开始，Linux提供了非标准资源限制<code>RLIMIT_RTTIME</code> (单位为毫秒)，用于控制在实时调度策略下运行的进程在单次突发中可消耗的CPU时间量。该资源限制可以限制进程在不执行阻塞系统调用时可消耗的CPU时间量。当进程执行阻塞系统调用时，其已消耗的CPU时间会被重置为0。当进程被高优先级进程抢占、时间片到期 (对于<code>SCHED_RR</code>进程) 或调用<code>sched_yield()</code>时，其已消耗的CPU时间不会被重置。当进程达到其CPU时间限制时，信号<code>SIGXCPU</code>会被发送给该进程。此外。2.6.25中的修改还有助于防止失控的实时进程锁定系统。</p><h5 id="防止子进程继承特权调度策略">35.3.2.5 防止子进程继承特权调度策略</h5><p>　　Linux 2.6.32添加了<code>SCHED_RESET_ON_FORK</code>作为调用<code>sched_setscheduler()</code>时可以指定给<code>policy</code>的值。它是标志值，可以与35.3.2.1的表格中的策略进行或运算<code>|</code>。若设置了该标志，则通过<code>fork()</code>创建的子进程不会继承特权调度策略和优先级，具体规则如下：</p><p>　　● 若调用进程具有实时调度策略 (<code>SCHED_RR</code>或<code>SCHED_FIFO</code>)，则子进程的策略会被重置<code>SCHED_OTHER</code>。</p><p>　　● 若进程有负的nice值 (即较高的优先级)，则子进程的nice值会被重置为0。</p><p>　　标志<code>SCHED_RESET_ON_FORK</code>旨在用于媒体播放应用程序。它允许创建单个具有实时调度策略的进程，该策略不会被子进程继承。使用该标志可以防止fork炸弹 (通过创建多个在实时调度策略下运行的子进程来试图逃避资源限制<code>RLIMIT_RTTIME</code>设置的上限)。</p><p>　　一旦进程的标志<code>SCHED_RESET_ON_FORK</code>被启用，只有特权进程 (能力<code>CAP_SYS_NICE</code>) 才能禁用该标志。当创建子进程时，子进程的的该标志会被禁用。</p><h4 id="放弃cpu">35.3.3 放弃CPU</h4><p>　　实时进程可以通过以下2种方式放弃CPU：</p><p>　　● 调用会阻塞进程的系统调用 (例如，在终端中调用<code>read()</code>)。</p><p>　　● 调用<code>sched_yield()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_yield</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>sched_yield()</code>的行为很简单。若调用进程的优先级队列中存在其他可运行的进程，则调用进程会被放置在队列的末尾，并且队列开头的进程会被调度使用CPU；否则，该系统调用不会进行任何操作 (调用进程继续使用CPU)。</p><p>　　SUSv3允许<code>sched_yield()</code>出错。但是，对于Linux和大部分UNIX实现，该系统调用总是会成功。可移植应用程序总是应该检查该系统调用的返回值。</p><p>　　非实时进程调度<code>sched_yield()</code>的行为是未定义的。</p><h4 id="sched_rr时间片">35.3.4 <code>SCHED_RR</code>时间片</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_rr_get_interval</span><span class="params">(<span class="type">pid_t</span> pid, <span class="keyword">struct</span> timespec *tp)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>sched_rr_get_interval()</code>会将进程ID为<code>pid</code>的<code>SCHED_RR</code>进程的时间片存储在参数<code>tp</code>指向的缓冲区中 (见15.2.2)。若<code>pid</code>为0，则将调用进程作为目标进程。</p><h3 id="cpu亲和性">35.4 CPU亲和性</h3><p>　　对于多处理器系统，当进程被重新调度时，它不一定会在上一次运行的CPU上运行 (通常是因为该CPU可能很忙)。当进程切换CPU时，会有性能影响：假设进程的某行数据加载位于旧CPU的缓存中，为了该行数据加载到新CPU的缓存中，必须先使其无效，若数据未被修改，则将其丢弃；若数据已被修改，则将其刷新到内存 (为了防止缓存不一致，多处理器架构仅允许数据在同一时间存储在1个CPU的缓存中)。这会消耗执行时间。因此，Linux内核 (2.6) 会尽量确保进程的<span style="background-color:#ff0">软</span>CPU亲和性——进程尽可能地被重新调度到上一次运行的CPU上。</p><p>　　<span style="background-color:#ff0">缓存行</span>是缓存中类似于虚拟内存管理系统中页的概念。它是CPU缓存与内存之间的数据传输单位，其范围通常为32~128字节。</p><p>　　特定于Linux的文件<code>/proc/PID/stat</code>中的1个字段可用于获取进程当前正在运行或最后运行的CPU的编号。</p><p>　　有时，需要为进程设置<span style="background-color:#ff0">硬</span>CPU亲和性，以便于明确限制该进程始终在某个可用CPU或可用CPU的子集上运行。原因如下：</p><p>　　● 避免无效化缓存数据而导致的性能影响。</p><p>　　● 若多个线程 (或进程) 在访问同一数据，则可以将它们全部限制在同一CPU上，这样它们就不会争用数据而导致缓存未命中，从而获得性能优势。</p><p>　　● 对于时间关键型应用程序，可能需要将系统中的大多数进程限制在其他CPU上，同时为时间关键型应用程序保留CPU。</p><p>　　内核引导选项<code>isolcpus</code>可用于将多个CPU与正常的内核调度算法隔离。该引导选项是实现第3个场景的首选方法。Linux还提供了内核选项<code>cpuset</code>，可以在包含大量CPU的系统上使用，以实现对如何将CPU和内存分配给进程的更复杂的控制。</p><p>　　Linux 2.6提供了非标准系统调用<code>sched_setaffinity()</code>和<code>sched_getaffinity()</code>来修改和检索线程的硬CPU亲和性。这2个系统调用是特定于Linux的。</p><p>　　很多UNIX实现都提供了用于控制CPU亲和性的接口 (例如，HP-UX和Solaris提供了系统调用<code>pset_bind()</code>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> len, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> len, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_ZERO</span><span class="params">(<span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_SET</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_CLR</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">CPU_ISSET</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">/* cpu在set中时返回真(1)，cpu不在set中时返回假(0) */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>sched_setaffinity()</code>会设置线程ID (通过<code>gettid()</code>返回) 为<code>pid</code>的线程的CPU亲和性。若<code>pid</code>为0，则设置调用线程的CPU亲和性。为线程设置的CPU亲和性通过参数<code>set</code>指向的结构体<code>cpu_set_t</code>指定。</p><p>　　系统调用<code>sched_getaffinity()</code>会检索线程ID为<code>pid</code>的线程的CPU亲和性掩码。若<code>pid</code>为0，则检索调用线程的CPU亲和性掩码。CPU亲和性掩码结果存储在参数<code>set</code>指向的结构体<code>cpu_set_t</code>中。参数<code>len</code>应该被指定为该结构体的字节数 (即<code>sizeof(cpu_set_t)</code>)。</p><p>　　尽管数据类型<code>cpu_set_t</code>被实现为位掩码，但应该将其视为不透明的结构体。对该结构体的所有操作应该通过宏<code>CPU_ZERO()</code>、<code>CPU_SET()</code>、<code>CPU_CLR()</code>和<code>CPU_ISSET()</code>进行。glibc还提供了很多其他用于处理该结构体的宏。</p><p>　　● <code>CPU_ZERO()</code>会将<code>set</code>初始化为空。</p><p>　　● <code>CPU_SET()</code>会将CPU <code>cpu</code>添加到<code>set</code>。</p><p>　　● <code>CPU_CLR()</code>会从<code>set</code>中删除CPU <code>cpu</code>。</p><p>　　● <code>CPU_ISSET()</code>会在CPU <code>cpu</code>是<code>set</code>的成员时返回真。</p><p>　　以下代码展示了如何将<code>pid</code>指定的线程限制在4处理器系统的第1个CPU以外的CPU上运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">cpu_set_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">CPU_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">CPU_SET(<span class="number">1</span>, &amp;<span class="built_in">set</span>);</span><br><span class="line">CPU_SET(<span class="number">2</span>, &amp;<span class="built_in">set</span>);</span><br><span class="line">CPU_SET(<span class="number">3</span>, &amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">sched_setaffinity(pid, CPU_SETSIZE, &amp;<span class="built_in">set</span>);</span><br></pre></td></tr></table></figure><p>　　对于<code>sched_getaffinity()</code>，若<code>set</code>指定的CPU不对应系统中的任何CPU，则会出错 (<code>EINVAL</code>)。若<code>set</code>中不包含调用线程正在运行的CPU，则该线程会被迁移到<code>set</code>中的某个CPU上。</p><p>　　当非特权线程的有效用户ID匹配目标线程的实际或有效用户ID时，非特权线程可以设置目标线程的CPU亲和性。特权线程 (能力<code>CAP_SYS_NICE</code>) 可以修改任何线程的CPU亲和性。</p><p>　　若目标线程的CPU亲和性掩码未被修改，则<code>sched_getaffinity()</code>会返回包含系统中的所有CPU的集合。非特权线程可以调用<code>sched_getaffinity()</code>来检索任意线程的CPU亲和性掩码。</p><p>　　通过<code>fork()</code>创建的子进程会继承父进程中调用<code>fork()</code>的线程的CPU亲和性掩码，并且该掩码在<code>exec()</code>期间会被保留。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第34章 进程组、会话和作业控制"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第34章 进程组、会话和作业控制</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_36/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第36章 进程资源">《Linux/UNIX系统编程手册》第36章 进程资源 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>