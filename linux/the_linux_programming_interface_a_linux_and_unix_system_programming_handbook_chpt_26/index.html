<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_26/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_26/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_26/","title":"《Linux/UNIX系统编程手册》第26章 监控子进程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第26章 监控子进程 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">26.1 等待子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait"><span class="nav-text">26.1.1 wait()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#waitpid"><span class="nav-text">26.1.2 waitpid()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81%E5%80%BC"><span class="nav-text">26.1.3 等待状态值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A4%84%E7%90%86%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-text">26.1.4 在信号处理函数中处理进程终止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8waitid"><span class="nav-text">26.1.5 系统调用waitid()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8wait3%E5%92%8Cwait4"><span class="nav-text">26.1.6 系统调用wait3()和wait4()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-text">26.2 孤儿进程和僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7sigchld"><span class="nav-text">26.3 信号SIGCHLD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8Csigchld%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">26.3.1 注册SIGCHLD处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E4%BF%A1%E5%8F%B7sigchld"><span class="nav-text">26.3.2 忽略信号SIGCHLD</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_26/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第26章 监控子进程 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第26章 监控子进程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-06-14 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-14T00:00:00+08:00">2025-06-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-06-15 00:00:00" itemprop="dateModified" datetime="2025-06-15T00:00:00+08:00">2025-06-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="等待子进程">26.1 等待子进程</h3><p>　　对于多进程应用程序，父进程可能需要知道子进程何时终止及其原因。<code>wait()</code>等系统调用提供了这个功能。</p><h4 id="wait">26.1.1 <code>wait()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>; <span class="comment">/* 返回终止的子进程的进程ID，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>wait()</code>会执行以下步骤：</p><p>　　1) 若调用<code>wait()</code>时调用进程没有之前未等待的终止的子进程，则调用进程会阻塞，直到某个子进程终止。若调用<code>wait()</code>时调用进程有之前未等待的终止的子进程，则会立即返回。</p><p>　　2) 若<code>status</code>不为<code>NULL</code>，则子进程如何终止的相关信息会存储在该参数指向的缓冲区中。</p><p>　　3) 内核将进程CPU时间和资源使用统计添加到调用进程的所有子进程的运行总计中。</p><p>　　4) <code>wait()</code>将终止的子进程的进程ID作为结果返回。</p><p>　　当出错时，<code>wait()</code>会返回-1。可能的错误之一是调用进程没有之前未等待的子进程，这会导致将<code>errno</code>设置为<code>ECHILD</code>。</p><p>　　SUSv3没有说明存在多个之前未等待的终止的子进程时<code>wait()</code>返回子进程的进程ID的顺序，该顺序因实现而异 (甚至可能因Linux内核版本而异)。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* multi_wait.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span> <span class="comment">/* 函数currTime()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numDead;    <span class="comment">/* 迄今为止已等待的子进程的数量 */</span></span><br><span class="line">    <span class="type">pid_t</span> childPid; <span class="comment">/* 等待的子进程的进程ID */</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s sleep-time...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为每个命令行参数创建1个子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (fork())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程睡眠一段时间并终止 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s] child %d started with PID %ld, sleeping %s seconds\n&quot;</span>,</span><br><span class="line">                   currTime(<span class="string">&quot;%T&quot;</span>), j, (<span class="type">long</span>)getpid(), argv[j]);</span><br><span class="line">            sleep(getInt(argv[j], GN_NONNEG, <span class="string">&quot;sleep-time&quot;</span>));</span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* 父进程持续循环 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numDead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        childPid = wait(<span class="literal">NULL</span>); <span class="comment">/* 等待所有子进程终止 */</span></span><br><span class="line">        <span class="keyword">if</span> (childPid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == ECHILD)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No more children - bye!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        numDead++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s] wait() returned child PID %ld (numDead=%d)\n&quot;</span>,</span><br><span class="line">               currTime(<span class="string">&quot;%T&quot;</span>), (<span class="type">long</span>)childPid, numDead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>wait()</code>的用法。该程序会为每个命令行参数创建1个子进程，每个子进程都睡眠对应的命令行参数指定的秒数并终止。当所有子进程都创建完成后，父进程会循环调用<code>wait()</code>来等待所有子进程终止。</p><h4 id="waitpid">26.1.2 <code>waitpid()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>; <span class="comment">/* 返回终止的子进程的进程ID或0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　对于系统调用<code>waitpid()</code>，参数<code>pid</code>用于指定等待的子进程。</p><p>　　● 若<code>pid</code>大于0，则等待进程ID为<code>pid</code>的子进程。</p><p>　　● 若<code>pid</code>等于0，则等待与调用进程 (父进程) 属于同一进程组的所有子进程。</p><p>　　● 若<code>pid</code>等于-1，则等待所有子进程。调用<code>waitpid(-1, &amp;status, 0)</code>等同于调用<code>wait(&amp;status)</code>。</p><p>　　● 若<code>pid</code>小于-1，则等待进程组ID为<code>pid</code>的绝对值的进程组中的所有子进程。</p><p>　　若调用进程没有匹配<code>pid</code>的子进程，则<code>waitpid()</code>会返回-1，并将<code>error</code>设置为<code>ECHILD</code>。</p><p>　　参数<code>status</code>与<code>wait()</code>的参数<code>status</code>相同。</p><p>　　参数<code>options</code>是位掩码，可以包含标志<code>WUNTRACED</code>、<code>WCONTINUED</code>和<code>WNOHANG</code>中的任意个标志 (或运算<code>|</code>)。</p><p>　　● <code>WUNTRACED</code>表示除了返回子进程如何终止的相关信息之外，还会在子进程被信号停止返回信息。</p><p>　　● <code>WCONTINUED</code>表示还返回被信号<code>SIGCONT</code>恢复的停止的子进程的相关信息 (Linux 2.6.10及以上版本) 。</p><p>　　● <code>WNOHANG</code>表示当<code>pid</code>指定的子进程的状态未发生改变时，立即返回 (而非阻塞)。此时，<code>waitpid()</code>会返回0。</p><p>　　在SUSv3对<code>waitpid()</code>的描述中，标志<code>WUNTRACED</code>的名称是该标志源于BSD的历史产物。对于BSD，进程可以2种方式停止：作为被系统调用<code>ptrace()</code>跟踪的结果而停止或被信号停止 (即未被跟踪)。当子进程被<code>ptrace()</code>跟踪时，任何信号 (除了<code>SIGKILL</code>) 的到达都会导致子进程停止，所以父进程会收到信号<code>SIGCHLD</code>。无论子进程是否忽略信号，都不会影响这种行为。但是，当子进程阻塞信号时，它不会停止 (除非收到的信号是<code>SIGSTOP</code>，因为该信号的处理方式无法被修改)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* child_status.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_wait_status.h&quot;</span> <span class="comment">/* 函数printWaitStatus()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [exit-status]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程: 以指定的状态终止或循环等待信号 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child started with PID = %ld\n&quot;</span>, (<span class="type">long</span>)getpid());</span><br><span class="line">        <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(getInt(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;exit-status&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;)</span><br><span class="line">            &#123;</span><br><span class="line">                pause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程: 循环等待子进程，直到被信号中断或子进程终止 */</span></span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            childPid = waitpid(<span class="number">-1</span>, &amp;status, WUNTRACED</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WCONTINUED <span class="comment">/* 较旧的Linux版本未提供该标志 */</span></span></span><br><span class="line">                                                | WCONTINUED</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (childPid == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 以十六进制打印状态 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;waitpid() returned: PID=%ld; status=0x%04x (%d,%d)\n&quot;</span>,</span><br><span class="line">                   (<span class="type">long</span>)childPid, (<span class="type">unsigned</span> <span class="type">int</span>)status, status &gt;&gt; <span class="number">8</span>, status &amp; <span class="number">0xff</span>);</span><br><span class="line">            printWaitStatus(<span class="literal">NULL</span>, status);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status) || WIFSIGNALED(status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>waitpid()</code>的用法。</p><h4 id="等待状态值">26.1.3 等待状态值</h4><p>　　<code>wait()</code>和<code>waitpid()</code>通过参数<code>status</code>返回的信息用于区分子进程发生的事件：</p><p>　　● 子进程调用<code>_exit()</code> (或<code>exit()</code>)。</p><p>　　● 子进程被未被处理的信号终止。</p><p>　　● 子进程被信号停止，并且调用<code>waitpid()</code>时指定了标志<code>WUNTRACED</code>。</p><p>　　● 停止的子进程被信号<code>SIGCONT</code>恢复，并且调用<code>waitpid()</code>时指定了标志<code>WCONTINUED</code>。</p><p>　　这里使用术语<strong>等待状态</strong>来表示以上事件。术语<strong>终止状态</strong>表示前2个事件 (对于shell，可以通过变量<code>$?</code>来获取最后执行的命令的终止状态)。</p><p>　　尽管<code>status</code>定义为<code>int</code>，但只有低16位才是实际使用的位。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_26/value_returned_in_the_status_argument_of_wait_and_waitpid.svg" title="value_returned_in_the_status_argument_of_wait_and_waitpid"><p>　　上图展示了Linux/x86-32的等待状态值的布局。但是，SUSv3没有说明该值的布局，甚至没有要求低16位是实际使用的位。为此，头文件<code>sys/wait.h</code>中定义了一系列用于解析等待状态值的标准宏。当将以下宏应用于等待状态值时，只有1个宏会返回真 (这里的<code>status</code>是整数值，而非指向整数的指针)：</p><p>　　● <code>WIFEXITED(status)</code>只会在子进程正常终止时返回真。在这种情况下，该宏会返回子进程的终止状态 (但父进程只能获取子进程的终止状态值的低8位)。</p><p>　　● <code>WIFSIGNALED(status)</code>只会在子进程被信号终止时返回真。在这种情况下，该宏会返回导致子进程终止的信号的编号。此外，宏<code>WCOREDUMP(status)</code>可用于判断子进程是否会生成核心转储文件 (若会生成，则返回真)。SUSv3没有说明宏<code>WCOREDUMP(status)</code>，但大多数UNIX实现都提供了该宏。</p><p>　　● <code>WIFSTOPPED(status)</code>只会在子进程被信号停止时返回真。在这种情况下，该宏会返回导致子进程停止的信号的编号。</p><p>　　● <code>WIFCONTINUED(status)</code>只会在停止的子进程被信号<code>SIGCONT</code>恢复时返回真 (Linux 2.6.10及以上版本)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* print_wait_status.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明会在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_wait_status.h&quot;</span> <span class="comment">/* printWaitStatus()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 解析等待状态值并打印相关信息 (该函数调用了非异步信号安全函数printf())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param msg</span></span><br><span class="line"><span class="comment"> * @param status 等待状态值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printWaitStatus</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child exited, status=%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child killed by signal %d (%s)&quot;</span>,</span><br><span class="line">               WTERMSIG(status), strsignal(WTERMSIG(status)));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WCOREDUMP <span class="comment">/* 有些系统未提供该宏 */</span></span></span><br><span class="line">        <span class="keyword">if</span> (WCOREDUMP(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; (core dumped)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child stopped by signal %d (%s)\n&quot;</span>,</span><br><span class="line">               WSTOPSIG(status), strsignal(WSTOPSIG(status)));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIFCONTINUED <span class="comment">/* 较旧的Linux版本和有些UNIX实现未提供该宏 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFCONTINUED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child continued\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;what happened to this child? (status=%x)\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>printWaitStatus()</code>会通过上述宏来解析等待状态值。</p><h4 id="在信号处理函数中处理进程终止">26.1.4 在信号处理函数中处理进程终止</h4><p>　　有些信号的默认处理方式是终止进程，而进程终止前可能需要执行特定的清理操作。为此，可以先注册信号处理函数来捕获信号，然后执行清理操作，最后终止进程。若子进程需要通知父进程自己因为信号而终止，则子进程的信号处理函数可以先将信号的处理方式恢复到默认，然后再次向自己发送同一信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 执行清理操作 */</span></span><br><span class="line"></span><br><span class="line">    signal(sig, SIG_DFL); <span class="comment">/* 将信号的处理方式恢复到默认 */</span></span><br><span class="line">    raise(sig);           <span class="comment">/* 再次发送同一信号给自己 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="系统调用waitid">26.1.5 系统调用<code>waitid()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waitid</span><span class="params">(<span class="type">idtype_t</span> idtype, <span class="type">id_t</span> id, <span class="type">siginfo_t</span> *infop, <span class="type">int</span> options)</span>; <span class="comment">/* 成功或指定了WNOHANG但没有可等待的子进程时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　对于系统调用<code>waitid()</code>，参数<code>idtype</code>和<code>id</code>用于指定等待的子进程。</p><p>　　● 若<code>idtype</code>是<code>P_ALL</code>，则等待所有子进程。此时，<code>ìd</code>会被忽略。</p><p>　　● 若<code>idtype</code>是<code>P_PID</code>，则等待进程ID为<code>id</code>的子进程。</p><p>　　● 若<code>idtype</code>是<code>P_PGID</code>，则等待进程组ID为<code>id</code>的所有子进程。在这种情况下，<code>id</code><span style="background-color:#ff0">不能</span>为0。</p><p>　　若调用进程没有匹配<code>idtype</code>和<code>id</code>的子进程，则<code>waitid()</code>会返回-1，并将<code>error</code>设置为<code>ECHILD</code>。</p><p>　　参数<code>options</code><span style="background-color:#ff0">至少</span>包含标志<code>WEXITED</code>、<code>WSTOPPED</code>和<code>WCONTINUED</code>中的1个标志，可以包含标志<code>WNOHANG</code>和<code>WNOWAIT</code>中的任意个标志 (或运算<code>|</code>)。</p><p>　　● <code>WEXITED</code>表示等待子进程终止 (无论正常终止或异常终止)。</p><p>　　● <code>WSTOPPED</code>表示等待子进程被信号停止。</p><p>　　● <code>WCONTINUED</code>表示等待停止的子进程被信号<code>SIGCONT</code>恢复。</p><p>　　● <code>WNOHANG</code>表示若子进程的状态未发生改变或调用<code>waitid()</code>时子进程的状态已经发生改变，则会立即返回0。对于前者，Linux和有些UNIX实现会将<code>infop</code>指向的结构体<code>siginfo_t</code>的所有成员都设置为0，但SUSv3没有要求这种行为 (未来对SUSv4的修改可能会增加1个要求：在这种情况下，结构体<code>siginfo_t</code>的成员<code>si_pid</code>和<code>si_signo</code>会被设置为0)。对于后者，子进程的相关信息会通过<code>infop</code>指向的结构体<code>siginfo_t</code>返回。在保证可移植性的情况下，区分<code>infop</code>指向的结构体<code>siginfo_t</code>的所有成员是否会被设置为0的唯一方法是在调用<code>waitid()</code>前将这些成员都设置为0。</p><p>　　● <code>WNOWAIT</code>表示当子进程的等待条件触发后，子进程将仍处于可等待状态 (在这种情况下，子进程通常会退出可等待状态)。</p><p>　　当<code>waitid()</code>成功时，会返回0，并且参数<code>infop</code>指向的结构体<code>siginfo_t</code>中会包含子进程终止的相关信息，该结构体的成员<code>si_code</code>、<code>si_pid</code>、<code>si_signo</code>、<code>si_status</code>和<code>si_uid</code>会被设置。</p><p>　　● 成员<code>si_code</code>会包含<code>CLD_EXITED</code> (表示子进程通过调用<code>_exit()</code>终止)、<code>CLD_KILLED</code> (表示子进程被信号终止)、<code>CLD_STOPPED</code> (表示子进程被信号停止) 或<code>CLD_CONTINUED</code> (表示停止的子进程被信号<code>SIGCONT</code>恢复)。</p><p>　　● 成员<code>si_pid</code>会包含状态改变的子进程的进程ID。</p><p>　　● 成员<code>si_signo</code>总是会包含<code>SIGCHLD</code>。</p><p>　　● 成员<code>si_status</code>会包含子进程的终止状态或导致子进程停止、恢复或终止的信号的编号。</p><p>　　● 成员<code>si_uid</code>会包含子进程的实际用户ID。大多数UNIX实现不会设置该成员。</p><p>　　对于Solaris，还会将成员<code>si_stime</code>和<code>si_utime</code>分别设置为子进程的系统CPU时间和用户CPU时间。SUSv3不要求<code>waitid()</code>设置这2个成员。</p><h4 id="系统调用wait3和wait4">26.1.6 系统调用<code>wait3()</code>和<code>wait4()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE <span class="comment">/* 对于wait3()，也可以#define _XOPEN_SOURCE 500 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回子进程的进程ID，出错时返回-1 */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait3</span><span class="params">(<span class="type">int</span> *status, <span class="type">int</span> options, <span class="keyword">struct</span> rusage *rusage)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait4</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options, <span class="keyword">struct</span> rusage *rusage)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>wait3()</code>和<code>wait4()</code>与<code>waitpid()</code>类似。主要的语义区别在于<code>wait3()</code>和<code>wait4()</code>会通过参数<code>rusage</code>指向的结构体<code>rusage</code>返回终止的子进程的资源使用信息 (包括使用的CPU时间和内存管理统计)。这2个系统调用的名称中的数字表示参数的数量。</p><p>　　当不使用<code>rusage</code>时，调用<code>wait3()</code>等同于调用<code>waitpid(-1, &amp;status, options)</code>，调用<code>wait4()</code>等同于调用<code>waitpid(pid, &amp;status, options)</code>。</p><p>　　对于有些UNIX实现，这2个系统调用只会返回终止的子进程的资源使用信息。对于Linux，当参数<code>options</code>指定了标志<code>WUNTRACED</code>时，还可以返回停止的子进程的资源使用信息。</p><p>　　这2个系统调用都源于BSD，SUSv3没有标准化这2个系统调用 (SUSv2详细说明了<code>wait3()</code>，并将其标记为LEGACY)，但现在的大多数UNIX实现都提供了这2个系统调用。</p><h3 id="孤儿进程和僵尸进程">26.2 孤儿进程和僵尸进程</h3><p>　　父进程和子进程的生命周期通常不同。</p><p>　　● 若父进程先于子进程终止，则子进程会转换为<strong>孤儿进程</strong>。孤儿进程会被进程<code>init</code>收养。</p><p>　　● 若子进程在父进程调用<code>wait()</code>之前终止，则子进程会转换为<strong>僵尸进程</strong>，这表示子进程占用的大部分资源都已经被系统释放。僵尸进程唯一剩下的部分是内核的进程表中的1个条目，该条目记录着僵尸进程的进程ID、终止状态和资源使用统计等信息。</p><p>　　僵尸进程<span style="background-color:#ff0">不受任何信号的影响</span>，这保证了父进程最终可以调用<code>wait()</code>。</p><p>　　当父进程调用<code>wait()</code>时，内核会删除僵尸进程，因为关于僵尸进程的剩余信息将不再需要。若父进程直接终止而不调用<code>wait()</code>，则进程<code>init</code>会收养子进程和自动调用<code>wait()</code> (删除僵尸进程)。</p><p>　　若父进程创建了子进程，但未能调用<code>wait()</code>，则内核的进程表中记录着僵尸进程的相关信息的条目会一直存在。当内核的进程表充斥着大量此类条目时，可能会导致无法创建新进程。由于僵尸进程不受信号的影响，所以删除这些僵尸进程唯一的方法是终止其父进程 (然后，进程<code>init</code>收养僵尸进程并调用<code>wait()</code>)。</p><p>　　这些语义对父进程长期存在的应用程序 (例如，网络服务器和shell) 很重要。对于这些应用程序，父进程需要调用<code>wait()</code>来确保终止的子进程会从系统中删除 (而非转换为长期存在的僵尸进程)。父进程可以在<code>SIGCHLD</code>处理函数中调用<code>wait()</code>。</p><h3 id="信号sigchld">26.3 信号<code>SIGCHLD</code></h3><p>　　当子进程终止时，父进程会收到信号<code>SIGCHLD</code>。该信号默认会被忽略，但可以为该信号注册处理函数，并在其中调用<code>wait()</code> (或类似的系统调用) 来回收僵尸进程。</p><h4 id="注册sigchld处理函数">26.3.1 注册<code>SIGCHLD</code>处理函数</h4><p>　　由于信号<code>SIGCHLD</code>是标准信号，所以不会排队。此外，调用信号处理函数期间对应的信号默认会被阻塞 (除非通过<code>sigaction()</code>注册信号处理函数时指定了标志<code>SA_NODEFER</code>)。因此，假设在调用<code>SIGCHLD</code>处理函数期间其他多个子进程相继终止，尽管信号<code>SIGCHLD</code>会多次被生成，但只会到达1次，这可能会导致仅回收部分僵尸进程。</p><p>　　为了解决这个问题，可以在<code>SIGCHLD</code>处理函数中循环调用<code>waitpid()</code>并指定标志<code>WNOHANG</code>，直到没有可回收的僵尸进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* multi_sigchld.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_wait_status.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> numLiveChildren = <span class="number">0</span>; <span class="comment">/* 已创建但未被回收的子进程的数量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数printf()、printWaitStatus()和currTime()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigchldHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status, savedErrno;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    savedErrno = errno; <span class="comment">/* 防止errno被修改 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s handler: Caught SIGCHLD\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> ((childPid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s handler: Reaped child %ld - &quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), (<span class="type">long</span>)childPid);</span><br><span class="line">        printWaitStatus(<span class="literal">NULL</span>, status);</span><br><span class="line">        numLiveChildren--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childPid == <span class="number">-1</span> &amp;&amp; errno != ECHILD)</span><br><span class="line">    &#123;</span><br><span class="line">        errMsg(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>); <span class="comment">/* 故意延长处理函数的执行时间 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s handler: returning\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>));</span><br><span class="line"></span><br><span class="line">    errno = savedErrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j, sigCnt;</span><br><span class="line">    <span class="type">sigset_t</span> blockMask, emptyMask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s child-sleep-time...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    sigCnt = <span class="number">0</span>;</span><br><span class="line">    numLiveChildren = argc - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = sigchldHandler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 阻塞信号SIGCHLD，防止该信号在父进程开始sigsuspend()循环前到达 */</span></span><br><span class="line">    sigemptyset(&amp;blockMask);</span><br><span class="line">    sigaddset(&amp;blockMask, SIGCHLD);</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;blockMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (fork())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程：睡眠并终止 */</span></span><br><span class="line">            sleep(getInt(argv[j], GN_NONNEG, <span class="string">&quot;child-sleep-time&quot;</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s Child %d (PID=%ld) exiting\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), j, (<span class="type">long</span>)getpid());</span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* 父进程：循环创建子进程 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程：循环等待信号SIGCHLD，直到所有子进程都被回收 */</span></span><br><span class="line">    sigemptyset(&amp;emptyMask);</span><br><span class="line">    <span class="keyword">while</span> (numLiveChildren &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sigsuspend(&amp;emptyMask) == <span class="number">-1</span> &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigsuspend&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sigCnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s All %d children have terminated; SIGCHLD was caught %d times\n&quot;</span>,</span><br><span class="line">           currTime(<span class="string">&quot;%T&quot;</span>), argc - <span class="number">1</span>, sigCnt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何通过<code>SIGCHLD</code>处理函数来回收僵尸进程。<code>SIGCHLD</code>处理函数会打印回收的子进程的进程ID和等待状态。为了展示调用<code>SIGCHLD</code>处理函数期间信号<code>SIGCHLD</code>不会排队，<code>SIGCHLD</code>处理函数会调用<code>sleep()</code>来延长执行时间 (第15~39行)。主函数会先注册<code>SIGCHLD</code>处理函数和阻塞信号<code>SIGCHLD</code> (第57~71行)。然后，为每个命令行参数创建1个子进程，每个子进程都会睡眠对应的命令行参数指定的秒数并终止 (第73~88行)。最后，循环调用<code>sigsuspend()</code>来等待信号<code>SIGCHLD</code> (第91~99行)。</p><h4 id="忽略信号sigchld">26.3.2 忽略信号<code>SIGCHLD</code></h4><p>　　显式地将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>会导致子进程后续终止时立即被删除 (而非转换为僵尸进程)。对于这种情况，由于内核的进程表中记录子进程的相关信息的条目已被删除，所以后续对该子进程调用<code>wait()</code> (或类似的系统调用) 不会返回任何信息。</p><p>　　对于Linux和很多UNIX实现，将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>不会影响现有的僵尸进程 (所以这些僵尸经常还是需要通过常规方法回收)。对于某些其他UNIX实现 (例如，Solaris 8)，将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>会删除现有的僵尸进程。</p><p>　　信号<code>SIGCHLD</code>的<code>SIG_IGN</code>语义有悠久的历史 (源于System V)。SUSv3详细说明了这里的行为，但POSIX.1没有说明这里的行为。因此，对于部分较旧的UNIX实现，忽略信号<code>SIGCHLD</code>不会影响僵尸进程的产生。防止僵尸进程产生的唯一完全可移植方法是调用<code>wait()</code> (或类似的系统调用)。</p><p>　　SUSv3规定，若将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>，则子进程的资源使用信息会被丢弃，并且父进程调用<code>getrusage()</code>并指定标志<code>RUSAGE_CHILDREN</code>时返回的信息中不会包含这些信息。此外，<code>times()</code>返回的结构体<code>tms</code>也不会包含子进程使用的CPU时间。但是，对于内核2.6.9之前的Linux版本，子进程使用的CPU时间和资源会被记录 (<code>getrusage()</code>和<code>times()</code>返回的信息会包含这些信息)。</p><p>　　SUSv3规定，若将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>，并且父进程没有未回收的僵尸子进程，则调用<code>wait()</code>和<code>waitpid()</code>会阻塞，直到父进程的所有子进程都终止，然后这些调用会导致错误<code>ECHILD</code>。Linux 2.6遵守该规范。但是，对于Linux 2.4及以下版本，<code>wait()</code>只会阻塞到下一次子进程终止，然后返回子进程的进程ID和状态 (行为与未将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>相同)。</p><p>　　SUSv3详细说明了标志<code>SA_NOCLDWAIT</code> (见20.10)，其功能与将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>相同。两者主要的区别在于当调用<code>sigaction()</code>并指定了标志<code>SA_NOCLDWAIT</code>时，SUSv3没有说明子进程终止时是否为父进程生成信号<code>SIGCHLD</code>。因此，在这种情况下，是否为父进程生成信号<code>SIGCHLD</code>因实现而异。对于Linux和有些UNIX实现，会生成该信号。对于其他UNIX，不会生成该信号。</p><p>　　Linux提供了等同于信号<code>SIGCHLD</code>的信号<code>SIGCLD</code>。两者同时存在是因为历史原因，信号<code>SIGCHLD</code>源于BSD，该名称随后被POSIX采用 (POSIX很大程度上标准化了BSD信号模型)。信号<code>SIGCLD</code>源于System V，其语义略有不同。两者的主要区别在于将信号<code>SIGCHLD</code>的处理方式设置为<code>SIG_IGN</code>的后续处理。</p><p>　　● 对于历史上的BSD实现 (或一些同时代的实现)，系统会继续将未等待的终止的子进程转换为僵尸进程。</p><p>　　● 对于System V，通过<code>signal()</code> (而非<code>sigaction()</code>) 来忽略信号<code>SIGCLD</code>会导致未等待的终止的子进程不会转换为僵尸进程。</p><p>　　最初的POSIX.1没有说明忽略<code>SIGCHLD</code>的结果，所以System V的行为是允许的。如今，System V的行为已经成为了SUSv3的一部分 (但使用的信号名是<code>SIGCHLD</code>)。现代System V衍生实现将<code>SIGCHLD</code>作为标准名，但仍然提供了<code>SIGCLD</code>。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_25/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第25章 进程终止"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第25章 进程终止</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_27/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第27章 程序执行">《Linux/UNIX系统编程手册》第27章 程序执行 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>