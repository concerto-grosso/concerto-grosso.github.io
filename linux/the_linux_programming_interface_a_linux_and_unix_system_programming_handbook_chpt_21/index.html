<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_21/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_21/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_21/","title":"《Linux/UNIX系统编程手册》第21章 信号：信号处理函数"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第21章 信号：信号处理函数 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">21.1 设计信号处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="nav-text">21.1.1 可重入和不可重入函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0"><span class="nav-text">21.1.2 异步信号安全函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bsig_atomic_t"><span class="nav-text">21.1.3 全局变量和数据类型sig_atomic_t</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigsetjmp%E5%92%8Csiglongjmp"><span class="nav-text">21.2 sigsetjmp()和siglongjmp()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#abort"><span class="nav-text">21.3 abort()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigaltstack"><span class="nav-text">21.4 sigaltstack()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%BF%97sa_siginfo"><span class="nav-text">21.5 标志SA_SIGINFO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E9%87%8D%E5%90%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">21.6 中断和重启系统调用</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_21/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第21章 信号：信号处理函数 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第21章 信号：信号处理函数</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-04-01T00:00:00+08:00">2025-04-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-04-02 00:00:00" itemprop="dateModified" datetime="2025-04-02T00:00:00+08:00">2025-04-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>17k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　通常，信号处理函数应该设计得尽可能简单 (重要原因之一是降低出现竞争的可能性)。信号处理函数的2种常见设计如下：</p><p>　　● 信号处理函数设置全局标志并退出。主函数会周期性地检查标志，若标志已设置，则采取合适的行动。若主函数因为需要监控文件描述符来判断I/O是否可用，而无法周期性地检查标志，则信号处理函数也可以向专用管道写1个字节，该管道的读取端包含在主函数监控的文件描述符中。</p><p>　　● 信号处理函数执行一些清理，然后终止进程或通过非本地跳转来展开栈和将控制权转移给主函数中的特定位置。</p><p>　　当调用信号处理函数时，内核通常会在进程的栈中为处理函数创建栈帧。当进程的栈容量达到上限时，继续在栈中分配空间会导致内核为进程生成信号<code>SIGSEGV</code>。但是，因为栈容量达到上限，所以无法为<code>SIGSEGV</code>处理函数分配栈帧，导致该处理函数不会调用，并且进程会被终止 (信号<code>SIGSEGV</code>的默认处理方式)。为此，可以使用以下方法来保证信号<code>SIGSEGV</code>会被处理：</p><p>　　1) 分配称为<strong>备用信号栈</strong>的内存区域，用于信号处理函数的栈帧。</p><p>　　2) 使用系统调用<code>sigaltstack()</code>来通知内核备用信号栈的存在。</p><p>　　3) 在注册信号处理函数时指定标志<code>SA_ONSTACK</code> (告诉内核应该在备用信号栈中为该处理函数分配栈帧)。</p><p>　　有时，从信号处理函数返回是不可取的 (甚至是无用的)。可以通过以下方法来终止信号处理函数：</p><p>　　● 通过<code>_exit()</code>来终止进程。在此之前，信号处理函数可能需要执行清理操作。</p><p>　　● 通过<code>kill()</code>或<code>raise()</code>发送信号来终止进程。</p><p>　　● 在信号处理函数中执行非本地跳转。</p><p>　　● 通过<code>abort()</code>来让进程生成核心转储文件并终止。</p><p>　　当阻塞系统调用被信号处理函数中断时，系统调用默认会出错 (<code>EINTR</code>)。为了继续执行被中断的系统调用，可以使用以下方式来重启系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((cnt = read(fd, buf, BUF_SIZE)) == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段代码可以通过宏简化为以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NO_EINTR(stmt)                     \</span></span><br><span class="line"><span class="meta">    while ((stmt) == -1 &amp;&amp; errno == EINTR) \</span></span><br><span class="line"><span class="meta">        ;</span></span><br><span class="line"></span><br><span class="line">NO_EINTR(cnt = read(fd, buf, BUF_SIZE));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在定义了特性测试宏<code>_GNU_SOURCE</code>后，glibc会在头文件<code>unistd.h</code>中提供与宏<code>NO_EINTR()</code>类似的非标准宏<code>TEMP_FAILURE_RETRY()</code>。</p><p>　　即使使用了<code>NO_EINTR</code>等宏，重启被信号处理函数中断的系统调用依然比较麻烦。因此，通过<code>sigaction()</code>注册信号处理函数时应该指定标志<code>SA_RESTART</code>。</p><span id="more"></span><p>　　对于Linux，有些阻塞系统调用会在没有注册处理函数的信号到达时出错 (<code>EINTR</code>)，包括<code>epoll_pwait()</code>、<code>epoll_wait()</code>、<code>semop()</code>、<code>semtimedop()</code>、<code>sigtimedwait()</code>、<code>sigwaitinfo()</code>、对inotify文件描述符调用的<code>read()</code>、2.6.9之前的内核中的<code>msgrcv()</code>和<code>msgsnd()</code>、2.6.22之前的内核中的<code>sem_wait()</code>、<code>sem_timedwait()</code>和<code>futex(FUTEX_WAIT)</code>、2.6.24之前的内核中的<code>poll()</code>以及Linux 2.4及以下版本中的<code>nanosleep()</code>。当这些系统调用阻塞时进程被信号 (<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>或<code>SIGTTOU</code>) 停止，然后被信号<code>SIGCONT</code>恢复时，就会出现这种情况。对于Linux 2.4及以下版本，<code>sleep()</code>也会出现类似的情况，但返回的是剩余未睡眠的秒数，而非出错。</p><p>　　因此，当程序可能被信号停止和恢复时，可能需要额外代码来重启这些系统调用，即使没有为停止信号注册处理函数。</p><h3 id="设计信号处理函数">21.1 设计信号处理函数</h3><p>　　并非所有系统调用和库函数都可以在信号处理函数中安全调用。要理解原因需要先介绍2个概念：可重入函数和异步信号安全函数。</p><h4 id="可重入和不可重入函数">21.1.1 可重入和不可重入函数</h4><p>　　传统UNIX程序只有1个<span style="background-color:#ff0">执行线程</span>，CPU处理为程序的单个逻辑执行流处理指令。多线程程序有多个独立的并发逻辑执行流。</p><p>　　若函数可以安全地由同一进程的多个线程同时执行 ("安全" 表示函数可以达到预期结果，无论其他执行线程的执行状态)，则该函数是<strong>可重入函数</strong>。SUSv3对可重入函数的定义是：当多个线程调用可重入函数时，即使实际执行是交错进行的，也能保证其效果按照未定义的顺序执行该函数一样。</p><p>　　更新全局或静态变量 (或数据结构) 的函数可能是不可重入的，仅使用局部变量 (或数据结构) 的函数一定是可重入的。若同一进程的多个线程同时调用同一函数来更新同一全局变量 (或数据结构)，则这些更新可能会互相干扰，进而导致错误的结果。</p><p>　　实际上，这种可能性充斥着标准C库。例如，<code>malloc()</code>和<code>free()</code>维护着用于在堆中分配内存的空闲内存块链接。若主程序中的<code>malloc()</code>调用被信号处理函数中断，并且信号处理函数也会调用该系统调用，则空闲内存块链表会损坏。其他不可重入的库函数会返回存储在静态分配的内存的数据或使用静态数据结构来进行内部存储。</p><p>　　即使不使用不可重入的库函数，可重入问题可能依旧存在。若主函数和信号处理函数都会更新程序员定义的全局数据结构，则该信号处理函数是不可重入的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* nonreentrant.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *str2;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> handled = <span class="number">0</span>; <span class="comment">/* 信号处理函数的调用次数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    crypt(str2, <span class="string">&quot;xx&quot;</span>);</span><br><span class="line">    handled++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *cr1;</span><br><span class="line">    <span class="type">int</span> callNum, mismatch;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s str1 str2\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str2 = argv[<span class="number">2</span>]; <span class="comment">/* 便于信号处理函数使用argv[2] */</span></span><br><span class="line">    cr1 = strdup(crypt(argv[<span class="number">1</span>], <span class="string">&quot;xx&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cr1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;strdup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 反复使用argv[1]调用crypt()。若被信号处理函数中断，则该函数返回的静态分配的字符串会被覆盖 */</span></span><br><span class="line">    <span class="keyword">for</span> (callNum = <span class="number">1</span>, mismatch = <span class="number">0</span>;; callNum++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(crypt(argv[<span class="number">1</span>], <span class="string">&quot;xx&quot;</span>), cr1) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mismatch++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Mismatch on call %d (mismatch=%d handled=%d)\n&quot;</span>,</span><br><span class="line">                   callNum, mismatch, handled);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了函数<code>crypt()</code>的不可重入性。该程序的执行步骤如下：</p><p>　　1) 调用<code>crypt()</code>来加密第1个命令行参数指定的字符串，然后通过<code>strdup()</code>将结果复制到独立的缓冲区。</p><p>　　2) 为信号<code>SIGINT</code>注册处理函数，该处理函数会调用<code>crypt()</code>来加密第2个命令行参数指定的字符串。</p><p>　　3) 进行无限循环。每次循环都会加密第1个命令行参数指定的字符串，并判断结果是否匹配第1步得到的结果。</p><h4 id="异步信号安全函数">21.1.2 异步信号安全函数</h4><p>　　<strong>异步信号安全函数</strong>是可以在信号处理函数中安全调用的函数 (可重入或不能被信号处理函数中断)。</p><p>　　当编写信号处理函数时，有2个选择：</p><p>　　● 确保信号处理函数是可重入的，并且仅调用异步信号安全函数。</p><p>　　● 对于主函数，调用不安全函数或操作信号处理函数也会操作的全局数据结构时阻塞信号。</p><p>　　第2个选择的问题在于，在复杂的程序中，难以保证调用不安全函数时不会被信号处理函数中断。因此，这2个选择通常会简化为<span style="background-color:#ff0">不能在信号处理函数中调用不安全的函数</span>。</p><p>　　当通过同一信号处理函数捕获多个信号或使用<code>sigaction()</code>的标志<code>SA_NODEFER</code>时，信号处理函数可能会被自己中断，所以使用全局 (或静态) 变量的信号处理函数可能是不可重入的 (即使主函数不使用这些变量)。</p><p>　　若信号处理函数调用了可能会更新<code>errno</code>的函数，则该信号处理函数可能是不可重入的，因为这可能会覆盖主函数调用的函数设置的<code>errno</code>值。解决方法是在信号处理函数的开头保存<code>errno</code>的值，并在信号处理函数的末尾恢复<code>errno</code>的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> savedErrno;</span><br><span class="line">    savedErrno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    errno = savedErrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局变量和数据类型sig_atomic_t">21.1.3 全局变量和数据类型<code>sig_atomic_t</code></h4><p>　　尽管存在可重入性问题，但在主函数和信号处理函数之间共享全局变量还是很有用的。只有主函数可以正确地处理信号处理函数可能随时修改全局变量的可能性，这就可以是安全的。例如，将信号处理函数设计为仅操作全局标志，然后主函数周期性地检查该标志，并在标志被设置时采取合适的行动 (然后清除标志)。当以这种方式使用全局变量时，应该在声明该全局变量时使用关键字<code>volatile</code>，以防止编译器优化导致该全局变量存储在寄存器中。</p><p>　　读写全局变量可能涉及多个机器语言指令，主函数执行这些指令时可能会被信号处理函数中断 (所以对该变量的访问是<strong>非原子</strong>的)。因此，C语言标准和SUSv3详细说明了整数数据类型<code>sig_atomic_t</code>，对该数据类型的读写是<strong>原子</strong>的。主函数和信号处理函数都使用的全局标志变量应该声明为<code>volatile sig_atomic_t flag</code>。</p><p>　　C语言的自增操作符 (<code>++</code>) 和自减操作符 (<code>--</code>) 不会受到<code>sig_atomic_t</code>的影响。对于有些硬件架构，这些操作可能是非原子的。</p><p>　　C99和SUSv3要求实现在头文件<code>stdint.h</code>中定义2个常量：<code>SIG_ATOMIC_MIN</code>和<code>SIG_ATOMIC_MAX</code>，这2个变量表示<code>sig_atomic_t</code>的取值范围。若<code>sig_atomic_t</code>是有符号数，则取值范围至少是-127~127；若<code>sig_atomic_t</code>是无符号数，则取值范围至少是0~255。对于Linux，该范围与有符号32位整数的取值范围相同。</p><h3 id="sigsetjmp和siglongjmp">21.2 <code>sigsetjmp()</code>和<code>siglongjmp()</code></h3><p>　　在6.6中介绍了如何通过<code>setjmp()</code>和<code>longjmp()</code>执行从被调函数到调用函数的非本地跳转。由于内核会自动在进入信号处理函数时将对应的信号和通过<code>act.sa_mask</code>指定的信号添加到信号掩码，并且在信号处理函数返回时从信号掩码删除这些信号，所以通过<code>longjmp()</code>退出信号处理函数<span style="background-color:#ff0">可能</span>会跳过从信号掩码删除信号的步骤，这取决于UNIX实现。对于System V，<code>longjmp()</code>不会执行该步骤。Linux在这一点上与System V相同。对于BSD衍生实现，<code>setjmp()</code>会将信号掩码保存在参数<code>env</code>中，并且<code>longjmp()</code>会恢复保存的信号掩码 (BSD衍生实现还提供了<code>_setjmp()</code>和<code>_longjmp()</code>，这2个函数遵循System V语义)。</p><p>　　若编译程序时使用特性测试宏<code>_BSD_SOURCE</code>，则glibc的<code>setjmp()</code>会遵循BSD语义。</p><p>　　由于这2个主要UNIX变体之间的差异，POSIX.1-1990选择不规定<code>setjmp()</code>和<code>longjmp()</code>如何处理信号掩码，相反，该标准详细说明了2个新函数：<code>sigsetjmp()</code>和<code>siglongjmp()</code>，它们会在执行非本地跳转时会显式地控制信号掩码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>; <span class="comment">/* 第1次调用时返回0，siglongjmp()导致的返回返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>sigsetjmp()</code>和<code>siglongjmp()</code>的功能与<code>setjmp()</code>和<code>longjmp()</code>的类似。唯一的区别是参数<code>env</code>的数据类型和<code>sigsetjmp()</code>的额外参数<code>savesigs</code>。若<code>savesigs</code>不是0，则调用<code>sigsetjmp()</code>时进程的信号掩码会保存在<code>env</code>中，并且随后可以通过为<code>siglongjmp()</code>指定相同的<code>env</code>来恢复信号掩码。若<code>savesigs</code>是0，则不会保存和恢复信号掩码。</p><p>　　<code>longjmp()</code>和<code>siglongjmp()</code>是非异步信号安全函数，因为在执行非本地跳转后调用非异步信号安全函数的风险与在信号处理函数中调用非异步信号安全函数的风险相同。此外，若主函数在更新数据结构时被信号处理函数中断，然后信号处理函数执行非本地跳转，则未完成的更新可能会导致数据结构处于不一致状态。因此，在更新关键数据时可以使用<code>sigprocmask()</code>临时阻塞信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sigmask_longjmp.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;signal_functions.h&quot;</span> <span class="comment">/* printSigMask()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> canJump = <span class="number">0</span>; <span class="comment">/* setjmp()或sigsetjmp()初始化env时会设置为1 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_SIGSETJMP</span></span><br><span class="line"><span class="type">static</span> sigjmp_buf senv;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> jmp_buf env;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数使用了非异步信号安全函数 (printf()、strsignal()和printSigMask())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal %d (%s), signal mask is:\n&quot;</span>, sig, strsignal(sig));</span><br><span class="line">    printSigMask(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canJump)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&#x27;env&#x27; buffer not yet set, doing a simple return\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_SIGSETJMP</span></span><br><span class="line">    siglongjmp(senv, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    longjmp(env, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    printSigMask(<span class="built_in">stdout</span>, <span class="string">&quot;Signal mask at startup:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_SIGSETJMP</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling sigsetjmp()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sigsetjmp(senv, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling setjmp()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (setjmp(env) == <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        canJump = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printSigMask(<span class="built_in">stdout</span>, <span class="string">&quot;After jump from handler, signal mask is:\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了2种非本地跳转之间的区别。该程序会为信号<code>SIGINT</code>注册处理函数，然后执行非本地跳转来退出处理函数 (使用哪种非本地跳转取决于编译时是否使用了选项<code>-DUSE_SIGSETJMP</code>)，最后打印进入处理函数时的信号掩码和退出处理函数后的信号掩码。</p><p>　　此外，该程序也展示了如何在信号处理函数中进行非本地跳转。信号可以在任何时刻生成，所以信号可能在调用<code>sigsetjmp()</code>或<code>setjmp()</code>之前到达。为了防止这种可能性 (使用未初始化的<code>env</code>来执行非本地跳转)，这里使用了标志<code>canJump</code>，该标志决定是否执行非本地跳转。只有调用<code>sigsetjmp()</code>或<code>setjmp()</code>后，才会设置该标志。另一种方法是在注册信号处理函数之前调用<code>sigsetjmp()</code>或<code>setjmp()</code>。但是，在复杂的程序中，可能无法保证第2种方法指定的顺序，而且第1种方法相对更简单。</p><p>　　这里使用<code>#ifdef</code>是最简单的符合规范的方法。若将其替换为<code>if</code>语句，则会进行运行时检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (useSiglongjmp)</span><br><span class="line">&#123;</span><br><span class="line">    s = sigsetjmp(senv, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    s = setjmp(env);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因为SUSv3不允许将<code>sigsetjmp()</code>和<code>setjmp()</code>用于赋值语句，所以这里无法使用<code>if</code>语句。</p><h3 id="abort">21.3 <code>abort()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>　　库函数<code>abort()</code>会让调用进程生成核心转储文件并终止 (通过信号<code>SIGABRT</code>)。</p><p>　　SUSv3要求<code>abort()</code>覆盖阻塞或忽略信号<code>SIGABRT</code>的效果。此外，SUSv3规定，<code>abort()</code>必须终止进程，除非进程使用不会返回的处理函数捕获信号。若处理函数中使用了非本地跳转，则该函数的效果会无效；否则，该函数总是会终止进程。对于大多数实现，若<code>abort()</code>通过信号<code>SIGABRT</code>终止进程失败 (例如，进程使用了信号处理函数捕获信号<code>SIGABRT</code>)，则<code>abort()</code>会将信号<code>SIGABRT</code>的处理方式设置为<code>SIG_DFL</code>，并再次通过该信号终止进程。</p><p>　　当<code>abort()</code>成功终止进程时，也会刷新和关闭stdio流。</p><h3 id="sigaltstack">21.4 <code>sigaltstack()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaltstack</span><span class="params">(<span class="type">const</span> <span class="type">stack_t</span> *sigstack, <span class="type">stack_t</span> *old_sigstack)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> *ss_sp;    <span class="comment">/* 备用信号栈的起始地址 */</span></span><br><span class="line">    <span class="type">int</span> ss_flags;   <span class="comment">/* 标志 (SS_ONSTACK或SS_DISABLE) */</span></span><br><span class="line">    <span class="type">size_t</span> ss_size; <span class="comment">/* 备用信号栈的大小 */</span></span><br><span class="line">&#125; <span class="type">stack_t</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>sigaltstack()</code>可用于定义备用信号栈或检索关于现有备用信号栈的信息。</p><p>　　参数<code>sigstack</code>指向的结构体用于指定新备用信号栈的地址和属性。参数<code>sigstack</code>指向的结构体用于存储现有备用信号栈的信息 (若存在)。此外，这2个参数都可以指定为<code>NULL</code>。</p><p>　　结构体<code>stack_t</code>的成员<code>ss_sp</code>和<code>ss_size</code>表示备用信号栈的地址和大小。当实际使用备用信号栈时，内核会进行对齐。</p><p>　　通常，备用信号栈是在堆上静态或动态分配的。SUSv3详细说明了常量<code>SIGSTKSZ</code>和<code>MINSIGSTKSZ</code>，前者作为调整备用信号栈的大小时的典型值，后者表示调用信号处理函数所需的最小空间。对于Linux/x86-32，这2个常量分别定义为8192和2048。</p><p>　　内核不会调整备用信号栈的大小。若备用信号栈溢出，则会导致无法预测的结果 (例如，覆盖与备用信号栈相邻的变量)。实际上，这通常不会是问题，因为使用备用信号栈是为了防止标准栈溢出，所以备用信号栈中的栈帧通常很少。<code>SIGSEGV</code>处理函数的任务是执行清理并终止进程或通过非本地跳转来展开标准栈。</p><p>　　成员<code>ss_flags</code>的值是<code>SS_ONSTACK</code>或<code>SS_DISABLE</code>。</p><p>　　● <code>SS_ONSTACK</code>会在检索现有备用信号栈的信息时设置，表示进程运当前运行在备用信号栈中。试图为运行在备用信号栈中的进程定义备用信号栈会导致错误<code>EPERM</code>。</p><p>　　● <code>SS_DISABLE</code>会出现在<code>old_sigstack</code>中，表示当前没有备用信号栈。当在<code>sigstack</code>中指定该标志时，会禁用1个现有备用信号栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数使用了非异步信号安全函数 (printf()、strsignal()fflush())</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigsegvHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal %d (%s)\n&quot;</span>, sig, strsignal(sig));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top of handler stack near %10p\n&quot;</span>, (<span class="type">void</span> *)&amp;x);</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    _exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用于溢出栈的递归函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param callNum</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">overflowStack</span><span class="params">(<span class="type">int</span> callNum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">100000</span>]; <span class="comment">/* 让栈帧较大 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Call %4d - top of stack near %10p\n&quot;</span>, callNum, &amp;a[<span class="number">0</span>]);</span><br><span class="line">    overflowStack(callNum + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">stack_t</span> sigstack;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Top of standard stack is near %10p\n&quot;</span>, (<span class="type">void</span> *)&amp;j);</span><br><span class="line"></span><br><span class="line">    sigstack.ss_sp = <span class="built_in">malloc</span>(SIGSTKSZ);</span><br><span class="line">    <span class="keyword">if</span> (sigstack.ss_sp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigstack.ss_size = SIGSTKSZ;</span><br><span class="line">    sigstack.ss_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sigaltstack(&amp;sigstack, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaltstack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alternate stack is at %10p-%p\n&quot;</span>,</span><br><span class="line">           sigstack.ss_sp, (<span class="type">char</span> *)sbrk(<span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sa.sa_handler = sigsegvHandler; <span class="comment">/* 为信号SIGSEGV注册处理函数 */</span></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_ONSTACK; <span class="comment">/* 处理函数将使用备用信号栈 */</span></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGSEGV, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    overflowStack(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序会定义和使用备用信号栈。在定义了备用信号栈和注册了信号处理函数后，该程序会调用无限递归的函数，所以栈会溢出，并且程序会收到信号<code>SIGSEGV</code>。</p><h3 id="标志sa_siginfo">21.5 标志<code>SA_SIGINFO</code></h3><p>　　若在通过<code>sigaction()</code>注册信号处理函数时指定了标志<code>SA_SIGINFO</code>，则信号到达时信号处理函数会得到关于信号的额外信号。为此，需要将处理函数声明为以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *siginfo, <span class="type">void</span> *ucontext)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> si_signo;          <span class="comment">/* 信号编号 */</span></span><br><span class="line">    <span class="type">int</span> si_code;           <span class="comment">/* 信号代码 */</span></span><br><span class="line">    <span class="type">int</span> si_trapno;         <span class="comment">/* 导致硬件生成的信号生成的陷阱号 (大部分架构都不会使用) */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">si_value</span>;</span> <span class="comment">/* 来自sigqueue()的随附数据 */</span></span><br><span class="line">    <span class="type">pid_t</span> si_pid;          <span class="comment">/* 发送进程的进程ID */</span></span><br><span class="line">    <span class="type">uid_t</span> si_uid;          <span class="comment">/* 发送进程的实际用户ID */</span></span><br><span class="line">    <span class="type">int</span> si_errno;          <span class="comment">/* 错误号 (通常不会使用) */</span></span><br><span class="line">    <span class="type">void</span> *si_addr;         <span class="comment">/* 生成信号的地址 (仅限于硬件生成的信号) */</span></span><br><span class="line">    <span class="type">int</span> si_overrun;        <span class="comment">/* 超限计数 (POSIX定时器) */</span></span><br><span class="line">    <span class="type">int</span> si_timerid;        <span class="comment">/* 内核内部的定时器ID (POSIX定时器) */</span></span><br><span class="line">    <span class="type">long</span> si_band;          <span class="comment">/* band event (仅限于信号SIGIO/SIGPOLL) */</span></span><br><span class="line">    <span class="type">int</span> si_fd;             <span class="comment">/* 文件描述符 (仅限于信号SIGIO/SIGPOLL) */</span></span><br><span class="line">    <span class="type">int</span> si_status;         <span class="comment">/* 退出状态或信号 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">clock_t</span> si_utime;      <span class="comment">/* 用户CPU时间 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">clock_t</span> si_stime;      <span class="comment">/* 系统CPU时间 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">short</span> si_addr_lsb;     <span class="comment">/* 地址的最低有效位 (Linux 2.6.32及以上版本) */</span></span><br><span class="line">    <span class="type">void</span> *si_lower;        <span class="comment">/* 发生地址冲突时的下限 (Linux 3.19及以上版本) */</span></span><br><span class="line">    <span class="type">void</span> *si_upper;        <span class="comment">/* 发生地址冲突时的下限 (Linux 3.19及以上版本) */</span></span><br><span class="line">    <span class="type">int</span> si_pkey;           <span class="comment">/* 导致故障的PTE的保护键值 (Linux 4.6及以上版本) */</span></span><br><span class="line">    <span class="type">void</span> *si_call_addr;    <span class="comment">/* 系统调用指令的地址 (Linux 3.5及以上版本) */</span></span><br><span class="line">    <span class="type">int</span> si_syscall;        <span class="comment">/* 尝试系统调用的次数 (Linux 3.5及以上版本) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> si_arch;  <span class="comment">/* 尝试系统调用的架构 (Linux 3.5及以上版本) */</span></span><br><span class="line">&#125; <span class="type">siginfo_t</span>;</span><br></pre></td></tr></table></figure><p>　　参数<code>sig</code>是目标信号。参数<code>siginfo</code>指向的结构体提供关于信号的额外信息。参数<code>ucontext</code>指向定义在头文件<code>ucontext.h</code>中的结构体<code>ucontext_t</code>。</p><p>　　因为此类信号处理函数的原型不同于标准信号处理函数，所以调用<code>sigaction()</code>需要指定结构体<code>sigaction</code>的成员<code>sa_sigaction</code>。</p><p>　　将特性测试宏<code>_POSIX_C_SOURCE</code>定义为大于199309的值后，结构体<code>siginfo_t</code>会被声明在头文件<code>signal.h</code>中。对于Linux和大多数UNIX实现，该结构体中的很多成员都合并为共用体，因为并非每个信号都需要这些成员 (详情见头文件<code>bits/siginfo.h</code>)。</p><p>　　● 成员<code>si_signo</code>适用于所有信号，其值与<code>sigaction()</code>的参数<code>sig</code>相同。</p><p>　　● 成员<code>si_code</code>适用于所有信号，包含关于信号源的更多信息的代码 (这里没有列出所有UNIX实现和硬件架构都提供的特定于信号的<code>si_code</code>值，尤其是信号<code>SIGBUS</code>、<code>SIGSEGV</code>、<code>SIGILL</code>和<code>SIGFPE</code>。但是，Linux定义了这里列出的所有值，并且SUSv3详细说明了其中的大部分值。值<code>SI_KERNEL</code>和<code>SI_SIGIO</code>是特定于Linux的，SUSv3没有说明这2个值，并且没有UNIX实现提供这2个值。值<code>SI_SIGIO</code>仅用于Linux 2.2。从内核2.4开始，Linux开始使用值<code>POLL_*</code>来代替<code>SI_SIGIO</code>)：</p><table><colgroup><col style="width:16%"><col style="width:18%"><col style="width:65%"></colgroup><thead><tr><th><code>si_code</code>值</th><th>适用的信号</th><th>信号源</th></tr></thead><tbody><tr><td><code>SI_ASYNCIO</code></td><td>所有信号</td><td>异步I/O操作完成</td></tr><tr><td><code>SI_KERNEL</code></td><td>所有信号</td><td>由内核发送 (例如，来自终端驱动程序)</td></tr><tr><td><code>SI_MESGQ</code></td><td>所有信号</td><td>POSIX消息队列有消息到达 (Linux 2.6.6及以上版本)</td></tr><tr><td><code>SI_QUEUE</code></td><td>所有信号</td><td>用户进程通过<code>sigqueue()</code>发送实时信号</td></tr><tr><td><code>SI_SIGIO</code></td><td>所有信号</td><td><code>SIGIO</code>信号 (Linux 2.2)</td></tr><tr><td><code>SI_TIMER</code></td><td>所有信号</td><td>POSIX实时定时器过期</td></tr><tr><td><code>SI_TKILL</code></td><td>所有信号</td><td>由用户进程通过<code>tkill()</code>或<code>tgkill()</code>发送 (Linux 2.4.19及以上版本)</td></tr><tr><td><code>SI_USER</code></td><td>所有信号</td><td>由用户进程通过<code>kill()</code>或<code>raise()</code>发送</td></tr><tr><td><code>BUS_ADRALN</code></td><td><code>SIGBUS</code></td><td>无效地址对齐</td></tr><tr><td><code>BUS_ADRERR</code></td><td><code>SIGBUS</code></td><td>不存在的物理地址</td></tr><tr><td><code>BUS_MCEERR_AO</code></td><td><code>SIGBUS</code></td><td>硬件内存错误，是否采取行动可选 (Linux 2.6.32及以上版本)</td></tr><tr><td><code>BUS_MCEERR_AR</code></td><td><code>SIGBUS</code></td><td>硬件内存错误，必须采取行动 (Linux 2.6.32及以上版本)</td></tr><tr><td><code>BUS_OBJERR</code></td><td><code>SIGBUS</code></td><td>特定于对象的硬件错误</td></tr><tr><td><code>CLD_CONTINUED</code></td><td><code>SIGCHLD</code></td><td>子进程由于信号<code>SIGCONT</code>恢复执行 (Linux 2.6.9及以上版本)</td></tr><tr><td><code>CLD_DUMPED</code></td><td><code>SIGCHLD</code></td><td>子进程异常终止，并且生成了核心转储文件</td></tr><tr><td><code>CLD_EXITED</code></td><td><code>SIGCHLD</code></td><td>子进程退出</td></tr><tr><td><code>CLD_KILLED</code></td><td><code>SIGCHLD</code></td><td>子进程异常终止，并且没有生成核心转储文件</td></tr><tr><td><code>CLD_STOPPED</code></td><td><code>SIGCHLD</code></td><td>子进程停止</td></tr><tr><td><code>CLD_TRAPPED</code></td><td><code>SIGCHLD</code></td><td>追踪的子进程停止</td></tr><tr><td><code>FPE_FLTDIV</code></td><td><code>SIGFPE</code></td><td>浮点数除以0</td></tr><tr><td><code>FPE_FLTINV</code></td><td><code>SIGFPE</code></td><td>无效浮点数操作</td></tr><tr><td><code>FPE_FLTOVF</code></td><td><code>SIGFPE</code></td><td>浮点数向上溢出</td></tr><tr><td><code>FPE_FLTRES</code></td><td><code>SIGFPE</code></td><td>不精确的浮点数结果</td></tr><tr><td><code>FPE_FLTUND</code></td><td><code>SIGFPE</code></td><td>浮点数向下溢出</td></tr><tr><td><code>FPE_INTDIV</code></td><td><code>SIGFPE</code></td><td>整数除以0</td></tr><tr><td><code>FPE_INTOVF</code></td><td><code>SIGFPE</code></td><td>整数溢出</td></tr><tr><td><code>FPE_SUB</code></td><td><code>SIGFPE</code></td><td>下标超出范围</td></tr><tr><td><code>ILL_BADSTK</code></td><td><code>SIGILL</code></td><td>内核栈错误</td></tr><tr><td><code>ILL_COPROC</code></td><td><code>SIGILL</code></td><td>协处理器错误</td></tr><tr><td><code>ILL_ILLADR</code></td><td><code>SIGILL</code></td><td>非法寻址模式</td></tr><tr><td><code>ILL_ILLOPC</code></td><td><code>SIGILL</code></td><td>非法操作码</td></tr><tr><td><code>ILL_ILLOPN</code></td><td><code>SIGILL</code></td><td>非法操作数</td></tr><tr><td><code>ILL_ILLTRP</code></td><td><code>SIGILL</code></td><td>非法陷阱</td></tr><tr><td><code>ILL_PRVOPC</code></td><td><code>SIGILL</code></td><td>特权操作码</td></tr><tr><td><code>ILL_PRVREG</code></td><td><code>SIGILL</code></td><td>特权寄存器</td></tr><tr><td><code>POLL_ERR</code></td><td><code>SIGIO</code>/<code>SIGPOLL</code></td><td>I/O错误</td></tr><tr><td><code>POLL_HUP</code></td><td><code>SIGIO</code>/<code>SIGPOLL</code></td><td>设备断开连接</td></tr><tr><td><code>POLL_IN</code></td><td><code>SIGIO</code>/<code>SIGPOLL</code></td><td>输入数据可用</td></tr><tr><td><code>POLL_MSG</code></td><td><code>SIGIO</code>/<code>SIGPOLL</code></td><td>输入消息可用</td></tr><tr><td><code>POLL_OUT</code></td><td><code>SIGIO</code>/<code>SIGPOLL</code></td><td>输出缓冲区可用</td></tr><tr><td><code>POLL_PRI</code></td><td><code>SIGIO</code>/<code>SIGPOLL</code></td><td>高优先级输入可用</td></tr><tr><td><code>SEGV_ACCERR</code></td><td><code>SIGSEGV</code></td><td>映射对象的权限无效</td></tr><tr><td><code>SEGV_MAPERR</code></td><td><code>SIGSEGV</code></td><td>地址未映射到对象</td></tr><tr><td><code>TRAP_BRANCH</code></td><td><code>SIGTRAP</code></td><td>进程分支陷阱</td></tr><tr><td><code>TRAP_BRKPT</code></td><td><code>SIGTRAP</code></td><td>进程断点</td></tr><tr><td><code>TRAP_HWBKPT</code></td><td><code>SIGTRAP</code></td><td>硬件断点/观察点</td></tr><tr><td><code>TRAP_TRACE</code></td><td><code>SIGTRAP</code></td><td>进程追踪陷阱</td></tr></tbody></table><p>　　● 成员<code>si_value</code>包含通过<code>sigqueue()</code>发送的信号的随附数据。</p><p>　　● 成员<code>si_pid</code>是通过<code>kill()</code>或<code>sigqueue()</code>发送信号的进程的进程ID。</p><p>　　● 成员<code>si_uid</code>是通过<code>kill()</code>或<code>sigqueue()</code>发送信号的进程的实际用户ID。这里提供发送进程的实际用户ID是因为实际用户ID提供的信息比有效用户ID提供的信息更多。当发送进程的实际用户ID与有效用户ID不同时，让接收进程知道发送进程的实际用户ID可能很有用。</p><p>　　● 成员<code>si_errno</code>设置为非0值时表示标识信号源的错误号 (与<code>errno</code>类似)。对于Linux，该成员通常不会使用。</p><p>　　● 成员<code>si_addr</code>仅适用于信号<code>SIGBUS</code>、<code>SIGSEGV</code>、<code>SIGILL</code>和<code>SIGFPE</code>。对于信号<code>SIGBUS</code>和<code>SIGSEGV</code>，该成员包含导致无效内存引用的地址。对于信号<code>SIGILL</code>和<code>SIGFPE</code>，该成员包含导致信号的程序指令的地址。</p><p>　　● 成员<code>si_overrun</code>和<code>si_timerid</code>是非标准Linux扩展，仅会在POSIX定时器过期时生成的信号到达时设置。前者表示定时器的超限计数，后者包含内核内部使用的用于标识定时器的ID。</p><p>　　● 成员<code>si_band</code>和<code>si_fd</code>只会在信号<code>SIGIO</code>/<code>SIGPOLL</code>到达时设置。前者包含与I/O事件关联的band event值 (对于glibc 2.3.2及以下版本，该成员的数据类型为<code>int</code>)，后者包含与I/O事件关联的文件描述符 (SUSv3没有说明该成员，但很多UNIX实现都提供了该成员)。</p><p>　　● 成员<code>si_status</code>、<code>si_utime</code>和<code>si_stime</code>只会在信号<code>SIGCHLD</code>到达时设置。成员<code>si_status</code>包含子进程的退出状态 (若成员<code>si_code</code>是<code>CLD_EXITED</code>) 或发送给子进程的信号的编号 (即终止或停止子进程的信号的编号)。成员<code>si_utime</code>是子进程所用的用户CPU时间。对于内核2.6之前的版本和2.6.27及之后的版本，该成员的计量单位是系统时钟周期 (除以<code>sysconf(_SC_CLK_TCK)</code>)。对内核2.6.27之前的2.6版本，漏洞的存在导致该成员的计量单位是jiffy。成员<code>si_stime</code>是子进程所用的系统CPU时间。SUSv3没有说明成员<code>si_utime</code>和<code>si_stime</code>，但很多UNIX实现都提供了这2个成员。</p><p>　　SUSv3没有说明结构体<code>ucontext_t</code>的任何成员 (所以参数<code>ucontext</code>的类型是<code>void *</code>)。该结构体提供用户上下文信息，用于描述调用信号处理函数之前的进程状态，其中包括信号掩码的旧值和保存的寄存器值 (例如，程序计数器和栈指针)。信号处理函数几乎不会使用这些信息，所以这里不介绍细节。</p><p>　　函数<code>getcontext()</code>、<code>makecontext()</code>、<code>setcontext()</code>和<code>swapcontext()</code>也会使用结构体<code>ucontext_t</code>，这些函数允许进程检索、创建、修改和切换执行上下文 (这些操作与<code>setjmp()</code>和<code>longjmp()</code>类似，但更通用)。这些函数可用于实现协程 (进程的执行线程在多个函数之间交替)。SUSv3说明了这些函数，但将它们标记为过时。SUSv4删除了相关规范，并建议应用程序使用POSIX线程代替它们。</p><p>　　SUSv4详细说明了与<code>psignal()</code>类似的函数<code>psiginfo()</code>。该函数有2个参数：指向结构体<code>siginfo_t</code>的指针和消息字符串。该函数会在标准错误中打印消息字符串加上关于结构体<code>siginfo_t</code>的信息。glibc从2.10开始提供该函数。glibc实现会打印信号描述和信号源 (如成员<code>si_code</code>所示)，并且对于某些信号，还会打印结构体<code>siginfo_t</code>的其他成员。<code>psiginfo()</code>是SUSv4新增的规范，但并非所有系统都提供了该函数。</p><h3 id="中断和重启系统调用">21.6 中断和重启系统调用</h3><p>　　并非所有被信号处理函数中断的阻塞系统调用都可以通过标志<code>SA_RESTART</code>重启，部分原因是历史造成的：</p><p>　　● 重启系统调用最早出现在4.2BSD，包含<code>wait()</code>、<code>waitpid()</code>、<code>read()</code>、<code>readv()</code>、<code>write()</code>、<code>writev()</code>和<code>ioctl()</code>的阻塞操作。I/O系统调用是可中断的，所以只有在操作 "慢设备" 时，才会被标志<code>SA_RESTART</code>重启。这些慢设备包括终端、有名管道、无名管道和套接字。对于其他类型的文件，各种I/O操作可能会阻塞。相比之下，磁盘不属于慢设备，因为磁盘I/O操作通常会通过缓冲区缓存立即完成。当需要进行实际的磁盘I/O时，内核会让进程睡眠，直到I/O完成。</p><p>　　● 很多其他阻塞系统调用都源于System V，System V最初不支持重启系统调用。</p><p>　　对于Linux，在指定了标志<code>SA_RESTART</code>后，以下阻塞系统调用 (包括基于它们的包装库函数) 在被信号处理函数中断后会自动重启：</p><p>　　● 用于等待子进程的系统调用，包括<code>wait()</code>、<code>waitpid()</code>、<code>wait3()</code>、<code>wait4()</code>和<code>waitid()</code>。</p><p>　　● 操作慢设备的I/O系统调用，包括<code>read()</code>、<code>readv()</code>、<code>write()</code>、<code>writev()</code>和<code>ioctl()</code>。若数据传输过程中信号到达，则输入和输出系统调用都会被中断，但会返回成功状态 (表示实际传输的字节数的整数)。</p><p>　　● 以可阻塞的方式调用的<code>open()</code>(例如，打开有名管道)。</p><p>　　● 与套接字一起使用的各种系统调用，包括<code>accept()</code>、<code>accept4()</code>、<code>connect()</code>、<code>send()</code>、<code>sendmsg()</code>、<code>sendto()</code>、<code>recv()</code>、<code>recvfrom()</code>和<code>recvmsg()</code>。对于Linux，若通过<code>setsockopt()</code>为套接字设置了超时时间，则这些系统调用不会自动重启。</p><p>　　● 用于POSIX消息队列上的I/O的系统调用，包括<code>mq_receive()</code>、<code>mq_timedreceive()</code>、<code>mq_send()</code>和<code>mq_timedsend()</code>。</p><p>　　● 用于对文件上锁的系统调用和库函数，包括<code>flock()</code>、<code>fcntl()</code>和<code>lockf()</code>。</p><p>　　● 特定于Linux的系统调用<code>futex()</code>的操作<code>FUTEX_WAIT</code>。</p><p>　　● 用于减少POSIX信号量的函数，包括<code>sem_wait()</code>和<code>sem_timedwait()</code> (对于部分UNIX实现，在指定了标志<code>SA_RESTART</code>后，<code>sem_wait()</code>会自动重启)。</p><p>　　● 用于同步POSIX线程的函数，包括<code>pthread_mutex_lock()</code>、<code>pthread_mutex_trylock()</code>、<code>pthread_mutex_timedlock()</code>、<code>pthread_cond_wait()</code>和<code>pthread_cond_timedwait()</code>。</p><p>　　在2.6.22之前的内核中，<code>futex()</code>、<code>sem_wait()</code>和<code>sem_timedwait()</code>总是会在被中断时出错 (<code>EINTR</code>)，无论是否指定了标志<code>SA_RESTART</code>。</p><p>　　以下阻塞系统调用 (包括基于它们的包装库函数) 永远不会自动重启 (即使指定了标志<code>SA_RESTART</code>)：</p><p>　　● 用于I/O多路复用的系统调用，包括<code>poll()</code>、<code>select()</code>和<code>pselect()</code>。SUSv3明确规定，当被信号处理函数中断后，<code>select()</code>和<code>pselect()</code>的行为将是不确定的。</p><p>　　● 特定于Linux的系统调用<code>epoll_wait()</code>和<code>epoll_pwait()</code>。</p><p>　　● 特定于Linux的系统调用<code>io_getevents()</code>。</p><p>　　● 与System V消息队列和信号量一起使用的阻塞系统调用，包括<code>semop()</code>、<code>semtimedop()</code>、<code>msgrcv()</code>和<code>msgsnd()</code> (尽管System V原生不支持重启系统调用，但对于有些UNIX实现，在指定了标志<code>SA_RESTART</code>后，这些系统调用会自动重启)。</p><p>　　● 对inotify文件描述符调用的<code>read()</code>。</p><p>　　● 用于将程序挂起指定时间的系统调用和库函数，包括<code>sleep()</code>、<code>nanosleep()</code>和<code>clock_nanosleep()</code>。</p><p>　　● 用于挂起进程来等待信号的系统调用，包括<code>pause()</code>、<code>sigsuspend()</code>、<code>sigtimedwait()</code>和<code>sigwaitinfo()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">siginterrupt</span><span class="params">(<span class="type">int</span> sig, <span class="type">int</span> flag)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>siginterrupt()</code>会修改参数<code>sig</code>指定的信号关联的<code>SA_RESTART</code>设置。若<code>flag</code>是1，则<code>sig</code>对应的处理函数会中断阻塞系统调用。若<code>flag</code>是0，则阻塞系统调用会在<code>sig</code>对应的处理函数执行完成后重启。</p><p>　　该函数通过<code>sigaction()</code>获取信号的当前处理方式，并调整参数<code>oldact</code>中的标志<code>SA_RESTART</code>，然后再次调用<code>sigaction()</code>来更新信号的处理方式。</p><p>　　SUSv4将该函数标记为过时，并推荐使用<code>sigaction()</code>来代替该函数。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_01/" rel="prev" title="《ARM Cortex-M3与Cortex-M4权威指南 第3版》第1章 ARM Cortex-M处理器简介"><i class="fa fa-angle-left"></i> 《ARM Cortex-M3与Cortex-M4权威指南 第3版》第1章 ARM Cortex-M处理器简介</a></div><div class="post-nav-item"><a href="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/" rel="next" title="《ARM Cortex-M3与Cortex-M4权威指南 第3版》第2章 嵌入式软件开发简介">《ARM Cortex-M3与Cortex-M4权威指南 第3版》第2章 嵌入式软件开发简介 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>