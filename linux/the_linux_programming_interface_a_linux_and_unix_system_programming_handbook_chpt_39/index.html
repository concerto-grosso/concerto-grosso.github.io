<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_39/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_39/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_39/","title":"《Linux/UNIX系统编程手册》第39章 能力"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第39章 能力 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E6%96%87%E4%BB%B6%E8%83%BD%E5%8A%9B"><span class="nav-text">39.1 进程和文件能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E8%83%BD%E5%8A%9B"><span class="nav-text">39.2 Linux能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exec%E6%9C%9F%E9%97%B4%E8%BF%9B%E7%A8%8B%E8%83%BD%E5%8A%9B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">39.3 exec()期间进程能力的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7id%E5%AF%B9%E8%BF%9B%E7%A8%8B%E8%83%BD%E5%8A%9B%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">39.4 修改用户ID对进程能力的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BF%AE%E6%94%B9%E8%BF%9B%E7%A8%8B%E8%83%BD%E5%8A%9B"><span class="nav-text">39.5 在程序中修改进程能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%8C%E5%85%A8%E5%9F%BA%E4%BA%8E%E8%83%BD%E5%8A%9B%E7%9A%84%E7%8E%AF%E5%A2%83"><span class="nav-text">39.6 创建完全基于能力的环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E6%94%AF%E6%8C%81%E6%96%87%E4%BB%B6%E8%83%BD%E5%8A%9B%E7%9A%84%E6%97%A7%E5%86%85%E6%A0%B8%E5%92%8C%E7%B3%BB%E7%BB%9F"><span class="nav-text">39.7 不支持文件能力的旧内核和系统</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_39/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第39章 能力 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第39章 能力</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-11-29 00:00:00" itemprop="dateCreated datePublished" datetime="2025-11-29T00:00:00+08:00">2025-11-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-11-30 00:00:00" itemprop="dateModified" datetime="2025-11-30T00:00:00+08:00">2025-11-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>15k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　传统UNIX特权机制将进程分为2类：有效用户ID为0 (超级用户) 的进程以及其他所有进程。前者可以绕过所有权限检查，后者根据其用户和组ID接受权限检查。</p><p>　　对于传统UNIX特权机制，若进程需要执行特权操作，则必须在运行该进程时将其有效用户ID设置为0 (若非特权用户需要执行特权操作，则通常会使用set-user-ID-root程序)，但这种方法会授予进程很多其他操作的权限 (例如，绕过所有访问文件的权限检查)。因此，若程序行为异常，就会导致安全漏洞。如前所述，处理该问题的传统方法是放弃特权并在有需要时临时获取特权。</p><p>　　Linux能力机制改进了该问题的处理方式。超级用户特权被划分为称为<strong>能力</strong>的独立单元。每个特权操作与特定的能力关联，并且进程执行特权操作需要拥有对应的能力。当进程的有效用户ID为0时，内核会授予该进程所有能力。</p><p>　　Linux能力实现基于POSIX 1003.1e草案。这项标准化工作在20世纪90年代末期尚未完成前就陷入了困境，但各种能力实现仍然基于该草案。</p><p>　　Sun的Solaris 10和早期的Trusted Solaris版本、SGI的Trusted Irix以及FreeBSD的TrustedBSD等UNIX实现也提供了能力机制。其他操作系统也存在类似的机制 (例如，Digital的VMS系统中的特权机制)。</p><p>　　完全实现能力机制需要满足以下条件：</p><p>　　● 对于每个特权操作，内核应检查进程是否拥有对应的能力，而非检查其有效 (文件系统) 用户ID是否为0。</p><p>　　● 内核必须提供用于检索和修改进程能力的系统调用。</p><p>　　● 内核必须支持将能力附加到可执行文件的概念，以便进程在执行该文件时获取关联的能力。这与set-user-ID位类似，但允许单独指定可执行文件的所有能力。此外，系统必须提供用于检索和设置附加到可执行文件的能力的API和命令。</p><p>　　对于内核2.6.23及以下版本，Linux仅满足前2个要求。从内核2.6.24开始，Linux支持将能力附加到文件。内核2.6.25和2.6.26添加的各种特性使得Linux能够满足所有要求。</p><span id="more"></span><h3 id="进程和文件能力">39.1 进程和文件能力</h3><p>　　内核为每个进程维护了3个关联的能力集：<span style="background-color:#ff0">允许能力集</span>、<span style="background-color:#ff0">有效能力集</span>和<span style="background-color:#ff0">可继承能力集</span>。</p><p>　　● 进程的允许能力集是进程可以使用的能力的集合。允许能力集合是可添加到有效能力集和可继承能力集中的能力的超集。若进程从其允许能力集中删除了某个能力，则它将永远无法重新获取该能力 (除非它执行能够授予该能力的程序)。</p><p>　　● 进程的有效能力集是内核用于对进程执行权限检查的能力的集合。只要进程在其允许能力集中保留了某个能力，就可以通过从其有效能力集删除该能力来临时禁用它，然后再将其恢复到有效能力集。</p><p>　　● 进程的可继承能力集是程序被进程执行时可以被继承到进程的允许能力集的能力的集合。</p><p>　　进程的允许能力集、有效能力集和可继承能力集的十六进制表示分别可以通过特定于Linux的文件<code>/proc/PID/status</code>的字段<code>CapPrm</code>、<code>CapEff</code>和<code>CapInh</code>获取。</p><p>　　通过<code>fork()</code>创建的子进程会继承父进程的能力集。</p><p>　　实际上，能力是线程级属性。线程的能力可以通过文件<code>/proc/PID/task/TID/status</code>获取。主线程的能力可以通过文件<code>/proc/PID/status</code>获取。</p><p>　　在内核2.6.25之前，Linux使用32位能力集。内核2.6.25中新增的能力需要64位能力集。</p><p>　　文件可以有3个关联的能力集：<span style="background-color:#ff0">允许能力集</span>、<span style="background-color:#ff0">有效能力集</span>和<span style="background-color:#ff0">可继承能力集</span>，用于决定进程执行该文件时授予该进程的能力。</p><p>　　● 文件的允许能力集是在<code>exec()</code>期间添加给进程的允许能力集的能力的集合。</p><p>　　● 文件的有效能力集只是1个位。若启用该位，则<code>exec()</code>期间进程的新允许能力集中启用的能力也会在进程的新有效能力集中被启用。若禁用该位，则<code>exec()</code>后进程的新有效能力集最初为空。对于不知道能力机制的传统程序，<code>exec()</code>应该能让新允许能力集中启用的所有能力在新有效能力集中被启用。对于设计时考虑了能力机制的程序，最小权限表示进程的有效能力集最初应该为空。</p><p>　　● 文件的可继承能力集会对进程的可继承能力集进行掩码操作 (与运算<code>&amp;</code>)，以确定<code>exec()</code>后应在进程的允许能力集中启用的能力。</p><p>　　文件的允许能力集和可继承能力集以前称为强制能力集和允许能力集。这些术语已经过时，但仍然有参考意义。文件的允许能力集是在<code>exec()</code>期间会被强制添加到进程的允许能力集的能力的集合。文件的可继承能力集是<code>exec()</code>期间允许被添加到进程的允许能力集的能力的集合，前提进程的可继承能力集也启用了这些能力。</p><p>　　安全扩展属性<code>security.capability</code>存储着与文件关联的能力，更新该扩展属性需要能力<code>CAP_SETFCAP</code>。</p><p>　　命令<code>setcap</code>和<code>getcap</code>可用于控制文件能力集。这里将通过标准程序<code>date</code>来展示它们的用法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">Tue Dec 28 15:54:08 CST 2010</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> -s <span class="string">&#x27;2018-02-01 21:39&#x27;</span></span> </span><br><span class="line">date: cannot set date: Operation not permitted</span><br><span class="line">Thu Feb  1 21:39:00 CST 2018</span><br></pre></td></tr></table></figure><p>　　首先，打印当前系统时间并尝试以非特权用户修改时间。根据结果可知，修改失败，但还是以标准格式打印了参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">date</span> -s <span class="string">&#x27;2018-02-01 21:39&#x27;</span></span></span><br><span class="line">root&#x27;s password:</span><br><span class="line">Thu Feb  1 21:39:00 CST 2018</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">Thu Feb  1 21:39:00 CST 2018</span><br></pre></td></tr></table></figure><p>　　然后，以超级用户修改时间。根据结果可知，修改成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis -b <span class="built_in">date</span></span></span><br><span class="line">date: /bin/date</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> /bin/date .</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">setcap</span> <span class="string">&quot;cap_sys_time=pe&quot;</span> <span class="built_in">date</span></span></span><br><span class="line">root&#x27;s password:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">getcap</span> <span class="built_in">date</span></span></span><br><span class="line">date = cap_sys_time+ep</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./date -s <span class="string">&#x27;2010-12-28 15:55&#x27;</span></span></span><br><span class="line">Thu Feb  1 15:55:00 CST 2010</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">Thu Feb  1 15:55:02 CST 2010</span><br></pre></td></tr></table></figure><p>　　最后，复制程序<code>date</code>并为它分配所需的能力。这里通过命令<code>setcap</code>将能力<code>CAP_SYS_TIME</code>添加到该程序的允许能力集 (<code>p</code>) 和有效能力集 (<code>e</code>)，通过命令<code>getcap</code>验证分配的能力，并以非特权用户运行它来修改系统时间。</p><h3 id="linux能力">39.2 Linux能力</h3><p>　　下表列出了各种Linux能力 (包括适用的操作的不完整介绍)：</p><table><colgroup><col style="width:26%"><col style="width:73%"></colgroup><thead><tr><th>能力</th><th>允许进程执行的操作</th></tr></thead><tbody><tr><td><code>CAP_AUDIT_CONTROL</code></td><td>(Linux 2.6.11及以上版本) 启用和禁用内核审计日志；修改审计过滤规则；检索审计状态和过滤规则</td></tr><tr><td><code>CAP_AUDIT_WRITE</code></td><td>(Linux 2.6.11及以上版本) 向内核审计日志写入记录</td></tr><tr><td><code>CAP_CHOWN</code></td><td>修改文件的用户ID或将文件的组ID修改为进程不属于的组的ID (<code>chown()</code>)</td></tr><tr><td><code>CAP_DAC_OVERRIDE</code></td><td>绕过文件读取、写入和执行权限检查 (DAC是自主访问控制的缩写)；读取<code>/proc/PID</code>中的符号链接<code>cwd</code>、<code>exe</code>和<code>root</code>的内容</td></tr><tr><td><code>CAP_DAC_READ_SEARCH</code></td><td>绕过文件的读取权限检查以及目录的读取和执行 (搜索) 权限检查</td></tr><tr><td><code>CAP_FOWNER</code></td><td>通常忽略对那些需要进程的文件系统用户ID匹配文件的用户ID的操作的权限检查 (<code>chmod()</code>和<code>utime()</code>)；设置任意文件的i-node标志；设置和修改任意的文件的ACL；删除文件时无视目录的粘滞位 (<code>unlink()</code>、<code>rmdir()</code>和<code>rename()</code>)；对任意文件调用<code>open()</code>和<code>fcntl(F_SETFL)</code>时指定标志<code>O_NOATIME</code></td></tr><tr><td><code>CAP_FSETID</code></td><td>修改文件而不让内核禁用set-user-ID和set-group-ID位 (<code>write()</code>和<code>truncate()</code>)；进程的文件系统组ID或辅助组ID不匹配文件的组ID时启用文件的set-group-ID位 (<code>chmod()</code>)</td></tr><tr><td><code>CAP_IPC_LOCK</code></td><td>覆盖内存锁定限制 (<code>mlock()</code>、<code>mlockall()</code>、<code>shmctl(SHM_LOCK)</code>和<code>shmctl(SHM_UNLOCK)</code>)；使用<code>shmget()</code>的标志<code>SHM_HUGETLB</code>和<code>mmap()</code>的标志<code>MAP_HUGETLB</code></td></tr><tr><td><code>CAP_IPC_OWNER</code></td><td>绕过System V IPC对象操作的权限检查</td></tr><tr><td><code>CAP_KILL</code></td><td>绕过发送信号的权限检查 (<code>kill()</code>和<code>sigqueue()</code>)</td></tr><tr><td><code>CAP_LEASE</code></td><td>(Linux 2.4及以上版本) 对任意文件建立租约 (<code>fcntl(F_SETLEASE)</code>)</td></tr><tr><td><code>CAP_LINUX_IMMUTABLE</code></td><td>设置i-node标志<code>FS_APPEND_FL</code>和<code>FS_IMMUTABLE_FL</code></td></tr><tr><td><code>CAP_MAC_ADMIN</code></td><td>(Linux 2.6.25及以上版本) 配置或修改强制访问控制 (MAC) 的状态 (由某些Linux安全模块实现)</td></tr><tr><td><code>CAP_MAC_OVERRIDE</code></td><td>(Linux 2.6.25及以上版本) 覆盖MAC (由某些Linux安全模块实现)</td></tr><tr><td><code>CAP_MKNOD</code></td><td>(Linux 2.4及以上版本) 通过<code>mknod()</code>来创建设备</td></tr><tr><td><code>CAP_NET_ADMIN</code></td><td>执行各种网络相关操作 (例如，设置特权套接字选项、启用多播、配置网络接口和修改路由表)</td></tr><tr><td><code>CAP_NET_BIND_SERVICE</code></td><td>绑定特权套接字端口</td></tr><tr><td><code>CAP_NET_BROADCAST</code></td><td>(未使用) 执行套接字广播并监听多播</td></tr><tr><td><code>CAP_NET_RAW</code></td><td>使用原始和分组套接字</td></tr><tr><td><code>CAP_SETGID</code></td><td>随意修改进程组ID (<code>setgid()</code>、<code>setegid()</code>、<code>setregid()</code>、<code>setresgid()</code>、<code>setfsgid()</code>、<code>setgroups()</code>和<code>initgroups()</code>)；通过UNIX域套接字传递凭证时伪造组ID (<code>SCM_CREDENTIALS</code>)</td></tr><tr><td><code>CAP_SETFCAP</code></td><td>(Linux 2.6.24及以上版本) 设置文件能力</td></tr><tr><td><code>CAP_SETPCAP</code></td><td>若不支持文件能力，则能够授予或删除其他进程 (包括自身) 进程允许能力集中的能力；若支持文件能力，则能够将进程能力边界集中的任何能力添加到其可继承能力集，从边界集中删除能力，并修改securebits位</td></tr><tr><td><code>CAP_SETUID</code></td><td>随意修改进程用户ID (<code>setuid()</code>、<code>seteuid()</code>、<code>setreuid()</code>、<code>setresuid()</code>和<code>setfsuid()</code>)；通过UNIX域套接字传递时凭证伪造用户ID (<code>SCM_CREDENTIALS</code>)</td></tr><tr><td><code>CAP_SYS_ADMIN</code></td><td>打开文件的系统调用可以超过<code>/proc/sys/fs/file-max</code>限制 (例如，<code>open()</code>、<code>shm_open()</code>、<code>pipe()</code>、<code>socket()</code>、<code>accept()</code>、<code>exec()</code>、<code>acct()</code>和<code>epoll_create()</code>)；执行各种系统管理操作，包括<code>quotactl()</code> (控制磁盘配额)、<code>mount()</code>、<code>umount()</code>、<code>swapon()</code>、<code>swapoff()</code>、<code>pivot_root()</code>、<code>sethostname()</code>和<code>setdomainname()</code>；调用系统调用<code>syslog()</code>；覆盖资源限制<code>RLIMIT_NPROC</code> (<code>fork()</code>)；调用<code>lookup_dcookie()</code>；设置受信任的扩展属性和安全扩展属性；对任意System V IPC对象执行操作<code>IPC_SET</code>和<code>IPC_RMID</code>；通过UNIX域套接字传递凭证时伪造进程ID (<code>SCM_CREDENTIALS</code>)；通过<code>ioprio_set()</code>分配调度类<code>IOPRIO_CLASS_RT</code>；使用<code>ioctl()</code>的操作<code>TIOCCONS</code>；调用<code>clone()</code>和<code>unshare()</code>时指定标志<code>CLONE_NEWNS</code>；执行<code>keyctl()</code>的操作<code>KEYCTL_CHOWN</code>和<code>KEYCTL_SETPERM</code>；管理内核随机数源设备；执行各种特定于设备的操作</td></tr><tr><td><code>CAP_SYS_BOOT</code></td><td>通过<code>reboot()</code>重启系统；调用<code>kexec_load()</code></td></tr><tr><td><code>CAP_SYS_CHROOT</code></td><td>通过<code>chroot()</code>设置进程根目录</td></tr><tr><td><code>CAP_SYS_MODULE</code></td><td>加载和卸载内核模块 (<code>init_module()</code>、<code>delete_module()</code>和<code>create_module()</code>)</td></tr><tr><td><code>CAP_SYS_NICE</code></td><td>减少nice值 (<code>nice()</code>和<code>setpriority()</code>)；修改任意的进程nice值 (<code>setpriority()</code>)；为调用进程设置实时调度策略<code>SCHED_RR</code>和<code>SCHED_FIFO</code>；重置标志<code>SCHED_RESET_ON_FORK</code>；设置任意进程的调度策略和优先级 (<code>sched_setscheduler()</code>和<code>sched_setparam()</code>)；设置任意进程的I/O调度类和级别 (<code>ioprio_set()</code>)；设置任意进程的CPU亲和性 (<code>sched_setaffinity()</code>)；通过<code>migrate_pages()</code>迁移进程，并允许将进程迁移到任意节点；将<code>move_pages()</code>应用于任意进程；调用<code>mbind()</code>和<code>move_pages()</code>时指定标志<code>MPOL_MF_MOVE_ALL</code></td></tr><tr><td><code>CAP_SYS_PACCT</code></td><td>通过<code>acct()</code>启用或禁用进程统计</td></tr><tr><td><code>CAP_SYS_PTRACE</code></td><td>通过<code>ptrace()</code>跟踪任意进程；访问任意进程的<code>/proc/PID/environ</code>；将<code>get_robust_list()</code>应用于任何进程</td></tr><tr><td><code>CAP_SYS_RAWIO</code></td><td>通过<code>iopl()</code>和<code>ioperm()</code>对I/O端口执行操作；访问<code>/proc/kcore</code>；打开<code>/dev/mem</code>和<code>/dev/kmem</code></td></tr><tr><td><code>CAP_SYS_RESOURCE</code></td><td>使用文件系统的保留空间；通过<code>ioctl()</code>控制ext3日志；覆盖磁盘配额限制；增加硬资源限制 (<code>setrlimit()</code>)；覆盖资源限制<code>RLIMIT_NPROC</code> (<code>fork()</code>)；将System V消息队列的<code>msg_qbytes</code>限制提高到<code>/proc/sys/kernel/msgmnb</code>中的限制以上；绕过<code>/proc/sys/fs/mqueue</code>下的文件定义的各种POSIX消息队列限制</td></tr><tr><td><code>CAP_SYS_TIME</code></td><td>修改系统时钟 (<code>settimeofday()</code>、<code>stime()</code>、<code>adjtime()</code>和<code>adjtimex()</code>)；设置硬件时钟</td></tr><tr><td><code>CAP_SYS_TTY_CONFIG</code></td><td>通过<code>vhangup()</code>对终端或伪终端执行虚拟挂断</td></tr></tbody></table><h3 id="exec期间进程能力的转换">39.3 <code>exec()</code>期间进程能力的转换</h3><p>　　在<code>exec()</code>期间，内核会根据进程的当前能力和被执行文件的能力集为进程设置新能力，规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P&#x27;(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; cap_bset)</span><br><span class="line">P&#x27;(effective) = F(effective) ? P&#x27;(permitted) : 0</span><br><span class="line">P&#x27;(inheritable) = P(inheritable)</span><br></pre></td></tr></table></figure><p>　　<code>P</code>表示<code>exec()</code>前的进程能力集，<code>P'</code>表示<code>exec()</code>后的进程能力集，<code>F</code>表示文件能力集。<code>cap_bset</code>表示能力边界集。能力边界集用于限制<code>exec()</code>期间进程可以获得的能力，其使用方式如下：</p><p>　　● 在<code>exec()</code>期间，能力边界集会与文件的允许能力集进行与运算<code>&amp;</code>来决定新程序的允许能力集 (若某个能力不在能力边界集中，则可执行文件的允许能力集就不能授予进程该能力)。</p><p>　　● 能力边界集是可以被添加到进程的可继承能力集的能力的有限超集。当能力边界集和进程的允许能力集中都包含某个能力时，进程才能将该能力添加到其可继承能力集。然后，当进程执行拥有该能力的文件时，该能力会被保留在其允许能力集中。</p><p>　　能力边界集是线程级属性。通过<code>fork()</code>创建的子进程会继承父进程中调用<code>fork()</code>的线程的能力边界集，并且能力边界集在<code>exec()</code>期间会被保留。对于支持文件能力的内核，进程<code>init</code>会以包含所有能力的能力边界集启动。</p><p>　　若进程拥有能力<code>CAP_SETPCAP</code>，则它可以通过<code>prctl()</code>的操作<code>PR_CAPBSET_DROP</code>来 (不可逆地) 删除其能力边界集中的能力。进程从能力边界集中删除能力不会影响其允许、有效和可继承能力集。进程可以通过<code>prctl()</code>的操作<code>PR_CAPBSET_READ</code>来读取其能力边界集。</p><p>　　从Linux 2.6.26开始，能力边界集显示在特定于Linux的文件<code>/proc/PID/task/TID/status</code>的字段<code>CapBnd</code>。主线程的能力边界集可以通过文件<code>/proc/PID/status</code>获取。</p><p>　　为了在执行文件时保留root用户的传统语义 (拥有所有特权)，与文件关联的所有能力都会被忽略。若执行的是set-user-ID-root程序或调用<code>exec()</code>的进程的实际或有效用户ID为0，则文件的允许能力集和可继承能力集会包含所有能力，并且有效能力集会被设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P&#x27;(permitted) = P(inheritable) | cap_bset</span><br><span class="line">P&#x27;(effective) = P&#x27;(permitted)</span><br></pre></td></tr></table></figure><h3 id="修改用户id对进程能力的影响">39.4 修改用户ID对进程能力的影响</h3><p>　　为了保持与用户ID为0的用户和用户ID不为0的用户之间转换的传统含义兼容，内核会在修改进程的用户ID时执行以下操作 (通过<code>setuid()</code>等函数)：</p><p>　　1) 当有效用户ID、有效用户ID或保存set-user-ID之前为0时，作为修改用户ID的结果，这些用户ID都会有非0值，并且允许能力集和有效能力集会被清空 (永久放弃所有能力)。</p><p>　　2) 当将有效用户ID从0修改为非0值时，有效能力集会被清空。</p><p>　　3) 当将有效用户ID从非0值修改为0时，允许能力集中的所有能力也会在有效能力集中被启用。</p><p>　　4) 当将文件系统用户ID从0修改为非0值时，能力<code>CAP_CHOWN</code>、<code>CAP_DAC_OVERRIDE</code>、<code>CAP_DAC_READ_SEARCH</code>、<code>CAP_FOWNER</code>、<code>CAP_FSETID</code>、<code>CAP_LINUX_IMMUTABLE</code> (Linux 2.6.30及以上版本)、<code>CAP_MAC_OVERRIDE</code>和<code>CAP_MKNOD</code> (Linux 2.6.30及以上版本) 会从有效能力集中被删除。相反，当将文件系统用户ID从非0值修改为0时，若允许能力集包括这些能力中的任意个，则包含的能力也会在有效能力集中被启用。这些行为是为了保持特定于Linux的文件系统用户ID操作的传统语义。</p><h3 id="在程序中修改进程能力">39.5 在程序中修改进程能力</h3><p>　　进程可以通过系统调用<code>capset()</code>或libcap API来获取或放弃能力 (实际上，应使用库libcap API，其中的函数提供了符合POSIX 1003.1e草案的接口以及一些Linux扩展的接口)。对进程能力的修改需遵循以下规则：</p><p>　　1) 若进程的有效能力集中没有能力<code>CAP_SETPCAP</code>，则新的可继承能力集必须是现有可继承能力集和允许能力集组合的子集。</p><p>　　2) 新的可继承能力集必须是现有可继承能力集和能力边界集组合的子集。</p><p>　　3) 新的允许能力集必须是现有允许能力集的子集。</p><p>　　4) 新的有效能力集中的能力只能是现的允许能力集中的能力。</p><p>　　使用libcap API的程序通常会执行以下步骤：</p><p>　　1) 通过函数<code>cap_get_proc()</code>来从内核中检索进程当前的能力集，并通过该函数在用户空间分配的结构体来存储结果 (或者，通过函数<code>cap_init()</code>来创建新的空能力集结构体)。在libcap API中，数据类型<code>cap_t</code>是用于引用该结构体的指针。</p><p>　　2) 通过函数<code>cap_set_flag()</code>更新用户空间结构体，以从第1步获取的用户空间结构体中存储的允许能力集、有效能力集和可继承能力集中添加 (<code>CAP_SET</code>) 或删除能力 (<code>CAP_CLEAR</code>)。</p><p>　　3) 通过函数<code>cap_set_proc()</code>来将用户空间结构体传递到内核，以修改进程能力。</p><p>　　4) 通过函数<code>cap_free()</code>释放第1步分配的结构体。</p><p>　　在撰写本书时，libcap-ng (改进的能力库API) 的开发正在进行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check_password_caps.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE   <span class="comment">/* 定义了该宏后，getpass()会被声明在unistd.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE <span class="comment">/* 定义了该宏后，crypt()会被声明在unistd.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/capability.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shadow.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 修改调用者的有效能力集中的指定能力的设置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param capability 目标能力</span></span><br><span class="line"><span class="comment"> * @param setting 设置</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">modifyCap</span><span class="params">(<span class="type">int</span> capability, <span class="type">int</span> setting)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cap_t</span> caps;</span><br><span class="line">    <span class="type">cap_value_t</span> capList[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检索调用者的当前能力 */</span></span><br><span class="line">    caps = cap_get_proc();</span><br><span class="line">    <span class="keyword">if</span> (caps == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改caps的有效集中的capability的设置 */</span></span><br><span class="line">    capList[<span class="number">0</span>] = capability;</span><br><span class="line">    <span class="keyword">if</span> (cap_set_flag(caps, CAP_EFFECTIVE, <span class="number">1</span>, capList, setting) == <span class="number">-1</span>) <span class="comment">/* 第3个参数 (1) 是数组caplist的元素数 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        cap_free(caps);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将修改后的能力集传递给内核，以修改调用者的能力 */</span></span><br><span class="line">    <span class="keyword">if</span> (cap_set_proc(caps) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cap_free(caps);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放libcap API分配的结构体 */</span></span><br><span class="line">    <span class="keyword">if</span> (cap_free(caps) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在调用者的有效能力集中添加指定能力</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param capability 目标能力</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">raiseCap</span><span class="params">(<span class="type">int</span> capability)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> modifyCap(capability, CAP_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 清空调用者的所有能力集</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dropAllCaps</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cap_t</span> empty;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line">    empty = cap_init();</span><br><span class="line">    <span class="keyword">if</span> (empty == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = cap_set_proc(empty);</span><br><span class="line">    <span class="keyword">if</span> (cap_free(empty) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *username, *password, *encrypted, *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spwd</span> *<span class="title">spwd</span>;</span></span><br><span class="line">    Boolean authOk;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">long</span> lnmax;</span><br><span class="line"></span><br><span class="line">    lnmax = sysconf(_SC_LOGIN_NAME_MAX);</span><br><span class="line">    <span class="keyword">if</span> (lnmax == <span class="number">-1</span>) <span class="comment">/* 若无法获取用户名长度上限 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        lnmax = <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    username = <span class="built_in">malloc</span>(lnmax);</span><br><span class="line">    <span class="keyword">if</span> (username == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Username: &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> (fgets(username, lnmax, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">strlen</span>(username);</span><br><span class="line">    <span class="keyword">if</span> (username[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        username[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 删除结尾的\n */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pwd = getpwnam(username);</span><br><span class="line">    <span class="keyword">if</span> (pwd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;couldn&#x27;t get password record&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取能力CAP_DAC_READ_SEARCH (因为仅需要该该能力) */</span></span><br><span class="line">    <span class="keyword">if</span> (raiseCap(CAP_DAC_READ_SEARCH) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;raiseCap() failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spwd = getspnam(username);</span><br><span class="line">    <span class="keyword">if</span> (spwd == <span class="literal">NULL</span> &amp;&amp; errno == EACCES)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;no permission to read shadow password file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此时，不再需要任何能力，所以清空所有能力集 */</span></span><br><span class="line">    <span class="keyword">if</span> (dropAllCaps() == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;dropAllCaps() failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若检索到影子密码记录，则使用影子密码 */</span></span><br><span class="line">    <span class="keyword">if</span> (spwd != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pwd-&gt;pw_passwd = spwd-&gt;sp_pwdp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 加密密码并立即清除密码明文 */</span></span><br><span class="line">    password = getpass(<span class="string">&quot;Password: &quot;</span>);</span><br><span class="line">    encrypted = crypt(password, pwd-&gt;pw_passwd);</span><br><span class="line">    <span class="keyword">for</span> (p = password; *p != <span class="string">&#x27;\0&#x27;</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        *p++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encrypted == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;crypt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    authOk = <span class="built_in">strcmp</span>(encrypted, pwd-&gt;pw_passwd) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!authOk)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Incorrect password\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Successfully authenticated: UID=%ld\n&quot;</span>, (<span class="type">long</span>)pwd-&gt;pw_uid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行认证完成后的操作 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　 这个示例是8.4中的<code>check_password.c</code>的修改版，这里使用了能力和libcap API。为了以普通用户读取影子密码文件，需要绕过标准文件权限检查，即能力<code>CAP_DAC_READ_SEARCH</code>。该程序会在读取影子密码文件之前将该能力添加到有效能力集，并在读取完成后立即放弃该能力。为了能够让非特权用户调用该程序，必须将该能力添加到文件的允许能力集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">setcap</span> <span class="string">&quot;cap_dac_read_search=p&quot;</span> check_password_caps</span></span><br><span class="line">root&#x27;s password:</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">getcap</span> check_password_caps</span></span><br><span class="line">check_password_caps = cap_dac_read_search+p</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./check_password_caps</span></span><br><span class="line">Username: mtk</span><br><span class="line">Password:</span><br><span class="line">Successfully authenticated: UID=1000</span><br></pre></td></tr></table></figure><h3 id="创建完全基于能力的环境">39.6 创建完全基于能力的环境</h3><p>　　对于完全基于能力的系统，内核无需对root执行特殊处理 (见39.4)。set-user-ID-root程序也就不复存在，并且文件能力将用于授予程序所需的最少能力。</p><p>　　现有应用程序并未被设计为使用文件能力机制，所以内核必须保持对用户ID为0的进程的传统处理方式。尽管如此，有时可能需要让应用程序运行在完全基于能力的环境。从内核2.6.26开始，若在内核中启用了文件能力，则Linux会提供securebits机制，该机制会控制一系列线程级标志，这些标志可以启用或禁用对root的3种特殊处理。</p><p>　　securebits机制由3个基础标志和3个对应的锁定标志组成。每个基础标志控制1种root的特殊处理。设置对应的锁定标志是一次性操作，可防止对对应的基础标志进行进一步修改——一旦被设置，锁定标志就无法被取消。</p><table><colgroup><col style="width:34%"><col style="width:65%"></colgroup><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td><code>SECBIT_KEEP_CAPS</code></td><td>当设置了该标志后，至少有1个用户ID为0的进程的所有用户ID都被修改为非0值时不会清空允许能力集。该标志仅在未设置标志<code>SECBIT_NO_SETUID_FIXUP</code>时生效。该标志在执行<code>exec()</code>时会被清除。</td></tr><tr><td><code>SECBIT_NO_SETUID_FIXUP</code></td><td>当设置了该标志后，进程的有效或文件系统用户ID在0和非0值之间切换时不会修改其能力。</td></tr><tr><td><code>SECBIT_NOROOT</code></td><td>当设置了该标志后，实际或有效用户ID为0的进程调用<code>exec()</code>或进程执行set-user-ID-root程序时不会授予该进程能力 (除非可执行文件有文件能力)。</td></tr><tr><td><code>SECBIT_KEEP_CAPS_LOCKED</code></td><td>锁定<code>SECBIT_KEEP_CAPS</code>。</td></tr><tr><td><code>SECBIT_NO_SETUID_FIXUP_LOCKED</code></td><td>锁定<code>SECBIT_NO_SETUID_FIXUP</code>。</td></tr><tr><td><code>SECBIT_NOROOT_LOCKED</code></td><td>锁定<code>SECBIT_NOROOT</code>。</td></tr></tbody></table><p>　　通过<code>fork()</code>创建的子进程会继承父进程中调用<code>fork()</code>的线程的securebits标志。所有securebits标志的设置在<code>exec()</code>期间会被保留，除了<code>SECBIT_KEEP_CAPS</code>。</p><p>　　进程可以通过<code>prctl()</code>的操作<code>PR_GET_SECUREBITS</code>检索securebits标志。完全基于能力的应用程序可以通过以下调用来不可逆地禁用调用进程及其所有子进程的的root特殊处理 (调用进程及其所有子进程随后只能通过执行拥有文件能力的程序来获得能力)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prctl(PR_SET_SECUREBITS,</span><br><span class="line">          SECBIT_NO_SETUID_FIXUP | SECBIT_NO_SETUID_FIXUP_LOCKED |</span><br><span class="line">              SECBIT_NOROOT | SECBIT_NOROOT_LOCKED) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;prctl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　标志<code>SECBIT_KEEP_CAPS</code>提供的功能约等于<code>SECBIT_NO_SETUID_FIXUP</code>的一半。<code>SECBIT_KEEP_CAPS</code>的存在是为了与较旧的<code>prctl()</code>的操作<code>PR_SET_KEEPCAPS</code>对应，该操作的功能与<code>SECBIT_KEEP_CAPS</code>的相同 (两者唯一的区别是进程无需能力<code>CAP_SETPCAP</code>就可以使用<code>prctl()</code>的操作<code>PR_SET_KEEPCAPS</code>)。</p><p>　　<code>exec()</code>期间清除标志<code>SECBIT_KEEP_CAPS</code>也是为了与<code>prctl()</code>的操作<code>PR_SET_KEEPCAPS</code>所设置的属性的处理保持一致。</p><p>　　<code>prctl()</code>的操作<code>PR_SET_KEEPCAPS</code>旨在供运行在不支持文件能力的旧内核上的set-user-ID-root程序使用。</p><p>　　即使set-user-ID-root程序放弃它所不需要的所有能力，它仍然保留2个特权：访问root所有的文件的特权和通过执行程序重新获取能力的特权。放弃这2个特权的唯一方式是将其所有用户ID都设置为非0值。但是，这样做通常会导致清空允许能力集和有效能力集。这违背了初衷，即在与永久将用户ID修改为非0值的情况下保留部分能力。为此，<code>prctl()</code>的操作<code>PR_SET_KEEPCAPS</code>可用于在将所有用户ID修改为非0值时防止允许能力集被清空 (进程的有效能力集在这种情况下总是会被清空)。</p><h3 id="不支持文件能力的旧内核和系统">39.7 不支持文件能力的旧内核和系统</h3><p>　　尽管Linux从内核2.2开始支持能力并允许将其附加到进程，但文件能力的实现直到后几年才出现。文件能力长时间未实现更多是政策考量，而非技术难题 (内核2.6就已经支持用于实现文件能力的扩展属性)。内核开发者普遍认为系统管理者应该为每个特权程序设置和监控不同的能力集，但这会导致无法管理的复杂管理任务。相比之下，系统管理员熟悉现有UNIX权限模型，知道应该谨慎对待set-user-ID程序，并能通过命令<code>find</code>定位set-user-ID和set-group-ID程序。尽管如此，文件能力的开发者仍然提出了在管理上可行的论点，并最终提供了足以令人信服的理由，使文件能力得以集成到内核中。</p><p>　　对于不支持文件能力的内核 (即2.6.24之前以及从2.6.24开始的文件能力被禁用的内核)，能力<code>CAP_SETPCAP</code>的语义有所不同。受到类似于39.5中的规则的限制，从理论角度，有效能力集中包含该能力的进程可以修改除自身和<code>init</code>之外的所有进程的能力 (不能修改<code>init</code>的能力是因为该进程对系统的运行至关重要)。</p><p>　　从内核2.6.25开始，能力边界集成为了线程级属性。但是，对于较旧的内核，能力边界集是会影响所有进程的系统级属性，而系统级能力边界集总是会屏蔽能力<code>CAP_SETPCAP</code>。</p><p>　　对于2.6.25之后的内核，只有在内核中启用文件能力后，才能从线程级能力边界集中删除能力。在这种情况下，进程<code>init</code>以包含所有能力的能力边界集启动，并且系统创建的其他进程也会继承该能力边界集。若文件能力被禁用，则进程<code>init</code>的能力边界集会因能力<code>CAP_SETPCAP</code>的语义而不包含该能力。</p><p>　　系统级能力边界集可以通过特定于Linux的文件<code>/proc/sys/kernel/cap-bound</code>访问。进程修改该文件需要能力<code>CAP_SYS_MODULE</code>。但是，只有进程<code>init</code>才能启用该掩码中的位，其他进程只能禁用该掩码中的位。这些限制的结果是不支持文件能力的系统中的进程无法获取能力<code>CAP_SETPCAP</code>。这是合理的，因为该能力可用于破坏整个内核权限检查系统 (在这种情况下，若需要授予技能能力<code>CAP_SETPCAP</code>，则必须加载会修改能力集的内核模块并修改程序<code>init</code>的源码，或者修改内核源代码中的能力边界集初始化部分并重新编译内核)。</p><p>　　尽管系统级能力边界集是位掩码，但在文件<code>cap-bound</code>中表示为有符号十进制数 (例如，若该文件的初始值为-257，其二进制补码表示为11111111 11111111 11111110 11111111，则能力<code>CAP_SETPCAP</code>的值为8)。</p><p>　　对于不支持文件能力的系统，还是可以通过能力来提高程序的安全性。具体步骤如下：</p><p>　　1) 以有效用户ID为0的进程运行程序 (set-user-ID-root程序)。该进程的允许能力集和有效能力集通常会包含所有能力。</p><p>　　2) 程序启动时通过libcap API清空有效能力集并从允许能力集中删除所需能力之外的所有能力。</p><p>　　3) 设置标志<code>SECBIT_KEEP_CAPS</code>。</p><p>　　4) 将进程的所有用户ID设置为非0值，以防止进程访问root所有的文件或通过<code>exec()</code>获取能力。</p><p>　　5) 在程序的剩余生命周期内，通过libcap API来获取和放弃能力来执行任务。</p><p>　　若进程需要访问root所有的文件，则可以将第4和5步合并为设置标志<code>SECBIT_NOROOT</code>。</p><p>　　对于那些反对可执行文件的能力实现的内核开发者，这里介绍的方法的优点之一是应用程序开发者可以清楚地知道可执行文件需要那些能力。相比之下，系统管理者可能难以获取这些信息。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_38/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第38章 编写安全特权程序"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第38章 编写安全特权程序</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_40/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第40章 登录统计">《Linux/UNIX系统编程手册》第40章 登录统计 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>