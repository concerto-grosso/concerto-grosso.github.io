<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_38/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_38/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_38/","title":"《Linux/UNIX系统编程手册》第38章 编写安全特权程序"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第38章 编写安全特权程序 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C"><span class="nav-text">38.1 以最小权限运行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%85%E5%9C%A8%E9%9C%80%E8%A6%81%E6%97%B6%E8%8E%B7%E5%8F%96%E7%89%B9%E6%9D%83"><span class="nav-text">38.1.1 仅在需要时获取特权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%86%8D%E9%9C%80%E8%A6%81%E7%89%B9%E6%9D%83%E6%97%B6%E6%B0%B8%E4%B9%85%E6%94%BE%E5%BC%83%E7%89%B9%E6%9D%83"><span class="nav-text">38.1.2 不再需要特权时永久放弃特权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E4%BF%AE%E6%94%B9%E8%BF%9B%E7%A8%8B%E5%87%AD%E8%AF%81%E7%9A%84%E8%A6%81%E7%82%B9"><span class="nav-text">38.1.3 关于修改进程凭证的要点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">38.2 执行程序时的注意点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E8%BF%9B%E7%A8%8B"><span class="nav-text">38.3 限制进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E5%BF%83%E4%BF%A1%E5%8F%B7%E5%92%8C%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="nav-text">38.4 小心信号和竞争条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%96%87%E4%BB%B6io%E6%97%B6%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-text">38.5 执行文件操作和文件I&#x2F;O时的陷阱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E7%9B%B8%E4%BF%A1%E8%BE%93%E5%85%A5%E5%92%8C%E7%8E%AF%E5%A2%83"><span class="nav-text">38.6 不要相信输入和环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E5%BF%83%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="nav-text">38.7 小心缓冲区溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E5%BF%83%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB"><span class="nav-text">37.8 小心拒绝服务攻击</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_38/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第38章 编写安全特权程序 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第38章 编写安全特权程序</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-11-13 00:00:00" itemprop="dateCreated datePublished" datetime="2025-11-13T00:00:00+08:00">2025-11-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-11-14 00:00:00" itemprop="dateModified" datetime="2025-11-14T00:00:00+08:00">2025-11-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.5k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　特权程序可以访问普通用户无法访问的特性和资源 (例如，文件和设备)。程序可以通过2种方式获取特权：</p><p>　　● 程序以特权用户ID启动 (例如，以root运行的守护进程和网络服务器)。</p><p>　　● 程序的set-user-ID或set-group-ID权限位已被设置。当执行set-user-ID (set-group-ID) 程序时，该程序会将进程的有效用户 (组) ID修改为该程序的所有者 (所属组)。</p><p>　　若特权程序存在漏洞或可以被恶意用户破坏，则系统或应用程序安全性可能受到威胁。因此，应该尽可能地避免将程序设计为特权程序。</p><p>　　有时，可以将需要特权的功能隔离到1个执行单一任务的程序中，并在需要时在子进程中执行该程序。这种方式对库很有用。</p><p>　　即使需要使用set-user-ID (set-group-ID) 程序，也不一定需要为set-user-ID (set-group-ID) 程序提供root凭证。若为进程提供其他凭证就足够了，则应该优先选择这些凭证，因为root权限可能导致漏洞。</p><p>　　当set-user-ID程序需要允许用户更新它们没有写权限的文件时，更安全的实现方法是为该程序创建1个专用的组账号 (组ID)，将文件的所属组修改为该组 (并使文件对该组可写)，然后编写1个set-group-ID程序来将进程的有效组ID设置该组的ID。</p><p>　　Linux默认不允许set-user-ID程序生成核心转储文件来响应信号，即使该程序已经放弃特权。但是，并非所有UNIX实现都提供了该安全特性。</p><span id="more"></span><p>　　当程序读取密码或其他敏感信息时，应该在执行所需的处理后立即从内存中删除这些信息。将这些信息留在内存存在安全风险，原因如下：</p><p>　　● 包含数据的虚拟内存页可能被换出 (除非使用<code>mlock()</code>等函数锁定在内存中)，然后特权程序可以在交换区域读取其中的数据。</p><p>　　● 当进程收到的信号会导致核心转储文件的生成时，可以通过读取核心转储文件来获取信息。</p><p>　　安全程序通常应该避免核心转储文件的生成，以防止其中的敏感信息被读取。程序可以通过<code>setrlimit()</code>将资源限制<code>RLIMIT_CORE</code>设置为0来实现这一点。</p><p>　　特权程序应该始终检查系统调用和库函数是否成功以及返回值是否符合预期 (这对所有程序都是如此，但对特权程序尤其重要)。很多系统调用都可能出错，即使程序以root凭证运行 (例如，<code>fork()</code>会因达到系统级进程数量限制而出错，对只读文件系统上的文件进行写入的<code>open()</code>调用会出错以及<code>chdir()</code>在目标目录不存在时会出错)。</p><p>　　即使系统调用成功，也可能需要检查其结果 (例如，在重要情况下，特权程序应检查<code>open()</code>调用是否返回了标准文件描述符之一)。</p><p>　　若特权程序遇到意外情况，通常应该终止程序 (若是服务器，则丢弃客户端请求)，因为尝试处理意外情况通常需要做出一些假设，而这些假设在某些情况下可能并不合理，甚至可能导致安全漏洞。</p><h3 id="以最小权限运行">38.1 以最小权限运行</h3><p>　　set-user-ID (set-group-ID) 程序只需要执行特定操作的权限。当它执行其他任务时，应该禁用特权。换句话说，程序应该以完成任务所需的<span style="background-color:#ff0">最小特权</span>运行，保存的set-user-ID (set-group-ID) 正是用于该目的 (见9.2)。</p><h4 id="仅在需要时获取特权">38.1.1 仅在需要时获取特权</h4><p>　　对于set-user-ID程序，可以在通过以下顺序调用<code>seteuid()</code>来临时放弃特权，然后再次获取特权：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uid_t</span> orig_euid;</span><br><span class="line"></span><br><span class="line">orig_euid = geteuid();</span><br><span class="line"><span class="keyword">if</span> (seteuid(getuid()) == <span class="number">-1</span>) <span class="comment">/* 临时放弃特权 */</span></span><br><span class="line">&#123;</span><br><span class="line">  errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行不需要特权的任务 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (seteuid(orig_euid) == <span class="number">-1</span>) <span class="comment">/* 重新获取特权 */</span></span><br><span class="line">&#123;</span><br><span class="line">  errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行需要特权的任务 */</span></span><br></pre></td></tr></table></figure><p>　　第1次调用<code>seteuid()</code>会将调用进程的有效用户ID修改为其实际用户ID。第2次调用<code>seteuid()</code>会将有效用户ID恢复为保存的set-user-ID。</p><p>　　对于set-group-ID程序，保存的set-group-ID会存储程序的初始有效组ID，<code>setegid()</code>可用于放弃和重新获取特权。</p><p>　　最安全的做法是在程序启动时立即放弃特权，然后在程序需要特权时临时获取特权。当程序不再需要特权时，通过修改保存的set-user-ID来永久放弃特权。</p><h4 id="不再需要特权时永久放弃特权">38.1.2 不再需要特权时永久放弃特权</h4><p>　　当set-user-ID (set-group-ID) 程序完成所有需要特权的任务后，应该永久放弃特权，以消除因程序漏洞或其他意外行为而产生的安全风险。永久放弃特权通过将进程的所有用户 (组) ID修改为其实际用户 (组) ID完成。</p><p>　　对于set-user-ID-root程序，可以通过以下代码来永久放弃特权：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (setuid(getuid()) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;setuid&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但是，当调用进程的有效用户ID不为0时，<code>setuid()</code>只会修改有效用户ID (见9.4.1.2)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始值: real=1000 effective=0 saved=0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 临时放弃特权 */</span></span><br><span class="line">orig_euid = geteuid();</span><br><span class="line"><span class="keyword">if</span> (seteuid(getuid() == <span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改后: real=1000 effective=1000 saved=0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 试图永久放弃特权 (错误) */</span></span><br><span class="line"><span class="keyword">if</span> (setuid(getuid() == <span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;setuid&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UID不变: real=1000 effective=1000 saved=0 */</span></span><br></pre></td></tr></table></figure><p>　　相反，这里需要重新获取特权来永久放弃特权，即在第1步和第2步之间插入以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (seteuid(orig_euid) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于set-user-ID程序，<code>setuid()</code>不足以修改保存的set-user-ID，所以必须通过<code>setreuid()</code>或<code>setresuid()</code>来永久放弃特权：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (setreuid(getuid(), getuid()) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;setreuid&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段代码依赖于<code>setreuid()</code>的Linux实现的特性：若第1个参数 (<code>ruid</code>) 不为-1，则保存的set-user-ID也会被设置为有效用户ID的新值。SUSv3没有说明该特性，但很多其他实现都提供了该特性。</p><h4 id="关于修改进程凭证的要点">38.1.3 关于修改进程凭证的要点</h4><p>　　某些会修改进程凭证的系统调用的语义因系统而异，其中的部分系统调用的语义甚至因调用者是否拥有特权而异。Dan Tsafrir等人的《Portably Solving File TOCTTOU Races with Hardness Amplification》推荐应用程序使用特定于系统的非标准系统调用来修改进程凭证，因为在很多情况下，这些非标准系统调用提供了比对应的标准系统调用更简单、更一致的语义 (例如，Linux的<code>setresuid()</code>和<code>setresgid()</code>)。尽管并非所有系统都提供了这些系统调用，但这些系统调用更不容易出错。</p><p>　　对于Linux，即使调用者的有效用户ID为0，修改凭证的系统调用也可能因程序已经显式地修改了其能力而不会按照预期运行 (例如，对进程用户ID的修改可能因能力<code>CAP_SETUID</code>被禁用而出错)。</p><p>　　因此，强烈建议<span style="background-color:#ff0">不仅检查修改凭证的系统调用是否成功，还要验证凭证是否已被修改为预期值</span>。当需要通过<code>seteuid()</code>临时放弃特权时，应该在调用该函数后调用<code>geteuid()</code>来验证有效用户ID是否为预期值。同样，当需要永久放弃特权时，应该在调用对应的函数后验证实际用户ID、有效用户ID以及保存的set-user-ID是否为非特权用户ID。但是，标准系统调用只能检索实际ID和有效ID，无法检索保存的set-user-ID或set-group-ID。Linux和有些UNIX提供了用于该目的<code>getresuid()</code>和<code>getresgid()</code>；对于其他系统，则需要通过解析文件<code>/proc</code>的信息等方法。</p><p>　　有些凭证只能被有效用户ID为0的进程修改，所以当修改多个ID (包括辅助组ID、组ID和用户ID) 时，应该在放弃特权ID时最后修改有效用户ID。相反地，当提升特权ID时，应该最先提升特权有效用户ID。</p><h3 id="执行程序时的注意点">38.2 执行程序时的注意点</h3><p>　　若set-user-ID (set-group-ID) 程序会执行其他程序，则应该在执行新程序之前将进程的所有用户 (组) ID修改为实际用户 (组) ID，以确保新程序不会带有特权启动，并且无法获取特权。除了38.1介绍的方法之外，还可以在<code>exec()</code>之前调用<code>setuid(getuid())</code>来达到相同的效果。<code>setuid()</code>在有效用户ID不为0时只会修改有效用户ID，但成功的<code>exec()</code>调用会将有效用户ID复制给保存的set-user-ID (若<code>exec()</code>出错，则保持不变)。类似的方法可以用于设置保存的set-group-ID，因为成功的<code>exec()</code>调用也会将有效组ID复制给保存的set-group-ID。</p><p>　　处于用户控制下的特权程序不应该直接或间接 (通过<code>system()</code>、<code>popen()</code>、<code>execlp()</code>和<code>execvp()</code>等函数) 执行shell。shell (以及<code>awk</code>等不受限制的解释器) 的复杂性和功能意味着，即使被执行的shell不允许交互访问，也几乎不可能消除所有安全漏洞。即使需要执行shell，也应该在执行shell之前永久放弃特权。</p><p>　　对于有些UNIX实现，脚本的set-user-ID和set-group-ID权限位也会生效，以便执行脚本时执行脚本的进程会假定为其他用户 (特权) 的身份。因为这会带来安全风险，所以Linux和其他某些UNIX实现会无视脚本的这2个权限位。</p><p>　　在默认情况下，文件描述符会在<code>exec()</code>期间保持打开。特权进程可以打开普通进程无法访问的文件，结果文件描述符代表特权资源。在<code>exec()</code>之前，应该关闭这些文件描述符，以防止新程序访问与之关联的文件。这可以通过显式关闭文件描述符或设置close-on-exec标志完成。</p><h3 id="限制进程">38.3 限制进程</h3><p>　　Linux的能力机制将传统的 "要么拥有所有特权，要么失去所有特权" 的UNIX权限机制划分为称为<strong>能力</strong>的独立单位。进程可以启用或禁用单个能力。通过仅启用那些所需的能力，程序运行所需的权限比以完全root权限运行时更少。这样可以降低程序遭到入侵后造成的破坏。</p><p>　　此外，通过使用能力和securebits标志，可以创建权限有限的非root所有的进程 (所有用户ID都不为0)。这样的进程无法在通过<code>exec()</code>来获取所有能力。</p><p>　　在某些情况下，可以通过创建chroot jail来限制程序可访问的目录和文件集 (需要同时调用<code>chdir()</code>来将进程的当前工作目录修改为jail中的位置)。但是，chroot jail不足以限制set-user-ID-root程序 (见18.11)。</p><p>　　虚拟服务器可以作为chroot jail的替代方法。虚拟服务器是在虚拟内核上实现的服务器。每个虚拟内核都与运行在同一硬件上的其他虚拟内核隔离，所以虚拟服务器比chroot jail更安全、更灵活 (其他一些现代操作系统也提供了各自的虚拟服务器实现)。Linux上最早的虚拟化实现是用户模式Linux (UML)，它是2.6内核的标准组成部分。</p><h3 id="小心信号和竞争条件">38.4 小心信号和竞争条件</h3><p>　　用户可以向其启动的set-user-ID程序发送任意信号。这些信号可能在随时到达，所以需要考虑信号在程序执行时到达而导致的竞争条件。若信号到达的时间合适，则信号应该会被捕获、阻塞或忽略，以防止可能的安全问题。此外，信号处理函数的设计应该尽可能精简，以减少意外产生竞争条件的风险。</p><p>　　这个问题与停止进程的信号 (例如，<code>SIGTSTP</code>和<code>SIGSTOP</code>) 尤为相关。考虑以下问题场景：</p><p>　　1) set-user-ID程序获取关于其运行时环境的某些信息。</p><p>　　2) 用户试图停止正在运行程序的进程，并修改运行时环境的细节。这些修改可能包括修改文件的权限位、修改符号链接的目标文件或删除程序依赖的文件。</p><p>　　3) 用户通过信号<code>SIGCONT</code>恢复进程。此时，程序会基于对运行时环境的错误假设继续执行，而这些假设可能会导致安全漏洞。</p><p>　　该场景实际上只是time of check to time of use (TOCTTOU) 竞争条件的特例之一。特权进程应该避免基于可能已失效的先前验证结果的操作。即使用户无法向进程发送信号，该准则依然适用。用户停止进程的能力仅仅允许用户延长检查时间与使用时间之间的间隔。</p><p>　　虽然在检查时间和使用时间之间仅通过单次尝试来停止进程比较困难，但恶意用户可以反复执行set-user-ID程序，并使用其他程序或shell脚本反复向其发送停止信号，从而修改运行时环境。这可以大大增加篡改set-user-ID程序设置的可能性。</p><h3 id="执行文件操作和文件io时的陷阱">38.5 执行文件操作和文件I/O时的陷阱</h3><p>　　当特权进程需要创建文件时，应该注意该文件的所有权和权限，以确保该文件在任何时刻都不会有被恶意操作的风险，即使只是短暂的瞬间。</p><p>　　● 进程umask应该被设置为可以确保进程不会创建公开可写的文件的值，防止这些文件被恶意用户修改。</p><p>　　● 因为文件的用户ID取自创建进程的有效用户ID，所以可能需要谨慎地使用<code>seteuid()</code>或<code>setreuid()</code>来临时修改进程凭证，以确保新文件不属于错误的用户。文件的组ID可能取自创建进程的有效组ID，set-group-ID程序也可能会出现类似的情况，所以也需要对组ID执行类似的操作 (对于Linux，新文件的所有者由进程的文件系统ID决定，该ID通常与进程的有效用户ID相同)。</p><p>　　● 当set-user-ID-root程序需要创建最初由自己所有但最终由其他用户所有的文件时，新文件应该以不允许其他用户写入的方式创建，这可以通过在调用<code>open()</code>时使用合适的参数或在调用<code>open()</code>之前设置进程的umask来完成。随后，程序可以通过<code>fchown()</code>修改其所有权，若有必要，还可以通过<code>fchown()</code>修改其权限。关键是set-user-ID程序应该确保它永远不会创建由程序所有者所有且其他用户拥有 (短暂) 写入权限的文件。</p><p>　　● 应该对打开的文件描述符进行文件属性检查 (例如，<code>open()</code>后跟<code>fstat()</code>) ，而不是检查与路径名关联的属性，然后在打开文件 (例如，<code>stat()</code>后跟<code>open()</code>)，因为后者会导致TOCTTOU问题。</p><p>　　● 若程序需要确保它是文件的创建者，则调用<code>open()</code>时应该使用标志<code>O_EXCL</code>。</p><p>　　● 特权程序应该避免创建或依赖公共可写目录 (例如，<code>/tmp</code>) 下的文件，因为这会让程序容易受到恶意创建特权程序预期名称的未授权文件的攻击。若程序必须在公共可写目录下创建文件，则至少应该使用<code>mktemp()</code>等函数来确保文件名不可预测。</p><h3 id="不要相信输入和环境">38.6 不要相信输入和环境</h3><p>　　set-user-ID和set-group-ID程序不应该假设环境变量的值是可靠的，尤其是<code>PATH</code>和<code>IFS</code>。</p><p>　　● <code>PATH</code>决定shell (包括<code>system()</code>和<code>popen()</code>) 以及<code>execlp()</code>和<code>execvp()</code>搜索程序的位置。恶意用户可以将该环境变量设置为某个值，从而欺骗使用这些函数之一的set-user-ID程序以特权执行这些程序。若需要使用这些函数，则应该将<code>PATH</code>设置为受信任的目录列表 (更好的做法是在执行程序时指定绝对路径名)。但是，如前所述，最好在执行shell或使用这些函数之前放弃特权。</p><p>　　● <code>IFS</code>决定shell分隔命令行单词的分隔符。该环境变量应该被设置为空字符串 (表示只会将空格作为单词分隔符)。某些shell会在启动时以这种方式设置<code>IFS</code>。</p><p>　　有时，最安全的做法可能是先清空环境列表，然后使用已知安全的值恢复特定的环境变量，尤其是在执行其他程序或调用可能受环境变量影响的库时。</p><p>　　特权程序在根据所有来自不可信来源的输入采取行动之前，应该仔细验证这些输入 (可能包括验证数字是否在可接受的范围内、字符串的长度是否超出范围以及字符串是否包含非法字符)。可能需要以这种方式验证的输入包括来自用户创建的文件、命令行参数、交换输入、CGI输入、电子邮件消息、环境变量、不受信任的用户可访问的IPC通道和网络分组的输入。</p><p>　　set-user-ID程序应该避免对其初始运行时环境做出不可靠的假设 (例如，标准输入、输出或错误已被关闭。在这种情况下，打开文件时可能意外地重用文件描述符1，从而让程序错误地认为它在向标准输入写入)。此外，还有很多其他可能性需要考虑。以资源限制为例，进程可能会耗尽资源限制，从而导致各种系统调用出错或生成各种信号。恶意用户可能会试图通过耗尽资源来破坏程序。</p><h3 id="小心缓冲区溢出">38.7 小心缓冲区溢出</h3><p>　　注意缓冲区溢出，即输入值或复制的字符串超出分配的缓冲区。切勿使用<code>get()</code>，并且谨慎使用<code>scanf()</code>、<code>sprintf()</code>、<code>strcpy()</code>和<code>strcat()</code>等函数 (例如，通过<code>if</code>语句来防止缓冲区溢出)。</p><p>　　缓冲区溢出会为<span style="background-color:#ff0">栈崩溃</span> (也称为<span style="background-color:#ff0">栈粉碎</span>) 等攻击敞开大门，恶意用户利用缓冲区溢出将精心编码的字节放入栈中，以强制特权程序执行任意代码。缓冲区溢出可能是计算机系统安全漏洞最常见的单一来源，CERT和Bugtrap发布的公告就证明了这一点。缓冲区溢出对网络服务器尤其危险，因为它会使系统暴露于网络上的任何地方的远程攻击。</p><p>　　为了增加栈崩溃的难度 (尤其是对网络服务器的远程攻击)，从内核2.6.12开始，Linux实现了<span style="background-color:#ff0">地址空间布局随机化</span> (ASLR)，该技术会在虚拟内存顶部8MB范围内随机改变栈的位置。此外，若软<code>RLIMIT_STACK</code>限制不为无穷大，并且特定于Linux的文件<code>/proc/sys/vm/legacy_va_layout</code>包含值0，则内存映射的位置也可能随机化。</p><p>　　较新的x86-32架构提供了可以将页表标记为NX (禁止执行) 的硬件支持。该特性可用于防止执行栈上的程序代码，从而增加栈崩溃的难度。</p><p>　　此外，上述函数都有安全的替代函数 (例如，<code>snprintf()</code>、<code>strncpy()</code>和<code>strncat()</code>)，允许指定待复制数据的最大字符数。</p><p>　　● 对于这些替代函数中的大多数函数，若达到了指定的最大值，则源字符串的截断版本将会被放入目标缓冲区。因为截断的字符串在程序语义上可能没有意义，所以调用者必须检查是否发生了截断，并采取合适的措施。</p><p>　　● 使用<code>strncpy()</code>可能会影响性能。若在调用<code>strncpy(s1, s2, n)</code>时<code>s2</code>的长度小于<code>n</code>，则会向<code>s1</code>填充空字节来确保总共写入<code>n</code>个字节。</p><p>　　● 若<code>strncpy()</code>的最大长度不足以容纳结尾的字符<code>\0</code>，则目标字符不会包含字符<code>\0</code>。</p><p>　　有些UNIX实现提供了函数<code>strlcpy()</code>。给定长度参数<code>n</code>，该函数会复制最多<code>n - 1</code>个字节到目标缓冲区，并且总是会在结尾加上字符<code>\0</code>。但是，SUSv3没有说明该函数，glibc也没有实现该函数。此外，当调用者没有仔细检查字符串长度时，该函数只是将缓冲区溢出的问题替换为静默丢弃数据的问题。</p><h3 id="小心拒绝服务攻击">37.8 小心拒绝服务攻击</h3><p>　　随着基于互联网的服务的普及，远程拒绝服务攻击的机会也相应增加。这种攻击会通过向服务器发送导致崩溃的格式错误的数据或伪造大量请求来使其过载，从而让服务器无法服务客户端。</p><p>　　处理格式错误的请求很简单——服务器应该被设计为严格检查其输入以避免缓冲区溢出。</p><p>　　过载攻击更难以处理。因为服务器无法控制远程客户端的行为或客户端发送请求的频率，所以通常无法防止此类攻击 (服务器可能甚至无法确定攻击的真正来源，因为网络分组的源IP地址可以被伪造。此外，分布式攻击可能会利用不知情的中间主机来攻击目标系统)。尽管如此，还是应该采取各种措施来最小化过载攻击的风险和后果：</p><p>　　● 服务器应该进行负载限制，在负载超过预设限制时丢弃请求。这会丢弃一些合法请求，但可以防止服务器和主机过载。使用资源限制和磁盘配额也有助于限制负载。</p><p>　　● 服务器应该对客户端的通信设置超时时间，防止服务器无期限地等待客户端。</p><p>　　● 服务器应该被设计为面对意外负载时不会崩溃 (例如，严格执行边界检查，确保过多的请求不会导致数据结构溢出)。</p><p>　　● 数据结构的设计应该避免算法复杂度攻击 (例如，二叉树可能是平衡的，并且在典型负载下能够提供可以接受的性能。但是，攻击者可以特殊的输入序列来让二叉树不平衡，从而影响性能)。</p><p>　　本地拒绝服务攻击是可能发生的。最常见的例子是用户运行简单的fork炸弹 (不断创建子进程的程序)。但是，本地拒绝服务攻击的来源更容易确定，而且可以通过适当的物理和密码措施来应对。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_37/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第37章 守护进程"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第37章 守护进程</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_39/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第39章 能力">《Linux/UNIX系统编程手册》第39章 能力 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>