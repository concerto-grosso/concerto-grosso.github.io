<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_37/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_37/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_37/","title":"《Linux/UNIX系统编程手册》第37章 守护进程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第37章 守护进程 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-text">37.1 创建守护进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BF%A1%E5%8F%B7sighup%E9%87%8D%E6%96%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-text">37.2 通过信号SIGHUP重新初始化守护进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8syslog%E8%AE%B0%E5%BD%95%E6%B6%88%E6%81%AF%E5%92%8C%E9%94%99%E8%AF%AF"><span class="nav-text">37.3 使用syslog记录消息和错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#syslog-api"><span class="nav-text">37.3.1 syslog API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#openlog"><span class="nav-text">37.3.1.1 openlog()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#syslog"><span class="nav-text">37.3.1.2 syslog()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#closelog"><span class="nav-text">37.3.1.3 closelog()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#setlogmask"><span class="nav-text">37.3.1.4 setlogmask()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6etcsyslog.conf"><span class="nav-text">37.3.2 文件&#x2F;etc&#x2F;syslog.conf</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_37/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第37章 守护进程 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第37章 守护进程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-11-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-11-01T00:00:00+08:00">2025-11-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-11-02 00:00:00" itemprop="dateModified" datetime="2025-11-02T00:00:00+08:00">2025-11-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>14k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　守护进程是带有以下特征的进程：</p><p>　　● 通常，守护进程在系统启动时被创建，并且一直运行，直到关机。</p><p>　　● 守护进程运行在后台，并且没有控制终端。因此，内核不会为守护进程生成作业控制或终端相关信号。</p><p>　　守护进程旨在执行特定任务，以下示例说明了这一点：</p><p>　　● <code>cron</code>：按预定时间执行命令的守护进程。</p><p>　　● <code>sshd</code>：安全shell守护进程，允许远程主机通过安全通信协议登录。</p><p>　　● <code>httpd</code>：HTTP服务器守护进程 (Apache)，用于服务网页。</p><p>　　● <code>inetd</code>：互联网超级服务器守护进程，它会监听指定TCP/IP端口的传入网络连接，并启动合适的服务器程序来处理这些连接。</p><p>　　很多标准守护进程都是以特权进程 (有效用户ID为0) 运行。按照惯例，守护进程的名称以字母<code>d</code>结尾 (但并非普遍遵循)。</p><p>　　对于Linux，某些守护进程以<span style="background-color:#ff0">内核线程</span>的形式运行。这些守护进程的代码是内核的一部分，并且它们通常在系统启动时被创建。当使用命令<code>ps</code>时，这些守护进程的名称被方括号 (<code>[]</code>) 括起来。</p><p>　　守护进程的日志日志和配置文件通常位于标准目录。按照惯例，配置文件通常位于目录<code>/etc</code>或其子目录，而日志文件通常位于目录<code>/var/log</code>。守护进程通常会提供命令行选项来修改日志文件和配置文件的位置。</p><span id="more"></span><h3 id="创建守护进程">37.1 创建守护进程</h3><p>　　为了成为守护进程，程序需要执行以下步骤：</p><p>　　1) 调用<code>fork()</code>，然后父进程退出，子进程继续运行。这样做有2个原因。首先，若守护进程从命令行启动，则shell会注意到父进程终止，然后显示另一个shell提示符并让子进程继续在后台运行。其次，子进程一定不会成为进程组组长，因为它会继承父进程的进程组ID，并获得自己的进程ID (这是成功执行下一步所需要的)。</p><p>　　2) 子进程调用<code>setsid()</code>来创建新会话和释放与控制终端的关联。</p><p>　　3) 若守护进程自此没有打开任何终端设备，则守护进程不会获取控制终端。为了防止守护进程随后打开终端设备，必须采取措施来确保该设备不会成为控制终端。这可以通过2种方法实现。第1种方法是通过<code>open()</code>打开终端设备时指定标志<code>O_NOCTTY</code>。第2种方法是在<code>setsid()</code>后调用<code>fork()</code>，然后子进程退出，孙进程继续运行。这会确保孙进程不会成为会话组长。根据System V获取控制终端的规则 (Linux遵循该规则)，该进程永远不能获取控制终端 (对于遵循BSD规则的实现，进程必须通过显式地执行<code>ioctl()</code>的操作<code>TIOCSCTTY</code>来获取控制终端)。</p><p>　　4) 清除进程umask，以确保守护进程创建文件和目录时有所需的权限。</p><p>　　5) 修改进程的当前工作目录，通常修改为根目录。这是必要的，因为守护进程通常会一直运行，若守护进程的当前工作目录位于不包含<code>/</code>的文件系统，则该文件系统无法被卸载。或者，守护进程可以将其工作目录修改为它执行任务的位置或配置文件中定义的位置 (只要该目录所在的文件系统永远不需要被卸载)。</p><p>　　6) 关闭守护进程从父进程继承的所有不再需要的打开的文件描述符。守护进程没有控制终端，并且在后台运行，所以无需让守护进程保留引用终端的文件描述符0~2。此外，无法卸载守护进程当前打开的文件所在的文件系统，而且文件描述符属于有限资源。</p><p>　　7) 当关闭文件描述符0~2后，守护进程通常会打开<code>/dev/null</code> (<code>/dev/null</code>是虚拟设备，它会丢弃向其写入的所有数据。读取该设备总是会返回EOF)，并通过<code>dup2()</code> (或类似的函数) 让这3个文件描述符引用该设备。这样做有2个原因。首先，当守护进程调用的函数对这3个文件描述符执行I/O时，这会保证这些函数不会意外地出错。其次，这可以防止守护进程随后使用文件描述符1或2打开文件，然后通过默认将这2个文件描述符视为标准输出和错误的库函数写入文件并损坏文件的可能性。</p><p>　　很多标准守护进程会在关机期间被特定应用程序的脚本终止。那些不通过这种方式终止的守护进程会在关机期间收到信号<code>SIGTERM</code>，因为进程<code>init</code>会在关机期间向其所有子进程发送该信号。若守护进程需要在终止前执行清理操作，则应该注册<code>SIGTERM</code>处理函数，该处理函数必须快速执行清理操作，因为进程<code>init</code>会在信号<code>SIGTERM</code>发送5秒后发送信号<code>SIGKILL</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* become_daemon.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BECOME_DAEMON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BECOME_DAEMON_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* becomeDaemon()的参数flags的位掩码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BD_NO_CHDIR 01          <span class="comment">/* 不会切换到根目录 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BD_NO_CLOSE_FILES 02    <span class="comment">/* 保留所有打开的文件描述符 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BD_NO_REOPEN_STD_FDS 04 <span class="comment">/* 不会重新打开文件描述符0~2 (让其引用/dev/null) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BD_NO_UMASK0 010        <span class="comment">/* 不清除umask */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BD_MAX_CLOSE 8192       <span class="comment">/* 最大文件描述符 (若sysconf(_SC_OPEN_MAX)无法获取最大文件描述符) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">becomeDaemon</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* become_daemon.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;become_daemon.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将调用进程转换为守护进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param flags</span></span><br><span class="line"><span class="comment"> * @return int 成功时返回0，出错时返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">becomeDaemon</span><span class="params">(<span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxfd, fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程继续运行 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程终止 */</span></span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsid() == <span class="number">-1</span>) <span class="comment">/* 成为新会话组长 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保孙进程不会成为会话组长 */</span></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; BD_NO_UMASK0))</span><br><span class="line">    &#123;</span><br><span class="line">        umask(<span class="number">0</span>); <span class="comment">/* 清除文件模式创建掩码 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; BD_NO_CHDIR))</span><br><span class="line">    &#123;</span><br><span class="line">        chdir(<span class="string">&quot;/&quot;</span>); <span class="comment">/* 切换到根目录 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭所有打开的文件描述符 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; BD_NO_CLOSE_FILES))</span><br><span class="line">    &#123;</span><br><span class="line">        maxfd = sysconf(_SC_OPEN_MAX);</span><br><span class="line">        <span class="keyword">if</span> (maxfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxfd = BD_MAX_CLOSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (fd = <span class="number">0</span>; fd &lt; maxfd; fd++)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭文件描述符0~2并让它们引用/dev/null */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; BD_NO_REOPEN_STD_FDS))</span><br><span class="line">    &#123;</span><br><span class="line">        close(STDIN_FILENO);</span><br><span class="line">        fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != STDIN_FILENO) <span class="comment">/* fd应该为0 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dup2(STDIN_FILENO, STDOUT_FILENO) != STDOUT_FILENO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dup2(STDIN_FILENO, STDERR_FILENO) != STDERR_FILENO)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数<code>becomeDaemon()</code>是上述步骤的实现 (glibc提供了与这个函数类似的非标准函数<code>daemon()</code>)。</p><h3 id="通过信号sighup重新初始化守护进程">37.2 通过信号<code>SIGHUP</code>重新初始化守护进程</h3><p>　　很多守护进程都是长时间运行，这会为带来一些编程上的问题：</p><p>　　● 通常，守护进程会在启动时从相关的配置文件读取参数。有时，可能需要即时修改这些参数，而无需停止并重新启动守护进程。</p><p>　　● 有些守护进程会生成日志文件。若守护进程一直打开日志文件，则日志文件可能无限增长，最终堵塞文件系统 (如前所述，即使删除了文件的所有文件名，只要有进程打开该文件，该文件就会一直存在)，所以需要某种方法来告诉守护进程关闭其日志文件并打开新文件，以便轮换日志文件 (程序<code>logrotate</code>可用于自动轮换守护进程日志文件)。</p><p>　　这些问题的解决方法是让守护进程注册<code>SIGHUP</code>处理函数。当控制进程与控制终端断开连接时，才会收到信号<code>SIGHUP</code>。因此，内核永远不会为守护进程生成该信号。</p><p>　　某些守护进程在收到信号<code>SIGHUP</code>时使用不同的方法进行重新初始化：关闭所有文件，然后通过<code>exec()</code>重新启动自己。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* daemon_SIGHUP.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;become_daemon.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TS_BUF_SIZE sizeof(<span class="string">&quot;YYYY-MM-DD HH:MM:SS&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *LOG_FILE = <span class="string">&quot;/tmp/ds.log&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *CONFIG_FILE = <span class="string">&quot;/tmp/ds.conf&quot;</span>;</span><br><span class="line"><span class="type">static</span> FILE *logfp;                           <span class="comment">/* 日志文件流 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> hupReceived = <span class="number">0</span>; <span class="comment">/* 是否收到信号SIGHUP */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向日志文件写入消息 (每条消息前会加上时间戳)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param format 格式字符串</span></span><br><span class="line"><span class="comment"> * @param ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">logMessage</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argList;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *TIMESTAMP_FMT = <span class="string">&quot;%F %X&quot;</span>; <span class="comment">/* 等同于YYYY-MM-DD HH:MM:SS */</span></span><br><span class="line">    <span class="type">char</span> timestamp[TS_BUF_SIZE];</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">loc</span>;</span></span><br><span class="line"></span><br><span class="line">    t = time(<span class="literal">NULL</span>);</span><br><span class="line">    loc = localtime(&amp;t);</span><br><span class="line">    <span class="keyword">if</span> (loc == <span class="literal">NULL</span> || strftime(timestamp, TS_BUF_SIZE, TIMESTAMP_FMT, loc) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(logfp, <span class="string">&quot;???Unknown time????: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(logfp, <span class="string">&quot;%s: &quot;</span>, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_start(argList, format);</span><br><span class="line">    <span class="built_in">vfprintf</span>(logfp, format, argList);</span><br><span class="line">    <span class="built_in">fprintf</span>(logfp, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    va_end(argList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打开日志文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param logFilename 日志文件路径名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">logOpen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *logFilename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mode_t</span> m;</span><br><span class="line"></span><br><span class="line">    m = umask(<span class="number">077</span>);</span><br><span class="line">    logfp = fopen(logFilename, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    umask(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开失败时不写入消息 */</span></span><br><span class="line">    <span class="keyword">if</span> (logfp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(logfp, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdio缓冲 */</span></span><br><span class="line"></span><br><span class="line">    logMessage(<span class="string">&quot;Opened log file&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 关闭日志文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">logClose</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    logMessage(<span class="string">&quot;Closing log file&quot;</span>);</span><br><span class="line">    fclose(logfp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读取配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param configFilename 配置文件路径名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">readConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *configFilename)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *configfp;</span><br><span class="line">    <span class="type">char</span> str[SBUF_SIZE];</span><br><span class="line"></span><br><span class="line">    configfp = fopen(configFilename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (configfp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fgets(str, SBUF_SIZE, configfp) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            str[<span class="built_in">strlen</span>(str) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 删除结尾的字符\0 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logMessage(<span class="string">&quot;Read config file: %s&quot;</span>, str);</span><br><span class="line">        fclose(configfp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sighupHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    hupReceived = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> SLEEP_TIME = <span class="number">15</span>; <span class="comment">/* 消息之间的睡眠时间 */</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;             <span class="comment">/* 睡眠次数 */</span></span><br><span class="line">    <span class="type">int</span> unslept;               <span class="comment">/* 剩余睡眠时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line">    sa.sa_handler = sighupHandler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (becomeDaemon(<span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;becomeDaemon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logOpen(LOG_FILE);</span><br><span class="line">    readConfigFile(CONFIG_FILE);</span><br><span class="line"></span><br><span class="line">    unslept = SLEEP_TIME;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        unslept = sleep(unslept);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hupReceived) <span class="comment">/* 若收到了信号SIGHUP */</span></span><br><span class="line">        &#123;</span><br><span class="line">            logClose();</span><br><span class="line"></span><br><span class="line">            logOpen(LOG_FILE);</span><br><span class="line">            readConfigFile(CONFIG_FILE);</span><br><span class="line">            hupReceived = <span class="number">0</span>; <span class="comment">/* 准备再次收到该信号 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unslept == <span class="number">0</span>) <span class="comment">/* 若睡眠完成 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            logMessage(<span class="string">&quot;Main: %d&quot;</span>, count);</span><br><span class="line">            unslept = SLEEP_TIME; <span class="comment">/* 重置间隔 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了守护进程如何使用信号<code>SIGHUP</code>。该程序会注册<code>SIGHUP</code>处理函数、转换为守护进程、打开日志文件和读取配置文件 (第121~135行)。<code>SIGHUP</code>处理函数只会设置全局标志变量<code>hupReceived</code> (第109~112行)。最后，主函数开始无限循环，每15秒打印1条消息 (第152~157行)。睡眠是为了模拟实际应用程序执行任务的情况。每当<code>sleep()</code>返回时，主函数会检查标志<code>hupReceived</code>是否被设置，若是，则重新打开日志文件、重新读取配置文件以及清除该标志 (第143~150行)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> START &gt; /tmp/ds.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./daemon_SIGHUP</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /tmp/ds.log</span></span><br><span class="line">2011-01-17 11:18:34: Opened log file</span><br><span class="line">2011-01-17 11:18:34: Read config file: START</span><br></pre></td></tr></table></figure><p>　　首先，创建1个配置文件，然后启动守护进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> CHANGED &gt; /tmp/ds.conf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> +<span class="string">&#x27;%F %X&#x27;</span>; <span class="built_in">mv</span> /tmp/ds.log /tmp/old_ds.log</span></span><br><span class="line">2011-01-17 11:19:03 AM</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> +<span class="string">&#x27;%F %X&#x27;</span>; killall -HUP daemon_SIGHUP</span></span><br><span class="line">2011-01-17 11:19:23 AM</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /tmp/*ds.log</span></span><br><span class="line">/tmp/ds.log /tmp/old_ds.log</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /tmp/old_ds.log</span></span><br><span class="line">2011-01-17 11:18:34: Opened log file</span><br><span class="line">2011-01-17 11:18:34: Read config file: START</span><br><span class="line">2011-01-17 11:18:49: Main: 1</span><br><span class="line">2011-01-17 11:19:04: Main: 2</span><br><span class="line">2011-01-17 11:19:19: Main: 3</span><br><span class="line">2011-01-17 11:19:23: Closing log file</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /tmp/ds.log</span></span><br><span class="line">2011-01-17 11:19:23: Opened log file</span><br><span class="line">2011-01-17 11:19:23: Read config file: CHANGED</span><br><span class="line">2011-01-17 11:19:34: Main: 4</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">killall daemon_SIGHUP</span></span><br></pre></td></tr></table></figure><p>　　第6行的命令<code>ls</code>的输出有1个新日志文件和1个旧日志文件。当通过命令<code>cat</code>查看旧日志文件时，可以发现通过命令<code>mv</code>重命名文件后守护进程仍然在运行 (此时，可以删除旧日志文件)。当查看新日志文件时，可以发现配置文件已经被读取。</p><h3 id="使用syslog记录消息和错误">37.3 使用syslog记录消息和错误</h3><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_37/overview_of_system_logging.svg"><p>　　syslog提供了单一的集中式日志记录工具，可用于记录系统上所有应用程序的消息。syslog有2个主要组件：系统日志守护进程<code>syslogd</code>和库函数<code>syslog()</code>。</p><p>　　守护进程<code>syslogd</code>有2个日志消息源：UNIX域套接字<code>/dev/log</code>和互联网域套接字 (UDP端口514)。前者存储本地生成的消息，后者存储通过TCP/IP网络发送的消息 (某些UNIX实现的syslog套接字位于<code>/var/run/log</code>)。</p><p>　　守护进程<code>syslogd</code>处理的每条消息有很多属性，包括facility (表示生成消息的程序的类别) 和level (表示消息的优先级)。<code>syslogd</code>会解析每条消息的facility和level，然后根据相关配置文件<code>/etc/syslog.conf</code>将消息传递给几个可能的目的地中的任意1个。可能的目的地包括终端或虚拟控制台、磁盘文件、有名管道、若干个已登录用户或通过TCP/IP网络连接的其他系统上的进程 (通常也是<code>syslogd</code>)。消息可以被发送给若干个目的地。具有不同facility和level组合的消息可以被定位到不同的目的地或目的地的不同实例 (例如，不同的控制台或磁盘文件)。</p><p>　　向通过TCIP/IP网络连接的其他系统发送消息有助于将来自多个系统的消息合并到单个系统，从而减少管理开销。此外，这还有助于检查系统入侵。入侵通常会在系统日志中留下痕迹，但攻击者通常会通过删除日志记录来掩盖入侵。当使用远程日志时，攻击者还需要入侵远程系统才能删除日志记录。</p><p>　　所有进程都可以通过库函数<code>syslog()</code>来记录消息，该函数会使用提供的参数构建标准格式的消息，然后将其放置在<code>/dev/log</code>套接字上，以供守护进程<code>syslogd</code>读取。</p><p>　　<code>/dev/log</code>上的消息还有另一种来源——内核日志守护进程<code>klogd</code>，该守护进程会收集日志消息 (由内核通过函数<code>printk()</code>生成)。这些消息可以通过2个特定于Linux的接口收集：文件<code>/proc/kmsg</code>和系统调用<code>syslog()</code>，然后通过库函数<code>syslog()</code>将其写入<code>/dev/log</code>。</p><p>　　尽管系统调用<code>syslog()</code>和库函数<code>syslog()</code>同名，但它们执行的任务截然不同。</p><p>　　syslog最早出现于4.2BSD，现在大多数UNIX实现都提供了该功能。SUSv3标准化了库函数<code>syslog()</code>及其相关函数，但没有说明守护进程<code>syslogd</code>的实现和行为以及文件<code>syslog.conf</code>的格式。syslog的Linux实现不同于最初的BSD实现，它允许对文件<code>syslog.conf</code>中指定的消息处理规则进行一些扩展。</p><h4 id="syslog-api">37.3.1 syslog API</h4><p>　　syslog API包含3个主要函数：<code>openlog()</code>、<code>syslog()</code>和<code>closelog()</code>。这3个函数都不会返回状态值，部分是因为日志系统应该始终是可用的 (当日志系统不可用时，系统管理者很快就会发现)。此外，若日志系统出错，则应用程序通常也难以有效地报告错误。</p><h5 id="openlog">37.3.1.1 <code>openlog()</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> log_options, <span class="type">int</span> facility)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>openlog()</code>会建立与日志系统 (即UNIX域套接字<code>/dev/log</code>) 的连接，并修改影响后续<code>syslog()</code>调用的设置。该函数的调用是可选的，若省略了该函数，则第1次调用<code>syslog()</code>时会使用默认设置来建立与日志系统的连接。</p><p>　　参数<code>ident</code>是字符串 (通常是程序名)，<code>syslog()</code>写入的每条消息都会包含该字符串。<code>openlog()</code>只是复制了该指针的值。因此，只要后续需要调用<code>syslog()</code>，就应该确保该字符串不变。若该参数为<code>NULL</code>，则glibc的实现会自动将其值设置为程序名 (有些UNIX实现也是如此)。但是，SUSv3没有要求这一点，并且有些UNIX实现也没有这样做。</p><p>　　参数<code>log_options</code>是标志<code>LOG_CONS</code>、<code>LOG_NDELAY</code>、<code>LOG_NOWAIT</code>、<code>LOG_ODELAY</code>、<code>LOG_PERROR</code>和<code>LOG_PID</code>中的若干个标志进行或运算<code>|</code>得到的结果：</p><p>　　● 标志<code>LOG_CONS</code>表示错误被发送给日志系统时将该消息打印到系统控制台 (<code>/dev/console</code>)。</p><p>　　● 标志<code>LOG_NDELAY</code>表示立即打开与日志系统的连接。当需要控制何时打开<code>/dev/log</code>文件描述符时，该标志很有用。调用<code>chroot()</code>的程序便是如此，调用<code>chroot()</code>后<code>/dev/log</code>的路径名将不可见，所以必须在调用<code>chroot()</code>之前调用<code>openlog()</code>并指定该标志。守护进程<code>tftpd</code> (简单文件传输) 就是使用该标志来实现该目的的程序之一。</p><p>　　● 标志<code>LOG_NOWAIT</code>表示不会回收为了记录消息而创建的子进程。对于创建子进程来记录消息的实现，若调用者创建了子进程，并且在等待子进程，则需要使用该标志，以防<code>syslog()</code>试图回收已被调用者回收的子进程。对于Linux，该标志不生效，因为记录消息时不会创建子进程。</p><p>　　● 标志<code>LOG_ODELAY</code>与<code>LOG_NDELAY</code>相反，与日志系统的连接会被推迟到记录第1条消息。这也是<span style="background-color:#ff0">默认</span>情况，无需指定。</p><p>　　● 标志<code>LOG_PERROR</code>表示会将消息写入到标志错误和系统日志。通常，守护进程会关闭标志错误或将其重定向到<code>/dev/null</code> (该标志无效)。</p><p>　　● 标志<code>LOG_PID</code>表示在所有消息中记录调用者的进程ID。</p><p>　　SUSv3详细说明了标志<code>LOG_PERROR</code>以外的所有标志，而且并非所有UNIX实现都提供了标志<code>LOG_PERROR</code>。</p><p>　　参数<code>facility</code>指定用于后续<code>syslog()</code>调用的默认facility值，该参数的可能值如下：</p><table><colgroup><col style="width:21%"><col style="width:71%"><col style="width:7%"></colgroup><thead><tr><th>facility值</th><th>描述</th><th>SUSv3</th></tr></thead><tbody><tr><td><code>LOG_AUTH</code></td><td>安全和认证消息 (例如，<code>su</code>)</td><td>✓</td></tr><tr><td><code>LOG_AUTHPRIV</code></td><td>私有安全和认证消息</td><td></td></tr><tr><td><code>LOG_CRON</code></td><td>来自守护进程<code>cron</code>和<code>at</code>的消息</td><td>✓</td></tr><tr><td><code>LOG_DAEMON</code></td><td>来自其他系统守护进程的消息</td><td>✓</td></tr><tr><td><code>LOG_FTP</code></td><td>来自守护进程<code>ftpd</code>的消息</td><td></td></tr><tr><td><code>LOG_KERN</code></td><td>内核消息 (无法由用户进程生成)</td><td>✓</td></tr><tr><td><code>LOG_LOCAL0</code></td><td>仅供本地使用 (包括<code>LOG_LOCAL1</code>到<code>LOG_LOCAL7</code>)</td><td>✓</td></tr><tr><td><code>LOG_LPR</code></td><td>来自行式打印机系统 (<code>lpr</code>、<code>lpd</code>和<code>lpc</code>) 的消息</td><td>✓</td></tr><tr><td><code>LOG_MAIL</code></td><td>来自邮件系统的消息</td><td>✓</td></tr><tr><td><code>LOG_NEWS</code></td><td>Usenet网络新闻相关的消息</td><td>✓</td></tr><tr><td><code>LOG_SYSLOG</code></td><td>来自守护进程<code>syslogd</code>的内部消息</td><td></td></tr><tr><td><code>LOG_USER</code></td><td>由用户进程生成的消息 (默认)</td><td>✓</td></tr><tr><td><code>LOG_UUCP</code></td><td>来自UUCP系统的消息</td><td>✓</td></tr></tbody></table><p>　　SUSv3详细说明了大部分facility值，除了仅出现在少部分UNIX实现的<code>LOG_AUTHPRIV</code>和<code>LOG_FTP</code>以及出现在大部分UNIX实现的<code>LOG_SYSLOG</code>。<code>LOG_AUTHPRIV</code>可用于将包含密码或其他敏感信息的消息记录在与<code>LOG_AUTH</code>不同的位置。</p><h5 id="syslog">37.3.1.2 <code>syslog()</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>syslog()</code>会记录1条消息。参数<code>priority</code>是1个facility值 (指定给<code>openlog()</code>的参数<code>facility</code>的值) 和1个level值 (消息的优先级) 进行或运算<code>|</code>得到的结果。若省略了facility值，则默认使用之前<code>openlog()</code>调用中指定的值。若之前未调用<code>openlog()</code>，则默认使用<code>LOG_USER</code>。SUSv3详细说明了所有level值，这些level值如下 (从高优先级到低优先级)：</p><table><thead><tr><th>level值</th><th>描述</th></tr></thead><tbody><tr><td><code>LOG_EMERG</code></td><td>紧急或恐慌情况 (系统无法使用)</td></tr><tr><td><code>LOG_ALERT</code></td><td>需要立即采取行动的情况 (例如，系统数据库损坏)</td></tr><tr><td><code>LOG_CRIT</code></td><td>关键情况 (例如，磁盘设备出错)</td></tr><tr><td><code>LOG_ERR</code></td><td>一般错误情况</td></tr><tr><td><code>LOG_WARNING</code></td><td>警告消息</td></tr><tr><td><code>LOG_NOTICE</code></td><td>可能需要特殊处理的普通情况</td></tr><tr><td><code>LOG_INFO</code></td><td>信息消息</td></tr><tr><td><code>LOG_DEBUG</code></td><td>调试消息</td></tr></tbody></table><p>　　<code>syslog()</code>的剩余参数是格式字符串和相应的参数，类似于<code>printf()</code>。与<code>printf()</code>的区别之一是格式字符串不需要包含结尾的换行符。此外，格式字符串还可以包含双字符序列<code>%m</code>，该序列会被替换为与<code>errno</code>的当前值对应的错误字符串 (等同于<code>strerror(errno)</code>)。</p><p>　　以下代码展示了<code>openlog()</code>和<code>syslog()</code>的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openlog(argv[<span class="number">0</span>], LOG_PID | LOG_CONS | LOG_NOWAIT, LOG_LOCALO);</span><br><span class="line">syslog(LOG_ERR, <span class="string">&quot;Bad argument: %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">syslog(LOG_USER | LOG_INFO, <span class="string">&quot;Exiting&quot;</span>);</span><br></pre></td></tr></table></figure><p>　　第1次调用<code>syslog()</code>没有指定facility值，所以会使用调用<code>openlog()</code>时指定的默认值<code>LOG_LOCALO</code>。当第2次调用<code>syslog()</code>时，显式指定了facility值<code>LOG_USER</code>来覆盖调用<code>openlog()</code>时指定的默认值。</p><p>　　<code>syslog(priority, user_supplied_string)</code>调用是错误的，因为它容易让程序受到<span style="background-color:#ff0">格式字符串攻击</span>。若用户提供的字符串包含格式字符串，则结果不可预测，从安全角度，这可能存在危险 (这也适用于<code>printf()</code>)。因此，正确的调用方式应该是<code>syslog(priority, "%s", user_supplied_string)</code>。</p><p>　　glibc还提供了函数<code>void vsyslog(int priority, const char *format, va_list ap)</code>。该函数执行与<code>syslog()</code>相同的任务，但它的第3个参数需要通过头文件<code>stdarg.h</code>中的可变参数列表宏处理。SUSv3没有说明了该函数，而且并非所有UNIX实现都提供了该函数。</p><p>　　对于shell，可以通过命令<code>logger</code>来添加条目到系统日志。该命令允许指定与日志消息关联的优先级 (类似于<code>syslog()</code>的参数<code>priority</code>) 和标识符 (类似于<code>openlog()</code>的参数<code>ident</code>)。SUSv3简要说明了该命令，并且大多数UNIX实现都提供了该命令的某个版本。</p><h5 id="closelog">37.3.1.3 <code>closelog()</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>closelog()</code>会关闭与日志系统的连接 (释放为<code>/dev/log</code>分配的文件描述符)。</p><p>　　守护进程通常会持续保持与日志系统的连接，所以通常不会调用该函数。</p><h5 id="setlogmask">37.3.1.4 <code>setlogmask()</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setlogmask</span><span class="params">(<span class="type">int</span> mask_priority)</span>; <span class="comment">/* 返回日志优先级掩码的旧值 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>setlogmask()</code>用于设置过滤<code>syslog()</code>写入的消息的掩码。level不在该掩码范围内的消息都会被丢弃。默认掩码允许记录所有优先级的消息。</p><p>　　定义在头文件<code>syslog.h</code>中的宏<code>LOG_MASK</code>可用于将level值转换为适合指定给参数<code>mask_priority</code>的值 (SUSv3详细说明了该宏)。为了过滤优先级低于<code>LOG_ERR</code>的消息，应该通过以下方式调用<code>setlogmask()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setlogmask(LOG_MASK(LOG_EMERG) | LOG_MASK(LOG_ALERT) |</span><br><span class="line">           LOG_MASK(LOG_CRIT) | LOG_MASK(LOG_ERR));</span><br></pre></td></tr></table></figure><p>　　Linux和大多数UNIX实现还提供了SUSv3未说明的宏<code>LOG_UPTO</code>，该宏会创建1个位掩码，过滤某个优先级及以下的所有消息。因此，该调用可以简化为以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setlogmask(LOG_UPTO(LOG_ERR));</span><br></pre></td></tr></table></figure><h4 id="文件etcsyslog.conf">37.3.2 文件<code>/etc/syslog.conf</code></h4><p>　　配置文件<code>/etc/syslog.conf</code>控制守护进程<code>syslogd</code>的行为。该文件包含规则和注释 (以字符<code>#</code>开头)。规则通常具有以下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">facility.level  action</span><br></pre></td></tr></table></figure><p>　　<code>facility</code>和<code>level</code>的组合称为<span style="background-color:#ff0">选择器</span>，因为它们选择规则适用的消息。这2个字段是37.3.1.1和37.3.1.2的表格中的值对应的字符串。<code>action</code>指定消息的目的地。选择器和<code>action</code>之间使用空格分隔。以下是一些规则示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.err                           /dev/tty10</span><br><span class="line">auth.notice                     root</span><br><span class="line">*.debug;mail.none;news.none     -/var/log/messages</span><br></pre></td></tr></table></figure><p>　　第1条规则表示level不低于<code>err</code> (<code>LOG_ERRs</code>) 的所有消息 (<code>*</code>) 都会被发送给控制台设备<code>/dev/tty10</code>。第2条规则表示level不低于<code>notice</code> (<code>LOG_NOTICE</code>) 的安全和认证消息 (<code>auth</code>) 都会被发送给root登录的所有控制台或终端。该规则允许登录的root用户立即收到<code>su</code>失败等消息。</p><p>　　第3条规则展示了规则语法的一些高级特性。1条规则可以包含多个选择器，选择器之间使用分号<code>;</code>分隔。第1个选择器指定所有消息 (对于Linux和有些UNIX实现，level也可以被指定<code>*</code>，其含义与<code>debug</code>相同。但是，并非所有syslog实现都支持了该特性)。通常，包含多个选择器的规则会匹配与任何选择器对应的消息，但level为<code>none</code>表示排除对应facility的所有消息。因此，该规则表示Usenet网络新闻相关的消息 (<code>LOG_MAIL</code>) 和来自邮件系统的消息 (<code>LOG_NEWS</code>) 以外的所有消息会被发送给文件<code>/var/log/messages</code>。文件名前的连字符<code>-</code>表示在写入该文件时不进行磁盘同步 (见13.3)。这样会提高写入速度，但系统在写入时崩溃可能会丢失一些数据。</p><p>　　当修改文件<code>syslog.conf</code>后，必须通过命令<code>killall -HUP syslogd</code>来重新初始化守护进程<code>syslogd</code>。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_04/" rel="prev" title="《ARM Cortex-M3与Cortex-M4权威指南 第3版》第4章 架构"><i class="fa fa-angle-left"></i> 《ARM Cortex-M3与Cortex-M4权威指南 第3版》第4章 架构</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_38/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第38章 编写安全特权程序">《Linux/UNIX系统编程手册》第38章 编写安全特权程序 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>