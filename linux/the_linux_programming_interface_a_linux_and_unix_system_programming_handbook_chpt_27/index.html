<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_27/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_27/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_27/","title":"《Linux/UNIX系统编程手册》第27章 程序执行"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第27章 程序执行 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#exec%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-text">27.1 exec()库函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fpath"><span class="nav-text">27.1.1 环境变量PATH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fexecve"><span class="nav-text">27.1.2 fexecve()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E8%84%9A%E6%9C%AC"><span class="nav-text">27.2 解释器脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E8%84%9A%E6%9C%AC%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-text">27.2.1 解释器脚本的执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#awk%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-text">27.2.2 awk解释器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8Cexec"><span class="nav-text">27.3 文件描述符和exec()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%92%8Cexec"><span class="nav-text">27.4 信号和exec()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#system"><span class="nav-text">27.5 system()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%9C%A8set-user-id%E5%92%8Cset-group-id%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8system"><span class="nav-text">27.5.1 避免在set-user-ID和set-group-ID程序中使用system()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0system"><span class="nav-text">27.5.2 实现system()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8system%E4%B8%AD%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7"><span class="nav-text">27.5.2.1 在system()中正确处理信号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84system%E5%AE%9E%E7%8E%B0"><span class="nav-text">27.5.2.2 改进的system()实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Esystem%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82"><span class="nav-text">27.5.2.3 关于system()的更多细节</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_27/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第27章 程序执行 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第27章 程序执行</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-06-23 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:00+08:00">2025-06-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-06-24 00:00:00" itemprop="dateModified" datetime="2025-06-24T00:00:00+08:00">2025-06-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>18k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>; <span class="comment">/* 成功时不会返回，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　对于系统调用<code>execve()</code>，参数<code>pathname</code>是待加载到进程内存的新程序的路径名 (绝对路径名或相对于调用进程的当前工作目录的相对路径名)。</p><p>　　参数<code>argv</code>是传递给新程序的命令行参数 (对应C主函数的参数<code>argv</code>)，该参数指向1个字符串数组 (第1个元素是<code>pathname</code>的基础部分，最后1个元素是<code>NULL</code>)。</p><p>　　参数<code>envp</code>是传递给新程序的环境列表，该参数指向1个字符串数组 (数组元素的格式为<code>name=value</code>，最后1个元素是<code>NULL</code>)。</p><p>　　当调用<code>execve()</code>后，调用进程的进程ID (和少量进程属性) 保持不变，旧程序会被丢弃，并且进程的栈、堆和数据会被新程序的栈、堆和数据替换。在执行各种C库运行时启动代码和程序初始化代码后，新程序开始执行主函数。<code>execve()</code>通常用于通过<code>fork()</code>创建的子进程。</p><p>　　若<code>pathname</code>指定的文件的set-user-ID位 (或set-group-ID位) 已设置，则当文件被执行时进程的有效用户ID (或有效组ID) 会被修改为该文件的所有者的用户ID (或所属组的组ID)。</p><p>　　无论<code>pathname</code>指定的文件的set-user-ID位 (或set-group-ID位) 是否设置，<code>execve()</code>都会将进程的有效用户ID和有效组ID复制给保存的set-user-ID和set-group-ID。</p><p>　　若<code>execve()</code>成功，则会替换调用进程执行的程序 (不会返回)。若有返回值，则只能是-1，并且会将<code>errno</code>设置为<code>EACCES</code>、<code>ENOENT</code>、<code>ENOEXEC</code>、<code>ETXTBSY</code>或<code>E2BIG</code>。</p><p>　　● <code>EACCES</code>表示<code>pathname</code>指定的文件不是常规文件、没有<code>pathname</code>指定的文件的执行权限、没有<code>pathname</code>的目录部分的某个目录的执行权限或<code>pathname</code>指定的文件所在的文件系统挂载时指定了标志<code>MS_NOEXEC</code>。</p><p>　　● <code>ENOENT</code>表示<code>pathname</code>指定的文件不存在。</p><p>　　● <code>ENOEXEC</code>表示<code>pathname</code>指定的文件被标记为可执行，但其格式不是可识别的可执行格式 (例如，不以<code>#!</code>开头的脚本)。</p><p>　　● <code>ETXTBSY</code>表示<code>pathname</code>指定的文件已经被其他进程打开以进行写入。</p><p>　　● <code>E2BIG</code>表示参数列表和环境列表的总大小超过了上限。</p><p>　　若为执行脚本而定义的解释器文件或用于执行程序的ELF解释器存在上述任何情况，则上述错误也会出现。</p><p>　　特定于Linux的文件<code>/proc/PID/exe</code>是包含对应进程正在执行的程序的绝对路径名的符号链接。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_execve.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *argVec[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> *envVec[] = &#123;<span class="string">&quot;GREET=salut&quot;</span>, <span class="string">&quot;BYE=adieu&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pathname\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取argv[1]的基础部分 */</span></span><br><span class="line">    argVec[<span class="number">0</span>] = <span class="built_in">strrchr</span>(argv[<span class="number">1</span>], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (argVec[<span class="number">0</span>] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        argVec[<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        argVec[<span class="number">0</span>] = argv[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    argVec[<span class="number">1</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    argVec[<span class="number">2</span>] = <span class="string">&quot;goodbye&quot;</span>;</span><br><span class="line">    argVec[<span class="number">3</span>] = <span class="literal">NULL</span>; <span class="comment">/* 参数列表必须以NULL结尾 */</span></span><br><span class="line"></span><br><span class="line">    execve(argv[<span class="number">1</span>], argVec, envVec);</span><br><span class="line">    errExit(<span class="string">&quot;execve&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>execve()</code>的用法。该程序会为新程序创建命令行参数列表和环境列表，然后将命令行参数作为<code>pathname</code>来调用<code>execve()</code>。</p><h3 id="exec库函数">27.1 <code>exec()</code>库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时不会返回，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/* , (char *) NULL, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/* , (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">          <span class="comment">/* , (char *) NULL */</span>)</span>;</span><br></pre></td></tr></table></figure><p>　　这些库函数都是基于<code>execve()</code>，它们之间的主要区别在于指定程序名以及新程序的参数列表和环境列表的方式。</p><table><colgroup><col style="width:13%"><col style="width:30%"><col style="width:28%"><col style="width:28%"></colgroup><thead><tr><th>函数</th><th>指定程序名的方式 (-, p)</th><th>指定参数的方式 (v, l)</th><th>指定环境的方式 (e, -)</th></tr></thead><tbody><tr><td><code>execve()</code></td><td>路径名</td><td>数组</td><td>参数<code>envp</code></td></tr><tr><td><code>execle()</code></td><td>路径名</td><td>列表</td><td>参数<code>envp</code></td></tr><tr><td><code>execlp()</code></td><td>文件名 + 环境变量<code>PATH</code></td><td>列表</td><td>调用程序的环境列表</td></tr><tr><td><code>execvp()</code></td><td>文件名 + 环境变量<code>PATH</code></td><td>数组</td><td>调用程序的环境列表</td></tr><tr><td><code>execv()</code></td><td>路径名</td><td>数组</td><td>调用程序的环境列表</td></tr><tr><td><code>execl()</code></td><td>路径名</td><td>列表</td><td>调用程序的环境列表</td></tr></tbody></table><p>　　● 大多数<code>exec()</code>函数都是通过路径名来指定待加载的新程序。但是，<code>execlp()</code>和<code>execvp()</code>允许仅指定文件名 (参数<code>filename</code>)，该文件名在环境变量<code>PATH</code>指定的目录下查找 (这是执行shell命令时shell所执行的搜索类型)。为了表示这种操作上的差异，这些函数的名称会包含字母<code>p</code> (对应环境变量<code>PATH</code>)。若<code>filename</code>包含斜杠<code>/</code>，则不会使用环境变量<code>PATH</code>，相反，该参数会被视为路径名 (绝对路径名或相对路径名)。</p><p>　　● <code>execle()</code>、<code>execlp()</code>和<code>execl()</code>通过多个参数来指定新程序的参数列表，<code>const char *arg, ...</code>可以视为<code>const char *arg0, ..., const char *argn</code>，<code>argn</code>之后的参数必须是<code>(char *) NULL</code> (表示参数列表的结尾)。对于以这种方式指定新程序的参数列表的<code>exec()</code>函数，其名称会包含字母<code>l</code>。对于通过数组指定新程序的参数列表的<code>exec()</code>函数，其名称会包含字母<code>v</code>。</p><p>　　● <code>execve()</code>和<code>execle()</code>通过参数<code>envp</code> (最后1个元素是<code>NULL</code>) 来指定新程序的环境列表。其他<code>exec()</code>函数会将调用程序的现有环境列表作为新程序的环境列表。</p><p>　　glibc 2.11添加了非标准函数<code>execvpe(file, argv, envp)</code>，该函数与<code>execvp()</code>类似，但该函数通过参数<code>envp</code>来指定新程序的环境列表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_execle.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *envVec[] = &#123;<span class="string">&quot;GREET=salut&quot;</span>, <span class="string">&quot;BYE=adieu&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *filename;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pathname\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取argv[1]的基础部分 */</span></span><br><span class="line">    filename = <span class="built_in">strrchr</span>(argv[<span class="number">1</span>], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (filename != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        filename++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        filename = argv[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execle(argv[<span class="number">1</span>], filename, <span class="string">&quot;hello world&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>, envVec);</span><br><span class="line">    errExit(<span class="string">&quot;execle&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>execle()</code>的用法。</p><h4 id="环境变量path">27.1.1 环境变量<code>PATH</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$PATH</span></span></span><br><span class="line">/home/mtk/bin:/usr/local/bin:/usr/bin:/bin:.</span><br></pre></td></tr></table></figure><p>　　环境变量<code>PATH</code>的值是由冒号<code>:</code>分隔的目录名组成的字符串，这些目录名称为<strong>路径前缀</strong>。路径前缀的长度可以是0，这等同于<code>.</code> (当前工作目录)，但SUSv3将这种行为标记为过时，所以当前工作目录应该指定为<code>.</code>。</p><p>　　登录shell的环境变量<code>PATH</code>的值由特定于用户的系统级shell启动脚本设置。由于子进程会继承父进程的环境列表，所以shell创建的用于执行命令的进程会继承shell的环境列表。</p><p>　　若未定义环境变量<code>PATH</code>，则<code>execvp()</code>和<code>execlp()</code>会默认使用<code>.:/usr/bin:/bin</code>。</p><p>　　出于安全，超级用户账户 (root) 通常会将环境变量<code>PATH</code>设置为不包含当前工作目录，这是为了防止root意外地执行当前工作目录下的文件 (可能由恶意用户故意放置在这里)。对于有些Linux发行版，环境变量<code>PATH</code>的默认值不会包含当前工作目录 (无论特权用户还是非特权用户)。</p><p>　　<code>execvp()</code>和<code>execlp()</code>会从环境变量<code>PATH</code>的值指定目录下搜索文件，搜索顺序为从左到右，直到找到匹配的文件。此外，应该尽量避免在set-user-ID或set-group-ID程序中使用<code>execvp()</code>和<code>execlp()</code> (可能会意外地执行恶意程序)。在实际中，应用程序应该使用安全的目录列表来覆盖环境变量<code>PATH</code>的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_execlp.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pathname\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execlp(argv[<span class="number">1</span>], argv[<span class="number">1</span>], <span class="string">&quot;hello world&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">    errExit(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>execlp()</code>的用法。</p><h4 id="fexecve">27.1.2 <code>fexecve()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fexecve</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>; <span class="comment">/* 成功时不会返回，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　从版本2.3.2开始，glibc提供了库函数<code>fexecve()</code>。<code>fexecve()</code>与<code>execve()</code>类似，但通过打开的文件描述符<code>fd</code>来指定新程序 (而非路径名)。</p><p>　　<code>fexecve()</code>的理念是允许调用者在执行可执行文件之前验证 (校验和) 其内容。仅仅打开文件来校验内容，然后调用<code>execve()</code>是不够的。因为在这2个步骤之间，文件名或目录名的前缀可能会被替换 (例如，通过修改符号链接的目标)。但是，<code>fexecve()</code>并没有解决这个问题，所以确保文件的权限不会被恶意用户修改。</p><h3 id="解释器脚本">27.2 解释器脚本</h3><p>　　<strong>解释器</strong>是读取文本形式的命令并执行它们的程序 (例如，各种UNIX shell以及<code>awk</code>、<code>sed</code>、<code>perl</code>、<code>python</code>和<code>ruby</code>等程序)。除了能够交互式地读取和执行命令之外，解释器通常会提供从文本文件 (称为脚本) 读取和执行命令的功能。</p><p>　　只要满足2个条件，UNIX内核就允许以二进制程序文件的执行方式来执行解释器脚本。第1个条件是脚本的执行权限必须已启用，第2个条件是脚本必须以特殊的初始化行开头，该行指定用于执行脚本的解释器的路径名，其格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#! interpreter-path [ optional-arg ]</span><br></pre></td></tr></table></figure><p>　　解释器脚本必须以<code>#!</code>开头，<code>#!</code>与解释器路径名之间可以有1个空格。环境变量<code>PATH</code><span style="background-color:#ff0">不会</span>用于解析解释器路径名，所以解释器路径名可以是绝对路径名或相对于启动解释器的进程的当前工作目录的相对路径名。此外，还可以指定可选参数，可选参数在解释器路径名之后，并且解释器路径名和可选参数之间有空格。例如，UNIX shell脚本的第1行通常如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br></pre></td></tr></table></figure><p>　　解释器脚本的第1行的可选参数不能包含空格，因为这里的空格处理因UNIX实现而异。对于Linux，可选参数中的空格不会被特殊处理，所以从开头到结尾的所有文本都被视为1个单词。有些UNIX实现处理可选参数中的空格的方式与Linux的相同，而其他UNIX实现则不然。对于版本6.0之前的FreeBSD，可选参数中的空格处理与shell的相同 (将空格视为单词之间的分隔符)；对于6.0及以上版本，FreeBSD的行为与Linux的相同。对于Solaris 8，空格被视为可选参数的结束符 (剩余文本将会被忽略)。</p><p>　　解释器脚本的第1行的长度限制因UNIX实现而异。Linux的限制是127个字符 (不包含结尾的换行符，超出的字符会被忽略)，OpenBSD 3.1的限制是64个字符，Tru64 5.1的限制是1024个字符，而有些早期UNIX实现 (例如，SunOS 4) 的限制是32个字符。</p><p>　　SUSv3没有要求解释器脚本以<code>#!</code>开头，但大多数UNIX实现都是如此。</p><h4 id="解释器脚本的执行">27.2.1 解释器脚本的执行</h4><p>　　当<code>execve()</code>检测到指定的文件以<code>#!</code>开头时，会提取剩余文本 (解释器路径名和可选参数) 并使用以下参数列表来执行解释器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interpreter-path [ optional-arg ] script-path arg...</span><br></pre></td></tr></table></figure><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_27/the_argument_list_supplied_to_an_execed_script.svg" title="the_argument_list_supplied_to_an_execed_script"><p>　　<code>interpreter-path</code>和<code>optional-arg</code>取自解释器脚本的第1行 (Linux内核2.2仅将<code>interpreter-path</code>的基础部分作为传递给解释器的第1个参数)，<code>script-path</code>是传递给<code>execve()</code>的路径名，<code>arg...</code>是指定给<code>execve()</code>的参数<code>argv</code>的值 (除了<code>argv[0]</code>)。</p><p>　　大多数UNIX shell和解释器都将<code>#</code>视为注释的起始字符，所以这些解释器在执行脚本时会忽略第1行。</p><p>　　当调用<code>exec()</code>执行脚本时，脚本不以<code>#!</code>开头通常会导致出错。但是，<code>execlp()</code>和<code>execvp()</code>有所不同。这2个函数会使用环境变量<code>PATH</code>来获取目录，并在这些目录下搜索待执行的文件。若这2个函数找到了匹配的执行权限已启用的非二进制文件，并且不以<code>#!</code>开头，则会调用shell来解释该文件。对于Linux，这表示此类文件会被解释为以行<code>#!/bin/sh</code>开头。</p><h4 id="awk解释器">27.2.2 <code>awk</code>解释器</h4><p>　　解释器脚本的第1行中的可选参数可用于指定解释器的命令行参数，这对<code>awk</code>等解释器很有用。</p><p>　　<code>awk</code>解释器在20世纪70年代晚期成为了UNIX的一部分。awk是1种弱类型语言，其语法基于C，并且具有丰富的文本处理原语，它的名称取自其开发者的姓名的首字母。awk是JavaScript和PHP等现代脚本语言的祖先。</p><p>　　脚本可以通过2种方式提供给<code>awk</code>。第1种方式是将脚本作为<code>awk</code>的第1个命令行参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;script&#x27;</span> input-file...</span></span><br></pre></td></tr></table></figure><p>　　第2种方式是使用awk脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> longest_line.awk</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/awk</span></span><br><span class="line">length &gt; max &#123; max = length; &#125;</span><br><span class="line">END &#123; print max; &#125;</span><br></pre></td></tr></table></figure><p>　　这个awk脚本会打印输出行中最长行的长度。假设需要通过以下方式调用<code>execl()</code>来执行该脚本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;longest_line.awk&quot;</span>, <span class="string">&quot;longest_line.awk&quot;</span>, <span class="string">&quot;input.txt&quot;</span>, (<span class="type">char</span> *) <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>　　该调用会使用以下参数列表调用<code>execve()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/awk longest_line.awk input.txt</span><br></pre></td></tr></table></figure><p>　　但是，这种调用<code>execve()</code>的方式会出错，因为<code>awk</code>会将<code>longest_line.awk</code>解释为包含无效<code>awk</code>命令的脚本。为此，需要将awk脚本的第1行的末尾加上选项<code>-f</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/awk -f</span></span><br><span class="line">length &gt; max &#123; max = length; &#125;</span><br><span class="line">END &#123; print max; &#125;</span><br></pre></td></tr></table></figure><p>　　现在，<code>execl()</code>调用会使用以下参数列表调用<code>execve()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/awk -f longest_line.awk input.txt</span><br></pre></td></tr></table></figure><p>　　这会成功使用脚本<code>longest_line.awk</code>调用<code>awk</code>来处理文件<code>input.txt</code>。</p><h3 id="文件描述符和exec">27.3 文件描述符和<code>exec()</code></h3><p>　　在默认情况下，调用<code>exec()</code>的程序打开的所有文件描述符在<code>exec()</code>完成后仍然保存打开状态，并且新程序可以使用这些文件描述符。shell通过这个特性来处理它执行的程序的I/O重定向。</p><p>　　当用户在终端输入命名<code>ls /tmp &gt; dir.txt</code>后，shell会执行以下步骤：</p><p>　　1) 通过<code>fork()</code>创建子进程，子进程也在运行shell的副本 (所以也会有命令的副本)。</p><p>　　2) 子shell使用文件描述符1 (标准输出) 打开文件<code>dir.txt</code>以进行输出，这可以通过2种方法完成。第1种方法是子shell关闭文件描述符1并打开文件<code>dir.txt</code> (<code>open()</code>总是使用可用的最小文件描述符，而文件描述符0处于打开状态，所以文件<code>dir.txt</code>会使用文件描述符1打开)。第2种方法是子shell直接打开<code>dir.txt</code>，然后通过<code>dup2()</code>来将新文件描述符复制给文件描述符1，最后关闭新文件描述符 (因为新文件描述符不再需要)。</p><p>　　3) 子shell执行程序<code>ls</code>。<code>ls</code>会将其输出写入到标准输出，即文件<code>dir.txt</code>。</p><p>　　这里介绍的步骤简化了一些内容，尤其是shell内置命令 (直接由shell执行的命令)。出于I/O重定向的目的，这些命令必须以不同的方式处理。</p><p>　　1个shell命令被实现为内置命令有2个原因：效率和在shell内获取额外效果。<code>pwd</code>、<code>echo</code>和<code>test</code>等常用命令足够简单，这些命令被实现为内置命令可以带来可观的效率提升。其他命令被实现为内置命令是为了对shell产生额外效果——修改shell存储的信息、shell的进程属性或shell进程的执行 (例如，命令<code>cd</code>会修改shell的当前工作目录，所以不能由其他进程执行)。</p><p>　　有时，可能需要在调用<code>exec()</code>前关闭特定的文件描述符。这可以通过<code>close()</code>实现，但这种方法存在以下限制：</p><p>　　● 文件描述符可能由库函数打开，而这些函数无法强制主函数在调用<code>exec()</code>前关闭文件描述符 (实际上，库函数通常会设置close-on-exec标志)。</p><p>　　● 当调用<code>exec()</code>出错时，可能需要保证文件描述符处于打开状态。但是，当文件描述符被关闭后，再次打开文件描述符并让文件描述符引用之前引用的文件非常困难 (甚至不可能)。</p><p>　　因此，内核为每个文件描述符提供了close-on-exec标志。若该标志已被设置，则文件描述符在<code>exec()</code>成功时会自动关闭，<code>exec()</code>出错时保持打开状态。文件描述符的close-on-exec标志可以通过系统调用<code>fcntl()</code>访问。<code>fcntl()</code>的操作<code>F_GETFD</code>可以获取文件描述符的标志的副本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">flags = fcntl(fd, F_GETFD);</span><br><span class="line"><span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当获取了这些标志后，可以修改位<code>FD_CLOEXEC</code>，然后再次调用<code>fcntl()</code>的操作<code>F_SETFD</code>来更新标志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flags |= FD_CLOEXEC;</span><br><span class="line"><span class="keyword">if</span> (fcntl(fd, F_SETFD, flags) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>FD_CLOEXEC</code>实际上是文件描述符的标志中唯一使用的位，对应值1，所以可以直接调用<code>fcntl(fd, F_SETFD, 1)</code>来设置文件描述符的close-on-exec标志。从理论角度，由于有些UNIX系统以后可能会使用其他标志位，所以应该避免使用这种方法。</p><p>　　Linux和很多UNIX实现允许通过非标准<code>ioctl()</code>调用来修改close-on-exec标志：<code>ioctl(fd, FIOCLEX)</code> (设置close-on-exec标志) 和<code>ioctl(fd, FIOCLEX)</code> (清除close-on-exec标志)。</p><p>　　当通过<code>dup()</code>、<code>dup2()</code>或<code>fcntl()</code>来复制文件描述符时，新文件描述符的close-on-exec标志总是处于关闭状态 (这种行为是历史性的，也是SUSv3的要求)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* closeonexec.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flags = fcntl(STDOUT_FILENO, F_GETFD);</span><br><span class="line">        <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fcntl - F_GETFD&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flags |= FD_CLOEXEC;</span><br><span class="line">        <span class="keyword">if</span> (fcntl(STDOUT_FILENO, F_SETFD, flags) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fcntl - F_SETFD&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, argv[<span class="number">0</span>], (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">    errExit(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何修改close-on-exec标志。</p><h3 id="信号和exec">27.4 信号和<code>exec()</code></h3><p>　　当<code>exec()</code>成功时，调用<code>exec()</code>的程序会被替换，该程序设置的信号处理函数也会被丢弃。由于信号处理函数消失，内核会将对应的信号的处理方式设置为<code>SIG_DFL</code>，其他信号 (处理方式是<code>SIG_IGN</code>或<code>SIG_DFL</code>) 的处理方式保持不变。这种行为是SUSv3的要求。</p><p>　　SUSv3没有说明处理方式是被忽略的信号<code>SIGCHLD</code>在<code>exec()</code>成功后处理方式保持不变还是被设置为<code>SIG_DFL</code>。Linux采用前者，而有些UNIX实现 (例如，Solaris) 采用后者。为了保证可移植性，对于会忽略信号<code>SIGCHLD</code>的程序，在调用<code>exec()</code>前应先将该信号的处理方式设置为<code>SIG_DFL</code>，并保证<code>exec()</code>调用的程序默认信号<code>SIGCHLD</code>的处理方式是<code>SIG_DFL</code>。</p><p>　　旧程序的数据、栈和堆被丢弃表示通过<code>sigaltstack()</code>定义的备用信号栈也会被丢弃，所以所有信号的标志<code>SA_ONSTACK</code>也会被清除。</p><p>　　<code>exec()</code>成功时进程的信号掩码和待处理信号集保持不变。该特性允许信号继续阻塞和排队。但是，SUSv3指出，很多现有应用程序错误地假设它们启动时特定信号的处理方式是<code>SIG_DFL</code>或这些信号未被阻塞。</p><h3 id="system">27.5 <code>system()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure><p>　　库函数<code>system()</code>会创建1个子进程，子进程会调用shell来执行<code>command</code>。</p><p>　　<code>system()</code>的主要优点是简单和便利：</p><p>　　● 无需处理调用<code>fork()</code>、<code>exec()</code>、<code>wait()</code>和<code>exit()</code>的细节。</p><p>　　● 错误和信号处理函数由<code>system()</code>代为执行。</p><p>　　● 由于<code>system()</code>使用shell执行<code>command</code>，所以执行<code>command</code>前会对其进行常规的shell处理、替换和重定向。这使得在应用程序中添加 "执行shell命令" 的功能很简单 (很多交互式应用程序都以!命令的形式提供该功能)。</p><p>　　<code>system()</code>的主要缺点是效率低。通过该函数执行命令需要至少创建2个进程，1个进程用于shell，其他进程用于执行命令 (这些进程都会调用<code>exec()</code>)。若存在效率或速度要求，显式调用<code>fork()</code>和<code>exec()</code>是更好的选择。</p><p>　　<code>system()</code>的返回值如下：</p><p>　　● 若<code>command</code>为<code>NULL</code>，则<code>system()</code>在shell可用时返回非0值，shell不可用时返回0。这是C标准的要求，不依赖于任何操作系统，所以非UNIX系统调用<code>system()</code>时shell可能不可用。尽管所有UNIX实现都有shell，但如果程序在调用<code>system()</code>前调用<code>chroot()</code>，则shell也可能不可用。</p><p>　　● 若无法创建子进程或无法获取子进程的终止状态，则<code>system()</code>返回-1。</p><p>　　● 若子进程无法执行shell，则<code>system()</code>的返回值就像子进程调用<code>_exit(127)</code>终止一样。</p><p>　　● 若所有系统调用都成功，则<code>system()</code>返回执行命令的shell的终止状态 (shell的终止状态是它指向的最后1条命令的终止状态)。</p><p>　　对于最后2种情况，<code>system()</code>的返回值使用等待状态值的格式 (见26.1.3)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_system.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_wait_status.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CMD_LEN 200</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[MAX_CMD_LEN]; <span class="comment">/* system()执行的命令 */</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 读取并执行shell命令 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Command: &quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(str, MAX_CMD_LEN, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        status = system(str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;system() returned: status=0x%04x (%d,%d)\n&quot;</span>,</span><br><span class="line">               (<span class="type">unsigned</span> <span class="type">int</span>)status, status &gt;&gt; <span class="number">8</span>, status &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;system&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) == <span class="number">127</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(Probably) could not invoke shell\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">/* shell成功执行命令 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                printWaitStatus(<span class="literal">NULL</span>, status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>system()</code>的用法。</p><h4 id="避免在set-user-id和set-group-id程序中使用system">27.5.1 避免在set-user-ID和set-group-ID程序中使用<code>system()</code></h4><p>　　当set-user-ID程序和set-group-ID程序以特权用户ID运行时，<span style="background-color:#ff0">绝不能</span>使用<code>system()</code>。即使这些程序不允许用户指定待执行的命令，shell也会依赖各种环境变量来控制其行为，这表示<code>system()</code>的使用会不可避免地为安全漏洞打开大门。</p><p>　　例如，对于较旧的<code>bash</code>，环境变量<code>IFS</code>定义了用于将命令分隔为内部字段的分隔符，这成为了许多成功的系统入侵的源头。若将该环境变量的值设置为<code>a</code>，则字符串<code>shar</code>会被解释为<code>sh</code>及其参数<code>r</code>，这会导致调用另一个shell来执行当前工作目录下的脚本<code>r</code>，而非预期目的 (执行命令<code>shar</code>)。该漏洞是通过将该环境变量的值指定为仅由shell扩展产生的词来修复。此外，现代shell在启动时会将该环境变量重置为由空格、制表符和换行符这3个字符组成的字符串。为了进一步地保证安全，当<code>bash</code>被set-user-ID程序 (或set-group-ID程序) 调用时，它会还原为实际用户ID (或实际组ID)。</p><p>　　需要产生其他程序的安全程序应该直接调用<code>fork()</code>以及<code>execlp()</code>和<code>execvp()</code>之外的<code>exec()</code>函数。</p><h4 id="实现system">27.5.2 实现<code>system()</code></h4><p>　　命令<code>sh</code>的选项<code>-c</code>提供了1种简单的方法来执行任意shell命令。因此，为了实现<code>system()</code>，需要调用<code>fork()</code>来创建子进程，子进程调用<code>execl("/bin/sh", "sh", "-c", command, (char *) NULL)</code>。为了获取子进程的状态，还需要调用<code>waitpid()</code>。<code>system()</code>的简单但不完整实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* simple_system.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 */</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command, (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="keyword">if</span> (waitpid(childPid, &amp;status, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在system中正确处理信号">27.5.2.1 在<code>system()</code>中正确处理信号</h5><p>　　第1个考虑的信号是<code>SIGCHLD</code>。假设调用<code>system()</code>的程序也会创建子进程，并且注册了<code>SIGCHLD</code>处理函数。当<code>system()</code>创建的子进程终止时，也会生成信号<code>SIGCHLD</code>，这可能会导致<code>system()</code>调用<code>waitpid()</code>前被主函数注册的<code>SIGCHLD</code>处理函数中断 (这也属于竞争条件)，进而产生2个问题：</p><p>　　● 调用<code>system()</code>的程序错误地认为它创建的子进程已终止。</p><p>　　● <code>system()</code>无法获取它创建的子进程的终止状态。</p><p>　　因此，<code>system()</code>执行期间必须阻塞信号<code>SIGCHLD</code>。</p><p>　　还需要考虑由终端中断字符 (通常是Control-C) 生成的信号<code>SIGINT</code>和终端退出字符 (通常是Control-\) 生成的信号<code>SIGQUIT</code>。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_27/arrangement_of_processes_during_execution_of_system.svg" title="arrangement_of_processes_during_execution_of_system"><p>　　在执行<code>system("sleep 20")</code>期间会存在3个运行中的进程：执行调用程序的进程、shell和<code>sleep</code> (若传递给选项<code>-c</code>的命令是简单命令，则<code>bash</code>等shell会直接执行该命令，而非创建子shell来执行该命令。因此，另一种可能是只有2个运行中的进程：执行调用程序的进程和<code>sleep</code>)。</p><p>　　这3个进程都是终端前台进程组的一部分，所以当在终端输入中断字符或退出字符时，对应的信号会发送给这3个进程。shell在等待子进程时会忽略信号<code>SIGINT</code>和<code>SIGQUIT</code>。但是，调用进程和<code>sleep</code>进程默认会被这些信号终止。为此，SUSv3做出了以下规定：</p><p>　　● 当执行命令时，调用进程应该忽略信号<code>SIGINT</code>和<code>SIGQUIT</code>。</p><p>　　● 对于子进程，信号<code>SIGINT</code>和<code>SIGQUIT</code>应该像调用进程执行<code>fork()</code>和<code>exec()</code>时一样被处理，即将这2个信号的处理方式设置为<code>SIG_DFL</code>，其他信号的处理方式保持不变。</p><p>　　按照SUSv3规定的方式处理信号是最合理的方法，原因如下：</p><p>　　● 同时让调用进程和子进程都响应信号是不合理的，因为这可能导致应用程序用户的行为混乱。</p><p>　　● 同样，在执行命令时忽略这些信号，而在调用进程中按照默认处理方式处理这些信号，也是不合理的。这样用户就可以在执行命令时终止调用进程。这也与调用进程在执行传递给<code>system()</code>的命令时已放弃控制权 (即阻塞在调用<code>waitpid()</code>) 的事实不符。</p><p>　　● <code>system()</code>执行的命令可能是交互式应用程序，所以它可能需要响应终端生成的信号。</p><p>　　此外，SUSv3指出上述行为可能会对隐式使用<code>system()</code>执行某些任务的程序产生副作用。当执行命令时，输入终端中断字符或退出字符只会终止<code>system()</code>的子进程，而应用程序继续运行 (出乎用户意料) 。以这种方式使用<code>system()</code>的程序应该检查<code>system()</code>返回的终止状态，并在检测到命令被信号终止时采取合适的行为。</p><h5 id="改进的system实现">27.5.2.2 改进的<code>system()</code>实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* system.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> blockMask, origMask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">saIgnore</span>, <span class="title">saOrigQuit</span>, <span class="title">saOrigInt</span>, <span class="title">saDefault</span>;</span></span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line">    <span class="type">int</span> status, savedErrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> system(<span class="string">&quot;:&quot;</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 阻塞信号SIGCHLD */</span></span><br><span class="line">    sigemptyset(&amp;blockMask);</span><br><span class="line">    sigaddset(&amp;blockMask, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;blockMask, &amp;origMask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 忽略信号SIGINT和SIGQUIT */</span></span><br><span class="line">    saIgnore.sa_handler = SIG_IGN;</span><br><span class="line">    saIgnore.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;saIgnore.sa_mask);</span><br><span class="line">    sigaction(SIGINT, &amp;saIgnore, &amp;saOrigInt);</span><br><span class="line">    sigaction(SIGQUIT, &amp;saIgnore, &amp;saOrigQuit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        status = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程：执行命令 */</span></span><br><span class="line">        saDefault.sa_handler = SIG_DFL;</span><br><span class="line">        saDefault.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigemptyset(&amp;saDefault.sa_mask);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (saOrigInt.sa_handler != SIG_IGN)</span><br><span class="line">        &#123;</span><br><span class="line">            sigaction(SIGINT, &amp;saDefault, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (saOrigQuit.sa_handler != SIG_IGN)</span><br><span class="line">        &#123;</span><br><span class="line">            sigaction(SIGQUIT, &amp;saDefault, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;origMask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command, (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程：等待子进程终止 */</span></span><br><span class="line">        <span class="keyword">while</span> (waitpid(childPid, &amp;status, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                status = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解除对信号SIGCHLD的阻塞, 恢复信号SIGINT和SIGQUIT处理方式 */</span></span><br><span class="line">    savedErrno = errno;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;origMask, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGINT, &amp;saOrigInt, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGQUIT, &amp;saOrigQuit, <span class="literal">NULL</span>);</span><br><span class="line">    errno = savedErrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是符合上述规则的<code>system()</code>实现。</p><p>　　● 如前所述，若<code>command</code>为<code>NULL</code>，则<code>system()</code>在shell可用时返回非0值，shell不可用时返回0。要可靠地获取该信息，唯一的方法就是尝试执行shell。命令<code>:</code>是1个没有实际作用的shell内置命令，并且总是返回成功状态。因此，这里通过<code>system()</code>执行该命令来判断shell是否可用 (第15~18行)。仅通过<code>access()</code>来判断文件<code>/bin/sh</code>是否存在以及是否已启用执行权限是不够的。对于<code>chroot()</code>环境，即使shell文件存在，但如果它是动态链接的，则它可能因无法链接共享库而无法使用。</p><p>　　● 只有父进程 (调用<code>system()</code>的进程) 需要阻塞信号<code>SIGCHLD</code> (第21~23行) 以及忽略信号<code>SIGINT</code>和<code>SIGQUIT</code> (第26~30行)。但是，为了防止产生竞争条件，阻塞和忽略操作必须先于<code>fork()</code>。因此，子进程必须取消这些操作 (第39~52行)。</p><p>　　● 对于父进程，这里选择忽略来自<code>sigaction()</code>和<code>sigprocmask()</code>的错误。这样做有2个原因。首先，这些调用几乎不会出错。实际上，唯一可能出错的地方就是参数指定错误，而这种错误在初步调试时就可以排除。其次，这里假设调用者更想知道<code>fork()</code>或<code>waitpid()</code>是否出错，而非这些信号操作调用是否出错。出于类似的原因，这里在<code>system()</code>的末尾进行保存和恢复<code>errno</code>的操作 (第70~74行)，这可以保证<code>fork()</code>或<code>waitpid()</code>出错时调用者可以确定原因。若由于信号操作调用出错而返回-1，则调用者可能错误地认为<code>system()</code>执行<code>command</code>出错 (SUSv3仅规定<code>system()</code>在无法创建子进程或无法获取子进程的状态时返回-1，没有提及由于信号操作调用出错而返回-1)。</p><p>　　● 对于子进程，没有对信号相关的系统调用进行错误检查 (第39~52行)，因为无法报告这些错误 (<code>_exit(127)</code>的目的是在执行shell时报告错误)，并且这些错误也不会影响<code>system()</code>的调用者。</p><p>　　● 子进程从<code>fork()</code>返回时信号<code>SIGINT</code>和<code>SIGQUIT</code>的处理方式设置是<code>SIG_IGN</code>。但是，对于子进程，这些信号应该被视为<code>system()</code>的调用者调用了<code>fork()</code>和<code>exec()</code>。<code>fork()</code>不会修改子进程的信号处理方式，<code>exec()</code>只会将这些信号的处理方式设置为<code>SIG_DFL</code>。因此，若调用进程未忽略信号<code>SIGINT</code>和<code>SIGQUIT</code>，则子进程会将这些信号的处理方式设置为<code>SIG_DFL</code> (第43~50行)。有些<code>system()</code>实现会将信号<code>SIGINT</code>和<code>SIGQUIT</code>的处理方式设置为调用者的处理方式，因为后续的<code>exec()</code>会自动将已注册处理函数的信号的处理方式设置为<code>SIG_DFL</code>。但是，若调用者正在处理这些信号中的任意1个，则可能会导致隐患。在这种情况下，若信号在子进程调用<code>exec()</code>之前的短暂时间内被发送给子进程，则子进程通过<code>sigprocmask()</code>解除对信号的阻塞后会调用信号处理函数。</p><p>　　● 当子进程调用<code>exec()</code>出错时，这里使用<code>_exit()</code>终止子进程 (第55行)，以防止刷新子进程的stdio缓冲区中的任何未写入的数据。</p><p>　　● 对于父进程，必须使用<code>waitpid()</code>来专门等待用于执行shell的子进程 (第58~65行)。若使用<code>wait()</code>，则可能无意中获取其他子进程的状态。</p><p>　　● 尽管<code>system()</code>实现不需要使用信号处理函数，但调用程序可能已经注册了信号处理函数，这些信号处理函数可能会中断对<code>waitpid()</code>的阻塞调用。对于这种情况，SUSv3明确要求重新开始等待。因此，这里选择在循环中调用<code>waitpid()</code>，若<code>waitpid()</code>出现错误<code>EINTR</code>，则会重启；若<code>waitpid()</code>出现其他错误，则终止循环 (第58~65行)。</p><h5 id="关于system的更多细节">27.5.2.3 关于<code>system()</code>的更多细节</h5><p>　　可移植应用程序应该确保信号<code>SIGCHLD</code>的处理方式为<code>SIG_IGN</code>时不调用<code>system()</code>，因为这种情况下无法通过<code>waitpid()</code>获取子进程的状态 (忽略信号<code>SIGCHLD</code>会导致子进程的状态立即被丢弃)。但是，对于有些UNIX实现，<code>system()</code>在这种情况下会临时将<code>SIGCHLD</code>的处理方式修改为<code>SIG_DFL</code>。这是可行的，只要这些UNIX实现会在这种情况下回收僵尸子进程 (不同于Linux)。</p><p>　　对于<code>/bin/sh</code>不是标准POSIX shell的UNIX实现 (例如，Solaris)，若需要确保执行的是标准shell，则必须通过库函数<code>confstr()</code>来获取配置变量<code>_CS_PATH</code>的值，该值是目录列表 (使用环境变量<code>PATH</code>的值的格式)，其中包含标准系统工具。然后，可以将该值复制给环境变量<code>PATH</code>的值并通过<code>execlp()</code>来执行标准shell。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> path[PATH_MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (confstr(_CS_PATH, path, PATH_MAX) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _exit(<span class="number">127</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setenv(<span class="string">&quot;PATH&quot;</span>, path, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _exit(<span class="number">127</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execlp(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command, (<span class="type">char</span> *)<span class="literal">NULL</span>);</span><br><span class="line">_exit(<span class="number">127</span>);</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_26/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第26章 监控子进程"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第26章 监控子进程</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_28/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第28章 详述进程创建和程序执行">《Linux/UNIX系统编程手册》第28章 详述进程创建和程序执行 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>