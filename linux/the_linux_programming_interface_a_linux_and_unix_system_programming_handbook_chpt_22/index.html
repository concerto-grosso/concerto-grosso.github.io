<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_22/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_22/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_22/","title":"《Linux/UNIX系统编程手册》第22章 信号：高级特性"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第22章 信号：高级特性 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6"><span class="nav-text">22.1 核心转储文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%9F%E6%88%90%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="nav-text">22.2 硬件生成的信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#signal%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="nav-text">22.3 signal()的实现和可移植性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7"><span class="nav-text">22.4 实时信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7"><span class="nav-text">22.4.1 发送实时信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7"><span class="nav-text">22.4.2 处理实时信号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigsuspend"><span class="nav-text">22.5 sigsuspend()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sigwaitinfo%E5%92%8Csigtimedwait"><span class="nav-text">22.6 sigwaitinfo()和sigtimedwait()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#signalfd"><span class="nav-text">22.7 signalfd()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BF%A1%E5%8F%B7%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-text">22.8 通过信号进行进程间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A9%E6%9C%9F%E4%BF%A1%E5%8F%B7api"><span class="nav-text">22.9 早期信号API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#system-v%E4%BF%A1%E5%8F%B7api"><span class="nav-text">22.9.1 System V信号API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bsd%E4%BF%A1%E5%8F%B7api"><span class="nav-text">22.9.2 BSD信号API</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_22/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第22章 信号：高级特性 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第22章 信号：高级特性</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-04-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-04-28T00:00:00+08:00">2025-04-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-04-30 00:00:00" itemprop="dateModified" datetime="2025-04-30T00:00:00+08:00">2025-04-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>25k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　特定信号会导致进程生成核心转储文件并终止，核心转储文件是进程终止时的内存映像 (术语core源于早期内存技术)。在默认情况下，生成的核心转储文件位于进程的工作目录，并且名为<code>core</code>。</p><p>　　很多UNIX实现都提供了用于获取运行中的进程的核心转储文件的工具 (例如，FreeBSD和Solaris的<code>gcore</code>)，Linux也提供了类似的功能：将运行中的进程附加到gdb，然后使用命令<code>gcore</code>。</p><p>　　核心转储文件在以下情况不会生成：</p><p>　　● 进程没有权限写核心存储文件，这可能是因为进程没有要创建核心转储文件的目录的写权限，或者同名的文件已经存在，并且该文件不可写入或不是常规文件 (例如，目录或符号链接)。</p><p>　　● 同名的常规文件已存在，并且可写，但该文件至少有2个硬链接。</p><p>　　● 要创建核心转储文件的目录不存在。</p><p>　　● 进程的核心转储文件大小资源限制 (<code>RLIMIT_CORE</code>) 为0。</p><p>　　● 进程的文件大小资源限制 (<code>RLIMIT_FSIZE</code>) 为0。</p><p>　　● 进程正在执行的二进制可执行文件未启用读权限 (为了防止用户使用核心转储文件来获取没有读权限的程序的代码副本)。</p><p>　　● 当前工作目录所在的文件系统挂载为只读、已满或i-node已用完，或者用户已达到文件系统的配额限制。</p><p>　　● 由所有者 (或所属组) 之外的用户运行的set-user-ID程序 (或set-group-ID程序) 不会生成核心转储文件 (为了防止用户使用核心转储文件来获取安全程序的内存映像并提取密码等敏感信息)。</p><p>　　特定于Linux的系统调用<code>prctl()</code>的操作<code>PR_SET_DUMPABLE</code>可用于设置进程的标志<code>dumpable</code>，以便由所有者 (或所属组) 之外的用户运行的set-user-ID程序 (或set-group-ID程序) 也能生成核心转储文件。Linux 2.4及以上版本开始支持操作<code>PR_SET_DUMPABLE</code>。此外，从内核2.6.13开始，文件<code>/proc/sys/fs/suid_dumpable</code>提供了set-user-ID程序 (或set-group-ID程序) 是否生成核心转储文件的系统级控制。</p><p>　　有时，内核会让进程睡眠，睡眠状态包括<code>TASK_INTERRUPTIBLE</code>和<code>TASK_UNINTERRUPTIBLE</code>。</p><p>　　● <code>TASK_INTERRUPTIBLE</code>表示进程正在等待某些事件 (例如，终端输入、数据写入到当前为空的无名管道或System V信号量的值增加)。进程处于此状态的时间是不固定的。若信号的目标进程处于此状态，则操作会被中断，并且目标进程会在信号到达时被唤醒。在命令<code>ps</code>打印的结果中，处于此状态的进程的STAT (进程状态) 字段是S。</p><p>　　● <code>TASK_UNINTERRUPTIBLE</code>表示进程正在等待特定类型的事件 (例如，磁盘I/O的完成)。进程处于此状态的时间通常很短。若信号的目标进程处于此状态，则信号只会在目标进程<span style="background-color:#ff0">退出此状态</span>后传递。在命令<code>ps</code>打印的结果中，处于此状态的进程的STAT字段是D。</p><p>　　Linux和大部分UNIX实现都提供了这2个状态。Linux从内核2.6.25开始支持睡眠状态<code>TASK_KILLABLE</code>。此状态与<code>TASK_UNINTERRUPTIBLE</code>类似，但处于此状态的进程在收到能够终止进程的信号时会被唤醒。</p><span id="more"></span><p>　　<span style="background-color:#ff0">无法</span>修改信号<code>SIGKILL</code>和<code>SIGSTOP</code>的处理方式，试图通过<code>signal()</code>和<code>sigaction()</code>修改这2个信号的处理方式会导致错误。因此，这2个信号总是会终止和停止进程 (除非进程由于硬件故障、NFS问题或内核漏洞等情况而一直处于睡眠状态<code>TASK_UNINTERRUPTIBLE</code>)。</p><p>　　信号<code>SIGCONT</code>总是会恢复停止的进程，即使目标进程当前阻塞或忽略了该信号 (若目标进程阻塞了该信号，并且注册了信号处理函数来捕获该信号，则在目标进程恢复后，信号处理函数只会在解除阻塞该信号后调用)。若发送给停止进程的是其他信号，则信号的传递实际发生会在进程恢复后 (唯一的例外是信号<code>SIGKILL</code>，该信号甚至会终止已停止的进程)。</p><p>　　当进程收到信号<code>SIGCONT</code>时，该进程的所有待处理的停止信号都会被丢弃。相反，当进程收到停止信号时，该进程的所有待处理的<code>SIGCONT</code>都会被丢弃。这是为了防止进程被<code>SIGCONT</code>恢复后，再次被先于<code>SIGCONT</code>发送的停止信号停止 (以及相反的情况)。</p><p>　　若程序执行时发现终端生成的信号的处理方式已经被设置为<code>SIG_IGN</code>，则程序通常<span style="background-color:#ff0">不应该</span>修改该信号的处理方式。</p><p>　　如前所述，进程通常无法预测信号何时传递，这仅适用于<span style="background-color:#ff0">异步生成</span>的信号，即信号由内核或其他进程发送，用于通知目标进程发生了与目标进程的执行无关的事件 (例如，用户在终端输入中断字符或子进程终止)。在某些情况下，进程的执行流程包括生成信号 (例如，执行会导致硬件异常的指令或发送信号给自己)。此时，信号是<span style="background-color:#ff0">同步生成</span>的，并且信号会立即传递 (除非信号已被阻塞)。换句话说，对于同步生成的信号，信号的传递是可预测和可重现的。</p><p>　　同步生成的信号会立即传递。例如，当进程调用<code>raise()</code>时，信号的传递会先于<code>raise()</code>返回。对于异步生成的信号，信号可能会短时间内处于待处理状态 (即使信号未被阻塞)，因为内核只会在为了执行目标进程而从内核模式切换到用户模式时传递待处理信号，这表示信号实际是在目标进程再次被调度 (即时间片的开始) 或系统调用完成 (信号的传递可能导致阻塞系统调用提前完成) 时传递。</p><p>　　当通过<code>sigprocmask()</code>解除阻塞多个待处理信号时，这些信号都会立即传递给目标进程。在当前的实现中，Linux会按照信号编号的升序传递这些信号。例如，若待处理的<code>SIGINT</code> (信号2) 和<code>SIGQUIT</code> (信号3) 同时被解除阻塞，则<code>SIGINT</code>会先于<code>SIGQUIT</code>传递，无论它们的生成顺序如何。但是，SUSv3规定，这种情况下的标准信号的传递顺序是实现定义的。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_22/delivery_of_multiple_unblocked_signals.svg" title="delivery_of_multiple_unblocked_signals"><p>　　当多个未阻塞的信号等待传递时，若在执行按序第1个信号的处理函数期间出现了内核模式与用户模式之间的切换，则该信号处理函数会被按序第2个信号的处理函数中断，依此类推。</p><p>　　POSIX.1b定义了实时信号来弥补标准信号的不足：</p><p>　　● 标准信号中可用于应用程序定义的目的信号只有2个：<code>SIGUSR1</code>和<code>SIGUSR2</code>，而实时信号中可用于此目的的信号较多。</p><p>　　● 标准信号不会排队，而实时信号会排队。</p><p>　　● 当发送实时信号时，可以指定信号的随附数据 (1个整数或指针值)，对应的处理函数可以获取该数据。</p><p>　　● 不同的实时信号会按序传递。不同的实时信号之间存在优先级，实时信号的编号越小，优先级越高。对于多个相同类型的实时信号，它们会按照发送顺序进行传递。</p><h3 id="核心转储文件">22.1 核心转储文件</h3><p>　　从内核2.6.23开始，特定于Linux的文件<code>/proc/PID/coredump_filter</code>提供了写到核心转储文件的内存映射的类型的进程级控制，对应的值是对应4种内存映射类型的4位掩码，这4种内存映射类型分别是<span style="background-color:#ff0">私有匿名映射</span>、<span style="background-color:#ff0">私有文件映射</span>、<span style="background-color:#ff0">共享匿名映射</span>和<span style="background-color:#ff0">共享文件映射</span>。该值的默认值表示传统Linux行为：仅使用私有匿名映射和共享匿名映射。</p><p>　　从内核2.6开始，核心转储文件的名称可以通过特定于Linux的文件<code>/proc/sys/kernel/core_pattern</code>中的格式字符串控制。在默认情况下，该字符串是<code>core</code>。特权用户可以将该字符串定义为包含以下格式说明符：</p><table><thead><tr><th>格式说明符</th><th>描述</th></tr></thead><tbody><tr><td><code>%c</code></td><td>核心转储文件大小的软资源限制 (Linux 2.6.24及以上版本)</td></tr><tr><td><code>%e</code></td><td>可执行文件名 (没有路径前缀)</td></tr><tr><td><code>%g</code></td><td>转储进程的实际组ID</td></tr><tr><td><code>%h</code></td><td>主机系统名</td></tr><tr><td><code>%p</code></td><td>转储进程的进程ID</td></tr><tr><td><code>%s</code></td><td>终止进程的信号的编号</td></tr><tr><td><code>%t</code></td><td>转储时间 (自纪元以来的秒数)</td></tr><tr><td><code>%u</code></td><td>转储进程的实际用户ID</td></tr><tr><td><code>%%</code></td><td>字符<code>%</code></td></tr></tbody></table><p>　　此外，格式字符串可以包含斜杠<code>/</code>。因此，该字符串不仅可以控制核心转储文件的名称，还可以控制要创建核心转储文件的 (绝对或相对) 目录。</p><p>　　在所有格式说明符都转换后，结果路径名字符串会截断为最多128个字符 (Linux 2.6.19之前是64个字符)。</p><p>　　文件<code>core_pattern</code>从内核2.6.19开始支持额外语法：若该文件包含以管道符<code>|</code>开头的字符串，则剩余字符会解释为程序，并且可以带有命令行参数 (可能包含上表中的格式说明符)。该程序会在转储核心时执行，并且核心转储内容会写入到该程序的标准输入 (而非核心转储文件)。</p><p>　　有些UNIX实现提供了与<code>core_pattern</code>类似的机制。例如，对于BSD衍生实现，可以在文件名后加上程序名 (即<code>core.progname</code>)。Solaris提供了工具<code>coreadm</code>，以允许用户选择核心转储文件的文件名和目录。</p><h3 id="硬件生成的信号">22.2 硬件生成的信号</h3><p>　　信号<code>SIGBUS</code>、<code>SIGFPE</code>、<code>SIGILL</code>和<code>SIGSEGV</code>可以作为硬件异常的结果生成，或者由<code>kill()</code>发送。对于前者，SUSv3规定，当进程从信号处理函数返回以及进程忽略或阻塞了信号时，进程的行为将是未定义的。</p><p>　　● 假设机器语言指令生成这些信号之一，并且随后调用了信号处理函数。当从信号处理函数正常返回时，程序会试图在中断处继续执行。但是，中断处正是导致生成信号的指令，所以信号会再次生成。这种结果通常会导致程序进入无限循环，重复调用信号处理函数。</p><p>　　● 忽略硬件生成的信号几乎没有意义。对于因硬件异常而生成的信号，Linux会保证该信号的传递，即使目标进程忽略了该信号。</p><p>　　● 同样，阻塞硬件生成的信号几乎也没有意义。对于Linux 2.4及以下版本，内核会直接无视进程对硬件生成的信号的阻塞，所以信号会传递给进程，然后终止进程或被信号处理函数捕获。从Linux 2.6开始，若硬件生成的信号被阻塞，则进程会立即被信号终止，即使进程已经为信号注册了处理函数 (Linux 2.6修改硬件生成的信号的处理方式是因为Linux 2.4的处理方式会隐藏漏洞，并且可能导致线程程序出现死锁)。</p><p>　　处理硬件生成的信号的正确方法是不改变这些信号的默认处理方式 (终止进程) 或为这些信号注册不会正常返回的处理函数，即调用<code>_exit()</code>终止进程或调用<code>siglongjmp()</code>进行非本地跳转来保证控制权会转移给其他位置 (而非生成该信号的指令)。</p><h3 id="signal的实现和可移植性">22.3 <code>signal()</code>的实现和可移植性</h3><p>　　这里将介绍如何通过<code>sigaction()</code>实现<code>signal()</code>。实现方式很简单，但需要考虑到1个事实：从历史和不同的UNIX实现角度，<code>signal()</code>具有不同的语义。早期信号实现不可靠，所以会导致以下情况：</p><p>　　● 在进入信号处理函数时，信号的处理方式会被设置为<code>SIG_DFL</code> (对应20.10中的标志<code>SA_RESETHAND</code>)。为了在同一信号再次到达时能够调用该信号处理函数，需要调用<code>signal()</code>来再次注册该信号处理函数。这种情况的问题在于进入信号处理函数与重新注册信号处理函数之间存在空窗期。在此期间，若信号再次到达，则会根据默认处理方式处理。</p><p>　　● 信号处理函数执行时未阻塞对应的信号 (对应20.10中的标志<code>SA_NODEFER</code>)。因此，若信号处理函数执行时对应的信号再次到达，则会再次调用该信号处理函数。当信号短时间内多次到达时，反复调用信号处理函数可能会导致栈溢出。</p><p>　　除了信号不可靠之外，早期UNIX实现还没有提供自动重启系统调用的机制。</p><p>　　4.2BSD的可靠信号解决了这些问题，其他几个UNIX实现也纷纷效仿。但是，旧语义依旧存在于System V实现的<code>signal()</code>中，并且SUSv3和C99等同时代的标准故意没有说明<code>signal()</code>的这些方面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* signal.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> sig, <span class="type">sighandler_t</span> handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newDisp</span>, <span class="title">prevDisp</span>;</span></span><br><span class="line"></span><br><span class="line">    newDisp.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;newDisp.sa_mask);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OLD_SIGNAL</span></span><br><span class="line">    newDisp.sa_flags = SA_RESETHAND | SA_NODEFER;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    newDisp.sa_flags = SA_RESTART;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(sig, &amp;newDisp, &amp;prevDisp) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SIG_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> prevDisp.sa_handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是结合了以上信息得到的<code>signal()</code>实现。在默认情况下，该实现会使用现代信号语义。若编译时使用了选项<code>–DOLD_SIGNAL</code>，则会使用不可靠信号语义，并且不会自动重启系统调用。</p><p>　　Linux内核提供了<code>signal()</code>的不可靠信号语义的系统调用版本。但是，glibc通过提供基于<code>sigaction()</code>的<code>signal()</code>库函数来绕过该系统调用。glibc的<code>signal()</code>库函数实现随着时间的推移而变化。对于较新的glibc版本 (glibc 2及以上版本)，默认使用现代信号语义。对于较旧的版本，使用的是不可靠信号语义 (兼容System V)。</p><p>　　当需要使用不可靠信号语义的现代版本glibc时，可以使用非标准函数 <code>sysv_signal()</code>来代替<code>signal()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*sysv_signal(<span class="type">int</span> sig, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>); <span class="comment">/* 成功时返回目标信号的旧处理方式，出错时返回SIG_ERR */</span></span><br></pre></td></tr></table></figure><p>　　<code>sysv_signal()</code>的参数与<code>signal()</code>的相同。若编译时没有定义功能测试宏<code>_BSD_SOURCE</code>，则glibc会隐式地将所有对<code>signal()</code>的调用都替换为对该函数的调用 (所以<code>signal()</code>会使用不可靠信号语义)。在默认情况下，功能测试宏<code>_BSD_SOURCE</code>会被定义。但是，若编译时定义了<code>_SVID_SOURCE</code>或<code>_XOPEN_SOURCE</code>等其他功能测试宏，则该功能测试宏会被禁用 (除非显式定义了该功能测试宏)。</p><h3 id="实时信号">22.4 实时信号</h3><p>　　SUSv3要求实现提供的实时信号数至少为<code>_POSIX_RTSIG_MAX</code> (定义为8)。Linux内核提供了32个实时信号，编号为32到63。头文件<code>signal.h</code>定义了常量<code>RTSIG_MAX</code>、<code>SIGRTMIN</code>和<code>SIGRTMAX</code>。第1个常量表示可用的实时信号的数量，后2个常量表示实时信号的编号的最小值和最大值。</p><p>　　对于使用LinuxThread线程实现的系统，<code>SIGRTMIN</code>定义为35 (而非32)，以允许LinuxThread内部使用前3个实时信号。对于使用NPTL线程实现的系统，<code>SIGRTMIN</code>定义为34，以允许NPTL内部使用前2个实时信号。</p><p>　　实时信号不像标准信号那样由不同的常量标识。但是，应用程序不应该通过编号来引用实时信号，因为实时信号的编号范围因UNIX实现而异。相反，应该以<code>SIGRTMIN + n</code>的形式来引用实时信号。</p><p>　　此外，SUSv3不要求<code>SIGRTMIN</code>和<code>SIGRTMAX</code>为简单的整数值，所以这2个常量可能定义为函数 (Linux就是如此)。</p><p>　　排队的实时信号 (和随附数据) 需要内核为所有进程都维护相关数据结构，这会占用内核内存，所以内核对排队的实时信号的数量施加了限制。</p><p>　　SUSv3允许实现对进程的排队的实时信号的数量设置上限，并要求该限制至少为<code>_POSIX_SIGQUEUE_MAX</code> (定义为32)。实现可以定义常量<code>SIGQUEUE_MAX</code>来表示排队的实时信号的数量限制，其值可以通过以下调用获取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lim = sysconf(_SC_SIGQUEUE_MAX);</span><br></pre></td></tr></table></figure><p>　　对于Linux，该调用会返回-1，因为Linux使用不同的模型来限制排队的实时信号的数量。</p><p>　　● 对于Linux 2.6.27及以下版本，内核使用系统级限制来限制所有进程的排队的实时信号的数量。该限制可以通过特定于Linux的文件<code>/proc/sys/kernel/rtsig-max</code>获取，并且可以修改 (需要特权)。该限制默认为1024。当前排队的实时信号的数量可以通过特定于Linux的文件<code>/proc/sys/kernel/rtsig-nr</code>获取。</p><p>　　● 对于Linux 2.6.28及以上版本，模型发生了改变，并且删除了之前的<code>/proc</code>接口。对于新模型，软资源限制<code>RLIMIT_SIGPENDING</code>定义了特定实际用户ID的所有进程的排队的实时信号的数量总和。</p><p>　　为了在2个进程之间传递实时信号，SUSv3做出了以下规定：</p><p>　　● 发送进程使用系统调用<code>sigqueue()</code>来发送实时信号和随附数据。<code>kill()</code>、<code>killpg()</code>和<code>raise()</code>也能用于发送实时信号，但SUSv3规定通过这些接口发送的实时信号是否会排队由实现定义。对于Linux，通过这些接口发送的实时信号会排队，但很多UNIX实现并非如此。</p><p>　　● 接收进程为实时信号注册处理函数时需要指定标志<code>SA_SIGINFO</code> (见21.5)。对于Linux，即使为实时信号注册处理函数时未指定该标志，实时信号也会排队 (尽管无法获取实时信号的随附数据)。但是，SUSv3没有要求实现保证这一点。</p><h4 id="发送实时信号">22.4.1 发送实时信号</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sival_int;</span><br><span class="line">    <span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>sigqueue()</code>会发送参数<code>sig</code>指定的实时信号和参数<code>value</code>指定的随附数据给参数<code>pid</code>指定的进程。通过该系统调用发送实时信号所需的权限与使用<code>kill()</code>所需的权限相同。<code>sig</code>可以指定为0，其含义与<code>kill()</code>的相同。但是，<code>sig</code>不能为负数。</p><p>　　Linux和部分UNIX实现定义了与<code>sigval</code>类似的数据类型<code>sigval_t</code>，但SUSv3没有说明该数据类型，并且有些UNIX没有提供该数据类型。</p><p>　　当排队的实时信号的数量达到上限时，对<code>sigqueue()</code>的调用可能会导致错误<code>EAGAIN</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_sigqueue.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sig, numSigs, j, sigData;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">sv</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s pid sig-num data [num-sigs]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: PID is %ld, UID is %ld\n&quot;</span>, argv[<span class="number">0</span>], (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getuid());</span><br><span class="line"></span><br><span class="line">    sig = getInt(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;sig-num&quot;</span>);</span><br><span class="line">    sigData = getInt(argv[<span class="number">3</span>], GN_ANY_BASE, <span class="string">&quot;data&quot;</span>);</span><br><span class="line">    numSigs = (argc &gt; <span class="number">4</span>) ? getInt(argv[<span class="number">4</span>], GN_GT_0, <span class="string">&quot;num-sigs&quot;</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numSigs; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sv.sival_int = sigData + j;</span><br><span class="line">        <span class="keyword">if</span> (sigqueue(getLong(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>), sig, sv) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigqueue %d&quot;</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>sigqueue()</code>的用法。该程序有4个命令行参数：信号编号、目标进程ID、随附的整数数据和信号数，前3个命令行参数是必须提供的，第4个命令行参数是可选的。若指定了第4个命令行参数，则每次发送实时信号时都会将随附的整数数据加1。</p><h4 id="处理实时信号">22.4.2 处理实时信号</h4><p>　　可以像处理标准信号那样为实时信号注册常规处理函数 (只有1个参数)，也可以通过标志<code>SA_SIGINFO</code>注册包含3个参数的处理函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_sigaction = handler;</span><br><span class="line">act.sa_flags = SA_RESTART | SA_SIGINFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGRTMIN + <span class="number">5</span>, &amp;act, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会通过标志<code>SA_SIGINFO</code>为第6个实时信号注册处理函数。当指定了标志<code>SA_SIGINFO</code>后，第2个传递给信号处理函数的参数是结构体<code>siginfo_t</code>，其中包含关于实时信息的更多信息 (见21.5)。</p><p>　　对于实时信号，结构体<code>siginfo_t</code>的以下成员会被设置：</p><p>　　● 成员<code>si_signo</code>与传递给信号处理函数的第1个参数相同。</p><p>　　● 成员<code>si_code</code>表示信号源，包含21.5的表格中的值之一。对于通过<code>sigqueue()</code>发送的实时信号，该成员的值总是为<code>SI_QUEUE</code>。</p><p>　　● 成员<code>si_value</code>包含发送进程指定给<code>sigqueue()</code>的参数<code>value</code>的值。如前所述，该成员的值的解释由应用程序决定 (若信号是通过<code>kill()</code>发送，则该成员不会包含有效信息)。</p><p>　　● 成员<code>si_pid</code>和<code>si_uid</code>分别包含发送进程的进程ID和实际用户ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* catch_rtsigs.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> handlerSleepTime;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> sigCnt = <span class="number">0</span>; <span class="comment">/* 收到的信号的数量 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> allDone = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数printf()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> * @param si</span></span><br><span class="line"><span class="comment"> * @param ucontext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">siginfoHandler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *si, <span class="type">void</span> *ucontext)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT || sig == SIGTERM) <span class="comment">/* 信号SIGINT和SIGTERM会终止程序 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        allDone = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigCnt++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;caught signal %d\n&quot;</span>, sig);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; si_signo=%d, si_code=%d (%s), &quot;</span>, si-&gt;si_signo, si-&gt;si_code,</span><br><span class="line">           (si-&gt;si_code == SI_USER) ? <span class="string">&quot;SI_USER&quot;</span> : (si-&gt;si_code == SI_QUEUE) ? <span class="string">&quot;SI_QUEUE&quot;</span></span><br><span class="line">                                                                            : <span class="string">&quot;other&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;si_value=%d\n&quot;</span>, si-&gt;si_value.sival_int);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; si_pid=%ld, si_uid=%ld\n&quot;</span>, (<span class="type">long</span>)si-&gt;si_pid, (<span class="type">long</span>)si-&gt;si_uid);</span><br><span class="line"></span><br><span class="line">    sleep(handlerSleepTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    <span class="type">sigset_t</span> prevMask, blockMask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [block-time [handler-sleep-time]]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: PID is %ld\n&quot;</span>, argv[<span class="number">0</span>], (<span class="type">long</span>)getpid());</span><br><span class="line"></span><br><span class="line">    handlerSleepTime = (argc &gt; <span class="number">2</span>) ? getInt(argv[<span class="number">2</span>], GN_NONNEG, <span class="string">&quot;handler-sleep-time&quot;</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为大部分信号都注册处理函数。在处理函数执行期间，阻塞其他所有信号来防止处理函数重复中断 */</span></span><br><span class="line">    sa.sa_sigaction = siginfoHandler;</span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (sig = <span class="number">1</span>; sig &lt; NSIG; sig++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sig != SIGTSTP &amp;&amp; sig != SIGQUIT)</span><br><span class="line">        &#123;</span><br><span class="line">            sigaction(sig, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 可选择阻塞信号并睡眠 */</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigfillset(&amp;blockMask);</span><br><span class="line">        sigdelset(&amp;blockMask, SIGINT);</span><br><span class="line">        sigdelset(&amp;blockMask, SIGTERM);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;blockMask, &amp;prevMask) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: signals blocked - sleeping %s seconds\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        sleep(getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;block-time&quot;</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: sleep complete\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;prevMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!allDone) <span class="comment">/* 等待信号 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何处理实时信号。该程序会捕获信号，然后打印传递给信号处理函数的结构体<code>siginfo_t</code>中的部分成员。该程序有2个可选的命令行参数。若指定了第1个命令行参数，则主函数会阻塞所有信号，然后睡眠该命令行参数指定的秒数。若指定了第2个参数，则信号处理函数在返回前会睡眠该命令行参数指定的秒数；否则，信号处理函数在返回前只会睡眠1秒。</p><p>　　这里将通过22.4.1中的<code>t_sigqueue.c</code>和<code>catch_rtsigs.c</code>来展示实时信号的处理方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./catch_rtsigs 60 &amp;</span></span><br><span class="line">[1] 12842</span><br><span class="line">./catch_rtsigs: PID is 12842</span><br><span class="line">./catch_rtsigs: signals blocked - sleeping 60 seconds</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 12842 54 100 3</span></span><br><span class="line">./t_sigqueue: PID is 12843, UID is 1000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 12842 43 200</span></span><br><span class="line">./t_sigqueue: PID is 12844, UID is 1000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 12842 40 300</span></span><br><span class="line">./t_sigqueue: PID is 12845, UID is 1000</span><br></pre></td></tr></table></figure><p>　　当程序<code>catch_rtsigs</code>完成睡眠后，会打印信号处理函数捕获的信号。最先到达的信号的是编号最小的信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./catch_rtsigs: <span class="built_in">sleep</span> complete</span></span><br><span class="line">caught signal 40</span><br><span class="line"> si_signo=40, si_code=-1 (SI_QUEUE), si_value=300</span><br><span class="line"> si_pid=12845, si_uid=1000</span><br><span class="line">caught signal 43</span><br><span class="line"> si_signo=43, si_code=-1 (SI_QUEUE), si_value=200</span><br><span class="line"> si_pid=12844, si_uid=1000</span><br></pre></td></tr></table></figure><p>　　剩余的输出是同一实时信号的3个实例 (成员<code>si_value</code>的值反映了发送这些实时信号的顺序)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">caught signal 54</span><br><span class="line"> si_signo=54, si_code=-1 (SI_QUEUE), si_value=100</span><br><span class="line"> si_pid=12843, si_uid=1000</span><br><span class="line">caught signal 54</span><br><span class="line"> si_signo=54, si_code=-1 (SI_QUEUE), si_value=101</span><br><span class="line"> si_pid=12843, si_uid=1000</span><br><span class="line">caught signal 54</span><br><span class="line"> si_signo=54, si_code=-1 (SI_QUEUE), si_value=102</span><br><span class="line"> si_pid=12843, si_uid=1000</span><br></pre></td></tr></table></figure><p>　　最后，通过命令<code>kill</code>来发送信号给程序<code>catch_rtsigs</code> (命令<code>echo $$</code>会打印shell的进程ID)。在打印的信息中，成员<code>si_code</code>是0，表示实时信号由用户进程通过<code>kill()</code>或<code>raise</code>发送：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $$</span></span><br><span class="line">12780</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -40 12842</span></span><br><span class="line">caught signal 40</span><br><span class="line"> si_signo=40, si_code=0 (SI_USER), si_value=0</span><br><span class="line"> si_pid=15354, si_uid=1000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> 12842</span></span><br><span class="line">[1]  + done       ./catch_rtsigs 60</span><br></pre></td></tr></table></figure><h3 id="sigsuspend">22.5 <code>sigsuspend()</code></h3><p>　　假设需要在执行关键代码时临时阻塞信号<code>SIGINT</code>，然后挂起进程，直到信号<code>SIGINT</code>到达。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> prevMask, intMask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;intMask);</span><br><span class="line">sigaddset(&amp;intMask, SIGINT);</span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">sa.sa_handler = handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;intMask, &amp;prevMask) == <span class="number">-1</span>) <span class="comment">/* 阻塞信号SIGINT */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigprocmask - SIG_BLOCK&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关键代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;prevMask, <span class="literal">NULL</span>) == <span class="number">-1</span>) <span class="comment">/* 解除阻塞信号SIGINT */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;sigprocmask - SIG_SETMASK&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若信号SIGINT此时到达，则会导致漏洞 */</span></span><br><span class="line"></span><br><span class="line">pause(); <span class="comment">/* 等待信号SIGINT */</span></span><br></pre></td></tr></table></figure><p>　　信号<code>SIGINT</code>完全可能在第2次调用<code>sigprocmask()</code>之后和调用<code>pause()</code>之前到达，这完全不符合程序的要求：解除阻塞信号<code>SIGINT</code>后，等待该信号的第1次到达。这种依赖于时间的漏洞是竞争条件的示例之一。通常，当多个进程或线程共享同一资源时，才会导致竞争条件。但是，对于这种情况，主函数会与信号处理函数竞争。</p><p>　　为了避免这个问题，需要能够以<span style="background-color:#ff0">原子</span>方式解除阻塞信号并挂起进程的方法，这正是系统调用<code>sigsuspend()</code>的目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>; <span class="comment">/* 返回-1并将errno设置为EINTR或EFAULT */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>sigsuspend()</code>会将调用进程的信号掩码替换为参数<code>mask</code>指向的信号集，然后挂起调用进程，直到信号被信号处理函数捕获并返回。一旦从信号处理函数返回，<code>sigsuspend()</code>就会将调用进程的信号掩码恢复到调用该系统调用之前的值。</p><p>　　调用<code>sigsuspend()</code>等同于以原子方式执行以下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prevMask); <span class="comment">/* 设置信号掩码 */</span></span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prevMask, <span class="literal">NULL</span>); <span class="comment">/* 恢复信号掩码 */</span></span><br></pre></td></tr></table></figure><p>　　尽管<code>sigsuspend()</code>恢复信号掩码的行为可能看似不方便，但在需要反复等待信号时，该行为对避免竞争条件至关重要。在这种情况下，除了调用<code>sigsuspend()</code>期间之外，其他时间必须阻塞信号。</p><p>　　当<code>sigsuspend()</code>被信号中断或<code>mask</code>是无效地址时，会返回-1，前者会导致<code>errno</code>设置为<code>EINTR</code>，后者会导致<code>errno</code>设置为<code>EFAULT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_sigsuspend.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;signal_functions.h&quot;</span> <span class="comment">/* printSigMask()和printPendingSigs()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> gotSigquit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该处理函数调用了非异步信号安全函数printf()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param sig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught signal %d (%s)\n&quot;</span>, sig, strsignal(sig));</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGQUIT)</span><br><span class="line">    &#123;</span><br><span class="line">        gotSigquit = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> loopNum;</span><br><span class="line">    <span class="type">time_t</span> startTime;</span><br><span class="line">    <span class="type">sigset_t</span> origMask, blockMask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    printSigMask(<span class="built_in">stdout</span>, <span class="string">&quot;Initial signal mask is:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;blockMask);</span><br><span class="line">    sigaddset(&amp;blockMask, SIGINT);</span><br><span class="line">    sigaddset(&amp;blockMask, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;blockMask, &amp;origMask) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask - SIG_BLOCK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGQUIT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (loopNum = <span class="number">1</span>; !gotSigquit; loopNum++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=== LOOP %d\n&quot;</span>, loopNum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通过延时几秒来模拟执行关键代码 */</span></span><br><span class="line">        printSigMask(<span class="built_in">stdout</span>, <span class="string">&quot;Starting critical section, signal mask is:\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (startTime = time(<span class="literal">NULL</span>); time(<span class="literal">NULL</span>) &lt; startTime + <span class="number">4</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printPendingSigs(<span class="built_in">stdout</span>, <span class="string">&quot;Before sigsuspend() - pending signals:\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sigsuspend(&amp;origMask) == <span class="number">-1</span> &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigsuspend&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;origMask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask - SIG_SETMASK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printSigMask(<span class="built_in">stdout</span>, <span class="string">&quot;=== Exited loop\nRestored signal mask to:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进行其他处理 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>sigsuspend()</code>的用法。该程序会执行以下步骤：</p><p>　　1) 打印信号掩码的当前值 (第32行)。</p><p>　　2) 阻塞信号<code>SIGINT</code>和<code>SIGQUIT</code>和保存信号掩码的当前值 (第34~40行)。</p><p>　　3) 为信号<code>SIGINT</code>和<code>SIGQUIT</code>注册处理函数。该处理函数会打印捕获的信号，若捕获的信号是<code>SIGQUIT</code>，则还会设置全局变量<code>gotSigquit</code> (第42~52行)。</p><p>　　4) 进行循环，直到全局变量<code>gotSigquit</code>被设置。每次循环会打印信号掩码的当前值、模拟执行关键代码、打印待处理信号以及解除阻塞信号<code>SIGINT</code>和<code>SIGQUIT</code>并等待这2个信号 (第54~70行)。</p><p>　　5) 恢复信号掩码 (第72~75行)。</p><p>　　6) 打印恢复后的信号掩码 (第77行)。</p><h3 id="sigwaitinfo和sigtimedwait">22.6 <code>sigwaitinfo()</code>和<code>sigtimedwait()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 199309</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigwaitinfo</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">siginfo_t</span> *info)</span>; <span class="comment">/* 成功时返回收到的信号的编号，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigtimedwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">siginfo_t</span> *info,</span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>; <span class="comment">/* 成功时返回收到的信号的编号，超时或出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>sigwaitinfo()</code>会挂起调用进程，直到参数<code>set</code>指向的信号集中的信号之一到达。若<code>set</code>指向的信号集中的信号在调用该系统调用时已处于待处理状态，则<code>sigwaitinfo()</code>会立即返回，对应的信号会从进程的待处理信号集中删除，并且其编号会作为函数结果返回。若参数<code>info</code>不为<code>NULL</code>，则它指向的结构体<code>siginfo_t</code>会初始化为包含提供给信号处理函数的参数<code>siginfo</code>的信息 (见21.5)。</p><p>　　<code>sigwaitinfo()</code>的信号到达顺序和排队规则与信号处理函数的相同，即标准信号不会排队，实时信号会排队，并且编号最小的信号最先到达。除了可以省去编写信号处理函数之外，使用<code>sigwaitinfo()</code>等待信号也比信号处理函数加<code>sigsuspend()</code>的组合更快。</p><p>　　系统调用<code>sigtimedwait()</code>是<code>sigwaitinfo()</code>的变体，可以通过参数<code>timeout</code>指定等待时间。若<code>timeout</code>的所有成员都是0，则该系统调用会立即返回 (可用于检测是否存在待处理信号)。若等待超时，则该系统调用会返回-1，并将<code>error</code>设置为<code>EAGAIN</code>。</p><p>　　当将<code>timeout</code>指定为<code>NULL</code>时，<code>sigtimedwait()</code>等同于<code>sigwaitinfo()</code>。SUSv3没有说明将<code>timeout</code>指定为<code>NULL</code>时<code>sigtimedwait()</code>的行为，并且有些UNIX实现将这种情况视为将<code>timeout</code>的所有成员都指定为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_sigwaitinfo.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    <span class="type">siginfo_t</span> si;</span><br><span class="line">    <span class="type">sigset_t</span> allSigs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [delay-secs]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: PID is %ld\n&quot;</span>, argv[<span class="number">0</span>], (<span class="type">long</span>)getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 阻塞所有信号 (除了SIGKILL和SIGSTOP) */</span></span><br><span class="line">    sigfillset(&amp;allSigs);</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;allSigs, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: signals blocked\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 适当延时，以便接收信号 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: about to delay %s seconds\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        sleep(getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;delay-secs&quot;</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: finished delay\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        sig = sigwaitinfo(&amp;allSigs, &amp;si);</span><br><span class="line">        <span class="keyword">if</span> (sig == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigwaitinfo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sig == SIGINT || sig == SIGTERM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got signal: %d (%s)\n&quot;</span>, sig, strsignal(sig));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; si_signo=%d, si_code=%d (%s), si_value=%d\n&quot;</span>,</span><br><span class="line">               si.si_signo, si.si_code,</span><br><span class="line">               (si.si_code == SI_USER) ? <span class="string">&quot;SI_USER&quot;</span> : (si.si_code == SI_QUEUE) ? <span class="string">&quot;SI_QUEUE&quot;</span></span><br><span class="line">                                                                              : <span class="string">&quot;other&quot;</span>,</span><br><span class="line">               si.si_value.sival_int);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; si_pid=%ld, si_uid=%ld\n&quot;</span>, (<span class="type">long</span>)si.si_pid, (<span class="type">long</span>)si.si_uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>sigwaitinfo()</code>的用法。该程序会先阻塞所有信号，然后延时命令行参数指定的秒数。最后，进行循环，直到收到信号<code>SIGINT</code>或<code>SIGTERM</code>，每次循环都会通过<code>sigwaitinfo()</code>等待信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigwaitinfo 60 &amp;</span></span><br><span class="line">./t_sigwaitinfo: PID is 3837</span><br><span class="line">./t_sigwaitinfo: signals blocked</span><br><span class="line">./t_sigwaitinfo: about to delay 60 seconds</span><br><span class="line">[1] 3837</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 3837 43 100</span></span><br><span class="line">./t_sigqueue: PID is 3839, UID is 1000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 3837 42 200</span> </span><br><span class="line">./t_sigqueue: PID is 3840, UID is 1000</span><br></pre></td></tr></table></figure><p>　　先在后台运行程序<code>t_sigwaitinfo</code>，并通过程序<code>t_sigqueue</code>发送实时信号42和43给该程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigwaitinfo: finished delay</span></span><br><span class="line">got signal: 42</span><br><span class="line"> si_signo=42, si_code=-1 (SI_QUEUE), si_value=200</span><br><span class="line"> si_pid=3840, si_uid=1000</span><br><span class="line">got signal: 43</span><br><span class="line"> si_signo=43, si_code=-1 (SI_QUEUE), si_value=100</span><br><span class="line"> si_pid=3839, si_uid=1000</span><br></pre></td></tr></table></figure><p>　　当程序<code>t_sigwaitinfo</code>完成睡眠后，会循环接收排队信号。与实时信号被处理函数捕获一样，可以看到输出结果中编号最小的实时信号最先到达，并且<code>si_pid</code>和<code>si_uid</code>也与发送进程匹配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $$</span></span><br><span class="line">3744</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -USR1 3837</span></span><br><span class="line">got signal: 10</span><br><span class="line"> si_signo=10, si_code=0 (SI_USER), si_value=100</span><br><span class="line"> si_pid=3744, si_uid=1000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> %1</span> </span><br><span class="line">[1]  + done       ./t_sigwaitinfo 60</span><br></pre></td></tr></table></figure><p>　　继续通过命令<code>kill</code>发送信号给程序<code>t_sigwaitinfo</code>，可以看到输出结果中<code>si_code</code>是<code>SI_USER</code>，<code>si_value</code>是100 (该值是收到上一个信号时设置的值，所以该值是无效值)。</p><h3 id="signalfd">22.7 <code>signalfd()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">signalfd</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">sigset_t</span> *mask, <span class="type">int</span> flags)</span>; <span class="comment">/* 成功时返回文件描述符，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　Linux从内核2.6.22开始提供非标准系统调用<code>signalfd()</code>。该系统调用会将创建1个signalfd文件描述符，调用进程可以从该文件描述符中读取信号。参数<code>mask</code>指定希望能够从该文件描述符中读取的信号。与<code>sigwaitinfo()</code>一样，应该将<code>mask</code>中的所有信号阻塞，防止这些信号在被读取前按照默认处理方式处理。</p><p>　　若参数<code>fd</code>指定为-1，则<code>signalfd()</code>会创建signalfd文件描述符；否则，它会修改<code>fd</code>关联的掩码 (<code>fd</code>必须是之前通过<code>signalfd()</code>获取的文件描述符)。</p><p>　　在最初的实现中，参数<code>flags</code>只能指定为0。但是，该参数从Linux 2.6.27开始支持2个标志：<code>SFD_CLOEXEC</code>和<code>SFD_NONBLOCK</code>。前者表示设置新signalfd文件描述符的close-on-exec标志 (<code>FD_CLOEXEC</code>)，后者表示设置底层打开的signalfd文件描述符的标志<code>O_NONBLOCK</code> (以后的读都是非阻塞的)。</p><p>　　当创建signalfd文件描述符后，可以通过对该文件描述符调用<code>read()</code>来读取信号，传递给<code>read()</code>的缓冲区必须足够大，以容纳至少1个结构体<code>signalfd_siginfo</code> (定义在头文件<code>sys/signalfd.h</code>中)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signalfd_siginfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_signo;    <span class="comment">/* 信号编号 */</span></span><br><span class="line">    <span class="type">int32_t</span> ssi_errno;     <span class="comment">/* 错误号 (通常不会使用) */</span></span><br><span class="line">    <span class="type">int32_t</span> ssi_code;      <span class="comment">/* 信号代码 */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_pid;      <span class="comment">/* 发送进程的进程ID */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_uid;      <span class="comment">/* 发送进程的实际用户ID */</span></span><br><span class="line">    <span class="type">int32_t</span> ssi_fd;        <span class="comment">/* 文件描述符 (仅限于信号SIGPOLL/SIGIO) */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_tid;      <span class="comment">/* 内核定时器ID (POSIX定时器) */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_band;     <span class="comment">/* Band event (仅限于信号SIGPOLL/SIGIO) */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_overrun;  <span class="comment">/* 超限计数 (POSIX定时器) */</span></span><br><span class="line">    <span class="type">uint32_t</span> ssi_trapno;   <span class="comment">/* 导致信号生成的陷阱号 */</span></span><br><span class="line">    <span class="type">int32_t</span> ssi_status;    <span class="comment">/* 退出状态或信号 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">int32_t</span> ssi_int;       <span class="comment">/* sigqueue()发送的整数 */</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_ptr;      <span class="comment">/* sigqueue()发送的指针 */</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_utime;    <span class="comment">/* 用户CPU时间 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_stime;    <span class="comment">/* 系统CPU时间 (仅限于信号SIGCHLD) */</span></span><br><span class="line">    <span class="type">uint64_t</span> ssi_addr;     <span class="comment">/* 生成信号的地址 (仅限于硬件生成的信号) */</span></span><br><span class="line">    <span class="type">uint16_t</span> ssi_addr_lsb; <span class="comment">/* 地址的最低有效位 (仅限于信号SIGBUS和Linux 2.6.37及以上版本) */</span></span><br><span class="line">    <span class="type">uint8_t</span> pad[X];        <span class="comment">/* 填充到128字节 (允许以后添加新成员) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　结构体<code>signalfd_siginfo</code>的成员提供的信息与结构体<code>siginfo_t</code>中名称相似的成员相同 (见21.5)。</p><p>　　每次调用<code>read()</code>会返回与待处理信号的数量相同的结构体<code>signalfd_siginfo</code>，但不会超过缓冲区的容量。若调用<code>read()</code>时没有待处理信号，则<code>read()</code>会阻塞，直到信号到达。这里也可以通过<code>fcntl()</code>的操作<code>F_SETFL</code>来设置signalfd文件描述符的标志<code>O_NONBLOCK</code>，随后对该文件描述符的读不会阻塞，并且在没有待处理信号时会导致错误<code>EAGAIN</code>。</p><p>　　当从signalfd文件描述符读取信号后，该信号会消耗，并且不再是进程的待处理信号。</p><p>　　可以使用<code>select()</code>、<code>poll()</code>和epoll来同时监控signalfd文件描述符和其他文件描述符。当存在待处理信号时，signalfd文件描述符会变为可读。</p><p>　　当不再需要signalfd文件描述符时，应该关闭它，以释放关联的内核资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* signalfd_sigval.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    <span class="type">int</span> sfd, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signalfd_siginfo</span> <span class="title">fdsi</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s sig-num...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: PID = %ld\n&quot;</span>, argv[<span class="number">0</span>], (<span class="type">long</span>)getpid());</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sigaddset(&amp;mask, atoi(argv[j]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sfd = signalfd(<span class="number">-1</span>, &amp;mask, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;signalfd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        s = read(sfd, &amp;fdsi, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> signalfd_siginfo));</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> signalfd_siginfo))</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: got signal %d&quot;</span>, argv[<span class="number">0</span>], fdsi.ssi_signo);</span><br><span class="line">        <span class="keyword">if</span> (fdsi.ssi_code == SI_QUEUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;; ssi_pid = %d; &quot;</span>, fdsi.ssi_pid);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ssi_int = %d&quot;</span>, fdsi.ssi_int);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>signalfd()</code>的用法。该程序会创建1个信号集，该信号集由命令行参数指定的信号组成。然后，阻塞这些信号，并创建1个signalfd文件描述符来读取这些信号。最后，进行循环，从signalfd文件描述符中读取信号，并打印返回的结构体<code>signalfd_siginfo</code>中的某些成员的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./signalfd_sigval 44 &amp;</span></span><br><span class="line">./signalfd_sigval: PID = 6267</span><br><span class="line">[1] 6267</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_sigqueue 6267 44 123</span></span><br><span class="line">./t_sigqueue: PID is 6269, UID is 1000</span><br><span class="line">./signalfd_sigval: got signal 44; ssi_pid=6269; ssi_int=123</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> %1</span></span><br></pre></td></tr></table></figure><p>　　这里会通过程序<code>t_sigqueue</code>发送信号44和随附数据123给运行在后台的程序<code>signalfd_sigval</code>。</p><h3 id="通过信号进行进程间通信">22.8 通过信号进行进程间通信</h3><p>　　从某种角度，信号可以认为是进程间通信的形式之一。但是，当将信号作为IPC机制时，会受到很多限制。首先，相比其他IPC机制，使用信号的程序会更繁琐，原因如下：</p><p>　　● 信号的异步性本质会导致很多问题，包括可重入要求、竞争条件和在信号处理函数中正确地处理全局变量 (当使用<code>sigwaitinfo()</code>或<code>signalfd()</code>来同步接收信号时，其中的大部分问题将不会出现)。</p><p>　　● 标准信号不会排队，而实时信号存在排队数量限制。为了防止丢失信息，接收进程必须通过某种方法来通知发送进程它已经准备好接收下一个信号，最直接的方法就是接收进程发送信号给发送进程。</p><p>　　其次，信号能够携带的信息相当有限：信息编号和实时信号的随附数据。</p><p>　　因此，信号很少作为IPC机制。</p><h3 id="早期信号api">22.9 早期信号API</h3><p>　　上述内容都是关于POSIX信号API。这里将简短地介绍System V和BSD提供的信号API。Linux和很多UNIX实现都提供了兼容System V和BSD的信号API。</p><h4 id="system-v信号api">22.9.1 System V信号API</h4><p>　　对于System V，若信号处理函数是通过<code>signal()</code>注册的，则使用的是不可靠信号语义，即信号不会添加到信号掩码，并且当调用信号处理函数后，信号的处理方式会被设置为<code>SIG_DFL</code>，被中断的系统调用不会自动重启。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*sigset(<span class="type">int</span> sig, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>); <span class="comment">/* 成功时返回目标信号的旧处理方式，目标信号被阻塞时返回SIG_HOLD，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sighold</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigrelse</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigignore</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpause</span><span class="params">(<span class="type">int</span> sig)</span>; <span class="comment">/* 总是返回-1并将errno设置为EINTR */</span></span><br></pre></td></tr></table></figure><p>　　为了以可靠信号语义注册信号处理函数，System V提供了函数<code>sigset()</code> (函数原型与<code>signal()</code>的相似)。与<code>signal()</code>相同，<code>sigset()</code>的参数<code>handler</code>可以指定为<code>SIG_IGN</code>、<code>SIG_DFL</code>或信号处理函数的地址。此外，该参数还可以指定为<code>SIG_HOLD</code>，表示将目标信号添加到信号掩码，同时不改变目标信号的处理方式。若<code>handler</code>指定为<code>SIG_HOLD</code>之外的值，则会将目标信号从信号掩码中删除 (若目标信号已被阻塞，则解除阻塞)。</p><p>　　函数<code>sighold()</code>会将参数<code>sig</code>指定的信号添加到信号掩码。函数<code>sigrelse()</code>会从信号掩码中删除参数<code>sig</code>指定的信号。函数<code>sigignore()</code>会将参数<code>sig</code>指定的信号的处理方式设置为忽略。函数<code>sigpause()</code>与<code>sigsuspend()</code>类似，但会在挂起进程前从信号掩码中删除参数<code>sig</code>指定的信号。</p><p>　　SUSv3详细说明了这些函数，但指出对应的现代POSIX信号API是更好的选择。SUSv4将这些函数标记为过时。</p><h4 id="bsd信号api">22.9.2 BSD信号API</h4><p>　　POSIX信号API在很大程度上借鉴了4.2BSD的信号API，所以BSD信号API与对应的POSIX信号API相似。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigvec</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> sigvec *vec, <span class="keyword">struct</span> sigvec *ovec)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回信号掩码的旧值 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigblock</span><span class="params">(<span class="type">int</span> mask)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetmask</span><span class="params">(<span class="type">int</span> mask)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpause</span><span class="params">(<span class="type">int</span> sigmask)</span>; <span class="comment">/* 总是返回-1并将errno设置为EINTR */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigmask</span><span class="params">(<span class="type">int</span> signum)</span>; <span class="comment">/* 返回signum的信号掩码 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigvec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*sv_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> sv_mask;</span><br><span class="line">    <span class="type">int</span> sv_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　函数<code>sigvec()</code>与<code>sigaction()</code>类似。参数<code>vec</code>和<code>ovec</code>都是指向结构体<code>sigvec</code>的指针。结构体<code>sigvec</code>的成员与对应的结构体<code>sigaction</code>成员类似。第1个区别是成员<code>sv_mask</code>的数据类型是<code>int</code>。第2个区别是成员<code>sv_flags</code>的标志<code>SV_INTERRUPT</code>的用法：因为4.2BSD会默认重启系统调用，所以该标志表示系统调用应该被信号处理函数中断。</p><p>　　函数<code>sigblock()</code>会将参数<code>mask</code>指定的信号添加到信号掩码 (与<code>sigprocmask()</code>的操作<code>SIG_BLOCK</code>类似)。函数<code>sigsetmask()</code>会将信号掩码设置为参数<code>mask</code>指定的值 (与<code>sigprocmask()</code>的操作<code>SIG_SETMASK</code>类似)。</p><p>　　函数<code>sigpause()</code>与<code>sigsuspend()</code>类似，该函数在System V和BSD中使用不同的调用签名定义。glibc默认提供System V版本，除非编译程序时定义了功能测试宏<code>_BSD_SOURCE</code>。</p><p>　　函数<code>sigmask()</code>会将参数<code>signum</code>指定的信号编号转换为对应的32位掩码，可以对这种位掩码进行与操作<code>|</code>来获取信号集 (例如，<code>sigblock(sigmask(SIGINT) | sigmask(SIGQUIT))</code>)。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/arm/the_definitive_guide_to_arm_cortex_m3_and_cortex_m4_processors_3e_chpt_02/" rel="prev" title="《ARM Cortex-M3与Cortex-M4权威指南 第3版》第2章 嵌入式软件开发简介"><i class="fa fa-angle-left"></i> 《ARM Cortex-M3与Cortex-M4权威指南 第3版》第2章 嵌入式软件开发简介</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_23/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第23章 定时器和睡眠">《Linux/UNIX系统编程手册》第23章 定时器和睡眠 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>