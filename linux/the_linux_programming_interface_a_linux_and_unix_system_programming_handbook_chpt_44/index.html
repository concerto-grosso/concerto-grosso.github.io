<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/","title":"《Linux/UNIX系统编程手册》第44章 无名管道和有名管道"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第44章 无名管道和有名管道 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-text">44.1 无名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E7%94%A8%E4%BA%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-text">44.1.1 将无名管道用于进程间通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E7%94%A8%E4%BA%8E%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">44.1.2 将无名管道用于进程同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E8%BF%9E%E6%8E%A5%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">44.1.3 使用无名管道连接过滤器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#popen%E5%92%8Cpclose"><span class="nav-text">44.1.4 popen()和pclose()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E4%B8%8Estdio%E7%BC%93%E5%86%B2"><span class="nav-text">44.1.5 无名管道与stdio缓冲</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-text">44.2 有名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E5%92%8C%E5%91%BD%E4%BB%A4tee%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%8F%8C%E7%AE%A1%E9%81%93"><span class="nav-text">44.2.1 使用有名管道和命令tee来创建双管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">44.2.2 使用有名管道的客户端-服务端应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">44.2.2.1 服务器程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="nav-text">44.2.2.2 客户端请求</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9Eio"><span class="nav-text">44.2.3 非阻塞I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E5%92%8C%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84read%E5%92%8Cwrite%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="nav-text">44.3 无名管道和有名管道的read()和write()的语义</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第44章 无名管道和有名管道 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第44章 无名管道和有名管道</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2026-02-21 00:00:00" itemprop="dateCreated datePublished" datetime="2026-02-21T00:00:00+08:00">2026-02-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2026-02-23 00:00:00" itemprop="dateModified" datetime="2026-02-23T00:00:00+08:00">2026-02-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>25k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　无名管道是UNIX系统上最古老的IPC方式，出现于20世纪70年代早期的UNIX第3版中。无名管道为常见需求提供了精简的解决方法：创建2个进程来允许不同程序 (命令)。无名管道可用于相关进程之间的通信。有名管道是无名管道的变体，但可用于任意进程之间的通信。</p><p>　　命令<code>ls | wc -l</code>会统计目录下的文件数。为了执行该命令，shell会创建2个进程来分别执行<code>ls</code>和<code>wc</code>。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/using_a_pipe_to_connect_two_processes.svg"><p>　　上图说明了无名管道名称的由来——可以将无名管道看作管道系统，允许数据从进程流向其他进程。</p><p>　　从无名管道读取数据的进程可以读取任意大小的字节块 (无论写入进程写入的数据块的大小)。此外，数据在无名管道中按序传输——字节的读取顺序和写入顺序完全一致，所以无法使用<code>lseek()</code>随机访问其中的数据。</p><p>　　对当前为空的无名管道的读取操作会被阻塞，直到至少有1个字节被写入到该无名管道。当无名管道写入端关闭后，一旦读取端读取完无名管道中的剩余数据，就会遇到EOF (<code>read()</code>返回0)。</p><p>　　无名管道是单向的，但某些UNIX实现 (尤其是System V Release 4衍生实现) 的无名管道是双向的 (即所谓的<span style="background-color:#ff0">流无名管道</span>)。没有UNIX标准说明双向无名管道，所以应该避免依赖其语义 (即使是那些提供它的实现)。作为替代方案，可以使用UNIX域套接字对 (通过系统调用<code>socketpair()</code>创建)，它提供了标准双向通信机制，其语义等同于流无名管道。</p><p>　　当多个进程向同一无名管道写入时，只要单次写入的数据不超过<code>PIPE_BUF</code>字节，写入的数据就不会交错。</p><p>　　SUSv3要求<code>PIPE_BUF</code>至少为<code>_POSIX_PIPE_BUF</code> (512)。实现应该在头文件<code>limits.h</code>中定义<code>PIPE_BUF</code>或/和允许调用<code>fpathconf(fd, _PC_PIPE_BUF)</code>返回原子写入的实际上限。<code>PIPE_BUF</code>因UNIX实现而异 (例如，FreeBSD 6.0是512，Tru64 5.1是4096，Solaris 8是5120)。对于Linux，其值为4096。</p><p>　　当写入到无名管道的数据块大于<code>PIPE_BUF</code>字节时，内核会将其转换为多个较小的数据块传输，并在读取进程从无名管道中读取字节时追加数据 (<code>write()</code>调用会被阻塞，直到所有数据都被写入到数据)。当只有1个进程向无名管道写入时，这不会导致问题。但是，当存在多个写入进程时，较大的数据块的写入会被分成任意大小的块 (可能小于<code>PIPE_BUF</code>字节)，并与其他进程的写入交错进行。</p><p>　　限制<code>PIPE_BUF</code>决定数据传输到无名管道的具体时间。当写入的数据不超过该限制时，若无名管道中没有足够的空间以便原子地完成操作，则<code>write()</code>将会被阻塞来等待空间。当写入的数据超过该限制时，<code>write()</code>将传输尽可能多的数据来填满无名管道，然后被阻塞，直到无名管道中的数据被读取。当以这种方式被阻塞的<code>write()</code>被信号处理函数中断时，<code>write()</code>会解除阻塞并返回成功写入的字节数，该值小于请求的字节数 (即所谓的<span style="background-color:#ff0">部分写入</span>)。</p><p>　　对于Linux 2.2，向无名管道写入任意数据都是以原子方式完成，除非被信号处理函数中断。对于Linux 2.4及以上版本，若向无名管道写入的数据大于<code>PIPE_BUF</code>字节，则可能与其他进程的写入操作交错进行 (在内核版本2.2和2.4之间，实现无名管道的内核代码发生了重大变化)。</p><span id="more"></span><p>　　无名管道只是内核内存中的缓冲区，该缓冲区有容量限制。一旦达到上限，对无名管道的写入会被阻塞，直到其中的数据被读取。</p><p>　　SUSv3没有要求无名管道的容量。在Linux 2.6.11之前，无名管道容量与系统页大小 (x86-32的页大小是4096字节) 相同。从Linux 2.6.11开始，无名管道的容量为65536字节。UNIX实现的无名管道容量各不相同。</p><p>　　应用程序通常不需要知道无名管道的具体容量。为了防止写入进程被阻塞，读取进程应该被设计为尽可能快地从无名管道中读取数据。</p><p>　　从理论角度，无名管道完全可以以更小的容量运行，即使是单字节缓冲区。但是，使用更大的缓冲区可以提升效率。当写入进程填满无名管道后，内核必须执行上下文切换来让读取进程读取。使用更大的缓冲区表示所需的上下文切换次数更少。</p><p>　　从Linux 2.6.35开始，无名管道的容量可以被修改。特定于Linux的调用<code>fcntl(fd, F_SETPIPE_SZ, size)</code>会将<code>fd</code>引用的无名管道的容量修改为不小于<code>size</code>字节，内核会将<code>size</code>向上取整到某个便于实现的值。非特权进程可以将无名管道的容量修改为从系统页大小到<code>/proc/sys/fs/pipe-max-size</code>中的值之间的任意值。<code>pipe-max-size</code>的默认值为1048576字节。特权进程 (能力<code>CAP_SYS_RESOURCE</code>) 可以超过该限制。调用<code>fcntl(fd, F_GETPIPE_SZ)</code>会返回为无名管道分配的空间的实际大小。</p><h3 id="无名管道">44.1 无名管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> filedes[<span class="number">2</span>])</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>pipe()</code>会创建无名管道。若成功，则会通过数组<code>filedes</code>返回2个打开的文件描述符，分别用于无名管道的读取端 (<code>filedes[0]</code>) 和写入端 (<code>filedes[1]</code>)。</p><p>　　与其他文件描述符相同，可以对<code>pipe()</code>返回的文件描述符调用<code>read()</code>和<code>write()</code>。一旦向无名管道写入端写入数据，数据会立即到达读取端。当从无名管道读取数据时，会获取请求字节数与当前无名管道中可用字节数中较小的值 (若无名管道为空，则会被阻塞)。此外，可以先使用<code>fopen()</code>获取与<code>filedes</code>中某个文件描述符对应的文件流，然后使用stdio函数 (例如，<code>printf()</code>和<code>scanf()</code>) 来操作无名管道。</p><p>　　<code>ioctl(fd, FIONREAD, &amp;cnt)</code>调用会返回<code>fd</code>引用的无名管道或有名管道的待读取字节数。某些其他实现也支持该特性，但SUSv3没有说明该特性。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/setting_up_a_pipe_to_transfer_data_from_a_parent_to_a_child.svg"><p>　　对于单个进程，无名管道的用途很少。无名管道通常用于2个进程之间的通信。为了使用无名管道连接2个进程，需要在调用<code>pipe()</code>后调用<code>fork()</code>。在<code>fork()</code>期间，子进程会继承父进程的文件描述符的副本 (上图左侧的情况)。虽然父进程和子进程都可以读写无名管道，但这并不常见。因此，当<code>fork()</code>完成后，其中的某个进程立即关闭无名管道写入端的文件描述符，而另一个会立即关闭无名管道读取端的文件描述符 (上图右侧的情况)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> filedes[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建无名管道 */</span></span><br><span class="line"><span class="keyword">if</span> (pipe(filedes) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (fork())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">    errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程：关闭无名管道写入端 */</span></span><br><span class="line">    <span class="keyword">if</span> (close(filedes[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 从无名管道读取 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 父进程：关闭无名管道读取端 */</span></span><br><span class="line">    <span class="keyword">if</span> (close(filedes[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 向无名管道写入 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　父进程和子进程都从无名管道读取的情况不常见的原因之一是2个进程同时读取会导致竞争，防止这种竞争需要同步机制。更简单的方法是创建2个无名管道，分别用于2个进程之间的双向数据传输 (这种方法需要注意2个进程在试图读取空无名管道或写入已满的无名管道时被阻塞而导致的死锁)。</p><p>　　虽然多个进程可以向同一无名管道写入，但通常只有1个写入进程。相比之下，多个进程写入同一有名管道有时会很有用。</p><p>　　从内核2.6.27开始，Linux支持非标准系统调用<code>pipe2()</code>。该系统调用执行与<code>pipe()</code>相同的任务，但支持可用于修改其行为的参数<code>flags</code>。该参数支持标志：<code>O_CLOEXEC</code> (启用返回的2个文件描述符的close-on-exec标志) 和 <code>O_NONBLOCK</code> (用于设置返回的2个文件描述符的打开文件状态标志<code>O_NONBLOCK</code>)。</p><p>　　实际上，无名管道也可用于多个相关进程之间的通信。只要无名管道是共同的祖先进程在通过<code>fork()</code>创建子进程前创建的，该无名管道就可以用于多个相关进程之间的通信。此外，通过UNIX域套接字将无名管道的文件描述符传递给无关进程就可以实现无关进程之间的通信。</p><p>　　关闭未使用的无名管道文件描述符不仅仅是为了确保进程不会耗尽其有限的文件描述符集合——这对于正确使用无名管道至关重要。</p><p>　　● 读取进程会关闭无名管道的写入文件描述符。因此，当写入进程完成写入并关闭其写入文件描述符后，读取进程会遇到EOF (一旦从无名管道读取所有数据)。若读取进程没有关闭无名管道的写入文件描述符，则即使写入进程关闭了其写入文件描述符，读取进程也无法遇到EOF (即使它已从无名管道中读取所有数据)。相反，<code>read()</code>会被阻塞 (等待数据)，因为内核知道无名管道至少有1个打开的写入文件描述符。这个写入文件描述符是否由读取进程打开并不重要。从理论角度，即使读取进程被阻塞，它仍然可以向无名管道写入数据。</p><p>　　● 写入进程关闭无名管道的读取文件描述符的原因有所不同。当写入进程试图写入没有进程拥有打开的读取文件描述符的无名管道时，内核会向写入进程发送信号<code>SIGPIPE</code>。在默认情况下，该信号会终止进程。进程可以捕获或忽略该信号。在这种情况下，对无名管道的<code>write()</code>会出错 (<code>EPIPE</code>)。收到信号<code>SIGPIPE</code>或错误<code>EPIPE</code>可以有效地指示无名管道的状态，所以应该关闭无名管道未使用的读取文件描述符。若写入进程没有关闭无名管道的读取文件描述符，则即使其他进程关闭了无名管道的读取文件描述符，写入进程仍然可以写入无名管道。最终，写入进程会填满无名管道，后续对无名管道的写入都会被无期限地阻塞。</p><p>　　● 当且仅当所有进程中引用无名管道的所有文件描述符都关闭后，无名管道才会被销毁，其资源会被释放以供其他进程重用。此时，无名管道中任何未读取的数据都会丢失。</p><p>　　在默认情况下，当<code>write()</code>等慢系统调用被信号处理函数中断时，调用要么自动重启，要么出错 (<code>EINTR</code>)，具体取决于调用<code>sigaction()</code>注册信号处理函数时是否使用了标志<code>SA_RESTART</code>。<code>SIGPIPE</code>信号处理函数的情况则有所不同，因为自动重启<code>write()</code>或仅仅指示<code>write()</code>被中断都没有意义。无论哪种情况，后续的<code>write()</code>调用都无法完成，因为无名管道仍然出于断开状态 (broken pipe)。</p><h4 id="将无名管道用于进程间通信">44.1.1 将无名管道用于进程间通信</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* simple_pipe.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pfd[<span class="number">2</span>]; <span class="comment">/* 无名管道文件描述符 */</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> numRead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s string\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建无名管道 */</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pfd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程：从无名管道读取 */</span></span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close - child&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从无名管道读取数据，然后在stdout中回显 */</span></span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            numRead = read(pfd[<span class="number">0</span>], buf, BUF_SIZE);</span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (numRead == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (write(STDOUT_FILENO, buf, numRead) != numRead)</span><br><span class="line">            &#123;</span><br><span class="line">                fatal(<span class="string">&quot;child - partial/failed write&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(STDOUT_FILENO, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程：向无名管道写入 */</span></span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close - parent&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pfd[<span class="number">1</span>], argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>])) != <span class="built_in">strlen</span>(argv[<span class="number">1</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;parent - partial/failed write&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>) <span class="comment">/* 子进程会遇到EOF */</span></span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">/* 等待子进程完成 */</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了父进程和子进程如何通过无名管道通信以及无名管道的字节流特性——父进程一次性写入数据，而子进程以小数据块的形式读取数据。</p><p>　　该程序会先调用<code>pipe()</code>来创建无名管道 (第19~22行)，然后调用<code>fork()</code>创建子进程。父进程会在创建子进程后关闭无名管道的读取文件描述符，然后将命令行参数指定的字符串写入到无名管道并关闭无名管道的写入文件描述符，最后等待子进程终止 (第63~80行)。当子进程关闭无名管道的写入文件描述符后，开始循环读取<code>BUF_SIZE</code>字节的数据块并将它们写入到标准输出 (直到遇到EOF)，然后写入换行符，最后关闭无名管道的读取文件描述符并终止 (第29~61行)。</p><h4 id="将无名管道用于进程同步">44.1.2 将无名管道用于进程同步</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pipe_sync.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span> <span class="comment">/* 函数currTime()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pfd[<span class="number">2</span>]; <span class="comment">/* 进程同步无名管道 */</span></span><br><span class="line">    <span class="type">int</span> j, dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s sleep-time...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲，因为这里通过_exit()终止子进程 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s Parent started\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pfd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (fork())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork %d&quot;</span>, j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 */</span></span><br><span class="line">            <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sleep(getInt(argv[j], GN_NONNEG, <span class="string">&quot;sleep-time&quot;</span>)); <span class="comment">/* 模拟执行任务 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s Child %d (PID=%ld) closing pipe\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), j, (<span class="type">long</span>)getpid());</span><br><span class="line">            <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 子进程继续执行其他任务 */</span></span><br><span class="line"></span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* 父进程循环创建子进程 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(pfd[<span class="number">0</span>], &amp;dummy, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;parent didn&#x27;t get EOF&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s Parent ready to go\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程继续执行其他任务 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了父进程和子进程如何通过无名管道同步。该程序会创建多个子进程 (每个命令行参数对应1个子进程)，所有子进程都会完成某些操作 (通过睡眠模拟)。父进程会等待所有子进程完成其操作。</p><p>　　为了进行同步，父进程会先创建无名管道 (第18~21行)，然后创建子进程，子进程会继承无名管道的写入文件描述符，子进程会在完成其操作后关闭该文件描述符 (第30~45行)。当所有子进程都关闭无名管道的写入文件描述符后，父进程对无名管道调用的<code>read()</code>会遇到EOF。此时，父进程可以继续执行其他任务。这里父进程关闭无名管道的写入文件描述符至关重要，否则父进程会永远被阻塞 (第52~65行)。</p><p>　　相比使用信号进行同步，使用无名管道进行同步的优势之一是可以协调单个进程与多个其他进程的行为。因为标准信号不会排队，所以标准信号不适用于这种情况 (相反，标准信号的优势之一是它可以被单个进程发送给进程组中的所有进程)。</p><p>　　其他同步拓扑也是可能的 (例如，使用多个无名管道)。此外，这种技术可以扩展，使得每个子进程不关闭无名管道，而是向其中写入包含进程ID和某些状态的信息。或者，每个子进程向无名管道写入1字节。父进程随后可以统计和分析这些消息。这种方法可以防止子进程意外终止 (而非显式地关闭管道)。</p><h4 id="使用无名管道连接过滤器">44.1.3 使用无名管道连接过滤器</h4><p>　　当创建无名管道时，两端的文件描述符是可用的编号最小的文件描述符。文件描述符0~2通常已被使用，所以无名管道的文件描述符的编号通常较大。为了达到类似于命令<code>ls | wc -l</code>的效果，即2个过滤器 (从标准输入读取数据并将其写入到标准输出的程序) 通过无名管道连接，使得其中1个程序的标准输出被定向到无名管道，而另一个程序的标准输入则从无名管道获取数据，需要进行文件描述符复制 (见5.3)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pipe_ls_wc.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pfd[<span class="number">2</span>]; <span class="comment">/* 无名管道 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pfd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 第1个子进程：执行命令ls写入无名管道 */</span></span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将标准输出复制给无名管道写入端并关闭未使用的文件描述符 */</span></span><br><span class="line">        <span class="keyword">if</span> (pfd[<span class="number">1</span>] != STDOUT_FILENO) <span class="comment">/* 防御性检查 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dup2(pfd[<span class="number">1</span>], STDOUT_FILENO) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;dup2 1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;close 2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>); <span class="comment">/* 写入无名管道 */</span></span><br><span class="line">        errExit(<span class="string">&quot;execlp ls&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程继续创建子进程 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 第2个子进程：执行命令ws读取无名管道 */</span></span><br><span class="line">        <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;close 3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将标准输入复制给无名管道读取端并关闭未使用的文件描述符 */</span></span><br><span class="line">        <span class="keyword">if</span> (pfd[<span class="number">0</span>] != STDIN_FILENO) <span class="comment">/* 防御性检查 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dup2(pfd[<span class="number">0</span>], STDIN_FILENO) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;dup2 2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;close 4&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        execlp(<span class="string">&quot;wc&quot;</span>, <span class="string">&quot;wc&quot;</span>, <span class="string">&quot;-l&quot;</span>, (<span class="type">char</span> *)<span class="literal">NULL</span>); <span class="comment">/* 读取无名管道 */</span></span><br><span class="line">        errExit(<span class="string">&quot;execlp wc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 父进程继续执行 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关闭未使用的文件描述符并等待子进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (close(pfd[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close 5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close(pfd[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close 6&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait(<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;wait 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wait(<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;wait 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何使用无名管道连接过滤器。当创建无名管道后，该程序会创建2个子进程。第1个子进程会将其标准输出绑定到无名管道写入端并执行命令<code>ls</code>。第2个子进程会将其标准输入绑定到无名管道读取端并执行命令<code>wc</code>。</p><h4 id="popen和pclose">44.1.4 <code>popen()</code>和<code>pclose()</code></h4><p>　　无名管道的常见用途之一是执行shell命令并读取其输出或向其发送输入。函数<code>popen()</code>和<code>pclose()</code>简化了这一任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *mode)</span>; <span class="comment">/* 成功时返回文件流，出错时返回NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>; <span class="comment">/* 成功时返回子进程的终止状态，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>popen()</code>会创建无名管道并创建子进程来执行shell，shell又会创建子进程来执行字符串<code>command</code>。参数<code>mode</code>用于指定无名管道的数据方向，其值必须包含<code>r</code>或<code>w</code>。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/overview_of_process_relationships_and_pipe_usage_for_popen.svg"><p>　　● 当<code>mode</code>为<code>r</code>时，表示调用进程从无名管道读取 (执行的命令的标准输出连接到无名管道写入端)。</p><p>　　● 当<code>mode</code>为<code>w</code>时，表示调用进程向无名管道写入 (执行的命令的标准输入连接到无名管道读取端)。</p><p>　　当<code>popen()</code>成功调用时，会返回可与stdio库函数一起使用的文件流指针。若出错 (例如，<code>mode</code>值无效、无名管道创建失败以及<code>fork()</code>创建子进程失败)，则返回<code>NULL</code>并设置<code>errno</code>。</p><p>　　当<code>popen()</code>调用后，调用进程可通过无名管道来读取<code>command</code>的输出或向其发送输入。与<code>pipe()</code>创建的无名管道相同，若调用进程读取<code>popen()</code>创建的无名管道时<code>command</code>关闭了无名管道写入端，则调用进程会遇到EOF；若调用进程读取<code>popen()</code>创建的无名管道时<code>command</code>关闭了无名管道写入端，则调用进程会收到信号<code>SIGPIPE</code>并出错 (<code>EPIPE</code>)。</p><p>　　当I/O完成后，函数<code>pclose()</code>可用于关闭无名管道并等待子shell终止。若成功调用时，则会返回子shell的终止状态 (见27.5)。与<code>system()</code>相同，若无法执行shell，则<code>pclose()</code>的返回值就像子shell通过调用<code>_exit(127)</code>终止一样。若出现了其他错误 (例如，无法获取终止状态)，则<code>pclose()</code>会返回-1。</p><p>　　当执行等待来获取子shell的状态时，SUSv3要求<code>pclose()</code>应该在对<code>waitpid()</code>的内部调用被信号处理函数中断时重启该调用 (如同<code>system()</code>)。</p><p>　　<code>popen()</code>会创建无名管道、复制文件描述符、关闭未使用的文件描述符以及处理<code>fork()</code>和<code>exec()</code>的细节，并且命令由shell处理。这种便利性是以效率为代价的，该函数至少会创建2个额外的进程：1个进程用于shell，其他进程用于shell执行的命令。与<code>system()</code>相同，<code>pclose()</code>永远不应该在特权程序中使用。</p><p>　　尽管<code>popen()</code>与<code>pclose()</code>的组合与<code>system()</code>之间有若干个相同之处，但也存在多个显著差异。这是因为使用<code>system()</code>时shell命令的执行被封装在单个函数调用中，而使用<code>popen()</code>时调用进程与shell命令并行运行，然后调用<code>pclose()</code>。这些差异如下：</p><p>　　● 由于调用进程和被执行的命令并行运行，SUSv3要求<code>popen()</code>不应该忽略信号<code>SIGINT</code>和<code>SIGQUIT</code>。若这些信号由键盘生成，则它们会发送给调用进程和被执行的命令。这是因为这2个进程位于同一进程组，而终端生成的信号会被发送给前台进程组的所有进程。</p><p>　　● 由于调用进程可能会在<code>popen()</code>和<code>pclose()</code>执行之间创建其他子进程，SUSv3要求<code>popen()</code>不应该阻塞信号<code>SIGCHLD</code>。这表示若调用进程在调用<code>pclose()</code>之前执行等待操作，则它可能会得到<code>popen()</code>创建的子进程的终止状态。在这种情况下，当后续调用<code>pclose()</code>时，会返回-1并将<code>errno</code>设置为<code>ECHILD</code> (表示无法获取子进程的状态)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* popen_glob.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print_wait_status.h&quot;</span> <span class="comment">/* 函数printWaitStatus()的声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POPEN_FMT <span class="string">&quot;/bin/ls -d %s 2&gt; /dev/null&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAT_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCMD_BUF_SIZE (sizeof(POPEN_FMT) + PAT_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> pat[PAT_SIZE]; <span class="comment">/* glob模式 */</span></span><br><span class="line">    <span class="type">char</span> popenCmd[PCMD_BUF_SIZE];</span><br><span class="line">    FILE *fp;           <span class="comment">/* popen()返回的文件流指针 */</span></span><br><span class="line">    Boolean badPattern; <span class="comment">/* 模式中是否包含无效字符 */</span></span><br><span class="line">    <span class="type">int</span> len, status, fileCnt, j;</span><br><span class="line">    <span class="type">char</span> pathname[PATH_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取glob模式，展示globbing结果 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pattern: &quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">if</span> (fgets(pat, PAT_SIZE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">strlen</span>(pat);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 空行 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pat[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pat[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 去除结尾的换行符 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 为了确保仅包含有效字符，即字母、数字、下划线、点号以及shell通配符 (这里有效</span></span><br><span class="line"><span class="comment">           字符的定义比shell更严格，shell允许其他字符，只要这些字符用括号括起来即可) */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, badPattern = FALSE; j &lt; len &amp;&amp; !badPattern; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>((<span class="type">unsigned</span> <span class="type">char</span>)pat[j]) &amp;&amp; <span class="built_in">strchr</span>(<span class="string">&quot;_*?[^-].&quot;</span>, pat[j]) == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                badPattern = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (badPattern)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Bad pattern character: %c\n&quot;</span>, pat[j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 构建和执行命令来展开pat */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(popenCmd, PCMD_BUF_SIZE, POPEN_FMT, pat);</span><br><span class="line">        popenCmd[PCMD_BUF_SIZE - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* 确保字符串以\0结尾 */</span></span><br><span class="line">        fp = popen(popenCmd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;popen() failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 读取路径名列表的结果，直到遇到EOF */</span></span><br><span class="line">        fileCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fgets(pathname, PATH_MAX, fp) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, pathname);</span><br><span class="line">            fileCnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 关闭无名管道并展示终止状态 */</span></span><br><span class="line">        status = pclose(fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;	%d matching file%s\n&quot;</span>, fileCnt, (fileCnt != <span class="number">1</span>) ? <span class="string">&quot;s&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;	pclose() status == %#x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)status);</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printWaitStatus(<span class="string">&quot;\t&quot;</span>, status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>popen()</code>和<code>pclose()</code>的用法。该程序会反复读取文件名通配符模式 (第25~38行)，然后通过<code>popen()</code>来获取结果并将其传递给命令<code>ls</code> (第59~72行)。在库函数<code>glob()</code>出现之前，早期的UNIX实现使用了类似的技术来进行文件名生成 (也称为<span style="background-color:#ff0">globbing</span>)。</p><p>　　用于globbing的命令构造 (第7和57行) 需要一些说明。模式匹配实际由shell执行，命令<code>ls</code>仅用于列出匹配结果。这里似乎可以使用命令<code>echo</code>，但这会产生不理想的结果：若模式没有匹配结果，shell会保持原模式不变，而<code>echo</code>只会简单地显示该模式。相比之下，<code>ls</code>在这种情况下仅会在标准错误上打印错误信息 (这里将标准错误重定向到<code>/dev/null</code>来处理) 并以状态1退出。</p><p>　　第42~54行的输入检查是为了防止无效输入导致<code>popen()</code>执行意外的shell命令。假设没有这些检查，若用户输入<code>; rm *</code>，则传递给<code>popen()</code>的命令将会是<code>/bin/ls -d ; rm * 2&gt; /dev/null</code>，这会导致灾难性后果。对于使用<code>popen()</code> (或<code>system()</code>) 执行由用户输入构建的shell命令时，始终需要这样的输入检查 (或者应用程序对除正在检查的字符之外的所有字符都用引号括起来，这样shell就不会对这些字符进行特殊处理)。</p><p>　　以下shell会话展示了该程序的用法 (这里先提供了匹配2个文件名的模式，然后提供了无匹配结果的模式)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./popen_glob</span> </span><br><span class="line">pattern: popen_glob*</span><br><span class="line">popen_glob</span><br><span class="line">popen_glob.c</span><br><span class="line">    2 matching files</span><br><span class="line">    pclose() status == 0</span><br><span class="line">        child exited, status=0</span><br><span class="line">pattern: x*</span><br><span class="line">    0 matching files</span><br><span class="line">    pclose() status == 0x100</span><br><span class="line">        child exited, status=1</span><br><span class="line">pattern: ^D$</span><br></pre></td></tr></table></figure><h4 id="无名管道与stdio缓冲">44.1.5 无名管道与stdio缓冲</h4><p>　　<code>popen()</code>返回的文件流指针不会引用终端，所以stdio库函数会对其指向的文件流使用块缓冲 (见13.2)。这表示若调用<code>popen()</code>时将<code>mode</code>指定为<code>w</code>，则在默认情况下，只有stdio缓冲区被填满或调用<code>pclose()</code>时无名管道另一端的子进程才会收到进程。为了保证子进程立即收到数据，可以周期性地调用<code>fflush()</code>或调用<code>setbuf(fp, NULL)</code>禁用stdio缓冲。当先使用<code>pipe()</code>打开无名管道，再使用<code>fpopen()</code>获取无名管道写入端对应的stdio流时，也可以使用这种方法。</p><p>　　若进程调用<code>popen()</code>时将<code>mode</code>指定为<code>r</code>，并且子进程使用的是stdio库，则只有子进程显式调用<code>fflusth()</code>或<code>setbuf()</code>后，调用进程才能访问其输出 (当读取<code>pipe()</code>创建的无名管道时，若写入进程使用的是stdio库，则同样的道理也适用)。若这会导致问题，则只能修改程序的源代码，使子进程调用<code>fflusth()</code>或<code>setbuf()</code> (若无法修改源代码，则可以不使用无名管道，而使用伪终端。对于一端的进程，伪终端就像终端，所以stdio库会使用行缓冲输出)。</p><h3 id="有名管道">44.2 有名管道</h3><p>　　从语义角度，有名管道类似于无名管道。主要区别是有名管道在文件系统中有名称，并且可以通过与普通文件相同的方式打开。这使得有名管道可用于不相关进程 (例如，客户端和服务端) 之间的通信。</p><p>　　当打开有名管道后，可以使用与无名管道和其他文件一起使用的I/O系统调用 (例如，<code>read()</code>和<code>write()</code>)。与无名管道相同，有名管道包含读取端和写入端，数据的读取顺序与写入顺序相同。有名管道的另一个名称 "先进先出" 便源于该特性。</p><p>　　与无名管道相同，当所有引用有名管道的文件描述符都关闭后，其中的所有数据都会丢失。</p><p>　　命令<code>mkfifo</code>可用于创建有名管道：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> [ -m mode ] pathname</span></span><br></pre></td></tr></table></figure><p>　　<code>pathname</code>是有名管道的名称。选项<code>-m</code>用于以与命令<code>chmod</code>的相同方式指定权限<code>mode</code>。</p><p>　　当对有名管道 (或无名管道) 调用<code>fstat()</code>和<code>stat()</code>时，返回的结构体<code>stat</code>的成员<code>st_mode</code>为<code>S_IFIFO</code>。当使用命令<code>ls -l</code>时，有名管道的第1列显示为了类型<code>p</code>，而<code>ls -F</code>会在有名管道路径名后附加管道符号<code>|</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>mkfifo()</code>会创建名为<code>pathname</code>的有名管道。参数<code>mode</code>用于指定有名管道的权限，其值为15.4.1的表格中的常量进行或运算<code>|</code>得到的结果。</p><p>　　从历史角度，有名管道是通过调用<code>mknod(pathname, S_FIFO, 0)</code>创建的。POSIX.1-1990详细说明了更简洁的API，从而避免了<code>mknod()</code>的通用性，后者允许创建各种类型的文件，包括设备文件 (SUSv3详细说明了<code>mknod()</code>，但仅定义了用于创建有名管道的用途)。大多数UNIX实现都将<code>mkfifo()</code>作为基于<code>mknod()</code>的库函数提供。</p><p>　　当创建有名管道后，所有进程都可以打开它，但需要遵守常规的文件权限检查规则 (见15.4.3)。</p><p>　　打开有名管道的语义有些特殊。通常，有名管道唯一合理的用途是在两端设置读取进程和写入进程。因此，在一般情况下，以读取方式打开有名管道 (使用<code>open()</code>的标志<code>O_RDONLY</code>) 会被阻塞，直到其他进程以写入方式打开有名管道 (使用<code>open()</code>的标志<code>O_WRONLY</code>)。相反，以写入方式打开有名管道也会被阻塞，直到其他进程以读取方式打开有名管道。换句话说，打开有名管道会同步读取进程和写入进程。若有名管道的另一端已经打开 (可能因为一对进程已经打开了有名管道的两端)，则<code>open()</code>会立即成功。</p><p>　　对于Linux和大多数UNIX实现，通过在打开有名管道时指定标志<code>O_RDWR</code>，可以防止被阻塞。此时，<code>open()</code>会立即返回可用于读写有名管道的文件描述符。这样做实际上颠覆了有名管道的I/O模型，而且SUSv3明确指出，用标志<code>O_RDWR</code>打开有名管道的行为是未定义的。因此，出于可移植性的考虑，应该避免使用这种方法。为了防止打开有名管道时被阻塞，可以使用<code>open()</code>的标志<code>O_NONBLOCK</code>。</p><p>　　打开有名管道应避免使用标志<code>O_RDWR</code>还有另一个原因。若以这种方式调用<code>open()</code>，则调用进程在读取结果文件描述符时不会遇到EOF，因为始终至少有1个文件描述符可用于写入有名管道——该文件描述符自己。</p><h4 id="使用有名管道和命令tee来创建双管道">44.2.1 使用有名管道和命令<code>tee</code>来创建双管道</h4><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/using_a_fifo_and_command_tee_to_create_a_dual_pipeline.svg"><p>　　shell管道的特点之一是线性：每个进程会读取上一个进程产生的数据，并将其发送给下一个进程。通过有名管道，可以在管道中创建分支，使得进程的输出副本除了发送给管道中的下一个进程之外，还可以发送给另一个进程。为了实现这一点，还需要命令<code>tee</code>，它会将从标准输入读取的内容写入到2个地方：标准输出和命令行参数指定的文件。</p><p>　　通过将<code>tee</code>的参数<code>file</code>设置为有名管道，可以实现2个进程同时读取<code>tee</code>产生的重复输出。以下shell会话展示了这一点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> myfifo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> -l &lt; myfifo &amp;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | <span class="built_in">tee</span> myfifo | <span class="built_in">sort</span> -k5n</span></span><br></pre></td></tr></table></figure><p>　　第1行命令会创建有名管道<code>myfifo</code>。第2个命令会在后台执行命令<code>wc</code>，该命令以读取方式打开该有名管道 (该操作会被阻塞，直到该有名管道被以写入方式打开)。第3行命令会执行管道，将<code>ls</code>的输出发送给<code>tee</code>，而<code>tee</code>同时将其输出传递给有名管道<code>myfifo</code>以及管道的下一个命令<code>sort</code> (<code>sort</code>的选项<code>-k5n</code>会使<code>ls</code>的输出按第5个以空格分隔的字段的数值升序排序)。</p><p>　　程序<code>tee</code>之所以得名，是因为其形状。该程序可以被视为类似于无名管道，但它多了1个用于发送重复输出的分支。如上图所示，其形状就像大写的字母T。除了这里描述的用途之外，该程序还可以用于调试管道以及保存复杂管道中某个中间点产生的结果。</p><h4 id="使用有名管道的客户端-服务端应用程序">44.2.2 使用有名管道的客户端-服务端应用程序</h4><p>　　这里将实现通过有名管道进行IPC的简单客户端-服务器应用程序。所有客户端会使用同一服务器有名管道来向服务器发送请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fifo_seqnum.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_FIFO <span class="string">&quot;/tmp/seqnum_sv&quot;</span>                             <span class="comment">/* 服务器有名管道的知名名称 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_FIFO_TEMPLATE <span class="string">&quot;/tmp/seqnum_cl.%ld&quot;</span>                <span class="comment">/* 构建客户端有名管道名称的模板 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_FIFO_NAME_LEN (sizeof(CLIENT_FIFO_TEMPLATE) + 20) <span class="comment">/* 客户端有名管道路径名所需的空间 (+20是为PID预留) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请求 (客户端 -&gt; 服务器) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">pid_t</span> pid;  <span class="comment">/* 客户端PID */</span></span><br><span class="line">    <span class="type">int</span> seqLen; <span class="comment">/* 序列的长度 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 响应 (服务器 -&gt; 客户端) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">response</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> seqNum; <span class="comment">/* 序列的起始值 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　头文件<code>fifo_seqnum.h</code>定义了服务器有名管道的知名名称。该名称是固定的，以便所有客户端都知道如何联系服务器 (这里将在目录<code>/tmp</code>下创建有名管道，因为这样可以保证程序直接在大多数系统上运行。但是，在<code>/tmp</code>等公共可写的目录下创建文件可能导致安全漏洞，在实际应用程序中应该避免这样做)。</p><p>　　但是，不可能使用单个有名管道向所有客户端发送响应，因为这会导致客户端之间竞争，并且可能会读取其他客户端的响应消息，而非自己的响应消息。因此，所有客户端都会创建唯一的有名管道，服务器使用该有名管道向客户端发送响应，而服务器需要知道如何找到客户端的有名管道。客户端生成其有名管道路径名，然后将该路径名作为请求消息的一部分传递。或者，客户端和服务器约定构建客户端有名管道路径名的规则，客户端在请求中将构建该客户端专属路径名所需的信息传递给服务器。这里使用第2个方法，所有客户端的有名管道的名称都基于模板构建，该模板包含客户端的进程ID (包含进程ID可以方便地生成唯一的有名管道名称)。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/using_fifos_in_a_single-server,multiple-client_application.svg"><p>　　头文件<code>fifo_seqnum.h</code>也定义了客户端发送给服务器的请求消息的格式以及服务器发送给客户端的响应消息的格式。由于无名管道和有名管道中的数据是字节流，多条消息之间的边界不会被保留。这表示当多条消息被发送给同一进程时，发送端和接收端之间必须约定分隔消息的方法。分隔消息可以采用各种方法：</p><p>　　● 所有消息以<span style="background-color:#ff0">分隔符</span>结尾。在这种情况下，要么消息不能包含分隔符，要么转义分隔符 (以换行符作为分隔符为例，字符<code>\</code>加上换行符表示消息内的换行符，<code>\\</code>表示消息内的<code>\</code>)。这种方法的缺点之一是读取端必须每次读取1个字节，直到找到分隔符。</p><p>　　● 加上<span style="background-color:#ff0">长度固定的包含长度字段的首部</span>，长度字段表示消息剩余部分的长度。在这种情况下，读取端需要先读取首部，再使用其中的长度字段获取消息剩余部分的长度。这种方法的优点是可以高效地处理任意长度的消息，但格式错误的消息可能会导致问题。</p><p>　　● 使用<span style="background-color:#ff0">长度固定的消息</span>。这种方法的优点是程序简单。但是，这限制了消息的长度，所以会浪费部分信道容量 (因为较短的信息必须填充到固定长度)。此外，若某个客户端发送了长度错误的消息，则后续的所有消息都会失去同步，进而导致服务器难以恢复。</p><p>　　无论使用哪种方法，消息的整体长度必须小于<code>PIPE_BUF</code>字节，以防止消息被内核拆分并与其他写入进程的消息交错。</p><p>　　除了所有客户端的消息共用同一信道 (有名管道) 之外，还可以让<span style="background-color:#ff0">每条信息使用独立的连接</span>。发送端打开通信信道，发送消息，然后关闭信道。当接收端遇到EOF，表示消息结束。若多个发送端同时打开同一信道，则这种方法不可行，因为当仅其中某个发送端关闭信道时，接收端不会遇到EOF。但是，当使用流套接字时，这种方法是可行的，在这种情况下，服务器会为每个客户端连接创建唯一的通信信道。</p><p>　　对于示例应用程序，将使用长度固定的消息。消息由结构体<code>request</code>定义。所有请求都包含客户端的进程ID，这使得服务器能够构建客户端用于接收响应的有名管道的名称。请求还包含字段<code>seqLen</code>，用于指定应分配给该客户端的序列号数量。服务器发送给客户端的响应仅包含字段<code>seqNum</code>，它是分配给该客户端的序列号范围的起始值。</p><h5 id="服务器程序">44.2.2.1 服务器程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fifo_seqnum_server.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fifo_seqnum.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serverFd, dummyFd, clientFd;</span><br><span class="line">    <span class="type">char</span> clientFifo[CLIENT_FIFO_NAME_LEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">response</span> <span class="title">resp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> seqNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建知名有名管道并以读取方式打开 */</span></span><br><span class="line">    umask(<span class="number">0</span>); <span class="comment">/* 以便获取预期权限 */</span></span><br><span class="line">    <span class="keyword">if</span> (mkfifo(SERVER_FIFO, S_IRUSR | S_IWUSR | S_IWGRP) == <span class="number">-1</span> &amp;&amp; errno != EEXIST)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;mkfifo %s&quot;</span>, SERVER_FIFO);</span><br><span class="line">    &#125;</span><br><span class="line">    serverFd = open(SERVER_FIFO, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (serverFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open %s&quot;</span>, SERVER_FIFO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开额外的写入文件描述符，以确保不会遇到EOF */</span></span><br><span class="line">    dummyFd = open(SERVER_FIFO, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (dummyFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open %s&quot;</span>, SERVER_FIFO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGPIPE, SIG_IGN) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取请求并发送响应 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (read(serverFd, &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error reading request; discarding\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 部分读取或出错 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 打开客户端有名管道 (已由客户端创建) */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(clientFifo, CLIENT_FIFO_NAME_LEN, CLIENT_FIFO_TEMPLATE, (<span class="type">long</span>)req.pid);</span><br><span class="line">        clientFd = open(clientFifo, O_WRONLY);</span><br><span class="line">        <span class="keyword">if</span> (clientFd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            errMsg(<span class="string">&quot;open %s&quot;</span>, clientFifo);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* 打开失败时放弃该客户端 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 发送响应并关闭有名管道 */</span></span><br><span class="line">        resp.seqNum = seqNum;</span><br><span class="line">        <span class="keyword">if</span> (write(clientFd, &amp;resp, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> response)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> response))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error writing to FIFO %s\n&quot;</span>, clientFifo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close(clientFd) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errMsg(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seqNum += req.seqLen; <span class="comment">/* 更新序列号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是服务器的代码。服务器会执行以下步骤：</p><p>　　1) 创建服务器知名有名管道并以只读方式打开 (第15~24行)。服务器必须在所有客户端之前运行，以保证客户端试图打开服务器有名管道时该有名管道已存在。服务器的<code>open()</code>会被阻塞，直到客户端以只写方式打开服务器有名管道。</p><p>　　2) 以只写方式打开服务器有名管道 (第27~31行)。该<code>open()</code>调用不会被阻塞，因为有名管道的已经被以只读方式打开。第2次打开为了确保所有客户端都关闭有名管道写入端后不会遇到EOF。</p><p>　　3) 忽略信号<code>SIGPIPE</code> (第33~36行)。当服务器写入没有读取端的客户端有名管道时，不会收到该信号，而是从<code>write()</code>得到错误<code>EPIPE</code>。</p><p>　　4) 循环读取并响应客户端请求 (第39~70行)。为了发送响应，服务器会构建客户端有名管道的名称并以只写方式打开。若打开客户端有名管道出错，则放弃该客户端请求。</p><p>　　该服务器属于<span style="background-color:#ff0">迭代服务器</span>，服务器会先读取并处理上一个客户端请求，再处理下一个客户端请求。这种设计适合客户端请求可以被快速处理并响应的情况。另一种设计是并发服务器，主服务器会使用单独的进程或线程来处理客户端请求。</p><h5 id="客户端请求">44.2.2.2 客户端请求</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fifo_seqnum_client.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fifo_seqnum.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> clientFifo[CLIENT_FIFO_NAME_LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除客户端有名管道</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">removeFifo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    unlink(clientFifo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serverFd, clientFd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">response</span> <span class="title">resp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [seq-len...]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建客户端有名管道 */</span></span><br><span class="line">    umask(<span class="number">0</span>); <span class="comment">/* 以便获取预期权限 */</span></span><br><span class="line">    <span class="built_in">snprintf</span>(clientFifo, CLIENT_FIFO_NAME_LEN, CLIENT_FIFO_TEMPLATE, (<span class="type">long</span>)getpid());</span><br><span class="line">    <span class="keyword">if</span> (mkfifo(clientFifo, S_IRUSR | S_IWUSR | S_IWGRP) == <span class="number">-1</span> &amp;&amp; errno != EEXIST)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;mkfifo %s&quot;</span>, clientFifo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (atexit(removeFifo) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;atexit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建请求、打开客户端有名管道以及发送请求 */</span></span><br><span class="line">    req.pid = getpid();</span><br><span class="line">    req.seqLen = (argc &gt; <span class="number">1</span>) ? getInt(argv[<span class="number">1</span>], GN_GT_0, <span class="string">&quot;seq-len&quot;</span>) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    serverFd = open(SERVER_FIFO, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (serverFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open %s&quot;</span>, SERVER_FIFO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write(serverFd, &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request))</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;Can&#x27;t write to server&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开客户端有名管道，然后读取并打印响应 */</span></span><br><span class="line">    clientFd = open(clientFifo, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (clientFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open %s&quot;</span>, clientFifo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(clientFd, &amp;resp, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> response)) != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> response))</span><br><span class="line">    &#123;</span><br><span class="line">        fatal(<span class="string">&quot;Can&#x27;t read response from server&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, resp.seqNum);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是客户端的代码。客户端会执行以下步骤：</p><p>　　1) 创建用于接收服务器响应的客户端有名管道 (第27~37行)。该步骤应该在发送请求前完成，以确保服务器试图打开客户端有名管道并发送响应时该有名管道已存在。</p><p>　　2) 构建发送给服务器的消息，其中包含客户端进程ID和数字 (取自命令行参数)，该数字指定客户端希望服务器分配给它的序列长度。若未指定，则默认为1 (第40~47行)。</p><p>　　3) 打开服务器有名管道并发送消息给服务器 (第49~52行)。</p><p>　　4) 打开客户端有名管道并打印服务器响应 (第55~66行)。</p><p>　　这里唯一值得注意的其他细节是通过<code>atexit()</code>注册退出处理函数，以确保客户端有名管道会在进程终止时被删除。或者，这里可以直接在通过<code>open()</code>打开客户端有名管道后调用<code>unlink()</code>。</p><p>　　以下shell会话展示了示例客户端和服务器的用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fifo_seqnum_server &amp;</span></span><br><span class="line">[1] 5066</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fifo_seqnum_client 3</span></span><br><span class="line">0</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fifo_seqnum_client 2</span></span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./fifo_seqnum_client</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="非阻塞io">44.2.3 非阻塞I/O</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;fifopath&quot;</span>, O_RDONLY | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如前所述，当进程打开有名管道的一端时，若另一端未打开，则该进程会被阻塞。有时，可能需要让进程不会被阻塞。为此，可以在调用<code>open()</code>时指定标志<code>O_NONBLOCK</code>，该标志的效果取决于打开的是有名管道读取端还是写入端。</p><p>　　● 若打开的是有名管道读取端，并且没有进程拥有有名管道写入端，则<code>open()</code>会立即成功 (就像有名管道写入端已打开一样)。</p><p>　　● 若打开的是有名管道写入端，并且没有进程拥有有名管道读取端，则<code>open()</code>会出错 (<code>ENXIO</code>)。</p><p>　　若有名管道的另一端已打开，则标志<code>O_NONBLOCK</code>不会生效。</p><p>　　标志<code>O_NONBLOCK</code>在打开有名管道进行读取或写入时的不对称性的原因如下：</p><p>　　● 当没有进程拥有有名管道写入端时，打开有名管道读取端不会导致问题，因为读取该有名管道不会返回数据。</p><p>　　● 当没有进程拥有有名管道读取端时，打开有名管道写入端会导致信号<code>SIGPIPE</code>的生成，并且<code>write()</code>会出错 (<code>EPIPE</code>)。</p><p>　　在打开有名管道时使用标志<code>O_NONBLOCK</code>主要有2个目的：</p><p>　　● 它允许同一进程打开有名管道的两端。进程可以先使用该标志打开有名管道读取端，然后打开有名管道写入端。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_44/deadlock_between_processes_opening_two_fifos.svg"><p>　　● 它可以防止打开2个有名管道的进程之间的死锁。如图所示，进程X和Y都被阻塞在打开有名管道读取端。只要其中某个进程能先执行第2步时，就不会出现这种阻塞。但是，在某些应用程序中，这可能难以实现。在这种情况下，可以在打开有名管道读取端时指定该标志来解决这个问题。</p><p>　　有时，可能需要修改已打开的有名管道 (或其他类型的文件) 的标志<code>O_NONBLOCK</code>的状态。以下情况可能需要这样做：</p><p>　　● 打开有名管道时使用了该标志，但后续的<code>read()</code>和<code>write()</code>调用需要以阻塞模式运行。</p><p>　　● 需要修改<code>open()</code>以外的其他方式获取的文件描述符 (例如，shell为每个新运行的程序自动打开的3个标准文件描述符以及<code>socket()</code>返回的文件描述符) 的非阻塞状态。</p><p>　　● 某些应用程序需要启用或禁用某个文件描述符的该标志。</p><p>　　为此，可以通过<code>fcntl()</code>来启用或禁用打开文件状态标志<code>O_NONBLOCK</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">flags = fcntl(fd, F_GETFL); <span class="comment">/* 获取打开文件状态标志 */</span></span><br><span class="line">flags |= O_NONBLOCK;        <span class="comment">/* 启用位O_NONBLOCK */</span></span><br><span class="line">fcntl(fd, F_SETFL, flags);  <span class="comment">/* 更新打开文件状态标志 */</span></span><br></pre></td></tr></table></figure><p>　　这段代码会启用标志<code>O_NONBLOCK</code> (这里省略了错误检查)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flags = fcntl(fd, F_GETFL);</span><br><span class="line">flags &amp;= ~O_NONBLOCK; <span class="comment">/* 禁用位O_NONBLOCK */</span></span><br><span class="line">fcntl(fd, F_SETFL, flags);</span><br></pre></td></tr></table></figure><p>　　这段代码会禁用标志<code>O_NONBLOCK</code>。</p><h3 id="无名管道和有名管道的read和write的语义">44.3 无名管道和有名管道的<code>read()</code>和<code>write()</code>的语义</h3><p>　　下表列出了无名管道和有名管道的<code>read()</code>操作的语义 (n表示希望读取的字节数，p表示无名管道或有名管道中的实际字节数)：</p><table><thead><tr><th></th><th>启用标志<code>O_NONBLOCK</code></th><th>禁用标志<code>O_NONBLOCK</code></th></tr></thead><tbody><tr><td>p = 0且写入端打开</td><td>错误<code>EAGAIN</code></td><td>阻塞</td></tr><tr><td>p = 0且写入端关闭</td><td>返回0 (EOF)</td><td>返回0 (EOF)</td></tr><tr><td>p &lt; n</td><td>读取p字节</td><td>读取p字节</td></tr><tr><td>p &gt;= n</td><td>读取n字节</td><td>读取n字节</td></tr></tbody></table><p>　　阻塞读取和非阻塞读取的唯一区别在没有数据且写入端打开时出现。此时，常规的<code>read()</code>会被阻塞，而非阻塞<code>read()</code>会导致错误<code>EAGAIN</code>。</p><p>　　当写入无名管道或有名管道时，标志<code>O_NONBLOCK</code>与限制<code>PIPE_BUF</code>的相互作用会导致情况变得更复杂。下表列出了无名管道和有名管道的<code>write()</code>操作的语义 (n表示希望写入的字节数)：</p><table><colgroup><col style="width:18%"><col style="width:40%"><col style="width:40%"></colgroup><thead><tr><th></th><th>启用标志<code>O_NONBLOCK</code></th><th>禁用标志<code>O_NONBLOCK</code></th></tr></thead><tbody><tr><td>n &lt;= <code>PIPE_BUF</code>且读取端打开</td><td>若空间足够，则立即以原子方式写入n字节；否则，出错 (<code>EAGAIN</code>)</td><td>以原子方式写入n字节 (可能被阻塞，直到有足够的空间)</td></tr><tr><td>n &gt; <code>PIPE_BUF</code>且读取端打开</td><td>若空间足以立即写入部分字节，则写入1到n字节 (可能与其他进程写入的数据交错)；否则，出错 (<code>EAGAIN</code>)</td><td>写入n字节 (可能被阻塞，直到有足够的空间)，并且数据可能与其他进程写入的数据交错</td></tr><tr><td>读取端关闭</td><td>信号<code>SIGPIPE</code> + 错误<code>EPIPE</code></td><td>信号<code>SIGPIPE</code> + 错误<code>EPIPE</code></td></tr></tbody></table><p>　　当无法立即写入数据时，标志<code>O_NONBLOCK</code>会导致无名管道或有名管道的<code>write()</code>出错 (<code>EAGAIN</code>)。因此，当写入的数据不超过<code>PIPE_BUF</code>字节时，若无名管道或有名管道中的空间不足，则<code>write()</code>会出错，因为内核无法立即完成操作，也无法执行执行部分写入 (这会违反写入不超过<code>PIPE_BUF</code>字节的数据需要以原子方式执行的要求)。</p><p>　　当单次写入的数据超过<code>PIPE_BUF</code>字节时，写入操作不再需要以原子方式执行。因此，<code>write()</code>会尽可能多地写入数据 (部分写入) 来填满无名管道或有名管道。在这种情况下，<code>write()</code>的返回值是实际写入的字节数，并且调用进程必须稍后再次写入剩余字节。但是，若无名管道或有名管道已满，则<code>write()</code>会出错 (<code>EAGAIN</code>)。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_43/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第43章 进程间通信简介"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第43章 进程间通信简介</a></div><div class="post-nav-item"></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>