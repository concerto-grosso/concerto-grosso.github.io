<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_15/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_15/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_15/","title":"《Linux/UNIX系统编程手册》第15章 文件属性"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第15章 文件属性 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="nav-text">15.1 检索文件信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87idi-node%E5%8F%B7%E6%96%87%E4%BB%B6%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E9%93%BE%E6%8E%A5%E6%95%B0"><span class="nav-text">15.1.1 设备ID、i-node号、文件所有权和链接数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%9D%83%E9%99%90"><span class="nav-text">15.1.2 文件类型和权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E5%B7%B2%E5%88%86%E9%85%8D%E7%9A%84%E5%9D%97%E6%95%B0%E5%92%8Cio%E7%9A%84%E6%9C%80%E4%BD%B3%E5%9D%97%E5%A4%A7%E5%B0%8F"><span class="nav-text">15.1.3 文件大小、已分配的块数和I&#x2F;O的最佳块大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-text">15.1.4 示例程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E6%88%B3"><span class="nav-text">15.2 文件时间戳</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#utime%E5%92%8Cutimes"><span class="nav-text">15.2.1 utime()和utimes()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#utimensat%E5%92%8Cfutimens"><span class="nav-text">15.2.2 utimensat()和futimens()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-text">15.3 文件所有权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-text">15.4 文件权限</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90"><span class="nav-text">15.4.1 常规文件的权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%9D%83%E9%99%90"><span class="nav-text">15.4.2 目录的权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5%E7%AE%97%E6%B3%95"><span class="nav-text">15.4.3 权限检查算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="nav-text">15.4.4 检查文件可访问性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set-user-id%E4%BD%8Dset-group-id%E4%BD%8D%E5%92%8C%E7%B2%98%E6%BB%9E%E4%BD%8D"><span class="nav-text">15.4.5 set-user-ID位、set-group-ID位和粘滞位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#umask"><span class="nav-text">15.4.6 umask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-text">15.4.7 修改文件权限</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i-node%E6%A0%87%E5%BF%97"><span class="nav-text">15.5 i-node标志</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_15/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第15章 文件属性 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第15章 文件属性</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-01-30 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-30T00:00:00+08:00">2025-01-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-02-06 00:00:00" itemprop="dateModified" datetime="2025-02-06T00:00:00+08:00">2025-02-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>24k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　每个文件都有1个关联的用户ID和1个关联的组ID，这些ID决定文件的所有者和所属组。</p><p>　　当创建文件时，文件的用户ID取自进程的有效用户ID，组ID取自进程的有效组ID (等同于System V的默认行为) 或父目录的组ID (BSD行为)。新文件的组ID取决于多个因素，包括文件创建时的文件系统类型。</p><p>　　当通过命令<code>mount</code>挂载ext2文件系统时，可以指定选项<code>-o grpid</code> (等同于<code>–o bsdgroups</code>) 或<code>-o nogrpid</code> (等同于<code>–o sysvgroups</code>)。若没有指定这2个选项，则会默认指定<code>-o nogrpid</code>。当指定了<code>-o grpid</code>后，新文件会继承父目录的组ID。当指定了<code>-o nogrpid</code>后，若父目录启用了set-group-ID位 (通过命令<code>chmod g+s</code>)，则新文件会继承父目录的组ID；否则，新文件继承进程的有效组ID。因此，新文件的组ID可能与创建该文件的进程的所有组ID都不匹配。在撰写本书时，只有文件系统ext2、ext3、ext4和XFS (Linux 2.6.14及以上版本) 支持挂载选项<code>grpid</code>和<code>nogrpid</code>。</p><p>　　当创建文件或目录时，内核会将<code>open()</code> (或<code>creat()</code>) 或<code>mkdir()</code>的参数<code>mode</code>指定的权限授予新文件或目录。但是，这些设置可以通过<strong>文件模式创建掩码</strong> (umask) 修改。umask是文件属性，它指定进程创建新文件或目录时应该始终禁用哪些权限位。</p><p>　　当创建符号链接时，所有用户都拥有该符号链接的所有权限，并且这些权限无法被禁用。</p><p>　　有些Linux文件系统允许为文件和目录设置各种i-node标志，该特性并非标准Linux扩展。</p><p>　　第1个支持i-node标志的Linux文件系统是ext2，所以i-node标志也称为<strong>ext2扩展文件属性</strong>。随后，其他文件系统也开始支持i-node标志，包括Btrfs、ext3、ext4、Reiserfs (Linux 2.4.19及以上版本)、XFS (Linux 2.4.25及以上版本) 和JFS (Linux 2.6.17及以上版本)。此外，每个文件系统支持的i-node标志不同。</p><p>　　为了修改文件的i-node标志，进程的有效用户ID必须匹配文件的用户ID (严格准确地说，对于Linux，应该是进程的文件系统用户ID必须匹配文件的用户ID，详情见9.3)，或者进程必须是特权进程 (能力<code>CAP_FOWNER</code>)。</p><p>　　现代BSD提供了与i-node标志类似的特性，即使用命令<code>chflags</code>或系统调用<code>chflags()</code>修改文件标志。</p><span id="more"></span><h3 id="检索文件信息">15.1 检索文件信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> st_dev;         <span class="comment">/* 文件所在设备的ID */</span></span><br><span class="line">    <span class="type">ino_t</span> st_ino;         <span class="comment">/* 文件的i-node号 */</span></span><br><span class="line">    <span class="type">mode_t</span> st_mode;       <span class="comment">/* 文件类型和权限 */</span></span><br><span class="line">    <span class="type">nlink_t</span> st_nlink;     <span class="comment">/* 指向文件的 (硬) 链接数 */</span></span><br><span class="line">    <span class="type">uid_t</span> st_uid;         <span class="comment">/* 文件所有者的用户ID */</span></span><br><span class="line">    <span class="type">gid_t</span> st_gid;         <span class="comment">/* 文件所属组的组ID */</span></span><br><span class="line">    <span class="type">dev_t</span> st_rdev;        <span class="comment">/* 设备特殊文件的ID */</span></span><br><span class="line">    <span class="type">off_t</span> st_size;        <span class="comment">/* 文件大小 (以字节为单位) */</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize; <span class="comment">/* I/O的最佳块大小 (以字节为单位) */</span></span><br><span class="line">    <span class="type">blkcnt_t</span> st_blocks;   <span class="comment">/* 已分配的块数 (块大小是512B) */</span></span><br><span class="line">    <span class="type">time_t</span> st_atime;      <span class="comment">/* 最后访问时间 */</span></span><br><span class="line">    <span class="type">time_t</span> st_mtime;      <span class="comment">/* 最后修改时间 */</span></span><br><span class="line">    <span class="type">time_t</span> st_ctime;      <span class="comment">/* 最后状态修改时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>stat()</code>、<code>lstat()</code>和<code>fstat()</code>可用于检索文件信息 (信息主要来自i-node)，结果存储在参数<code>statbuf</code>指向的结构体中。这3个系统调用唯一的区别是指定文件的方式：</p><p>　　● <code>stat()</code>指定的是文件的路径名。当参数<code>pathanem</code>是符号链接时，会解引用。</p><p>　　● <code>lstat()</code>指定文件的方式与<code>stat()</code>类似。但是，当参数<code>pathanem</code>是符号链接时，检索结果是符号链接的相关信息 (而非符号链接引用的文件的相关信息)。</p><p>　　● <code>fstat()</code>指定的是打开的文件描述符。</p><p>　　系统调用<code>stat()</code>和<code>lstat()</code>不需要文件的访问权限，但需要<code>pathname</code>中指定的所有父目录的执行 (搜索) 权限。</p><p>　　只要参数<code>fd</code>指定的文件描述符有效，系统调用<code>fstat()</code>就不会失败。</p><p>　　根据SUSv3，当对符号链接调用<code>lstat()</code>时，只需要在成员<code>st_mode</code>的文件类型部分和成员<code>st_size</code>中返回有效信息 (其他成员无需包含有效信息)。这让实现能够自由地维护这些成员，这可能是由于效率原因。早期UNIX标准的目的是允许将符号链接实现为i-node或目录中的条目。但是，若将符号链接实现为目录中的条目，则无法提供结构体<code>stat</code>中的所有成员 (同时代的所有主要UNIX实现都将符号链接实现为i-node)。对于Linux，对符号链接调用<code>lstat()</code>时，结构体<code>stat</code>中的所有成员都包含有效信息。</p><h4 id="设备idi-node号文件所有权和链接数">15.1.1 设备ID、i-node号、文件所有权和链接数</h4><p>　　成员<code>st_dev</code>是文件所在设备的ID (主ID和次ID)。成员<code>st_ino</code>是文件的i-node号。这2个成员的组合可作为所有文件系统中的文件的唯一标识。</p><p>　　成员<code>st_dev</code>中的主ID和次ID可以通过接口<code>major()</code>和<code>minor()</code>来提取。对于早期glibc，这2个接口定义为宏。当定义了合适的宏后，这2个接口的定义会出现在头文件<code>sys/types.h</code>中。但是，这种行为在glibc 2.25中弃用，并且从glibc 2.28开始，<code>sys/types.h</code>不再提供这2个接口的定义。从glibc 2.3.3开始，这2个接口成为了特定于GNU的函数<code>gnu_dev_major()</code>和<code>gnu_dev_minor()</code>的别名。对于Linux，这2个接口定义在头文件<code>sys/sysmacros.h</code>中。</p><p>　　<code>major()</code>和<code>minor()</code>返回的整数值的长度因UNIX实现而异。</p><p>　　成员<code>st_uid</code>和<code>st_gid</code>分别是文件的所有者的用户ID和所属组的组ID。</p><p>　　成员<code>st_nlink</code>是指向文件的 (硬) 链接数。</p><h4 id="文件类型和权限">15.1.2 文件类型和权限</h4><p>　　成员<code>st_mode</code>是用于标识文件类型和指定文件权限的位掩码。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_15/layout_of_st_mode_bit_mask.svg"><p>　　文件类型部分可以通过与常量<code>S_IFMT</code>进行与运算<code>&amp;</code>来提取 (对于Linux，该部分由4位表示。但是，SUSv3没有指定如何表示该部分，所以细节因实现而异)。可以通过比较结果值来获取文件类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((statbuf.st_mode &amp; S_IFMT) == S_IFREG)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;regular file\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因为这种操作很常见，所以出现了标准宏来简化这一操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (S_ISREG(statbuf.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;regular file\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　完整的文件类型常量和对应的宏如下 (定义在头文件<code>sys/stat.h</code>中)：</p><table><thead><tr><th>常量</th><th>判断宏</th><th>文件类型</th></tr></thead><tbody><tr><td><code>S_IFREG</code></td><td><code>S_ISREG()</code></td><td>常规文件</td></tr><tr><td><code>S_IFDIR</code></td><td><code>S_ISDIR()</code></td><td>目录</td></tr><tr><td><code>S_IFCHR</code></td><td><code>S_ISCHR()</code></td><td>字符设备</td></tr><tr><td><code>S_IFBLK</code></td><td><code>S_ISBLK()</code></td><td>块设备</td></tr><tr><td><code>S_IFIFO</code></td><td><code>S_ISFIFO()</code></td><td>有名管道或无名管道</td></tr><tr><td><code>S_IFSOCK</code></td><td><code>S_ISSOCK()</code></td><td>套接字</td></tr><tr><td><code>S_IFLNK</code></td><td><code>S_ISLNK()</code></td><td>符号链接</td></tr></tbody></table><p>　　SUSv3说明了以上所有文件类型宏，并且Linux也提供了这些宏。部分UNX实现定义了额外的文件类型 (例如，Solaris的门文件对应的常量是<code>S_IFDOOR</code>)。</p><p>　　最初的POSIX.1没有说明第1列展示的常量，但大多数UNIX实现都提供了这些常量。SUSv3要求提供这些常量。</p><p>　　为了在<code>sys/stat.h</code>中获取<code>S_IFSOCK</code>和<code>S_ISSOCK()</code>的定义，需要将定义宏<code>_BSD_SOURCE</code>或将<code>_XOPEN_SOURCE</code>定义为不小于500的值 (实际情况可能因glibc的版本而异，在某些情况下，<code>_XOPEN_SOURCE</code>必须定义为不小于600的值)。</p><p>　　成员<code>st_mode</code>的后12位定义了文件权限。用户类别、组类别和其他类别的读、写和执行权限占用后9位。</p><h4 id="文件大小已分配的块数和io的最佳块大小">15.1.3 文件大小、已分配的块数和I/O的最佳块大小</h4><p>　　对于常规文件，成员<code>st_size</code>是文件大小 (以字节为单位)。对于符号链接，该成员是符号链接指向的路径名的长度 (以字节为单元)。对于共享内存对象，该成员是对象的大小。</p><p>　　成员<code>st_blocks</code>表示分配给文件的块数 (块大小是512字节)，其中包括指针块 (见14.4)。将块的测量大小指定为512字节是由于历史原因，这是UNIX可用的所有文件系统的最小块大小。现代文件系统使用更大的逻辑块。例如，对于ext2，<code>st_blocks</code>的值总是2、4或8的整数倍，取决于逻辑块是1024、2048或4096字节。</p><p>　　SUSv3没有说明成员<code>st_blocks</code>的测量单元。大多数UNIX实现确实使用512字节的块，但HP-UX 11使用的是特定于文件系统的单元 (例如，在某些情况下，使用的是1024字节的块)。</p><p>　　若文件包含空洞，则成员<code>st_blocks</code>的值比成员<code>st_size</code>对应的块数更少。磁盘使用情况命令<code>du -k file</code>会显示实际分配给文件的空间 (以KB为单位)，即根据成员<code>st_blocks</code>计算而来的值 (而非<code>st_size</code>的值)。</p><p>　　成员<code>st_blksize</code>的名称存在一定的误导性，该成员的值并非底层文件系统的块大小，而是文件系统中的文件的I/O的最佳块大小 (以字节为单位)。执行I/O所用的块小于该成员的值时，I/O效率会更低 (见13.1)。该成员的值通常是4096。</p><h4 id="示例程序">15.1.4 示例程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_stat.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysmacros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file_perms.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">displayStatInfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> stat *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File type: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (sb-&gt;st_mode &amp; S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> S_IFREG:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;regular file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;directory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;character device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;symbolic (soft) link\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFO or pipe\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unknown file type?\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Device containing i-node: major=%ld minor=%ld\n&quot;</span>,</span><br><span class="line">           (<span class="type">long</span>)major(sb-&gt;st_dev), (<span class="type">long</span>)minor(sb-&gt;st_dev));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I-node number: %ld\n&quot;</span>, (<span class="type">long</span>)sb-&gt;st_ino);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Mode: %lo (%s)\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)sb-&gt;st_mode, filePermStr(sb-&gt;st_mode, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sb-&gt;st_mode &amp; (S_ISUID | S_ISGID | S_ISVTX))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; special bits set: %s%s%s\n&quot;</span>,</span><br><span class="line">               (sb-&gt;st_mode &amp; S_ISUID) ? <span class="string">&quot;set-UID &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">               (sb-&gt;st_mode &amp; S_ISGID) ? <span class="string">&quot;set-GID &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">               (sb-&gt;st_mode &amp; S_ISVTX) ? <span class="string">&quot;sticky &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of (hard) links: %ld\n&quot;</span>, (<span class="type">long</span>)sb-&gt;st_nlink);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ownership: UID=%ld GID=%ld\n&quot;</span>, (<span class="type">long</span>)sb-&gt;st_uid, (<span class="type">long</span>)sb-&gt;st_gid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISCHR(sb-&gt;st_mode) || S_ISBLK(sb-&gt;st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Device number (st_rdev): major=%ld; minor=%ld\n&quot;</span>,</span><br><span class="line">               (<span class="type">long</span>)major(sb-&gt;st_rdev), (<span class="type">long</span>)minor(sb-&gt;st_rdev));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File size: %lld bytes\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)sb-&gt;st_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Optimal I/O block size: %ld bytes\n&quot;</span>, (<span class="type">long</span>)sb-&gt;st_blksize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;512B blocks allocated: %lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)sb-&gt;st_blocks);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Last file access: %s&quot;</span>, ctime(&amp;sb-&gt;st_atime));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Last file modification: %s&quot;</span>, ctime(&amp;sb-&gt;st_mtime));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Last status change: %s&quot;</span>, ctime(&amp;sb-&gt;st_ctime));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    Boolean statLink; <span class="comment">/* 若指定了&quot;-l&quot;，则为真 */</span></span><br><span class="line">    <span class="type">int</span> fname;        <span class="comment">/* argv[]中文件名参数的位置 */</span></span><br><span class="line"></span><br><span class="line">    statLink = (argc &gt; <span class="number">1</span>) &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-l&quot;</span>) == <span class="number">0</span>;</span><br><span class="line">    fname = statLink ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fname &gt;= argc || (argc &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s [-l] file\n&quot;</span></span><br><span class="line">                 <span class="string">&quot; -l = use lstat() instead of stat()\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (statLink)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lstat(argv[fname], &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;lstat&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (stat(argv[fname], &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    displayStatInfo(&amp;sb);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会通过<code>stat()</code>来检索命令行参数指定的文件的相关信息。若指定了命令行选项<code>-l</code>，则该程序会使用<code>lstat()</code>来检索符号链接的相关信息。</p><h3 id="文件时间戳">15.2 文件时间戳</h3><p>　　结构体<code>stat</code>的成员<code>st_atime</code>、<code>st_mtime</code>和<code>st_ctime</code>包含文件时间戳。这3个成员分别表示文件的最后访问时间、最后修改时间和最后状态修改时间 (即最后i-node修改时间)。</p><p>　　大多数原生Linux和UNIX文件系统都支持这些时间戳成员，但部分非UNIX文件系统不支持。</p><p>　　以下是本书中介绍的各种库函数和系统调用对文件时间戳所做的修改 (在某些情况下，也会修改父目录的时间戳)：</p><table><colgroup><col style="width:8%"><col style="width:10%"><col style="width:10%"><col style="width:12%"><col style="width:9%"><col style="width:9%"><col style="width:10%"><col style="width:27%"></colgroup><thead><tr><th>函数</th><th>文件或目录的最后访问时间</th><th>文件或目录的最后修改时间</th><th>文件或目录的最后状态修改时间</th><th>父目录的最后访问时间</th><th>父目录的最后修改时间</th><th>父目录的最后状态修改时间</th><th>描述</th></tr></thead><tbody><tr><td><code>chmod()</code></td><td></td><td></td><td>✓</td><td></td><td></td><td></td><td><code>fchmod()</code>与之相同</td></tr><tr><td><code>chown()</code></td><td></td><td></td><td>✓</td><td></td><td></td><td></td><td><code>lchown()</code>和<code>fchown()</code>与之相同</td></tr><tr><td><code>exec()</code></td><td>✓</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>link()</code></td><td></td><td></td><td>✓</td><td></td><td>✓</td><td>✓</td><td>影响第2个参数的父目录</td></tr><tr><td><code>mkdir()</code></td><td>✓</td><td>✓</td><td>✓</td><td></td><td>✓</td><td>✓</td><td></td></tr><tr><td><code>mkfifo()</code></td><td>✓</td><td>✓</td><td>✓</td><td></td><td>✓</td><td>✓</td><td></td></tr><tr><td><code>mknod()</code></td><td>✓</td><td>✓</td><td>✓</td><td></td><td>✓</td><td>✓</td><td></td></tr><tr><td><code>mmap()</code></td><td>✓</td><td>✓</td><td>✓</td><td></td><td></td><td></td><td>最后修改时间和最后状态修改时间只会在更新MAP_SHARED映射时修改</td></tr><tr><td><code>msync()</code></td><td></td><td>✓</td><td>✓</td><td></td><td></td><td></td><td>时间戳只会在修改文件时更新</td></tr><tr><td><code>open()</code>和<code>creat()</code></td><td>✓</td><td>✓</td><td>✓</td><td></td><td>✓</td><td>✓</td><td>创建文件</td></tr><tr><td><code>open()</code>和<code>creat()</code></td><td></td><td>✓</td><td>✓</td><td></td><td></td><td></td><td>截断现有文件</td></tr><tr><td><code>pipe()</code></td><td>✓</td><td>✓</td><td>✓</td><td></td><td></td><td></td><td></td></tr><tr><td><code>read()</code></td><td>✓</td><td></td><td></td><td></td><td></td><td></td><td><code>readv()</code>、<code>pread()</code>和<code>preadv()</code>与之相同</td></tr><tr><td><code>readdir()</code></td><td>✓</td><td></td><td></td><td></td><td></td><td></td><td><code>readdir()</code>可能会缓冲目录条目；时间戳只会在读目录时更新</td></tr><tr><td><code>removexattr()</code></td><td></td><td></td><td>✓</td><td></td><td></td><td></td><td><code>fremovexattr()</code>和<code>lremovexattr()</code>与之相同</td></tr><tr><td><code>rename()</code></td><td></td><td></td><td>✓</td><td></td><td>✓</td><td>✓</td><td>影响所有参数的父目录的时间戳；SUSv3没有说明文件的最后状态修改时间会更新，但部分UNIX实现依旧如此</td></tr><tr><td><code>rmdir()</code></td><td></td><td></td><td></td><td></td><td>✓</td><td>✓</td><td><code>remove(directory)</code>与之相同</td></tr><tr><td><code>sendfile()</code></td><td>✓</td><td></td><td></td><td></td><td></td><td></td><td>更新输入文件的时间戳</td></tr><tr><td><code>setxattr()</code></td><td></td><td></td><td>✓</td><td></td><td></td><td></td><td><code>fsetxattr()</code>和<code>lsetxattr()</code>与之相同</td></tr><tr><td><code>symlink()</code></td><td>✓</td><td>✓</td><td>✓</td><td></td><td>✓</td><td>✓</td><td>设置链接的时间戳 (而非目标文件)</td></tr><tr><td><code>truncate()</code></td><td></td><td>✓</td><td>✓</td><td></td><td></td><td></td><td><code>ftruncate()</code>与之相同；时间戳只会在文件大小变更时更新</td></tr><tr><td><code>unlink()</code></td><td></td><td></td><td>✓</td><td></td><td>✓</td><td>✓</td><td><code>remove(file)</code>与之相同；文件的最后状态修改时间只会在之前的链接数大于1时更新</td></tr><tr><td><code>utime()</code></td><td>✓</td><td>✓</td><td>✓</td><td></td><td></td><td></td><td><code>utimes()</code>、<code>futimes()</code>、<code>futimens()</code>、<code>lutimes()</code>和<code>utimensat()</code>与之相同</td></tr><tr><td><code>write()</code></td><td></td><td>✓</td><td>✓</td><td></td><td></td><td></td><td><code>writev()</code>、<code>pwrite()</code>和<code>pwritev()</code>与之相同</td></tr></tbody></table><p>　　在大部分情况下，系统调用会将相关时间戳设置为当前时间。例外是<code>utime()</code>和类似的系统调用，这些系统调用会将最后访问时间和最后修改时间设置为指定时间。</p><p>　　大多数UNIX系统不会记录文件的创建时间。对于较新的BSD系统，文件创建时间会记录在结构体<code>stat</code>的成员<code>st_birthname</code>中。</p><p>　　对于Linux 2.6及以上版本，结构体<code>stat</code>中的3种时间戳的精度提高到了纳秒。对纳秒的支持提高了需要根据文件时间戳的相对顺序来做出决策的程序 (例如，<code>make</code>) 的准确性。SUSv3没有说明这3种时间戳对纳秒的支持，但SUSv4新增了该规定。</p><p>　　并非所有文件系统都支持纳秒时间戳。JFS、XFS、ext4和Btrfs支持，但ext2、ext3和Reiserfs不支持。</p><p>　　对于glibc API (2.3及以上版本)，时间戳定义为结构体<code>timespec</code>，该结构体包含2个成员，分别表示秒和纳秒。定义了合适的宏后，结构体<code>stat</code>中的3个时间戳成员就会支持纳秒 (例如，成员<code>st_atim.tv_nsec</code>表示最后访问时间的纳秒部分)。</p><h4 id="utime和utimes">15.2.1 <code>utime()</code>和<code>utimes()</code></h4><p>　　存储在文件i-node中的最后访问时间和最后修改时间可以通过<code>utime()</code>或相关系统调用来显式修改。<code>tar</code>和<code>unzip</code>等使用这些系统调用的程序会在解压文件时重置文件时间戳。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *buf)</span>; <span class="comment">/* 成功时返回0，出错返回-1 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">time_t</span> actime;  <span class="comment">/* 访问时间 */</span></span><br><span class="line">    <span class="type">time_t</span> modtime; <span class="comment">/* 修改时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　参数<code>pathname</code>是文件路径名，若该参数是符号链接，则会解引用。参数<code>buf</code>是指向结构体<code>utimbuf</code>的指针或<code>NULL</code>，<code>utime()</code>也会依此做出相应的处理：</p><p>　　● 若<code>buf</code>是指向结构体<code>utimbuf</code>的指针，则最后访问时间和最后修改时间会修改为该结构体中的对应成员的值。对于这种情况，进程的有效用户ID必须匹配文件的用户ID，或者进程是特权进程 (能力<code>CAP_FOWNER</code>)。</p><p>　　● 若<code>buf</code>为<code>NULL</code>，则最后访问时间和最后修改时间都会设置为当前时间。对于这种情况，进程的有效用户ID必须匹配文件的用户ID，进程必须要有文件的写权限 (从逻辑角度，拥有文件的写权限的进程可能会使用副作用包括修改这些文件时间戳的系统调用)，或者进程是特权进程 (能力<code>CAP_FOWNER</code>或<code>CAP_DAC_OVERRIDE</code>)。</p><p>　　若需要修改最后访问时间或最后修改时间，则需要先通过<code>stat()</code>来检索这2个时间，用结果来初始化不需要修改的时间，然后将待修改的时间修改目标值 (若其他进程在这2步之间修改了时间戳，则可能导致竞争)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> <span class="title">utb</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stat(pathname, &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">utb.actime = sb.st_atime; <span class="comment">/* 不修改最后访问时间 */</span></span><br><span class="line">utb.modtime = sb.st_atime;</span><br><span class="line"><span class="keyword">if</span> (utime(pathname, &amp;utb) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;utime&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　若<code>utime()</code>成功，则会将最后状态修改时间修改为<span style="background-color:#ff0">当前时间</span>。</p><p>　　Linux也提供了系统调用<code>utimes()</code> (源于BSD)、库函数<code>futimes()</code> (glibc 2.3及以上版本) 和<code>lutimes()</code> (glibc 2.6及以上版本)，这些函数与<code>utime()</code>类似。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">utimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> timeval tv[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">futimes</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> timeval tv[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lutimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> timeval tv[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>　　不同于<code>utime()</code>，<code>utimes()</code>、<code>futimes()</code>和<code>lutimes()</code>允许指定的时间值达到微秒级别 (结构体<code>timeval</code>)。这提供了对Linux 2.6中提供的文件时间戳的纳秒精度的 (部分) 访问。新访问时间通过<code>tv[0]</code>指定，新修改时间通过<code>tv[1]</code>指定。</p><p>　　对于<code>utimes()</code>和<code>lutimes()</code>，指定文件的方式都是路径名 (参数<code>pathname</code>)。但是，当<code>pathname</code>是符号链接时，则前者会解引用，而后者不会，所以后者修改的是链接的时间戳 (而非指向的文件的时间戳)。</p><p>　　对于<code>futimes()</code>，指定文件的方式是文件描述符 (参数<code>fd</code>)。</p><h4 id="utimensat和futimens">15.2.2 <code>utimensat()</code>和<code>futimens()</code></h4><p>　　系统调用<code>utimensat()</code> (内核2.6.22及以上版本) 和库函数<code>futimens()</code> (glibc 2.6及以上版本) 为设置文件的最后访问时间和最后修改时间提供了扩展功能。这些函数具有以下优势：</p><p>　　● 允许指定的时间值达到纳秒级别。</p><p>　　● 允许独立设置时间戳 (即1次设置1个)。</p><p>　　● 允许独立地将任意时间戳设置为当前时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 700 <span class="comment">/* 或将_POSIX_C_SOURCE定义为不小于200809的值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">utimensat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line">    <span class="type">long</span> tv_nsec;  <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>utimensat()</code>会将参数<code>pathname</code>指定的文件的时间戳修改为参数<code>times</code>指定的时间戳。若<code>times</code>为<code>NULL</code>，则最后访问时间和最后修改时间都会修改为当前时间；若<code>times</code>不为<code>NULL</code>，则最后访问时间会修改为<code>times[0]</code>，最后修改时间会修改为<code>times[1]</code>。</p><p>　　若需要将某个文件时间戳指定为当前时间，则只需要将对应的<code>tv_nsec</code>指定为<code>UTIME_NOW</code>；若不需要某个文件时间戳，则只需要将对应的<code>tv_nsec</code>指定为<code>UTIME_OMIT</code>。这2种情况都会忽略对应的<code>tv_sec</code>的值。</p><p>　　参数<code>dirfd</code>可以指定为<code>AT_FDCWD</code> (若<code>pathname</code>是符号链接，则会解引用) 或引用目录的文件描述符。</p><p>　　参数<code>flags</code>可以指定为0或<code>AT_SYMLINK_NOFOLLOW</code> (若<code>pathname</code>是符号链接，则不会解引用，所以修改的是链接的时间戳)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">times</span>[2];</span></span><br><span class="line"></span><br><span class="line">times[<span class="number">0</span>].tv_sec = <span class="number">0</span>;</span><br><span class="line">times[<span class="number">0</span>].tv_nsec = UTIME_NOW;</span><br><span class="line">times[<span class="number">1</span>].tv_sec = <span class="number">0</span>;</span><br><span class="line">times[<span class="number">1</span>].tv_nsec = UTIME_OMIT;</span><br><span class="line"><span class="keyword">if</span> (utimensat(AT_FDCWD, <span class="string">&quot;myfile&quot;</span>, times, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;utimensat&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会将最后访问时间设置为当前时间，并且不修改最后修改时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">futimens</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　库函数<code>futimens()</code>会将参数<code>fd</code>引用的文件的时间戳修改为参数<code>times</code>指定的时间戳。<code>times</code>的用法与<code>utimensat()</code>的相同。</p><p>　　SUSv3没有说明<code>utimensat()</code>和<code>futimens()</code>，但SUSv4说明了它们。</p><h3 id="文件所有权">15.3 文件所有权</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>chown()</code>会将参数<code>pathname</code>指定的文件的用户ID和组ID修改为参数<code>owner</code>指定的用户ID和参数<code>group</code>指定的组ID。若无需修改用户ID，则可以将<code>owner</code>指定为-1；若无需修改组ID，则可以将<code>group</code>指定为-1。</p><p>　　当<code>pathname</code>是符号链接时，对于Linux 2.2以下的版本，<code>chown()</code>不会解引用 (修改的是链接的用户ID和组ID)；对于Linux 2.2及以上版本，<code>chown()</code>会解引用，并且加入了新系统调用<code>lchown()</code>来替代<code>chown()</code>的旧行为。</p><p>　　只有特权进程 (能力<code>CAP_CHOWN</code>) 才能通过<code>chown()</code>来修改文件的用户ID。非特权进程可以通过<code>chown()</code>来将属于该进程的文件 (进程的有效用户ID匹配文件的用户ID) 的组ID修改为该进程所属的组的组ID。特权进程可以将文件的组ID修改为任意值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500 <span class="comment">/* 或#define _BSD_SOURCE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lchown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchown</span><span class="params">(<span class="type">int</span> fd, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>lchown()</code>和<code>fchown()</code>与<code>chown()</code>类似。<code>fchown()</code>指定文件的方式是文件描述符 (参数<code>fd</code>)。</p><p>　　当文件的用户ID或组ID被修改后，set-user-ID位和set-group-ID位都会被禁用。这是为了确保普通用户不会启用可执行文件的set-user-ID位 (和set-group-ID位)，然后将该可执行文件的用户ID (或组ID) 修改为特权用户的用户ID (或特权组的组ID)，从而在执行该可执行文件时获取特权。</p><p>　　当修改文件的用户ID或组ID时，若group-execute位已被禁用或修改对象是目录，则set-group-ID位不会被禁用。无论是哪种情况，set-group-ID位会用于创建set-group-ID程序之外的目的：</p><p>　　● 若group-execute位已被禁用，则set-group-ID位可用于启用强制文件锁定。</p><p>　　● 若修改对象是目录，则set-group-ID位可用于控制该目录下创建的文件的所有权。</p><p>　　SUSv3没有说明特权用户修改文件的用户ID或组ID时是否禁用set-user-ID位和set-group-ID位。Linux 2.0在这种情况下会禁用这些位，但部分早期2.2内核 (直到2.2.12) 不会禁用这些位。后来的2.2内核在这种情况下又会禁用这些位，并且后续的内核版本一直如此 (但是，在登录root后，若先调用<code>chown()</code>，然后通过命令<code>chmod</code>修改文件的所有权，则命令<code>chmod</code>会通过<code>chown()</code>来重新启用set-user-ID位和set-group-ID位)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_chown.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uid_t</span> uid;</span><br><span class="line">    <span class="type">gid_t</span> gid;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    Boolean errFnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s owner group [file...]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  owner or group can be &#x27;-&#x27;, meaning leave unchanged\n&quot;</span>,</span><br><span class="line">                 argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        uid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        uid = userIdFromName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (uid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;No such user (%s)&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;-&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        gid = groupIdFromName(argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (gid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;No such group (%s)&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改剩余参数指定的文件的所有权 */</span></span><br><span class="line">    errFnd = FALSE;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (chown(argv[j], uid, gid) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errMsg(<span class="string">&quot;chown: %s&quot;</span>, argv[j]);</span><br><span class="line">            errFnd = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(errFnd ? EXIT_FAILURE : EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>chown()</code>的用法，它允许修改任意数量的文件的所有权 (通过命令行参数指定)。</p><h3 id="文件权限">15.4 文件权限</h3><p>　　在15.1.2中提到过，结构体<code>stat</code>的成员<code>st_mode</code>的后12位定义了文件权限，其中的前3位 (U、G和T) 分别是<span style="background-color:#ff0">set-user-ID位</span>、<span style="background-color:#ff0">set-groupr-ID位</span>和<span style="background-color:#ff0">粘滞位</span>，后9位定义了各种类别的用户对文件的访问权限。权限类别分为所有者类别 (也称为用户类别，<code>chmod</code>等命令中使用的<code>u</code>引用的就是该类别)、组类别和其他类别。</p><p>　　● 所有者类别包括文件的所有者。</p><p>　　● 组类别包括与文件属于相同组的用户。</p><p>　　● 其他类别包括其他用户。</p><p>　　所有权限类别都有读权限、写权限和执行权限。</p><p>　　● 读权限表示文件的内容可读。</p><p>　　● 写权限表示文件的内容可写。</p><p>　　● 执行权限表示文件的内容可执行 (即该文件是程序或脚本)。执行脚本需要同时拥有读和执行权限。</p><h4 id="常规文件的权限">15.4.1 常规文件的权限</h4><p>　　可以通过命令<code>ls -l</code>来显示文件的权限和所有权：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l myscript.sh</span></span><br><span class="line">-rwxr-x--- 1 mtk users 1667 Jan 15 09:22 myscript.sh</span><br></pre></td></tr></table></figure><p>　　<code>myscript.sh</code>的文件权限为<code>rwxr-x---</code> (第1个连字符<code>-</code>表示文件类型是常规文件)。为了解析该字符串，可以将这9个字符平均分为3组，每组的3个字符分别代表读、写和执行权限 (若对应的字符不是连字符，则表示已启用)，这3个组分别表示用户类别、组类别和其他类别。因此，用户类别拥有该文件的所有访问权限，组类别拥有该文件的读权限和执行权限，其他类别没有访问权限。</p><p>　　头文件<code>sys/stat.h</code>中定义了用于与结构体<code>stat</code>中的成员<code>st_mode</code>进行与运算<code>&amp;</code>来检测是否启用对应的权限位的常量 (这些常量是通过引用头文件<code>fcntl.h</code>来定义的)，如下所示：</p><table><thead><tr><th>常量</th><th>八进制值</th><th>权限位</th></tr></thead><tbody><tr><td><code>S_ISUID</code></td><td>04000</td><td>set-user-ID位</td></tr><tr><td><code>S_ISGID</code></td><td>02000</td><td>set-group-ID位</td></tr><tr><td><code>S_ISVTX</code></td><td>01000</td><td>粘滞位</td></tr><tr><td><code>S_IRWXU</code></td><td>0700</td><td>用户类别读、写和执行权限位</td></tr><tr><td><code>S_IRUSR</code></td><td>0400</td><td>用户类读位权限位</td></tr><tr><td><code>S_IWUSR</code></td><td>0200</td><td>用户类别写权限位</td></tr><tr><td><code>S_IXUSR</code></td><td>0100</td><td>用户类别执行权限位</td></tr><tr><td><code>S_IRWXG</code></td><td>070</td><td>组类别读、写和执行权限位</td></tr><tr><td><code>S_IRGRP</code></td><td>040</td><td>组类别读权限位</td></tr><tr><td><code>S_IWGRP</code></td><td>020</td><td>组类别写权限位</td></tr><tr><td><code>S_IXGRP</code></td><td>010</td><td>组类别执行权限位</td></tr><tr><td><code>S_IRWXO</code></td><td>07</td><td>其他类别读、写和执行权限位</td></tr><tr><td><code>S_IROTH</code></td><td>04</td><td>其他类别读权限位</td></tr><tr><td><code>S_IWOTH</code></td><td>02</td><td>其他类别写权限位</td></tr><tr><td><code>S_IXOTH</code></td><td>01</td><td>其他类别执行权限位</td></tr></tbody></table><p>　　常量<code>S_ISVTX</code>的名称来源于粘滞位的别名<span style="background-color:#ff0">保存的文本</span>位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file_perms.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FILE_PERMS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PERMS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FP_SPECIAL 1 <span class="comment">/* 表示返回字符串中包含set-user-ID、set-group-ID位和粘滞位 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">filePermStr</span><span class="params">(<span class="type">mode_t</span> perm, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file_perms.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file_perms.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_SIZE sizeof(<span class="string">&quot;rwxrwxrwx&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回ls -l风格的文件权限位掩码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param perm 文件权限位掩码</span></span><br><span class="line"><span class="comment"> * @param flags</span></span><br><span class="line"><span class="comment"> * @return char*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">filePermStr</span><span class="params">(<span class="type">mode_t</span> perm, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> str[STR_SIZE];</span><br><span class="line">    <span class="built_in">snprintf</span>(str, STR_SIZE, <span class="string">&quot;%c%c%c%c%c%c%c%c%c&quot;</span>,</span><br><span class="line">             (perm &amp; S_IRUSR) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, (perm &amp; S_IWUSR) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">             (perm &amp; S_IXUSR) ? (((perm &amp; S_ISUID) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;s&#x27;</span> : <span class="string">&#x27;x&#x27;</span>) : (((perm &amp; S_ISUID) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;S&#x27;</span> : <span class="string">&#x27;-&#x27;</span>),</span><br><span class="line">             (perm &amp; S_IRGRP) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, (perm &amp; S_IWGRP) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">             (perm &amp; S_IXGRP) ? (((perm &amp; S_ISGID) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;s&#x27;</span> : <span class="string">&#x27;x&#x27;</span>) : (((perm &amp; S_ISGID) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;S&#x27;</span> : <span class="string">&#x27;-&#x27;</span>),</span><br><span class="line">             (perm &amp; S_IROTH) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, (perm &amp; S_IWOTH) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">             (perm &amp; S_IXOTH) ? (((perm &amp; S_ISVTX) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;t&#x27;</span> : <span class="string">&#x27;x&#x27;</span>) : (((perm &amp; S_ISVTX) &amp;&amp; (flags &amp; FP_SPECIAL)) ? <span class="string">&#x27;T&#x27;</span> : <span class="string">&#x27;-&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例声明了函数<code>filePermStr()</code>，该函数会根据参数<code>perm</code>指定的文件权限位掩码来返回对应的静态分配的字符串表示 (命令<code>ls</code>风格)。若在参数<code>flags</code>中指定了标志<code>FP_SPECIAL</code>，则返回字符串会包含set-user-ID位、set-group-ID位和粘滞位。</p><h4 id="目录的权限">15.4.2 目录的权限</h4><p>　　目录的权限体系与文件的相同，但3个权限位的含义不同：</p><p>　　● 读权限表示可以列出 (通过命令<code>ls</code>) 目录的内容 (即文件名)。</p><p>　　● 写权限表示可以在目录下创建和删除文件 (文件删除自己不需要任何权限)。</p><p>　　● 执行权限表示可以访问目录下的文件，所以该权限也称为搜索权限。</p><p>　　当执行验证目录的读权限的操作时，有些Linux发行版可能会将命令<code>ls</code>视为默认包含需要目录下的文件的i-node信息的访问权限的标志 (例如，<code>-F</code>)，但这需要目录的执行权限。为了防止这种情况，可以指定命令的路径名 (<code>/bin/ls</code>)。</p><p>　　当访问文件时，除了需要文件的读权限之外，还需要路径名中的<span style="background-color:#ff0">所有目录</span>的执行权限。例如，读文件<code>/home/mtk/x</code>需要<code>/</code>、<code>/mtk</code>和<code>/home/mtk</code>的执行权限。若当前工作目录是<code>/home/mtk/sub1</code>，并且需要访问相对路径名<code>../sub2/x</code>，则需要<code>/home/mtk</code>和<code>/home/mtk/sub2</code>的执行权限。</p><p>　　当在目录下创建和删除文件时，需要该目录的写和执行权限。</p><p>　　拥有能力<code>CAP_DAC_READ_SEARCH</code>的进程总是拥有文件的读权限和目录的执行权限。拥有能力<code>CAP_DAC_OVERRIDE</code>的进程总是拥有文件的读和写权限，并且当文件类型是目录或至少有1个权限类别拥有执行权限时，拥有该能力的进程也会拥有文件的执行权限。</p><h4 id="权限检查算法">15.4.3 权限检查算法</h4><p>　　当为访问文件或目录的系统调用指定路径名时，内核会检查文件权限。当指定的路径名包含目录前缀时，除了检查文件权限之外，还会检查前缀中的所有目录的执行权限。权限检查涉及进程的有效ID和辅助组ID。</p><p>　　当通过<code>open()</code>打开文件后，内核将不再对后续使用结果文件描述符的系统调用 (例如，<code>read()</code>、<code>write()</code>、<code>fstat()</code>、<code>fcntl()</code>和<code>mmap()</code>) 执行权限检查。</p><p>　　内核的权限检查遵循如下规则：</p><p>　　1) 若进程是特权进程，则授予所有访问权限。当文件不是目录，并且至少有1个权限类别拥有权限时，才会授予特权进程相同的权限 (对于有些UNIX实现，特权进程可以直接执行文件)。当文件是目录时，总是会授予特权进程执行权限。</p><p>　　2) 若进程的有效用户ID与文件的用户ID相同，则根据文件的用户类别的权限授予访问权限 (例如，若文件的用户类别的读权限已启用，则进程拥有读权限；否则，进程没有读权限)。</p><p>　　3) 若进程的有效组ID或辅助组ID与文件的组ID相同，则根据文件的组类别的权限授予访问权限。</p><p>　　4) 否则， 根据文件的其他类别的权限授予访问权限。</p><p>　　对用户类别、组类别和其他类别的判断依次进行，并且找到符合的规则后就立即停止检查。</p><p>　　这些文件权限和所有权信息维护在文件i-node中，所有引用相同i-node的链接共享这些信息。</p><p>　　Linux 2.6提供了<strong>访问控制列表</strong>，这使得可以基于每个用户和每个组设置文件权限。若文件有访问控制列表，则会使用以上权限检查算法的修改版本。</p><h4 id="检查文件可访问性">15.4.4 检查文件可访问性</h4><p>　　除了根据有效ID和辅助组ID决定进程的文件访问权限之外，有些程序 (例如，set-user-ID程序和set-group-ID程序) 也会根据实际ID来检查文件可访问性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>; <span class="comment">/* 拥有所有访问权限时返回0，否则返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>access()</code>会根据进程的实际ID (和辅助组ID) 检查参数<code>pathname</code>指定的文件的可访问性 (若<code>pathname</code>是符号链接，则会解引用)。</p><p>　　参数<code>mode</code>是若干个常量进行或运算<code>|</code>得到的结果，这些常量如下：</p><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td><code>F_OK</code></td><td>文件是否存在</td></tr><tr><td><code>R_OK</code></td><td>文件是否可读</td></tr><tr><td><code>W_OK</code></td><td>文件是否可写</td></tr><tr><td><code>X_OK</code></td><td>文件是否可执行</td></tr></tbody></table><p>　　若<code>pathname</code>指定的文件拥有<code>mode</code>指定的所有权限，则<code>access()</code>返回0；若缺少权限或出错，则<code>access()</code>返回-1。</p><p>　　对<code>access()</code>的调用与后续操作之间的时间间隔表示无法保证<code>access()</code>返回的信息在后续操作时依旧有效 (无论该间隔多短)，这可能会导致应用程序设计出现安全漏洞。</p><p>　　假设set-user-ID-root程序先通过<code>access()</code>检查文件可访问性，然后操作文件 (例如，<code>open()</code>或<code>exec()</code>)。若<code>pathname</code>是符号链接，并且恶意用户修改了该链接，使其在执行操作前引用其他文件，则set-user-ID-root程序可能会对没有权限的文件执行操作。因此，尽量避免使用<code>access()</code>。对于这里描述的情况，可以通过临时修改set-user-ID-root程序的有效用户ID来执行预期的操作，然后检查返回值和<code>errno</code>来确定操作是否由于权限问题而失败。</p><p>　　glibc提供了与<code>access()</code>类似的非标准函数<code>euidaccess()</code> (等同于<code>eaccess()</code>)，该函数会根据进程的有效用户ID来检查文件可访问性。</p><h4 id="set-user-id位set-group-id位和粘滞位">15.4.5 set-user-ID位、set-group-ID位和粘滞位</h4><p>　　除了用于创建特权程序，set-user-ID位 (位<code>04000</code>) 和set-group-ID位 (位<code>02000</code>) 还可用于控制在带有选项<code>nogrpid</code>挂载的目录下创建的文件的所属组和启用文件强制锁定。</p><p>　　对于较旧的UNIX实现，粘滞位 (位<code>01000</code>) 通常用于提高程序运行速度。若启用了程序的粘滞位，则程序第1次运行时会在交换空间中保留1份副本，所以后续运行该程序时加载会更快。现代UNIX实现的内存管理系统更复杂，所以这种用法已经过时。</p><p>　　对于Linux和现代UNIX实现，粘滞位的用法大不相同。对于目录，粘滞位相当于<span style="background-color:#ff0">限制性删除</span>位。对目录设置粘滞位后，当且仅当非特权进程拥有该目录的写权限和拥有文件或目录时，才能取消链接 (<code>unlink()</code>和<code>rmdir()</code>) 或重命名 (<code>rename()</code>) 该目录下的文件 (拥有能力<code>CAP_FOWNER</code>的进程无需拥有文件或目录)。这使得多个用户共享相同的目录成为可能 (每个用户只能创建和删除自己的文件)。因此，通常会启用目录<code>/tmp</code>的粘滞位。</p><p>　　可以通过命令<code>chmod +t file</code>或系统调用<code>chomd()</code>来启用文件的粘滞位。当文件的粘滞位启用后，命令<code>ls -l</code>显示的结果中会在其他类别的执行权限位显示大写或小写的t (若其他类别的执行权限位已启用，则显示为t；否则，显示为T)。</p><h4 id="umask">15.4.6 umask</h4><p>　　进程通常会继承父shell的umask，所以shell内置命令<code>umask</code> (修改shell的umask) 可用于控制shell执行的程序的umask。</p><p>　　大多数shell的初始文件会将默认umask设置为八进制值022 (----w--w-)，该值表示组类别和其他类别的写权限应该被禁用。因此，若<code>open()</code>的参数<code>mode</code>指定为0666 (启用所有用户的读写权限)，则文件所有者拥有新创建的文件的读写权限，其他用户仅用于读权限 (rw-r--r--)。若<code>mkdir()</code>的参数<code>mode</code>指定为0777 (启用所有用户的所有权限)，文件所有者拥有新创建的文件的所有权限，其他用户拥有读和执行权限 (rwxr-xr-x)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>; <span class="comment">/* 返回umask的旧值 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>umask()</code>会将进程的umask修改为参数<code>mask</code>指定的值。<code>mask</code>可以指定为15.4.1的表中列出的常量进行或运算<code>|</code>得到的结果。</p><p>　　<code>umask()</code>不会失败，总是会返回umask的旧值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_umask.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file_perms.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYFILE <span class="string">&quot;myfile&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYDIR <span class="string">&quot;mydir&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PERMS (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIR_PERMS (S_IRWXU | S_IRWXG | S_IRWXO)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UMASK_SETTING (S_IWGRP | S_IXGRP | S_IWOTH | S_IXOTH)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="type">mode_t</span> u;</span><br><span class="line"></span><br><span class="line">    umask(UMASK_SETTING);</span><br><span class="line"></span><br><span class="line">    fd = open(MYFILE, O_RDWR | O_CREAT | O_EXCL, FILE_PERMS);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open-%s&quot;</span>, MYFILE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mkdir(MYDIR, DIR_PERMS) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;mkdir-%s&quot;</span>, MYDIR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u = umask(<span class="number">0</span>); <span class="comment">/* 检索 (和清除) umask值 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stat(MYFILE, &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;stat-%s&quot;</span>, MYFILE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Requested file perms: %s\n&quot;</span>, filePermStr(FILE_PERMS, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process umask: %s\n&quot;</span>, filePermStr(u, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Actual file perms: %s\n\n&quot;</span>, filePermStr(sb.st_mode, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stat(MYDIR, &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;stat-%s&quot;</span>, MYDIR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Requested dir. perms: %s\n&quot;</span>, filePermStr(DIR_PERMS, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process umask: %s\n&quot;</span>, filePermStr(u, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Actual dir. perms: %s\n&quot;</span>, filePermStr(sb.st_mode, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlink(MYFILE) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errMsg(<span class="string">&quot;unlink-%s&quot;</span>, MYFILE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rmdir(MYDIR) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errMsg(<span class="string">&quot;rmdir-%s&quot;</span>, MYDIR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了<code>umask()</code>如何与<code>open()</code>和<code>makdir()</code>一起使用。</p><h4 id="修改文件权限">15.4.7 修改文件权限</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>chmod()</code>会将参数<code>pathname</code>指定的文件的权限修改为参数<code>mode</code>指定的权限 (若<code>pathname</code>是符号链接，则会解引用)。</p><p>　　参数<code>mode</code>可以是八进制值或15.4.1的表中列出的常量进行或运算<code>|</code>得到的结果。为了修改文件的权限，需要进程是特权进程 (能力<code>CAP_FOWNER</code>) 或进程的有效用户ID匹配文件的用户ID。</p><p>　　为了修改文件权限的特定位，必须先通过<code>stat()</code>检索现有权限和修改位，然后通过<code>chmod()</code>更新权限：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="type">mode_t</span> mode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stat(<span class="string">&quot;myfile&quot;</span>, &amp;sb) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">mode = (sb.st_mode | S_IWUSR) &amp; ~S_IROTH;</span><br><span class="line"><span class="keyword">if</span> (chmod(<span class="string">&quot;myfile&quot;</span>, mode) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例等同于命令<code>chmod u+w,o-r myfile</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500 <span class="comment">/* 或#define _BSD_SOURCE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fchmod</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>fchmod()</code>与<code>chmod()</code>相似，除了指定文件的方式是文件描述符 (参数<code>fd</code>)。</p><p>　　如前所述，新文件的组ID可能不同于创建该文件的进程的所有组ID，所以非特权进程 (没有能力<code>CAP_FSETID</code>) 对此类文件调用<code>chmod()</code>或<code>fchmod()</code>时内核会清除set-group-ID位 (防止用户为不属于自己的组创建set-group-ID程序)。</p><h3 id="i-node标志">15.5 i-node标志</h3><p>　　对于shell，i-node标志可以通过命令<code>chattr</code>和<code>lsattr</code>设置和查看。对于程序，i-node标志可以通过系统调用<code>ioctl()</code> (见4.5) 检索和修改。</p><p>　　大部分i-node标志设计为供常规文件使用，但其中的部分i-node标志也对目录生效。以下列出了各种可用的i-node标志对应的用于<code>ioctl()</code>的标志 (定义在头文件<code>linux/fs.h</code>中) 和用于命令<code>chattr</code>的选项：</p><table><colgroup><col style="width:27%"><col style="width:16%"><col style="width:56%"></colgroup><thead><tr><th>标志</th><th><code>chattr</code>选项</th><th>目的</th></tr></thead><tbody><tr><td><code>FS_APPEND_FL</code></td><td><code>a</code></td><td>仅限于文件末尾 (需要特权)</td></tr><tr><td><code>FS_COMPR_FL</code></td><td><code>c</code></td><td>启用文件压缩 (未实现)</td></tr><tr><td><code>FS_DIRSYNC_FL</code></td><td><code>D</code></td><td>同步目录更新 (Linux 2.6及以上版本)</td></tr><tr><td><code>FS_IMMUTABLE_FL</code></td><td><code>i</code></td><td>禁用文件修改 (需要特权)</td></tr><tr><td><code>FS_JOURNAL_DATA_FL</code></td><td><code>j</code></td><td>启用数据日志 (需要特权)</td></tr><tr><td><code>FS_NOATIME_FL</code></td><td><code>A</code></td><td>不更新文件最后访问时间</td></tr><tr><td><code>FS_NODUMP_FL</code></td><td><code>d</code></td><td>在使用dump备份文件系统时跳过该文件</td></tr><tr><td><code>FS_NOTAIL_FL</code></td><td><code>t</code></td><td>禁用尾部打包</td></tr><tr><td><code>FS_SECRM_FL</code></td><td><code>s</code></td><td>安全删除 (未实现)</td></tr><tr><td><code>FS_SYNC_FL</code></td><td><code>S</code></td><td>同步文件 (包括目录) 更新</td></tr><tr><td><code>FS_TOPDIR_FL</code></td><td><code>T</code></td><td>以Orlov处理顶层目录 (Linux 2.6及以上版本)</td></tr><tr><td><code>FS_UNRM_FL</code></td><td><code>u</code></td><td>文件无法删除 (未实现)</td></tr></tbody></table><p>　　● <code>FS_APPEND_FL</code>表示只有指定了标志<code>O_APPEND</code>后，才能打开文件来进行写入 (强制所有文件更新添加到文件末尾)。只有特权进程 (能力<code>CAP_LINUX_IMMUTABLE</code>) 才能设置该标志。</p><p>　　● <code>FS_COMPR_FL</code>表示以压缩格式将文件存储在磁盘上，所有主要原生Linux文件系统都没有将该特性作为标准特性 (有些软件包为ext2和ext3实现了该特性)。虽然压缩的成本较低，但由于压缩和解压所用的CPU开销以及压缩文件带来的负面影响 (通过<code>lseek()</code>随机访问文件内容将不再简单)，文件压缩对于很多应用程序都是不可取的。</p><p>　　● <code>FS_DIRSYNC_FL</code>表示同步目录更新 (例如，<code>open(pathname, O_CREAT)</code>、<code>link()</code>、<code>unlink()</code>和<code>mkdir()</code>)，这与13.3中介绍的文件更新同步机制类似。与同步文件更新一样，同步目录更新也会带来性能影响。</p><p>　　● <code>FS_IMMUTABLE_FL</code>表示禁用文件修改，即文件的数据 (<code>write()</code>和<code>truncate()</code>) 和元数据 (例如，<code>chmod()</code>、<code>chown()</code>、<code>unlink()</code>、<code>link()</code>、<code>rename()</code>、<code>rmdir()</code>、<code>utime()</code>、<code>setxattr()</code>和<code>removexattr()</code>) 都无法被修改。只有特权进程 (能力<code>CAP_LINUX_IMMUTABLE</code>) 才能设置该标志。当该标志启用后，特权进程也无法修改文件的数据和元数据。</p><p>　　● <code>FS_JOURNAL_DATA_FL</code>表示启用数据日志。支持该标志的文件系统只有ext3和ext4，这2个文件系统提供了3种级别的日志：journal、ordered和writeback。这3种模式的日志都会记录文件元数据，但只有journal模式才会记录文件数据。对于ordered或writeback模式的文件系统，特权进程 (能力<code>CAP_SYS_RESOURCE</code>) 能够通过设置该标志来启用文件级别的数据更新日志。</p><p>　　● <code>FS_NOATIME_FL</code>表示不更新文件最后访问时间。这样就无需在访问文件时更新文件的i-node，从而提高I/O性能。</p><p>　　● <code>FS_NODUMP_FL</code>表示使用dump备份文件系统时跳过该文件。</p><p>　　● <code>FS_NOTAIL_FL</code>表示禁用尾部打包，支持该标志的文件系统只有Reiserfs (见14.6)。也可以在通过命令<code>mount</code>挂载Reiserfs时指定选项<code>-notail</code>来禁用尾部打包。</p><p>　　● <code>FS_SECRM_FL</code>表示安全删除文件，即删除前先覆盖，以防止磁盘扫描程序读取或重新创建该文件，但这是未实现的特性。实际上，安全删除的问题相当复杂，这可能需要对磁性介质进行多次写入才能安全地擦除以前记录的数据。</p><p>　　● <code>FS_SYNC_FL</code>表示同步文件更新。当对文件启用该标志后，所有对文件的写操作都会同步 (如同调用<code>open()</code>时指定标志<code>O_SYNC</code>)。该标志对目录的效果等同于<code>FS_DIRSYNC_FL</code>。</p><p>　　● <code>FS_TOPDIR_FL</code>表示以<span style="background-color:#ff0">Orlov块分配策略</span>处理该目录。Orlov策略是受到BSD启发的ext2块分配策略的修改版，该策略会试图提高将相关文件 (例如，单个目录中的文件) 放置在磁盘上彼此靠近的位置的几率，进而缩短磁盘寻道时间。该标志仅对ext2、ext3和ext4生效。</p><p>　　● <code>FS_UNRM_FL</code>表示允许恢复已删除的文件，但这是未实现的特性，因为可以在内核外实现文件恢复机制。</p><p>　　对于Linux 2.6.19以下的版本，这些标志并非定义在头文件<code>linux/fs.h</code>中。相反，这些标志定义在一组特定于文件系统的头文件中，带有特定于文件系统的前缀，但值相同 (例如，ext2的标志<code>EXT2_APPEND_FL</code>定义在头文件<code>linux/ext2_fs.h</code>中，Reiserfs的标志<code>REISERFS_APPEND_FL</code>定义在头文件<code>linux/reiser_fs.h</code>)。因此，对于不提供头文件<code>linux/fs.h</code>的旧系统，可以引用这些头文件，然后使用特定于文件系统的名称。</p><p>　　当对目录设置i-node标志后，在该目录下创建的文件和子目录通常会继承i-node标志。该规则存在以下例外：</p><p>　　● 标志<code>FS_DIRSYNC_FL</code> (命令<code>chattr +D</code>) 仅适用于目录，所以只有子目录才会继承该标志。</p><p>　　● 当标志<code>FS_IMMUTABLE_FL</code> (命令<code>chattr +i</code>) 应用于目录后，文件和子目录都不会继承该标志，因为该标志会禁止在目录下创建新文件或目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, FS_IOC_GETFLAGS, &amp;attr) == <span class="number">-1</span>) <span class="comment">/* 获取当前i-node标志 */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">attr |= FS_NOATIME_FL;</span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, FS_IOC_SETFLAGS, &amp;attr) == <span class="number">-1</span>) <span class="comment">/* 更新i-node标志 */</span></span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　对于程序，i-node标志可以通过<code>ioctl()</code>的操作<code>FS_IOC_GETFLAGS</code>和<code>FS_IOC_SETFLAGS</code> (这些常量定义在头文件<code>linux/fs.h</code>) 来检索和修改。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第14章 文件系统"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第14章 文件系统</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_16/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第16章 扩展属性">《Linux/UNIX系统编程手册》第16章 扩展属性 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>