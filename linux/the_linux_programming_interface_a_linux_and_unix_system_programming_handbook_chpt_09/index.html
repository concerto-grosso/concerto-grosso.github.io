<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_09/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_09/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_09/","title":"《Linux/UNIX系统编程手册》第9章 进程凭证"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第9章 进程凭证 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#set-user-id%E7%A8%8B%E5%BA%8F%E5%92%8Cset-group-id%E7%A8%8B%E5%BA%8F"><span class="nav-text">9.1 set-user-ID程序和set-group-ID程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%9A%84set-user-id%E5%92%8C%E4%BF%9D%E5%AD%98%E7%9A%84set-group-id"><span class="nav-text">9.2 保存的set-user-ID和保存的set-group-ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7id%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%84id"><span class="nav-text">9.3 文件系统用户ID和文件系统组ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%92%8C%E4%BF%AE%E6%94%B9%E8%BF%9B%E7%A8%8B%E5%87%AD%E8%AF%81"><span class="nav-text">9.4 检索和修改进程凭证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AE%9E%E9%99%85id%E6%9C%89%E6%95%88id%E4%BF%9D%E5%AD%98%E7%9A%84set-user-id%E5%92%8C%E4%BF%9D%E5%AD%98%E7%9A%84set-group-id"><span class="nav-text">9.4.1 检索和修改实际ID、有效ID、保存的set-user-ID和保存的set-group-ID</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%AE%9E%E9%99%85id%E5%92%8C%E6%9C%89%E6%95%88id"><span class="nav-text">9.4.1.1 检索实际ID和有效ID</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%9C%89%E6%95%88id"><span class="nav-text">9.4.1.2 修改有效ID</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%AE%9E%E9%99%85id%E5%92%8C%E6%9C%89%E6%95%88id"><span class="nav-text">9.4.1.3 修改实际ID和有效ID</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AE%9E%E9%99%85id%E6%9C%89%E6%95%88id%E4%BF%9D%E5%AD%98%E7%9A%84set-user-id%E5%92%8C%E4%BF%9D%E5%AD%98%E7%9A%84set-group-id-1"><span class="nav-text">9.4.1.4 检索和修改实际ID、有效ID、保存的set-user-ID和保存的set-group-ID</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%92%8C%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Fid"><span class="nav-text">9.4.2 检索和修改文件系统ID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%92%8C%E4%BF%AE%E6%94%B9%E8%BE%85%E5%8A%A9%E7%BB%84id"><span class="nav-text">9.4.3 检索和修改辅助组ID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-text">9.4.4 示例程序</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_09/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第9章 进程凭证 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第9章 进程凭证</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-20T00:00:00+08:00">2024-11-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-12-30 00:00:00" itemprop="dateModified" datetime="2024-12-30T00:00:00+08:00">2024-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>12k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　每个进程都有1组关联的数字用户ID和组ID，包括<span style="background-color:#ff0">实际用户ID和实际组ID</span>、<span style="background-color:#ff0">有效用户ID和有效组ID</span>、<span style="background-color:#ff0">保存的set-user-ID和保存的set-group-ID</span>、<span style="background-color:#ff0">文件系统用户ID和文件系统组ID</span> (特定于Linux) 和<span style="background-color:#ff0">辅助组ID</span>。这些ID统称为<strong>进程凭证</strong>。</p><p>　　实际用户ID和实际组ID分别是进程的所有者和所属组的ID。作为登录过程的一部分，登录shell会将用户的密码文件记录的第3个和第4个字段作为其实际用户ID和实际组ID。当进程被创建时，会继承父进程的实际用户ID和实际组ID。</p><p>　　对于大多数UNIX实现 (Linux略有不同)，有效用户ID和有效组ID与辅助组ID一起使用来确定进程访问文件、System V IPC对象和其他系统资源时拥有的权限。此外，系统会通过有效用户ID来决定进程是否能发送信号给其他进程。</p><p>　　辅助组ID是进程所属的附加组的ID。子进程会从父进程继承辅助组ID。登录shell会从系统组文件获取辅助组ID。</p><p>　　有效用户ID为0 (root的用户ID) 的进程是<strong>特权进程</strong>，该进程拥有超级用户的所有特权。特定系统调用只能由特权进程执行。</p><p>　　通常，有效用户ID和有效组ID与对应的实际用户ID和实际组ID相同。但是，可以通过2种方式来让有效用户ID和有效组ID异于对应的实际用户ID和实际组ID。第1种方式是通过系统调用，第2种方式是通过set-user-ID和set-group-ID程序。</p><p>　　所有进程的凭证都可以通过特定于Linux的文件<code>/proc/PID/status</code>的行<code>Uid</code>、<code>Gid</code>和<code>Groups</code>来获取，行<code>Uid</code>和<code>Gid</code>按序列出了实际用户ID、实际组ID、有效用户ID、有效组ID、保存的set-user-ID、保存的set-group-ID、文件系统用户ID和文件系统组ID。</p><p>　　Linux将超级用户特权划分为不同的能力，其中与修改进程的用户ID和组ID相关的能力有2个：</p><p>　　● 能力<code>CAP_SETUID</code>允许进程修改其用户ID。</p><p>　　● 能力<code>CAP_SETGID</code>允许进程修改其组ID。</p><span id="more"></span><h3 id="set-user-id程序和set-group-id程序">9.1 set-user-ID程序和set-group-ID程序</h3><p>　　set-user-ID程序会通过将进程的有效用户ID设置为可执行文件的所有者的用户ID来让进程获得它通常没有的特权。set-group-ID程序对进程的有效组ID执行类似的操作。set-user-ID程序和set-group-ID程序有时会缩写为<span style="background-color:#ff0">set-UID程序</span>和<span style="background-color:#ff0">set-GID程序</span>。</p><p>　　与其他文件一样，可执行文件有1个关联的用户ID和1个关联的组ID (即所有者的用户ID和所属组的组ID)。可执行文件有2个特殊的权限位：set-user-ID位和set-group-ID位 (实际上，所有文件都有这2个权限位，但可执行文件的这2个权限位的功能不同于其他文件)。这2个权限位可以通过命令<code>chmod</code>修改。非特权用户只能修改它拥有的文件的这2个权限位，特权用户 (能力<code>CAP_FOWNER</code>) 可以修改所有文件的这2个权限位。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l prog</span></span><br><span class="line">-rwxr-xr-x 1 root root 302585 Jun 26 15:05 prog</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> u+s prog</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> g+s prog</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -l prog</span></span><br><span class="line">-rwsr-sr-x 1 root root 302585 Jun 26 15:05 prog</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure><p>　　第2行和第6行的命令会列出<code>prog</code>的访问权限，包括set-user-ID位和set-group-ID位。第4行和第5行的命令会启用<code>prog</code>的set-user-ID位和set-group-ID位。启用后，<code>prog</code>的权限位中的x (表示执行权限) 被替换为s。第8行的命令会退出会话。</p><p>　　由于某些原因，set-user-ID位和set-group-ID位对Linux的shell脚本无效。</p><p>　　当set-user-ID程序启动时 (通过<code>exec()</code>来将其加载到进程的内存)，内核会将用于运行该程序的进程的有效用户ID设置为该程序的所有者的用户ID。set-group-ID程序对用于运行程序的进程的有效组ID执行类似的操作。当用于运行程序的进程的有效用户ID或有效组ID以这种方式修改后，进程将拥有通常没有的特权。例如，若可执行文件的所有者是root，并且启用了set-user-ID位，则用于运行该可执行文件的进程将拥有超级用户特权。</p><p>　　有时，可能需要通过set-user-ID程序或set-group-ID程序来将进程的有效ID更改为非0值。例如，为了提供对受保护文件 (或其他系统资源) 的访问，需要创建1个仅拥有访问该文件所需特权的专用用户ID (或组ID)，然后通过set-user-ID程序 (或set-group-ID程序) 来将进程的有效用户ID (或有效组ID) 设置为该用户ID (或组ID)。这样可以避免进程滥用超级用户特权。</p><p>　　对于Linux，常用的set-user-ID程序包括<code>passwd</code> (修改用户密码)、<code>mount</code>和<code>unmount</code> (挂载和卸载文件系统) 以及<code>su</code> (允许用户以不同的用户ID来运行shell)，常用的set-group-ID程序包括<code>wall</code> (发送1条信息到所有属于组<code>tty</code>的终端，而所有终端通常都属于该组)。</p><h3 id="保存的set-user-id和保存的set-group-id">9.2 保存的set-user-ID和保存的set-group-ID</h3><p>　　保存的set-user-ID和保存的set-group-ID旨在与set-user-ID程序和set-group-ID程序一起使用。当运行程序时，会执行以下步骤 (以及很多其他步骤)：</p><p>　　1) 若可执行文件启用了set-user-ID位 (或set-group-ID位)，则用于运行可执行文件的进程的有效用户ID (或有效组ID) 会设置为可执行文件的所有者的用户ID (或组ID)；若未启用，则不会修改用于运行可执行文件的进程的有效用户ID (或有效组ID)。</p><p>　　2) 将有效用户ID和有效组ID的值复制给对应的保存的set-user-ID和保存的set-group-ID。无论执行时是否启用了set-user-ID位和set-group-ID位，该步骤都会发生。</p><p>　　例如，实际用户ID、有效用户ID和保存的set-user-ID都是1000的进程运行所有者是root的set-user-ID程序后，进程的实际用户ID仍然是1000，但有效用户ID和保存的set-user-ID会变为0。</p><p>　　很多系统调用允许set-user-ID程序的有效用户ID在实际用户ID和保存的set-user-ID之间切换。类似的系统调用允许set-group-ID程序修改其有效组ID。通过这种方式，程序可以暂时失去和重新获得与可执行文件的用户ID (或组ID) 关联的所有特权。</p><p>　　保存的set-user-ID和保存的set-group-ID有时也称为<span style="background-color:#ff0">保存的用户ID</span>和<span style="background-color:#ff0">保存的组ID</span>。</p><p>　　保存的set-user-ID和保存的set-group-ID源于System V，随后POSIX将其标准化。4.4BSD之前的版本不提供该这些ID。最初的POSIX.1标准将这些ID的支持作为可选项，后来的标准 (从1988年的FIPS 151-1开始) 强制要求支持这些ID。</p><h3 id="文件系统用户id和文件系统组id">9.3 文件系统用户ID和文件系统组ID</h3><p>　　对于Linux，执行打开文件、修改文件的所有者和修改文件的访问权限等文件系统操作时决定相关权限的ID是文件系统用户ID和文件系统组ID (与辅助组ID一起)，而非有效用户ID和有效组ID。</p><p>　　通常，文件系统ID与对应的有效ID相同。此外，当有效ID被修改时，对应的文件系统ID也会自动变为相同的值。文件系统ID可以通过特定于Linux的系统调用<code>setfsuid()</code>和<code>setfsgid()</code>来修改。</p><p>　　文件系统ID首次出现在Linux 1.2中，在这个内核版本中，只有进程A的有效用户ID与进程B的实际用户ID或有效用户ID相同时，进程A才能发送信号给进程B。这影响了Linux NFS服务器等程序，因为这些程序需要经常访问文件，所以需要将自己的有效用户ID修改为对应的客户端进程的有效用户ID。但是，当NFS服务器修改了自己的有效用户ID后，它容易受到来自非特权用户进程的信号的影响。于是，Linux加入了文件系统ID。通过仅修改自己的文件系统ID，NFS服务器可以伪装成其他用户来访问文件，而不会受到来自用户进程的信号的影响。</p><p>　　从内核 2.0开始，Linux采用了SUSv3的关于信号发送权限的规则，这些规则不涉及目标进程的有效用户ID。因此，文件系统ID不再是必要的，但为了兼容现有软件，这些ID得以存留下来。</p><h3 id="检索和修改进程凭证">9.4 检索和修改进程凭证</h3><p>　　Linux提供了大量用于检索和修改进程凭证的系统调用和库函数，但SUSv3仅详细说明了其中的部分函数。</p><p>　　为了区分set-user-ID程序，这里会使用术语set-user-ID-root程序来表示拥有超级用户特权的set-user-ID程序。</p><h4 id="检索和修改实际id有效id保存的set-user-id和保存的set-group-id">9.4.1 检索和修改实际ID、有效ID、保存的set-user-ID和保存的set-group-ID</h4><h5 id="检索实际id和有效id">9.4.1.1 检索实际ID和有效ID</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的实际用户ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">geteuid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的有效用户ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的实际组ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getegid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回调用进程的有效组ID */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>getuid()</code>和<code>getgid()</code>会返回调用进程的实际ID。系统调用<code>geteuid()</code>和<code>getegid()</code>会返回调用进程的有效ID。这4个系统调用不会失败。</p><h5 id="修改有效id">9.4.1.2 修改有效ID</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>setuid()</code>会将调用进程的有效用户ID (可能还有实际用户ID和保存的set-user-ID) 修改为参数<code>uid</code>指定的值。系统调用<code>setgid()</code>会对调用进程的组ID执行类似的操作。</p><p>　　<code>setuid()</code>和<code>setgid()</code>对调用进程的有效ID做出的修改取决于该进程是否是特权进程 (有效用户ID是0)。以下规则适用于<code>setuid()</code>：</p><p>　　1) 对于非特权进程，只能修改有效用户ID，并且有效用户ID只能修改为对应的实际用户ID或保存的set-user-ID的当前值 (否则，会导致错误<code>EPERM</code>)。这意味着，对于非特权用户，只有运行set-user-ID程序时，对<code>setuid()</code>的调用才有效，因为运行常规程序时，进程的实际用户ID、有效用户ID和保存的set-user-ID相同。对于部分BSD衍生的实现，非特权进程对<code>setuid()</code>或<code>setgid()</code>的调用不同于其他UNIX实现：此次调用会将实际ID、有效ID、保存的set-user-ID和保存的set-group-ID修改为实际ID或有效ID的当前值。</p><p>　　2) 对于特权进程，只有调用<code>setuid()</code>时将<code>uid</code>指定为非0值，实际用户ID、有效用户ID和保存的set-user-ID才会修改为<code>uid</code>指定的值。这个过程是不可逆的，一旦修改后，进程将失去所有特权，所以不能通过<code>setuid()</code>将这些ID恢复为0。</p><p>　　<code>setgid()</code>的情况与<code>setuid()</code>的类似。规则1同样适用于<code>setgid()</code>。对于规则2，因为修改组ID并不会导致进程失去特权，所以特权进程可以任意修改其组ID。</p><p>　　当需要让有效用户ID为0的set-user-ID-root程序永久失去特权时，应该将其有效用户ID和保存的set-user-ID都修改为实际用户ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">seteuid</span><span class="params">(<span class="type">uid_t</span> euid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setegid</span><span class="params">(<span class="type">gid_t</span> egid)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>seteuid()</code>会将调用进程的有效用户ID修改为参数<code>euid</code>指定的值。系统调用<code>setegid()</code>会将调用进程的实际组ID修改为参数<code>egid</code>指定的值。</p><p>　　<code>seteuid()</code>和<code>setegid()</code>对进程的有效ID做出的修改遵循以下规则：</p><p>　　1) 对于非特权进程，有效ID只能修改为实际ID或保存的set-user-ID/set-group-ID的当前值。因此，调用<code>seteuid()</code>等同于调用<code>setuid()</code>，调用<code>setegid()</code>等同于调用<code>setgid()</code> (除了部分BSD衍生的实现之外)。</p><p>　　2) 对于特权进程，有效ID可以修改为任意值。若特权进程通过<code>seteuid()</code>将其有效用户ID修改为非0值，则该进程将会失去特权。由于规则1，该进程可以再次获得特权。</p><p>　　使用<code>seteuid()</code>是让set-user-ID程序和set-group-ID程序临时失去特权，然后再次获得特权的首选方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">euid = geteuid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (seteuid(getuid()) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (seteuid(euid) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    errExit(<span class="string">&quot;seteuid&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>seteuid()</code>和<code>setegid()</code>源于BSD，SUSv3将其标准化，并且大多数UNIX实现都提供了这2个函数。</p><h5 id="修改实际id和有效id">9.4.1.3 修改实际ID和有效ID</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setreuid</span><span class="params">(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setregid</span><span class="params">(<span class="type">gid_t</span> rgid, <span class="type">gid_t</span> egid)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>setreuid()</code>允许调用进程分别修改其实际用户ID (参数<code>ruid</code>) 和有效用户ID (参数<code>euid</code>)。系统调用<code>setregid()</code>允许调用进程分别修改其实际组ID (参数<code>rgid</code>) 和有效组ID (参数<code>eguid</code>)。若只需要修改实际ID或有效ID，则应该把不需要修改的ID指定为-1。</p><p>　　<code>setreuid()</code>对进程的用户ID做出的修改遵循以下规则 (<code>setregid()</code>与之类似)：</p><p>　　1) 对于非特权进程，实际用户ID只能修改为实际用户ID或有效用户ID的当前值，有效用户ID只能修改为实际用户ID、有效用户ID或保存的set-user-ID的当前值。</p><p>　　2) 对于特权进程，实际用户ID和有效用户ID可以修改为任意值。</p><p>　　3) 若<code>ruid</code>不为-1，或者有效用户ID被设置为调用该函数之前的实际用户ID值以外的值，则保存的set-user-ID也会自动被修改为有效用户ID的新值。换句话说，若进程只通过<code>setreuid()</code>来将有效用户ID修改为实际用户ID的当前值，则保存的set-user-ID不变，并且随后对<code>setreuid()</code> (或<code>seteuid()</code>) 的调用可以将有效用户ID恢复成保存的set-user-ID值 (SUSv3没有说明<code>setreuid()</code>和<code>setregid()</code>对保存的set-user-ID和保存的set-group-ID的影响，但SUSv4详细说明了这里描述的行为)。</p><p>　　规则3为set-user-ID程序提供了1种永久失去特权的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setreuid(getuid(), getuid());</span><br></pre></td></tr></table></figure><p>　　如果set-user-ID-root程序需要修改其用户凭证和组凭证，应该先调用<code>setregid()</code>，再调用<code>setreuid()</code>。若以相反的顺序调用这2个函数，则<code>setregid()</code>会失败，因为调用<code>setreuid()</code>后，程序会失去特权。</p><p>　　<code>setreuid()</code>和<code>setregid()</code>源于BSD，SUSv3将其标准化，并且大多数UNIX实现都提供了这2个函数。</p><p>　　SUSv3没有说明非特权进程能否通过<code>setreuid()</code>来将其实际用户ID修改为实际用户ID、有效用户ID或保存的set-user-ID的当前值，并且具体可以对实际用户ID做出哪些修改因实现而异。</p><p>　　SUSv3描述的<code>setregid()</code>的行为略有不同：非特权进程能够将其实际组ID修改为保存的set-group-ID的当前值，或将有效组ID修改为实际组ID或保存的set-group-ID的当前值。同样，具体可以对实际组ID和有效组ID做出哪些修改因实现而异。</p><p>　　4.3BSD及以下版本没有保存的set-user-ID和保存的set-group-ID (SUSv3强制要求提供这2个ID)。因此，对于BSD，<code>setreuid()</code>和<code>setregid()</code>允许进程通过来回切换实际ID和有效ID的值来失去和重获特权。但是，这种行为有副作用：必须通过修改实际用户ID来修改有效用户ID。</p><p>　　对于glibc 2.0及以下版本，<code>seteuid(euid)</code>被实现为<code>setreuid(–1, euid)</code>。对于之后的版本， <code>seteuid(euid)</code>被实现为<code>setresuid(–1, euid, –1)</code>。这2种实现都允许将<code>euid</code>指定为有效用户ID的当前值 (不进行修改)。但是，SUSv3没有说明这种行为，并且部分UNIX实现不允许这种行为。</p><p>　　对于glibc的所有版本，<code>setegid()</code>都被实现为<code>setregid(–1, egid)</code>。与<code>seteuid()</code>类似，<code>egid</code>可以指定为有效组ID的当前值，尽管SUSv3没有说明这种行为。这表示将有效组ID修改为实际组ID以外的值时，<code>setegid()</code>还会修改保存的set-group-ID (通过<code>setreuid()</code>实现的<code>seteuid()</code>会出现类似的行为)。同样，SUSv3没有说明这种行为。</p><h5 id="检索和修改实际id有效id保存的set-user-id和保存的set-group-id-1">9.4.1.4 检索和修改实际ID、有效ID、保存的set-user-ID和保存的set-group-ID</h5><p>　　对于大多数UNIX实现，进程无法直接检索和修改其保存的set-user-ID和保存的set-group-ID。但是，Linux提供了4个用于此目的的系统调用：<code>getresuid()</code>、<code>getresgid()</code>、<code>setresuid()</code>、<code>setresgid()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getresuid</span><span class="params">(<span class="type">uid_t</span> *ruid, <span class="type">uid_t</span> *euid, <span class="type">uid_t</span> *suid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getresgid</span><span class="params">(<span class="type">gid_t</span> *rgid, <span class="type">gid_t</span> *egid, <span class="type">gid_t</span> *sgid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setresuid</span><span class="params">(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid, <span class="type">uid_t</span> suid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setresgid</span><span class="params">(<span class="type">gid_t</span> rgid, <span class="type">gid_t</span> egid, <span class="type">gid_t</span> sgid)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>getresuid()</code>会将调用进程的实际用户ID、有效用户ID和保存的set-user-ID的当前值保存在3个参数指向的位置。系统调用<code>getresgid()</code>会对对应的组ID执行类似的操作。</p><p>　　系统调用<code>setresuid()</code>会将调用进程的实际用户ID、有效用户ID和保存的set-user-ID修改为3个参数指定的值。系统调用<code>setresgid()</code>会对对应的组ID执行类似的操作。若只需要修改这3个ID中的部分ID，则应该把不需要修改的ID指定为-1。</p><p>　　<code>setresuid()</code>对进程的用户ID做出的修改遵循以下规则 (<code>setresgid()</code>与之类似)：</p><p>　　1) 对于非特权进程，实际用户ID、有效用户ID和保存的set-user-ID只能修改为实际用户ID、有效用户ID和保存的set-user-ID的当前值。</p><p>　　2) 对于特权进程，实际用户ID、有效用户ID和保存的set-user-ID可以修改为任意值。</p><p>　　3) 无论该函数如何修改ID，文件系统用户ID都会与有效用户ID的当前值相同。</p><p>　　对<code>setresuid()</code>和<code>setresgid()</code>的调用要么修改所有请求的ID，要么不做修改。SUSv3没有说明这2个函数，并且只有少部分UNIX实现提供了这2个函数。</p><h4 id="检索和修改文件系统id">9.4.2 检索和修改文件系统ID</h4><p>　　特定于Linux的系统调用<code>setfsuid()</code>和<code>setfsgid()</code>用于修改文件系统ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fsuid.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setfsuid</span><span class="params">(<span class="type">uid_t</span> fsuid)</span>; <span class="comment">/* 返回调用之前的文件系统用户ID值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setfsgid</span><span class="params">(<span class="type">gid_t</span> fsgid)</span>; <span class="comment">/* 返回调用之前的文件系统组ID值 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>setfsuid()</code>会将调用进程的文件系统用户ID修改为<code>fsuid</code>指定的值。系统调用<code>setfsgid()</code>会将调用进程的文件系统组ID修改为<code>fsgid</code>指定的值。</p><p>　　<code>setfsuid()</code>对进程的文件系统用户ID做出的修改遵循以下规则 (<code>setfsgid()</code>与之类似)：</p><p>　　1) 对于非特权进程，文件系统用户ID只能修改为实际用户ID、有效用户ID、文件系统用户ID和保存的set-user-ID的当前值。</p><p>　　2) 对于特权进程，文件系统用户ID可以修改为任意值。</p><p>　　这2个系统调用的实现存在些许问题。首先，没有对应的系统调用来检索文件系统ID的当前值。其次，这2个系统调用没有错误检测。当非特权进程试图将其文件系统ID修改为无效值时，这2个系统调用会直接忽略此次修改。无论是否出错，这2个系统调用都会返回调用之前的文件系统ID值。因此，可以通过修改文件系统ID (无论是否出错) 来获取文件系统ID的值。</p><h4 id="检索和修改辅助组id">9.4.3 检索和修改辅助组ID</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getgroups</span><span class="params">(<span class="type">int</span> gidsetsize, <span class="type">gid_t</span> grouplist[])</span>; <span class="comment">/* 成功时返回grouplist中的组ID数，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>getgroups()</code>用于获取调用进程所属的组 (集)，结果存储在参数<code>grouplist</code>指定的数组中。调用进程必须分配<code>grouplist</code>，并在参数<code>gidsetsize</code>中指定其长度。</p><p>　　若<code>getgroups()</code>成功，则会返回<code>grouplist</code>中的组ID数。</p><p>　　对于Linux和大多数UNIX实现，<code>grouplist</code>仅包含调用进程的辅助组ID，但SUSv3允许<code>grouplist</code>包含调用进程的有效组ID。</p><p>　　若调用进程所属的组的数量大于<code>gidsetsize</code>，则<code>getgroups()</code>会返回-1，并将<code>errno</code>设置为<code>EINVAL</code>。为了防止这种情况，可以在声明<code>grouplist</code>时将其大小指定为大于常量<code>NGROUPS_MAX</code> (定义在头文件<code>limits.h</code>中) 的值，该常量定义了进程最多能属于多少个辅助组。因此，可以以如下方式声明<code>grouplist</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">gid_t</span> grouplist[NGROUPS_MAX + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>　　对于Linux 2.6.4及以上版本，<code>NGROUPS_MAX</code>是65536。对于之前的版本，<code>NGROUPS_MAX</code>是32。</p><p>　　应用程序可以在运行时通过特定于Linux的文件<code>/proc/sys/kernel/ngroups_max</code> (Linux 2.6.4及以上版本) 或调用<code>sysconf(_SC_NGROUPS_MAX)</code>来获取<code>NGROUPS_MAX</code>的值。</p><p>　　应用程序在调用<code>getgroups()</code>时可以将<code>gidsetsize</code>指定为0。此时，<code>grouplist</code>不会被修改，但返回值会给出调用进程所属的组的数量。</p><p>　　特权进程可以通过系统调用<code>setgroups()</code>和<code>initgroups()</code>来修改其辅助组ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setgroups</span><span class="params">(<span class="type">size_t</span> gidsetsize, <span class="type">const</span> <span class="type">gid_t</span> *grouplist)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">initgroups</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *user, <span class="type">gid_t</span> group)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>setgroups()</code>会将调用进程的辅助组ID替换为参数<code>grouplist</code>指定的组ID。参数<code>gidsetsize</code>指定<code>grouplist</code>中的组ID的数量。</p><p>　　系统调用<code>initgroups()</code>会扫描<code>/etc/groups</code>，并且生成参数<code>user</code>指定的用户所属的组的列表，然后通过该组列表来初始化调用进程的辅助组ID。此外，参数<code>group</code>指定的组ID也会添加到进程的辅助组ID。</p><p>　　<code>initgroups()</code>主要用于创建登录会话的程序，此类程序通常通过读系统密码文件中的用户记录的组ID字段来获取用于参数<code>group</code>的值。</p><p>　　SUSv3没有说明<code>setgroups()</code>和<code>initgroups()</code>，但所有UNIX实现都提供了这2个函数。</p><h4 id="示例程序">9.4.4 示例程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* idshow.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fsuid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ugid_functions.h&quot;</span> <span class="comment">/* userNameFromId() &amp; groupNameFromId() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SG_SIZE (NGROUPS_MAX + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uid_t</span> ruid, euid, suid, fsuid;</span><br><span class="line">    <span class="type">gid_t</span> rgid, egid, sgid, fsgid;</span><br><span class="line">    <span class="type">gid_t</span> suppGroups[SG_SIZE];</span><br><span class="line">    <span class="type">int</span> numGroups, j;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getresuid(&amp;ruid, &amp;euid, &amp;suid) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;getresuid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getresgid(&amp;rgid, &amp;egid, &amp;sgid) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;getresgid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对于非特权进程，对文件系统ID的修改会被忽略，尽管如此，以下调用会返回当前的文件系统ID */</span></span><br><span class="line">    fsuid = setfsuid(<span class="number">0</span>);</span><br><span class="line">    fsgid = setfsgid(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UID: &quot;</span>);</span><br><span class="line">    p = userNameFromId(ruid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;real=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)ruid);</span><br><span class="line">    p = userNameFromId(euid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;eff=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)euid);</span><br><span class="line">    p = userNameFromId(suid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;saved=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)suid);</span><br><span class="line">    p = userNameFromId(fsuid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fs=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)fsuid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GID: &quot;</span>);</span><br><span class="line">    p = groupNameFromId(rgid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;real=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)rgid);</span><br><span class="line">    p = groupNameFromId(egid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;eff=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)egid);</span><br><span class="line">    p = groupNameFromId(sgid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;saved=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)sgid);</span><br><span class="line">    p = groupNameFromId(fsgid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fs=%s (%ld); &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)fsgid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    numGroups = getgroups(SG_SIZE, suppGroups);</span><br><span class="line">    <span class="keyword">if</span> (numGroups == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;getgroups&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Supplementary groups (%d): &quot;</span>, numGroups);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numGroups; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = groupNameFromId(suppGroups[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s (%ld) &quot;</span>, (p == <span class="literal">NULL</span>) ? <span class="string">&quot;???&quot;</span> : p, (<span class="type">long</span>)suppGroups[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例会通过上述系统调用和库函数来检索和打印进程的用户ID和组ID。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_08/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第8章 用户和组"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第8章 用户和组</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_10/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第10章 时间">《Linux/UNIX系统编程手册》第10章 时间 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>