<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/","title":"《Linux/UNIX系统编程手册》第34章 进程组、会话和作业控制"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第34章 进程组、会话和作业控制 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-text">34.1 进程组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6shell%E4%B8%AD%E4%BD%BF%E7%94%A8setpgid"><span class="nav-text">34.1.1 在作业控制shell中使用setpgid()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%94%A8%E4%BA%8E%E6%A3%80%E7%B4%A2%E5%92%8C%E4%BF%AE%E6%94%B9%E8%BF%9B%E7%A8%8B%E7%BB%84id%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-text">34.1.2 其他用于检索和修改进程组ID的接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D"><span class="nav-text">34.2 会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF%E5%92%8C%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B"><span class="nav-text">34.3 控制终端和控制进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E5%8F%B0%E5%92%8C%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-text">34.4 前台和后台进程组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7sighup"><span class="nav-text">34.5 信号SIGHUP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shell%E5%AF%B9%E4%BF%A1%E5%8F%B7sighup%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">34.5.1 shell对信号SIGHUP的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7sighup%E4%B8%8E%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="nav-text">34.5.2 信号SIGHUP与控制进程的终止</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6"><span class="nav-text">34.6 作业控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6"><span class="nav-text">34.6.1 实现作业控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7"><span class="nav-text">34.6.2 处理作业控制信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-text">34.6.3 孤儿进程组</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第34章 进程组、会话和作业控制 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第34章 进程组、会话和作业控制</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-09-16 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-16T00:00:00+08:00">2025-09-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-09-18 00:00:00" itemprop="dateModified" datetime="2025-09-18T00:00:00+08:00">2025-09-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>25k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　<strong>进程组</strong> (有时称为<strong>作业</strong>) 是由若干个共享同一<span style="background-color:#ff0">进程组标识符</span> (PGID) 的进程组成的集合。进程组ID是与进程ID数据类型 (<code>pid_t</code>) 相同的数字。进程组有1个<strong>进程组组长</strong>。进程组组长是创建进程组的进程，其进程ID会成为创建的进程组的进程组ID。子进程会继承父进程的进程组ID。</p><p>　　进程组的生命周期从进程组组长创建进程组开始，到最后1个进程离开进程组结束。进程可能因终止或合并其他进程而离开进程组。进程组组长无需是进程组的最后1个进程。</p><p>　　<strong>会话</strong>是进程组集合。进程所属的会话由<span style="background-color:#ff0">会话标识符</span> (SID) 决定。会话ID是与进程ID数据类型 (<code>pid_t</code>) 相同的数字。<strong>会话组长</strong>是创建会话的进程，其进程ID会成为创建的会话的会话ID。子进程会继承父进程的会话ID。</p><p>　　会话中的所有进程共享同一<strong>控制终端</strong>。当创建会话时，新会话没有控制终端。当会话组长第1次打开尚未成为会话的控制终端的终端时，将建立控制终端，除非在调用<code>open()</code>时指定了标志<code>O_NOCTTY</code>。作为与控制终端建立连接的结果，会话组长会成为控制终端的<strong>控制进程</strong>。若控制终端断开连接，则内核会发送信号<code>SIGHUP</code>给它的控制进程。1个终端最多只能成为1个会话的控制终端。</p><p>　　通过检查特定于Linux的文件<code>/proc/PID/stat</code>，可以获取任何进程的进程组ID和会话ID、进程的控制终端的设备ID (包含主ID和次ID的十进制整数) 以及控制终端的控制进程的进程ID。</p><p>　　在任何时刻，会话中只能有1个进程组成为控制终端的<strong>前台进程组</strong>，其他进程组都是<strong>后台进程组</strong>。只有前台进程组中的进程才能自由地读写控制终端。当用户在控制终端输入信号生成终端字符时，对应的信号会被发送给前台进程组的所有进程。信号生成终端字符包括生成信号<code>SIGINT</code>的中断字符 (通常是Control-C)、生成信号<code>SIGQUIT</code>的退出字符 (通常是Control-\) 以及生成信号<code>SIGTSTP</code>的挂起字符 (通常是Control-Z)。</p><p>　　从理论角度，可能出现没有前台进程组的会话 (例如，前台进程组的所有进程都已终止，而其他进程没有注意这一点并将自己移动到前台进程组)。实际上，这种情况很罕见。通常，shell是监控前台进程组状态的进程，并且当它注意到 (通过<code>wait()</code>) 前台进程组的所有进程都已终止时，它会将自己移动到前台进程组。</p><p>　　进程组和会话主要用于shell作业控制。对于交互式登录，控制终端是用户登录的终端，登录shell会成为会话组长和该终端的控制进程。从shell启动的每个命令或管道都会导致进程创建，并且shell会将创建的进程放置在新进程组中 (这些进程是该进程组的初始进程，这些进程的子进程也属于该进程组)。若命令或管道以与号<code>&amp;</code>结尾，则会创建为后台进程组；否则，它将被创建为前台进程组。在登录会话期间创建的所有进程都属于同一会话。</p><p>　　进程组偶尔会用于作业控制以外的领域，因为它具有2个有用的属性：父进程可以等待特定进程组中的任何子进程 (见26.1.2)，并且可以向进程组的所有进程发送信号 (见20.3)。</p><p>　　对于窗口环境，控制终端是伪终端，每个终端窗口都有单独的会话，窗口的启动shell是该终端的会话组长和控制进程。</p><span id="more"></span> <img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/relationships_between_process_groups,sessions_and_the_controlling_terminal.svg" title="relationships_between_process_groups,sessions_and_the_controlling_terminal"><p>　　上图展示了执行以下命令的结果进程之间的进程组和会话关系：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $$</span></span><br><span class="line">400</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find / 2&gt; /dev/null | <span class="built_in">wc</span> -l &amp;</span></span><br><span class="line">[1] 659</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> &lt; longlist | <span class="built_in">uniq</span> -c</span> </span><br></pre></td></tr></table></figure><p>　　作业控制是1980年左右第1次出现在BSD的<code>csh</code>的特性。作业控制允许shell用户同时执行多个命令 (作业)，其中的1个命令在前台执行，其他命令在后台执行。作业可以停止和恢复，并且可以在前台和后台之间切换。</p><p>　　对于最初的POSIX.1，作业控制的支持是可选的。后来的UNIX标准则强制要求支持该特性。</p><p>　　在基于字符的哑终端 (仅限于显示ASCII字符的物理终端设备) 时代，许多shell用户都知道如何使用shell作业控制命令。随着运行X Window系统的位图显示器的出现，有关shell作业控制的知识已经不那么常见了。但是，作业控制仍然是有用的特性。使用作业控制来管理多个同时运行的命令比在窗口之间来回切换更便捷。</p><h3 id="进程组">34.1 进程组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 总是返回调用进程的进程组ID */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>getpgrp()</code>会返回调用进程的进程组ID。</p><p>　　系统调用<code>setpgid()</code>会将参数<code>pid</code>指定的进程的进程组ID修改为<code>pgid</code>。若<code>pid</code>为0，则会修改调用进程的进程组ID。若<code>pgid</code>为0，则会将参数<code>pid</code>指定的进程的进程组ID修改为它的进程ID。</p><p>　　若<code>pid</code>和<code>pgid</code>指定的是同一进程 (即<code>pgid</code>为0或匹配<code>pid</code>指定的进程的进程ID)，则会创建1个进程组，并让指定的进程成为进程组组长。若<code>pid</code>和<code>pgid</code>被指定为不同值 (即<code>pgid</code>不为0且不匹配<code>pid</code>指定的进程的进程ID)，则会将进程移动到指定进程组。</p><p>　　<code>setpgid()</code> (和<code>setsid()</code>) 通常用于shell或<code>login</code>等程序。</p><p>　　<code>setpgid()</code>受到以下规则的约束：</p><p>　　● <code>pid</code>只能被指定为调用进程或它的子进程 (违反该规则会导致错误<code>ESRCH</code>)。</p><p>　　● 当在进程组之间移动进程时，调用进程、<code>pid</code>指定的进程以及目标进程组必须属于同一会话 (违反该规则会导致错误<code>EPERM</code>)。</p><p>　　● <code>pid</code>指定的进程不能是会话组长 (违反该规则会导致错误<code>EPERM</code>)。</p><p>　　● 当子进程调用<code>exec()</code>后，父进程不能修改该子进程的进程组ID，因为程序启动后其进程组ID的改变可能会导致混乱 (违反该规则会导致错误<code>EACCES</code>)。</p><h4 id="在作业控制shell中使用setpgid">34.1.1 在作业控制shell中使用<code>setpgid()</code></h4><p>　　父进程不能在子进程调用<code>exec()</code>后修改该子进程的进程组ID的规则影响了作业控制shell的编程，这些shell存在以下要求：</p><p>　　● 作业 (即命令或管道) 中的所有进程必须属于同一进程组。该步骤允许shell使用<code>killpg()</code> (或<code>kill()</code>) 来同时发送作业控制信号给进程组中的所有进程。当然，该操作必须在发送作业控制信号之前完成。</p><p>　　● 将子进程移动到其他进程组的操作必须在子进程在调用<code>exec()</code>之前完成，因为程序本身不知道进程组ID的操作。</p><p>　　作业中的父进程和子进程都可以使用<code>setpgid()</code>来修改子进程的进程组ID。但是，因为在<code>fork()</code>之后父进程和子进程的调度是不确定的，所以不能保证父进程在子进程执行<code>exec()</code>之前修改子进程的进程组ID，也不能保证子进程在父进程试图向其发送作业控制信号之前修改自己的进程组ID。因此，作业控制shell必须被设计为父进程和子进程都在<code>fork()</code>返回之后立即调用<code>setpgid()</code>，并且父进程忽略<code>setpgid()</code>出现错误<code>EACCES</code>的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> childPid;</span><br><span class="line"><span class="type">pid_t</span> pipelinePgid; <span class="comment">/* 管道中的进程的PGID */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他代码 */</span></span><br><span class="line"></span><br><span class="line">childPid = fork();</span><br><span class="line"><span class="keyword">switch</span> (childPid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">/* fork()出错 */</span></span><br><span class="line">    <span class="comment">/* 错误处理 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (setpgid(<span class="number">0</span>, pipelinePgid) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 错误处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 调用exec() */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 父进程 (shell) */</span></span><br><span class="line">    <span class="keyword">if</span> (setpgid(childPid, pipelinePgid) == <span class="number">-1</span> &amp;&amp; errno != EACCES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 错误处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 执行其他操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　实际情况比这个示例略微复杂一些，因为当为管道创建进程时，父shell会记录管道中第1个进程的进程ID，并将其作为进程组ID (<code>pipelinePgid</code>)。</p><h4 id="其他用于检索和修改进程组id的接口">34.1.2 其他用于检索和修改进程组ID的接口</h4><p>　　系统调用<code>getpgrp()</code>和<code>setpgid()</code>的名称中的不同后缀值得解释。</p><p>　　最初，4.2BSD提供了系统调用<code>getprgp(pid)</code>，该系统调用会返回<code>pid</code>指定的进程的进程组ID。实际上，<code>pid</code>总是用于指定调用进程。因此，POSIX委员会认为该调用过于复杂，所以采用了System V的<code>getpgrp()</code>调用 (没有参数，并且总是返回调用进程的进程组ID)。</p><p>　　为了修改进程组ID，4.2BSD提供了<code>setpgrp(pid, pgid)</code>，其用法与<code>setpgid()</code>的类似。主要区别在于BSD的<code>setpgrp()</code>可用于将进程组ID设置为任意值 (<code>setpgid()</code>不能将进程移动到其他会话的进程组)。这会导致一些安全问题，并且也比实现作业控制所需的灵活性更高。因此，POSIX委员会采用了更具限制性的函数，并将其命名为<code>setpgid()</code>。</p><p>　　进一步复杂化问题的是，SUSv3详细说明了<code>getprgp(pid)</code>，使用的是旧版BSD的<code>getpgrp()</code>的语义，并且还说明了<code>setpgrp()</code>的替代函数 (源于System V)，该替代函数没有参数，大致等同于<code>setpgid(0, 0)</code>。</p><p>　　尽管<code>getpgrp()</code>和<code>setpgid()</code>足以实现shell作业控制，但Linux和大多数UNIX实现仍然提供了<code>getpgid(pid)</code>和<code>setpgrp(void)</code>。此外，很多BSD衍生实现还提供了等同于<code>setpgid(pid, pgid)</code>的<code>setprgp(pid, pgid)</code>来保证向后兼容。</p><p>　　若编译程序时显式地定义了功能测试宏<code>_BSD_SOURCE</code>，则glibc提供的将是<code>getpgrp()</code>和<code>setpgrp()</code>的BSD衍生版本，而非默认版本。</p><h3 id="会话">34.2 会话</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>; <span class="comment">/* 返回指定进程的会话ID，出错时返回(pid_t)-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>getsid()</code>会返回参数<code>pid</code>指定的进程的会话ID。若<code>pid</code>为0，则返回调用进程的会话ID。</p><p>　　对于少数UNIX实现 (例如，HP-UX 11)，<code>getsid()</code>只能用于检索与调用进程属于同一会话的进程的会话ID，并且SUSv3允许这种可能性。若<code>pid</code>指定的进程属于其他会话，则<code>getsid()</code>返回-1，并将<code>errno</code>设置为<code>EPERM</code>。该限制不适用于Linux和其他大多数UNIX实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* 返回新会话的会话ID，出错时返回(pid_t)-1 */</span></span><br></pre></td></tr></table></figure><p>　　若调用进程不是进程组组长，则系统调用<code>setsid()</code>会创建1个新会话，调用进程会成为新会话的组长以及新会话中的进程组的组长 (将调用进程的进程组ID和会话ID设置为其进程ID)。</p><p>　　若调用进程是进程组组长，则<code>setsid()</code>会出错 (<code>EPERM</code>)。防止这种情况发生的最简单的方法是调用<code>fork()</code>并让父进程退出，同时子进程调用<code>setsid()</code>。子进程会继承父进程的进程组ID，但会有自己的进程ID，所以子进程不会成为进程组组长。</p><p>　　阻止进程组组长调用<code>setsid()</code>的限制是有必要的。如果没有该限制，进程组组长可能会将自己移动其他 (新) 会话，而原进程组的其他进程仍然留在原会话 (这不会创建新进程组，因为根据定义，进程组组长的进程组ID已经与其进程ID相同)。这将违反会话和进程组的2级层次结构，即进程组的所有进程都必须属于同一会话。</p><p>　　当通过<code>fork()</code>创建新进程时，内核不仅会确保新进程有唯一的进程ID，还会确保其进程ID不会与所有现有进程的进程组ID和会话ID相同。因此，即使进程组或会话的组长已退出，新进程也不会重用组长的进程ID (进而意外地成为现有进程组或会话的组长)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_setsid.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsid() == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld, PGID=%ld, SID=%ld\n&quot;</span>, (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getpgrp(), (<span class="type">long</span>)getsid(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDWR) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open /dev/tty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何通过<code>setsid()</code>创建新会话。该程序会试图打开特殊文件<code>/dev/tty</code>来检查自己是否不再拥有控制终端。当运行该程序后，得到以下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -p $$ -o <span class="string">&#x27;pid pgid sid command&#x27;</span></span></span><br><span class="line">    PID    PGID     SID COMMAND</span><br><span class="line">  12243   12243   12243 bash</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./t_setsid</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">PID=12352, PGID=12352, SID=12352</span></span><br><span class="line">ERROR [ENXIO Device not configured] open /dev/tty</span><br></pre></td></tr></table></figure><p>　　进程成功地将自己移动到新会话的新进程组。因为新会话没有控制终端，所以<code>open()</code>会出错 (在第5行，shell提示符已经与程序输出混合在一起，因为shell注意到父进程在<code>fork()</code>调用后已经退出，所以在子进程完成之前打印了下一个提示符)。</p><h3 id="控制终端和控制进程">34.3 控制终端和控制进程</h3><p>　　<code>fork()</code>创建的子进程会继承父进程的控制终端，并且<code>exec()</code>期间控制终端会被保留。</p><p>　　若进程有控制终端，则打开特殊文件<code>/dev/tty</code>会得到控制终端的文件描述符。当标准输入和输出被重定向，并且程序需要确保它与控制终端通信时，这很有用。若进程没有控制终端，则打开<code>/dev/tty</code>会出错 (<code>ENXIO</code>)。</p><p>　　SUSv3详细说明了函数<code>tcgetsid(int fd)</code> (原型位于在头文件<code>termios.h</code>中)，它会返回<code>fd</code>指定的控制终端关联的会话的ID。该函数由glibc提供，glibc将其实现为基于<code>ioctl()</code>的操作<code>TIOCGSID</code> (<code>ioctl(int fd, TIOCGSID, pid_t *argp)</code>)。</p><p>　　<code>ioctl()</code>的操作<code>TIOCNOTTY</code> (<code>ioctl(int fd, TIOCNOTTY)</code>) 可用于删除进程与<code>fd</code>指定的控制终端的关联。尽管SUSv3没有说明该操作，但大多数UNIX实现都提供了该操作。若调用进程是终端的控制进程，则对于控制进程的终止，将发生以下步骤：</p><p>　　1) 会话的所有进程都会失去与控制终端的关联。</p><p>　　2) 控制终端失去与会话的关联，并且可以作为其他会话组长的控制终端。</p><p>　　3) 内核发送信号<code>SIGHUP</code>给前台进程组的所有进程来通知它们失去了控制终端。</p><p>　　SUSv3没有说明会话获取控制终端的行为，仅说明了通过<code>open()</code>打开终端时指定了标志<code>O_NOCTTY</code>会保证该终端不会成为会话的控制终端 (该Linux语义源于System V)。</p><p>　　对于BSD，会话组长打开终端绝不会使该终端成为它的控制终端。相反，会话组长需要显式地使用<code>ioctl()</code>的操作<code>TIOCSCTTY</code> (<code>ioctl(fd, TIOCSCTTY, int arg)</code>) 来让<code>fd</code>引用的终端成为控制终端。Linux提供了该操作，但很多 (非BSD) UNIX实现未提供该操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">/* 定义常量L_ctermid */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctermid</span><span class="params">(<span class="type">char</span> *ttyname)</span>; <span class="comment">/* 返回控制终端的路径名字符串，无法获取控制终端的路径名时返回NULL */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>ctermid()</code>会返回调用进程的控制终端的路径名字符串。该函数会以2种方式返回控制终端的路径名字符串：返回值和参数<code>ttyname</code>。若<code>ttyname</code>不为<code>NULL</code>，则它应该指向不小于<code>L_ctermid</code>字节的缓冲区，并且会包含控制终端的路径名。在这种情况下，返回值也是指向该缓冲区的指针。若<code>ttyname</code>为<code>NULL</code>，则返回值是指向静态分配的缓冲区的指针。因此，当<code>ttyname</code>为<code>NULL</code>时，该函数是不可重入函数。</p><h3 id="前台和后台进程组">34.4 前台和后台进程组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">tcgetpgrp</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 返回终端的前台进程组的进程组ID，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcsetpgrp</span><span class="params">(<span class="type">int</span> fd, <span class="type">pid_t</span> pgid)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>tcgetpgrp()</code>会返回参数<code>fd</code>指定的终端的前台进程组的进程组ID (必须是调用进程的控制终端)。若指定的终端没有前台进程组，则返回大于1的值，并且该值不匹配任何现有进程组的进程组ID (这是SUSv3所要求的)。</p><p>　　函数<code>tcsetpgrp()</code>会修改终端的前台进程组。若调用进程有控制终端，则参数<code>fd</code>需要被指定为引用该终端，然后该函数会将该终端的前台进程组修改为参数<code>pgid</code>指定的前台进程组 (该前台进程组必须与调用进程属于同一会话)。</p><p>　　SUSv3标准化了<code>tcgetpgrp()</code>和<code>tcsetpgrp()</code>。对于Linux和很多UNIX实现，它们被实现为基于<code>ioctl()</code>的非标准操作<code>TIOCGPGRP</code>和<code>TIOCSPGRP</code>。</p><h3 id="信号sighup">34.5 信号<code>SIGHUP</code></h3><p>　　当控制进程失去其终端连接时，内核会发送信号<code>SIGHUP</code>给该进程来通知它 (还会发送信号<code>SIGCONT</code>来确保该进程在被信号停止时恢复)。通常，这会在以下2种情况下发生：</p><p>　　● 终端驱动程序检测到 "断开连接" (表示调制解调器或终端线路上的信号丢失)。</p><p>　　● 工作站上的终端窗口被关闭 (因为与终端窗口关联的伪终端主端的最后1个打开的文件描述符被关闭)。</p><p>　　信号<code>SIGHUP</code>的默认处理方式是终止进程。若控制进程注册了<code>SIGHUP</code>处理函数或忽略该信号，则随后读取终端时会返回EOF。</p><p>　　SUSv3规定，若终端断开连接，同时发生了导致<code>read()</code>出现错误<code>EIO</code>的条件之一，则<code>read()</code>会返回EOF还是出错 (<code>EIO</code>) 是不确定的。可移植程序必须允许这2种可能性。</p><p>　　信号<code>SIGHUP</code>被发送给控制进程会触发连锁反应，导致该信号被发送给很多其他进程。这会通过以下2种方式发生：</p><p>　　● 控制终端通常是shell。shell会注册<code>SIGHUP</code>处理函数，所以shell在终止前会发送信号<code>SIGHUP</code>给它创建的所有作业，该信号默认会终止这些作业。若这些作业选择捕获该信号，则它们会收到shell终止的信息。</p><p>　　● 当控制终端的控制进程终止时，内核会取消会话的所有进程与控制终端的关联，取消控制终端与会话的关联，并通过向前台进程组的所有进程发送信号<code>SIGHUP</code>来通知它们已失去控制终端。</p><p>　　有些作业控制shell会在正常退出时 (例如，用户显式注销或在shell窗口中输入Control-D) 发送信号<code>SIGHUP</code>来停止后台作业。<code>bash</code>和<code>ksh</code>都会这样做 (在第1次试图注销后打印1条信息)。</p><p>　　命令<code>nohup</code>可以让命令不受信号<code>SIGHUP</code>的影响：启动命令时将信号<code>SIGHUP</code>的处理方式设置为<code>SIG_IGN</code>。<code>bash</code>的内置命令<code>disown</code>具有类似的功能，它会从shell的作业列表中删除作业，防止shell终止时发送信号<code>SIGHUP</code>给该作业。</p><h4 id="shell对信号sighup的处理">34.5.1 shell对信号<code>SIGHUP</code>的处理</h4><p>　　对于登录会话，shell通常是终端的控制进程。大多数shell被设计为当以交互式运行时，会安装<code>SIGHUP</code>处理函数。该处理函数会终止进程，但在终止前会发送信号<code>SIGHUP</code>给它创建的所有进程组 (随后可能发送信号<code>SIGCONT</code>，取决于shell以及作业当前是否已停止)。这些进程组中的进程如何响应信号<code>SIGHUP</code>取决于应用程序 (默认是终止进程)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* catch_SIGHUP.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 500</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    childPid = fork();</span><br><span class="line">    <span class="keyword">if</span> (childPid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childPid == <span class="number">0</span> &amp;&amp; argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (setpgid(<span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>) <span class="comment">/* 移动到新进程组 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;setpgid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld; PPID=%ld; PGID=%ld; SID=%ld\n&quot;</span>, (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getppid(),</span><br><span class="line">           (<span class="type">long</span>)getpgrp(), (<span class="type">long</span>)getsid(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">60</span>); <span class="comment">/* 未被处理的信号SIGALRM会确保进程最终会终止 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待信号 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld: caught SIGHUP\n&quot;</span>, (<span class="type">long</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了shell收到信号<code>SIGHUP</code>时会向它创建的作业发送该信号。该程序会创建1个子进程，然后父进程和子进程都暂停来捕获信号<code>SIGHUP</code>并在收到该信号时打印1条信息。若指定了可选的命令行参数，则子进程会将自己移动到会话的其他进程组。这是为了展示shell不会发送信号<code>SIGHUP</code>给不是由它创建的进程组，即使该进程组和shell属于同一会话。因为<code>for</code>语句会无限循环，所以该程序会通过<code>alarm()</code>来设置定时器 (发送信号<code>SIGALRM</code>)，以确保进程最终会终止。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $$</span></span><br><span class="line">5533</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./catch_SIGHUP &gt; samegroup.log 2&gt;&amp;1 &amp;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./catch_SIGHUP x &gt; diffgroup.log 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure><p>　　第3行的命令创建的子进程与shell位于同一进程组，而第4行的命令创建的子进程与shell位于不同进程组。当关闭运行这些命令的终端窗口后，文件<code>samegroup.log</code>和<code>diffgroup.log</code>的内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> samegroup.log</span></span><br><span class="line">PID=5612; PPID=5611; PGID=5611; SID=5533</span><br><span class="line">PID=5611; PPID=5533; PGID=5611; SID=5533</span><br><span class="line">5611: caught SIGHUP</span><br><span class="line">5612: caught SIGHUP</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> diffgroup.log</span></span><br><span class="line">PID=5614; PPID=5613; PGID=5614; SID=5533</span><br><span class="line">PID=5613; PPID=5533; PGID=5613; SID=5533</span><br><span class="line">5613: caught SIGHUP</span><br></pre></td></tr></table></figure><p>　　文件<code>samegroup.log</code>的内容表示父进程和子进程都收到了来自shell的信号。文件<code>diffgroup.log</code>的内容表示只有父进收到了来自shell的信号。</p><h4 id="信号sighup与控制进程的终止">34.5.2 信号<code>SIGHUP</code>与控制进程的终止</h4><p>　　若因终端断开连接而发送给控制进程的信号<code>SIGHUP</code>导致控制进程终止，则该信号还会被发送给终端的前台进程组的所有进程。该行为是控制进程终止的结果，而非与信号<code>SIGHUP</code>特别相关的行为。当控制进程终止时，信号<code>SIGHUP</code>会被发送给前台进程组。对于Linux，信号<code>SIGHUP</code>后会跟着信号<code>SIGCONT</code>，以确保进程组能够恢复 (若之前已被信号停止)。但是，SUSv3没有说明这种行为，并且大多数UNIX实现在这种情况下不会发送信号<code>SIGCONT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* disc_SIGHUP.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID %ld: caught signal %2d (%s)\n&quot;</span>, (<span class="type">long</span>)getpid(), sig, strsignal(sig));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> parentPid, childPid;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s &#123;d|s&#125;... [ &gt; sig.log 2&gt;&amp;1 ]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    parentPid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID of parent process is: %ld\n&quot;</span>, (<span class="type">long</span>)parentPid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Foreground process group ID is: %ld\n&quot;</span>, (<span class="type">long</span>)tcgetpgrp(STDIN_FILENO));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        childPid = fork();</span><br><span class="line">        <span class="keyword">if</span> (childPid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (childPid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">&#x27;d&#x27;</span>) <span class="comment">/* d表示移动到不同的进程组 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (setpgid(<span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    errExit(<span class="string">&quot;setpgid&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">            sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">            sa.sa_handler = handler;</span><br><span class="line">            <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 子进程退出循环 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">60</span>); <span class="comment">/* 确保进程最终会终止 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld PGID=%ld\n&quot;</span>, (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getpgrp());</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause(); <span class="comment">/* 等待信号 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了控制进程的终止会导致信号<code>SIGHUP</code>被发送给前台进程组的所有进程。该程序会为每个命令行参数创建1个子进程 (第31~35行)。若命令行参数以字母<code>d</code>结尾，则对应的子进程会被移动到新进程组 (第39~45行)；否则，子进程将与父进程位于同一进程组。所有子进程都会注册<code>SIGHUP</code>处理函数 (第47~53行)，该处理函数会打印进程的进程ID和信号编号 (第6~9行)。为了确保进程最终会终止，所有进程都会调用<code>alarm()</code> (第58行)。最后，所有进程都打印自己的进程ID和进程组ID并循环等待信号到达 (第60~64行)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exec</span> ./disc_SIGHUP d s s &gt; sig.log 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure><p>　　shell内置命令<code>exec</code>会导致shell调用<code>exec()</code>，用指定的程序替换自己。因为shell是终端的控制进程，所以替换后的程序也是控制进程，并且终端窗口关闭时会收到信号<code>SIGHUP</code>。当关闭终端窗口后，文件<code>sig.log</code>的内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> sig.log</span></span><br><span class="line">PID of parent process is: 12733</span><br><span class="line">Foreground process group ID is: 12733</span><br><span class="line">PID=12755 PGID=12755</span><br><span class="line">PID=12756 PGID=12733</span><br><span class="line">PID=12757 PGID=12733</span><br><span class="line">PID=12733 PGID=12733</span><br><span class="line">PID 12756: caught signal  1 (Hangup)</span><br><span class="line">PID 12757: caught signal  1 (Hangup)</span><br></pre></td></tr></table></figure><p>　　关闭终端窗口会导致信号<code>SIGHUP</code>被发送给控制进程 (父进程)，从而导致其终止。此外，与父进程位于同一进程组 (即终端的前台进程组) 的2个子进程也收到了该信号，而另一个 (后台) 进程组的子进程没有收到该信号。</p><h3 id="作业控制">34.6 作业控制</h3><p>　　当在终端输入以与号<code>&amp;</code>结尾的命令时，它会作为后台作业运行，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -r SIGHUP /usr/src/linux &gt;x &amp;</span></span><br><span class="line">[1] 18932</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sleep</span> 60 &amp;</span></span><br><span class="line">[2] 18934</span><br></pre></td></tr></table></figure><p>　　shell会为每个后台作业分配1个唯一的作业号。当启动后台作业和通过各种作业控制命令控制或监控后台作业时，作业号会显示在方括号中。作业号后的数字是为了执行命令而创建的进程的进程ID或管道的最后1个进程的进程ID (若是管道)。对于后续的命令，作业可以通过符号<code>%num</code>表示，其中<code>num</code>是作业号。</p><p>　　在很多情况下，参数<code>%num</code>会被省略，此时，默认使用<span style="background-color:#ff0">当前作业</span>。当前作业是最后1个在前台停止的作业或最后1个在后台启动的作业 (若没有符合要求的前台作业)。实际上，不同的shell在确定哪个后台作业被视为当前作业的细节上存在一些差异。此外，符号<code>%%</code>或<code>%+</code>表示当前作业，符号<code>%-</code>表示上一个的当前作业。</p><p>　　shell内置命令<code>jobs</code>会列出所有后台作业，当前作业和上一个的当前作业分别由加号<code>+</code>和减号<code>-</code>标记。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  - Running    grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br><span class="line">[2]  + Running    sleep 60 &amp;</span><br></pre></td></tr></table></figure><p>　　此时，shell是终端的前台进程。因为只有1个前台进程能够从控制终端读取输入和接收终端生成的信号，所以可能需要将某个后台作业移动到前台。这可以通过shell内置命令<code>fg</code>完成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">fg</span> %1</span>     </span><br><span class="line">grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br></pre></td></tr></table></figure><p>　　当作业运行在前台时，可以通过终端挂起字符 (通常是Control-Z) 来挂起作业。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入Control-Z</span><br><span class="line">[1]  + Stopped    grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br></pre></td></tr></table></figure><p>　　当输入Control-Z后，shell会显示已在后台停止的命令。若有需要，可以使用命令<code>fg</code>来在前台恢复该作业，或者使用命令<code>bg</code>来在后台恢复该作业。对于这2种情况，shell都会通过发送信号<code>SIGCONT</code>来恢复停止的作业。</p><p>　　可以通过发送信号<code>SIGSTOP</code>给后台作业来停止该作业 (<code>ksh</code>和<code>csh</code>提供了命令<code>stop</code>作为命令<code>kill -STOP</code>的简写)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -STOP %1</span></span><br><span class="line">[1]  + Stopped    grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  + Stopped    grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br><span class="line">[2]  - Running    sleep 60 &amp;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">bg</span> %1</span></span><br><span class="line">[1]  + grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br></pre></td></tr></table></figure><p>　　当后台作业完成时，shell会在下一个提示符前打印1条信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入回车键以显示额外的shell提示符</span><br><span class="line">[1]  - Done    grep -r SIGHUP /usr/src/linux &gt;x &amp;</span><br><span class="line">[2]  + Done    sleep 60 &amp;</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure><p>　　当后台作业试图从终端读取时，信号<code>SIGTTIN</code>会被发送给该作业，其默认处理行为是停止作业。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt; x.txt &amp;</span></span><br><span class="line">[1] 18947</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">输入回车键，以便在下一个shell提示符之前显示作业状态变化</span></span><br><span class="line">[1]  + Stopped cat &gt; x.txt   </span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure><p>　　此时，必须将该作业恢复到前台并提供必要的输入。若有需要，可以先暂停该作业，然后在后台恢复，从而继续在后台执行该作业 (当然，对于这个示例，<code>cat</code>会再次立即停止，因为它会再次从终端读取)。</p><p>　　在默认情况下，后台作业被允许输出到控制终端。但是，若为终端指定了标志<code>TOSTOP</code>，则后台作业试图输出到控制终端会导致信号<code>SIGTTOU</code>的生成。与信号<code>SIGTTIN</code>相同，信号<code>SIGTTOU</code>会停止作业。</p><p>　　对于这个示例和后续的一些示例，可能并不总是需要输入回车键来查看作业状态的变化。根据内核调度策略，shell可能会在下一个shell提示符之前收到关于后台作业状态变化的通知。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">stty</span> tostop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> &amp;</span></span><br><span class="line">[1] 19023</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">输入回车键，以便在下一个shell提示符之前显示作业状态变化</span></span><br><span class="line">[1]  + Stopped    date</span><br></pre></td></tr></table></figure><p>　　第1条命令会启用终端的标志<code>TOSTOP</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">fg</span></span></span><br><span class="line">date</span><br><span class="line">Tue Dec 28 16:20:51 CEST 2010</span><br></pre></td></tr></table></figure><p>　　这里需要将作业在前台恢复才能看到输出。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/job-control_states.svg" title="job-control_states"><p>　　上图展示了作业控制的各种状态以及用于在各种状态之间移动作业的shell命令和终端字符以及伴随的信号。</p><h4 id="实现作业控制">34.6.1 实现作业控制</h4><p>　　尽管在最初的POSIX.1中是可选的，但包括SUSv3在内的后续标准要求支持作业控制实现。该支持需要满足以下条件：</p><p>　　● 实现必须提供特定的作业控制信号：<code>SIGTSTP</code>、<code>SIGSTOP</code>、<code>SIGCONT</code>、<code>SIGTTOU</code>和<code>SIGTTIN</code>。此外，还需要提供信号<code>SIGCHLD</code>，因为它允许shell在子进程终止或停止时收到通知。</p><p>　　● 终端驱动程序必须支持作业控制信号的生成，以便输入特定字符以及后台作业执行终端I/O和其他特定终端操作时特定信号会被发送给相关进程组。为此，终端驱动程序必须记录会话ID (控制进程) 和与终端关联的前台进程组ID。</p><p>　　● shell必须支持作业控制 (大多数现代shell都支持)。该支持以之前描述的命令的形式提供，用于在前台和后台之间移动作业以及监控作业状态，并且其中的某些命令会发生信号给作业。此外，当执行将作业从前台运行状态移动其他作业控制状态的操作时，shell会调用<code>tcsetpgrp()</code>来调整终端驱动程序的前台进程组记录。</p><p>　　通常，当发送进程的的实际或有效用户ID匹配接收进程的实际用户ID或保存的set-user-ID时，发送进程才能发送信号给接收进程。但是，信号<code>SIGCONT</code>是例外。内核允许进程发送该信号给同一会话的任意进程。这是必要的，以便当用户启动会修改其凭证的set-user-ID程序后，仍然可以在该程序停止时通过信号<code>SIGCONT</code>恢复它。</p><p>　　SUSv3详细说明了一些适用于后台作业生成信号<code>SIGTTIN</code>和<code>SIGTTOU</code>的特殊情况：</p><p>　　● 若进程当前阻塞或忽略了信号<code>SIGTTIN</code>，则该信号不会被发送给该进程。相反，对控制终端调用<code>read()</code>会出错 (<code>EIO</code>)；否则，进程将无法得知<code>read()</code>调用不被允许。</p><p>　　● 若进程当前阻塞或忽略了信号<code>SIGTTOU</code>，则该信号也不会被发送给进程。相反，对控制终端调用<code>write()</code>会被允许 (即标志<code>TOSTOP</code>会被忽略)。</p><p>　　● 若后台进程试图对其控制终端调用某些修改终端驱动程序的数据结构的函数，则会生成信号<code>SIGTTOU</code>。这些函数包括<code>tcsetpgrp()</code>、<code>tcsetattr()</code>、<code>tcflush()</code>、<code>tcflow()</code>、<code>tcsendbreak()</code>和<code>tcdrain()</code>。若信号<code>SIGTTOU</code>已被阻塞或忽略，则这些调用会成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* job_mon.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cmdNum; <span class="comment">/* 管道中的位置 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getpid() == getpgrp())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 进程组组长 */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Terminal FG process group: %ld\n&quot;</span>, (<span class="type">long</span>)tcgetpgrp(STDERR_FILENO));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Process %ld (%d) received signal %d (%s)\n&quot;</span>, (<span class="type">long</span>)getpid(),</span><br><span class="line">            cmdNum, sig, strsignal(sig));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当捕获的信号是SIGTSTP时，实际不会停止进程。因此，这里会通过raise()发送信号SIGSTOP来停止进程 */</span></span><br><span class="line">    <span class="keyword">if</span> (sig == SIGTSTP)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSTOP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGTSTP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCONT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isatty(STDIN_FILENO))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 若stdin是终端，则表示这是管道中的第1个进程：打印标题并初始化待发送到管道的信息 */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Terminal FG process group: %ld\n&quot;</span>, (<span class="type">long</span>)tcgetpgrp(STDIN_FILENO));</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Command PID PPID PGRP SID\n&quot;</span>);</span><br><span class="line">        cmdNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 若不是管道中的第1个进程，则从管道中读取信息 */</span></span><br><span class="line">        <span class="keyword">if</span> (read(STDIN_FILENO, &amp;cmdNum, <span class="keyword">sizeof</span>(cmdNum)) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;read got EOF or error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmdNum++;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%4d %5ld %5ld %5ld %5ld\n&quot;</span>, cmdNum, (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getppid(),</span><br><span class="line">            (<span class="type">long</span>)getpgrp(), (<span class="type">long</span>)getsid(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若不是最后1个进程，则向下一个进程传递信息 */</span></span><br><span class="line">    <span class="keyword">if</span> (!isatty(STDOUT_FILENO)) <span class="comment">/* 若不是tty，则应该是管道 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (write(STDOUT_FILENO, &amp;cmdNum, <span class="keyword">sizeof</span>(cmdNum)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errMsg(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待信号 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了shell如何将管道中的命令组织成作业 (进程组)、特定信号的发送以及在作业控制下对终端前台进程组设置所做的修改。该程序被设计为可以在管道中运行多个实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./job_mon | ./job_mon | ./job_mon</span></span><br></pre></td></tr></table></figure><p>　　该程序会执行以下步骤：</p><p>　　1) 该程序会在启动时为信号<code>SIGINT</code>、<code>SIGTSTP</code>和<code>SIGCONT</code>注册处理函数 (第30~44行)。首先，该处理函数会打印终端的前台进程组。为了避免输出多行相同的内容，该操作仅由进程组组长完成 (第11~15行)。然后，该处理函数会打印进程的ID、进程在管道中的位置以及收到的信号 (第16~17行)。当捕获的信号是<code>SIGTSTP</code>时，该处理函数还会执行一些额外的操作，因为该信号实际不会停止进程。为了停止进程，该处理函数会调用<code>raise()</code>来发送信号<code>SIGSTOP</code> (第20~23行)。</p><p>　　2) 若程序是管道中的第1个进程，则会打印所有进程打印的输出的标题。为了判断自己是否为管道中的第1个 (或最后1个) 进程，程序会调用函数<code>isatty()</code>来检查其标准输入 (或输出) 是否为终端 (第46~52行)。若指定的文件描述符引用的是管道，则该函数会返回假 (0)。</p><p>　　3) 程序构建传递给管道中的下一个进程的信息，该信息是1个整数，表示该进程在管道中的位置的整数。对于第1个进程，该信息为数字1。此外，第1个进程会将该信息初始化为0 (第51行)。若不是管道中的第1个进程，则程序会先从上一个进程读取该信息 (第53~60行)。程序会在执行下一步前将信息值加1 (第62行)。</p><p>　　4) 程序打印1行包含其管道位置、进程ID、父进程ID、进程组ID和会话ID的信息 (第63~64行)。</p><p>　　5) 除非程序是管道中的最后1个命令，否则它会向管道中的下一个命令写入1条整数信息 (第67~73行)。</p><p>　　6) 程序无限循环来等待信号 (第76~79行)。</p><h4 id="处理作业控制信号">34.6.2 处理作业控制信号</h4><p>　　作业控制对大多数应用程序都是透明的，它们无需采取特殊行为来处理作业控制信号，执行屏幕处理的程序是例外 (例如，<code>vi</code>和<code>less</code>)。此类程序控制终端的文本的精确布局并更改各种终端设置 (包括1次读取1个字符的终端输入设置)。</p><p>　　屏幕处理程序需要处理终端停止信号 (<code>SIGTSTP</code>)。信号处理函数应该将终端重置为规范 (逐行) 输入模式，并将光标放置在终端的最左端。当恢复后，程序会将终端设置回程序所需的模式，检查终端窗口大小 (在此期间可能已更改)，并用所需的内容重绘屏幕。</p><p>　　当用户挂起或退出<code>xterm</code>或其他终端模拟器上的<code>vi</code>等终端处理程序时，通常会看到终端被重绘为程序启动前可见的文本。终端模拟器通过捕获需要在获取和释放终端布局控制时输出的2个字符序列来实现该效果，这些序列是使用terminfo或termcap包的程序所必需的。第1个序列称为smcap (通常是Escape后接[?1049h)，它会使终端模拟器切换到 "备用" 屏幕。第2个序列称为rmcup (通常是Escape后接[?1049l)，它会使终端模拟器切换到默认屏幕，从而导致在屏幕处理程序控制终端之前显示的原文本重新出现。</p><p>　　当处理信号<code>SIGTSTP</code>时，需要注意一些细节。34.6.1介绍了第1个细节：当捕获的信号是<code>SIGTSTP</code>时，不会停止进程 (默认处理行为)，示例程序的处理方法是让<code>SIGTSTP</code>处理函数通过<code>raise()</code>发送信号<code>SIGSTOP</code>，因为该信号无法被捕获、阻塞和忽略。但是，这种方法并不完全正确。父进程会通过<code>wait()</code>或<code>waitpid()</code>返回的等待状态值来获取导致子进程停止的信号的信息 (见26.1.3)。若<code>SIGTSTP</code>处理函数通过<code>raise()</code>发送信号<code>SIGSTOP</code>，则父进程会错误地认为子进程被信号<code>SIGSTOP</code>停止。</p><p>　　在这种情况下，信号<code>SIGTSTP</code>的正确处理方法是让<code>SIGTSTP</code>处理函数进一步发送信号<code>SIGTSTP</code>来停止进程，如下所示：</p><p>　　1) <code>SIGTSTP</code>处理函数将信号<code>SIGTSTP</code>的处理行为重置为默认 (<code>SIG_DFL</code>)。</p><p>　　2) <code>SIGTSTP</code>处理函数发送信号<code>SIGTSTP</code>。</p><p>　　3) 信号<code>SIGTSTP</code>在进入<code>SIGTSTP</code>处理函数函数时会被阻塞 (除非指定了标志<code>SA_NODEFER</code>)，所以<code>SIGTSTP</code>处理函数解除阻塞该信号，此时，上一步发送的待处理<code>SIGTSTP</code>会立即挂起进程。</p><p>　　4) 当进程随后被信号<code>SIGCONT</code>恢复时，<code>SIGTSTP</code>处理函数继续执行。</p><p>　　5) 在返回之前，<code>SIGTSTP</code>处理函数阻塞信号<code>SIGTSTP</code>，并重新注册自己以便再次捕获该信号。</p><p>　　第5步中的阻塞信号<code>SIGTSTP</code>是必要的，这是为了防止<code>SIGTSTP</code>处理函数在重新注册自己之后但在返回之前又收到信号<code>SIGTSTP</code>而被递归调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* handling_SIGTSTP.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tstpHandler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> tstpMask, prevMask;</span><br><span class="line">    <span class="type">int</span> savedErrno;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    savedErrno = errno; <span class="comment">/* 备份errno */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught SIGTSTP\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGTSTP, SIG_DFL) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;signal&quot;</span>); <span class="comment">/* 将SIGTSTP的处理方式设置为默认 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raise(SIGTSTP); <span class="comment">/* 发送SIGTSTP */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解除阻塞SIGTSTP，待处理SIGTSTP会立即挂起程序 */</span></span><br><span class="line">    sigemptyset(&amp;tstpMask);</span><br><span class="line">    sigaddset(&amp;tstpMask, SIGTSTP);</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;tstpMask, &amp;prevMask) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 被SIGCONT恢复后，程序会从这里继续执行 */</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;prevMask, <span class="literal">NULL</span>) == <span class="number">-1</span>) <span class="comment">/* 阻塞SIGTSTP */</span></span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask); <span class="comment">/* 重新注册处理函数 */</span></span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line">    sa.sa_handler = tstpHandler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGTSTP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Exiting SIGTSTP handler\n&quot;</span>);</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有未忽略SIGTSTP时，才为其注册信号处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGTSTP, <span class="literal">NULL</span>, &amp;sa) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sa.sa_handler != SIG_IGN)</span><br><span class="line">    &#123;</span><br><span class="line">        sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">        sa.sa_flags = SA_RESTART;</span><br><span class="line">        sa.sa_handler = tstpHandler;</span><br><span class="line">        <span class="keyword">if</span> (sigaction(SIGTSTP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待信号 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pause();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Main\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何正确地处理信号<code>SIGTSTP</code>。在注册<code>SIGTSTP</code>处理函数后，主函数会无限循环来等待信号。</p><p>　　对于<code>vi</code>等屏幕处理程序，这个示例程序的信号处理函数中的<code>printf()</code>调用会被替换为导致程序修改终端模式并重绘终端显示的代码。为了避免调用非异步信号安全函数，该信号处理函数应该通过设置用于通知主函数重绘屏幕的标志来实现这一点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./handling_SIGTSTP</span></span><br><span class="line">输入Control-Z来发送信号SIGTSTP</span><br><span class="line">Caught SIGTSTP</span><br><span class="line"></span><br><span class="line">[1]  + Stopped  ./handling_SIGTSTP</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">fg</span></span></span><br><span class="line">./handling_SIGTSTP</span><br><span class="line">Exiting SIGTSTP handler</span><br><span class="line">Main</span><br><span class="line">输入Control-C来终止程序</span><br></pre></td></tr></table></figure><p>　　<code>SIGTSTP</code>处理函数可能会中断某些阻塞系统调用。这个示例程序的输出说明了这一点：在<code>pause()</code>调用被中断后，主函数会打印信息<code>Main</code>。</p><p>　　这个示例程序只会在信号<code>SIGTSTP</code>未被忽略的情况下为其注册信号处理函数。这体现了1个更通用的规则：应用程序应该只在作业控制信号和终端生成的信号未被忽略的情况下处理信号。对于作业控制信号，这可以防止由非作业控制shell启动的应用程序试图处理这些信号。非作业控制shell会将这些信号的处理方式设置为<code>SIG_IGN</code>，而作业控制shell会将这些信号的处理方式设置为<code>SIG_DFL</code>。</p><p>　　类似的规则也适用于可以由终端生成的其他信号：<code>SIGINT</code>、<code>SIGQUIT</code>和<code>SIGHUP</code>。</p><p>　　● 对于信号<code>SIGINT</code>和<code>SIGQUIT</code>，当命令在非作业控制shell的后台执行时，结果进程会与shell位于同一进程组 (而非单独的进程组)，并且shell会在执行命令之前将这2个信号的处理方式设置为<code>SIG_IGN</code>。这会确保用户输入终端中断或退出字符时进程不会终止。若进程后续取消了shell对这2个信号的处理方式的修改，则它将变得容易收到这2个信号。</p><p>　　● 对于信号<code>SIGHUP</code>，若命令通过<code>nohup</code>执行，则它会被忽略。这是为了防止由于终端挂断而导致命令终止。因此，当信号<code>SIGHUP</code>被忽略时，应用程序不应该试图该信号的处理方式。</p><h4 id="孤儿进程组">34.6.3 孤儿进程组</h4><p>　　孤儿进程是父进程终止后被<code>init</code> (进程ID为1) 收养的进程。在程序中，可以通过以下代码创建孤儿进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当在shell中执行包含这段代码的程序时，父进程退出后剩余进程的状态如下图所示：</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/steps_in_the_creation_of_an_orphaned_process_group.svg" title="steps_in_the_creation_of_an_orphaned_process_group"><p>　　当父进程终止后，子进程不只是孤儿进程，还是<strong>孤儿进程组</strong>的一部分。SUSv3将孤儿进程组定义为 "每个进程的父进程都是该进程组的成员或不属于该进程组的会话"。换句话说，若至少有1个进程在同一的会话的其他进程组中有父进程，则该进程组不是孤儿进程组。在上图中，子进程的进程组是孤儿进程组，因为子进程的进程组与父进程 (<code>init</code>) 的进程组不是同一进程组。</p><p>　　根据定义，会话组长的进程组可以是孤儿进程组，因为<code>setsid()</code>会在新会话中创建了1个进程组，而会话组长的父进程属于其他会话。</p><p>　　为了展示孤儿进程组的重要性，需要从作业控制的角度看待事物。基于上图考虑以下场景：</p><p>　　1) 在父进程退出前，子进程已停止 (可能因为父进程向其发送了停止信号)。</p><p>　　2) 当父进程退出时，shell会将父进程的进程组从它的作业列表中删除。子进程被<code>init</code>收养并成为终端的后台进程。子进程的进程组成为孤儿进程组。</p><p>　　3) 此时，没有进程通过<code>wait()</code>监控停止的子进程的状态。</p><p>　　因为子进程不是由shell创建，所以shell不知道子进程的存在，也不知道子进程与终止的父进程属于同一进程组。此外，进程<code>init</code>只会检查终止的子进程，然后回收结果僵尸进程。因此，停止的子进程可能会永远处于停止状态，因为没有进程知道需要发送信号<code>SIGCONT</code>来恢复它。</p><p>　　即使孤儿进程组中的子进程有尚未终止的属于其他会话的父进程，父进程也无法保证能够发送信号<code>SIGCONT</code>来恢复子进程。进程可以发送信号<code>SIGCONT</code>给同一会话的任意进程，但当子进程属于其他会话时，将受到发送信号的正常规则的限制 (见20.3)。因此，若子进程是特权进程，并且已修改了其凭证，则父进程可能无法发送信号给子进程。</p><p>　　为了避免上述场景，SUSv3规定，若进程组是孤儿进程组，并且存在停止的进程，则信号<code>SIGHUP</code>会被发送给该进程组的所有进程，以通知它们已与会话断开连接。随后，信号<code>SIGCONT</code>会被发送给该进程组的所有进程，以确保它们会恢复执行。若孤儿进程组中没有停止的进程，则这些信号不会被发送。</p><p>　　进程组成为孤儿进程组要么是因为同一会话的不同进程组的最后1个父进程终止，要么是因为该进程组的最后1个拥有来自同一会话的其他进程组的父进程的进程终止。无论哪种情况，对包含停止的子进程的孤儿进程组的处理都是相同的。</p><p>　　向包含停止的进程的新孤儿进程组发送信号<code>SIGHUP</code>和<code>SIGCONT</code>是为了消除作业控制框架中的特定漏洞。没有任何事情可以阻止孤儿进程组中的进程随后被其他进程 (具有合适的权限) 发送停止信号而停止。在这种情况下，进程将保持停止状态，直到某个进程 (同样具有合适的权限) 发送信号<code>SIGCONT</code>给它。</p><p>　　孤儿进程组还会影响信号<code>SIGTSTP</code>、<code>SIGTTIN</code>和<code>SIGTTOU</code>的传递语义。如前所述，若后台进程试图对控制终端调用<code>read()</code>，则信号<code>SIGTTIN</code>会被发送给该进程。若后台进程试图对控制终端调用<code>write()</code>，并且该终端的标志<code>TOSTOP</code>已设置，则信号<code>SIGTTOU</code>会被发送给该进程。但是，发送这些信号给孤儿进程组没有意义，因为孤儿进程组中的进程一旦停止，就不会恢复。因此，在这种情况下，内核会让<code>read()</code>和<code>write()</code>出错 (<code>EIO</code>)。</p><p>　　出于类似的原因，若信号<code>SIGTSTP</code>、<code>SIGTTIN</code>或<code>SIGTTOU</code>的传递会停止孤儿进程组中的进程，则该信号会被静默丢弃 (若注册了对应的信号处理函数，则这些信号还是会被传递给该进程)。</p><p>　　当被孤儿进程组中的进程调用时，<code>tcsetpgrp()</code>会出错 (<code>ENOTTY</code>)，对<code>tcsetattr()</code>、<code>tcflush()</code>、<code>tcflow()</code>、<code>tcsendbreak()</code>和<code>tcdrain()</code>的调用也会出错 (<code>EIO</code>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* orphaned_pgrp_SIGHUP.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">/* 定义了该宏后，strsignal()会被声明在string.h中 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld: caught signal %d (%s)\n&quot;</span>, (<span class="type">long</span>)getpid(), sig, strsignal(sig));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s &#123;s|p&#125; ...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">/* 禁用stdout的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCONT, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: PID=%ld, PPID=%ld, PGID=%ld, SID=%ld\n&quot;</span>, (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getppid(),</span><br><span class="line">           (<span class="type">long</span>)getpgrp(), (<span class="type">long</span>)getsid(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为每个命令行参数创建1个子进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (fork())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child: PID=%ld, PPID=%ld, PGID=%ld, SID=%ld\n&quot;</span>,</span><br><span class="line">                   (<span class="type">long</span>)getpid(), (<span class="type">long</span>)getppid(),</span><br><span class="line">                   (<span class="type">long</span>)getpgrp(), (<span class="type">long</span>)getsid(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 通过信号停止 */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld stopping\n&quot;</span>, (<span class="type">long</span>)getpid());</span><br><span class="line">                raise(SIGSTOP);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 等待信号 */</span></span><br><span class="line">                alarm(<span class="number">60</span>); <span class="comment">/* 确保进程最终会终止 */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld pausing\n&quot;</span>, (<span class="type">long</span>)getpid());</span><br><span class="line">                pause();</span><br><span class="line">            &#125;</span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* 父进程 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>); <span class="comment">/* 等待子进程执行 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS); <span class="comment">/* 让子进程的进程组成为孤儿进程组 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何处理孤儿进程组中的进程。该程序会先注册<code>SIGHUP</code>和<code>SIGCONT</code>处理函数 (第23~33行)，然后为每个命令行参数创建1个子进程。每个子进程要么通过<code>raise()</code>发送信号<code>SIGSTOP</code>给自己 (第50~55行)，要么等待信号 (第56~62行)，这取决于对应的命令行参数是否以字母<code>s</code> (表示停止) 开头。</p><p>　　当子进程创建完成后，父进程会睡眠来等待子进程执行 (第70行)，以这种方式调用<code>sleep()</code>是不完美但有时可行的实现方法 (见24.1)。然后，父进程退出。此时，子进程的进程组会成为孤儿进程组。若子进程因进程组成为孤儿进程组而收到信号，则信号处理函数会被调用并打印子进程的进程ID和信号编号 (第6~9行)。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_33/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第33章 线程：更多细节"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第33章 线程：更多细节</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_35/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第35章 进程优先级和调度">《Linux/UNIX系统编程手册》第35章 进程优先级和调度 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>