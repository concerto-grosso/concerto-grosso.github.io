<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_33/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_33/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_33/","title":"《Linux/UNIX系统编程手册》第33章 线程：更多细节"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第33章 线程：更多细节 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%88"><span class="nav-text">33.1 线程栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="nav-text">33.2 线程和信号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%8E%A9%E7%A0%81"><span class="nav-text">33.2.1 控制线程的信号掩码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E7%BB%99%E7%BA%BF%E7%A8%8B"><span class="nav-text">33.2.2 发送信号给线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BF%A1%E5%8F%B7"><span class="nav-text">33.2.3 处理异步信号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">33.3 线程和进程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B"><span class="nav-text">33.4 线程实现模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#m1%E5%AE%9E%E7%8E%B0"><span class="nav-text">33.4.1 M:1实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-text">33.4.2 1:1实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mn%E5%AE%9E%E7%8E%B0"><span class="nav-text">33.4.3 M:N实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#posix%E7%BA%BF%E7%A8%8B%E7%9A%84linux%E5%AE%9E%E7%8E%B0"><span class="nav-text">33.5 POSIX线程的Linux实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#linuxthreads"><span class="nav-text">33.5.1 LinuxThreads</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nptl"><span class="nav-text">33.5.2 NPTL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E5%BD%93%E5%89%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="nav-text">33.5.3 确定当前使用的线程实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E6%8E%A7%E5%88%B6%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="nav-text">33.5.4 显式控制使用的线程实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthreads-api%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">33.6 Pthreads API的高级特性</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_33/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第33章 线程：更多细节 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第33章 线程：更多细节</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-08-22 00:00:00" itemprop="dateCreated datePublished" datetime="2025-08-22T00:00:00+08:00">2025-08-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-08-23 00:00:00" itemprop="dateModified" datetime="2025-08-23T00:00:00+08:00">2025-08-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>11k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="线程栈">33.1 线程栈</h3><p>　　每个线程都有自己的栈，其大小在线程创建时就已固定。对于Linux/x86-32，主线程之外的所有线程的栈大小默认为2MB。对于某些64位架构，线程栈的默认大小更大 (例如，IA-64的默认大小是32MB)。</p><p>　　有时，可能需要修改线程栈的大小。函数<code>pthread_attr_setstacksize()</code>会设置1个线程属性，该线程属性决定使用线程属性对象创建的线程的栈大小。函数<code>pthread_attr_setstack()</code>可用于控制线程栈的大小和位置，但设置线程栈的位置会降低应用程序的可移植性。</p><p>　　修改线程栈的大小可能是因为需要为那些分配大型自动变量或进行深度嵌套函数调用的线程提供更大的栈，也可能是因为应用程序希望减小线程栈的大小 (以便在1个进程中容纳更多的线程)。x86-32的虚拟地址空间是3GB，2MB的默认栈大小表示最多可以创建大约15000个线程 (具体数量取决于文本段、数据段和共享库等内存段占用的虚拟内存)。可以通过调用<code>sysconf(_SC_THREAD_STACK_MIN)</code>来获取架构的实际最小线程栈大小。对于Linux/x86-32上的NPTL实现，该调用会返回16384。</p><p>　　对于NPTL线程实现，若将线程栈大小资源线程 (<code>RLIMIT_STACK</code>) 设置为<code>unlimited</code>以外的值，则创建新线程时会将该值作为默认栈大小。该限制必须在<span style="background-color:#ff0">程序执行之前</span>被设置，这通常使用命令<code>ulimit –s</code>设置。在主程序中使用<code>setrlimit()</code>设置该限制是不够的，因为NPTL会在调用<code>main()</code>之前进行的运行时初始化期间确定默认栈大小。</p><span id="more"></span><h3 id="线程和信号">33.2 线程和信号</h3><p>　　UNIX信号模型的设计考虑了UNIX进程模型，并且比Pthreads早出现几十年。因此，信号模型和线程模型之间存在一些重大冲突。这些冲突主要源于情况：一方面需要维护单线程进程的传统信号语义，另一方面需要开发适用于多线程进程的信号模型。</p><p>　　要理解UNIX信号如何映射到Pthreads模型，需要知道信号模型的哪些方面是进程级的，而哪些方面是线程级的。</p><p>　　● 信号处理方式是进程级的 (例如，若发送给进程的未被处理的信号的默认处理行为是停止或终止，则进程的所有线程都会停止或终止)。</p><p>　　● 在线程上下文中执行特定硬件指令而生成的信号、线程试图写入损坏的管道时生成的信号<code>SIGPIPE</code>以及通过<code>pthread_kill()</code>和<code>pthread_sigqueue()</code>发送的信号是线程级信号，通过其他机制生成的信号是进程级信号。</p><p>　　● 当信号被发送给已注册信号处理函数的多线程进程时，内核会随机选择1个线程来接收该信号并调用信号处理函数。这种行为与单线程进程的传统语义一致。进程为了响应1个信号而多次调用信号处理函数没有意义。</p><p>　　● 信号掩码是线程级的。新线程会继承创建线程的信号掩码。线程可以通过<code>pthread_sigmask()</code>来 (解除) 阻塞信号。</p><p>　　● 内核维护着关于整个进程的待处理信号的记录和每个线程的待处理信号的记录。<code>sigpending()</code>返回的是进程的待处理信号集和调用线程的待处理信号集的并集。新线程的待处理信号集为空。目标为线程的信号只能被发送给目标线程。若目标线程阻塞了该信号。则信号将保持待处理状态，直到目标线程解除阻塞该信号。</p><p>　　● 若<code>pthread_mutex_lock()</code>调用被信号处理函数中断，则该调用总是会自动重启。若<code>pthread_cond_wait()</code>调用被信号处理函数中断，则该调用要么自动重启，要么返回0来表示虚假唤醒 (见30.2.1)。这些行为也是SUSv3所要求的。</p><p>　　● 备用信号栈是线程级的。更准确地说，SUSv3要求备用信号栈是KSE级的。对于采用1:1实现的系统，每个线程都有1个KSE。</p><h4 id="控制线程的信号掩码">33.2.1 控制线程的信号掩码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　线程可以通过函数<code>pthread_sigmask()</code>来修改信号掩码或/和检索信号掩码。除了操作目标是线程的信号掩码之外，该函数用法与<code>sigprocmask()</code>的相同 (见20.8)。</p><p>　　SUSv3指出，在多线程程序中使用<code>sigprocmask()</code>将会导致未定义的结果。因此，不能在多线程程序中使用该系统调用。实际上，<code>sigprocmask()</code>和<code>pthread_sigmask()</code>在很多实现中是相同的，包括Linux。</p><h4 id="发送信号给线程">33.2.2 发送信号给线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_kill</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> sig)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>pthread_kill()</code>会发送参数<code>sig</code>指定的信号给参数<code>thread</code>指定的线程。因为Pthreads线程ID仅在进程内是唯一的，所以不能通过该函数发送信号给其他进程的线程。</p><p>　　<code>pthread_kill()</code>被实现为基于特定于Linux的系统调用<code>tgkill(tgid, tid, sig)</code>。该系统调用会发送参数<code>sig</code>指定的信号给参数<code>tgid</code>指定的线程组内的内核线程ID为<code>tid</code>的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigqueue</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　特定于Linux的函数<code>pthread_sigqueue()</code>结合了<code>pthread_kill()</code>和<code>sigqueue()</code>的功能。该函数会发送参数<code>sig</code>指定的信号给参数<code>thread</code>指定的线程。参数<code>value</code>用于指定随附数据，其用法与对应的<code>sigqueue()</code>参数的相同。</p><p>　　<code>pthread_sigqueue()</code>在glibc 2.11中被添加，并且需要内核的支持。该支持由Linux 2.6.31中添加的系统调用<code>rt_tgsigqueueinfo()</code>提供。</p><h4 id="处理异步信号">33.2.3 处理异步信号</h4><p>　　第20~22章介绍了各种可能会导致信号处理函数处理异步生成的信号更复杂的因素 (例如，可重入问题、重启系统调用和避免竞争条件)。此外，Pthreads API中的所有函数都是非异步信号安全的。因此，必须处理异步生成的信号的多线程程序通常不应该注册信号处理函数。相反，应该通过以下方法来处理异步信号：</p><p>　　1) 所有线程都阻塞进程可能会收到的异步信号。实现这一点的最简单的方法是在主线程创建线程之前阻塞这些信号，新线程会继承主线程的信号掩码的副本。</p><p>　　2) 创建1个专用线程，该线程通过<code>sigwaitinfo()</code>、<code>sigtimedwait()</code>或<code>sigwait()</code>接收信号。</p><p>　　这种方法的优点是异步生成的信号可以被同步接收。当专用线程接收信号时，它可以安全地修改共享变量 (受到互斥锁控制) 并调用非异步信号安全函数。它还可以唤醒等待条件变量的线程，并使用其他线程和进程通信和同步机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> *sig)</span>; <span class="comment">/* 成功时返回0，出错时返回正错误号 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>sigwait()</code>会等待参数<code>set</code>指定的信号集中的任一信号到达，然后接收信号并将其编号存储在<code>sig</code>指向的缓冲区中。</p><p>　　<code>sigwait()</code>的行为与<code>sigwaitinfo()</code>的类似，但有以下不同：</p><p>　　● <code>sigwait()</code>返回的只是信号编号 (而非描述信号的结构体<code>siginfo_t</code>)。</p><p>　　● <code>sigwait()</code>的返回值与线程相关函数一致 (而非传统UNIX调用返回的0或-1)。</p><p>　　当多个线程通过<code>sigwait()</code>等待同一信号时，只会有1个线程实际接收该信号，并且哪个线程会接收该信号是不确定的。</p><h3 id="线程和进程控制">33.3 线程和进程控制</h3><p>　　与信号机制相同，<code>exec()</code>、<code>fork()</code>和<code>exit()</code>也早于Pthreads API出现。</p><p>　　当线程调用<code>exec()</code>时，调用程序会完全被替换。除了调用线程之外，其他所有线程都会立即消失，这些线程的线程特定数据的析构函数以及清除处理函数都不会被调用。属于该进程的所有 (进程私有) 互斥锁和条件变量也会消失。当调用<code>exec()</code>后，剩余线程的线程ID将会是不确定的。</p><p>　　当多线程进程调用<code>fork()</code>时，只有调用线程会在子进程中被复制，其他线程在子进程中都会消失 (子进程中线程的ID会与父进程中调用<code>fork()</code>的线程的ID相同)。此外，这些消失的线程的线程特定数据的析构函数以及清除处理函数都不会被调用。这会导致各种问题：</p><p>　　● 尽管只有调用线程会在子进程中被复制，但全局变量的状态以及互斥锁和条件变量等Pthreads对象会在子进程中被保留 (因为Pthreads对象会被分配在父进程的内存，而子进程会得到这些内存的副本)。这可能会导致棘手的情况：假设其他线程在<code>fork()</code>时锁定了互斥锁，并且正在更新全局数据结构。在这种情况下，子进程中的线程将无法解锁互斥锁 (因为不存在互斥锁的所有者)，并且当它试图获取互斥锁时，会被阻塞。此外，子进程的全局数据结构副本可能处于不一致的状态 (因为正在更新它的线程在更新时消失了)。</p><p>　　● 因为线程特定数据的析构函数以及清理处理函数都不会被调用，多线程程序中的<code>fork()</code>调用可能会导致子进程的内存泄露。此外，子进程中的新线程可能无法访问其他线程创建的线程特定数据，因为它没有指向这些数据的指针。</p><p>　　正是因为这些问题，在多线程程序中调用<code>fork()</code>后通常会立即调用<code>exec()</code>。</p><p>　　对于那些<code>fork()</code>后不能立即调用<code>exec()</code>的程序，Pthreads API提供了1种定义fork处理函数的机制。fork处理函数通过调用<code>pthread_atfork(prepare_func, parent_func, child_func)</code>来注册，这会将<code>prepare_func</code>指向的函数添加到1个函数列表，该函数列表中的函数会在调用<code>fork()</code>时子进程被创建之前自动被调用 (按照注册顺序的逆序)。同样，<code>parent_func</code>和<code>child_func</code>指向的函数也会分别被添加到1个函数函数，这些函数会分别在<code>fork()</code>返回后父进程和子进程立即被调用 (按照注册顺序)。</p><p>　　对于Linux，当使用NPTL线程库的程序调用<code>vfork()</code>时，fork处理函数不会自动被调用。但是，在这种情况下，若程序使用的是LinuxThreads，则fork处理函数会自动被调用。</p><p>　　有时，fork处理函数对使用线程的库代码非常有用。若没有fork处理函数，库无法处理那些直接使用库并调用<code>fork()</code>的应用程序，因为这些应用程序不知道库已经创建了一些线程。</p><p>　　若任一线程调用<code>exit()</code>或主线程返回，则所有线程会立即消失，线程特定数据的析构函数以及清除处理函数都不会自动被调用。</p><h3 id="线程实现模型">33.4 线程实现模型</h3><p>　　这里将介绍3种用于实现线程API的模型：<span style="background-color:#ff0">M:1实现</span>、<span style="background-color:#ff0">1:1实现</span>和<span style="background-color:#ff0">M:N实现</span>。这些实现模型之间的差异在于线程如何映射到KSE (对于线程出现之间的传统UNIX实现，KSE等同于进程)。</p><h4 id="m1实现">33.4.1 M:1实现</h4><p>　　对于M:1线程实现，线程创建、调度和同步 (例如，锁定互斥锁和等待条件变量) 的所有细节完全在进程内部由用户空间线程库处理。内核对进程中存在多个线程的情况一无所知。</p><p>　　M:1实现有几个优点。最大的优点很多操作 (例如，创建和终止线程、线程间的上下文切换以及互斥锁和条件变量操作) 都很快，因为不需要切换到内核模式。此外，由于不需要内核对线程库的支持，M:1实现可以相对容易地进行移植。</p><p>　　但是，M:1实现存在一些严重的缺点：</p><p>　　● 当线程调用<code>read()</code>等系统调用时，控制权会从用户空间线程库转移到内核。这表示若<code>read()</code>阻塞，则所有线程都会阻塞。</p><p>　　● 内核无法调度进程的线程。因为内核不知道进程中存在多个线程，所以它无法将单独的线程调度到多处理器硬件上的不同处理器。此外，内核无法有效地为进程中的线程分配比另一个进程中的线程更高的优先级，因为线程的调度完全在进程内部进行。</p><h4 id="实现">33.4.2 1:1实现</h4><p>　　对于1:1实现，每个线程映射到单独的KSE。内核分别处理每个线程的调度。线程同步操作被实现为使用系统调用。</p><p>　　1:1实现消除了M:1实现的缺点。阻塞系统调用不会导致进程的其他线程都阻塞，并且内核可以将进程的线程调度到多处理器硬件上的不同处理器。</p><p>　　但是，1:1实现的线程创建、上下文切换和同步等操作慢于M:1实现，因为需要切换到内核模式。此外，当应用程序存在大量线程时，为每个线程维护单独的KSE的开销可能会为内核调度程序带来很大的负载，从而降低整体系统性能。</p><p>　　尽管存在这些缺点，但相比M:1实现，1:1实现通常是更好的选择。LinuxThreads和NPTL都是使用该模型。</p><h4 id="mn实现">33.4.3 M:N实现</h4><p>　　M:N实现旨在结合M:1实现和1:1实现的优点，同时消除它们的缺点。</p><p>　　对于M:N实现，每个进程都有多个关联的KSE，并且多个线程可能映射到所有KSE。这种设计允许内核将应用程序的线程分配到多个处理器上，同时消除了与使用大量线程的应用程序相关的可能出现的扩展问题。</p><p>　　M:N实现最大的缺点是复杂性。线程调度任务由内核和用户空间线程库共同承担，它们必须相互合作并传递信息。在使用M:N实现的情况下，按照SUSv3的要求管理信号也很复杂。</p><p>　　NPTL实现最初考虑采用M:N实现，但由于需要对内核进行过于广泛和可能不必要的修改 (考虑到Linux调度程序在处理大量KSE时的良好扩展性)，最终采用了1:1实现。</p><h3 id="posix线程的linux实现">33.5 POSIX线程的Linux实现</h3><p>　　Linux有2种主要的Pthreads API实现：LinuxThreads和NPTL (Native POSIX Threads Library)。</p><p>　　● LinuxThreads是最初的Linux线程实现，由Xavier Leroy开发。LinuxThreads现已过时，glibc 2.4及以上版本不支持该实现。</p><p>　　● NPTL是现代Linux线程实现，由Ulrich Drepper和Ingo Molnar开发，作为LinuxThreads是后继者。NPTL的性能更优越，并且更严格地遵循SUSv3。对NPTL的支持需要修改内核，这些修改出现在Linux 2.6中。</p><p>　　一度，LinuxThread的后继者似乎是IBM开发的NGPT (Next Generation POSIX Threads)。NGPT采用M:N实现，性能明显优于LinuxThreads。但是，NPTL的开发者决定寻求1种新的实现。这个做法是合理的——1:1实现的NPTL被证明比NGPT性能更好。当NPTL发布后，NGPT的开发就停止了。</p><h4 id="linuxthreads">33.5.1 LinuxThreads</h4><p>　　多年来，LinuxThreads是Linux上的主要线程实现，它足以用于实现各种多线程应用程序。LinuxThread的要点如下：</p><p>　　● 线程是通过指定以下标志调用<code>clone()</code>创建的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND</span><br></pre></td></tr></table></figure><p>　　这表示LinuxThreads线程会共享虚拟内存、文件描述符、文件系统相关信息 (umask、根目录和当前工作目录) 和信号处理方式。但是，线程不会共享进程ID和父进程ID。</p><p>　　● 除了应用程序创建的线程之外，LinuxThreads还会创建1个额外的 "管理" 线程，用于处理线程的创建和终止。</p><p>　　● LinuxThreads会使用信号进行内部操作。对于支持实时信号的内核 (Linux 2.2及以上版本)，会使用前3个实时信号。对于较旧的内核，使用<code>SIGUSR1</code>和<code>SIGUSR2</code>。应用程序不能使用这些信号 (使用这些信号会导致各种线程同步操作出现高延迟)。</p><p>　　LinuxThreads在某些方面不符合SUSv3 (LinuxThreads受到开发时可用的内核特性的限制，它需要在这些限制内尽可能地符合规范)：</p><p>　　● 进程的不同线程调用<code>getpid()</code>会返回不同的值。调用<code>getppid()</code>反映了事实：除了主线程之外，所有线程均由进程的管理线程创建 (<code>getppid()</code>返回管理线程的进程ID)。其他线程调用<code>getppid()</code>的返回值应该与主线程调用<code>getppid()</code>的返回值相同。</p><p>　　● 若某个线程通过<code>fork()</code>创建子进程，则进程的其他线程都应该能通过<code>wait()</code> (或类似函数) 来获取该子进程的终止状态。但是，事实并非如此，只有创建子进程的线程可以对其调用<code>wait()</code>。</p><p>　　● SUSv3要求，若线程调用<code>exec()</code>，则进程的其他所有线程都会终止。但是，若<code>exec()</code>由主线程之外的线程调用，则结果进程将具有与调用线程相同的进程ID，即进程ID与主线程的进程ID不同。根据SUSv3，进程ID应该与主线程的进程ID相同。</p><p>　　● 线程不会共享凭证 (用户和组ID)。当多线程进程执行set-user-ID程序时，可能导致线程无法发送信号给其他线程 (通过<code>pthread_kill()</code>)，因为这2个线程的凭证已被修改，以至于发送线程不再具有发送信号给目标线程的权限 (见20.3)。此外，因为LinuxThreads内部会使用信号，所以线程修改其凭证后，各种Pthreads操作可能会出错或被挂起。</p><p>　　● 通过<code>kill()</code>或<code>sigqueue()</code>发送给进程的信号应该被传递给目标进程中未阻塞信号的任意线程并由该线程处理。但是，因为LinuxThreads线程的进程ID不同，信号的目标只能是指定的线程。若该线程阻塞了信号，则该信号将保持待处理状态 (即使进程的其他线程未阻塞该信号)。</p><p>　　● LinuxThreads不支持进程级待处理信号的概念，只支持线程级待处理信号。</p><p>　　● 若信号是针对包含多线程应用程序的进程组，则该信号将由应用程序中的所有线程 (即已注册信号处理函数的所有线程) 处理，而非由单个 (任意) 线程处理 (例如，可以通过输入为前台进程组生成作业控制信号的终端字符来生成此类信号)。</p><p>　　● 备用信号栈 (由<code>sigaltstack()</code>定义) 是线程级的。但是，因为新线程会错误地继承创建线程的备用信号栈，所以这2个线程会共享备用信号栈。SUSv3要求新线程启动时不应该有备用信号栈。LinuxThreads不符合规范的行为会导致问题：当2个线程同时在共享备用信号栈上处理不同信号时，可能会导致混乱 (例如，程序崩溃)。这个问题可能很难重现和调试，因为它的发生依赖于2个信号同时被处理。对于使用LinuxThreads的程序，新线程可以调用<code>sigaltstack()</code>来确保它不会与创建线程共享备用信号栈。但是，可移植程序 (以及会创建线程的库函数) 并不知道要这样做，因为其他实现不要求这样做。此外，即使使用了该技术，仍然存在潜在的竞争条件：新线程可能在调用<code>sigaltstack()</code>之前就接收了信号并在备用信号栈上处理。</p><p>　　● 线程不会共享会话ID和进程组ID。系统调用<code>setsid()</code>和<code>setpgid()</code>不能用于修改多线程进程的会话或进程组ID。</p><p>　　● 通过<code>fcntl()</code>注册的记录锁不会被共享。同一类型的重叠锁请求不会合并。</p><p>　　● 线程不会共享资源限制。SUSv3要求资源线程是进程级属性。</p><p>　　● <code>times()</code>返回的CPU时间和<code>getrusage()</code>返回的资源使用信息是线程级的。这些系统调用应该返回进程范围内的总计。</p><p>　　● 命令<code>ps</code>的某些版本会将进程中的所有线程 (包括管理线程) 显示为具有不同进程ID的独立项。</p><p>　　● 线程不会共享由<code>setpriority()</code>设置的nice值。</p><p>　　● 线程不会共享通过<code>setitimer()</code>设置的间隔定时器。</p><p>　　● 线程不会共享System V信号量取消 (<code>semadj</code>) 值。</p><p>　　除了在某些方面不符合SUSv3之外，LinuxThreads还存在以下问题：</p><p>　　● 当管理线程终止后，必须手动清理剩余线程。</p><p>　　● 多线程程序的核心转储文件可能不包含进程的所有线程 (甚至不包含触发核心转储的线程)。</p><p>　　● 只有在主线程中执行<code>ioctl()</code>的非标准操作<code>TIOCNOTTY</code>时，才会删除进程与控制终端的关联。</p><h4 id="nptl">33.5.2 NPTL</h4><p>　　NPTL的开发工作始于2002年，并在接下来的大约1年取得了进展。与此同时，Linux内核也进行了多项修改以满足NPTL的要求。Linux 2.6内核为支持NPTL而做出的修改如下：</p><p>　　● 改进线程组实现。</p><p>　　● 添加futex作为同步机制 (futex是通用机制，并非仅为NPTL而设计)。</p><p>　　● 添加系统调用<code>get_thread_area()</code>和<code>set_thread_area()</code>来支持线程本地存储。</p><p>　　● 支持线程核心转储和多线程进程调试。</p><p>　　● 修改以支持与Pthreads模型一致的方式管理信号。</p><p>　　● 添加系统调用<code>exit_group()</code>来终止进程中的所有线程。从glibc 2.3开始，<code>_exit()</code>变成了<code>exit_group()</code>的包装函数的别名，而调用<code>pthread_exit()</code>才会调用真正的<code>_exit()</code> (仅终止调用线程)。</p><p>　　● 重写内核调度程序以允许更高效地调度大量 (即数千个) KSE。</p><p>　　● 提升内核进程终止代码的性能。</p><p>　　● 扩展系统调用<code>clone()</code>。</p><p>　　NPTL的要点如下：</p><p>　　● 线程是通过指定以下标志调用<code>clone()</code>创建的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD |</span><br><span class="line">CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM</span><br></pre></td></tr></table></figure><p>　　除了共享LinuxThreads线程共享的所有信息之外，NPTL线程还共享更多信息 (见28.2.1)。</p><p>　　● NPTL内部会使用前2个实时信号。其中的1个信号用于用于实现线程取消。另一个信号作为确保进程中的所有线程具有相同用户ID和组ID的技术的一部分。这项技术是必需的，因为在内核级别，线程具有不同的用户和组凭证。NPTL会在更改用户和组ID的系统调用 (例如，<code>setuid()</code>和<code>setresuid()</code>) 的包装函数中执行一些操作，以保证修改进程的所有线程的ID。应用程序不应该使用这些信号。</p><p>　　● 不同于LinuxThreads，NPTL不会使用管理线程。</p><p>　　虽然NPTL比LinuxThreads更严格地遵循SUSv3，但在撰写本书时，还是存在不符合规范的行为：线程不会共享nice值。</p><p>　　对于较旧的内核2.6.x，还存在一些额外的不符合规范的行为：</p><p>　　● 对于内核2.6.16之前的版本，备用信号栈是线程级的，但新线程会错误地继承创建线程的备用信号栈。因此，这2个线程会共享备用信号栈。</p><p>　　● 对于内核2.6.16之前的版本，只有线程组组长才能通过调用<code>setsid()</code>创建新会话。</p><p>　　● 对于内核2.6.16之前的版本，只有线程组组长才能通过<code>setpgid()</code>让主机进程成为进程组组长。</p><p>　　● 对于内核2.6.12之前的版本，线程不会共享通过<code>setitimer()</code>创建的间隔定时器。</p><p>　　● 对于内核2.6.10之前的版本，线程不会共享资源限制。</p><p>　　● 对于内核2.6.9之前的版本，<code>times()</code>返回的CPU时间和<code>getrusage()</code>返回的资源使用信息是线程级的。</p><p>　　NPTL被设计为与LinuxThreads ABI兼容，所以与支持LinuxThreads的glibc链接的程序不需要重新链接即可使用NPTL。但是，当使用NPTL时，程序的某些行为可能会变化，主要是因为NPTL更严格地遵循SUSv3。</p><p>　　当使用命令<code>ps</code>列出使用NPTL的多线程进程时，只会有1行结果。为了查看线程的相关信息，需要加上命令行选项<code>-L</code>。</p><h4 id="确定当前使用的线程实现">33.5.3 确定当前使用的线程实现</h4><p>　　某些Linux发行版附带了glibc，该库同时支持LinuxThreads和NPTL，默认使用的线程实现由动态链接器根据系统运行的底层内核决定 (这些发行版现已成为历史，因为从版本2.4开始，glibc不再支持LinuxThreads)。</p><p>　　对于使用glibc 2.3.2及以上版本的系统，可以通过以下命令来确定系统支持哪个线程实现，或者系统同时支持这2个线程实现时默认使用的线程实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">getconf GNU_LIBPTHREAD_VERSION</span></span><br></pre></td></tr></table></figure><p>　　对于仅支持NPTL或默认使用NPTL的系统，该命令的结果如下 (版本可能有所不同)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NPTL 2.3.4</span><br></pre></td></tr></table></figure><p>　　从glibc 2.3.2开始，可以通过库函数<code>confstr()</code>检索特定于glibc的配置变量<code>_CS_GNU_LIBPTHREAD_VERSION</code>的值来获取类似的信息。</p><p>　　对于使用较旧的glibc的系统，还需要进行更多的操作。首先，需要通过以下命令来获取运行程序时glibc的路径名 (这里以位于<code>/bin/ls</code>的程序<code>ls</code>为例)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd /bin/ls | grep libc.so</span></span><br><span class="line">        libc.so.6 =&gt; /lib/tls/libc.so.6 (0x40050000)</span><br></pre></td></tr></table></figure><p>　　<code>=&gt;</code>之后的内容是glibc的路径名 (glibc的路径名可能因Linux发行版而异)。若将该路径名作为命令执行，则会打印大量关于glibc的信息。这里可以通过<code>grep</code>进行筛选，以找到关于线程实现的那一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/lib/tls/libc.so.6 | egrep -i <span class="string">&#x27;threads|nptl&#x27;</span></span></span><br><span class="line">        Native POSIX Threads Library by Ulrich Drepper et al</span><br></pre></td></tr></table></figure><p>　　在<code>egrep</code>中使用正则表达式是因为某些支持NPTL的glibc版本会包含字符串<code>NPTL 0.61 by Ulrich Drepper</code> (或类似的字符串)。</p><p>　　或者，直接使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">$(ldd /bin/ls | grep libc.so | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>) | egrep -i <span class="string">&#x27;threads|nptl&#x27;</span></span></span><br><span class="line">        Native POSIX Threads Library by Ulrich Drepper et al</span><br></pre></td></tr></table></figure><h4 id="显式控制使用的线程实现">33.5.4 显式控制使用的线程实现</h4><p>　　对于同时支持LinuxThreads和NPTL的Linux系统，可能需要显式地控制使用的线程实现。为此，需要使用特殊环境变量<code>LD_ASSUME_KERNEL</code>。顾名思义，该环境变量会告诉动态链接器像在特定版本的Linux内核上运行一样运行。通过指定不支持NPTL的内核版本 (例如，2.2.5)，可以确保使用LinuxThreads。因此，可以使用以下命令运行使用LinuxThreads的多线程程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ LD_ASSUME_KERNEL=<span class="number">2.2</span>.<span class="number">5</span> ./prog</span><br></pre></td></tr></table></figure><p>　　可以指定给环境变量<code>LD_ASSUME_KERNEL</code>的内核版本号的范围存在一些限制。对于常见的Linux发行版，版本号2.2.5足以确保使用LinuxThreads。</p><p>　　当将该环境变量与33.5.3中介绍的命令结合起来以显示所使用的线程实现时，得到的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> LD_ASSUME_KERNEL=2.2.5</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">$(ldd /bin/ls | grep libc.so | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>) | egrep -i <span class="string">&#x27;threads|nptl&#x27;</span></span></span><br><span class="line">        linuxthreads-0.10 by Xavier Leroy</span><br></pre></td></tr></table></figure><h3 id="pthreads-api的高级特性">33.6 Pthreads API的高级特性</h3><p>　　Pthreads API的高级特性如下：</p><p>　　● <span style="background-color:#ff0">实时调度</span>：可以为线程设置实时调度策略和优先级。</p><p>　　● <span style="background-color:#ff0">进程共享的互斥锁和条件变量</span>：SUSv3规定了1个允许在进程间共享互斥锁和条件变量的选项。在这种情况下，互斥锁和条件变量必须位于进程共享的内存区域。NPTL支持该特性。</p><p>　　● <span style="background-color:#ff0">高级线程同步原语</span>：包括屏障、读写锁和自旋锁。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_32/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第32章 线程：线程取消"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第32章 线程：线程取消</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_34/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第34章 进程组、会话和作业控制">《Linux/UNIX系统编程手册》第34章 进程组、会话和作业控制 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>