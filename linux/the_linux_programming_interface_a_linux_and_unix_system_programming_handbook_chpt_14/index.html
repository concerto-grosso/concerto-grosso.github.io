<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/","title":"《Linux/UNIX系统编程手册》第14章 文件系统"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第14章 文件系统 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87"><span class="nav-text">14.1 设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA"><span class="nav-text">14.2 磁盘和分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">14.3 文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i-node"><span class="nav-text">14.4 i-node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">14.5 虚拟文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">14.6 日志文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E7%9B%AE%E5%BD%95%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%92%8C%E6%8C%82%E8%BD%BD%E7%82%B9"><span class="nav-text">14.7 单一目录层次结构和挂载点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E5%92%8C%E5%8D%B8%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">14.8 挂载和卸载文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">14.8.1 挂载文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">14.8.2 卸载文件系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%8C%82%E8%BD%BD%E7%89%B9%E6%80%A7"><span class="nav-text">14.9 高级挂载特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%861%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%8C%82%E8%BD%BD%E7%82%B9"><span class="nav-text">14.9.1 将1个文件系统挂载到多个挂载点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E5%A4%9A%E4%B8%AA%E6%8C%82%E8%BD%BD%E5%A0%86%E5%8F%A0%E5%9C%A81%E4%B8%AA%E6%8C%82%E8%BD%BD%E7%82%B9"><span class="nav-text">14.9.2 将多个挂载堆叠在1个挂载点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E6%AF%8F%E4%B8%AA%E6%8C%82%E8%BD%BD%E7%82%B9%E9%80%89%E9%A1%B9%E7%9A%84%E6%A0%87%E5%BF%97"><span class="nav-text">14.9.3 作为每个挂载点选项的标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E6%8C%82%E8%BD%BD"><span class="nav-text">14.9.4 绑定挂载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%BB%91%E5%AE%9A%E6%8C%82%E8%BD%BD"><span class="nav-text">14.9.5 递归绑定挂载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">14.10 虚拟内存文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-text">14.11 获取文件系统的相关信息</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第14章 文件系统 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第14章 文件系统</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-01-11 00:00:00" itemprop="dateCreated datePublished" datetime="2025-01-11T00:00:00+08:00">2025-01-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-30 00:00:00" itemprop="dateModified" datetime="2025-01-30T00:00:00+08:00">2025-01-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>19k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　<strong>文件系统</strong>是常规文件和目录的有组织的集合。可以通过命令<code>mkfs</code>来创建文件系统。</p><p>　　支持多种文件系统是Linux的优势之一，包括传统的ext2文件系统、各种原生UNIX文件系统 (例如，Minix、System V和BSD文件系统)、Microsoft的文件系统 (FAT、FAT2和NTFS)、ISO 9660 CD-ROM文件系统、Apple Macintosh的HFS、网络文件系统 (例如，Sun的NFS、IBM和Microsoft的SMB、Novell的NCP和卡内基梅隆大学开发的Coda文件系统) 以及日志文件系统 (包括ext3、ext4、Reiserfs、JFS、XFS和Btrfs)。</p><p>　　内核当前已知的文件系统可以通过特定于Linux的文件<code>/proc/filesystems</code>获取。</p><p>　　Linux 2.6.14添加了<span style="background-color:#ff0">用户空间文件系统</span>功能，该机制向内核添加了hook，允许文件系统完全通过用户空间程序实现 (无需为内核应用补丁或重新编译内核)。</p><p>　　多年来，Linux上使用最广泛的文件系统是ext2，它是原始Linux文件系统ext的后继者。ext2文件系统的开发者是Remy Card。它的源码很短 (大约5000行C代码)，构成了其他几个文件系统实现的模型。近年来，ext2的使用率有所下降，取而代之的是各种日志文件系统。</p><h3 id="设备">14.1 设备</h3><p>　　<strong>设备特殊文件</strong>与系统上的设备对应。在内核中，每个设备类型都有1个对应的设备驱动程序，<strong>设备驱动程序</strong>是用于实现一组操作的内核代码单元，这些操作 (通常) 对应关联硬件上的输入和输出行为。设备驱动程序提供的API是固定的，并且其中包括与系统调用<code>open()</code>、<code>close()</code>、<code>read()</code>、<code>write()</code>、<code>mmap()</code>和<code>ioctl()</code>相对应的操作。所有设备驱动程序提供的接口都是一致的，隐藏了各个设备的操作之间的差异，从而实现I/O的通用性。</p><p>　　设备特殊文件分为<strong>字符设备</strong>和<strong>块设备</strong>。字符设备逐字符处理数据 (例如，终端和键盘)。块设备每次处理1个数据块 (例如，磁盘和磁带驱动器)，块大小取决于设备类型，通常是512字节的整数倍。</p><p>　　设备文件在文件系统中的形式与其他文件相似，通常位于目录<code>/dev</code>下。超级用户可以通过命令<code>mknod</code>来创建设备文件，特权程序 (能力<code>CAP_MKNOD</code>) 也可以通过系统调用<code>mknod()</code>来执行相同的任务。</p><p>　　系统调用<code>mknod()</code> (make file-system i-node) 的用法简单，并且现在只有在创建设备文件时才会使用该系统调用，所以这里不进行详细介绍。<code>mknod()</code>也能用于创建有名管道，但函数<code>mkfifo()</code>是这项任务的首选方法。从历史角度，有些UNIX实现也通过<code>mknod()</code>来创建目录，但如今这种用法已经被系统调用<code>mkdir()</code>所取代。尽管如此，部分UNIX实现还是保留了该特性来保证向后兼容性。</p><p>　　对于Linux早期版本，目录<code>/dev</code>包含系统中所有可能的设备的条目 (即使有些设备未连接到系统)，这表示该目录可能包含数千个未使用的条目，从而减慢了程序扫描该目录的速度，并且无法通过该目录下的条目来确定实际连接到系统的设备。Linux 2.6添加了程序<code>udev</code>来解决这些问题，该程序基于sysfs文件系统 (通过挂载在目录<code>/sys</code>下的伪文件系统来将设备相关信息和其他内核对象导出到用户空间)。</p><p>　　每个设备文件都有1个<strong>主ID号</strong>和1个<strong>次ID号</strong>。主ID表示设备的常规类，内核通过主ID来为设备寻找合适的驱动程序。属于相同常规类的设备通过次ID区分。设备文件的主ID和次ID可以通过命令<code>ls -l</code>查看。</p><p>　　设备的主ID和次ID记录在设备文件的i-node中。所有设备驱动器程序都会注册与特定设备主ID的关联，该关联会提供设备特殊文件和设备驱动程序之间的连接。当内核查找设备驱动程序时，设备文件的名称无关紧要。</p><p>　　对于Linux 2.4及以下版本，设备主ID和次ID都由8位表示，从而限制了系统上的设备总数。此外，主ID是固定的，次ID只能由Linux Assigned Names and Numbers Authority (LANNA) 分配，这进一步加剧了该限制。Linux 2.6通过使用更多位来表示主ID (12位) 和次ID (20位) 来缓解该限制。</p><span id="more"></span><h3 id="磁盘和分区">14.2 磁盘和分区</h3><p>　　常规文件和目录通常位于磁盘设备 (也可能位于CD-ROM、闪存卡和虚拟磁盘等设备)。</p><p>　　磁盘驱动器是1种机械结构，由若干个高速旋转的盘片 (每分钟数千转) 组成。磁盘表面上的磁性编码信息由磁盘上径向移动的<strong>磁头</strong>检索或修改。从物理角度，盘面的信息位于一组称为<strong>磁道</strong>的同心圆。磁道分为多个<strong>扇区</strong>，每个扇区包含一组物理块。物理块通常是512字节 (或512字节的整数倍)，表示驱动器可以读写的最小信息单元。</p><p>　　尽管现代磁盘很快，但读写磁盘上的信息仍然需要大量时间。磁头移动到合适的磁道 (寻道时间)，然后驱动器必须等待扇区旋转到磁头下方 (旋转延迟)，最后传输所需的块 (传输时间)。执行1次这样的操作所需的时间通常是毫秒级，在此期间，现代CPU可以执行数百万条指令。</p><p>　　每个磁盘分为若干个<strong>分区</strong>。内核将每个分区都作为位于目录<code>/dev</code>下的独立设备。磁盘分区可能会包含任何类型的信息，但通常会包含<span style="background-color:#ff0">文件系统</span> (存储常规文件和目录)、<span style="background-color:#ff0">数据区域</span> (访问时视为原始模式设备) 或<span style="background-color:#ff0">交换区域</span> (用于内核内存管理)。</p><p>　　系统管理员可以通过命令<code>fdisk</code>来获取磁盘分区的编号、类型和大小。命令<code>fdisk -l</code>会列出磁盘上的所有分区。特定与Linux的文件<code>/proc/partitions</code>列出了系统上的所有磁盘分区的编号、大小和名称。</p><p>　　可以通过命令<code>mkswap</code>来创建交换区域。特权进程 (能力<code>CAP_SYS_ADMIN</code>) 可以通过系统调用<code>swapon()</code>来通知内核将磁盘分区作为交换区域。系统调用<code>swapoff()</code>执行相反的功能，通知内核停止将磁盘分区作为交换区域。SUSv3没有说明<code>swapon()</code>和<code>swapoff()</code>，但很多UNIX实现都提供了这2个系统调用。特定于Linux的文件<code>/proc/swaps</code>可用于获取系统上当前已启用的交换区域的相关信息，这些信息包括每个交换区域的大小和已使用的区域量。</p><h3 id="文件系统">14.3 文件系统</h3><p>　　文件系统中分配空间的基本单元是<span style="background-color:#ff0">逻辑块</span>，这是文件系统所在的磁盘设备上的连续物理块的整数倍 (逻辑块大小指定为命令<code>mkfs</code>的参数)。例如，ext2的逻辑块的大小是1024、2048或4096字节。</p><p>　　特权程序 (能力<code>CAP_SYS_RAWIO</code>) 可以通过<code>ioctl()</code>的操作<code>FIBMAP</code>来获取文件中特定块的物理位置。该调用的第3个参数是整数结果值。在调用前，该参数应该设置为逻辑块号 (第1个逻辑块的编号是0)；在调用后，该参数会变为存储逻辑块的起始物理块的编号。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/layout_of_disk_partitions_and_a_file_system.svg"><p>　　文件系统由<span style="background-color:#ff0">引导块</span>、<span style="background-color:#ff0">超级块</span>、<span style="background-color:#ff0">i-node表</span>和<span style="background-color:#ff0">数据块</span>组成。</p><p>　　● 引导块总是文件系统的第1个块。文件系统不使用引导块，相反，引导块包含用于引导文件系统的信息。尽管操作系统只需要1个引导块，但所有文件系统都有引导块 (大部分未使用)。</p><p>　　● 超级块总是文件系统的第2个块，其中包含文件系统的参数信息：i-node表的大小、文件系统的逻辑块大小和文件系统的大小 (以逻辑块为单位)。位于相同物理设备的不同文件系统可以有不同的类型、大小和参数设置 (这也是将磁盘划分为多个分区的原因之一)。</p><p>　　● 文件系统中的所有文件或目录在i-node表中都有1个唯一的条目，该条目记录着文件的各种信息。i-node表有时也称为<span style="background-color:#ff0">i-list</span>。</p><p>　　● 文件系统中的大部分空间都是组成文件和目录的数据块。</p><p>　　对于ext2文件系统，情况略有不同。在引导块后，文件系统划分为1组固定大小的<span style="background-color:#ff0">块组</span>。每个块组的第1个块都是超级块，其中包含该块组的参数信息。超级块之后是i-node表，i-node表之后是数据块。通过尝试将1个文件的所有块都存储在1个块组，ext2文件系统旨在减少顺序访问文件时的寻道时间。</p><h3 id="i-node">14.4 i-node</h3><p>　　i-node节点通过其在i-node表中的顺序位置进行数字标识。文件的i-node号是命令<code>ls -li</code>显示的第1个字段。i-node维护的信息包括文件类型、文件所有者的用户ID、文件所属组的组ID、访问权限、时间戳 (最近1次访问文件的时间戳、最近1次修改文件的时间戳和最近1次修改i-node信息的时间戳)、指向文件的硬链接数、文件大小 (以字节为单位)、实际分配给文件的块数 (块大小是512字节) 和指向文件数据块的指针。</p><p>　　与其他UNIX文件系统一样，ext2文件系统不会连续存储文件数据块 (甚至不会顺序存储)。为了定位文件数据块，内核在i-node中维护了一组指针。</p><p>　　对于文件系统，以非连续的方式存储文件块可以提高磁盘空间使用率，尤其是降低产生空闲磁盘空间碎片的可能性 (存在大量不连续且小到无法使用的空闲空间)。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/structure_of_file_blocks_for_a_file_in_an_ext2_file_system.svg"><p>　　对于ext2，每个i-node包含15个指针。前12个指针指向文件的前12个块。第13个指针是指向指针块的指针，该指针块提供了文件的第13个块和后续数据块的位置。第13个指针指向的指针块中的指针数取决于文件系统的块大小 (当指针是4字节时，该指针块中可能有256~1024个指针)。对于较大的文件，第14个指针是<span style="background-color:#ff0">双重间接指针</span>，它指向的指针块也指向指针块，而后者指向文件的数据块。对于很大的文件，第15个指针是<span style="background-color:#ff0">三重间接指针</span>。</p><p>　　这个看似复杂的文件系统旨在满足多个请求。首先，它允许i-node结构体有固定大小，同时也允许文件有任意大小。其次，它允许文件系统以非连续的方式存储文件块，同时也允许通过<code>lseek()</code>随机访问数据 (内核只需要计算下一个指针)。最后，对于较小的文件，该文件系统允许通过i-node中的直接指针快速访问；对于很大的文件，当块是4096字节时，三重间接指针就能存储1024*1024*1024*4096字节 (4TB) 的文件。</p><p>　　这种设计的另一个优势是文件可以有空洞。文件系统可以直接将指针标记为0来表示对应的块没有引用磁盘块。</p><h3 id="虚拟文件系统">14.5 虚拟文件系统</h3><p>　　可用于Linux的文件系统的细节各不相同 (例如，分配文件块的方式和组织目录的方式)，这使得开发支持各种文件系统的应用程序几乎不可能。虚拟文件系统正是为了解决这一问题，<strong>虚拟文件系统</strong>是为文件系统操作创建抽象层的内核功能。</p><p>　　● VFS给文件系统操作定义了1个通用接口。所有处理文件的程序可以通过该接口来指定文件系统操作。</p><p>　　● 每个文件系统为VFS接口提供实现。</p><p>　　VFS接口包括与用于处理文件系统和目录的常用系统调用 (例如，<code>open()</code>、<code>read()</code>、<code>write()</code>、<code>lseek()</code>、<code>close()</code>、<code>truncate()</code>、<code>stat()</code>、<code>mount()</code>、<code>umount()</code>、<code>mmap()</code>、<code>mkdir()</code>、<code>link()</code>、<code>unlink()</code>、<code>symlink()</code>和<code>rename()</code>) 相对应的操作。</p><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/virtual_file_system.svg"><p>　　VFS抽象层以传统的UNIX文件系统模型为模型。当然，有些文件系统 (尤其是非原生UNIX文件系统) 不支持所有VFS操作。对于这种情况，底层文件系统会返回错误码给VFS来表示不支持指定操作，并且VFS会将该错误码返回给应用程序。</p><h3 id="日志文件系统">14.6 日志文件系统</h3><p>　　对于ext2等传统文件系统，系统崩溃后，必须在重启时执行<span style="background-color:#ff0">文件系统一致性检测</span> (命令<code>fsck</code>) 来确保文件系统的完整性。系统崩溃时，文件更新可能只完成了一部分，并且文件系统元数据 (目录条目、i-node信息和文件块指针) 可能处于不一致的状态，所以文件系统可能由于不一致未修复而进一步损坏。文件系统一致性检测会确保文件系统元数据的一致性。当可能时，也会执行修复，无法修复的信息 (可能包含文件数据) 将被丢弃。</p><p>　　传统文件系统的问题在于一致性检测需要检查整个文件系统。对于较小的文件系统，这可能会花费数秒。对于较大的文件系统，这可能会花费数小时，这对于必须保持高可用性的系统 (例如，网络服务器) 是严重的问题。</p><p>　　日志文件系统解决了系统崩溃后进行冗长的一致性检测的问题，日志文件系统会在实际元数据更新前就将所有元数据更新记录在1个特殊的磁盘日志文件中。这些更新记录在相关元数据更新 (事务) 组中。若在执行事务的过程中系统崩溃，则系统重启时会撤销所有未完成的更新，并将文件还原到一致性状态 (按照数据库术语，日志文件系统会保证文件元数据事务始终作为完整的单元提交)。当系统崩溃后，很大的日志文件系统只需要数秒就能正常运行。</p><p>　　部分日志文件系统只确保文件元数据的一致性。因为他们不记录文件数据，所以系统崩溃时，文件数据还是可能会丢失。ext3、ext4和Reiserfs提供了记录文件数据更新的选项，但由于工作负载，这可能会降低I/O性能。</p><p>　　日志文件系统最大的劣势是更新文件需要更长的时间，尽管良好的设计已经在尽可能地缩短这一时间。</p><p>　　可用于Linux的日志文件系统包括Reiserfs、ext3、JFS和XFS。</p><p>　　● Reiserfs是第1个集成到内核 (版本2.4.1) 的日志文件系统。Reiserfs提供了称为<strong>尾部打包</strong> (或<strong>尾部合并</strong>) 的特性，即将较小的文件 (和较大文件的最后1个片) 打包到文件元数据所属的磁盘块。很多系统都有 (和有些应用程序都会生成) 大量的较小的文件，这会节省很多磁盘空间。</p><p>　　● ext3文件系统是以最小的影响将日志加入到ext2得到的结果。从ext2迁移到ext3非常简单 (无需备份和存储)，并且也可以从ext3迁移到ext2。ext3已集成到内核2.4.15中。</p><p>　　● JFS由IBM开发，它已集成到内核2.4.20中。</p><p>　　● XFS最初由Silicon Graphics (SCI) 于20世纪90年代早期为其专有的UNIX实现Irix开发。在2001年，XFS移植到了Linux，并且提供为免费软件。XFS已集成到内核2.4.24中。</p><p>　　在配置内核时，可以通过在文件系统菜单下设置内核选项来启用对各种文件系统的支持。</p><p>　　在撰写本书时，ext4和Btrfs (B-tree FS) 的工作正在进行中，这2个文件系统提供了日志和一系列其他高级特性：</p><p>　　● ext4文件系统是ext3的后继者。实现的第1部分已集成到内核2.6.19中，在后来的版本中集成了各种特性。ext4的计划 (或已实现的) 特性包括扩展 (保留连续的存储块) 和其他旨在减少文件碎片的分配特性、在线文件系统碎片整理、更快的文件系统检索和对纳秒时间戳的支持。</p><p>　　● Btrfs是从头开始设计的新文件系统，旨在提供了一系列现代特性，包括扩展、可写的快照 (提供等同于元数据和数据日志的功能) 、数据和元数据的校验和、在线文件系统检测、在线文件系统碎片整理、节省空间的小文件打包以及节省空间的索引目录。Btrfs已集成到内核2.6.29中。</p><h3 id="单一目录层次结构和挂载点">14.7 单一目录层次结构和挂载点</h3><p>　　对于Linux和大多数UNX实现，所有文件都位于单一目录树下。该树的根节点是根目录<code>/</code>。其他文件系统都是<strong>挂载</strong>在根目录下。超级用户可以通过以下命令来挂载1个文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount device directory</span></span><br></pre></td></tr></table></figure><p>　　该命令会将名为<code>device</code>的文件系统附加到<code>directory</code>指定的目录下，即<strong>挂载点</strong>。当文件系统已挂载时，无法修改其挂载点。文件系统可以通过命令<code>umount</code>来卸载。</p><p>　　对于Linux 2.4.19及以上版本，事情变得更加复杂，因为内核开始支持进程级<span style="background-color:#ff0">挂载命名空间</span>，即每个进程都可以有自己的文件系统挂载点集合。因此，可能会出现不同于其他进程的单一目录层次结构。</p><p>　　当需要列出当前已挂载的文件系统时，可以直接使用命令<code>mount</code> (不带有任何参数)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount</span></span><br><span class="line">/dev/sda6 on / type ext4 (rw)</span><br><span class="line">proc on /proc type proc (rw)</span><br><span class="line">sysfs on /sys type sysfs (rw)</span><br><span class="line">devpts on /dev/pts type devpts (rw,mode=0620,gid=5)</span><br><span class="line">/dev/sda8 on /home type ext3 (rw,acl,user_xattr)</span><br><span class="line">/dev/sda1 on /windows/C type vfat (rw,noexec,nosuid,nodev)</span><br><span class="line">/dev/sda9 on /home/mtk/test type reiserfs (rw)</span><br></pre></td></tr></table></figure><img src="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/example_directory_hierarchy_showing_file-system_mount_points.svg"><p>　　上图展示了执行上述挂载命令的系统的部分目录和文件结构，同时，这里也展示了挂载点如何映射到目录层次结构。</p><p>　　文件<code>/etc/mtab</code>、<code>/etc/fstab</code>以及特定于Linux的虚拟文件<code>/proc/mounts</code>包含当前已挂载和能挂载的文件系统的相关信息。</p><p>　　● 命令<code>mount</code>和<code>umount</code>会自动维护文件<code>/etc/mtab</code>，其中包含已挂载的文件系统的详细信息。该文件包含提供给命令<code>mount</code>的特定于文件系统的选项 (文件<code>/proc/mounts</code>中不包含这些信息)。但是，因为系统调用<code>mount()</code>和<code>umount()</code>不更新<code>/etc/mtab</code>，所以当挂载或卸载设备的应用程序更新该文件失败时，该文件中的信息可能不准确。</p><p>　　● 文件<code>/etc/fstab</code>由系统管理员手动维护，其中包含系统中所有可用的文件系统的描述。命令<code>mount</code>、<code>umount</code>和<code>fsck</code>会使用该文件。</p><p>　　● 可以通过文件<code>/proc/mounts</code>来获取当前已挂载的文件系统的列表，该文件是到内核数据结构的接口，所以它包含已挂载的文件系统的准确信息。由于进程级挂载命名空间，每个进程都有文件<code>/proc/PID/mounts</code>，其中列出了组成挂载命名空间的挂载点。此外，<code>/proc/mounts</code>只是指向<code>/proc/self/mounts</code>的符号链接。</p><p>　　这3个文件中的信息都使用如下所示的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda9 /boot ext3 rw 0 0</span><br></pre></td></tr></table></figure><p>　　每行信息包含6个字段。第1个和第2个字段是已挂载的设备的名称和挂载点。第3个字段是文件系统类型。第4个字段是挂载标志 (例如，<code>rw</code>表示挂载为可读可写)。第5个字段是用于通过命令<code>dump</code>控制文件系统备份操作的数字。第6个字段是用于控制命令<code>fsck</code>在系统引导时检测文件系统的顺序的数字。</p><p>　　库函数<code>getfsent()</code>和<code>getmntent()</code>的手册记录了可用于从这3个文件读记录的函数。</p><h3 id="挂载和卸载文件系统">14.8 挂载和卸载文件系统</h3><p>　　系统调用<code>mount()</code>和<code>umount()</code>允许特权进程 (能力<code>CAP_SYS_ADMIN</code>) 挂载和卸载文件系统。大多数UNIX实现提供了这2个系统调用。但是，SUSv3没有说明这2个系统调用，并且它们的行为因UNIX实现或文件系统而异。</p><h4 id="挂载文件系统">14.8.1 挂载文件系统</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *source, <span class="type">const</span> <span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *fstype,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> mountflags, <span class="type">const</span> <span class="type">void</span> *data)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br></pre></td></tr></table></figure><p>　　系统调用<code>mount()</code>会将参数<code>source</code>指定的设备挂载到参数<code>target</code>指定的挂载点。</p><p>　　参数<code>fstype</code>是设备包含的文件系统类型的标识字符串 (例如，<code>ext4</code>或<code>btrfs</code>)。参数<code>mountflags</code>可以包含任意个挂载标志 (或运算<code>|</code>)。参数<code>data</code>是指向缓冲区的指针，该缓冲区中的信息的解析取决于文件系统。对于大多数文件系统类型，<code>data</code>是由逗号分隔的选项设置组成的字符串。</p><table><colgroup><col style="width:21%"><col style="width:78%"></colgroup><thead><tr><th><code>mountflags</code>标志</th><th>目的</th></tr></thead><tbody><tr><td><code>MS_BIND</code></td><td>创建绑定挂载 (Linux 2.4及以上版本)</td></tr><tr><td><code>MS_DIRSYNC</code></td><td>同步目录更新 (Linux 2.6及以上版本)</td></tr><tr><td><code>MS_MANDLOCK</code></td><td>允许强制锁定文件</td></tr><tr><td><code>MS_MOVE</code></td><td>以原子方式将挂载点移动到其他位置</td></tr><tr><td><code>MS_NOATIME</code></td><td>不更新文件 (包括目录) 的最后访问时间</td></tr><tr><td><code>MS_NODEV</code></td><td>不允许访问设备</td></tr><tr><td><code>MS_NODIRATIME</code></td><td>不更新目录的最后访问时间</td></tr><tr><td><code>MS_NOEXEC</code></td><td>不允许执行程序</td></tr><tr><td><code>MS_NOSUID</code></td><td>禁用set-user-ID和set-group-ID程序</td></tr><tr><td><code>MS_RDONLY</code></td><td>只读挂载点，文件无法创建或修改</td></tr><tr><td><code>MS_REC</code></td><td>递归挂载 (Linux 2.4.11及以上版本)</td></tr><tr><td><code>MS_RELATIME</code></td><td>当且仅当最后访问时间早于最后修改时间或最后状态修改时间时，才更新最后访问时间 (Linux 2.6.20及以上版本)</td></tr><tr><td><code>MS_REMOUNT</code></td><td>修改已挂载的文件系统的<code>mountflags</code>和<code>data</code></td></tr><tr><td><code>MS_STRICTATIME</code></td><td>总是更新最后访问时间 (Linux 2.6.30及以上版本)</td></tr><tr><td><code>MS_SYNCHRONOUS</code></td><td>同步所有文件和目录更新</td></tr></tbody></table><p>　　● <code>MS_BIND</code>表示创建1个挂载点。若指定了该标志，则<code>fstype</code>、<code>mountflags</code>和<code>data</code>都会被忽略。</p><p>　　● <code>MS_DIRSYNC</code>表示同步目录更新，类似于<code>open()</code>的打开状态标志<code>O_SYNC</code>，但只会应用于目录更新，并且不会产生同步所有文件的开销。标志<code>FS_DIRSYNC_FL</code>与<code>MS_DIRSYNC</code>类似，但<code>FS_DIRSYNC_FL</code>可应用于单个目录。此外，对于Linux，对引用目录的文件描述符调用<code>fsync()</code>也能用于同步单个目录 (SUSv3没有说明这种特定于Linux的行为)。</p><p>　　● <code>MS_MANDLOCK</code>表示允许该文件系统中的文件进行强制记录锁定。</p><p>　　● <code>MS_MOVE</code>表示以原子方式将<code>source</code>指定的已存在的挂载点移动到<code>target</code>指定的新位置，这与命令<code>mount</code>的选项<code>--move</code>对应。该标志等同于卸载子树，然后重新挂载到新位置，除了子树未卸载时没有挂载点。<code>source</code>应该是之前调用<code>mount()</code>时作为<code>target</code>的字符串。当指定该标志时，<code>fstype</code>、<code>mountflags</code>和<code>data</code>都会被忽略。</p><p>　　● <code>MS_NOATIME</code>表示不更新该文件系统中的所有类型的文件的最后访问时间。该标志与<code>MS_NODIRATIME</code>用于节省每次访问文件时更新文件i-node所需的额外磁盘空间。对于不需要维护最后访问时间的应用程序，这会显著提升性能。<code>MS_NOATIME</code>与<code>FS_NOATIME_FL</code>类似，但是<code>FS_NOATIME_FL</code>可应用于单个文件。此外，对于Linux，打开单个文件时使用<code>open()</code>的打开状态标志<code>O_NOATIME</code>也能用于不更新单个文件的最后访问时间。</p><p>　　● <code>MS_NODEV</code>表示不允许访问该文件系统中的块设备和字符设备。该标志是旨在防止用户执行部分行为 (例如，插入包含允许任意访问系统的设备特殊文件的可移动磁盘) 的安全特性。</p><p>　　● <code>MS_NODIRATIME</code>表示不更新该文件系统中的目录的最后访问时间。该标志的功能是<code>MS_NOATIME</code>的功能的子集。</p><p>　　● <code>MS_NOEXEC</code>表示不允许执行该文件系统中的文件 (或脚本)。</p><p>　　● <code>MS_NOSUID</code>表示禁用该文件系统中的set-user-ID程序和set-group-ID程序。该标志是旨在防止用户运行可移动磁盘中的set-user-ID程序和set-group-ID程序的安全特性。</p><p>　　● <code>MS_RDONLY</code>表示将文件系统挂载为只读，所以无法创建和修改文件。</p><p>　　● <code>MS_REC</code>与其他标志一起使用，表示以递归方式将挂载操作应用于子树中的所有挂载。</p><p>　　● <code>MS_RELATIME</code>表示当且仅当最后访问时间戳早于最后修改时间戳或最后状态修改时间戳时，才会更新最后访问时间戳。该标志提供了<code>MS_NOATIME</code>的部分性能优势，并且对需要知道文件自上次更新以来是否被读取的程序很有用。对于Linux 2.6.30及以上版本，<code>MS_RELATIME</code>提供的功能成为了默认功能 (除非指定了<code>MS_NOATIME</code>)，并且需要指定<code>MS_STRICTATIME</code>才能获取经典行为。此外，若距最后访问时间戳的当前值已过去24小时，则总是会更新最后访问时间戳。</p><p>　　● <code>MS_RMOUNT</code>表示修改已挂载的文件系统的<code>mountflags</code>和<code>data</code> (例如，使只读的文件系统可写)。当使用该标志后，<code>source</code>和<code>target</code>需要与初始调用<code>mount()</code>时的相同，并且<code>fstype</code>会被忽略。该标志避免了卸载和重新挂载磁盘 (某些情况下，不可能卸载和重新挂载磁盘)。此外，并非所有的<code>mountflags</code>都可以修改。</p><p>　　● <code>MS_STRICTATIME</code>表示总是更新该文件系统中的文件的最后访问时间戳 (这是Linux 2.6.30之前的版本的默认行为)。若指定了该标志，则<code>mountflags</code>中的<code>MS_NOATIME</code>和<code>MS_RELATIME</code>都会被忽略。</p><p>　　● <code>MS_SYNCHRONOUS</code>表示同步该文件系统中的所有文件和目录更新 (对于文件，这等同于打开文件时使用<code>open()</code>的打开状态标志<code>O_SYNC</code>)。</p><p>　　从内核2.6.15开始，Linux提供了4个支持<span style="background-color:#ff0">共享子树</span>的新挂载标志：<code>MS_PRIVATE</code>、<code>MS_SHARED</code>、<code>MS_SLAVE</code>和<code>MS_UNBINDABLE</code> (这些标志可以与<code>MS_REC</code>一起使用来将其效果传播到挂载子树下的所有子挂载)。共享子树设计为供进程级挂载命名空间和用户空间文件系统等特定的高级文件系统特性使用。共享子树允许以受控方式在挂载命名空间之间传播文件系统挂载。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* t_mount.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usageError</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *progName, <span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [options] source target\n\n&quot;</span>, progName);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Available options:\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fpe(str) fprintf(stderr, <span class="string">&quot;  &quot;</span> str)</span></span><br><span class="line">    fpe(<span class="string">&quot;-t fstype [e.g., &#x27;ext2&#x27; or &#x27;reiserfs&#x27;]\n&quot;</span>);</span><br><span class="line">    fpe(<span class="string">&quot;-o data [file system-dependent options,\n&quot;</span>);</span><br><span class="line">    fpe(<span class="string">&quot; e.g., &#x27;bsdgroups&#x27; for ext2]\n&quot;</span>);</span><br><span class="line">    fpe(<span class="string">&quot;-f mountflags can include any of:\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fpe2(str) fprintf(stderr, <span class="string">&quot;     &quot;</span> str)</span></span><br><span class="line">    fpe2(<span class="string">&quot;b - MS_BIND create a bind mount\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;d - MS_DIRSYNC synchronous directory updates\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;l - MS_MANDLOCK permit mandatory locking\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;m - MS_MOVE atomically move subtree\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;A - MS_NOATIME don&#x27;t update atime (last access time)\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;V - MS_NODEV don&#x27;t permit device access\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;D - MS_NODIRATIME don&#x27;t update atime on directories\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;E - MS_NOEXEC don&#x27;t allow executables\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;S - MS_NOSUID disable set-user/group-ID programs\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;r - MS_RDONLY read-only mount\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;c - MS_REC recursive mount\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;R - MS_REMOUNT remount\n&quot;</span>);</span><br><span class="line">    fpe2(<span class="string">&quot;s - MS_SYNCHRONOUS make writes synchronous\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">char</span> *data, *fstype;</span><br><span class="line">    <span class="type">int</span> j, opt;</span><br><span class="line"></span><br><span class="line">    flags = <span class="number">0</span>;</span><br><span class="line">    data = <span class="literal">NULL</span>;</span><br><span class="line">    fstype = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;o:t:f:&quot;</span>)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">            data = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            fstype = optarg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(optarg); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (optarg[j])</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                    flags |= MS_BIND;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                    flags |= MS_DIRSYNC;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">                    flags |= MS_MANDLOCK;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">                    flags |= MS_MOVE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                    flags |= MS_NOATIME;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">                    flags |= MS_NODEV;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                    flags |= MS_NODIRATIME;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                    flags |= MS_NOEXEC;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                    flags |= MS_NOSUID;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">                    flags |= MS_RDONLY;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                    flags |= MS_REC;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">                    flags |= MS_REMOUNT;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    flags |= MS_SYNCHRONOUS;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    usageError(argv[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            usageError(argv[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != optind + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageError(argv[<span class="number">0</span>], <span class="string">&quot;Wrong number of arguments\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mount(argv[optind], argv[optind + <span class="number">1</span>], fstype, flags, data) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;mount&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个示例提供了系统调用<code>mount()</code>的命令级接口。实际上，这是命令<code>mount</code>的简略版。</p><h4 id="卸载文件系统">14.8.2 卸载文件系统</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">umount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">umount2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>umount()</code>会卸载参数<code>target</code>指定的挂载点对应的文件系统。当文件系统<span style="background-color:#ff0">繁忙</span>时 (即该文件系统中有打开的文件或某个进程的当前工作目录位于该文件系统)，无法卸载该文件系统。对繁忙的文件系统调用<code>umount()</code>会导致错误<code>EBUSY</code>。</p><p>　　系统调用<code>umount2()</code>是<code>umount()</code>的扩展版，它允许通过参数<code>flags</code>来为挂载操作提供更好的控制。参数<code>flags</code>可以包含以下标志中的任意个标志 (或运算<code>|</code>)：</p><p>　　● <code>MNT_DETACH</code> (Linux 2.4.11及以上版本) 表示执行<span style="background-color:#ff0">懒</span>卸载。挂载点会被标记，以便进程无法对其进行新的访问，但已经在使用它的进程可以继续访问。当所有进程都不再使用该挂载时，文件系统才会卸载。</p><p>　　● <code>MNT_EXPIRE</code> (Linux 2.6.8及以上版本) 表示将挂载点标记为<span style="background-color:#ff0">过期</span>。若调用<code>umount2()</code>时指定了该标志，并且挂载点不忙，则本次调用会失败 (错误<code>EAGAIN</code>)，对应的挂载点会被标记为过期；若挂载点繁忙，则本次调用也会失败 (错误<code>EBUSY</code>)，并且挂载点不会被标记为过期。挂载点标记为过期后，只要后续没有进程使用该挂载点，它就一直保持过期。若对过期的挂载点调用<code>umount2()</code>，并且指定了该标志，则会卸载过期的挂载点。这提供了1种机制来卸载一段时间未使用的文件系统。此外，该标志无法与<code>MNT_DETACH</code>或<code>MNT_FORCE</code>一起使用。</p><p>　　● <code>MNT_FORCE</code>表示即使设备繁忙，也强制卸载 (仅限于NFS挂载)。</p><p>　　● <code>UMOUNT_NOFOLLOW</code> (Linux 2.6.34及以上版本) 表示若<code>target</code>是符号链接，则不对其解引用。该标准设计为供set-user-ID-root程序 (允许非特权用户执行卸载) 使用，以避免<code>target</code>是被修改为指向其他位置的符号链接而导致的安全问题。</p><h3 id="高级挂载特性">14.9 高级挂载特性</h3><h4 id="将1个文件系统挂载到多个挂载点">14.9.1 将1个文件系统挂载到多个挂载点</h4><p>　　对于内核2.4以下的版本，1个文件系统只能挂载在1个挂载点。对于内核2.4及以上版本，1个文件系统可以挂载到该文件系统内的多个挂载点，因为挂载着相同的文件系统的所有挂载点都对应相同的子树，所以通过1个挂载点所做的修改可以通过其他挂载点看到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> /demo</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount /dev/sda12 /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount /dev/sda12 /demo</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount | grep sda12</span></span><br><span class="line">/dev/sda12 on /testfs type ext3 (rw)</span><br><span class="line">/dev/sda12 on /demo type ext3 (rw)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> /testfs/myfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> /demo</span></span><br><span class="line">lost+found myfile</span><br></pre></td></tr></table></figure><p>　　以上命令会先将文件系统<code>/dev/sda12</code>挂载到2个挂载点，然后修改1个挂载点的内容，最后通过另一个挂载点展示做出的修改。</p><p>　　因为设备可以挂载到多个挂载点，所以对于Linux 2.4及以上版本，系统调用<code>umount()</code>无法将设备作为其参数。</p><h4 id="将多个挂载堆叠在1个挂载点">14.9.2 将多个挂载堆叠在1个挂载点</h4><p>　　对于内核2.4以下的版本，1个挂载点只能挂载1次。对于内核2.4及以上版本，1个挂载点堆叠多个挂载。对于堆叠在相同挂载点的挂载，每个新挂载都会隐藏以前在该挂载点可见的目录子树。当位于顶端的挂载被卸载时，之前隐藏的挂载会再次可见。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount /dev/sda12 /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> /testfs/myfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount /dev/sda13 /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount | grep testfs</span></span><br><span class="line">/dev/sda12 on /testfs type ext3 (rw)</span><br><span class="line">/dev/sda13 on /testfs type reiserfs (rw)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> /testfs/newfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> /testfs</span></span><br><span class="line">newfile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">umount /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount | grep testfs</span></span><br><span class="line">/dev/sda12 on /testfs type ext3 (rw)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> /testfs</span></span><br><span class="line">lost+found myfile</span><br></pre></td></tr></table></figure><p>　　以上命令会先将文件系统<code>/dev/sda12</code>和<code>/dev/sda13</code>都挂载到1个挂载点并创建子树，然后卸载顶端的文件系统，最后显示挂载点的内容。</p><p>　　挂载堆叠的用途之一是将新挂载堆叠到当前繁忙的挂载点。保持文件描述符打开、<code>chroot</code>失败或在旧挂载点中有当前工作目录的进程可以继续在旧挂载下运行，但对挂载点进行新访问的进程会使用新挂载。与系统调用<code>umount2()</code>的标志<code>MNT_DETACH</code>一起使用，可以提供从文件系统平滑迁移的过程，而无需使系统进入单用户模式。</p><h4 id="作为每个挂载点选项的标志">14.9.3 作为每个挂载点选项的标志</h4><p>　　对于内核2.4以下的版本，文件系统和挂载点之间关系是1对1。对于内核2.4及以上版本，部分<code>mountflags</code>标志可以基于挂载设置，这些标志是<code>MS_NOATIME</code> (Linux 2.6.16及以上版本)、<code>MS_NODEV</code> 、<code>MS_NODIRATIME</code> (Linux 2.6.16及以上版本)、<code>MS_NOEXEC</code>、<code>MS_NOSUID</code>、<code>MS_RDONLY</code> (Linux 2.6.26及以上版本) 和<code>MS_RELATIME</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount /dev/sda12 /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -o noexec /dev/sda12 /demo</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/mounts | grep sda12</span></span><br><span class="line">/dev/sda12 /testfs ext3 rw 0 0</span><br><span class="line">/dev/sda12 /demo ext3 rw,noexec 0 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cp</span> /bin/echo /testfs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/testfs/echo <span class="string">&quot;Art is something which is well done&quot;</span></span></span><br><span class="line">Art is something which is well done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/demo/echo <span class="string">&quot;Art is something which is well done&quot;</span></span></span><br><span class="line">bash: /demo/echo: Permission denied</span><br></pre></td></tr></table></figure><p>　　以上命令展示了标志<code>MS_NOEXEC</code>的用法。</p><h4 id="绑定挂载">14.9.4 绑定挂载</h4><p>　　对于内核2.4及以上版本，Linux允许创建绑定挂载 (通过系统调用<code>mount()</code>的标志<code>MS_BIND</code>)。<strong>绑定挂载</strong>允许目录或文件挂载到文件系统层次架构中的其他位置，该目录或文件的结果会在所有位置都可见。绑定挂载与硬链接类似，但在以下2个方面不同：</p><p>　　● 绑定挂载可以跨文件系统挂载点 (甚至<code>chroot</code>失败)。</p><p>　　● 可以对目录进行绑定挂载。</p><p>　　可以通过命令<code>mount</code>的选项<code>--bind</code>在shell中创建绑定挂载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> d1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> d1/x</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> d2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount --<span class="built_in">bind</span> d1 d2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> d2</span></span><br><span class="line">x</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> d2/y</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> d1</span></span><br><span class="line">x y</span><br></pre></td></tr></table></figure><p>　　以上命令会先将<code>d1</code>绑定到<code>d2</code>，然后在目录<code>d2</code>下从创建文件<code>y</code>，最后列出目录<code>d1</code>下的文件。</p><h4 id="递归绑定挂载">14.9.5 递归绑定挂载</h4><p>　　在默认情况下，当通过系统调用<code>mount()</code>的标志<code>MS_BIND</code>来对目录进行绑定时，只会将该目录挂载到新位置，若该目录下有子绑定，则不会在挂载目录下复制这些子绑定。Linux 2.4.11添加了标志<code>MS_REC</code>，该标志与<code>MS_BIND</code>进行或运算得到的结果可以指定给<code>mount()</code>的参数<code>flags</code>，以保证子绑定也会复制，这种情况称为<strong>递归绑定挂载</strong>。</p><p>　　可以通过命令<code>mount</code>的选项<code>--rbind</code>来在shell中创建递归绑定挂载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su</span></span><br><span class="line">Password:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> top</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> src1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> src1/aaa</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount --<span class="built_in">bind</span> src1 top</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> top/sub</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> src2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">touch</span> src2/bbb</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount --<span class="built_in">bind</span> src2 top/sub</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find top</span></span><br><span class="line">top</span><br><span class="line">top/aaa</span><br><span class="line">top/sub</span><br><span class="line">top/sub/bbb</span><br></pre></td></tr></table></figure><p>　　这里会先在<code>top</code>下创建1个挂载在<code>top</code>下的目录树<code>src1</code>，该树包括挂载在<code>top/sub</code>的子挂载<code>src2</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> dir1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount --<span class="built_in">bind</span> top dir1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find dir1</span></span><br><span class="line">dir1</span><br><span class="line">dir1/aaa</span><br><span class="line">dir1/sub</span><br></pre></td></tr></table></figure><p>　　然后，创建第3个绑定挂载<code>dir2</code>，因为该绑定挂载是非递归的，所以子挂载不会复制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> dir2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount --rbind top dir2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find dir2</span></span><br><span class="line">dir2</span><br><span class="line">dir2/aaa</span><br><span class="line">dir2/sub</span><br><span class="line">dir2/sub/bbb</span><br></pre></td></tr></table></figure><p>　　最后，创建递归绑定挂载<code>dir2</code>。</p><h3 id="虚拟内存文件系统">14.10 虚拟内存文件系统</h3><p>　　之前的介绍的文件系统都是位于磁盘。Linux也支持<span style="background-color:#ff0">位于内存的虚拟文件系统</span>。对于应用程序，这些文件系统系统与常规文件系统相似，对常规文件系统执行的操作 (例如，<code>open()</code>、<code>read()</code>、<code>write()</code>、<code>link()</code>和<code>mkdir()</code>) 也可以应用于这些文件系统，但这些操作会更快，因为不涉及磁盘访问。</p><p>　　迄今为止，最复杂的位于的虚拟文件系统是tmpfs文件系统，它首次出现在Linux 2.4。tmpfs与其他位于内存的虚拟文件系统不同之处在于它是<strong>虚拟内存文件系统</strong>，这表示tmpfs不仅会使用RAM，还会在RAM耗尽时使用交换空间。尽管tmpfs是特定于Linux的，但大多数UNIX实现也提供了某种形式的位于内存的虚拟文件系统。</p><p>　　tmpfs文件系统是可选的Linux内核组件，可以通过选项<code>CONFIG_TMPFS</code>配置。</p><p>　　可以使用如下格式的命令来创建tmpfs文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -t tmpfs <span class="built_in">source</span> target</span></span><br></pre></td></tr></table></figure><p>　　<code>source</code>可以是任何名称，其唯一的意义在于出现在<code>/proc/mounts</code>，并且由命令<code>mount</code>和<code>df</code>显示。<code>target</code>是文件系统的挂载点。这里并不需要先通过命令<code>mkfs</code>创建文件系统，因为命令<code>mount</code>会自动创建文件系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount -t tmpfs newtmp /tmp</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/mounts | grep tmp</span></span><br></pre></td></tr></table></figure><p>　　以上命令 (或在文件<code>/etc/fstab</code>中的等效条目) 有时会用于提高频繁使用目录<code>/tmp</code>来创建临时文件的应用程序 (例如，编译器) 的性能。</p><p>　　在默认情况下，tmpfs文件系统被允许最多占用RAM的一半，但选项<code>size=nbytes</code>可用于为该文件系统的大小设置上限，无论是在创建文件系统时还是重新挂载时 (tmpfs文件系统占用的内存和交换空间的大小等于它保存的文件的大小)。</p><p>　　当卸载文件系统或系统崩溃时，tmpfs文件系统中的所有数据将会丢失，所以其名称是tmpfs。</p><p>　　除了供用户应用程序使用之外，tmpfs文件系统还有2个特殊目的：</p><p>　　● 由内核内部挂载的不可见的tmpfs文件系统会用于实现System V共享内存和共享匿名内存映射。</p><p>　　● 挂载在<code>/dev/shm</code>的tmpfs文件系统会用于POSIX共享内存和POSIX信号量的glibc实现。</p><h3 id="获取文件系统的相关信息">14.11 获取文件系统的相关信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/statvfs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">statvfs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> statvfs *statvfsbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstatvfs</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> statvfs *statvfsbuf)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">statvfs</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_bsize;   <span class="comment">/* 文件系统块大小 (以字节为单位) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_frsize;  <span class="comment">/* 基本文件系统块大小 (以字节为单位) */</span></span><br><span class="line">    <span class="type">fsblkcnt_t</span> f_blocks;     <span class="comment">/* 文件系统中的块的数量 (以f_frsize为单位) */</span></span><br><span class="line">    <span class="type">fsblkcnt_t</span> f_bfree;      <span class="comment">/* 空闲块数 */</span></span><br><span class="line">    <span class="type">fsblkcnt_t</span> f_bavail;     <span class="comment">/* 非特权进程可用的空闲块数 */</span></span><br><span class="line">    <span class="type">fsfilcnt_t</span> f_files;      <span class="comment">/* i-node数 */</span></span><br><span class="line">    <span class="type">fsfilcnt_t</span> f_ffree;      <span class="comment">/* 空闲i-node数 */</span></span><br><span class="line">    <span class="type">fsfilcnt_t</span> f_favail;     <span class="comment">/* 非特权进程可用的i-node数 (对于Linux，其值与f_ffree相同) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_fsid;    <span class="comment">/* 文件系统ID */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_flag;    <span class="comment">/* 挂载标志 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_namemax; <span class="comment">/* 该文件系统中的文件名的最大长度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　库函数<code>statvfs()</code>和<code>fstatvfs()</code>都可用于获取已挂载的文件系统的相关信息，结果存储在参数<code>statvfsbuf</code>指向的结构体中。两者唯一的区别是指定文件系统的方式。前者指定的是目标文件系统中的文件的路径名 (参数<code>pathname</code>)，后者指定的是目标文件系统中的文件描述符 (参数<code>fd</code>)。</p><p>　　结构体<code>statvfs</code>的注释清楚地说明了大多数成员的用途，以下是部分成员的细节：</p><p>　　● 对于大多数Linux文件系统，成员<code>f_bsize</code>和<code>f_frsize</code>的值相同。但是，部分文件系统支持<span style="background-color:#ff0">块碎片</span> (UNIX文件系统的块碎片概念最早于20世纪80年代早期出现在4.2BSD的快速文件系统)，该特性可用于在不需要完整块时在文件末尾分配较小的存储单元。对于这些文件系统，成员<code>f_frsize</code>的值是块碎片的大小，而成员<code>f_bsize</code>的值是完整块的大小。</p><p>　　● 很多原生UNIX和Linux文件系统都支持为超级用户保留文件系统中的块，所以即使文件系统已满，超级用户依旧能够登录到系统，并执行一些操作来解决该问题。若文件系统中存在保留块，则成员<code>f_bfree</code>和<code>f_bavail</code>的差值表示保留的块数。</p><p>　　● 成员<code>f_flag</code>是由用于挂载文件系统的标志组成的位掩码，即其中包含的信息与系统调用<code>mount()</code>的参数<code>mountflags</code>的相似，但该成员使用的标志带有前缀<code>ST_</code>，而非前缀<code>MS_</code>。SUSv3仅要求该成员使用的标志包括<code>ST_RDONLY</code>和<code>ST_NOSUID</code>，但glibc实现支持各种标志，其名称与<code>mount()</code>的<code>mountflags</code>标志的名称对应。</p><p>　　● 有些UNIX实现会通过成员<code>f_fsid</code>来返回文件系统的ID (例如，基于文件系统所在的设备的ID的值)。对于大多数Linux文件系统，该成员的值是0。</p><p>　　SUSv3详细说明了<code>statvfs()</code>和<code>fstatvfs()</code>。对于Linux和部分UNIX实现，这2个函数是系统调用<code>statfs()</code>和<code>fstatfs()</code>的包装函数 (有些UNIX实现提供了<code>statfs()</code>，但未提供<code>statvfs()</code>)。它们的主要区别如下 (除了部分名称不同的字段之外)：</p><p>　　● 库函数<code>statvfs()</code>和<code>fstatvfs()</code>会通过结构体<code>statvfs</code>的成员<code>f_flag</code>来返回文件系统的挂载标志 (glibc实现通过扫描文件<code>/proc/mounts</code>或<code>/etc/mtab</code>来获取这些信息)。</p><p>　　● 系统调用<code>statfs()</code>和<code>fstatfs()</code>会通过结构体<code>statfs</code>的成员<code>f_type</code>来返回文件系统的类型 (例如，值<code>0xef53</code>表示ext2文件系统)。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_13/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第13章 文件I&#x2F;O缓存"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第13章 文件I/O缓存</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_15/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第15章 文件属性">《Linux/UNIX系统编程手册》第15章 文件属性 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>