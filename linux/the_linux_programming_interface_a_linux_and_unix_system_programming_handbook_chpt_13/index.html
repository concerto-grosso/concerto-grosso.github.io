<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple_touch_icon_next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32_next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16_next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/serach.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script><link rel="canonical" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_13/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_13/","path":"linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_13/","title":"《Linux/UNIX系统编程手册》第13章 文件I/O缓存"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《Linux/UNIX系统编程手册》第13章 文件I/O缓存 |</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title"></p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6io%E4%B8%AD%E7%9A%84%E5%86%85%E6%A0%B8%E7%BC%93%E5%86%B2"><span class="nav-text">13.1 文件I&#x2F;O中的内核缓冲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdio%E5%BA%93%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2"><span class="nav-text">13.2 stdio库中的缓冲</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEstdio%E6%B5%81%E7%9A%84%E7%BC%93%E5%86%B2%E6%A8%A1%E5%BC%8F"><span class="nav-text">13.2.1 设置stdio流的缓冲模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%B7%E6%96%B0stdio%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">13.2.2 刷新stdio缓冲区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%96%87%E4%BB%B6io%E7%9A%84%E5%86%85%E6%A0%B8%E7%BC%93%E5%86%B2"><span class="nav-text">13.3 控制文件I&#x2F;O的内核缓冲</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%BF%97o_sync"><span class="nav-text">13.3.1 标志O_SYNC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%BF%97o_dsync%E5%92%8Co_rsync"><span class="nav-text">13.3.2 标志O_DSYNC和O_RSYNC</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description">这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_13/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""><meta itemprop="description" content="这只是个人学习总结，难免出错，欢迎指出，邮箱：concerto-grosso@outlook.com"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="《Linux&#x2F;UNIX系统编程手册》第13章 文件I&#x2F;O缓存 | null"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Linux/UNIX系统编程手册》第13章 文件I/O缓存</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-26T00:00:00+08:00">2024-12-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-21 00:00:00" itemprop="dateModified" datetime="2025-01-21T00:00:00+08:00">2025-01-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.7k</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>　　为了速度和效率，I/O系统调用 (即内核) 和标准C库的I/O函数 (即stdio函数) 在操作磁盘文件时会缓存数据。</p><p>　　当对磁盘文件调用系统调用<code>read()</code>和<code>write()</code>时，这2个系统调用不会立即开始访问磁盘文件。相反，它们只会在用户空间缓冲区和内核<strong>缓冲区缓存</strong>中的某个缓冲区之间复制信息。</p><p>　　● <code>write(fd, "abc", 3)</code>会从用户空间缓冲区传输3字节的数据到内核空间缓冲区。在<code>write()</code>返回后的某个时间点，内核会将其缓冲区刷新 (写入) 到磁盘。在此期间 (<code>write()</code>返回后到内核刷新缓冲区前)，若其他进程试图访问通过<code>write()</code>写入的数据，则内核会自动从缓冲区缓存提供数据，而非从对应的文件提供数据。</p><p>　　● 对于输入，内核会从磁盘读数据到在某个内核缓冲区。调用<code>read()</code>会从该缓冲区提取数据，直到该缓冲区为空，此时，内核继续读数据到缓冲区缓存 (这里进行了一些简化，对于顺序文件访问，内核通常会在缓冲区为空前提前读数据)。</p><p>　　这种设计提高了<code>read()</code>和<code>write()</code>的速度，因为它们不需要等待磁盘操作。这种设计也是高效的，因为减少了内核必须执行的磁盘数据传输。</p><p>　　从内核2.4开始，Linux不再维护单独的缓冲区缓存。相反，文件I/O缓冲区包含在页缓存 (其中也包含内存映射文件的页等页)。尽管如此，在之后的内容，还是会使用术语缓冲区缓存，因为该术语在UNIX实现中历来常见。</p><p>　　强制刷新输出文件的内核缓冲区是可能的。若应用程序 (数据库日志进程) 必须确保输出确实已写入到磁盘 (至少写入到磁盘的硬件缓存) 才能继续，则这是必要的。</p><p>　　SUSv3定义了术语<strong>同步I/O完成</strong>来表示 "已经传输到磁盘或确定为失败的I/O操作"。SUSv3定义了2种类型的同步I/O完成，两者之间的差距涉及到<span style="background-color:#ff0">文件元数据</span> (其中包含文件所有者和所属组、文件权限、文件大小、指向文件的 (硬) 链接数、最近1次访问文件的时间戳、最近1次修改文件的时间戳、最近1次修改文件元数据的时间戳以及文件数据块指针)。</p><p>　　SUSv3定义的第1种同步I/O完成是<strong>同步I/O数据完整性完成</strong>。对于读操作，这表示请求的文件数据已经被传输到进程 (若存在会影响请求数据的待执行的写操作，则这些写操作会先于读操作执行)。对于写操作，这表示请求的写操作指定的数据已经被传输到磁盘，并且检索该数据所需的所有文件元数据也已经传输到磁盘 (例如，若写操作扩大了文件，则必须传输的文件元数据包括文件大小)。值得注意的是检索文件数据并不需要所有修改后的文件元数据属性都传输完成 (例如，最近1次修改文件的时间戳)。</p><p>　　SUSv3定义的第2种同步I/O完成是<strong>同步I/O文件完整性完成</strong>，它是同步I/O数据完整性完成的超集。不同于同步I/O数据完整性完成的是，更新文件时，所有更新后的文件元数据都必须传输到磁盘，即使后续的文件数据的读操作不是必要的。</p><span id="more"></span><h3 id="文件io中的内核缓冲">13.1 文件I/O中的内核缓冲</h3><p>　　Linux内核没有对缓冲区缓存的上限设置固定值。内核会按需分配指定数量的缓冲区缓存页，这个过程仅受可用物理内存和用于其他目的物理内存需求的限制。若可用内存不足，则内核会将部分修改后的缓存区缓存页刷新到磁盘，以重新利用这些页。</p><p>　　无论是以每次写1字节的形式执行1000次，还是以每次写1000字节的形式执行1次，内核都执行相同数量的磁盘访问。但是，后者是首选方式，因为后者只需要1次系统调用，而前者需要1000次系统调用 (尽管系统调用比磁盘操作更快，但还仍然需要不少时间)。</p><p>　　不同大小的缓冲区对文件I/O的影响可以通过将<code>copy.c</code> (见第4章) 的<code>BUF_SIZE</code>设置为不同的值来查看。以下是在该程序使用不同的<code>BUF_SIZE</code>值在使用vanilla 2.6.30内核 (vanilla内核是<span style="background-color:#ff0">未应用补丁的主线内核</span>，这不同于大多数发行商提供的版本，后者通常包含修复漏洞和添加特性的补丁) 和块大小是4096字节的ext2文件系统的Linux上复制1亿字节的文件所需的时间：</p><table><colgroup><col style="width:14%"><col style="width:16%"><col style="width:20%"><col style="width:23%"><col style="width:23%"></colgroup><thead><tr><th style="text-align:left"><code>BUF_SIZE</code></th><th>总耗时 (秒)</th><th>总CPU时间 (秒)</th><th>用户CPU时间 (秒)</th><th>系统CPU时间 (秒)</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td>107.43</td><td>107.32</td><td>8.20</td><td>99.12</td></tr><tr><td style="text-align:left">2</td><td>54.16</td><td>53.89</td><td>4.13</td><td>49.76</td></tr><tr><td style="text-align:left">4</td><td>31.72</td><td>30.96</td><td>2.30</td><td>28.66</td></tr><tr><td style="text-align:left">8</td><td>15.59</td><td>14.34</td><td>1.08</td><td>13.26</td></tr><tr><td style="text-align:left">16</td><td>7.50</td><td>7.14</td><td>0.51</td><td>6.63</td></tr><tr><td style="text-align:left">32</td><td>3.76</td><td>3.68</td><td>0.26</td><td>3.41</td></tr><tr><td style="text-align:left">64</td><td>2.19</td><td>2.04</td><td>0.13</td><td>1.91</td></tr><tr><td style="text-align:left">128</td><td>2.16</td><td>1.59</td><td>0.11</td><td>1.48</td></tr><tr><td style="text-align:left">256</td><td>2.06</td><td>1.75</td><td>0.10</td><td>1.65</td></tr><tr><td style="text-align:left">512</td><td>2.06</td><td>1.03</td><td>0.05</td><td>0.98</td></tr><tr><td style="text-align:left">1024</td><td>2.05</td><td>0.65</td><td>0.02</td><td>0.63</td></tr><tr><td style="text-align:left">4096</td><td>2.05</td><td>0.38</td><td>0.01</td><td>0.38</td></tr><tr><td style="text-align:left">16384</td><td>2.05</td><td>0.34</td><td>0.00</td><td>0.33</td></tr><tr><td style="text-align:left">65536</td><td>2.06</td><td>0.32</td><td>0.00</td><td>0.32</td></tr></tbody></table><p>　　上表的数据是运行20次的平均值 (对于以上测试和本章的其他测试，每次运行程序之间都会卸载和重新挂载文件系统，以确保文件系统的缓冲区为空)。计时是使用命令<code>time</code>完成。因为通过各种大小的缓冲区传输的数据量是相同的，所以上表也展示了<code>read()</code>和<code>write()</code>的开销。对于1字节的缓冲区，需要调用1亿次<code>read()</code>和<code>write()</code>。对于4096字节的缓冲区，大约需要调用24000次<code>read()</code>和<code>write()</code>，并且达到了最佳性能。继续增大缓冲区并不会有明显的性能提升，因为与在用户空间和内核空间之间传输数据以及执行实际的磁盘I/O所用的时间相比，调用<code>read()</code>和<code>write()</code>所用的时间可以忽略不记。</p><p>　　最后几行大致给出了在用户空间和内核空间之间传输数据所用的时间和执行文件I/O所用的时间。因为系统调用的所用时间相比总耗时和CPU时间可以忽略不记，所以系统CPU时间可以视为在用户空间和内核空间之间传输数据所用的时间，总耗时可以视为数据传入和传出磁盘所用的时间。</p><p>　　从上表可以得出，<code>write()</code>在数据从用户空间传输到内核缓冲区缓存后就立即返回，因为测试系统的RAM (4GB) 远大于目标文件 (100MB) 的大小，所以可以假设程序运行完成时，目标文件并没有实际写入到磁盘。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* write_bytes.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        usageErr(<span class="string">&quot;%s file num-bytes buf-size\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> numBytes = getLong(argv[<span class="number">2</span>], GN_GT_0, <span class="string">&quot;num-bytes&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> bufSize = getLong(argv[<span class="number">3</span>], GN_GT_0, <span class="string">&quot;buf-size&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(bufSize);</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> openFlags = O_CREAT | O_WRONLY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_O_SYNC) &amp;&amp; defined(O_SYNC)</span></span><br><span class="line">    <span class="comment">/* 若编译时使用了选项-DUSE_O_SYNC，则以标志O_SYNC打开文件 */</span></span><br><span class="line">    openFlags |= O_SYNC;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">1</span>], openFlags, S_IRUSR | S_IWUSR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> thisWrite, totWritten;</span><br><span class="line">    <span class="keyword">for</span> (totWritten = <span class="number">0</span>; totWritten &lt; numBytes; totWritten += thisWrite)</span><br><span class="line">    &#123;</span><br><span class="line">        thisWrite = min(bufSize, numBytes - totWritten);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(fd, buf, thisWrite) != thisWrite)</span><br><span class="line">        &#123;</span><br><span class="line">            fatal(<span class="string">&quot;partial/failed write&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_FSYNC</span></span><br><span class="line">        <span class="comment">/* 若编译时使用了选项-DUSE_FSYNC，则在每次写入后都调用fsync() */</span></span><br><span class="line">        <span class="keyword">if</span> (fsync(fd))</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fsync&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_FDATASYNC</span></span><br><span class="line">        <span class="comment">/* 若编译时使用了选项-DUSE_FSYNC，则在每次写入后都调用fdatasync() */</span></span><br><span class="line">        <span class="keyword">if</span> (fdatasync(fd))</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;fdatasync&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　为了验证假设，这里会使用这个示例来进行测试 (该程序会写任意数据到指定文件)。以下是该程序使用不同大小的写缓冲区在使用vanilla 2.6.30内核和块大小是4096字节的ext2文件系统的Linux上写1亿字节到文件所需的时间 (运行20次的平均值)：</p><table><colgroup><col style="width:14%"><col style="width:16%"><col style="width:20%"><col style="width:23%"><col style="width:23%"></colgroup><thead><tr><th style="text-align:left"><code>BUF_SIZE</code></th><th>总耗时 (秒)</th><th>总CPU时间 (秒)</th><th>用户CPU时间 (秒)</th><th>系统CPU时间 (秒)</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td>72.13</td><td>72.11</td><td>5.00</td><td>67.11</td></tr><tr><td style="text-align:left">2</td><td>36.19</td><td>36.17</td><td>2.47</td><td>33.70</td></tr><tr><td style="text-align:left">4</td><td>20.01</td><td>19.99</td><td>1.26</td><td>18.73</td></tr><tr><td style="text-align:left">8</td><td>9.35</td><td>9.32</td><td>0.62</td><td>8.70</td></tr><tr><td style="text-align:left">16</td><td>4.70</td><td>4.68</td><td>0.31</td><td>4.47</td></tr><tr><td style="text-align:left">32</td><td>2.39</td><td>2.39</td><td>0.16</td><td>2.23</td></tr><tr><td style="text-align:left">64</td><td>1.24</td><td>1.24</td><td>0.07</td><td>1.16</td></tr><tr><td style="text-align:left">128</td><td>0.67</td><td>0.67</td><td>0.04</td><td>0.63</td></tr><tr><td style="text-align:left">256</td><td>0.38</td><td>0.38</td><td>0.02</td><td>0.36</td></tr><tr><td style="text-align:left">512</td><td>0.24</td><td>0.24</td><td>0.01</td><td>0.23</td></tr><tr><td style="text-align:left">1024</td><td>0.17</td><td>0.17</td><td>0.01</td><td>0.16</td></tr><tr><td style="text-align:left">4096</td><td>0.11</td><td>0.11</td><td>0.00</td><td>0.11</td></tr><tr><td style="text-align:left">16384</td><td>0.10</td><td>0.10</td><td>0.00</td><td>0.10</td></tr><tr><td style="text-align:left">65536</td><td>0.09</td><td>0.09</td><td>0.00</td><td>0.09</td></tr></tbody></table><p>　　上表仅展示了调用<code>write()</code>和将数据从用户空间传输到内核缓冲区缓存所用的时间。当缓冲区大小达到65536字节时，上一个测试总耗时2.06秒，而这里的总耗时仅有0.09秒。因为上一个测试并没有进行实际的磁盘I/O，即上一个测试的大部分时间用于读取磁盘。</p><p>　　上表中的信息只代表文件系统的1种 (简单) 基准测试机制。此外，结果可能会显示不同系统之间的一些差异。文件系统可以通过各种其他标志来衡量 (例如，在繁重的多用户负载下的性能、文件创建和删除的速度、在大型目录中搜索文件所需的时间、存储小文件所需的空间以及在系统崩溃时保证文件的完整性)。若I/O或其他文件系统操作的系统至关重要，则在目标平台上执行的特定于应用程序的基准测试是无可替代的。</p><h3 id="stdio库中的缓冲">13.2 stdio库中的缓冲</h3><p>　　在操作磁盘文件时，C库I/O函数会将数据缓冲到较大的内存块来减少系统调用。因此，使用stdio库会减轻<code>write()</code>输出数据和<code>read()</code>输入数据时的缓冲任务。</p><p>　　主线Linux内核没有实现System V的功能STREAMS，所以stdio库使用的流不会与该功能混淆。</p><h4 id="设置stdio流的缓冲模式">13.2.1 设置stdio流的缓冲模式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>; <span class="comment">/* 成功时返回0，出错时返回非0值 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>; <span class="comment">/* setvbuf()的包装函数 */</span></span><br></pre></td></tr></table></figure><p>　　函数<code>setvbuf()</code>用于控制stdio库使用的缓冲模式。</p><p>　　参数<code>stream</code>标识待设置的缓冲模式所属的文件流。当该文件流被打开后，应该保证<code>setvbuf()</code>先于其他基于该文件流的stdio函数调用，因为<code>setvbuf()</code>对缓冲模式的设置会影响后续的基于该文件流的所有stdio操作。</p><p>　　参数<code>buf</code>和<code>size</code>指定<code>stream</code>使用的缓冲区。这些参数可能通过以下2种方式指定：</p><p>　　● 若<code>buff</code>非<code>NULL</code>，则它指向供<code>stream</code>使用的<code>size</code>字节的内存块。因为<code>buf</code>指向的内存块随后供stdio库使用，所以该内存块应该是在堆上静态分配或动态分配的。</p><p>　　● 若<code>buff</code>是<code>NULL</code>，则stdio库会自动分配1个缓冲区供<code>stream</code>使用 (除非指定了不缓冲的I/O)。SUSv3允许但不要求实现使用<code>size</code>来决定该缓冲区的大小。对于这种情况，glibc实现中的<code>size</code>会被忽略。</p><p>　　参数<code>mode</code>指定缓冲模式，其值只能是<code>_IONBF</code>、<code>IOLBF</code>或<code>IOFBF</code>。</p><p>　　● <code>_IONBF</code>表示不缓冲的I/O。所有的stdio库调用都会导致执行系统调用<code>write()</code>或<code>read()</code>。此时，<code>buf</code>和<code>size</code>会被忽略，并且可以分别指定为<code>NULL</code>和0。这是<code>stderr</code>的默认缓冲模式，所以错误输出会立即出现。</p><p>　　● <code>_IOLBF</code>表示使用行缓冲的I/O。这是引用终端设备的流的默认缓冲模式。对于输出流，会缓冲数据，直到换行符输出 (除非缓冲区已满)。对于输入流，1次读取1行数据。</p><p>　　● <code>IOFBF</code>表示使用完全缓冲的I/O。数据以缓冲区的大小为单位读写。这是引用磁盘文件的流的默认缓冲模式。</p><p>　　函数<code>setbuf</code>是<code>setvbuf()</code>的包装函数，执行相似的任务。<code>setbuf(fp, buf)</code>等同于<code>setvbuf(fp, buf, (buf != NULL) ? _IOFBF : _IONBF, BUFSIZ)</code>。参数<code>buf</code>可以指定为<code>NULL</code>，表示不缓冲的I/O。<code>buf</code>也可以指定为调用者分配的大小为<code>BUFSIZ</code>字节的缓冲区 (<code>BUFSIZ</code>定义在<code>stdio.h</code>中)。对于glibc实现，<code>BUFSIZ</code>通常定义为8192。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>　　函数<code>setbuffer</code>与<code>setbuf()</code>类似，但允许调用者通过参数<code>size</code>来指定<code>buf</code>的大小。<code>setbuffer(fp, buf, size)</code>等同于<code>setvbuf(fp, buf, (buf != NULL) ? _IOFBF : _IONBF, size)</code>。</p><p>　　SUSv3没有说明<code>setbuffer()</code>，但大多数UNIX实现都提供了该函数。</p><h4 id="刷新stdio缓冲区">13.2.2 刷新stdio缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>; <span class="comment">/* 成功是返回0，出错时返回EOF */</span></span><br></pre></td></tr></table></figure><p>　　无论当前的缓冲模式如何，都可以通过库函数<code>fflush()</code>来强制写入stdio输出流中的数据 (即通过<code>write()</code>来刷新内核缓冲区)。该函数会刷新参数<code>stream</code>指定的输出缓冲区。若<code>stream</code>为<code>NULL</code>，则刷新所有stdio缓冲区。</p><p>　　<code>fflush()</code>也可以用于输入流，这会导致已缓冲的输入无效 (当程序下一次读取该流时，对应的缓冲区才会再次填充)。</p><p>　　当关闭流后，对应的stdio缓冲区也会自动刷新。</p><p>　　对于glibc等很多C库实现，若<code>stdin</code>和<code>stderr</code>引用的都是终端，则读<code>stdin</code>时会隐式调用 <code>fflush(stdout)</code>，这会刷新写入<code>stdout</code>的所有结尾不带有换行符的提示信息 (例如，<code>printf("Data: ")</code>)。SUSv3和C99没有说明该行为，并且只有部分C库实现了该行为。对于可移植应用程序，应该显式地调用<code>fflush(stdout)</code>来保证这类提示信息会显示。</p><p>　　C99对同时用于输入和输出的流提出了2个要求。首先，输出操作之后不能是输入操作，两者之间必须要调用<code>fflush()</code>和文件定位函数 (<code>fseek()</code>、<code>fsetpos()</code>和<code>rewind()</code>)。其次，输入操作之后不能是输出操作，两者之间必须要调用文件定位函数，除非输出操作遇到了EOF。</p><h3 id="控制文件io的内核缓冲">13.3 控制文件I/O的内核缓冲</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>; <span class="comment">/* 成功时返回0，出错时返回-1 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>　　系统调用<code>fsync()</code>会导致缓冲的数据和与参数<code>fd</code>指定的文件描述符关联的所有元数据都刷新到磁盘。调用<code>fsync()</code>会强制文件进入同步I/O文件完整性完成状态。<code>fsync()</code>只会在数据和元数据都传输到磁盘 (至少传输到磁盘缓存) 后才会返回。</p><p>　　系统调用<code>fdatasync()</code>与<code>fsync()</code>类似，但只强制文件进入同步I/O数据完整性完成状态。</p><p>　　调用<code>fdatasync()</code>可能会将磁盘操作从<code>fsync()</code>所需的2个减少到1个 (例如，若仅修改了文件数据，而没有修改文件大小，则调用<code>fdatasync()</code>只会强制更新数据。相比之下，调用<code>fsync()</code>还会强制更新元数据)。对于侧重性能 (不侧重某些元数据的准确性) 的应用程序，这很有用。此外，对于更新多个文件的应用程序，这会可能会显著提升性能，因为文件数据和元数据通常存储在磁盘的不同部分 (更新它们需要重复地来回寻道)。对于Linux 2.2及以下版本，<code>fdatasync()</code>被实现为对<code>fsync()</code>的调用，所以没有性能提升。</p><p>　　从内核2.6.17开始，Linux提供了非标准的系统调用<code>sync_file_range()</code>，在刷新文件数据时，它允许比<code>fdatasync()</code>更精确的控制，并且还能指定标志来控制是否允许该系统调用阻塞在对磁盘的写操作上。</p><p>　　系统调用<code>sync()</code>会导致所有包含更新后的文件信息的内核缓冲区 (例如，数据块、指针块和元数据) 刷新到磁盘。对于Linux实现，<code>sync()</code>只会在所有数据都传输到磁盘 (至少传输到磁盘缓存) 后才会返回。但是，SUSv3允许<code>sync()</code>实现简单地调度I/O传输，然后在其完成之前返回。</p><p>　　若修改后的内核缓冲区在30秒内没有显式同步，则1个永久运行的内核线程 (对于Linux 2.4，它是<code>kupdated</code>；对于Linux 2.6，它是<code>pdflush</code>) 会保证修改后的内核缓冲区刷新到磁盘。这是为了保证缓冲区不会长期未与对应的磁盘文件同步 (导致系统崩溃时更容易丢失该缓冲区)。</p><p>　　文件<code>/proc/sys/vm/dirty_expire_centisecs</code>指定了脏缓冲区在被<code>pdflush</code>刷新之前的最短存在时间 (以百分之一秒为单位)。同一目录下的其他文件控制着<code>pdflush</code>的其他方面。</p><h4 id="标志o_sync">13.3.1 标志<code>O_SYNC</code></h4><p>　　若调用<code>open()</code>时指定了打开文件状态标志<code>O_SYNC</code>，则会<span style="background-color:#ff0">同步</span>后续的所有输出，即后续的所有对<code>write()</code>的调用会自动将文件数据和元数据刷新到磁盘 (按照同步I/O文件完整性完成的要求)。</p><p>　　早期BSD系统使用标志<code>O_FSYNC</code>来提供<code>O_SYNC</code>的功能。对于glibc，<code>O_FSYNC</code>等同于<code>O_SYNC</code>。</p><p>　　以下是在<code>write_bytes.c</code>使用不同的<code>BUF_SIZE</code>值在使用vanilla 2.6.30内核和块大小是4096字节的ext2文件系统的Linux上写1亿字节到新创建的文件所需的时间 (运行20次的平均值)：</p><table><colgroup><col style="width:8%"><col style="width:22%"><col style="width:25%"><col style="width:20%"><col style="width:23%"></colgroup><thead><tr><th><code>BUF_SIZE</code></th><th>不指定<code>O_SYNC</code>的总耗时 (秒)</th><th>不指定<code>O_SYNC</code>的总CPU时间 (秒)</th><th>指定<code>O_SYNC</code>的总耗时 (秒)</th><th>指定<code>O_SYNC</code>的总CPU时间 (秒)</th></tr></thead><tbody><tr><td>1</td><td>0.73</td><td>0.73</td><td>1030</td><td>98.8</td></tr><tr><td>16</td><td>0.05</td><td>0.05</td><td>65.0</td><td>0.40</td></tr><tr><td>256</td><td>0.02</td><td>0.02</td><td>4.07</td><td>0.03</td></tr><tr><td>4096</td><td>0.01</td><td>0.01</td><td>0.34</td><td>0.03</td></tr></tbody></table><p>　　从上表可以看出，指定标志<code>O_SYNC</code>后，总耗时会显著增加。当<code>BUF_SIZE</code>为1时，总耗时大于1000秒。此外，总耗时和总CPU时间存在很大差异，因为程序阻塞在缓冲区传输数据到磁盘。这个测试忽略了1个影响程序性能的重要因素——磁盘缓存。现代磁盘驱动都拥有较大的外部缓存，在默认情况下，<code>O_SYNC</code>只会导致数据传输到缓存。</p><p>　　综上所述，为了强制刷新内核缓冲区，应该考虑使用较大的<code>write()</code>缓冲区或 (谨慎地) 使用<code>fsync()</code>或<code>fdatasnyc()</code> (而非使用标志<code>O_SYNC</code>)。</p><h4 id="标志o_dsync和o_rsync">13.3.2 标志<code>O_DSYNC</code>和<code>O_RSYNC</code></h4><p>　　SUSv3还提供了2个与同步I/O相关的打开文件状态标志：<code>O_DSYNC</code>和<code>O_RSYNC</code>。</p><p>　　● <code>O_DSYNC</code>会导致写操作按照同步I/O数据完整性完成的要求执行 (类似<code>fdatasync()</code>)。</p><p>　　● <code>O_RSYNC</code>与<code>O_SYNC</code>或<code>O_DSYNC</code>一起使用，会将这些标志的写操作的行为扩展到读操作。因此，当同时使用这些标志时，读操作也会按照同步I/O文件完整性完成或同步I/O数据完整性完成的要求执行 (即在执行读操作之前，所有待处理的写操作都会按照同步I/O文件完整性完成或同步I/O数据完整性完成的要求执行)。</p><p>　　在内核2.6.33之前，Linux没有实现这2个标志，并且glibc将这2个标志定义为标志<code>O_SYNC</code>的值。此外，Linux没有完全实现标志<code>O_SYNC</code>的语义，相反，标志<code>O_SYNC</code>被实现为标志<code>O_DSYNC</code>。为了兼容较旧的内核版本，应用程序应该链接旧版本的glibc。从内核2.6.33开始，Linux实现了标志<code>O_DSYNC</code>。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_12/" rel="prev" title="《Linux&#x2F;UNIX系统编程手册》第12章 系统和进程信息"><i class="fa fa-angle-left"></i> 《Linux/UNIX系统编程手册》第12章 系统和进程信息</a></div><div class="post-nav-item"><a href="/linux/the_linux_programming_interface_a_linux_and_unix_system_programming_handbook_chpt_14/" rel="next" title="《Linux&#x2F;UNIX系统编程手册》第14章 文件系统">《Linux/UNIX系统编程手册》第14章 文件系统 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript></body></html>